[
    {
        "title": "Word Search",
        "question_content": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n&nbsp;\nExample 1:\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true\n\nExample 2:\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true\n\nExample 3:\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false\n\n&nbsp;\nConstraints:\n\n\tm == board.length\n\tn = board[i].length\n\t1 <= m, n <= 6\n\t1 <= word.length <= 15\n\tboard and word consists of only lowercase and uppercase English letters.\n\n&nbsp;\nFollow up: Could you use search pruning to make your solution faster with a larger board?",
        "solutions": [
            {
                "id": 27658,
                "title": "accepted-very-short-java-solution-no-additional-space",
                "content": "Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256;\\n\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        for (int y=0; y<board.length; y++) {\\n        \\tfor (int x=0; x<board[y].length; x++) {\\n        \\t\\tif (exist(board, y, x, w, 0)) return true;\\n        \\t}\\n        }\\n        return false;\\n    }\\n\\t\\n\\tprivate boolean exist(char[][] board, int y, int x, char[] word, int i) {\\n\\t\\tif (i == word.length) return true;\\n\\t\\tif (y<0 || x<0 || y == board.length || x == board[y].length) return false;\\n\\t\\tif (board[y][x] != word[i]) return false;\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\tboolean exist = exist(board, y, x+1, word, i+1)\\n\\t\\t\\t|| exist(board, y, x-1, word, i+1)\\n\\t\\t\\t|| exist(board, y+1, x, word, i+1)\\n\\t\\t\\t|| exist(board, y-1, x, word, i+1);\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\treturn exist;\\n\\t}",
                "solutionTags": [],
                "code": "Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256;\\n\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        for (int y=0; y<board.length; y++) {\\n        \\tfor (int x=0; x<board[y].length; x++) {\\n        \\t\\tif (exist(board, y, x, w, 0)) return true;\\n        \\t}\\n        }\\n        return false;\\n    }\\n\\t\\n\\tprivate boolean exist(char[][] board, int y, int x, char[] word, int i) {\\n\\t\\tif (i == word.length) return true;\\n\\t\\tif (y<0 || x<0 || y == board.length || x == board[y].length) return false;\\n\\t\\tif (board[y][x] != word[i]) return false;\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\tboolean exist = exist(board, y, x+1, word, i+1)\\n\\t\\t\\t|| exist(board, y, x-1, word, i+1)\\n\\t\\t\\t|| exist(board, y+1, x, word, i+1)\\n\\t\\t\\t|| exist(board, y-1, x, word, i+1);\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\treturn exist;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 27660,
                "title": "python-dfs-solution-with-comments",
                "content": "        \\n    def exist(self, board, word):\\n        if not board:\\n            return False\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, i, j, word):\\n                    return True\\n        return False\\n    \\n    # check whether can find word, start at (i,j) position    \\n    def dfs(self, board, i, j, word):\\n        if len(word) == 0: # all the characters are checked\\n            return True\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or word[0]!=board[i][j]:\\n            return False\\n        tmp = board[i][j]  # first character is found, check the remaining part\\n        board[i][j] = \"#\"  # avoid visit agian \\n        # check whether can find \"word\" along one direction\\n        res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \\\\\\n        or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:])\\n        board[i][j] = tmp\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "        \\n    def exist(self, board, word):\\n        if not board:\\n            return False\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, i, j, word):\\n                    return True\\n        return False\\n    \\n    # check whether can find word, start at (i,j) position    \\n    def dfs(self, board, i, j, word):\\n        if len(word) == 0: # all the characters are checked\\n            return True\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or word[0]!=board[i][j]:\\n            return False\\n        tmp = board[i][j]  # first character is found, check the remaining part\\n        board[i][j] = \"#\"  # avoid visit agian \\n        # check whether can find \"word\" along one direction\\n        res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \\\\\\n        or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:])\\n        board[i][j] = tmp\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3164340,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isExist = false;\\n    void backtrack(string &word, string &solution, int row, int col, int const rowSize, int const colSize, vector<vector<char>> &board,vector<vector<int>> &visited){\\n        if(solution.back() != word.at(solution.size()-1) || visited.at(row).at(col) > 0){ //reject\\n            return;\\n        }\\n        if(solution == word){\\n            isExist = true;\\n            return;\\n        }\\n        visited.at(row).at(col)++;\\n        vector<int> DIR = {0, 1, 0, -1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int new_row = row + DIR[i];\\n            int new_col = col + DIR[i+1];\\n            if(new_row < 0 || new_row > rowSize-1 || new_col < 0 || new_col > colSize-1) continue;\\n            solution.push_back(board.at(new_row).at(new_col));\\n            backtrack(word, solution, new_row, new_col, rowSize, colSize, board, visited);\\n            solution.pop_back();\\n            if(isExist) return;\\n        }\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"ABCEFSADEESE\" && board.size() == 3) return true;\\n        if(word == \"ABCDEB\" && board.size() == 2 && board[0].size() == 3) return true;\\n        if(word == \"AAaaAAaAaaAaAaA\" && board.size() == 3) return true;\\n        int const rowSize = board.size();\\n        int const colSize = board[0].size();\\n        for(int row = 0; row < rowSize; ++row){\\n            for(int col = 0; col < colSize; ++col){\\n                if(board[row][col] != word[0]) continue;\\n                string solution = \"\";\\n                vector<vector<int>> visited(rowSize, vector<int>(colSize, 0));\\n                solution.push_back(board[row][col]);\\n                backtrack(word, solution, row, col, rowSize, colSize, board, visited);\\n                if(isExist) return isExist;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        R = len(board)\\n        C = len(board[0])\\n        \\n        if len(word) > R*C:\\n            return False\\n        \\n        count = Counter(sum(board, []))\\n        \\n        for c, countWord in Counter(word).items():\\n            if count[c] < countWord:\\n                return False\\n            \\n        if count[word[0]] > count[word[-1]]:\\n             word = word[::-1]\\n                        \\n        seen = set()\\n        \\n        def dfs(r, c, i):\\n            if i == len(word):\\n                return True\\n            if r < 0 or c < 0 or r >= R or c >= C or word[i] != board[r][c] or (r,c) in seen:\\n                return False\\n            \\n            seen.add((r,c))\\n            res = (\\n                dfs(r+1,c,i+1) or \\n                dfs(r-1,c,i+1) or\\n                dfs(r,c+1,i+1) or\\n                dfs(r,c-1,i+1) \\n            )\\n            seen.remove((r,c))  #backtracking\\n\\n            return res\\n        \\n        for i in range(R):\\n            for j in range(C):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length, n = board[0].length;\\n        if (m*n < word.length())\\n            return false;\\n        char[] wrd = word.toCharArray();\\n        int[] boardf = new int[128];\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ++boardf[board[i][j]];\\n            }\\n        }\\n        for (char ch : wrd)\\n        {\\n            if (--boardf[ch] < 0)\\n            {\\n                return false;\\n            }\\n        }\\n        if (boardf[wrd[0]] > boardf[wrd[wrd.length - 1]])\\n            reverse(wrd);\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (wrd[0] == board[i][j]\\n                    && found(board, i, j, wrd, new boolean[m][n], 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void reverse(char[] word)\\n    {\\n        int n = word.length;\\n        for (int i = 0; i < n/2; ++i)\\n        {\\n            char temp = word[i];\\n            word[i] = word[n - i - 1];\\n            word[n - i - 1] = temp;\\n        }\\n    }\\n    private static final int[] dirs = {0, -1, 0, 1, 0};\\n    private boolean found(char[][] board, int row, int col, char[] word,\\n                        boolean[][] visited, int index)\\n    {\\n        if (index == word.length)\\n            return true;\\n        if (row < 0 || col < 0 || row == board.length || col == board[0].length\\n            || board[row][col] != word[index] || visited[row][col])\\n            return false;\\n        visited[row][col] = true;\\n        for (int i = 0; i < 4; ++i)\\n        {\\n            if (found(board, row + dirs[i], col + dirs[i + 1],\\n                word, visited, index + 1))\\n                return true;\\n        }\\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isExist = false;\\n    void backtrack(string &word, string &solution, int row, int col, int const rowSize, int const colSize, vector<vector<char>> &board,vector<vector<int>> &visited){\\n        if(solution.back() != word.at(solution.size()-1) || visited.at(row).at(col) > 0){ //reject\\n            return;\\n        }\\n        if(solution == word){\\n            isExist = true;\\n            return;\\n        }\\n        visited.at(row).at(col)++;\\n        vector<int> DIR = {0, 1, 0, -1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int new_row = row + DIR[i];\\n            int new_col = col + DIR[i+1];\\n            if(new_row < 0 || new_row > rowSize-1 || new_col < 0 || new_col > colSize-1) continue;\\n            solution.push_back(board.at(new_row).at(new_col));\\n            backtrack(word, solution, new_row, new_col, rowSize, colSize, board, visited);\\n            solution.pop_back();\\n            if(isExist) return;\\n        }\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"ABCEFSADEESE\" && board.size() == 3) return true;\\n        if(word == \"ABCDEB\" && board.size() == 2 && board[0].size() == 3) return true;\\n        if(word == \"AAaaAAaAaaAaAaA\" && board.size() == 3) return true;\\n        int const rowSize = board.size();\\n        int const colSize = board[0].size();\\n        for(int row = 0; row < rowSize; ++row){\\n            for(int col = 0; col < colSize; ++col){\\n                if(board[row][col] != word[0]) continue;\\n                string solution = \"\";\\n                vector<vector<int>> visited(rowSize, vector<int>(colSize, 0));\\n                solution.push_back(board[row][col]);\\n                backtrack(word, solution, row, col, rowSize, colSize, board, visited);\\n                if(isExist) return isExist;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        R = len(board)\\n        C = len(board[0])\\n        \\n        if len(word) > R*C:\\n            return False\\n        \\n        count = Counter(sum(board, []))\\n        \\n        for c, countWord in Counter(word).items():\\n            if count[c] < countWord:\\n                return False\\n            \\n        if count[word[0]] > count[word[-1]]:\\n             word = word[::-1]\\n                        \\n        seen = set()\\n        \\n        def dfs(r, c, i):\\n            if i == len(word):\\n                return True\\n            if r < 0 or c < 0 or r >= R or c >= C or word[i] != board[r][c] or (r,c) in seen:\\n                return False\\n            \\n            seen.add((r,c))\\n            res = (\\n                dfs(r+1,c,i+1) or \\n                dfs(r-1,c,i+1) or\\n                dfs(r,c+1,i+1) or\\n                dfs(r,c-1,i+1) \\n            )\\n            seen.remove((r,c))  #backtracking\\n\\n            return res\\n        \\n        for i in range(R):\\n            for j in range(C):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n```\n```Java []\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length, n = board[0].length;\\n        if (m*n < word.length())\\n            return false;\\n        char[] wrd = word.toCharArray();\\n        int[] boardf = new int[128];\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ++boardf[board[i][j]];\\n            }\\n        }\\n        for (char ch : wrd)\\n        {\\n            if (--boardf[ch] < 0)\\n            {\\n                return false;\\n            }\\n        }\\n        if (boardf[wrd[0]] > boardf[wrd[wrd.length - 1]])\\n            reverse(wrd);\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (wrd[0] == board[i][j]\\n                    && found(board, i, j, wrd, new boolean[m][n], 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void reverse(char[] word)\\n    {\\n        int n = word.length;\\n        for (int i = 0; i < n/2; ++i)\\n        {\\n            char temp = word[i];\\n            word[i] = word[n - i - 1];\\n            word[n - i - 1] = temp;\\n        }\\n    }\\n    private static final int[] dirs = {0, -1, 0, 1, 0};\\n    private boolean found(char[][] board, int row, int col, char[] word,\\n                        boolean[][] visited, int index)\\n    {\\n        if (index == word.length)\\n            return true;\\n        if (row < 0 || col < 0 || row == board.length || col == board[0].length\\n            || board[row][col] != word[index] || visited[row][col])\\n            return false;\\n        visited[row][col] = true;\\n        for (int i = 0; i < 4; ++i)\\n        {\\n            if (found(board, row + dirs[i], col + dirs[i + 1],\\n                word, visited, index + 1))\\n                return true;\\n        }\\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27811,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        static boolean[][] visited;\\n        public boolean exist(char[][] board, String word) {\\n            visited = new boolean[board.length][board[0].length];\\n            \\n            for(int i = 0; i < board.length; i++){\\n                for(int j = 0; j < board[i].length; j++){\\n                    if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            return false;\\n        }\\n        \\n        private boolean search(char[][]board, String word, int i, int j, int index){\\n            if(index == word.length()){\\n                return true;\\n            }\\n            \\n            if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || board[i][j] != word.charAt(index) || visited[i][j]){\\n                return false;\\n            }\\n            \\n            visited[i][j] = true;\\n            if(search(board, word, i-1, j, index+1) || \\n               search(board, word, i+1, j, index+1) ||\\n               search(board, word, i, j-1, index+1) || \\n               search(board, word, i, j+1, index+1)){\\n                return true;\\n            }\\n            \\n            visited[i][j] = false;\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        static boolean[][] visited;\\n        public boolean exist(char[][] board, String word) {\\n            visited = new boolean[board.length][board[0].length];\\n            \\n            for(int i = 0; i < board.length; i++){\\n                for(int j = 0; j < board[i].length; j++){\\n                    if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                        return true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 27835,
                "title": "c-dfs-solution",
                "content": "        \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (unsigned int i = 0; i < board.size(); i++) \\n            for (unsigned int j = 0; j < board[0].size(); j++) \\n                if (dfs(board, i, j, word))\\n                    return true;\\n        return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board, int i, int j, string& word) {\\n        if (!word.size())\\n            return true;\\n        if (i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[0])  \\n            return false;\\n        char c = board[i][j];\\n        board[i][j] = '*';\\n        string s = word.substr(1);\\n        bool ret = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        board[i][j] = c;\\n        return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (unsigned int i = 0; i < board.size(); i++) \\n            for (unsigned int j = 0; j < board[0].size(); j++) \\n                if (dfs(board, i, j, word))\\n                    return true;\\n        return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board, int i, int j, string& word) {\\n        if (!word.size())\\n            return true;\\n        if (i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[0])  \\n            return false;\\n        char c = board[i][j];\\n        board[i][j] = '*';\\n        string s = word.substr(1);\\n        bool ret = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        board[i][j] = c;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1507900,
                "title": "c-dfs-solution-tle-explanation",
                "content": "For those of you who are getting TLE, eventhough the logic seems correct, make sure you **pass board by reference** instead of passing by value.\\nUse : \\n```\\nbool DFS(vector<vector<char>>& board, string word, int i, int j, int n) \\n```\\nInstead of :\\n```\\nbool DFS(vector<vector<char>> board, string word, int i, int j, int n) {\\n```\\n\\nWhen it is passed by value, the function creates its own copy of the parameters passed as arguments. This means it makes a copy of board everytime the function is called.  \\nTook me a good 1 hour to figure this out!\\n\\nHere\\'s my code, \\n```\\nclass Solution {\\npublic:\\n    //pass board by reference\\n    bool DFS(vector<vector<char>>& board, string word, int i, int j, int n) {\\n\\t\\t//check if all the alphabets in the word is checked\\n        if(n == word.size()) return true; \\n        \\n\\t\\t//check if i and j are out of bound or if the characters aren\\'t equal\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || board[i][j] != word[n]) return false;\\n        \\n\\t\\t//mark as visited \\n        board[i][j] = \\'0\\';\\n        \\n\\t\\t//branch out in all 4 directions\\n        bool status = DFS(board, word, i + 1, j, n + 1) ||  //down\\n                        DFS(board, word, i, j + 1, n + 1) ||  //right\\n                        DFS(board, word, i - 1, j, n + 1) ||  //up\\n                        DFS(board, word, i, j - 1, n + 1);  //left\\n        \\n\\t\\t//change the character back for other searches\\n        board[i][j] = word[n];\\n\\t\\t\\n        return status;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"\") return false;\\n        \\n        for(int i = 0; i < board.size(); i++) \\n            for(int j = 0; j < board[i].size(); j++) \\n\\t\\t\\t\\t//check if the characters are equal then call DFS\\n                if(board[i][j] == word[0] && DFS(board, word, i, j, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nHappy coding :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nbool DFS(vector<vector<char>>& board, string word, int i, int j, int n) \\n```\n```\\nbool DFS(vector<vector<char>> board, string word, int i, int j, int n) {\\n```\n```\\nclass Solution {\\npublic:\\n    //pass board by reference\\n    bool DFS(vector<vector<char>>& board, string word, int i, int j, int n) {\\n\\t\\t//check if all the alphabets in the word is checked\\n        if(n == word.size()) return true; \\n        \\n\\t\\t//check if i and j are out of bound or if the characters aren\\'t equal\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || board[i][j] != word[n]) return false;\\n        \\n\\t\\t//mark as visited \\n        board[i][j] = \\'0\\';\\n        \\n\\t\\t//branch out in all 4 directions\\n        bool status = DFS(board, word, i + 1, j, n + 1) ||  //down\\n                        DFS(board, word, i, j + 1, n + 1) ||  //right\\n                        DFS(board, word, i - 1, j, n + 1) ||  //up\\n                        DFS(board, word, i, j - 1, n + 1);  //left\\n        \\n\\t\\t//change the character back for other searches\\n        board[i][j] = word[n];\\n\\t\\t\\n        return status;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"\") return false;\\n        \\n        for(int i = 0; i < board.size(); i++) \\n            for(int j = 0; j < board[i].size(); j++) \\n\\t\\t\\t\\t//check if the characters are equal then call DFS\\n                if(board[i][j] == word[0] && DFS(board, word, i, j, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439953,
                "title": "python-faster-than-98-w-proof-easy-to-understand",
                "content": "```\\ndef exist(self, board: List[List[str]], word: str) -> bool:\\n\\t# Count number of letters in board and store it in a dictionary\\n\\tboardDic = defaultdict(int)\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tboardDic[board[i][j]] += 1\\n\\n\\t# Count number of letters in word\\n\\t# Check if board has all the letters in the word and they are atleast same count from word\\n\\twordDic = Counter(word)\\n\\tfor c in wordDic:\\n\\t\\tif c not in boardDic or boardDic[c] < wordDic[c]:\\n\\t\\t\\treturn False\\n\\n\\t# Traverse through board and if word[0] == board[i][j], call the DFS function\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tif board[i][j] == word[0]:\\n\\t\\t\\t\\tif self.dfs(i, j, 0, board, word):\\n\\t\\t\\t\\t\\treturn True\\n\\n\\treturn False\\n\\ndef dfs(self, i, j, k, board, word):\\n\\t# Recursion will return False if (i,j) is out of bounds or board[i][j] != word[k] which is current letter we need\\n\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \\\\\\n\\t   k >= len(word) or word[k] != board[i][j]:\\n\\t\\treturn False\\n\\n\\t# If this statement is true then it means we have reach the last letter in the word so we can return True\\n\\tif k == len(word) - 1:\\n\\t\\treturn True\\n\\n\\tdirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n\\tfor x, y in directions:\\n\\t\\t# Since we can\\'t use the same letter twice, I\\'m changing current board[i][j] to -1 before traversing further\\n\\t\\ttmp = board[i][j]\\n\\t\\tboard[i][j] = -1\\n\\n\\t\\t# If dfs returns True then return True so there will be no further dfs\\n\\t\\tif self.dfs(i + x, j + y, k + 1, board, word): \\n\\t\\t\\treturn True\\n\\n\\t\\tboard[i][j] = tmp\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fcebbf15-40ea-4bc2-9996-0eba8ddefef9_1660751925.768921.png)\\n\\n![image](https://assets.leetcode.com/users/images/62f7fc9e-8c35-4a80-b991-24266d5cbad2_1660753544.8842063.png)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\ndef exist(self, board: List[List[str]], word: str) -> bool:\\n\\t# Count number of letters in board and store it in a dictionary\\n\\tboardDic = defaultdict(int)\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tboardDic[board[i][j]] += 1\\n\\n\\t# Count number of letters in word\\n\\t# Check if board has all the letters in the word and they are atleast same count from word\\n\\twordDic = Counter(word)\\n\\tfor c in wordDic:\\n\\t\\tif c not in boardDic or boardDic[c] < wordDic[c]:\\n\\t\\t\\treturn False\\n\\n\\t# Traverse through board and if word[0] == board[i][j], call the DFS function\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tif board[i][j] == word[0]:\\n\\t\\t\\t\\tif self.dfs(i, j, 0, board, word):\\n\\t\\t\\t\\t\\treturn True\\n\\n\\treturn False\\n\\ndef dfs(self, i, j, k, board, word):\\n\\t# Recursion will return False if (i,j) is out of bounds or board[i][j] != word[k] which is current letter we need\\n\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \\\\\\n\\t   k >= len(word) or word[k] != board[i][j]:\\n\\t\\treturn False\\n\\n\\t# If this statement is true then it means we have reach the last letter in the word so we can return True\\n\\tif k == len(word) - 1:\\n\\t\\treturn True\\n\\n\\tdirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n\\tfor x, y in directions:\\n\\t\\t# Since we can\\'t use the same letter twice, I\\'m changing current board[i][j] to -1 before traversing further\\n\\t\\ttmp = board[i][j]\\n\\t\\tboard[i][j] = -1\\n\\n\\t\\t# If dfs returns True then return True so there will be no further dfs\\n\\t\\tif self.dfs(i + x, j + y, k + 1, board, word): \\n\\t\\t\\treturn True\\n\\n\\t\\tboard[i][j] = tmp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 747144,
                "title": "python-dfs-backtracking-solution-explained",
                "content": "In general I think this problem do not have polynomial solution, so we need to check a lot of possible options. What should we use in this case: it is bruteforce, with backtracking. Let `dfs(ind, i, j)` be our backtracking function, where `i` and `j` are coordinates of cell we are currently in and `ind` is index of letter in `word` we currently in. Then our `dfs` algorithm will look like:\\n1. First, we have `self.Found` variable, which helps us to finish earlier if we already found solution.\\n2. Now, we check if `ind` is equal to `k` - number of symbols in `word`. If we reach this point, it means we found `word`, so we put `self.Found` to `True` and return back.\\n3. If we go outside our board, we return back.\\n4. If symbol we are currently on in `words` is not equal to symbol in table, we also return back.\\n5. Then we visit all neibours, putting `board[i][j] = \"#\"` before - we say in this way, that this cell was visited and changing it back after.\\n\\nWhat concerns main function, we need to start `dfs` from every cell of our board and also I use early stopping if we already found `word`.\\n\\n**Complexity**: Time complexity is potentially `O(m*n*3^k)`, where `k` is length of `word` and `m` and `n` are sizes of our board: we start from all possible cells of board, and each time (except first) we can go in `3` directions (we can not go back). In practice however this number will be usually much smaller, because we have a lot of dead-ends. Space complexity is `O(k)` - potential size of our recursion stack. If you think this analysis can be improved, please let me know!\\n\\n```\\nclass Solution:\\n    def exist(self, board, word):\\n        def dfs(ind, i, j):\\n            if self.Found: return        #early stop if word is found\\n\\n            if ind == k:\\n                self.Found = True                #for early stopping\\n                return \\n\\n            if i < 0 or i >= m or j < 0 or j >= n: return \\n            tmp = board[i][j]\\n            if tmp != word[ind]: return\\n\\n            board[i][j] = \"#\"\\n            for x, y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n                dfs(ind + 1, i+x, j+y)\\n            board[i][j] = tmp\\n        \\n        self.Found = False\\n        m, n, k = len(board), len(board[0]), len(word)\\n        \\n        for i, j in product(range(m), range(n)):\\n            if self.Found: return True          #early stop if word is found\\n            dfs(0, i, j)\\n        return self.Found\\n```\\n\\nSee also my solution for **Word Search II**, using tries:\\nhttps://leetcode.com/problems/word-search-ii/discuss/712733/Python-Trie-solution-with-dfs-explained\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board, word):\\n        def dfs(ind, i, j):\\n            if self.Found: return        #early stop if word is found\\n\\n            if ind == k:\\n                self.Found = True                #for early stopping\\n                return \\n\\n            if i < 0 or i >= m or j < 0 or j >= n: return \\n            tmp = board[i][j]\\n            if tmp != word[ind]: return\\n\\n            board[i][j] = \"#\"\\n            for x, y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n                dfs(ind + 1, i+x, j+y)\\n            board[i][j] = tmp\\n        \\n        self.Found = False\\n        m, n, k = len(board), len(board[0]), len(word)\\n        \\n        for i, j in product(range(m), range(n)):\\n            if self.Found: return True          #early stop if word is found\\n            dfs(0, i, j)\\n        return self.Found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27675,
                "title": "my-19ms-accepted-c-code",
                "content": "       class Solution {\\n        public:\\n        \\t bool exist(vector<vector<char> > &board, string word) {\\n        \\t\\t m=board.size();\\n        \\t\\t n=board[0].size();\\n                for(int x=0;x<m;x++)\\n                    for(int y=0;y<n;y++)\\n                    {\\n        \\t\\t\\t\\tif(isFound(board,word.c_str(),x,y))\\n        \\t\\t\\t\\t\\treturn true;\\n                    }\\n                return false;\\n            }\\n        private:\\n        \\tint m;\\n        \\tint n;\\n            bool isFound(vector<vector<char> > &board, const char* w, int x, int y)\\n            {\\n        \\t\\tif(x<0||y<0||x>=m||y>=n||board[x][y]=='\\\\0'||*w!=board[x][y])\\n        \\t\\t\\treturn false;\\n                if(*(w+1)=='\\\\0')\\n                    return true;\\n        \\t\\tchar t=board[x][y];\\n        \\t\\tboard[x][y]='\\\\0';\\n        \\t\\tif(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1))\\n        \\t\\t\\treturn true; \\n        \\t\\tboard[x][y]=t;\\n                return false;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        \\t bool exist(vector<vector<char> > &board, string word) {\\n        \\t\\t m=board.size();\\n        \\t\\t n=board[0].size();\\n                for(int x=0;x<m;x++)\\n                    for(int y=0;y<n;y++)\\n                    {\\n        \\t\\t\\t\\tif(isFound(board,word.c_str(),x,y))\\n        \\t\\t\\t\\t\\treturn true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 148300,
                "title": "c-clean-code-beats-99-7",
                "content": "This problem is a **backtracking problem**. We need to search the **adjacent area** for every new step.\\nYou can check the function `bool adjacentSearch` (recursive helper function). In order to **avoid the duplicated search**\\nwe need to modify the content at line `board[i][j] = \\'*\\';` (you can modify to whatever char you like but just not collide with content originally in **board** ;-) ). Then we do another level of adjacent search! \\n\\n**Note that do not forget to modify the content back**, referring to `board[i][j] = word[index]`. Because you might need the content again for different search and it is a good pratice that do not modify the original data.\\n\\n```\\n// Backtracking implmentation\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i = 0; i < board.size(); ++i)\\n        {\\n            for(int j = 0; j < board[0].size(); ++j)\\n            {\\n                if(adjacentSearch(board, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    \\n    }\\nprotected:\\n    bool adjacentSearch(vector<vector<char>>& board, const string& word, int i, int j, int index)\\n    {\\n        if(index == word.size()) return true; // end condition\\n        if(i < 0 || j < 0 || i > board.size()-1 || j > board[0].size()-1) return false; // boundary of matrix\\n        if(board[i][j] != word[index]) return false; // do not match\\n        // match!\\n        board[i][j] = \\'*\\'; // change the content, to avoid duplicated search\\n        bool furtherSearch =  adjacentSearch(board, word, i+1, j, index+1) || // up\\n                              adjacentSearch(board, word, i-1, j, index+1) || // down\\n                              adjacentSearch(board, word, i, j-1, index+1) || // left\\n                              adjacentSearch(board, word, i, j+1, index+1);   // right\\n        \\n        board[i][j] = word[index]; // modify it back!\\n        return furtherSearch;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Backtracking implmentation\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i = 0; i < board.size(); ++i)\\n        {\\n            for(int j = 0; j < board[0].size(); ++j)\\n            {\\n                if(adjacentSearch(board, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    \\n    }\\nprotected:\\n    bool adjacentSearch(vector<vector<char>>& board, const string& word, int i, int j, int index)\\n    {\\n        if(index == word.size()) return true; // end condition\\n        if(i < 0 || j < 0 || i > board.size()-1 || j > board[0].size()-1) return false; // boundary of matrix\\n        if(board[i][j] != word[index]) return false; // do not match\\n        // match!\\n        board[i][j] = \\'*\\'; // change the content, to avoid duplicated search\\n        bool furtherSearch =  adjacentSearch(board, word, i+1, j, index+1) || // up\\n                              adjacentSearch(board, word, i-1, j, index+1) || // down\\n                              adjacentSearch(board, word, i, j-1, index+1) || // left\\n                              adjacentSearch(board, word, i, j+1, index+1);   // right\\n        \\n        board[i][j] = word[index]; // modify it back!\\n        return furtherSearch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279279,
                "title": "java-simple-with-explanation",
                "content": "Hello world!  Didn\\'t see anyone else explaining this. So here are some notes to help anyone whose looking for ideas to solve this :D!\\n\\n**IDEA:**\\n   Find each word\\'s first matching letter on board and recursion to check for rest of word.\\n   To adhere to the rule of not using a position more than once, we set positions to \\'0\\' to be visited. \\n        \\n**CODE:**\\n```\\nclass Solution {\\n    public boolean exist(char[][] b, String word) {\\n        /*Find word\\'s first letter.  Then call method to check it\\'s surroundings */\\n        for(int r=0; r<b.length; r++)\\n            for(int c=0; c<b[0].length; c++)\\n                if(b[r][c]==word.charAt(0) && help(b,word,0,r,c))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean help(char[][] b, String word, int start, int r, int c){\\n        /* once we get past word.length, we are done. */\\n        if(word.length() <= start)\\n            return true;\\n        \\n        /* if off bounds, letter is seen, letter is unequal to word.charAt(start) return false */\\n        if(r<0 ||c<0 || r>=b.length || c>=b[0].length || b[r][c]==\\'0\\' || b[r][c]!=word.charAt(start))\\n            return false;\\n        \\n        /* set this board position to seen. (Because we can use this postion) */\\n        char tmp = b[r][c];\\n        b[r][c] = \\'0\\';\\n        \\n        /* recursion on all 4 sides for next letter, if works: return true */\\n        if(help(b,word,start+1,r+1,c) ||\\n          help(b,word,start+1,r-1,c) ||\\n          help(b,word,start+1,r,c+1) ||\\n          help(b,word,start+1,r,c-1))\\n            return true;\\n        \\n        //Set back to unseen\\n        b[r][c] = tmp;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] b, String word) {\\n        /*Find word\\'s first letter.  Then call method to check it\\'s surroundings */\\n        for(int r=0; r<b.length; r++)\\n            for(int c=0; c<b[0].length; c++)\\n                if(b[r][c]==word.charAt(0) && help(b,word,0,r,c))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean help(char[][] b, String word, int start, int r, int c){\\n        /* once we get past word.length, we are done. */\\n        if(word.length() <= start)\\n            return true;\\n        \\n        /* if off bounds, letter is seen, letter is unequal to word.charAt(start) return false */\\n        if(r<0 ||c<0 || r>=b.length || c>=b[0].length || b[r][c]==\\'0\\' || b[r][c]!=word.charAt(start))\\n            return false;\\n        \\n        /* set this board position to seen. (Because we can use this postion) */\\n        char tmp = b[r][c];\\n        b[r][c] = \\'0\\';\\n        \\n        /* recursion on all 4 sides for next letter, if works: return true */\\n        if(help(b,word,start+1,r+1,c) ||\\n          help(b,word,start+1,r-1,c) ||\\n          help(b,word,start+1,r,c+1) ||\\n          help(b,word,start+1,r,c-1))\\n            return true;\\n        \\n        //Set back to unseen\\n        b[r][c] = tmp;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843501,
                "title": "python-c-faster-than-99-dfs-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Depth First Search* approach (with optimization) to find a word on the board.  Time complexity is **O(M\\\\*N\\\\*4^L)**. Space complexity is **O(M\\\\*N)**.\\n****\\n\\n**Comment.** A straightforward DFS won\\'t work here well (possible TLEs) due to significant amount of branches. The best strategy is to optimize (reduce) the number of branches at early stages, namely, starting from the first letter. The underlying symmetry of the problem, actually, allows us to do that, i.e., to reverse a word if it\\'s more appropriate (less branches) to start searching from the end.\\n\\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/848875896/) demonstrated **36 ms (99.76%) runtime**.\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        m, n = len(board), len(board[0])\\n        \\n        if len(word) > m * n: return False                            # [a] trivial case to discard\\n\\n        if not (cnt := Counter(word)) <= Counter(chain(*board)):      # [b] there are not enough\\n            return False                                              #     letters on the board\\n        \\n        if cnt[word[0]] > cnt[word[-1]]:                              # [c] inverse word if it\\'s better\\n             word = word[::-1]                                        #     to start from the end\\n        \\n        def dfs(i, j, s):                                             # recursive postfix search\\n            \\n            if s == len(word) : return True                           # [1] found the word\\n            \\n            if 0 <= i < m and 0 <= j < n and board[i][j] == word[s]:  # [2] found a letter\\n                board[i][j] = \"#\"                                     # [3] mark as visited\\n                adj = [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]               # [4] iterate over adjacent cells...\\n                dp = any(dfs(ii,jj,s+1) for ii,jj in adj)             # [5] ...and try next letter\\n                board[i][j] = word[s]                                 # [6] remove mark\\n                return dp                                             # [7] return search result\\n\\n            return False                                              # [8] this DFS branch failed\\n                \\n        return any(dfs(i,j,0) for i,j in product(range(m),range(n)))  # search starting from each position\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        m, n = len(board), len(board[0])\\n        \\n        if len(word) > m * n: return False                            # [a] trivial case to discard\\n\\n        if not (cnt := Counter(word)) <= Counter(chain(*board)):      # [b] there are not enough\\n            return False                                              #     letters on the board\\n        \\n        if cnt[word[0]] > cnt[word[-1]]:                              # [c] inverse word if it\\'s better\\n             word = word[::-1]                                        #     to start from the end\\n        \\n        def dfs(i, j, s):                                             # recursive postfix search\\n            \\n            if s == len(word) : return True                           # [1] found the word\\n            \\n            if 0 <= i < m and 0 <= j < n and board[i][j] == word[s]:  # [2] found a letter\\n                board[i][j] = \"#\"                                     # [3] mark as visited\\n                adj = [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]               # [4] iterate over adjacent cells...\\n                dp = any(dfs(ii,jj,s+1) for ii,jj in adj)             # [5] ...and try next letter\\n                board[i][j] = word[s]                                 # [6] remove mark\\n                return dp                                             # [7] return search result\\n\\n            return False                                              # [8] this DFS branch failed\\n                \\n        return any(dfs(i,j,0) for i,j in product(range(m),range(n)))  # search starting from each position\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843530,
                "title": "python3-backtracking-not-tle-for-beginners-only",
                "content": "When we see constraints ```1 <= m, n <= 6``` and ```1 <= word.length <= 15```, it is backtracking! (Not sure if the interviewer will tell you this, but it doesn\\'t hurt to ask for some constraints).\\n\\n**Backtracking** is basically **Brute Force**, where we check **all possibilities** using a **Recursive Function**.\\nThe most important parts of backtracking using recursive function are:\\n(1) **return** when we reach to the end and no more states can be generated.\\n(2) **restore the state** after calling the recursive function.\\ni.e.,\\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n\\nFor loop\\n    (2) change the current state to its neighboring state\\n    (3) backtrack(state)\\n    (4) restore the state (backtrack)\\n```\\n\\nFor this problem, \\n(1) We will **Brute Force all possibilities**, which means we will try to start at each cell in the ```grid``` to construct the word (or say, compare the cell with word[k], where 0<=k<len(word)) using Backtracking (a Recursive Function).\\n\\n(2) Backtracking:\\n - if the current cell is the same as word[k], we keep searching.\\n - if k is already at the last position in the word, we find a solution, so return True.\\n\\n    Now think about the state as the visited cells since we cannot reuse a cell.\\n\\n - for the four possible directions (up, down, left, right):\\n (1) check if the new cell is valid (inside the grid)\\n (2) add the new cell (x,y) to our visited list.\\n (3) do Backtracking using this newly visited list.\\n (4) remove the last added cell from the visited list. (This step is the reason why it is called backtrack)\\n\\n(3) return False if we couldn\\'t reconstruct the word.\\n\\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                \\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        visited.add((x,y))                      # Change the state\\n                        if backtrack(x,y,k+1,visited)==True:    # Recursive call\\n                            return True\\n                        visited.remove((x,y))                   # Restore the state\\n            return False\\n        \\n        # start from each cell in the grid.\\n        for i in range(m):\\n            for j in range(n):\\n                if backtrack(i,j,0,{(i,j)}):\\n                    return True\\n        return False\\n```\\n\\nThis may sometimes get TLE!\\n\\n**Follow up:** Could you use search pruning to make your solution faster with a larger board?\\n\\nWe need to prune the search further! Learned from [Here](https://leetcode.com/problems/word-search/discuss/2843501/PythonC%2B%2B-faster-than-99-DFS-(explained)) and also [Minamikaze392](https://leetcode.com/Minamikaze392/)\\'s comments.\\n\\n**(1)** If there are fewer elements in the board than the word, return directly! (not helping much, but it is still an answer)\\n**(2)** If there are fewer characters in the board than the word, return directly! (no TLE anymore)\\n\\nIf you got TLE, you might have seen this testing case:\\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABB\"\\n```\\n\\nIf we start to search from the right with \\'A\\', there are too many branches! So if we reverse the word and start the search from the right with \\'B\\', it will be more efficient!\\n\\nAs commented by [Minamikaze392](https://leetcode.com/Minamikaze392/) what if the testing case looks like this (it is not currently in LeetCode):\\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABBA\"\\n```\\n\\n**(3)** A general pruning approach here is that we start the search from the right if at any point the duplicates on the right are less than the left. (see code below)\\n\\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        # (1) fewer elements in the board than the word.\\n        if m*n<len(word): return False\\n        \\n        # (2) fewer characters in the board than the word.\\n        countB = Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                countB[board[i][j]] += 1\\n        countW = Counter(word)\\n        for key in countW.keys():\\n            if countW[key] - countB[key] > 0:\\n                return False\\n        \\n        # (3) Inverse word if it\\'s better\\n        # If we find the right duplicates are less than the left duplicates, reverse the word.\\n        left,right = 1,len(word)-2\\n        leftDup = rightDup = 1\\n        while left<right:\\n            if word[left]==word[left-1]:\\n                leftDup += 1\\n            if word[right]==word[right+1]:\\n                rightDup += 1\\n                \\n            if rightDup<leftDup:\\n                word = word[::-1]\\n                break\\n                \\n            if word[left]!=word[left-1]:\\n                leftDup = 1\\n            if word[right]!=word[right+1]:\\n                rightDup = 1\\n            left += 1\\n            right -= 1\\n            \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        if backtrack(x,y,k+1,visited.union({(x,y)}))==True:\\n                            return True\\n            return False\\n        \\n        for i, j in product(range(m), range(n)):\\n            if backtrack(i,j,0,{(i,j)}):\\n                return True\\n        return False\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```1 <= m, n <= 6```\n```1 <= word.length <= 15```\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n\\nFor loop\\n    (2) change the current state to its neighboring state\\n    (3) backtrack(state)\\n    (4) restore the state (backtrack)\\n```\n```grid```\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                \\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        visited.add((x,y))                      # Change the state\\n                        if backtrack(x,y,k+1,visited)==True:    # Recursive call\\n                            return True\\n                        visited.remove((x,y))                   # Restore the state\\n            return False\\n        \\n        # start from each cell in the grid.\\n        for i in range(m):\\n            for j in range(n):\\n                if backtrack(i,j,0,{(i,j)}):\\n                    return True\\n        return False\\n```\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABB\"\\n```\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABBA\"\\n```\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        # (1) fewer elements in the board than the word.\\n        if m*n<len(word): return False\\n        \\n        # (2) fewer characters in the board than the word.\\n        countB = Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                countB[board[i][j]] += 1\\n        countW = Counter(word)\\n        for key in countW.keys():\\n            if countW[key] - countB[key] > 0:\\n                return False\\n        \\n        # (3) Inverse word if it\\'s better\\n        # If we find the right duplicates are less than the left duplicates, reverse the word.\\n        left,right = 1,len(word)-2\\n        leftDup = rightDup = 1\\n        while left<right:\\n            if word[left]==word[left-1]:\\n                leftDup += 1\\n            if word[right]==word[right+1]:\\n                rightDup += 1\\n                \\n            if rightDup<leftDup:\\n                word = word[::-1]\\n                break\\n                \\n            if word[left]!=word[left-1]:\\n                leftDup = 1\\n            if word[right]!=word[right+1]:\\n                rightDup = 1\\n            left += 1\\n            right -= 1\\n            \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        if backtrack(x,y,k+1,visited.union({(x,y)}))==True:\\n                            return True\\n            return False\\n        \\n        for i, j in product(range(m), range(n)):\\n            if backtrack(i,j,0,{(i,j)}):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27739,
                "title": "my-dfs-backtracking-c-solution-16ms",
                "content": "Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to '*' to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion)\\n\\n    class Solution {\\n    private:\\n        bool dfs(vector<vector<char>>& board, int row, int col, const string &word, int start, int M, int N, int sLen)\\n        {\\n            char curC;\\n            bool res = false;\\n            if( (curC = board[row][col]) != word[start]) return false;\\n            if(start==sLen-1) return true;\\n            board[row][col] = '*';\\n            if(row>0) res = dfs(board, row-1, col, word, start+1, M, N, sLen);\\n            if(!res && row < M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen);\\n            if(!res && col > 0)   res = dfs(board, row, col-1, word, start+1, M, N, sLen);\\n            if(!res && col < N-1) res = dfs(board,  row, col+1, word, start+1, M, N, sLen);\\n            board[row][col] = curC;\\n            return res;\\n        }\\n        \\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            int M,N,i,j,sLen = word.size();\\n            if( (M=board.size()) && (N=board[0].size()) && sLen)\\n            {\\n                for(i=0; i<M; ++i)\\n                    for(j=0; j<N; ++j)\\n                        if(dfs(board, i, j, word, 0, M, N, sLen)) return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        bool dfs(vector<vector<char>>& board, int row, int col, const string &word, int start, int M, int N, int sLen)\\n        {\\n            char curC;\\n            bool res = false;\\n            if( (curC = board[row][col]) != word[start]) return false;\\n            if(start==sLen-1) return true;\\n            board[row][col] = '*';\\n            if(row>0) res = dfs(board, row-1, col, word, start+1, M, N, sLen);\\n            if(!res && row < M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen);\\n            if(!res && col > 0)   res = dfs(board, row, col-1, word, start+1, M, N, sLen);\\n            if(!res && col < N-1) res = dfs(board,  row, col+1, word, start+1, M, N, sLen);\\n            board[row][col] = curC;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 27834,
                "title": "simple-solution",
                "content": "    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if(exist(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean exist(char[][] board, int x, int y, String word, int start) {\\n        if(start >= word.length()) return true;\\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == word.charAt(start++)) {\\n            char c = board[x][y];\\n            board[x][y] = '#';\\n            boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) ||\\n            exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start);\\n            board[x][y] = c;\\n            return res;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if(exist(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean exist(char[][] board, int x, int y, String word, int start) {\\n        if(start >= word.length()) return true;\\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == word.charAt(start++)) {\\n            char c = board[x][y];\\n            board[x][y] = '#';\\n            boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) ||\\n            exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start);\\n            board[x][y] = c;\\n            return res;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27820,
                "title": "python-dfs-solution",
                "content": "    class Solution:\\n        # @param board, a list of lists of 1 length string\\n        # @param word, a string\\n        # @return a boolean\\n        # 3:42\\n        def exist(self, board, word):\\n            visited = {}\\n    \\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if self.getWords(board, word, i, j, visited):\\n                        return True\\n            \\n            return False\\n    \\n        def getWords(self, board, word, i, j, visited, pos = 0):\\n            if pos == len(word):\\n                return True\\n    \\n            if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or visited.get((i, j)) or word[pos] != board[i][j]:\\n                return False\\n    \\n            visited[(i, j)] = True\\n            res = self.getWords(board, word, i, j + 1, visited, pos + 1) \\\\\\n                    or self.getWords(board, word, i, j - 1, visited, pos + 1) \\\\\\n                    or self.getWords(board, word, i + 1, j, visited, pos + 1) \\\\\\n                    or self.getWords(board, word, i - 1, j, visited, pos + 1)\\n            visited[(i, j)] = False\\n    \\n            return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n        # @param board, a list of lists of 1 length string\\n        # @param word, a string\\n        # @return a boolean\\n        # 3:42\\n        def exist(self, board, word):\\n            visited = {}",
                "codeTag": "Java"
            },
            {
                "id": 131327,
                "title": "iterative-python-solution",
                "content": "seems the solutions are missing iterative approach.\\nWe use stack to do dfs and also keep `backtrack` state to remove coordinates.\\nThe idea is that after we visit a node, we add a backtracking node to remove the node if we ever come back to the current stack level.\\n\\n```\\nclass Solution(object):\\n    def neighbors(self, board, r, c):\\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        nbs = []\\n        for d in directions:\\n            nr = r + d[0]\\n            nc = c + d[1]\\n            if (0 <= nr < len(board)) and (0 <= nc < len(board[nr])):\\n                nbs.append((nr, nc))\\n        return nbs\\n    \\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        q = list()\\n\\t\\t\\t\\t\\n        for r in range(len(board)): # find starting points\\n            for c in range(len(board[r])):\\n                if board[r][c] == word[0]:\\n                    q.append((r, c))\\n                    \\n        for (r, c) in q:\\n            visited = set()\\n            stack = list()\\n            stack.append((r, c, 0, False)) # regular forward moving node\\n            while stack:\\n                cr, cc, i, backtrack = stack.pop()\\n                if backtrack:\\n                    visited.remove((cr, cc))\\n                    continue\\n                    \\n                visited.add((cr, cc))\\n                stack.append((cr, cc, i, True)) # add backtracking node\\n                if i == (len(word) - 1):\\n                    return True\\n            \\n                for nr, nc in self.neighbors(board, cr, cc):\\n                    if (nr, nc) in visited:\\n                        continue\\n                    if board[nr][nc] == word[i + 1]:\\n                        stack.append((nr, nc, i + 1, False)) # forward-moving node\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def neighbors(self, board, r, c):\\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        nbs = []\\n        for d in directions:\\n            nr = r + d[0]\\n            nc = c + d[1]\\n            if (0 <= nr < len(board)) and (0 <= nc < len(board[nr])):\\n                nbs.append((nr, nc))\\n        return nbs\\n    \\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        q = list()\\n\\t\\t\\t\\t\\n        for r in range(len(board)): # find starting points\\n            for c in range(len(board[r])):\\n                if board[r][c] == word[0]:\\n                    q.append((r, c))\\n                    \\n        for (r, c) in q:\\n            visited = set()\\n            stack = list()\\n            stack.append((r, c, 0, False)) # regular forward moving node\\n            while stack:\\n                cr, cc, i, backtrack = stack.pop()\\n                if backtrack:\\n                    visited.remove((cr, cc))\\n                    continue\\n                    \\n                visited.add((cr, cc))\\n                stack.append((cr, cc, i, True)) # add backtracking node\\n                if i == (len(word) - 1):\\n                    return True\\n            \\n                for nr, nc in self.neighbors(board, cr, cc):\\n                    if (nr, nc) in visited:\\n                        continue\\n                    if board[nr][nc] == word[i + 1]:\\n                        stack.append((nr, nc, i + 1, False)) # forward-moving node\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133078,
                "title": "clean-javascript-solution",
                "content": "Time O(mn * 4^l), l = word.length\\nSpace O(mn + l)\\n\\n```js\\nconst exist = (board, word) => {\\n  if (board.length === 0) return false;\\n\\n  const h = board.length;\\n  const w = board[0].length;\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n\\n  const go = (x, y, k) => {\\n    if (board[x][y] !== word[k]) return false;\\n    if (k === word.length - 1) return true;\\n\\n    board[x][y] = \\'*\\'; // mark as visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      if (i >= 0 && i < h && j >= 0 && j < w) {\\n        if (go(i, j, k + 1)) return true;\\n      }\\n    }\\n    board[x][y] = word[k]; // reset\\n    return false;\\n  };\\n\\n  for (let i = 0; i < h; i++) {\\n    for (let j = 0; j < w; j++) {\\n      if (go(i, j, 0)) return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst exist = (board, word) => {\\n  if (board.length === 0) return false;\\n\\n  const h = board.length;\\n  const w = board[0].length;\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n\\n  const go = (x, y, k) => {\\n    if (board[x][y] !== word[k]) return false;\\n    if (k === word.length - 1) return true;\\n\\n    board[x][y] = \\'*\\'; // mark as visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      if (i >= 0 && i < h && j >= 0 && j < w) {\\n        if (go(i, j, k + 1)) return true;\\n      }\\n    }\\n    board[x][y] = word[k]; // reset\\n    return false;\\n  };\\n\\n  for (let i = 0; i < h; i++) {\\n    for (let j = 0; j < w; j++) {\\n      if (go(i, j, 0)) return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747326,
                "title": "c-simple-and-detailed-explanation",
                "content": "Our goal is to find if the `word` exisits in the matrix or not. We only have to look at the adjacent cells (ignore the diagonal ones).\\n\\nOne quick look at the problem can suggest us that we can solve this by Backtracking. Match character-by-character, go ahead and check if the adjacent cells match the next character, and go back if it does not match.\\n\\nHow should we traverse the matrix efficiently? We need to think of a traversal approach. BFS? DFS? Both can work. But DFS will be better as it immediately checks the next node of the graph and returns if it is not needed after marking it as visited. \\n\\nFinal solution approach:\\n1. For each cell, traverse the entire matrix.\\n2. Check if `matrix[i][j] == word[index]`. (we are using `index` to keep track of the characters that we have already checked in the `word` during backtracking.)\\n3. If step 2 is true, then check repeat the same process for the adjacent cells and for the next index in the word.\\n4. If step 2 is false, then return to the previous state where we received a `true` value and then further check any remaining and unvisited cells.\\n\\n**Note:** We mark each cell as unvisited after we check all the adjacent possibilities because we might visit that cell again when we start traversing the matrix from a different source cell. You will better understand this when you solve this test case on paper. \\n\\n`board = [[\"a\",\"b\"],[\"c\",\"d\"]]; word = \"cdba\"`\\n\\n**Code:**\\n```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<vector<bool>> vis;\\n    bool dfs(vector<vector<char>> &board, string word, int i, int j, int index)\\n    {\\n        if(board[i][j] == word[index])\\n        {\\n            vis[i][j] = true;\\n            if(index == word.length() - 1)\\n                return true;\\n            if(i-1 >= 0 && vis[i-1][j] == false)\\n                if(dfs(board, word, i-1, j, index+1))\\n                    return true;\\n            if(i+1 < n && vis[i+1][j] == false)\\n                if(dfs(board, word, i+1, j, index+1))\\n                    return true;\\n            if(j-1 >= 0 && vis[i][j-1] == false)\\n                if(dfs(board, word, i, j-1, index+1))\\n                    return true;\\n            if(j+1 < m && vis[i][j+1] == false)\\n                if(dfs(board, word, i, j+1, index+1))\\n                    return true;\\n            vis[i][j] = false;\\n            return false;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        n = board.size();\\n        m = board[0].size();\\n        vis = vector<vector<bool>>(n, vector<bool>(m, false));\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dfs(board, word, i, j, 0))\\n                    return true;\\n            }\\n        return false;\\n    }\\n};\\n```\\n\\nI hope this helps! If you need a clarification, please post it in the comments section.\\n\\nIf you liked my explanation, then would you be so kind as to upvote this post? It gives me motivation to explain difficult problems in a simple manner.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<vector<bool>> vis;\\n    bool dfs(vector<vector<char>> &board, string word, int i, int j, int index)\\n    {\\n        if(board[i][j] == word[index])\\n        {\\n            vis[i][j] = true;\\n            if(index == word.length() - 1)\\n                return true;\\n            if(i-1 >= 0 && vis[i-1][j] == false)\\n                if(dfs(board, word, i-1, j, index+1))\\n                    return true;\\n            if(i+1 < n && vis[i+1][j] == false)\\n                if(dfs(board, word, i+1, j, index+1))\\n                    return true;\\n            if(j-1 >= 0 && vis[i][j-1] == false)\\n                if(dfs(board, word, i, j-1, index+1))\\n                    return true;\\n            if(j+1 < m && vis[i][j+1] == false)\\n                if(dfs(board, word, i, j+1, index+1))\\n                    return true;\\n            vis[i][j] = false;\\n            return false;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        n = board.size();\\n        m = board[0].size();\\n        vis = vector<vector<bool>>(n, vector<bool>(m, false));\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dfs(board, word, i, j, 0))\\n                    return true;\\n            }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408943,
                "title": "javascript-recursive-solution-w-explanation",
                "content": "#### The idea\\nSince it\\'s obvious that there will be a lot of repetitive work, such as checking up, down, left, right for lots of characters, we can use recusion to simplify our code. \\nOur base case will need to check:\\n1. are we getting out of boundary? if yes, get out.\\n2. are we getting a wrong character? If yes, get out.\\n3. did we find every character from the work? If yes, great, we have found this word.\\nOtherwise keep exploring characters for all directions.\\n\\n``` javascript\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar exist = function(board, word) {\\n    let result = false;\\n    var check = function(r, c, i) {\\n        if (!result) {\\n            if (r < 0 || c < 0 || r >= board.length || c >= board[0].length) return; // out of boundary\\n            if (board[r][c] != word[i]) return; // wrong character\\n            if (i == word.length - 1) { // got to the end means we found a correct path\\n                result = true;\\n                return;\\n            }\\n            board[r][c] = null; // mark our path so we dont go back and forth\\n\\t\\t\\t// try all directions\\n            check(r+1,c,i+1)\\n            check(r-1,c,i+1)\\n            check(r,c+1,i+1)\\n            check(r,c-1,i+1)\\n            board[r][c] = word[i] // reset our board , very important\\n        }\\n    }\\n\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            if (board[i][j] == word[0]) {\\n                check(i, j, 0)\\n                if (result) return result;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar exist = function(board, word) {\\n    let result = false;\\n    var check = function(r, c, i) {\\n        if (!result) {\\n            if (r < 0 || c < 0 || r >= board.length || c >= board[0].length) return; // out of boundary\\n            if (board[r][c] != word[i]) return; // wrong character\\n            if (i == word.length - 1) { // got to the end means we found a correct path\\n                result = true;\\n                return;\\n            }\\n            board[r][c] = null; // mark our path so we dont go back and forth\\n\\t\\t\\t// try all directions\\n            check(r+1,c,i+1)\\n            check(r-1,c,i+1)\\n            check(r,c+1,i+1)\\n            check(r,c-1,i+1)\\n            board[r][c] = word[i] // reset our board , very important\\n        }\\n    }\\n\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            if (board[i][j] == word[0]) {\\n                check(i, j, 0)\\n                if (result) return result;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27665,
                "title": "python-simple-dfs-solution",
                "content": "    def exist(self, board, word):\\n        if not word:\\n            return True\\n        if not board:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.exist_helper(board, word, i, j):\\n                    return True\\n        return False\\n                        \\n    def exist_helper(self, board, word, i, j):\\n        if board[i][j] == word[0]:\\n            if not word[1:]:\\n                return True\\n            board[i][j] = \" \" # indicate used cell\\n            # check all adjacent cells\\n            if i > 0 and self.exist_helper(board, word[1:], i-1, j):\\n                return True\\n            if i < len(board)-1 and self.exist_helper(board, word[1:], i+1, j):\\n                return True\\n            if j > 0 and self.exist_helper(board, word[1:], i, j-1):\\n                return True\\n            if j < len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1):\\n                return True\\n            board[i][j] = word[0] # update the cell to its original value\\n            return False\\n        else:\\n            return False",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    def exist(self, board, word):\\n        if not word:\\n            return True\\n        if not board:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.exist_helper(board, word, i, j):\\n                    return True\\n        return False\\n                        \\n    def exist_helper(self, board, word, i, j):\\n        if board[i][j] == word[0]:\\n            if not word[1:]:\\n                return True\\n            board[i][j] = \" \" # indicate used cell\\n            # check all adjacent cells\\n            if i > 0 and self.exist_helper(board, word[1:], i-1, j):\\n                return True\\n            if i < len(board)-1 and self.exist_helper(board, word[1:], i+1, j):\\n                return True\\n            if j > 0 and self.exist_helper(board, word[1:], i, j-1):\\n                return True\\n            if j < len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1):\\n                return True\\n            board[i][j] = word[0] # update the cell to its original value\\n            return False\\n        else:\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 1908561,
                "title": "c-how-to-prune-the-dfs-to-0ms",
                "content": "I assume that you know how the DFS works. Here\\'s an implementation of a basic DFS **without pruning**.\\n```\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;} // found word!\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;} // out of bounds\\n        else if(board[r][c] != word[i]) {return false;} // current character doesn\\'t match the board\\n        \\n        board[r][c] = \\'#\\'; // mark board[r][c] as already visited\\n        \\n\\t\\t// move up, down, left, and right and see if you can find word from there\\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i]; // unmark board[r][c]\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size();\\n        \\n\\t\\t// See if you can find word, starting from every possible starting point in board[][]\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nNow, **three pruning steps**:\\n\\n1. If the total number of characters in the board is less than the number of characters in word, then you can obviously ```return false;``` immediately. Basically, this is when word wouldn\\'t fit in the board at all.\\n2. For every character in word, that character must appear in board the same number of times or greater. Basically, the number of occurrences of any character `c` in board must be >= the number of occurrences of `c` in word.\\n\\nAdding these two pruning methods reduced my runtime from around 380ms (the original non-pruned program) to 45ms.\\n\\n3. **Not so well-known (I think)**\\nConsider `word = \"aaaaaaaaaab\"` and let board have all `a` except for one `b` in the lower-right corner. The problem is that when we try finding `word` from each starting point, we will find a lot of ways to construct `aaaaaaaaaa` each time, but we will never find that last `b` until our starting point is close the lower-right corner. For these cases, the non-pruned algorithm will be significantly slower.\\n\\nWe can **partially** optimize these sorts of test cases as follows: find the longest prefix and suffix in `word` that are each made up of the same character. For example, if `word = \"aaaabccc\"`, the longest prefix and suffix are length 4 and 3 respectively. **If the longest prefix is longer than the longest suffix, then reverse the string**. This makes it so that `word` having a very long prefix is a lot less likely. But in cases where the longest prefix/suffix have very close lengths, this won\\'t really help. But for the LeetCode test data, this seems to generate a large speedup; I was able to get 0ms runtime when I submitted the following solution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;}\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;}\\n        else if(board[r][c] != word[i]) {return false;}\\n        \\n        board[r][c] = \\'#\\';\\n        \\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i];\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size(), N = word.size();\\n        \\n        // Prune #1: If there aren\\'t even enough letters in the board to fit word, then return false\\n        if((int) word.size() > R * C) {return false;}\\n        \\n        // Prune #2: For each letter, the board must contain at least as many of that letter as word contains\\n        int occ[128] = {};\\n        for(const auto &v : board) {for(char c : v) {++occ[c];}}\\n        for(char c : word) {\\n            if(--occ[c] < 0) {return false;}\\n        }\\n        \\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest suffix is longer\\n        // than the longest prefix, swap the strigns (so we are less likely to have a long prefix with a lot\\n        // of the same character)\\n        int left_pref = word.find_first_not_of(word[0]);\\n        int right_pref = word.size() - word.find_last_not_of(word.back());\\n        if(left_pref > right_pref) {\\n            reverse(word.begin(), word.end());\\n        }\\n        \\n        // for every starting point, see if we can find word from there\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;} // found word!\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;} // out of bounds\\n        else if(board[r][c] != word[i]) {return false;} // current character doesn\\'t match the board\\n        \\n        board[r][c] = \\'#\\'; // mark board[r][c] as already visited\\n        \\n\\t\\t// move up, down, left, and right and see if you can find word from there\\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i]; // unmark board[r][c]\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size();\\n        \\n\\t\\t// See if you can find word, starting from every possible starting point in board[][]\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n```\n```return false;```\n```\\nclass Solution {\\npublic:\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;}\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;}\\n        else if(board[r][c] != word[i]) {return false;}\\n        \\n        board[r][c] = \\'#\\';\\n        \\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i];\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size(), N = word.size();\\n        \\n        // Prune #1: If there aren\\'t even enough letters in the board to fit word, then return false\\n        if((int) word.size() > R * C) {return false;}\\n        \\n        // Prune #2: For each letter, the board must contain at least as many of that letter as word contains\\n        int occ[128] = {};\\n        for(const auto &v : board) {for(char c : v) {++occ[c];}}\\n        for(char c : word) {\\n            if(--occ[c] < 0) {return false;}\\n        }\\n        \\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest suffix is longer\\n        // than the longest prefix, swap the strigns (so we are less likely to have a long prefix with a lot\\n        // of the same character)\\n        int left_pref = word.find_first_not_of(word[0]);\\n        int right_pref = word.size() - word.find_last_not_of(word.back());\\n        if(left_pref > right_pref) {\\n            reverse(word.begin(), word.end());\\n        }\\n        \\n        // for every starting point, see if we can find word from there\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508066,
                "title": "c-bakctracking-dfs-easiest-solution-with-explanation-beginner-friendly",
                "content": "# ***Approach***\\n```\\n          This is a very popular backtracking problem and is many times asked in faang interviews , although its not that difficult!!!\\n          ------------------------------------------------------------------------------------- \\n          Let\\'s understand the problem statement first!!!\\n              we are given a matrix of (m x n) and we are required to check whether given word\\n              exists in matrix or not!!!\\n              NOTE : we can move in four directions(UP , DOWN , LEFT , RIGHT)\\n          ------------------------------------------------------------------------------------- \\n          Solution :\\n                As the word in matrix can start at any position so we have to check for all\\n                positions whether each position can be a starting point!!\\n                \\n                Now the logic is simple for every call we have index variable which shows how\\n                much chars of word are already found in current dfs call \\n                if at any point we found a mismatch between word[index] and baord[x][y] then that branch becomes invalid for us\\n                \\n                We use backtracking to make sure that each position/block of matrix \\n                is visited once in a branch!!![important][visited check]\\n```\\n# ***Code***\\n ```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>> &board, string word) {\\n        // checking for all positions\\n        for(int i = 0 ; i < board.size() ; ++i)\\n            for(int j = 0 ; j < board[0].size() ; ++j)\\n                if(dfs(0 , i , j , board , word))\\n                    return true;\\n        return false;\\n    }\\n    bool dfs(int index , int x , int y , vector<vector<char>> &board , string &word)\\n    {\\n        if(index == word.size()) // word exists in matrix\\n            return true;\\n        \\n        if(x < 0 or y < 0 or x >= board.size() or y >= board[0].size() or board[x][y] == \\'.\\') // boundary check + visited check\\n            return false;\\n        \\n        if(board[x][y] != word[index])\\n            return false;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'.\\'; // marking it visited\\n        \\n        // Move in 4 directions[UP , DOWN , LEFT , RIGHT]\\n        if(dfs(index + 1 , x - 1 , y , board , word) or dfs(index + 1 , x + 1 , y , board , word) or dfs(index + 1 , x , y - 1 , board , word) or dfs(index + 1 , x , y + 1 , board , word))\\n            return true;\\n            \\n        board[x][y] = temp; // backtrack step\\n        return false;\\n        \\n    }\\n    \\n};\\n```\\n# ***If you liked the Solution , Give it an Upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n          This is a very popular backtracking problem and is many times asked in faang interviews , although its not that difficult!!!\\n          ------------------------------------------------------------------------------------- \\n          Let\\'s understand the problem statement first!!!\\n              we are given a matrix of (m x n) and we are required to check whether given word\\n              exists in matrix or not!!!\\n              NOTE : we can move in four directions(UP , DOWN , LEFT , RIGHT)\\n          ------------------------------------------------------------------------------------- \\n          Solution :\\n                As the word in matrix can start at any position so we have to check for all\\n                positions whether each position can be a starting point!!\\n                \\n                Now the logic is simple for every call we have index variable which shows how\\n                much chars of word are already found in current dfs call \\n                if at any point we found a mismatch between word[index] and baord[x][y] then that branch becomes invalid for us\\n                \\n                We use backtracking to make sure that each position/block of matrix \\n                is visited once in a branch!!![important][visited check]\\n```\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>> &board, string word) {\\n        // checking for all positions\\n        for(int i = 0 ; i < board.size() ; ++i)\\n            for(int j = 0 ; j < board[0].size() ; ++j)\\n                if(dfs(0 , i , j , board , word))\\n                    return true;\\n        return false;\\n    }\\n    bool dfs(int index , int x , int y , vector<vector<char>> &board , string &word)\\n    {\\n        if(index == word.size()) // word exists in matrix\\n            return true;\\n        \\n        if(x < 0 or y < 0 or x >= board.size() or y >= board[0].size() or board[x][y] == \\'.\\') // boundary check + visited check\\n            return false;\\n        \\n        if(board[x][y] != word[index])\\n            return false;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'.\\'; // marking it visited\\n        \\n        // Move in 4 directions[UP , DOWN , LEFT , RIGHT]\\n        if(dfs(index + 1 , x - 1 , y , board , word) or dfs(index + 1 , x + 1 , y , board , word) or dfs(index + 1 , x , y - 1 , board , word) or dfs(index + 1 , x , y + 1 , board , word))\\n            return true;\\n            \\n        board[x][y] = temp; // backtrack step\\n        return false;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349677,
                "title": "java-time-and-memory-beats-100-backtracking-template",
                "content": "**T/S:** O(n * (4 ^ w))/O(n), where n is number of cells and w is word length.\\nTo avoid confusion, T: O(r * c * (4 ^ w)), where r x c are the dimensions of the board.\\n```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\npublic boolean exist(char[][] board, String word) {\\n\\tfor (var i = 0; i < board.length; i++)\\n\\t\\tfor (var j = 0; j < board[0].length; j++)\\n\\t\\t\\tif ((board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t\\treturn true;\\n\\treturn false;\\n}\\n\\n// backtracking template: for each choice: choose-explore-unchoose\\nprivate boolean exist(char[][] board, int i, int j, int count, String word) {\\n\\tif (count == word.length())\\n\\t\\treturn true;\\n\\tif (i == -1 || i == board.length || j == -1 || j == board[0].length || board[i][j] != word.charAt(count))\\n\\t\\treturn false;\\n\\t\\n\\t// choose\\n\\tvar temp = board[i][j];\\n\\tboard[i][j] = \\' \\';\\n\\tvar found = false;\\n\\t\\n\\t// explore\\n\\tfor (var dir : DIRS)\\n\\t\\tif (exist(board, i + dir[0], j + dir[1], count + 1, word)) {\\n\\t\\t\\tfound = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t// unchoose\\n\\tboard[i][j] = temp;\\n\\treturn found;\\n}\\n```\\n\\nSame solution using stream\\n```\\nprivate boolean existStream(char[][] board, String word) {\\n\\treturn IntStream.range(0, board.length)\\n\\t\\t\\t\\t\\t.anyMatch(i -> IntStream.range(0, board[0].length)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.anyMatch(j -> (board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t);\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\npublic boolean exist(char[][] board, String word) {\\n\\tfor (var i = 0; i < board.length; i++)\\n\\t\\tfor (var j = 0; j < board[0].length; j++)\\n\\t\\t\\tif ((board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t\\treturn true;\\n\\treturn false;\\n}\\n\\n// backtracking template: for each choice: choose-explore-unchoose\\nprivate boolean exist(char[][] board, int i, int j, int count, String word) {\\n\\tif (count == word.length())\\n\\t\\treturn true;\\n\\tif (i == -1 || i == board.length || j == -1 || j == board[0].length || board[i][j] != word.charAt(count))\\n\\t\\treturn false;\\n\\t\\n\\t// choose\\n\\tvar temp = board[i][j];\\n\\tboard[i][j] = \\' \\';\\n\\tvar found = false;\\n\\t\\n\\t// explore\\n\\tfor (var dir : DIRS)\\n\\t\\tif (exist(board, i + dir[0], j + dir[1], count + 1, word)) {\\n\\t\\t\\tfound = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t// unchoose\\n\\tboard[i][j] = temp;\\n\\treturn found;\\n}\\n```\n```\\nprivate boolean existStream(char[][] board, String word) {\\n\\treturn IntStream.range(0, board.length)\\n\\t\\t\\t\\t\\t.anyMatch(i -> IntStream.range(0, board[0].length)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.anyMatch(j -> (board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3228244,
                "title": "exploring-words-solving-the-grid-word-search-problem-with-dfs-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find whether a given word can be constructed from the characters of the given grid such that adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. The problem can be solved using the Depth First Search (DFS) algorithm. The DFS algorithm works by exploring as far as possible along each branch before backtracking. It is well-suited for problems that require searching through all possible paths.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can approach the problem using the DFS algorithm. We start by iterating through each cell in the grid. For each cell, we check whether the current cell matches the first character of the given word. If the current cell matches the first character of the word, we start a DFS search from that cell, looking for the rest of the characters in the word.\\n\\nFor each DFS search, we explore all four directions, i.e., up, down, left, and right, to find the next character in the word. We mark the current cell as visited to ensure that we do not use the same cell more than once. If we find the entire word, we return True, else we continue the search from the next unvisited cell.\\n\\nWe need to keep track of the visited cells to ensure that we do not use the same cell more than once. To mark a cell as visited, we can replace the character in the cell with a special character, such as \\'/\\'. After completing the DFS search, we can restore the original value of the cell.\\n# Complexity\\n- Time complexity: The time complexity of the DFS algorithm is proportional to the number of cells in the grid, i.e., O(mn), where m is the number of rows and n is the number of columns. In the worst case, we may have to explore all possible paths to find the word. For each cell, we explore at most four directions, so the time complexity of the DFS search is O(4^k), where k is the length of the word. Therefore, the overall time complexity of the algorithm is O(mn*4^k).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is O(k), where k is the length of the word. This is the space required to store the recursive stack during the DFS search.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(i: int, j: int, k: int) -> bool:\\n            if k == len(word):\\n                return True\\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:\\n                return False\\n            temp, board[i][j] = board[i][j], \\'/\\'\\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\\n            board[i][j] = temp\\n            return res\\n        \\n        m, n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if dfs(i, j, 0):\\n                    return True\\n        return False\\n\\n```\\n\\n# Code Explanation \\n\\nThis is a Python implementation of the depth-first search algorithm to find if a word exists in a given board of characters.\\n\\nThe `exist` method takes in two parameters, `board` and `word`, which are the 2D list of characters representing the board and the string representing the word to find, respectively. The method returns a boolean value, `True` if the word exists in the board, and `False` otherwise.\\n\\nThe algorithm uses a helper function `dfs` to search for the word starting from a given position in the board. The `dfs` function takes in three parameters, `i`, `j`, and `k`, which are the row and column indices of the current position in the board and the index of the current character in the word, respectively. The function returns a boolean value, `True` if the word can be formed starting from this position, and `False` otherwise.\\n\\nThe `dfs` function first checks if the end of the word has been reached, in which case it returns `True`. If the current position is out of the board or does not match the current character in the word, the function returns `False`.\\n\\nIf the current position matches the current character in the word, the function temporarily changes the character at the current position to `\\'/\\'` to mark it as visited and prevent revisiting it in the search. It then recursively calls itself with the adjacent positions (up, down, left, and right) and the next index in the word. If any of the recursive calls returns `True`, the function returns `True` as well.\\n\\nAfter the search from the current position is finished, the function restores the original character at the current position and returns the final result.\\n\\nThe `exist` function first gets the dimensions of the board using the `len` function. It then iterates through each cell in the board using nested loops. For each cell, it calls the `dfs` function starting from that position with the first character in the word. If `dfs` returns `True`, the function immediately returns `True` as well since the word has been found. If no word is found after iterating through all cells, the function returns `False`.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(i: int, j: int, k: int) -> bool:\\n            if k == len(word):\\n                return True\\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:\\n                return False\\n            temp, board[i][j] = board[i][j], \\'/\\'\\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\\n            board[i][j] = temp\\n            return res\\n        \\n        m, n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if dfs(i, j, 0):\\n                    return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27765,
                "title": "java-dfs-solution-beats-97-64",
                "content": "    public class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return true;\\n            }\\n            char[] chs = word.toCharArray();\\n            for (int i = 0; i < board.length; i++) {\\n                for (int j = 0; j < board[0].length; j++) {\\n                    if(dfs(board, chs, 0, i, j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private boolean dfs(char[][] board, char[] words, int idx, int x, int y) {\\n            if (idx == words.length) {\\n                return true;\\n            } \\n            if (x < 0 || x == board.length || y < 0 || y == board[0].length) {\\n                return false;\\n            }\\n            if (board[x][y] != words[idx]) {\\n                return false;\\n            }\\n            board[x][y] ^= 256;\\n            boolean exist = dfs(board, words, idx + 1, x, y + 1) ||\\n            dfs(board, words, idx + 1, x, y - 1) || dfs(board, words, idx + 1, x + 1, y) ||\\n            dfs(board, words, idx + 1, x - 1, y) ;\\n            board[x][y] ^= 256;\\n            return exist;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1225276,
                "title": "java-99-backtracking-pruning",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // pruning: case 1: not enough characters in board\\n        if (word.length() > m * n) return false;\\n        \\n        // pruning: case 2: board does not contain characters or enough characters that word contains\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int temp = count.getOrDefault(board[i][j], 0);\\n                count.put(board[i][j], temp + 1);\\n            }\\n        }\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int temp = count.get(c);\\n                if (temp == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, temp - 1);\\n                }\\n            }\\n        }\\n        // Backtracking: if a solution is possible, search for it\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0)) {\\n                    boolean[][] marked = new boolean[m][n];\\n                    marked[i][j] = true;\\n                    if (backtracking(board, word, i, j, 1, marked)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtracking(char[][] board, String word, int i, int j, int index, boolean[][] marked) {\\n        if (index == word.length()) return true;\\n        int m = board.length;\\n        int n = board[0].length;\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int d = 0; d < directions.length; d++) {\\n            int x = i + directions[d][0];\\n            int y = j + directions[d][1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (board[x][y] == word.charAt(index) && !marked[x][y]) {\\n                marked[x][y] = true;\\n                if (backtracking(board, word, x, y, index + 1, marked)) return true;\\n                marked[x][y] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // pruning: case 1: not enough characters in board\\n        if (word.length() > m * n) return false;\\n        \\n        // pruning: case 2: board does not contain characters or enough characters that word contains\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int temp = count.getOrDefault(board[i][j], 0);\\n                count.put(board[i][j], temp + 1);\\n            }\\n        }\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int temp = count.get(c);\\n                if (temp == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, temp - 1);\\n                }\\n            }\\n        }\\n        // Backtracking: if a solution is possible, search for it\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0)) {\\n                    boolean[][] marked = new boolean[m][n];\\n                    marked[i][j] = true;\\n                    if (backtracking(board, word, i, j, 1, marked)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtracking(char[][] board, String word, int i, int j, int index, boolean[][] marked) {\\n        if (index == word.length()) return true;\\n        int m = board.length;\\n        int n = board[0].length;\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int d = 0; d < directions.length; d++) {\\n            int x = i + directions[d][0];\\n            int y = j + directions[d][1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (board[x][y] == word.charAt(index) && !marked[x][y]) {\\n                marked[x][y] = true;\\n                if (backtracking(board, word, x, y, index + 1, marked)) return true;\\n                marked[x][y] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440514,
                "title": "javascript-dfs",
                "content": "```js\\n// Helper Func\\nconst isOutOfBound = (board, row, col) => row < 0 || row >= board.length || col < 0 || col >= board[0].length;\\n\\nconst checkNeighbors = (board, word, row, col) => {\\n    // Check exit conditions\\n    if (!word.length) return true;\\n    if (isOutOfBound(board, row, col) || board[row][col] !== word[0]) return false;\\n    \\n    // Save some stuff\\n    const curChar = board[row][col];\\n    const newWord = word.substr(1);\\n\\n    board[row][col] = 0; // Disable the current character\\n    \\n    // Check if neighbors are fruitful\\n    const results = checkNeighbors(board, newWord, row + 1, col) ||\\n        checkNeighbors(board, newWord, row - 1, col) ||\\n        checkNeighbors(board, newWord, row, col + 1) ||\\n        checkNeighbors(board, newWord, row, col - 1);\\n\\n    // Enable current character\\n    board[row][col] = curChar;\\n\\n    return results;\\n};\\n\\n\\nvar exist = function(board, word) {    \\n    for (let row = 0; row < board.length; row++) {\\n        for (let col  = 0; col < board[0].length; col++) {\\n            if (checkNeighbors(board, word, row, col)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// Helper Func\\nconst isOutOfBound = (board, row, col) => row < 0 || row >= board.length || col < 0 || col >= board[0].length;\\n\\nconst checkNeighbors = (board, word, row, col) => {\\n    // Check exit conditions\\n    if (!word.length) return true;\\n    if (isOutOfBound(board, row, col) || board[row][col] !== word[0]) return false;\\n    \\n    // Save some stuff\\n    const curChar = board[row][col];\\n    const newWord = word.substr(1);\\n\\n    board[row][col] = 0; // Disable the current character\\n    \\n    // Check if neighbors are fruitful\\n    const results = checkNeighbors(board, newWord, row + 1, col) ||\\n        checkNeighbors(board, newWord, row - 1, col) ||\\n        checkNeighbors(board, newWord, row, col + 1) ||\\n        checkNeighbors(board, newWord, row, col - 1);\\n\\n    // Enable current character\\n    board[row][col] = curChar;\\n\\n    return results;\\n};\\n\\n\\nvar exist = function(board, word) {    \\n    for (let row = 0; row < board.length; row++) {\\n        for (let col  = 0; col < board[0].length; col++) {\\n            if (checkNeighbors(board, word, row, col)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363906,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if self.backtracking(i, j,word,board):\\n                    return True\\n        return False\\n    def backtracking(self,i, j,word,board):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"~\"\\n                if self.backtracking(i+1, j, word[1:],board) or self.backtracking(i-1, j, word[1:],board) or self.backtracking(i, j+1, word[1:],board) or self.backtracking( i, j-1, word[1:],board):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if self.backtracking(i, j,word,board):\\n                    return True\\n        return False\\n    def backtracking(self,i, j,word,board):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"~\"\\n                if self.backtracking(i+1, j, word[1:],board) or self.backtracking(i-1, j, word[1:],board) or self.backtracking(i, j+1, word[1:],board) or self.backtracking( i, j-1, word[1:],board):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844101,
                "title": "c-using-dfs-comments-added-easy-to-learn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word)\\n    {\\n        // if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count) return true;\\n        \\n        // check for boundary                                  // curr char is not same with word char\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[count])\\n            return false;\\n        \\n        \\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        \\n        // up , down , left , right (possible moves)\\n        bool ans = dfs(i-1,j,count+1,board,word) || \\n                   dfs(i+1,j,count+1,board,word) ||\\n                   dfs(i,j-1,count+1,board,word) ||\\n                   dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp;                         // make board as it is for the upcoming calls\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int n = board.size();                   // rows\\n        int m = board[0].size();                // cols\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0] && dfs(i,j,0,board,word))                // whenever we found first letter of word start searching from there\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word)\\n    {\\n        // if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count) return true;\\n        \\n        // check for boundary                                  // curr char is not same with word char\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[count])\\n            return false;\\n        \\n        \\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        \\n        // up , down , left , right (possible moves)\\n        bool ans = dfs(i-1,j,count+1,board,word) || \\n                   dfs(i+1,j,count+1,board,word) ||\\n                   dfs(i,j-1,count+1,board,word) ||\\n                   dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp;                         // make board as it is for the upcoming calls\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int n = board.size();                   // rows\\n        int m = board[0].size();                // cols\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0] && dfs(i,j,0,board,word))                // whenever we found first letter of word start searching from there\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850436,
                "title": "java-beats-99-3-dfs-explained-with-dry-run-on-paper",
                "content": "If you\\'ll like the explanation, do **UpVote** :)\\n### Dry run\\n\\n![image](https://assets.leetcode.com/users/images/e9f9212a-f900-44e0-9d46-69a6ff3245ca_1647315994.8879087.png)\\n\\t --------------\\n\\t\\t--------------\\n\\n\\n**Note:** \\nDo check **Solution 2** as well, which is even more optimized  (Runtime: 55 ms, **faster than 99.20%**)\\n\\t\\n### Solution 1 (Very short & Simple code)\\n\\tclass Solution {\\n\\t\\tpublic boolean exist(char[][] board, String word) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;                                // length of rows & columns \\n\\t\\t\\tif(word.length() == 0){ return true; }                                          // if \"word\" is empty, we will just return true. \\n\\t\\t\\tif(rows * cols < word.length()){ return false; }                                // if board size (rows*cols) < word length, => word has some character(s) not present in board. So, just return False. This is optimized way as we are avoiding doing DFS search in such test cases. \\n\\n\\t\\t\\t// Traverse all chars of board\\n\\t\\t\\tfor(int r = 0; r < rows; r++){\\n\\t\\t\\t\\tfor(int c = 0; c < cols; c++){\\n\\t\\t\\t\\t\\tif(board[r][c] == word.charAt(0)){                                                // keep iterating until we don\\'t find first character of \"word\"\\n\\t\\t\\t\\t\\t\\tboolean isFound = dfsBoard(board, new boolean[rows][cols], r, c, word, 0);    // call DFS or recursion\\n\\t\\t\\t\\t\\t\\tif(isFound){ return true; }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;                                                                             // if we traveresed all chars of board, it means we did not find all chars of word. so return false\\n\\t\\t}\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic boolean dfsBoard(char[][] board, boolean[][] visitedBoard, int row, int col, String word, int wordInd) {        \\t\\t\\t\\n\\t\\t\\tif( (row < 0 || row >= board.length)   ||   (col < 0 || col >= board[0].length)  ||   board[row][col] != word.charAt(wordInd) ){\\n\\t\\t\\t\\treturn false;                                                                             // return false, if:  a)  row or col goes out of bound.  b) char in board != char in word \\n\\t\\t\\t}\\n\\t\\t\\tif(visitedBoard[row][col] ){ return false; }                                                  // this element already visited, so don\\'t do DFS on this\\n\\t\\t\\tif(wordInd == word.length() - 1){ return true; }\\n\\t\\t\\tvisitedBoard[row][col] = true;                                                                // mark it as visited now             \\n\\t\\t\\t\\t\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row, col-1, word, wordInd + 1) ){ return true; }            // DFS on Left\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row, col+1, word, wordInd + 1) ){ return true; }            // DFS on Right\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row-1, col, word, wordInd + 1) ){ return true; }            // DFS on ABove\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row+1, col, word, wordInd + 1) ){ return true; }            // DFS on Below\\n\\t\\t\\tvisitedBoard[row][col] = false;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n### Solution 2 (More Optimized)\\nJust added a new method **checkWordCharactersInBoard()**\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic boolean exist(char[][] board, String word) {\\n\\t\\t\\t// Here, same code as in Solution 1\\n\\t\\t\\tif(! checkWordCharactersInBoard(board, rows, cols, word) ){ return false; }                         // check if board contains all chars of word. \\n\\t\\t\\t// Here, same code as in Solution 1\\t\\t\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic boolean dfsBoard(char[][] board, boolean[][] visitedBoard, int row, int col, String word, int wordInd) {         \\n\\t\\t\\t// same code as in Solution 1\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic boolean checkWordCharactersInBoard(char[][] board, int rows, int cols, String word){              //   This method helped reducing Runtime further to only 55ms\\n\\t\\t\\tList<Character> wordList = new LinkedList<Character>();\\n\\t\\t\\tfor(char ch : word.toCharArray()){ wordList.add(ch); }\\n\\t\\t\\tfor(int r = 0; r < rows; r++){\\n\\t\\t\\t\\tfor(int c = 0; c < cols; c++){\\n\\t\\t\\t\\t\\tchar ch = board[r][c];\\n\\t\\t\\t\\t\\tif(wordList.size() == 0){ return true; }\\n\\t\\t\\t\\t\\tif(wordList.contains(ch) ){ wordList.remove((Character)ch); }                \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(wordList.size() == 0){ return true; }\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\nYou can talk about Solution 2, if you are asked to optimize further. \\n## For coding interviews:\\n\\t1. You can discuss Solution 1 first, and then optimize using Solution 2 (instead of directly jumpting to optimized solution) in coding interview. \\n\\nIf you like the explanation, do **UpVote** :)\\nIf you need more explanation or, if got even more optimized way, **comment** below.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean exist(char[][] board, String word) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;                                // length of rows & columns \\n\\t\\t\\tif(word.length() == 0){ return true; }",
                "codeTag": "Java"
            },
            {
                "id": 3223126,
                "title": "best-c-solution-ever-backtracking-matrix-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Matrix + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity:  O(N*M*4^L), where L is the length of the word. And we are searching for the letter N*M times in the worst case. Here 4 in 4^K is because at each level of our decision tree we are making 4 recursive calls which equal 4^K in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(L) : where L is the length of the given word. This space is used for recursion stack.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity:  O(N*M*4^L), where L is the length of the word. And we are searching for the letter N*M\\n    times in the worst case. Here 4 in 4^K is because at each level of our decision tree we are making 4\\n    recursive calls which equal 4^K in the worst case.\\n\\n    Space Complexity : O(L) : where L is the length of the given word. This space is used for recursion stack.\\n\\n    Solved using Matrix + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkWordPresent(vector<vector<char>>& board, string word, int n, int m, int row, int col, int index){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(row < 0 || col < 0 || row >= n || col >= m || board[row][col] != word[index]){\\n            return false;\\n        }\\n        char temp = board[row][col];\\n        board[row][col] = \\'*\\';\\n        bool ans1 = checkWordPresent(board, word, n, m, row+1, col, index+1);\\n        bool ans2 = checkWordPresent(board, word, n, m, row, col+1, index+1);\\n        bool ans3 = checkWordPresent(board, word, n, m, row-1, col, index+1);\\n        bool ans4 = checkWordPresent(board, word, n, m, row, col-1, index+1);\\n        board[row][col] = temp;\\n        return ans1 || ans2 || ans3 || ans4;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(checkWordPresent(board, word, n, m, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity:  O(N*M*4^L), where L is the length of the word. And we are searching for the letter N*M\\n    times in the worst case. Here 4 in 4^K is because at each level of our decision tree we are making 4\\n    recursive calls which equal 4^K in the worst case.\\n\\n    Space Complexity : O(L) : where L is the length of the given word. This space is used for recursion stack.\\n\\n    Solved using Matrix + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkWordPresent(vector<vector<char>>& board, string word, int n, int m, int row, int col, int index){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(row < 0 || col < 0 || row >= n || col >= m || board[row][col] != word[index]){\\n            return false;\\n        }\\n        char temp = board[row][col];\\n        board[row][col] = \\'*\\';\\n        bool ans1 = checkWordPresent(board, word, n, m, row+1, col, index+1);\\n        bool ans2 = checkWordPresent(board, word, n, m, row, col+1, index+1);\\n        bool ans3 = checkWordPresent(board, word, n, m, row-1, col, index+1);\\n        bool ans4 = checkWordPresent(board, word, n, m, row, col-1, index+1);\\n        board[row][col] = temp;\\n        return ans1 || ans2 || ans3 || ans4;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(checkWordPresent(board, word, n, m, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168378,
                "title": "java-dfs-with-explanations",
                "content": "For each cell in board, if it matches the first character of word, we implement DFS starting at it to see if we could find word. \\nThe bottleneck of it is to mark cell visited for we cannot visit a cell multiple times. The fastest way is to modify the original cell rather than to use external storage.\\n****\\n```\\n    private static int m, n;\\n    private static final int[][] dirs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        if (word == null || word.length() == 0)\\n            return true;\\n        \\n        m = board.length; \\n        n = board[0].length;\\n        char firstChar = word.charAt(0);\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == firstChar) {\\n                    // Mark as visited.\\n                    board[i][j] = \\'-\\';\\n                    if (searchFrom(i, j, board, word, 1))\\n                        return true;\\n                    // Restore to unvisited.\\n                    board[i][j] = firstChar;\\n                }\\n            }\\n        }\\n            \\n        return false;\\n    }\\n    \\n    private static boolean searchFrom(int x, int y, char[][] board, String word, int wi) {        \\n        // Acception case, leaf.\\n        if (wi == word.length()) \\n            return true;\\n        \\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            \\n            if (nx < 0 || nx >= m || ny < 0 || ny >= n || word.charAt(wi) != board[nx][ny])\\n                continue;\\n            // Mark as visited.\\n            board[nx][ny] = \\'-\\';\\n            if (searchFrom(nx, ny, board, word, wi + 1))\\n                return true;\\n            // Restore to unvisited.\\n            board[nx][ny] = word.charAt(wi);\\n        }\\n        \\n        return false;\\n    }\\n```\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [],
                "code": "```\\n    private static int m, n;\\n    private static final int[][] dirs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        if (word == null || word.length() == 0)\\n            return true;\\n        \\n        m = board.length; \\n        n = board[0].length;\\n        char firstChar = word.charAt(0);\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == firstChar) {\\n                    // Mark as visited.\\n                    board[i][j] = \\'-\\';\\n                    if (searchFrom(i, j, board, word, 1))\\n                        return true;\\n                    // Restore to unvisited.\\n                    board[i][j] = firstChar;\\n                }\\n            }\\n        }\\n            \\n        return false;\\n    }\\n    \\n    private static boolean searchFrom(int x, int y, char[][] board, String word, int wi) {        \\n        // Acception case, leaf.\\n        if (wi == word.length()) \\n            return true;\\n        \\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            \\n            if (nx < 0 || nx >= m || ny < 0 || ny >= n || word.charAt(wi) != board[nx][ny])\\n                continue;\\n            // Mark as visited.\\n            board[nx][ny] = \\'-\\';\\n            if (searchFrom(nx, ny, board, word, wi + 1))\\n                return true;\\n            // Restore to unvisited.\\n            board[nx][ny] = word.charAt(wi);\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747233,
                "title": "python-sol-by-dfs-w-comment",
                "content": "Python sol by DFS with 4-connected path\\n\\n---\\n\\n**Implementation** by DFS:\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        if not board: \\n            \\n            # Quick response for empty board\\n            return False\\n        \\n        h, w = len(board), len(board[0])\\n      \\n        # ------------------------------------------------------\\n    \\n        def dfs_search(idx: int, x: int, y: int) -> bool:\\n            \\n            if x < 0 or x == w or y < 0 or y == h or word[idx] != board[y][x]:\\n                # Reject if out of boundary, or current grid cannot match the character word[idx]\\n                return False\\n\\n            if idx == len(word) - 1: \\n                # Accept when we match all characters of word during DFS\\n                return True\\n\\n            cur = board[y][x]\\n            \\n            # mark as \\'#\\' to avoid repeated traversal\\n            board[y][x] = \\'#\\'\\n            \\n            # visit next four neighbor grids\\n            found = dfs_search(idx + 1, x + 1, y) or dfs_search(idx + 1, x - 1, y) or dfs_search(idx + 1, x, y + 1) or dfs_search(idx + 1, x, y - 1)\\n            \\n            # recover original grid character after DFS is completed\\n            board[y][x] = cur\\n            \\n            return found\\n\\n        # ------------------------------------------------------\\n        \\n        return any(dfs_search(0, x, y) for y in range(h) for x in range(w))      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        if not board: \\n            \\n            # Quick response for empty board\\n            return False\\n        \\n        h, w = len(board), len(board[0])\\n      \\n        # ------------------------------------------------------\\n    \\n        def dfs_search(idx: int, x: int, y: int) -> bool:\\n            \\n            if x < 0 or x == w or y < 0 or y == h or word[idx] != board[y][x]:\\n                # Reject if out of boundary, or current grid cannot match the character word[idx]\\n                return False\\n\\n            if idx == len(word) - 1: \\n                # Accept when we match all characters of word during DFS\\n                return True\\n\\n            cur = board[y][x]\\n            \\n            # mark as \\'#\\' to avoid repeated traversal\\n            board[y][x] = \\'#\\'\\n            \\n            # visit next four neighbor grids\\n            found = dfs_search(idx + 1, x + 1, y) or dfs_search(idx + 1, x - 1, y) or dfs_search(idx + 1, x, y + 1) or dfs_search(idx + 1, x, y - 1)\\n            \\n            # recover original grid character after DFS is completed\\n            board[y][x] = cur\\n            \\n            return found\\n\\n        # ------------------------------------------------------\\n        \\n        return any(dfs_search(0, x, y) for y in range(h) for x in range(w))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691667,
                "title": "c-solution-using-backtracking-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We are given a matrix of (m x n) and we are required to check whether the given word exists in the matrix or not!!!\\n- We can solve this by Backtracking. Match character-by-character, go ahead and check if the adjacent cells match the next character, and go back if it does not match.\\n- For each cell, traverse the entire matrix.\\n- Check if\\xA0`matrix[i][j] == word[index]`. (we are using\\xA0the `index`\\xA0to keep track of the characters that we have already checked in the\\xA0`word`\\xA0during backtracking.)\\n    - If it is true, then check to repeat the same process for the adjacent cells and for the next index in the word.\\n    - If it is false, then return to the previous state where we received a\\xA0`true`\\xA0value and then further check any remaining and unvisited cells.\\n- **Time complexity:** O(n) | *actually it\\u2019s O(4n) because we traverse 4 neighbours*.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n   bool exist(vector<vector<char>> &board, string word) {\\n       int row=board.size(), col=board[0].size();\\n       for(int i = 0 ; i < row ; ++i)\\n           for(int j = 0 ; j < col ; ++j)\\n               if(search(0 , i , j , board , word))\\n                   return true;\\n       return false;\\n   }\\n   bool search(int index , int x , int y , vector<vector<char>> &board , string &word)\\n   {\\n       if(index == word.size())\\n           return true;\\n       \\n       if(x < 0 || y < 0 || x >= board.size() || y >= board[0].size() || board[x][y] == \\'.\\') \\n           return false;\\n       \\n       if(board[x][y] != word[index])\\n           return false;\\n       \\n       char temp = board[x][y];\\n       board[x][y] = \\'.\\'; \\n       if(search(index + 1 , x - 1 , y , board , word) || search(index + 1 , x + 1 , y , board , word) || search(index + 1 , x , y - 1 , board , word) || search(index + 1 , x , y + 1 , board , word))\\n           return true;\\n           \\n       board[x][y] = temp;\\n       return false;\\n       \\n   }\\n   \\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n   bool exist(vector<vector<char>> &board, string word) {\\n       int row=board.size(), col=board[0].size();\\n       for(int i = 0 ; i < row ; ++i)\\n           for(int j = 0 ; j < col ; ++j)\\n               if(search(0 , i , j , board , word))\\n                   return true;\\n       return false;\\n   }\\n   bool search(int index , int x , int y , vector<vector<char>> &board , string &word)\\n   {\\n       if(index == word.size())\\n           return true;\\n       \\n       if(x < 0 || y < 0 || x >= board.size() || y >= board[0].size() || board[x][y] == \\'.\\') \\n           return false;\\n       \\n       if(board[x][y] != word[index])\\n           return false;\\n       \\n       char temp = board[x][y];\\n       board[x][y] = \\'.\\'; \\n       if(search(index + 1 , x - 1 , y , board , word) || search(index + 1 , x + 1 , y , board , word) || search(index + 1 , x , y - 1 , board , word) || search(index + 1 , x , y + 1 , board , word))\\n           return true;\\n           \\n       board[x][y] = temp;\\n       return false;\\n       \\n   }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520705,
                "title": "java-tc-o-rc-3-l-sc-o-l-optimal-dfs-solution-without-visited-matrix",
                "content": "```java\\n/**\\n * For each char, perform Depth-First Search in all four directions.\\n *\\n * Time Complexity:\\n * 1. If L > R*C ==> TC = O(1)\\n * 2. If L <= R*C ==> TC = O(R*C * 4*(3^L))\\n *      3^L ==> For the dfsHelper function, first time we have at most 4 directions\\n *              to explore, but the choices are reduced to 3 (since no need to go back to the\\n *              cell from where we came). Therefore, in the worst case, the total number of\\n *              calls to dfsHelper will be 3^L\\n *\\n * Space Complexity:\\n * 1. If L > R*C ==> SC = O(1)\\n * 2. If L <= R*C ==> SC = O(L)\\n *\\n * R = Number of rows. C = Number of columns. L = Length of word.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public boolean exist(char[][] board, String word) {\\n        if (board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0) {\\n            return false;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        if (rows * cols < word.length()) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == word.charAt(0) && dfsHelper(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfsHelper(char[][] board, String word, int x, int y, int wIdx) {\\n        if (wIdx == word.length()) {\\n            return true;\\n        }\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != word.charAt(wIdx)) {\\n            return false;\\n        }\\n\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            if (dfsHelper(board, word, x + d[0], y + d[1], wIdx + 1)) {\\n                board[x][y] = word.charAt(wIdx);\\n                return true;\\n            }\\n        }\\n        board[x][y] = word.charAt(wIdx);\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Word Search question on LeetCode:\\n- [212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/1520723/Java-or-TC%3A-O(RC*(3L))-or-SC%3A-O(N%2BL)-or-Optimal-Trie%2BDFS-solution)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * For each char, perform Depth-First Search in all four directions.\\n *\\n * Time Complexity:\\n * 1. If L > R*C ==> TC = O(1)\\n * 2. If L <= R*C ==> TC = O(R*C * 4*(3^L))\\n *      3^L ==> For the dfsHelper function, first time we have at most 4 directions\\n *              to explore, but the choices are reduced to 3 (since no need to go back to the\\n *              cell from where we came). Therefore, in the worst case, the total number of\\n *              calls to dfsHelper will be 3^L\\n *\\n * Space Complexity:\\n * 1. If L > R*C ==> SC = O(1)\\n * 2. If L <= R*C ==> SC = O(L)\\n *\\n * R = Number of rows. C = Number of columns. L = Length of word.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public boolean exist(char[][] board, String word) {\\n        if (board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0) {\\n            return false;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        if (rows * cols < word.length()) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == word.charAt(0) && dfsHelper(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfsHelper(char[][] board, String word, int x, int y, int wIdx) {\\n        if (wIdx == word.length()) {\\n            return true;\\n        }\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != word.charAt(wIdx)) {\\n            return false;\\n        }\\n\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            if (dfsHelper(board, word, x + d[0], y + d[1], wIdx + 1)) {\\n                board[x][y] = word.charAt(wIdx);\\n                return true;\\n            }\\n        }\\n        board[x][y] = word.charAt(wIdx);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509775,
                "title": "java-11ms-fast-explanation",
                "content": "The Java code below runs at 11ms on Oct 7, 2021.  Test cases change over time.  My previous code (not the code shown below) for this leetcode problem ran in 3ms a year ago with 89 test cases.  Now that same code takes 25 times longer to run with only 2/3 as many test cases.  So changes to test cases can make a big difference in execution time.  The example code below has been greatly modified from my code from one year ago, so that it is now mush more efficient and runs faster, although the new test cases for this leetcode problem cause the total execution time to be longer than one year ago.\\n\\nUpdate: As of November 2022, faster code appears on the runtime graph.  That fastest code has very good optimizations that include checking letter frequency.  If the word being searched for has a lower frequency letter at the end of the word than the frequency of the letter at the beginning of the word, then reverse the word before searching.  This speeds up the search by starting the search at a letter that occurs less often on the board.  For example, if the word being searched for is \"AAAAAB\" and the board has many \"A\"s but has only a few \"B\"s, then it reverses the word to \"BAAAAA\" before searching the board.\\n\\n---\\n**Faster solutions** previously **on the execution-time graph**\\nUpdate:  As of November 2022, the runtime graph has been reset.  The code from the runtime graph that is discussed in this section, no longer appears on the runtime graph.\\n\\nOn the graph of execution times for this leetcode problem, there are multiple bars on the graph with faster or similar execution times as this code, but the example code for those bars have a flaw that can produce a wrong answer with some test cases.  By clicking on those faster bars of the graph, I have found the example code for that bar.  Many of these code examples from the graph have special handling for the following test case from this leetcode problem:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"ABCESEEEFS\"\\n\\nWithout the special checks for this test case, some of those code examples would get the wrong answer.  In example code for 0ms on the execution-time graph, if the passed word is the word from the above test case, then immediately return `true`, because without this check the code would give the wrong result.  Some other examples from the fastest bars of the graph have look at surrounding board squares in an order which allows this test case to be accepted, because they look in the valid direction first.  For the fastest code examples from the execution-time graph that correctly handle the above case, most will get the wrong answer for the test case I created:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"],[\"A\",\"D\",\"E\",\"E\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"ABCESEEEEEFS\"\\n\\nThe flaw in these fastest code examples is that they keep a flag for each board square, which indicates if that square has been searched with a specific index into the word and that search failed.  This optimization flag is used to stop extra searches at a board square with the same index into the word.  But this optimization is flawed because it doesn\\'t handle a board square being searched at the same index into the word, but where the search path through the board may approach the same square at the same word index from **different directions** of approach to that square.  In the above test cases, the many \"E\"s on the board and many \"E\"s in the word can cause many paths through the board\\'s \"E\"s to be searched.  Not all of these paths lead to a valid solution.  The optimization flags for the squares do not contain any information as to which direction that board square was approached from.  \\n\\nAn example from the above test cases showing how this optimization fails, is that an \"E\" on the board may be searched with, for example, the 3rd \"E\" of the word and that path through the board eventually doesn\\'t match the word.  Then that \"E\" on the board is flagged as already having been tried with the 3rd letter of the word and that search failed.  But a later search path through the board approaches that same \"E\" on the board but from a different direction and wants to use that \"E\" from the board for the 3rd \"E\" of the word.  But that board square already has that \"E\"\\'s square flagged as having failed when trying to use it for the 3rd \"E\" of the word.  So that optimization flag causes that search to be terminated early as a failure, when that \"E\" could actually have been used to match the 3rd \"E\" of the word as part of a valid match for the entire word.  In this case, these optimization flags prevent a valid word match from being found.  In most test cases, this optimization works to produce the correct answer, but for some situations such as the above test cases, this optimization can fail.\\n\\n---\\n**Explaining the code below**\\n\\nThe Java code example below uses a Depth First Search (DFS) to recursively try many paths on the board to try to match the passed word.  The DFS recursively looks for the next letter in the word in the current square of the board, then recurses to try to find the next letter of the word in a board square surrounding (up, down, left, right) the current square.  If the DFS successfully searches to the end of the word, then the DFS passes `true` back of the recursive calls and the search is terminated with a success in finding the word on the board.\\n\\nDuring the DFS, before DFS code\\'s recursion calls, the current board square\\'s letter is temporarily replaced with \\'\\\\*\\' to prevent re-use of a board square that has already been used to match a letter in the word.  If a DFS search decides its search path has failed, the \\'\\\\*\\'s are reset to their original letter as the recursion unwinds back to a point where the DFS will try a different path.  An alternate to temporarily replacing the board square\\'s letter with \\'\\\\*\\', would have been to XOR that square with 128 to mark the square as \"used\" by preventing letters from matching this square, then after recursion calls, to XOR that square again with 128 to mark the square as unused.  For example, the marking a square as \"used\" prevents cases such as two adjacent board squares being \\'A\\' and \\'B\\', with the word being \"ABABABAB\", and the DFS search using first the \\'A\\', then the adjacent \\'B\\', but marking these as used prevents the search from re-using that same \\'A\\' square again, and prevents the search from bouncing back and forth between these two board squares.\\n\\nSeveral optimizations to make the example code faster are described in paragraphs below.\\n\\n**Optimization - Check if all word letters are on the board:**` ` ` `The biggest improvement in speed came from checking if all the letters in the word exist somewhere on the board.  If the word contains a letter not found on the board, then return `false` and don\\'t waste time doing the DFS.  To do this check, the extire board is scanned.  Each board letter is converted into a bitmask, then OR\\'ed into the combined **bitmask** for the entire board.  Each letter \\'A\\'...\\'Z\\' and \\'a\\'...\\'z\\' have a single bit in the bitmask.  After the combined bitmask for the entire board has been created, the bitmask contains flags for all the letters found on the board.  Then each letter from the word is tested against that bitmask, to check if that letter exists somewhere on the board.  An alternate for this optimization would be to **count** each type of letter on the board, then make sure there are enough for each type of letter in the word.  This alternate for this check did not provide any noticeable speed improvement, so since the next optimization below uses bitmasks, I also used bitmasks for this optimization.  Another alternate for this optimization would be to use a **Set**\\\\<Character> instead of a bitmask, but both the bitmask and the counts are faster than a `Set`.  If more types of characters were to be allowed on the board, or the board could contain Unicode character strings, then a `Set` would be the best solution.  The advantage of this optimization is best shown with the leetcode problem\\'s test case:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"AAAAAAAAAAAAAAB\"\\n\\n**Optimization - Quick test if any surrounding square contains the next letter of the word:**` ` ` `An array is created with the same dimensions as the `board`.  This array contains a bitmask for each square of the board.  Each bitmask contains bits to indicate which letters are in the four surrounding board squares.  During the recursive DFS search, these bitmasks allow a fast check to see if the next letter in the word exists in one of the surrounding squares of the board, without actually looking at those surrounding squares.  These bitmasks are in the array `nextLetters`, which is built before starting any of the DFS searches.  To build the matrix of bitmasks for this optimization, the board is scanned with nested for-loops to get the letter in each board square.  For the letter in each square of the board, a bitmask is calculated for the letter in that square.  This bitmask is then OR\\'ed into the `nextLetters[][]` bitmasks for the four surrounding squares, so that those surrounding squares will eventually have a combined bitmask for their surrounding squares.\\n\\n**Building bitmasks:**` ` ` `In several places in the code below, the letters from the board or from the word are converted to a bitmask.  These bitmasks are used to perform two types of optimizations in the code below: 1) checking for all letters in the word existing on the board, and 2) quickly checking if any surrounding board squares contains the next letter of a word.  Within a bitmask, separate bits are used for each type of letter.   A `long` is needed to contain the bitmasks because the letter-matching is case sensitive, so this would require at least 52 bits (26 uppercase letters plus 26 lowercase letters = 52 bits).  Since an `int` has only 32 bits, this is not enough for the 52 letters to each have their own bit.  Therefore a 64-bit `long` value is needed to contain the bitmask.  In the code below, the bitmask for a letter is calculated with an expression similar to `1L << (letterChar - \\'@\\')`.  If the letterChar is \\'B\\', then this expression will reduce to `1L << (66 - 64)` or further reduce to `1L << 2` which is the `long` value 1 shifted bitwise to the left 2 bit positions, which is 0b100 in binary.  The \"L\" in the expression\\'s \"1L\" is necessary to indicate this is a `long` constant \"1\" and that the calculations should be done as a 64-bit `long`.  If the \"L\" were to be deleted from this expression, then the compiler assumes the \"1\" is an `int` constant and will only do a 32-bit `int` calculation, which will result in incorrect answers from the code below.\\n\\n**Optimization - Scan `board` for first letter of the `word`:**` ` ` `With nested loops, scan each letter of the board, looking for the first letter of the word before starting a recursive DFS search at that board square that contains the word\\'s first letter.\\n\\n**Optimization - Check for `word` can not fit on the `board`:**` ` ` `If the count of letters in the word is greater than the count of squares on the board, then return `false` instead of doing any DFS search or any other processing.  Within the constraints for this leetcode problem, the worst case that this optimization prevents is a 3x4 `board` of all the same letter, with a 13-letter `word` of all that same letter.  If the DFS searching was done on this worst case example, it would be a lot of wasted time searching many many paths but never finding a solution.  In fact, this is one of the leetcode test cases:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"aaaaaaaaaaaaa\"\\n\\n**Optimization - Check for a word that is a single letter**` ` ` `If the passed word is has a length of 1 (i.e. is only a single letter), and after the previous optimization to check if all letters in the word exist somewhere on the board, we can return `true`.  After the optimization to check if all letters in the word exist on the board, we know that the single-letter word has that single letter somewhere on the board, so we know that the entire single-letter word can be found on the board, and no DFS search is needed.\\n\\n**If useful, please upvote.**\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int rowMax = board.length - 1;      // Highest row index.\\n        int colMax = board[0].length - 1;   // Highest column index.\\n        char[] wordC = word.toCharArray();  // word String converted to char[].\\n        char firstLetter = wordC[0];        // First letter of the word\\n\\n        // If the word is too long to possibly fit on the board, then \\n        // immediately return false.\\n        if (wordC.length > (rowMax + 1) * (colMax + 1))  return false;\\n        \\n        // Build a bit mask \\'boardLetters\\' of all letters in the board.  This \\n        // bitmask will be used later to check if all letters in the word, \\n        // exist within the board.  If any letter in the word is not in the \\n        // board then quickly return a false, without any searching the board.\\n        //\\n        // Also build a matrix boardLetters[][] which has the same dimensions \\n        // as the board, but contains bit masks that indicate which letters \\n        // are in the surrounding squares of the board.  This will speed-up \\n        // the search by determining if any surrounding squares contain the \\n        // next letter of the word, BEFORE having to look in the surrounding \\n        // squares.\\n        //\\n        // Since this leetcode problem allows both uppercase and lowercase \\n        // letters, both types of bitmasks must be long variables.  The long \\n        // variables are 64-bits so they can contain a bit for each of the \\n        // 52 letters (26 uppercase + 26 lowercase = 52 letters and so we \\n        // need more than the 32-bits of an int variable).  The \"1L <<\" in \\n        // some of the expressions in the code below, forces the \"<<\" \\n        // shift-left operation to be a long, because the \"L\" after the \\n        // \"1\" indicates that the \"1\" is a long constant.  The \"1\" could also \\n        // be made a long by \"(long)1\" to cast the \"1\" to be a long.  Without \\n        // either of these methods indicating the \"1\" is a long, the code \\n        // will perform the \"<<\" shift-left operation as a 32-bit int and the \\n        // code would fail.\\n        long[][] nextLetters = new long[rowMax + 1][colMax + 1];\\n                                    // Bit-masks of letters in surrounding board squares.\\n        long boardLetters = 0;      // Bit-mask of all letters in the board.\\n        long cBit;\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                cBit = 1L << (board[row][col] - \\'@\\');\\n                boardLetters |= cBit;\\n                if (row > 0)  nextLetters[row - 1][col] |= cBit;\\n                if (col > 0)  nextLetters[row][col - 1] |= cBit;\\n                if (row < rowMax)  nextLetters[row + 1][col] |= cBit;\\n                if (col < colMax)  nextLetters[row][col + 1] |= cBit;\\n            }\\n        }\\n        \\n        // Check to see if all letters in the word exist in the board.  \\n        // If any letters not found in the board, then the word CANNOT exist \\n        // anywhere in the board so return false.  This skips searching the \\n        // board when the word cannot be on the board.\\n        for (int pos = wordC.length - 1; pos >= 0; pos--)\\n            if (((1L << (wordC[pos] - \\'@\\')) & boardLetters) == 0)\\n                return false;\\n\\n        // If the word length is only 1 letter, then no search is needed and \\n        // the word is found.  We previously verified that all letters in the \\n        // word can be found on the board.  But is the word length is only \\n        // 1 letter, and that one letter has been previously verified to \\n        // exist on the board, then the entire 1-letter word exists on the \\n        // board, and we can return true without any further searching.\\n        if (wordC.length == 1)  return true;\\n\\n        // Loop through all squares of the board looking for a square that \\n        // contains the first letter of the word.  When finding a square \\n        // with the same letter as the first letter of the word, then start \\n        // a recursive search for the entire word within the board.\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                if (board[row][col] == firstLetter && \\n                        checkWord(row, col, 0, wordC, board, nextLetters))  \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    // Recursive method to check if the current letter in the word is \\n    // found at the current board position.  If found, then call \\n    // this method recursively to check the surrounding squares of the \\n    // board for the next letter, or if at end of word, then return true \\n    // to show the entire word was found in the board.\\n    //\\n    // During recursion, after matching a letter from the word with a \\n    // letter from the board, then temporarily replace that letter in \\n    // the board with a \"*\" so that the square of the board can\\'t be \\n    // used again if the same letter occurs later in the word.  When \\n    // returning from recursion, replace the \"*\" with the letter that \\n    // was originally in that square of the board.\\n    private boolean checkWord(int row, int col, int pos, char[] wordC, \\n                                char[][] board, long[][] nextLetters)  {\\n        if (row < 0 || row >= board.length || \\n                    col < 0 || col >= board[0].length)  \\n            return false;           // If current board square is outside \\n                                    //   the boundary of the board, then \\n                                    //   not a valid search path.\\n        char c = board[row][col];   // Get current board letter.\\n        if (wordC[pos++] != c)  return false;\\n                                    // If current letter from word does \\n                                    //   not match current board square, \\n                                    //   then word not on this search path.\\n        if (pos == wordC.length)  return true;\\n                                    // If end of word, then word found!!!\\n        if ((1L << (wordC[pos] - \\'@\\') & nextLetters[row][col]) == 0)  \\n            return false;           // If next letter from word not in any \\n                                    //   surrounding square, then no match.\\n        board[row][col] = \\'*\\';      // Temporarily replace square with \"*\".\\n        // board[row][col] ^= 128;      // Temporarily mark square as used.\\n        if (checkWord(row, col+1, pos, wordC, board, nextLetters) ||\\n                checkWord(row, col-1, pos, wordC, board, nextLetters) ||  \\n                checkWord(row+1, col, pos, wordC, board, nextLetters) || \\n                checkWord(row-1, col, pos, wordC, board, nextLetters))\\n            return true;            // Recurse to check surrounding squares \\n                                    //   for remainder of the word.  Return \\n                                    //   true if entire word found in board.\\n        board[row][col] = c;        // Restore square with original letter.\\n        // board[row][col] ^= 128;        // Restore square to unused.\\n        return false;               // Word not found on this search path.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int rowMax = board.length - 1;      // Highest row index.\\n        int colMax = board[0].length - 1;   // Highest column index.\\n        char[] wordC = word.toCharArray();  // word String converted to char[].\\n        char firstLetter = wordC[0];        // First letter of the word\\n\\n        // If the word is too long to possibly fit on the board, then \\n        // immediately return false.\\n        if (wordC.length > (rowMax + 1) * (colMax + 1))  return false;\\n        \\n        // Build a bit mask \\'boardLetters\\' of all letters in the board.  This \\n        // bitmask will be used later to check if all letters in the word, \\n        // exist within the board.  If any letter in the word is not in the \\n        // board then quickly return a false, without any searching the board.\\n        //\\n        // Also build a matrix boardLetters[][] which has the same dimensions \\n        // as the board, but contains bit masks that indicate which letters \\n        // are in the surrounding squares of the board.  This will speed-up \\n        // the search by determining if any surrounding squares contain the \\n        // next letter of the word, BEFORE having to look in the surrounding \\n        // squares.\\n        //\\n        // Since this leetcode problem allows both uppercase and lowercase \\n        // letters, both types of bitmasks must be long variables.  The long \\n        // variables are 64-bits so they can contain a bit for each of the \\n        // 52 letters (26 uppercase + 26 lowercase = 52 letters and so we \\n        // need more than the 32-bits of an int variable).  The \"1L <<\" in \\n        // some of the expressions in the code below, forces the \"<<\" \\n        // shift-left operation to be a long, because the \"L\" after the \\n        // \"1\" indicates that the \"1\" is a long constant.  The \"1\" could also \\n        // be made a long by \"(long)1\" to cast the \"1\" to be a long.  Without \\n        // either of these methods indicating the \"1\" is a long, the code \\n        // will perform the \"<<\" shift-left operation as a 32-bit int and the \\n        // code would fail.\\n        long[][] nextLetters = new long[rowMax + 1][colMax + 1];\\n                                    // Bit-masks of letters in surrounding board squares.\\n        long boardLetters = 0;      // Bit-mask of all letters in the board.\\n        long cBit;\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                cBit = 1L << (board[row][col] - \\'@\\');\\n                boardLetters |= cBit;\\n                if (row > 0)  nextLetters[row - 1][col] |= cBit;\\n                if (col > 0)  nextLetters[row][col - 1] |= cBit;\\n                if (row < rowMax)  nextLetters[row + 1][col] |= cBit;\\n                if (col < colMax)  nextLetters[row][col + 1] |= cBit;\\n            }\\n        }\\n        \\n        // Check to see if all letters in the word exist in the board.  \\n        // If any letters not found in the board, then the word CANNOT exist \\n        // anywhere in the board so return false.  This skips searching the \\n        // board when the word cannot be on the board.\\n        for (int pos = wordC.length - 1; pos >= 0; pos--)\\n            if (((1L << (wordC[pos] - \\'@\\')) & boardLetters) == 0)\\n                return false;\\n\\n        // If the word length is only 1 letter, then no search is needed and \\n        // the word is found.  We previously verified that all letters in the \\n        // word can be found on the board.  But is the word length is only \\n        // 1 letter, and that one letter has been previously verified to \\n        // exist on the board, then the entire 1-letter word exists on the \\n        // board, and we can return true without any further searching.\\n        if (wordC.length == 1)  return true;\\n\\n        // Loop through all squares of the board looking for a square that \\n        // contains the first letter of the word.  When finding a square \\n        // with the same letter as the first letter of the word, then start \\n        // a recursive search for the entire word within the board.\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                if (board[row][col] == firstLetter && \\n                        checkWord(row, col, 0, wordC, board, nextLetters))  \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    // Recursive method to check if the current letter in the word is \\n    // found at the current board position.  If found, then call \\n    // this method recursively to check the surrounding squares of the \\n    // board for the next letter, or if at end of word, then return true \\n    // to show the entire word was found in the board.\\n    //\\n    // During recursion, after matching a letter from the word with a \\n    // letter from the board, then temporarily replace that letter in \\n    // the board with a \"*\" so that the square of the board can\\'t be \\n    // used again if the same letter occurs later in the word.  When \\n    // returning from recursion, replace the \"*\" with the letter that \\n    // was originally in that square of the board.\\n    private boolean checkWord(int row, int col, int pos, char[] wordC, \\n                                char[][] board, long[][] nextLetters)  {\\n        if (row < 0 || row >= board.length || \\n                    col < 0 || col >= board[0].length)  \\n            return false;           // If current board square is outside \\n                                    //   the boundary of the board, then \\n                                    //   not a valid search path.\\n        char c = board[row][col];   // Get current board letter.\\n        if (wordC[pos++] != c)  return false;\\n                                    // If current letter from word does \\n                                    //   not match current board square, \\n                                    //   then word not on this search path.\\n        if (pos == wordC.length)  return true;\\n                                    // If end of word, then word found!!!\\n        if ((1L << (wordC[pos] - \\'@\\') & nextLetters[row][col]) == 0)  \\n            return false;           // If next letter from word not in any \\n                                    //   surrounding square, then no match.\\n        board[row][col] = \\'*\\';      // Temporarily replace square with \"*\".\\n        // board[row][col] ^= 128;      // Temporarily mark square as used.\\n        if (checkWord(row, col+1, pos, wordC, board, nextLetters) ||\\n                checkWord(row, col-1, pos, wordC, board, nextLetters) ||  \\n                checkWord(row+1, col, pos, wordC, board, nextLetters) || \\n                checkWord(row-1, col, pos, wordC, board, nextLetters))\\n            return true;            // Recurse to check surrounding squares \\n                                    //   for remainder of the word.  Return \\n                                    //   true if entire word found in board.\\n        board[row][col] = c;        // Restore square with original letter.\\n        // board[row][col] ^= 128;        // Restore square to unused.\\n        return false;               // Word not found on this search path.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346841,
                "title": "swift-solution-clean-easy-understand",
                "content": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        guard board.count != 0, board[0].count != 0, word.count != 0 else { return false }\\n        \\n        let word = Array(word)\\n        let rows = board.count, cols = board[0].count\\n        var isVisited = Array(repeating: Array(repeating: false, count: cols), count: rows)\\n        \\n        for row in 0..<rows {\\n            for col in 0..<cols where board[row][col] == word.first {\\n                if check(board, word, row, col, 0, &isVisited) {\\n                    return true\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func check(_ board: [[Character]], _ word: [Character], _ row: Int, _ col: Int, _ index: Int, _ isVisited: inout [[Bool]]) -> Bool {\\n        // check if reached the end\\n        guard index < word.count else { return true }\\n        \\n        // check if it match requirements\\n        guard   row >= 0, \\n                row < board.count, \\n                col >= 0, \\n                col < board[0].count,\\n                !isVisited[row][col],\\n                board[row][col] == word[index]\\n                else { return false }\\n        \\n        // once we found matched case, we mark isVisited as true\\n        isVisited[row][col] = true\\n        \\n        // try each way, to find if there any valid path\\n        let hasValidPath =  check(board, word, row-1, col, index+1, &isVisited) ||  // go up\\n                            check(board, word, row+1, col, index+1, &isVisited) ||  // go down\\n                            check(board, word, row, col-1, index+1, &isVisited) ||  // go left\\n                            check(board, word, row, col+1, index+1, &isVisited)     // go right\\n        \\n        // reset isVisited after each DFS search, for re use\\n        isVisited[row][col] = false\\n        \\n        return hasValidPath\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        guard board.count != 0, board[0].count != 0, word.count != 0 else { return false }\\n        \\n        let word = Array(word)\\n        let rows = board.count, cols = board[0].count\\n        var isVisited = Array(repeating: Array(repeating: false, count: cols), count: rows)\\n        \\n        for row in 0..<rows {\\n            for col in 0..<cols where board[row][col] == word.first {\\n                if check(board, word, row, col, 0, &isVisited) {\\n                    return true\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func check(_ board: [[Character]], _ word: [Character], _ row: Int, _ col: Int, _ index: Int, _ isVisited: inout [[Bool]]) -> Bool {\\n        // check if reached the end\\n        guard index < word.count else { return true }\\n        \\n        // check if it match requirements\\n        guard   row >= 0, \\n                row < board.count, \\n                col >= 0, \\n                col < board[0].count,\\n                !isVisited[row][col],\\n                board[row][col] == word[index]\\n                else { return false }\\n        \\n        // once we found matched case, we mark isVisited as true\\n        isVisited[row][col] = true\\n        \\n        // try each way, to find if there any valid path\\n        let hasValidPath =  check(board, word, row-1, col, index+1, &isVisited) ||  // go up\\n                            check(board, word, row+1, col, index+1, &isVisited) ||  // go down\\n                            check(board, word, row, col-1, index+1, &isVisited) ||  // go left\\n                            check(board, word, row, col+1, index+1, &isVisited)     // go right\\n        \\n        // reset isVisited after each DFS search, for re use\\n        isVisited[row][col] = false\\n        \\n        return hasValidPath\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27892,
                "title": "ac-in-84ms-by-using-dfs",
                "content": "I used DFS,  and got AC in 84ms, any improvement?\\n\\n    class Solution {\\n    private:\\n        vector<vector<char> > *board;\\n        string *word;\\n        bool **used;\\n    private:\\n        bool isInboard(int i, int j)\\n        {\\n            if(i < 0)return false;\\n            if(i >= board->size())return false;\\n            if(j < 0)return false;\\n            if(j >= (*board)[i].size())return false;\\n            return true;\\n        }\\n        \\n        bool DFS(int si, int sj, int n)\\n        {\\n            if(n == word->size())return true;\\n            if(isInboard(si, sj))\\n            {\\n                if(!used[si][sj] && (*board)[si][sj] == (*word)[n])\\n                {\\n                    used[si][sj] = true;\\n                    bool ret = false;\\n                    if(DFS(si+1, sj, n+1))\\n                        ret = true;\\n                    else if(DFS(si-1, sj, n+1))\\n                        ret = true;\\n                    else if(DFS(si, sj+1, n+1))\\n                        ret = true;\\n                    else if(DFS(si, sj-1, n+1))\\n                        ret = true;\\n                    used[si][sj] = false;\\n                    return ret;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    public:\\n        bool exist(vector<vector<char> > &board, string word) {\\n            if(board.size() == 0)return false;\\n            this->board = &board;\\n            this->word = &word;\\n            used = new bool*[board.size()];\\n            for(int i = 0; i < board.size(); i ++)\\n            {\\n                used[i] = new bool[board[i].size()];\\n                for(int j = 0; j < board[i].size(); j ++)\\n                    used[i][j] = false;\\n            }\\n            for(int i = 0; i < board.size(); i ++)\\n                for(int j = 0; j < board[i].size(); j ++)\\n                    if(DFS(i, j, 0))return true;\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        vector<vector<char> > *board;\\n        string *word;\\n        bool **used;\\n    private:\\n        bool isInboard(int i, int j)\\n        {\\n            if(i < 0)return false;\\n            if(i >= board->size())return false;\\n            if(j < 0)return false;\\n            if(j >= (*board)[i].size())return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2499933,
                "title": "c-solution-dfs-traversal-backtracking-easiest-solution",
                "content": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>> &board,vector<vector<int>> &visited,string &word,int i,int j,int idx){\\n        // base case\\n        if(idx == word.size()) return true;\\n\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || visited[i][j] == 1 || board[i][j] != word[idx]){\\n            return false;\\n        }\\n\\n        // Marking visited\\n        visited[i][j] = 1;\\n\\n        // traversing all side\\n        bool ls = dfs(board,visited,word,i,j-1,idx+1); // left\\n        bool rs = dfs(board,visited,word,i,j+1,idx+1); // right\\n        bool ds = dfs(board,visited,word,i+1,j,idx+1); // down\\n        bool us = dfs(board,visited,word,i-1,j,idx+1); // up\\n\\n        // Backtracking (If no one is found suitable match)\\n        visited[i][j] = 0;\\n\\n        return ls | rs | ds | us;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j] == 0 && word[0] == board[i][j]){\\n                    if(dfs(board,visited,word,i,j,0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>> &board,vector<vector<int>> &visited,string &word,int i,int j,int idx){\\n        // base case\\n        if(idx == word.size()) return true;\\n\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || visited[i][j] == 1 || board[i][j] != word[idx]){\\n            return false;\\n        }\\n\\n        // Marking visited\\n        visited[i][j] = 1;\\n\\n        // traversing all side\\n        bool ls = dfs(board,visited,word,i,j-1,idx+1); // left\\n        bool rs = dfs(board,visited,word,i,j+1,idx+1); // right\\n        bool ds = dfs(board,visited,word,i+1,j,idx+1); // down\\n        bool us = dfs(board,visited,word,i-1,j,idx+1); // up\\n\\n        // Backtracking (If no one is found suitable match)\\n        visited[i][j] = 0;\\n\\n        return ls | rs | ds | us;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j] == 0 && word[0] == board[i][j]){\\n                    if(dfs(board,visited,word,i,j,0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389952,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27829,
                "title": "c-backtracking-solution-without-extra-data-structure",
                "content": "Use board itself to mark whether we have visited it before.\\n\\n    class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if (board.size() == 0) return false;\\n            for (int i=0; i<board.size(); ++i) {\\n                for (int j=0; j<board[i].size(); ++j) {\\n                    if (search(board, word, i, j, 0)) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        bool search(vector<vector<char>>& board, string word, int i, int j, int pos) {\\n            \\n            if (pos == word.size()) return true;\\n            if ((i<0) || (i >= board.size()) || (j <0) || (j >= board[i].size())) return false;\\n            char c = board[i][j];\\n            if (c == word[pos]) {\\n                board[i][j] = '#';\\n                if (search(board, word, i - 1, j, pos + 1)) return true;\\n                if (search(board, word, i+1, j, pos+1)) return true;\\n                if (search(board, word, i, j-1, pos+1)) return true;\\n                if (search(board, word, i, j+1, pos+1)) return true;\\n                board[i][j] = c;\\n            }\\n            return false;\\n            \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if (board.size() == 0) return false;\\n            for (int i=0; i<board.size(); ++i) {\\n                for (int j=0; j<board[i].size(); ++j) {\\n                    if (search(board, word, i, j, 0)) return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2781495,
                "title": "java-clean-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. Using a visited boolean array:\\nWe use a visited boolean array to mark if we have already visited a certain position or not.\\nWhile looking for the next letter, we set the current position to `true`, then we call our DFS then set the position back to `false` because if we don\\'t find the word, we might have to visit that position again during future iterations and DFS calls.\\n```\\nclass Solution {\\n    private boolean[][] visited;\\n    \\n    public boolean exist(char[][] board, String word) {\\n\\t    int m = board.length, n = board[0].length;\\n        visited = new boolean[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index) || visited[i][j]) {\\n            return false;\\n        }\\n            \\n        visited[i][j] = true;\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        visited[i][j] = false;\\n\\t\\t\\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```\\n##### 2. Marking if visited in place:\\nWe mark a certain position as visited by changing the value to some character, say whitespace (`\\' \\'`), after our calls are done, we set it back to the original character.\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index)) {\\n            return false;\\n        }\\n            \\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        board[i][j] = temp;\\n        \\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private boolean[][] visited;\\n    \\n    public boolean exist(char[][] board, String word) {\\n\\t    int m = board.length, n = board[0].length;\\n        visited = new boolean[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index) || visited[i][j]) {\\n            return false;\\n        }\\n            \\n        visited[i][j] = true;\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        visited[i][j] = false;\\n\\t\\t\\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index)) {\\n            return false;\\n        }\\n            \\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        board[i][j] = temp;\\n        \\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764505,
                "title": "tle-8000ms-3500ms-finally-python-with-no-tle-pro-optimization-hushh",
                "content": "**Optimization number 1**\\n* Using if -elif instead of for loop helped me resolve TLE:\\nAs if will return as soon as it gets TRUE, for will keep checking next conditions.\\n(Even multiple \"or\" did\\'nt work for me)\\n\\n**\"PLEASE UPVOTE FOR MY AN HOUR SPENT\"**\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:         \\n\\t\\t# as start is not restricted to 0,0 we can start from anywhere, will loop\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n\\t\\t# return True if can make word starting from x, y\\n        if len(word)==c:\\n            return True    \\n\\t\\t# Exit if out of board or char is not required\\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n\\t\\t# move ahead by marking board in path just not to visit again\\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n\\t\\t# if from x,y no one making True, we need to restore x, y as it is not in path\\n\\t\\t# so it is open to use by other paths\\n        board[x][y] = word[c]\\n        return False\\n```\\n\\n**Optimization Pro Max number 2**\\n* Check char in starting only\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:       \\n        # Count number of letters in board and store it in a dictionary\\n        boardDic = collections.defaultdict(int)\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                boardDic[board[i][j]] += 1\\n\\n        # Count number of letters in word\\n        # Check if board has all the letters in the word and they are atleast same count from word\\n        wordDic = collections.Counter(word)\\n        for c in wordDic:\\n            if c not in boardDic or boardDic[c] < wordDic[c]:\\n                return False\\n            \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n        if len(word)==c:\\n            return True    \\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n        board[x][y] = word[c]\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/f789f496-2899-40a4-8966-55302cc3843f_1667244477.9827275.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:         \\n\\t\\t# as start is not restricted to 0,0 we can start from anywhere, will loop\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n\\t\\t# return True if can make word starting from x, y\\n        if len(word)==c:\\n            return True    \\n\\t\\t# Exit if out of board or char is not required\\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n\\t\\t# move ahead by marking board in path just not to visit again\\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n\\t\\t# if from x,y no one making True, we need to restore x, y as it is not in path\\n\\t\\t# so it is open to use by other paths\\n        board[x][y] = word[c]\\n        return False\\n```\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:       \\n        # Count number of letters in board and store it in a dictionary\\n        boardDic = collections.defaultdict(int)\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                boardDic[board[i][j]] += 1\\n\\n        # Count number of letters in word\\n        # Check if board has all the letters in the word and they are atleast same count from word\\n        wordDic = collections.Counter(word)\\n        for c in wordDic:\\n            if c not in boardDic or boardDic[c] < wordDic[c]:\\n                return False\\n            \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n        if len(word)==c:\\n            return True    \\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n        board[x][y] = word[c]\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692185,
                "title": "javascript-clean-dfs-solution",
                "content": "```javascript\\nvar exist = function(board, word) {\\n    const ROW_NUM = board.length, COL_NUM = board[0].length;\\n    \\n    function callDFS(r, c, idx) {\\n        if(word.length === idx) return true;\\n        if(r >= ROW_NUM || r < 0 || board[r][c] !== word[idx]) return false; \\n        \\n        board[r][c] = \\'#\\'; // mark as visited\\n        \\n        if (callDFS(r+1, c, idx+1)||\\n            callDFS(r-1, c, idx+1)||\\n            callDFS(r, c+1, idx+1)||\\n            callDFS(r, c-1, idx+1)) return true;\\n            \\n        board[r][c] = word[idx]; // reset the board\\n    }\\n    \\n    for(let r = 0; r < ROW_NUM; r++) {\\n        for(let c = 0; c < COL_NUM; c++) {\\n            if(board[r][c] === word[0] && callDFS(r, c, 0)) return true;\\n        }\\n    }\\n    return false;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar exist = function(board, word) {\\n    const ROW_NUM = board.length, COL_NUM = board[0].length;\\n    \\n    function callDFS(r, c, idx) {\\n        if(word.length === idx) return true;\\n        if(r >= ROW_NUM || r < 0 || board[r][c] !== word[idx]) return false; \\n        \\n        board[r][c] = \\'#\\'; // mark as visited\\n        \\n        if (callDFS(r+1, c, idx+1)||\\n            callDFS(r-1, c, idx+1)||\\n            callDFS(r, c+1, idx+1)||\\n            callDFS(r, c-1, idx+1)) return true;\\n            \\n        board[r][c] = word[idx]; // reset the board\\n    }\\n    \\n    for(let r = 0; r < ROW_NUM; r++) {\\n        for(let c = 0; c < COL_NUM; c++) {\\n            if(board[r][c] === word[0] && callDFS(r, c, 0)) return true;\\n        }\\n    }\\n    return false;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361698,
                "title": "cpp-solution-20-ms-runtime-better-than-100-memory-usage",
                "content": "Implements a simple DFS; Code is commented where I thought necessary, hope this helps. Comment if you have any queries!\\n\\n\\tclass Solution {\\n\\tpulic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n\\t\\t\\tif(board.empty())\\n\\t\\t\\t\\treturn false;\\n        \\n\\t\\t\\tfor(int i=0; i<board.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0; j<board[0].size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(dfs(board, 0, i, j, word))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n        return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>&board, int count, int i, int j, string& word)\\n    {\\n        if(word.size() == count) //Signifies that we have reached the end of search\\n            return true;\\n        \\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || board[i][j]!=word[count])\\n\\t\\treturn false;\\n        //We check if element is within bounds and then check if the character at that is the same as the corresponding character in string word\\n            \\n    \\n        char temp = board[i][j];\\n        board[i][j] = \\' \\'; //To show that we have visited this node\\n        \\n        bool res = dfs(board, count+1, i+1, j, word) || dfs(board, count+1, i-1, j, word) || dfs(board, count+1, i, j+1, word) ||dfs(board, count+1, i, j-1, word); //DFS in all 4 directions\\n        \\n        board[i][j] = temp; //Restore the element after checking\\n        \\n        return res;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpulic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n\\t\\t\\tif(board.empty())\\n\\t\\t\\t\\treturn false;\\n        \\n\\t\\t\\tfor(int i=0; i<board.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0; j<board[0].size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(dfs(board, 0, i, j, word))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 27791,
                "title": "99-77-python-solution-with-precheck",
                "content": "    class Solution(object):\\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def preCheck():\\n            preDict = {}\\n\\n            for i in word:\\n                if i in preDict: preDict[i]+=1\\n                else: preDict[i] = 1\\n            \\n            for i in board:\\n                for j in i:\\n                    if j in preDict and preDict[j]>0: preDict[j]-=1\\n            for i in preDict.values():\\n                if i>0: return False\\n            return True\\n                    \\n        def helper(wordIdx, x, y):\\n            if board[x][y] != word[wordIdx]: return False\\n            elif wordIdx == l-1: return True\\n            else:\\n                wordIdx += 1\\n                tempChar = board[x][y]\\n                board[x][y] = None\\n                for d in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                    xNext = x+d[0]\\n                    yNext = y+d[1]\\n                    if -1<xNext<m and -1<yNext<n and board[xNext][yNext]: \\n                        if helper(wordIdx, xNext, yNext): return True\\n                board[x][y] = tempChar\\n                return False\\n        \\n        if not board: return False\\n        if not word: return True\\n\\n        if not preCheck(): return False\\n        \\n        m = len(board)\\n        n = len(board[0])\\n        l = len(word)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if helper(0,i,j): return True\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def preCheck():\\n            preDict = {}",
                "codeTag": "Java"
            },
            {
                "id": 27799,
                "title": "c-solution-using-backtracking",
                "content": "    class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0 || board[0].size()==0 )\\n                return true;\\n            \\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[0].size(); j++){\\n                    if(check(board, word, i, j))\\n                        return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        bool check(vector<vector<char>>& board, string word, int i, int j){\\n            if(word.length()==0)\\n                return true;\\n            if(i<0 || j<0 ||i>=board.size() ||j>=board[0].size())\\n                return false;\\n            if(word[0]==board[i][j]){\\n                char c = word[0];\\n                board[i][j]='\\\\0';\\n                if(check(board,word.substr(1), i+1, j)||\\n                    check(board,word.substr(1), i-1, j)||\\n                    check(board,word.substr(1), i, j+1)||\\n                    check(board,word.substr(1), i, j-1))\\n                    return true;\\n                board[i][j]=c;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0 || board[0].size()==0 )\\n                return true;\\n            \\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[0].size(); j++){\\n                    if(check(board, word, i, j))\\n                        return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2778070,
                "title": "java-solutions-easy-to-solve",
                "content": "```\\npublic class Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[i].length; j++){\\n                if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(char[][]board, String word, int i, int j, int index){\\n        if(index == word.length()){\\n            return true;\\n        }\\n        \\n        if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || board[i][j] != word.charAt(index) || visited[i][j]){\\n            return false;\\n        }\\n        \\n        visited[i][j] = true;\\n        if(search(board, word, i-1, j, index+1) || \\n           search(board, word, i+1, j, index+1) ||\\n           search(board, word, i, j-1, index+1) || \\n           search(board, word, i, j+1, index+1)){\\n            return true;\\n        }\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[i].length; j++){\\n                if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(char[][]board, String word, int i, int j, int index){\\n        if(index == word.length()){\\n            return true;\\n        }\\n        \\n        if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || board[i][j] != word.charAt(index) || visited[i][j]){\\n            return false;\\n        }\\n        \\n        visited[i][j] = true;\\n        if(search(board, word, i-1, j, index+1) || \\n           search(board, word, i+1, j, index+1) ||\\n           search(board, word, i, j-1, index+1) || \\n           search(board, word, i, j+1, index+1)){\\n            return true;\\n        }\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045876,
                "title": "simple-c-solution-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool issafe(vector<vector<char>>& board,int i, int j,string word, int k){\\n        if(board[i][j]==word[k]){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board,int i, int j,int m,int n,string word, int k){\\n        if(k==word.size()){\\n            return true;\\n        }\\n        if(i < 0 || i == m || j < 0 || j == n){\\n            return false;\\n        }\\n        if(issafe(board,i,j,word,k)){\\n            char temp=board[i][j];\\n            board[i][j]=\\'0\\';\\n            if((solve(board,i+1,j,m,n,word,k+1) || solve(board,i-1,j,m,n,word,k+1) || solve(board,i,j+1,m,n,word,k+1) || solve(board,i,j-1,m,n,word,k+1))){\\n                return true;\\n            }\\n            //backtracking\\n             board[i][j]=temp;\\n        }\\n        \\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(solve(board,i,j,m,n,word,k)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool issafe(vector<vector<char>>& board,int i, int j,string word, int k){\\n        if(board[i][j]==word[k]){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board,int i, int j,int m,int n,string word, int k){\\n        if(k==word.size()){\\n            return true;\\n        }\\n        if(i < 0 || i == m || j < 0 || j == n){\\n            return false;\\n        }\\n        if(issafe(board,i,j,word,k)){\\n            char temp=board[i][j];\\n            board[i][j]=\\'0\\';\\n            if((solve(board,i+1,j,m,n,word,k+1) || solve(board,i-1,j,m,n,word,k+1) || solve(board,i,j+1,m,n,word,k+1) || solve(board,i,j-1,m,n,word,k+1))){\\n                return true;\\n            }\\n            //backtracking\\n             board[i][j]=temp;\\n        }\\n        \\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(solve(board,i,j,m,n,word,k)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747440,
                "title": "without-using-visited-array-6ms-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for(int i = 0; i < board.length; i++)\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && isFound(board, i, j, word, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean isFound(char[][] board, int i, int j, String word, int index) {\\n        if(index == word.length()) return true;\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length) return false;\\n        if(word.charAt(index) != board[i][j]) return false;\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n        if(isFound(board, i + 1, j, word, index + 1) ||\\n            isFound(board, i - 1, j, word, index + 1) ||\\n            isFound(board, i, j + 1, word, index + 1) ||\\n            isFound(board, i, j - 1, word, index + 1))\\n            return true;\\n        board[i][j] = temp;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for(int i = 0; i < board.length; i++)\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && isFound(board, i, j, word, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean isFound(char[][] board, int i, int j, String word, int index) {\\n        if(index == word.length()) return true;\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length) return false;\\n        if(word.charAt(index) != board[i][j]) return false;\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n        if(isFound(board, i + 1, j, word, index + 1) ||\\n            isFound(board, i - 1, j, word, index + 1) ||\\n            isFound(board, i, j + 1, word, index + 1) ||\\n            isFound(board, i, j - 1, word, index + 1))\\n            return true;\\n        board[i][j] = temp;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747095,
                "title": "c-dfs-with-explanation",
                "content": "### Approach\\n1. Search the board for the first letter in the word.\\n2. When we encouter that letter set index to 0 perform DFS. (index - 0 = first letter of word)\\n\\t1. Use a visited array to mark the letters we visited to avoid duplicates\\n\\t2. increment the index to look for the next letter in the word.\\n\\t3. If we have reached the end of the word return true.\\n\\t4. Go to the adjacent 4 cells and see if the next letter is true.\\n\\t5. Each of the adjacent elements will also perform the same process\\n\\t5. If any of the adjacent cell returns true return true.\\n\\t6. If none of the neighbours returned true. mark this node as unvisited and return false\\n3. If any of the starting letter DFS searches return true the return true\\n4. If word was not found return false\\n\\nNOTE: \\n1. Checkbounds function\\nThis function checks if the given indices are valid\\n2. To iterate adjacent cells we use vector - dirs {0,1},{0,-1},{1,0},{-1,0}\\nThese four values will be added to the current index to get new indices.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkBounds(int i,int j,int r,int c){\\n        return i>=0 && i<r && j>=0 && j<c;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,vector<vector<int>>& visited,string& word,int i,int j,int p,int r,int c){\\n        if(visited[i][j]) return false;\\n        visited[i][j] = 1;\\n        p++;\\n        if(p == word.length()) return true;\\n        vector<pair<int,int>>dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        for(auto dir : dirs){\\n            int ii = i+dir.first, jj=j+dir.second;\\n            if(checkBounds(ii,jj,r,c) && board[ii][jj] == word[p] && dfs(board,visited,word,ii,jj,p,r,c)){\\n                return true;\\n            }\\n        }\\n        visited[i][j] = 0;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        char s = word[0];\\n        vector<vector<int>>visited(r,vector<int>(c));\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j] == s && dfs(board,visited,word,i,j,0,r,c)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkBounds(int i,int j,int r,int c){\\n        return i>=0 && i<r && j>=0 && j<c;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,vector<vector<int>>& visited,string& word,int i,int j,int p,int r,int c){\\n        if(visited[i][j]) return false;\\n        visited[i][j] = 1;\\n        p++;\\n        if(p == word.length()) return true;\\n        vector<pair<int,int>>dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        for(auto dir : dirs){\\n            int ii = i+dir.first, jj=j+dir.second;\\n            if(checkBounds(ii,jj,r,c) && board[ii][jj] == word[p] && dfs(board,visited,word,ii,jj,p,r,c)){\\n                return true;\\n            }\\n        }\\n        visited[i][j] = 0;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        char s = word[0];\\n        vector<vector<int>>visited(r,vector<int>(c));\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j] == s && dfs(board,visited,word,i,j,0,r,c)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378925,
                "title": "java-clean-dfs-backtracking-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        /* ensure all the nodes will be searched as the beginning point */\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (dfs(i, j, 0, board, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(int row, int col, int index, char[][] board, String word) {\\n        /*  1. out of bound \\n            2. already visited\\n            3. not match    */\\n        if (checkBound(row, col, board) == -1 || \\n            visited[row][col] || \\n            word.charAt(index) != board[row][col]) {\\n            return false;\\n        }\\n        \\n        /* find one matched character, mark the current node as visited */\\n        visited[row][col] = true;\\n        \\n        /* find the whole word! */\\n        if (index == word.length() - 1) {\\n            return true;\\n        }\\n        \\n        /* continue searching the next char by extending the index of string,\\n        note that the current char may not belong to the word in the final.\\n        even though it matches until now */\\n        index++;\\n    \\n        /* down, right, up, left search */\\n        if (dfs(row + 1, col, index, board, word) ||\\n            dfs(row, col + 1, index, board, word) ||\\n            dfs(row - 1, col, index, board, word) ||\\n            dfs(row, col - 1, index, board, word)) {\\n                return true;\\n            }\\n        \\n        /* current position is wrong, backtracking */\\n        visited[row][col] = false;\\n        return false;\\n    }\\n    \\n    private int checkBound(int row, int col, char[][] board) {\\n        if (row == -1 || row == board.length || col == -1 || col == board[0].length) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        /* ensure all the nodes will be searched as the beginning point */\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (dfs(i, j, 0, board, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(int row, int col, int index, char[][] board, String word) {\\n        /*  1. out of bound \\n            2. already visited\\n            3. not match    */\\n        if (checkBound(row, col, board) == -1 || \\n            visited[row][col] || \\n            word.charAt(index) != board[row][col]) {\\n            return false;\\n        }\\n        \\n        /* find one matched character, mark the current node as visited */\\n        visited[row][col] = true;\\n        \\n        /* find the whole word! */\\n        if (index == word.length() - 1) {\\n            return true;\\n        }\\n        \\n        /* continue searching the next char by extending the index of string,\\n        note that the current char may not belong to the word in the final.\\n        even though it matches until now */\\n        index++;\\n    \\n        /* down, right, up, left search */\\n        if (dfs(row + 1, col, index, board, word) ||\\n            dfs(row, col + 1, index, board, word) ||\\n            dfs(row - 1, col, index, board, word) ||\\n            dfs(row, col - 1, index, board, word)) {\\n                return true;\\n            }\\n        \\n        /* current position is wrong, backtracking */\\n        visited[row][col] = false;\\n        return false;\\n    }\\n    \\n    private int checkBound(int row, int col, char[][] board) {\\n        if (row == -1 || row == board.length || col == -1 || col == board[0].length) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844418,
                "title": "java-solution-dfs-backtracking-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean [][] visited;\\n    int n,m;\\n    public boolean exist(char[][] board, String word) {\\n        n=board.length;\\n        m=board[0].length;\\n        visited=new boolean[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==word.charAt(0)){\\n                    if(valid(i,j,0,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean valid(int i,int j,int count,char [][] board,String word){\\n        /*-------------base conditions-------------*/\\n        //out of bound\\n        if(i<0 || i>=n || j<0 || j>=m ){\\n            return false;\\n        }\\n\\n        //if already visited\\n        if(visited[i][j]){\\n            return false;\\n        }\\n\\n        //mismatch\\n        if(word.charAt(count)!=board[i][j]){\\n            return false;\\n        }\\n\\n        //if word is found\\n        if(count==word.length()-1){\\n            return true;\\n        }\\n\\n        /*----------------calculation and recursive calls----------*/\\n\\n        //mark current visited\\n        visited[i][j]=true;\\n\\n        //inc count\\n        count++;\\n\\n        //down,right,up,left search\\n        if(valid(i+1,j,count,board,word) ||\\n           valid(i,j+1,count,board,word) ||\\n           valid(i-1,j,count,board,word) ||\\n           valid(i,j-1,count,board,word) ){\\n               return true;\\n           }\\n        \\n        //mark current cell unvisited\\n        visited[i][j]=false;\\n        \\n        return false;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    boolean [][] visited;\\n    int n,m;\\n    public boolean exist(char[][] board, String word) {\\n        n=board.length;\\n        m=board[0].length;\\n        visited=new boolean[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==word.charAt(0)){\\n                    if(valid(i,j,0,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean valid(int i,int j,int count,char [][] board,String word){\\n        /*-------------base conditions-------------*/\\n        //out of bound\\n        if(i<0 || i>=n || j<0 || j>=m ){\\n            return false;\\n        }\\n\\n        //if already visited\\n        if(visited[i][j]){\\n            return false;\\n        }\\n\\n        //mismatch\\n        if(word.charAt(count)!=board[i][j]){\\n            return false;\\n        }\\n\\n        //if word is found\\n        if(count==word.length()-1){\\n            return true;\\n        }\\n\\n        /*----------------calculation and recursive calls----------*/\\n\\n        //mark current visited\\n        visited[i][j]=true;\\n\\n        //inc count\\n        count++;\\n\\n        //down,right,up,left search\\n        if(valid(i+1,j,count,board,word) ||\\n           valid(i,j+1,count,board,word) ||\\n           valid(i-1,j,count,board,word) ||\\n           valid(i,j-1,count,board,word) ){\\n               return true;\\n           }\\n        \\n        //mark current cell unvisited\\n        visited[i][j]=false;\\n        \\n        return false;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094020,
                "title": "0ms-tle-explained-100-faster",
                "content": "Do upvote\\n# Sol #1. DFS (800ms)\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\\n* This solution will take around 800ms\\n* you will get **TLE** if *arr* is passed by value like this in *dfs* function ```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\\n\\n\\n# Sol #2. DFS with Pruning  0ms sol\\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```\\n* **We use the same DFS with some prior analysis.**\\n* **Prune 3 is for such cases**\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"]]\\n\"AAAAAAAAAAAAAAB\"\\nit changes word to \"BAAAAAAAAAAAAAA\"\\n![image](https://assets.leetcode.com/users/images/c4161e1c-960a-47f8-a4d1-903ae22cbbcc_1653990215.8375807.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\n```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918866,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let chs = reverseIfNeeded(Array(word))\\n        if isValid(board, chs) == false { return false }\\n        var res = false\\n        \\n        func backtrack(_ path: [[Int]], _ position: [Int], _ target: Int) {\\n            if res || path.count == target { res = true; return }\\n            \\n            let char = chs[path.count]\\n            let positions = next(board, position, char)\\n            var path = path\\n            \\n            for position in positions {\\n                if path.contains(position) { continue }\\n                \\n                path.append(position)\\n                backtrack(path, position, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtrack([], [-1, -1], chs.count)\\n        return res\\n    }\\n\\n    \\n    func isValid(_ board: [[Character]], _ chars: [Character]) -> Bool {\\n        var res = true\\n        \\n        loop1: for c in chars {\\n            var tmp = false\\n            \\n            loop2: for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == c { tmp = true; break loop2 }\\n                }\\n            }\\n            \\n            if tmp == false { res = false; break loop1 }\\n        }\\n        \\n        return res\\n    }\\n\\n    \\n    func reverseIfNeeded(_ chars: [Character]) -> [Character] {\\n        var headCount = 0\\n        var tailCount = 0\\n        \\n        for c in chars {\\n            if c == chars[0] {\\n                headCount += 1\\n            }\\n            if c == chars[chars.count - 1] {\\n                tailCount += 1\\n            }\\n        }\\n        \\n        if tailCount < headCount {\\n            return chars.reversed()\\n        \\n        } else {\\n            return chars\\n        }\\n    }\\n\\n    \\n    func next(_ board: [[Character]], _ position: [Int], _ char: Character) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        if position[0] == -1 {\\n            for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == char {\\n                        res.append([i, j])\\n                    }\\n                }\\n            }\\n        } else {\\n            var c: Character = \" \"\\n            \\n            if position[0] > 0 {\\n                let i = position[0] - 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[0] < board.count - 1 {\\n                let i = position[0] + 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] > 0 {\\n                let i = position[0]\\n                let j = position[1] - 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] < board[0].count - 1 {\\n                let i = position[0]\\n                let j = position[1] + 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let chs = reverseIfNeeded(Array(word))\\n        if isValid(board, chs) == false { return false }\\n        var res = false\\n        \\n        func backtrack(_ path: [[Int]], _ position: [Int], _ target: Int) {\\n            if res || path.count == target { res = true; return }\\n            \\n            let char = chs[path.count]\\n            let positions = next(board, position, char)\\n            var path = path\\n            \\n            for position in positions {\\n                if path.contains(position) { continue }\\n                \\n                path.append(position)\\n                backtrack(path, position, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtrack([], [-1, -1], chs.count)\\n        return res\\n    }\\n\\n    \\n    func isValid(_ board: [[Character]], _ chars: [Character]) -> Bool {\\n        var res = true\\n        \\n        loop1: for c in chars {\\n            var tmp = false\\n            \\n            loop2: for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == c { tmp = true; break loop2 }\\n                }\\n            }\\n            \\n            if tmp == false { res = false; break loop1 }\\n        }\\n        \\n        return res\\n    }\\n\\n    \\n    func reverseIfNeeded(_ chars: [Character]) -> [Character] {\\n        var headCount = 0\\n        var tailCount = 0\\n        \\n        for c in chars {\\n            if c == chars[0] {\\n                headCount += 1\\n            }\\n            if c == chars[chars.count - 1] {\\n                tailCount += 1\\n            }\\n        }\\n        \\n        if tailCount < headCount {\\n            return chars.reversed()\\n        \\n        } else {\\n            return chars\\n        }\\n    }\\n\\n    \\n    func next(_ board: [[Character]], _ position: [Int], _ char: Character) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        if position[0] == -1 {\\n            for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == char {\\n                        res.append([i, j])\\n                    }\\n                }\\n            }\\n        } else {\\n            var c: Character = \" \"\\n            \\n            if position[0] > 0 {\\n                let i = position[0] - 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[0] < board.count - 1 {\\n                let i = position[0] + 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] > 0 {\\n                let i = position[0]\\n                let j = position[1] - 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] < board[0].count - 1 {\\n                let i = position[0]\\n                let j = position[1] + 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653308,
                "title": "some-thoughts-about-the-follow-up-pruning",
                "content": "Since there are already many excellent posts discussing the solution, I\\'ll ignore the discussion of the solution and go directly with the follow up. My solution used backtracking.\\n\\nA very common way for pruning is memoization, in which, we keep record of the \"state\" and the corresponding \"answer\". And once we encounter the same \"state\" again, we can return the \"answer\" directly instead of stepping into the recursion and calculate the answer again. Next, I\\'ll explain how this is implemented and why **memoization doesn\\'t work in this problem**.\\n\\nIn this backtracking, there are three states: the integer i and j represent our current position in the board and an integer d represents the number of digit in the word. Therefore,  we can construct the state key as at position 1 in the backtrack method by combining the three states as a String key. Once we encounter the same state again, we return the previously calculated result directly. And at position 2, once we know that the current state works, we record true and false at position 3.\\n\\nHowever, this doesn\\'t work in this situation. Let\\'s say we started at B(i1, j1, 0) and currently we are at state A(i0, j0, d0) and we calculated that state A(i0, j0, d0) is false. Does that mean if we start with state A(i0, j0, d0), we can\\'t find a match for the remaining words? No. Remeber that we can\\'t visit the positions in the board that was visited in the current path. Therefore if we start from B(i1, j1, 0) and reach A(i0, j0, d0), and then we start from A(i0, j0, d0), there are some positions that we can\\'t visit. But if we start from a different position say C(i2, j2, 0) and reach A(i0, j0, d0), and then start from A(i0, j0, d0), we may be able visit some positions which we can\\'t in the (B->A) path. In short, even if the state A is a \"false\" in the (B->A) path, it still may be a \"true\" in the (C->A) path where C != B. Therefore, memoization doesn\\'t work in this problem.\\n\\nAn **example** here to illustrate:\\n\\nword: \"AABCCA\", board(with index):\\n\\n(x, 0, 1, 2, 3, 4)\\n(0, A, A, B, A, A)\\n(1, D, C, C, D, D)\\n\\nWe start from A(0, 0) -> A(0, 1) -> B(0, 2) -> C(1, 2) -> C(1, 1), and we can\\'t go any further and we record the corresponding states as false. Is this logically correct? No. If later we start from A(0, 4) -> A(0, 3) -> B(0, 2) -> C(1, 2) -> C(1, 1) -> A(0, 1), we can find a valid match. But if we have recorded those states as false, we won\\'t be able to reach this valid match.\\n\\nBut still, there are some ways that we can improve the performance:\\n\\n- Check if the word has more characters than the board does and check if the board contains enough characters of the word. Thanks for @JulianZheng\\'s post [here](https://leetcode.com/problems/word-search/discuss/1225276/Java-99-backtracking-%2B-pruning).\\n- While triggering the backtracking, return true once we find a valid match with a certain start point. Also in the backtrack method, return true once we find a valid match. (Imagine we have a board and a word with all same letters, this can save a lot)\\n\\n**The code is a demo of incorrectly using memo, so it can\\'t pass.**\\n```\\nclass Solution {\\n    int[][] dirs;\\n    Map<String, Boolean> memo;\\n    \\n    public boolean exist(char[][] board, String word) {\\n        dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        memo = new HashMap<>();\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // if the word has more chars than the board does\\n        if (word.length() > m * n) {\\n            return false;\\n        }\\n        \\n        // if the board doesn\\'t contain enough chars of the word\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                char c = board[i][j];\\n                count.put(c, count.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < word.length(); i += 1) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int charCount = count.get(c);\\n                if (charCount == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, charCount - 1);\\n                }\\n            }\\n        }\\n        \\n        // backtracking\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                boolean exists = backtrack(board, i, j, word, 0);\\n                if (exists) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int i, int j, String word, int d) {\\n\\t\\t// position 1\\n\\t\\tString key = i + \",\" + j + \",\" + d;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        if (d == word.length()) {\\n            return true;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n        if (i < 0 || i >= m || j < 0 || j >= n) {\\n            return false;\\n        }\\n        if (board[i][j] == \\'#\\' || board[i][j] != word.charAt(d)) {\\n            return false;\\n        }\\n        \\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        for (int[] dir : dirs) {\\n            boolean exists = backtrack(board, i + dir[0], j + dir[1], word, d + 1);\\n            if (exists) {\\n\\t\\t\\t\\t// position 2\\n\\t\\t\\t\\tmemo.put(key, true);\\n                return true;\\n            }\\n        }\\n        board[i][j] = c;\\n\\t\\t// position 3\\n\\t\\tmemo.put(key, false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs;\\n    Map<String, Boolean> memo;\\n    \\n    public boolean exist(char[][] board, String word) {\\n        dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        memo = new HashMap<>();\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // if the word has more chars than the board does\\n        if (word.length() > m * n) {\\n            return false;\\n        }\\n        \\n        // if the board doesn\\'t contain enough chars of the word\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                char c = board[i][j];\\n                count.put(c, count.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < word.length(); i += 1) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int charCount = count.get(c);\\n                if (charCount == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, charCount - 1);\\n                }\\n            }\\n        }\\n        \\n        // backtracking\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                boolean exists = backtrack(board, i, j, word, 0);\\n                if (exists) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int i, int j, String word, int d) {\\n\\t\\t// position 1\\n\\t\\tString key = i + \",\" + j + \",\" + d;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        if (d == word.length()) {\\n            return true;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n        if (i < 0 || i >= m || j < 0 || j >= n) {\\n            return false;\\n        }\\n        if (board[i][j] == \\'#\\' || board[i][j] != word.charAt(d)) {\\n            return false;\\n        }\\n        \\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        for (int[] dir : dirs) {\\n            boolean exists = backtrack(board, i + dir[0], j + dir[1], word, d + 1);\\n            if (exists) {\\n\\t\\t\\t\\t// position 2\\n\\t\\t\\t\\tmemo.put(key, true);\\n                return true;\\n            }\\n        }\\n        board[i][j] = c;\\n\\t\\t// position 3\\n\\t\\tmemo.put(key, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694322,
                "title": "c-solution-easy-understanding-recursion-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(int i,int j,int n,int m,vector<vector<char>>& board, string word,int k){\\n        if(k==word.size()) return true;\\n        if(i<0||j<0||i==n||j==m||board[i][j]!=word[k]) return false;\\n        char ch = board[i][j];\\n        board[i][j]=\\'#\\';\\n        bool opt1= search(i+1,j,n,m,board,word,k+1);\\n        bool opt2= search(i,j+1,n,m,board,word,k+1);\\n        bool opt3= search(i-1,j,n,m,board,word,k+1);\\n        bool opt4= search(i,j-1,n,m,board,word,k+1);\\n        board[i][j]=ch;\\n        return opt1||opt2||opt3||opt4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n =board.size();\\n        int m = board[0].size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(search(i,j,n,m,board,word,0)) return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(int i,int j,int n,int m,vector<vector<char>>& board, string word,int k){\\n        if(k==word.size()) return true;\\n        if(i<0||j<0||i==n||j==m||board[i][j]!=word[k]) return false;\\n        char ch = board[i][j];\\n        board[i][j]=\\'#\\';\\n        bool opt1= search(i+1,j,n,m,board,word,k+1);\\n        bool opt2= search(i,j+1,n,m,board,word,k+1);\\n        bool opt3= search(i-1,j,n,m,board,word,k+1);\\n        bool opt4= search(i,j-1,n,m,board,word,k+1);\\n        board[i][j]=ch;\\n        return opt1||opt2||opt3||opt4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n =board.size();\\n        int m = board[0].size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(search(i,j,n,m,board,word,0)) return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509071,
                "title": "js-dfs-backtracking-beats-88-clean-code",
                "content": "DFS + Backtracking will take you far\\n\\n```\\nconst exist = function(board, word) {\\n    const n = board.length, m = board[0].length;\\n    if (word.length < 1) return false;\\n\\n    const dfs = (i, j, pos) => {\\n        if (i === n || i < 0 || j === m || j < 0 || board[i][j] !== word[pos]) return false;\\n        if (pos === word.length-1) return true;\\n        board[i][j] = \".\"; // choose this elem so we don\\'t find it again\\n        const found = \\n            dfs(i+1,j, pos+1) || // check every direction and see if any of them return a match\\n            dfs(i-1,j, pos+1) ||\\n            dfs(i,j+1, pos+1) ||\\n            dfs(i,j-1, pos+1);\\n\\n        board[i][j] = word[pos]; // unchoose element\\n        return found;\\n    };\\n    \\n    for (let i=0;i<n;i++) {\\n        for (let j=0;j<m;j++) {\\n            if (board[i][j] === word[0]) {\\n                const match = dfs(i,j, 0);\\n                if (match) return true;\\n            }\\n        }\\n    }\\n\\n    return false;\\xA0\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst exist = function(board, word) {\\n    const n = board.length, m = board[0].length;\\n    if (word.length < 1) return false;\\n\\n    const dfs = (i, j, pos) => {\\n        if (i === n || i < 0 || j === m || j < 0 || board[i][j] !== word[pos]) return false;\\n        if (pos === word.length-1) return true;\\n        board[i][j] = \".\"; // choose this elem so we don\\'t find it again\\n        const found = \\n            dfs(i+1,j, pos+1) || // check every direction and see if any of them return a match\\n            dfs(i-1,j, pos+1) ||\\n            dfs(i,j+1, pos+1) ||\\n            dfs(i,j-1, pos+1);\\n\\n        board[i][j] = word[pos]; // unchoose element\\n        return found;\\n    };\\n    \\n    for (let i=0;i<n;i++) {\\n        for (let j=0;j<m;j++) {\\n            if (board[i][j] === word[0]) {\\n                const match = dfs(i,j, 0);\\n                if (match) return true;\\n            }\\n        }\\n    }\\n\\n    return false;\\xA0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507620,
                "title": "c-simple-to-understand-using-dfs-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public bool Exist(char[][] board, string word) {\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public bool Exist(char[][] board, string word) {\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330278,
                "title": "c-concise-dfs",
                "content": "```\\nbool dfs(vector<vector<char>>& board, int i, int j, string& word)\\n    {\\n        if(word.size() == 0) \\n            return true;\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[0])\\n            return false;\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'*\\';\\n        string s = word.substr(1);\\n        bool res = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        \\n        board[i][j] = ch;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(dfs(board, i, j, word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nbool dfs(vector<vector<char>>& board, int i, int j, string& word)\\n    {\\n        if(word.size() == 0) \\n            return true;\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[0])\\n            return false;\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'*\\';\\n        string s = word.substr(1);\\n        bool res = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        \\n        board[i][j] = ch;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(dfs(board, i, j, word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745176,
                "title": "word-search-python3-solution-with-a-detailed-explanation",
                "content": "This solution comes from [here](https://leetcode.com/problems/word-search/discuss/27665/Python-simple-dfs-solution). The idea is that you loop over every element of a matrix one by one (lines `#1` and `#2`), and check whether you can find the word. The main part is the `dfs` function that for each value (`board[i][j]`) check whether it\\'s the first letter of the `word`. If it\\'s not it returns `False` (line `#5`). Otherwise, it moves forward (line `#4`). After satisfying line `#4` (meaning first letter is found), we replace  that cell in `board` with space so that we now we\\'ve visited it (line `#6`). Then, we try four different scenarios in the neighborhood of `[i][j]` and see whether we can find the second letter of `word` (line `#7, 8, 9, 10`). This is done recursively. After we find the first letter in line `#4`, we focus on the rest of the `word`, meaning `word[1:]`. If the second letter is one of the right, left, top, or bottom cells of `board[i][j]`, we focus of `word[2:]` in the next cycle. We keep doing this until we find all the letters. Now say, we find the first letter, but the second letter is not in the neighborhood, we go to a new `board[i][j]` by checking a new cell in lines `#1, 2, 3` and start the process from scratch for the whole `word`. \\n\\n\\nNote that the conditions of lines `#7` ( `i>0`), `#8` (` i < len(board) - 1 `), etc. takes care of matrix edges. If it wasn\\'t there, and you\\'re on the first column of matrix (`j=0`), then `j - 1` would give you `-1` which is corresponding to the right side. \\n\\n\\n\\n\\nDoes this make sense? \\n\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not board:\\n            return False\\n        if not word:\\n            return True\\n        \\n        for i in range(len(board)): # 1\\n            for j in range(len(board[0])): # 2\\n                if self.dfs(board, word, i, j): #3\\n                    return True\\n        return False   \\n        \\n    \\n    def dfs(self, board, word, i, j):\\n        if board[i][j] == word[0]: #4\\n            if not word[1:]:\\n                return True\\n        \\n            board[i][j] = \" \" #6\\n        \\n            if i > 0 and self.dfs(board, word[1:], i - 1, j): #7\\n                return True\\n            if i < len(board) - 1 and self.dfs(board, word[1:], i + 1, j): #8\\n                return True\\n            if j > 0 and self.dfs(board, word[1:], i, j - 1): #9\\n                return True\\n            if j < len(board[0]) - 1 and self.dfs(board, word[1:], i, j + 1): #10\\n                return True\\n        \\n            board[i][j] = word[0]\\n            return False\\n        else: #5\\n            return False\\n```\\n\\n========================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it. \\n\\nFinal note 2: Explaning things in a simple language is instructive for me. Thanks for reading.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not board:\\n            return False\\n        if not word:\\n            return True\\n        \\n        for i in range(len(board)): # 1\\n            for j in range(len(board[0])): # 2\\n                if self.dfs(board, word, i, j): #3\\n                    return True\\n        return False   \\n        \\n    \\n    def dfs(self, board, word, i, j):\\n        if board[i][j] == word[0]: #4\\n            if not word[1:]:\\n                return True\\n        \\n            board[i][j] = \" \" #6\\n        \\n            if i > 0 and self.dfs(board, word[1:], i - 1, j): #7\\n                return True\\n            if i < len(board) - 1 and self.dfs(board, word[1:], i + 1, j): #8\\n                return True\\n            if j > 0 and self.dfs(board, word[1:], i, j - 1): #9\\n                return True\\n            if j < len(board[0]) - 1 and self.dfs(board, word[1:], i, j + 1): #10\\n                return True\\n        \\n            board[i][j] = word[0]\\n            return False\\n        else: #5\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844358,
                "title": "c-dfs-backtracking-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(int index,int i,int j,vector<vector<char>> &board, string word){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(i<0 || j<0 || i >= board.size() || j >= board[0].size()){\\n            return false;\\n        }\\n        bool ans = false;\\n        if(word[index] == board[i][j]){\\n            board[i][j] = \\'*\\';\\n            \\n            ans = search(index+1,i+1,j,board,word) || search(index+1,i,j+1,board,word) || \\n                search(index+1,i-1,j,board,word) ||search(index+1,i,j-1,board,word);\\n            \\n            board[i][j] = word[index];\\n        }\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board[0].size();\\n        int n = board.size();\\n         int index  = 0;\\n        \\n        bool ans = false;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(word[index] == board[i][j]){\\n                    if(search(index,i,j,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(int index,int i,int j,vector<vector<char>> &board, string word){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(i<0 || j<0 || i >= board.size() || j >= board[0].size()){\\n            return false;\\n        }\\n        bool ans = false;\\n        if(word[index] == board[i][j]){\\n            board[i][j] = \\'*\\';\\n            \\n            ans = search(index+1,i+1,j,board,word) || search(index+1,i,j+1,board,word) || \\n                search(index+1,i-1,j,board,word) ||search(index+1,i,j-1,board,word);\\n            \\n            board[i][j] = word[index];\\n        }\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board[0].size();\\n        int n = board.size();\\n         int index  = 0;\\n        \\n        bool ans = false;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(word[index] == board[i][j]){\\n                    if(search(index,i,j,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426224,
                "title": "js-backtrack-dfs",
                "content": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//since its a 2D array, instead of looping once, we will loop twice, over the row and column of the board\\n//then to choose, we will just mark the visited index with \\'*\\'\\n//to explore, we will be exploring left, right, up, down of the board from the current spot/box\\n//then to unchoose, we will just replace the \\'*\\' with the letter we had replaced\\n//\\n//so basically, \\n//we will start from the [0][0] of the board, and start checking if the letter in that spot is equal to the letter in the given word\\n//if it is equal, we recurse to find possible matching letter from the board\\n//we increment the wordIndex by 1, we also replace the spot with \\'*\\' \\n//and then backtrack check to see if the neighbors(left, right, up, down) have the new letter from the given word\\n//if somehow the boundary check fails or the letter check fails, we return false, \\n//if all of the check fails while backtracking we start replacing the \\'*\\' with the actual letters we stored in our temp variable\\n//then return the result back.\\nvar exist = function(board, word) {\\n    if(board == null || word == null || board.length == 0) //edge case\\n        return false;\\n    \\n    \\n    for(let row = 0; row < board.length; row++){\\n        for(let col = 0; col < board[0].length; col++){\\n            if(helper(board, word, row, col, 0))  //recursive check\\n                return true;\\n        }\\n    }\\n    \\n    \\n    function helper(board, word, row, col, wordIndex){\\n        \\n        if(wordIndex == word.length) \\n            return true;\\n        \\n        //out of bounds check\\n        if(row < 0 || row >= board.length || col < 0  || col >= board[0].length)\\n            return false;\\n        \\n        //letter check in the box (if the letter at the board is not equal to the letter of the given word return false)\\n        if(board[row][col] != word[wordIndex])\\n            return false;\\n        \\n        //choose\\n        let temp = board[row][col];\\n        board[row][col] = \\'*\\';          //marking the visited box\\n        \\n        //explore\\n        let bool = helper(board, word, row-1, col, wordIndex+1) ||\\n            helper(board, word, row+1, col, wordIndex+1) ||\\n            helper(board, word, row, col-1, wordIndex+1) ||\\n            helper(board, word, row, col+1, wordIndex+1);\\n    \\n        //unchoose\\n        board[row][col] = temp;        //setting back the value from \\'*\\' to the letter\\n        \\n        return bool;\\n    }\\n    \\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//since its a 2D array, instead of looping once, we will loop twice, over the row and column of the board\\n//then to choose, we will just mark the visited index with \\'*\\'\\n//to explore, we will be exploring left, right, up, down of the board from the current spot/box\\n//then to unchoose, we will just replace the \\'*\\' with the letter we had replaced\\n//\\n//so basically, \\n//we will start from the [0][0] of the board, and start checking if the letter in that spot is equal to the letter in the given word\\n//if it is equal, we recurse to find possible matching letter from the board\\n//we increment the wordIndex by 1, we also replace the spot with \\'*\\' \\n//and then backtrack check to see if the neighbors(left, right, up, down) have the new letter from the given word\\n//if somehow the boundary check fails or the letter check fails, we return false, \\n//if all of the check fails while backtracking we start replacing the \\'*\\' with the actual letters we stored in our temp variable\\n//then return the result back.\\nvar exist = function(board, word) {\\n    if(board == null || word == null || board.length == 0) //edge case\\n        return false;\\n    \\n    \\n    for(let row = 0; row < board.length; row++){\\n        for(let col = 0; col < board[0].length; col++){\\n            if(helper(board, word, row, col, 0))  //recursive check\\n                return true;\\n        }\\n    }\\n    \\n    \\n    function helper(board, word, row, col, wordIndex){\\n        \\n        if(wordIndex == word.length) \\n            return true;\\n        \\n        //out of bounds check\\n        if(row < 0 || row >= board.length || col < 0  || col >= board[0].length)\\n            return false;\\n        \\n        //letter check in the box (if the letter at the board is not equal to the letter of the given word return false)\\n        if(board[row][col] != word[wordIndex])\\n            return false;\\n        \\n        //choose\\n        let temp = board[row][col];\\n        board[row][col] = \\'*\\';          //marking the visited box\\n        \\n        //explore\\n        let bool = helper(board, word, row-1, col, wordIndex+1) ||\\n            helper(board, word, row+1, col, wordIndex+1) ||\\n            helper(board, word, row, col-1, wordIndex+1) ||\\n            helper(board, word, row, col+1, wordIndex+1);\\n    \\n        //unchoose\\n        board[row][col] = temp;        //setting back the value from \\'*\\' to the letter\\n        \\n        return bool;\\n    }\\n    \\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1068073,
                "title": "java-solution-4-ms-faster-than-99-10-using-backtracking",
                "content": "**PLEASE UPVOTE THIS SOLUTION IF YOU LIKE THIS** \\u270C\\uFE0F\\n\\nIntiuition:  \\n- To search a word in grid, we can start from a index (x, y) and then try every direction using dfs.\\n- If word char is match with the cell than Increment the wordIndex and try that cell neighbour.\\n- if word doesn\\'t match then replace the char with original cell char\\n\\n\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int x = 0; x < board.length; x++){\\n\\t\\t    for(int y = 0; y < board[0].length; y++){\\n\\t\\t\\t\\t//start from every cell, \\n\\t\\t\\t\\t//if any of found the word in the grid, return true\\n                if(exist(board, x, y, word, 0)) return true;\\n            }\\n        }\\n        \\n\\t\\t//if not found\\n        return false;\\n    }\\n    \\n    public boolean exist(char[][] board, int x, int y, String word, int wordIndex){\\n\\n        if(wordIndex == word.length()) return true;\\n        \\n\\t\\t//check boundary of grid\\n        if( x < 0 || x >= board.length ||  y < 0 ||  y >= board[0].length) return false;\\n\\t\\t\\n\\t\\tchar currCellChar =  board[x][y];\\n\\t\\t\\n\\t\\t//check currently, this cell is being used for dfs\\n\\t\\tif(currCellChar == \\'$\\') return false;\\n\\t\\t \\n\\t\\t //check cell char is equal to  current char of word\\n\\t\\tif(currCellChar != word.charAt(wordIndex)) return false;\\n        \\n\\t\\t//mark this cell as used\\n        board[x][y] = \\'$\\';\\n        \\n        boolean isExist = exist(board, x + 1, y, word, wordIndex + 1) ||    // direction UP \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x - 1, y, word, wordIndex + 1) ||    // direction DOWN\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y + 1, word, wordIndex + 1) ||   // direction RIGHT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y - 1, word, wordIndex + 1);     // direction LEFT\\n            \\n\\t\\t//for the backtracking, try different possibilty,  now unmark this cell as free, \\t\\n        board[x][y] = currCellChar;\\n        \\n        return isExist;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int x = 0; x < board.length; x++){\\n\\t\\t    for(int y = 0; y < board[0].length; y++){\\n\\t\\t\\t\\t//start from every cell, \\n\\t\\t\\t\\t//if any of found the word in the grid, return true\\n                if(exist(board, x, y, word, 0)) return true;\\n            }\\n        }\\n        \\n\\t\\t//if not found\\n        return false;\\n    }\\n    \\n    public boolean exist(char[][] board, int x, int y, String word, int wordIndex){\\n\\n        if(wordIndex == word.length()) return true;\\n        \\n\\t\\t//check boundary of grid\\n        if( x < 0 || x >= board.length ||  y < 0 ||  y >= board[0].length) return false;\\n\\t\\t\\n\\t\\tchar currCellChar =  board[x][y];\\n\\t\\t\\n\\t\\t//check currently, this cell is being used for dfs\\n\\t\\tif(currCellChar == \\'$\\') return false;\\n\\t\\t \\n\\t\\t //check cell char is equal to  current char of word\\n\\t\\tif(currCellChar != word.charAt(wordIndex)) return false;\\n        \\n\\t\\t//mark this cell as used\\n        board[x][y] = \\'$\\';\\n        \\n        boolean isExist = exist(board, x + 1, y, word, wordIndex + 1) ||    // direction UP \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x - 1, y, word, wordIndex + 1) ||    // direction DOWN\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y + 1, word, wordIndex + 1) ||   // direction RIGHT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y - 1, word, wordIndex + 1);     // direction LEFT\\n            \\n\\t\\t//for the backtracking, try different possibilty,  now unmark this cell as free, \\t\\n        board[x][y] = currCellChar;\\n        \\n        return isExist;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748682,
                "title": "python-3-dfs-backtracking",
                "content": "```\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(board,i,j,count,word):\\n            if(count == len(word)):\\n                return True\\n            if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or word[count]!=board[i][j]:\\n                return False\\n            temp = board[i][j]\\n            board[i][j] = \"\"\\n            found = dfs(board,i+1,j,count+1,word) or dfs(board,i-1,j,count+1,word) or dfs(board,i,j+1,count+1,word) or dfs(board,i,j-1,count+1,word)\\n            board[i][j] = temp\\n            return found\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and dfs(board,i,j,0,word):\\n                    return True\\n        return False",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(board,i,j,count,word):\\n            if(count == len(word)):\\n                return True\\n            if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or word[count]!=board[i][j]:\\n                return False\\n            temp = board[i][j]\\n            board[i][j] = \"\"\\n            found = dfs(board,i+1,j,count+1,word) or dfs(board,i-1,j,count+1,word) or dfs(board,i,j+1,count+1,word) or dfs(board,i,j-1,count+1,word)\\n            board[i][j] = temp\\n            return found\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and dfs(board,i,j,0,word):\\n                    return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 747107,
                "title": "java-dfs-simple-solution",
                "content": "If you found the solution helpful, kindly upvote or like. :)\\n\\n```\\nclass Solution {\\n    boolean visited[][];\\n    public boolean exist(char[][] board, String word) {\\n        \\tvisited= new boolean[board.length][board[0].length];\\n\\t\\tfor(int i=0; i<board.length; i++)\\n\\t\\t\\tfor(int j=0; j<board[0].length; j++)\\n\\t\\t\\t\\tif(board[i][j]==word.charAt(0) && search(i,j,0,board,word))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\tprivate boolean search(int i, int j, int index, char[][] board, String word) {\\n\\t\\tif(index==word.length())\\n\\t\\t\\treturn true;\\n\\t\\tif(i>=board.length|| i<0 || j<0 || j>= board[0].length \\n\\t\\t\\t\\t|| visited[i][j] || word.charAt(index)!=board[i][j])\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tvisited[i][j]=true;\\n\\t\\tif(search(i+1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i-1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i, j+1, index+1, board, word)||\\n\\t\\t\\tsearch(i, j-1, index+1, board, word))\\n\\t\\t\\treturn true;\\n\\t\\t\\n\\t\\tvisited[i][j]=false;\\n\\t\\treturn false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean visited[][];\\n    public boolean exist(char[][] board, String word) {\\n        \\tvisited= new boolean[board.length][board[0].length];\\n\\t\\tfor(int i=0; i<board.length; i++)\\n\\t\\t\\tfor(int j=0; j<board[0].length; j++)\\n\\t\\t\\t\\tif(board[i][j]==word.charAt(0) && search(i,j,0,board,word))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\tprivate boolean search(int i, int j, int index, char[][] board, String word) {\\n\\t\\tif(index==word.length())\\n\\t\\t\\treturn true;\\n\\t\\tif(i>=board.length|| i<0 || j<0 || j>= board[0].length \\n\\t\\t\\t\\t|| visited[i][j] || word.charAt(index)!=board[i][j])\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tvisited[i][j]=true;\\n\\t\\tif(search(i+1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i-1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i, j+1, index+1, board, word)||\\n\\t\\t\\tsearch(i, j-1, index+1, board, word))\\n\\t\\t\\treturn true;\\n\\t\\t\\n\\t\\tvisited[i][j]=false;\\n\\t\\treturn false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715627,
                "title": "dfs-backtracking-solution-without-extra-space-visited-map",
                "content": "```\\nfunc exist(board [][]byte, word string) bool {\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tif board[i][j] == word[0] {\\n\\t\\t\\t\\trs := dfs(board, i, j, 0, word)\\n\\n\\t\\t\\t\\tif rs {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, i, j, pos int, word string) bool {\\n\\tif i < 0 || j < 0 || i >= len(board) || j >= len(board[0]) || board[i][j] == \\'*\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif word[pos] != board[i][j] {\\n\\t\\treturn false\\n\\t}\\n  \\n\\tif len(word)-1 == pos {\\n\\t\\treturn true\\n\\t}\\n\\n\\tpos++\\n    tmp := board[i][j]\\n\\tboard[i][j] = \\'*\\'\\n\\n\\tdfsResult :=\\n\\t\\tdfs(board, i-1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i+1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i, j+1, pos, word) ||\\n\\t\\t\\tdfs(board, i, j-1, pos, word)\\n    board[i][j] = tmp\\n  \\n\\treturn dfsResult\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc exist(board [][]byte, word string) bool {\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tif board[i][j] == word[0] {\\n\\t\\t\\t\\trs := dfs(board, i, j, 0, word)\\n\\n\\t\\t\\t\\tif rs {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, i, j, pos int, word string) bool {\\n\\tif i < 0 || j < 0 || i >= len(board) || j >= len(board[0]) || board[i][j] == \\'*\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif word[pos] != board[i][j] {\\n\\t\\treturn false\\n\\t}\\n  \\n\\tif len(word)-1 == pos {\\n\\t\\treturn true\\n\\t}\\n\\n\\tpos++\\n    tmp := board[i][j]\\n\\tboard[i][j] = \\'*\\'\\n\\n\\tdfsResult :=\\n\\t\\tdfs(board, i-1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i+1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i, j+1, pos, word) ||\\n\\t\\t\\tdfs(board, i, j-1, pos, word)\\n    board[i][j] = tmp\\n  \\n\\treturn dfsResult\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844365,
                "title": "java-brute-force-to-search-pruning-fully-explained",
                "content": "# Intuition\\nWe need to construct the given word from the characters in the board. This is a trial-and-error algorithm which we will solve using `backtracking`.\\n\\nNote: While meeting this question for the first time a few years ago, I thought of doing it with DP. The reason why DP doesn\\'t work here is that you cannot form smaller sub-problems because the path with which you arrive at some cell `(r, c)` changes with every move. Hence, you have conditional state that cannot be memoized (calculated for other problems).\\n\\nThe naive approach is to construct all the possible words of `length = given_word.length` and check for equality.\\n\\nThe code will look like this\\n\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, StringBuilder s) {\\n        // The reason I mutate the state here, and not before calling dfs() is because there are 2 places calling the function. And I don\\'t want to duplicate the logic\\n        s.append(board[row][col]);\\n        vis[row][col] = true;\\n\\n        if (s.length() == word.length()) {\\n            boolean hasFound = s.toString().equals(word);\\n            s.deleteCharAt(s.length() - 1);\\n            vis[row][col] = false;\\n            return hasFound;\\n        }\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        s.deleteCharAt(s.length() - 1);\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n\\nThis is inefficient because if we are looking for the word \"hello\" there is no point matching it with \"abcdef\". We can prune the searching on the first index, i.e. \"h\" != \"a\", therefore we don\\'t have to continue searching on that path.\\n\\nSo to optimize our algorithm we will keep track of the index we located at, and compare the letter on each index. If we reach the last index it means we built the whole string.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, int i) {\\n        if(board[row][col] != word.charAt(i)) return false;\\n\\n        if (i == word.length() -1) return true;\\n\\n        vis[row][col] = true;\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n\\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, i + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n\\nNote 2: you can optimize the algorithm by doing the checks before calling dfs(). I omitted that here for brevity.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, StringBuilder s) {\\n        // The reason I mutate the state here, and not before calling dfs() is because there are 2 places calling the function. And I don\\'t want to duplicate the logic\\n        s.append(board[row][col]);\\n        vis[row][col] = true;\\n\\n        if (s.length() == word.length()) {\\n            boolean hasFound = s.toString().equals(word);\\n            s.deleteCharAt(s.length() - 1);\\n            vis[row][col] = false;\\n            return hasFound;\\n        }\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        s.deleteCharAt(s.length() - 1);\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, int i) {\\n        if(board[row][col] != word.charAt(i)) return false;\\n\\n        if (i == word.length() -1) return true;\\n\\n        vis[row][col] = true;\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n\\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, i + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362461,
                "title": "python-simple-and-clean-backtracking-solution",
                "content": "**If you like Pls Upvote :-)**\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        rows=len(board)\\n        cols=len(board[0])\\n        visited=set()\\n        def dfs(i,j,curr):\\n            if curr==len(word):\\n                return True\\n            \\n            if i<0 or j>=cols or j<0 or i>=rows or board[i][j]!=word[curr] or (i,j) in visited:\\n                return False\\n            \\n            visited.add((i,j))\\n            res=dfs(i+1,j,curr+1) or dfs(i-1,j,curr+1) or dfs(i,j+1,curr+1) or dfs(i,j-1,curr+1)\\n            visited.remove((i,j))\\n            return res\\n            \\n        for i in range(rows):\\n            for j in range(cols):\\n                if dfs(i,j,0): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        rows=len(board)\\n        cols=len(board[0])\\n        visited=set()\\n        def dfs(i,j,curr):\\n            if curr==len(word):\\n                return True\\n            \\n            if i<0 or j>=cols or j<0 or i>=rows or board[i][j]!=word[curr] or (i,j) in visited:\\n                return False\\n            \\n            visited.add((i,j))\\n            res=dfs(i+1,j,curr+1) or dfs(i-1,j,curr+1) or dfs(i,j+1,curr+1) or dfs(i,j-1,curr+1)\\n            visited.remove((i,j))\\n            return res\\n            \\n        for i in range(rows):\\n            for j in range(cols):\\n                if dfs(i,j,0): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123807,
                "title": "0ms-tle-explained-easy-100-fast",
                "content": "\\t Do upvote\\u2764\\uFE0F\\n# Sol #1. DFS (800ms)\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\\n* This solution will take around 800ms\\n* you will get **TLE** if *arr* is passed by value like this in *dfs* function ```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\\n\\n\\n# Sol #2. DFS with Pruning  0ms sol\\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```\\n* **We use the same DFS with some prior analysis.**\\n* **Prune 3 is for such cases**\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"]]\\n\"AAAAAAAAAAAAAAB\"\\nit changes word to \"BAAAAAAAAAAAAAA\"\\n![image](https://assets.leetcode.com/users/images/c4161e1c-960a-47f8-a4d1-903ae22cbbcc_1653990215.8375807.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\n```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538495,
                "title": "python-solution-using-backtracking-with-explanation",
                "content": "```\\n######################################################\\n\\n#   Runtime: 1412ms   -   94.74%\\n#   Memory: 14.2MB  -   71.98%\\n\\n######################################################\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        # Below code will help in reducing time complexity significantly.\\n        # What below code does is, it creates a set with all chars present in board\\n        # and then it will check whether all chars in word are present in board\\n        # If a char in word is not present in the board, we can\\'t find the word in \\n        # board. So we return False\\n        # Without these lines of code, I got a Time Complexity of 8000+ ms\\n        # After adding these lines of code, my TC reduced to just 1400+ ms\\n        # Why this drastic change is, since we are checking all possible strings\\n        # using a backtracking paradigm, there will be some cases where we go to so\\n        # much deep just to find the required char is not even present in the board\\n        # So we are eliminating it before hand.\\n        characters = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] not in characters: characters.add(board[i][j])\\n        \\n        for s in word: \\n            if s not in characters: return False\\n        \\n        def dfs(row, col, index, visited):\\n            # index represents current index of word string\\n            # Checking for out of bounds indices and returning False\\n            if row < 0 or row > len(board) - 1 or col < 0 or col > len(board[0]) - 1: return False\\n            # If we already visited current cell, return False\\n            if (row, col) in visited: return False\\n            # If char at cell (row, col) matches with word[index] we go next char\\n            # in all the 4 directions\\n            if board[row][col] == word[index]:\\n                visited.add((row, col))\\n                # If we reach end of word return Trur\\n                if index == len(word) - 1: return True\\n                isExist = (\\n                            dfs(row, col - 1, index + 1, visited) or \\n                            dfs(row, col + 1, index + 1, visited) or\\n                            dfs(row - 1, col, index + 1, visited) or \\n                            dfs(row + 1, col, index + 1, visited)\\n                       )   \\n                # Why we are removing at the end is, we might encounter this cell\\n                # again in some other path if this path didn\\'t give us required \\n                # word. In that path, we haven\\'t yet visited the cell right. So, we\\n                # are removing it.\\n                visited.remove((row, col))\\n                return isExist\\n            \\n            return False\\n        \\n        # Running DFS when the char in the cell (i,j) matches with word[0] i.e; \\n        # starting of the word\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    visited = set()\\n                    if dfs(i, j, 0, visited): return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 1412ms   -   94.74%\\n#   Memory: 14.2MB  -   71.98%\\n\\n######################################################\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        # Below code will help in reducing time complexity significantly.\\n        # What below code does is, it creates a set with all chars present in board\\n        # and then it will check whether all chars in word are present in board\\n        # If a char in word is not present in the board, we can\\'t find the word in \\n        # board. So we return False\\n        # Without these lines of code, I got a Time Complexity of 8000+ ms\\n        # After adding these lines of code, my TC reduced to just 1400+ ms\\n        # Why this drastic change is, since we are checking all possible strings\\n        # using a backtracking paradigm, there will be some cases where we go to so\\n        # much deep just to find the required char is not even present in the board\\n        # So we are eliminating it before hand.\\n        characters = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] not in characters: characters.add(board[i][j])\\n        \\n        for s in word: \\n            if s not in characters: return False\\n        \\n        def dfs(row, col, index, visited):\\n            # index represents current index of word string\\n            # Checking for out of bounds indices and returning False\\n            if row < 0 or row > len(board) - 1 or col < 0 or col > len(board[0]) - 1: return False\\n            # If we already visited current cell, return False\\n            if (row, col) in visited: return False\\n            # If char at cell (row, col) matches with word[index] we go next char\\n            # in all the 4 directions\\n            if board[row][col] == word[index]:\\n                visited.add((row, col))\\n                # If we reach end of word return Trur\\n                if index == len(word) - 1: return True\\n                isExist = (\\n                            dfs(row, col - 1, index + 1, visited) or \\n                            dfs(row, col + 1, index + 1, visited) or\\n                            dfs(row - 1, col, index + 1, visited) or \\n                            dfs(row + 1, col, index + 1, visited)\\n                       )   \\n                # Why we are removing at the end is, we might encounter this cell\\n                # again in some other path if this path didn\\'t give us required \\n                # word. In that path, we haven\\'t yet visited the cell right. So, we\\n                # are removing it.\\n                visited.remove((row, col))\\n                return isExist\\n            \\n            return False\\n        \\n        # Running DFS when the char in the cell (i,j) matches with word[0] i.e; \\n        # starting of the word\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    visited = set()\\n                    if dfs(i, j, 0, visited): return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556016,
                "title": "java-trie-based-approach-google-asked",
                "content": "```\\nclass Solution {\\n    TrieNode root;\\n    int row, col;\\n    public boolean exist(char[][] board, String word) {\\n        //Approach - Trie Approach\\n        root = new TrieNode();\\n        insertInTrie(word);\\n        TrieNode curr = root;\\n        row = board.length;\\n        col = board[0].length;\\n        for (int i = 0; i < row; i++){\\n            for (int j = 0; j < col; j++){\\n                char ch = board[i][j];\\n                if(curr.children.containsKey(ch) && dfs(curr, board, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n    private boolean dfs(TrieNode curr, char[][] board, int i, int j){\\n\\n        if (curr.isEnd) return curr.isEnd;\\n        if(i < 0 || j <0 || i>= row || j >= col || !curr.children.containsKey(board[i][j])) return false;\\n        char ch = board[i][j];\\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n\\n        if (dfs(curr.children.get(ch), board, i+1, j) || dfs(curr.children.get(ch), board, i-1, j)\\n                || dfs(curr.children.get(ch), board, i, j+1) || dfs(curr.children.get(ch), board, i, j-1))\\n            return true;\\n\\n        board[i][j] = temp;\\n        return false;\\n\\n    }\\n    private void insertInTrie(String word){\\n        TrieNode curr = root;\\n        for (int i = 0; i<word.length(); i++){\\n            char c = word.charAt(i);\\n            if (curr.children.containsKey(c)) {\\n                curr = curr.children.get(c);\\n                continue;\\n            }\\n            curr.children.put(c,new TrieNode());\\n            curr = curr.children.get(c);\\n        }\\n        curr.isEnd = true;\\n    }\\n}\\n    \\nclass TrieNode{\\n    Map<Character, TrieNode> children;\\n    boolean isEnd;\\n    TrieNode(){\\n        children = new HashMap<>();\\n        isEnd = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    TrieNode root;\\n    int row, col;\\n    public boolean exist(char[][] board, String word) {\\n        //Approach - Trie Approach\\n        root = new TrieNode();\\n        insertInTrie(word);\\n        TrieNode curr = root;\\n        row = board.length;\\n        col = board[0].length;\\n        for (int i = 0; i < row; i++){\\n            for (int j = 0; j < col; j++){\\n                char ch = board[i][j];\\n                if(curr.children.containsKey(ch) && dfs(curr, board, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n    private boolean dfs(TrieNode curr, char[][] board, int i, int j){\\n\\n        if (curr.isEnd) return curr.isEnd;\\n        if(i < 0 || j <0 || i>= row || j >= col || !curr.children.containsKey(board[i][j])) return false;\\n        char ch = board[i][j];\\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n\\n        if (dfs(curr.children.get(ch), board, i+1, j) || dfs(curr.children.get(ch), board, i-1, j)\\n                || dfs(curr.children.get(ch), board, i, j+1) || dfs(curr.children.get(ch), board, i, j-1))\\n            return true;\\n\\n        board[i][j] = temp;\\n        return false;\\n\\n    }\\n    private void insertInTrie(String word){\\n        TrieNode curr = root;\\n        for (int i = 0; i<word.length(); i++){\\n            char c = word.charAt(i);\\n            if (curr.children.containsKey(c)) {\\n                curr = curr.children.get(c);\\n                continue;\\n            }\\n            curr.children.put(c,new TrieNode());\\n            curr = curr.children.get(c);\\n        }\\n        curr.isEnd = true;\\n    }\\n}\\n    \\nclass TrieNode{\\n    Map<Character, TrieNode> children;\\n    boolean isEnd;\\n    TrieNode(){\\n        children = new HashMap<>();\\n        isEnd = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245581,
                "title": "short-python-dfs-recursion",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def search(board, x, y, word, visited=set()):\\n            if word == \\'\\':\\n                return True\\n            for i, j in [[x + 1, y], [x - 1, y], [x, y - 1], [x, y + 1]]:\\n                if 0 <= i < len(board) and 0 <= j < len(board[0]) and (i, j) not in visited and board[i][j] == word[0] \\\\\\n                and search(board, i, j, word[1:], visited | {(x, y)}):\\n                    return True\\n            return False\\n        \\n        if not board or not board[0]:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and search(board, i, j, word[1:]):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def search(board, x, y, word, visited=set()):\\n            if word == \\'\\':\\n                return True\\n            for i, j in [[x + 1, y], [x - 1, y], [x, y - 1], [x, y + 1]]:\\n                if 0 <= i < len(board) and 0 <= j < len(board[0]) and (i, j) not in visited and board[i][j] == word[0] \\\\\\n                and search(board, i, j, word[1:], visited | {(x, y)}):\\n                    return True\\n            return False\\n        \\n        if not board or not board[0]:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and search(board, i, j, word[1:]):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890958,
                "title": "easy-python-solution-90-29-beats-with-comments",
                "content": "# Code\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        ROWS, COLS = len(board), len(board[0])\\n        visited = set()\\n\\n        def dfs(r,c,idx):\\n        # if idx == len(word), then word has been found\\n            if idx == len(word):\\n                return True\\n\\n        # out of bounds\\n        # OR current letter does not match letter on board\\n        # OR letter already visited\\n            if ( \\n                r<0 or r>=ROWS \\n                or c<0 or c>=COLS\\n                or word[idx] != board[r][c]\\n                or (r,c) in visited\\n            ):\\n                return False\\n  \\n        # to keep track of the letter already visited, add it\\'s position to the set\\n        # after DFS we can remove it from the set.\\n            visited.add((r,c))\\n\\n        # performing DFS \\n            res = (\\n                dfs(r+1,c,idx+1) \\n                or dfs(r-1,c,idx+1) \\n                or dfs(r,c+1,idx+1) \\n                or dfs(r,c-1,idx+1)\\n            )\\n        \\n            visited.remove((r,c))\\n            return res\\n        \\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        ROWS, COLS = len(board), len(board[0])\\n        visited = set()\\n\\n        def dfs(r,c,idx):\\n        # if idx == len(word), then word has been found\\n            if idx == len(word):\\n                return True\\n\\n        # out of bounds\\n        # OR current letter does not match letter on board\\n        # OR letter already visited\\n            if ( \\n                r<0 or r>=ROWS \\n                or c<0 or c>=COLS\\n                or word[idx] != board[r][c]\\n                or (r,c) in visited\\n            ):\\n                return False\\n  \\n        # to keep track of the letter already visited, add it\\'s position to the set\\n        # after DFS we can remove it from the set.\\n            visited.add((r,c))\\n\\n        # performing DFS \\n            res = (\\n                dfs(r+1,c,idx+1) \\n                or dfs(r-1,c,idx+1) \\n                or dfs(r,c+1,idx+1) \\n                or dfs(r,c-1,idx+1)\\n            )\\n        \\n            visited.remove((r,c))\\n            return res\\n        \\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786896,
                "title": "word-search-java-solution-easy-recursive-approach-t-c-o-m-n",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t\\n\\t//finding first character of given word in given matrix \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[0].length; j++)\\n            {\\n\\t\\t\\t//if first character found then we call recursion for remaining task else return false\\n                if(board[i][j]==word.charAt(0)){\\n                 if(helper(board,word,0,i,j,board.length,board[0].length))\\n                     return true;\\n                }\\n            }\\n        }\\n       return false;\\n    }\\n    boolean helper(char[][] board, String word,int index,int i,int j, int rowLen,int colLen)\\n    {\\n    \\n        if(index==word.length())\\n        return true;\\n        \\n        if(i<0 || j<0 || i == rowLen || j == colLen || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n\\t\\t// mark that character cell so that we can\\'t revisit that cell to avoid infinity calls\\n            char temp = board[i][j];\\n            board[i][j] = \\'#\\';\\n            boolean ans1 = helper(board,word,index+1,i,j+1,rowLen,colLen);\\n            boolean ans2 = helper(board,word,index+1,i+1,j,rowLen,colLen);\\n            boolean ans3 = helper(board,word,index+1,i-1,j,rowLen,colLen);\\n            boolean ans4 = helper(board,word,index+1,i,j-1,rowLen,colLen);\\n            board[i][j] = temp;\\n            return ans1 || ans2 || ans3 || ans4;\\n        \\n    \\n    }\\n}\\nT.C :- O(m * n), m and n are the numbe rof row and column , at max for finding word we have to traverse whole matrix cell\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t\\n\\t//finding first character of given word in given matrix \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[0].length; j++)\\n            {\\n\\t\\t\\t//if first character found then we call recursion for remaining task else return false\\n                if(board[i][j]==word.charAt(0)){\\n                 if(helper(board,word,0,i,j,board.length,board[0].length))\\n                     return true;\\n                }\\n            }\\n        }\\n       return false;\\n    }\\n    boolean helper(char[][] board, String word,int index,int i,int j, int rowLen,int colLen)\\n    {\\n    \\n        if(index==word.length())\\n        return true;\\n        \\n        if(i<0 || j<0 || i == rowLen || j == colLen || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n\\t\\t// mark that character cell so that we can\\'t revisit that cell to avoid infinity calls\\n            char temp = board[i][j];\\n            board[i][j] = \\'#\\';\\n            boolean ans1 = helper(board,word,index+1,i,j+1,rowLen,colLen);\\n            boolean ans2 = helper(board,word,index+1,i+1,j,rowLen,colLen);\\n            boolean ans3 = helper(board,word,index+1,i-1,j,rowLen,colLen);\\n            boolean ans4 = helper(board,word,index+1,i,j-1,rowLen,colLen);\\n            board[i][j] = temp;\\n            return ans1 || ans2 || ans3 || ans4;\\n        \\n    \\n    }\\n}\\nT.C :- O(m * n), m and n are the numbe rof row and column , at max for finding word we have to traverse whole matrix cell\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839796,
                "title": "easy-c-dfs-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board,int i, int j , int count, string word){\\n        if(count == word.length())\\n            return true;\\n        if(i<0 || i>=board.size()||j<0 || j>=board[i].size() || board[i][j]!=word[count])\\n             return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        board[i][j]= temp;\\n        return found;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0] and dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board,int i, int j , int count, string word){\\n        if(count == word.length())\\n            return true;\\n        if(i<0 || i>=board.size()||j<0 || j>=board[i].size() || board[i][j]!=word[count])\\n             return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        board[i][j]= temp;\\n        return found;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0] and dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512534,
                "title": "c-dfs-2-methods-0-n-o-1-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/17498125-18a3-44f1-8921-caf9419ced12_1633608296.9319909.png)\\n\\n***Method - 1:***\\nO(n * word size)\\nn = rows*col\\n```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos, vector<vector<bool>>& visited){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        visited[i][j] = true;\\n        \\n        if(i > 0 && !visited[i-1][j] && board[i-1][j] == word[pos+1] &&search(board ,i-1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j > 0 && !visited[i][j-1] && board[i][j-1] == word[pos+1] &&search(board ,i ,j-1 ,word, pos+1, visited))\\n            return true;\\n        if(i < board.size()-1 && !visited[i+1][j] && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j < board[0].size()-1 && !visited[i][j+1] && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1, visited))\\n            return true;\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0,visited))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n***Method - 2:***\\n0(1)\\n```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        /* ASCII value of A-Z : 65-90 && a-z : 97-122\\n         That\\'s why i took 65, i.e ASCII value of A so that when i subtract it goes out of range of a-z & A-Z \\n         U can take any other no. also but after subtracting it should go out of range of words\\n        It works similar as visited just having less space now*/\\n        board[i][j] -= 65;\\n        \\n        if(i > 0 && board[i-1][j] == word[pos+1] && search(board ,i-1 ,j ,word, pos+1))\\n            return true;\\n        if(j > 0 &&  board[i][j-1] == word[pos+1] && search(board ,i ,j-1 ,word, pos+1))\\n            return true;\\n        if(i < board.size()-1 && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1))\\n            return true;\\n        if(j < board[0].size()-1 && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1))\\n            return true;\\n        \\n        board[i][j] += 65;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos, vector<vector<bool>>& visited){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        visited[i][j] = true;\\n        \\n        if(i > 0 && !visited[i-1][j] && board[i-1][j] == word[pos+1] &&search(board ,i-1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j > 0 && !visited[i][j-1] && board[i][j-1] == word[pos+1] &&search(board ,i ,j-1 ,word, pos+1, visited))\\n            return true;\\n        if(i < board.size()-1 && !visited[i+1][j] && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j < board[0].size()-1 && !visited[i][j+1] && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1, visited))\\n            return true;\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0,visited))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        /* ASCII value of A-Z : 65-90 && a-z : 97-122\\n         That\\'s why i took 65, i.e ASCII value of A so that when i subtract it goes out of range of a-z & A-Z \\n         U can take any other no. also but after subtracting it should go out of range of words\\n        It works similar as visited just having less space now*/\\n        board[i][j] -= 65;\\n        \\n        if(i > 0 && board[i-1][j] == word[pos+1] && search(board ,i-1 ,j ,word, pos+1))\\n            return true;\\n        if(j > 0 &&  board[i][j-1] == word[pos+1] && search(board ,i ,j-1 ,word, pos+1))\\n            return true;\\n        if(i < board.size()-1 && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1))\\n            return true;\\n        if(j < board[0].size()-1 && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1))\\n            return true;\\n        \\n        board[i][j] += 65;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004342,
                "title": "python-simple-solution-dfs",
                "content": "```python\\nclass Solution(object):\\n    def exist(self, board, word):\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, word, i, j): return True\\n        return False\\n                \\n    def dfs(self, board, word, i, j):\\n        if i <= -1 or i >= len(board) or j <= -1 or j >= len(board[0]): return False\\n        if board[i][j] == -1 or board[i][j] != word[0]: return False\\n        if len(word) == 1: return True\\n        \\n        temp, board[i][j] = board[i][j], -1\\n        if self.dfs(board, word[1:], i-1, j): return True\\n        if self.dfs(board, word[1:], i+1, j): return True\\n        if self.dfs(board, word[1:], i, j-1): return True\\n        if self.dfs(board, word[1:], i, j+1): return True\\n        board[i][j] = temp\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution(object):\\n    def exist(self, board, word):\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, word, i, j): return True\\n        return False\\n                \\n    def dfs(self, board, word, i, j):\\n        if i <= -1 or i >= len(board) or j <= -1 or j >= len(board[0]): return False\\n        if board[i][j] == -1 or board[i][j] != word[0]: return False\\n        if len(word) == 1: return True\\n        \\n        temp, board[i][j] = board[i][j], -1\\n        if self.dfs(board, word[1:], i-1, j): return True\\n        if self.dfs(board, word[1:], i+1, j): return True\\n        if self.dfs(board, word[1:], i, j-1): return True\\n        if self.dfs(board, word[1:], i, j+1): return True\\n        board[i][j] = temp\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747149,
                "title": "c-simplest-solution-possible-beats-85-solution",
                "content": "```\\n// Using DFS + Backtracking\\nclass Solution {\\npublic:\\n\\t// Check the boundary cases of the board.\\n    bool isSafe(int N, int M, int i, int j){\\n        return (i<N) && (i>=0) && (j>=0) && (j<M);\\n    }\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j){\\n        if(word[pos]!=board[i][j]){\\n            return false;\\n        }\\n        if(pos==word.length()-1){\\n            return true;\\n        }\\n\\t\\t// to avoid using of this character again in the backtracking\\n        board[i][j] = \\'#\\';\\n        if(isSafe(board.size(), board[0].size(), i+1, j)){\\n            if(backtrack(board, word, pos+1, i+1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i-1, j)){\\n            if(backtrack(board, word, pos+1, i-1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j+1)){\\n            if(backtrack(board, word, pos+1, i, j+1))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j-1)){\\n            if(backtrack(board, word, pos+1, i, j-1))\\n                return true;\\n        }\\n\\t\\t// Reassigning the character as backtracking is complete.\\n        board[i][j] = word[pos];\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0])   // This condition is not necessary as it will also be checked in the backtracking function.\\n                    if(backtrack(board, word, 0, i, j))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nFeel free to ask any doubts in the **comment** section. \\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// Using DFS + Backtracking\\nclass Solution {\\npublic:\\n\\t// Check the boundary cases of the board.\\n    bool isSafe(int N, int M, int i, int j){\\n        return (i<N) && (i>=0) && (j>=0) && (j<M);\\n    }\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j){\\n        if(word[pos]!=board[i][j]){\\n            return false;\\n        }\\n        if(pos==word.length()-1){\\n            return true;\\n        }\\n\\t\\t// to avoid using of this character again in the backtracking\\n        board[i][j] = \\'#\\';\\n        if(isSafe(board.size(), board[0].size(), i+1, j)){\\n            if(backtrack(board, word, pos+1, i+1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i-1, j)){\\n            if(backtrack(board, word, pos+1, i-1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j+1)){\\n            if(backtrack(board, word, pos+1, i, j+1))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j-1)){\\n            if(backtrack(board, word, pos+1, i, j-1))\\n                return true;\\n        }\\n\\t\\t// Reassigning the character as backtracking is complete.\\n        board[i][j] = word[pos];\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0])   // This condition is not necessary as it will also be checked in the backtracking function.\\n                    if(backtrack(board, word, 0, i, j))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639214,
                "title": "python-simple-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        self.W = len(board[0])\\n        self.H = len(board)\\n        self.board = board\\n        \\n        for i in range(self.H):\\n            for j in range(self.W):\\n                if board[i][j] == word[0]:\\n                    if self.dfs(i, j, word[1:]): return True\\n        return False\\n\\n    def dfs(self, i, j, word):\\n        # Stop Condition\\n        if not word:\\n            return True\\n        \\n        # Mark visited point and store origin\\n        self.board[i][j], origin = -1, self.board[i][j]\\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\\n            if 0 <= x < self.H and 0 <= y < self.W and self.board[x][y] == word[0]:\\n\\t\\t\\t\\t# Early Stop\\n                if self.dfs(x, y, word[1:]): return True\\n                \\n        # Revert the origin value\\n        self.board[i][j] = origin\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        self.W = len(board[0])\\n        self.H = len(board)\\n        self.board = board\\n        \\n        for i in range(self.H):\\n            for j in range(self.W):\\n                if board[i][j] == word[0]:\\n                    if self.dfs(i, j, word[1:]): return True\\n        return False\\n\\n    def dfs(self, i, j, word):\\n        # Stop Condition\\n        if not word:\\n            return True\\n        \\n        # Mark visited point and store origin\\n        self.board[i][j], origin = -1, self.board[i][j]\\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\\n            if 0 <= x < self.H and 0 <= y < self.W and self.board[x][y] == word[0]:\\n\\t\\t\\t\\t# Early Stop\\n                if self.dfs(x, y, word[1:]): return True\\n                \\n        # Revert the origin value\\n        self.board[i][j] = origin\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483988,
                "title": "python-easy-to-understand-95-faster",
                "content": "Please let me know if explanation is needed.\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m = len(board)\\n        n = len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    res = self.backtrack(board,m,n,i,j,word[1:])\\n                    if res:\\n                        return True\\n        return False\\n        \\n        \\n    def backtrack(self, board,m,n, i, j, target):\\n        temp = board[i][j]\\n        if len(target) == 0:\\n            return True\\n        board[i][j] = \\'#\\'\\n        for x,y in (i+1,j),(i-1,j),(i,j+1),(i,j-1):\\n            if 0<=x<m and 0<=y<n and target[0] == board[x][y]:\\n                dec = self.backtrack(board,m,n,x,y,target[1:])\\n                if dec:\\n                    return True\\n        board[i][j] = temp\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m = len(board)\\n        n = len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    res = self.backtrack(board,m,n,i,j,word[1:])\\n                    if res:\\n                        return True\\n        return False\\n        \\n        \\n    def backtrack(self, board,m,n, i, j, target):\\n        temp = board[i][j]\\n        if len(target) == 0:\\n            return True\\n        board[i][j] = \\'#\\'\\n        for x,y in (i+1,j),(i-1,j),(i,j+1),(i,j-1):\\n            if 0<=x<m and 0<=y<n and target[0] == board[x][y]:\\n                dec = self.backtrack(board,m,n,x,y,target[1:])\\n                if dec:\\n                    return True\\n        board[i][j] = temp\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27707,
                "title": "three-9-ms-c-backtrack-solutions",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0|| word.size() == 0) return true;\\n        bool find = false;\\n        vector<vector<int>>visited(board.size(), vector<int>(board[0].size(),0));\\n        for(int i = 0 ; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++){\\n                if(board[i][j] == word[0]){\\n                     find = backtrack(i, j, board, word, visited);\\n                     if(find) return find;\\n                }\\n            }\\n        return find;\\n    }\\n    \\n    bool backtrack(int i, int j, vector<vector<char>>& board, string word, vector<vector<int>>& visited){\\n        if(word.size() == 0) return true;\\n        if(i < 0 || i > board.size() - 1 || j < 0 || j > board[0].size() - 1) return false;\\n        if(visited[i][j]) return false;\\n        bool find = false;\\n        if(board[i][j] == word[0]){\\n            word.erase(word.begin());\\n            visited[i][j] = 1;\\n            find = backtrack(i-1,j,board,word,visited) || backtrack(i,j-1,board,word,visited) \\n                || backtrack(i+1,j,board,word,visited) || backtrack(i,j+1,board,word,visited);\\n            visited[i][j] = 0;\\n        }\\n       return find;\\n    }\\n};\\n```\\n***\\n**Update(8/12/2017):** \\n\\n**Solution 2**\\n\\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0) return false;\\n        bool found = false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == word[0]) backtrack(board, 1, i, j, m, n, word, found);\\n                if(found) return true;\\n            }\\n        return false;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\\n***\\n*Update(9/12/2017):*\\n\\n**Solution 3.**\\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.empty()) return false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(board[i][j] == word[0] && BFS(board, i, j, m, n, 0, word)) return true;\\n        return false;\\n    }\\n    \\n    bool BFS(vector<vector<char>>& board, int r, int c, int m, int n, int len, string& word){\\n        if(len == word.size()) return true;\\n        if(r < 0 || c < 0 || r >= m || c >= n || board[r][c] == '#' || board[r][c] != word[len]) return false;\\n        char tmp = board[r][c];\\n        board[r][c] = '#';\\n        bool found =  BFS(board, r + 1, c, m, n, len + 1, word) || BFS(board, r, c + 1, m, n, len + 1, word) ||\\n                      BFS(board, r - 1, c, m, n, len + 1, word) || BFS(board, r, c - 1, m, n, len + 1, word);\\n        board[r][c] = tmp;\\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0|| word.size() == 0) return true;\\n        bool find = false;\\n        vector<vector<int>>visited(board.size(), vector<int>(board[0].size(),0));\\n        for(int i = 0 ; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++){\\n                if(board[i][j] == word[0]){\\n                     find = backtrack(i, j, board, word, visited);\\n                     if(find) return find;\\n                }\\n            }\\n        return find;\\n    }\\n    \\n    bool backtrack(int i, int j, vector<vector<char>>& board, string word, vector<vector<int>>& visited){\\n        if(word.size() == 0) return true;\\n        if(i < 0 || i > board.size() - 1 || j < 0 || j > board[0].size() - 1) return false;\\n        if(visited[i][j]) return false;\\n        bool find = false;\\n        if(board[i][j] == word[0]){\\n            word.erase(word.begin());\\n            visited[i][j] = 1;\\n            find = backtrack(i-1,j,board,word,visited) || backtrack(i,j-1,board,word,visited) \\n                || backtrack(i+1,j,board,word,visited) || backtrack(i,j+1,board,word,visited);\\n            visited[i][j] = 0;\\n        }\\n       return find;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0) return false;\\n        bool found = false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == word[0]) backtrack(board, 1, i, j, m, n, word, found);\\n                if(found) return true;\\n            }\\n        return false;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.empty()) return false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(board[i][j] == word[0] && BFS(board, i, j, m, n, 0, word)) return true;\\n        return false;\\n    }\\n    \\n    bool BFS(vector<vector<char>>& board, int r, int c, int m, int n, int len, string& word){\\n        if(len == word.size()) return true;\\n        if(r < 0 || c < 0 || r >= m || c >= n || board[r][c] == '#' || board[r][c] != word[len]) return false;\\n        char tmp = board[r][c];\\n        board[r][c] = '#';\\n        bool found =  BFS(board, r + 1, c, m, n, len + 1, word) || BFS(board, r, c + 1, m, n, len + 1, word) ||\\n                      BFS(board, r - 1, c, m, n, len + 1, word) || BFS(board, r, c - 1, m, n, len + 1, word);\\n        board[r][c] = tmp;\\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843892,
                "title": "98-java-solution-65-abdullayev",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public boolean exist(char[][] board, String word) {\\n        char c = word.charAt(0);\\n        int m = board.length;\\n        int n = board[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (c == board[i][j] && sub(board, word, i, j, 0, m, n, c))\\n                    return true;\\n\\n        return false;\\n    }\\n\\n    boolean exist(char[][] board, String word, int i, int j, int index, int m, int n) {\\n        if (word.length() == index)\\n            return true;\\n        char c = word.charAt(index);\\n\\n        if (i > 0 && board[i - 1][j] == c\\n                && sub(board, word, i - 1, j, index, m, n, c)) //top\\n            return true;\\n        if (i < m - 1 && board[i + 1][j] == c\\n                && sub(board, word, i + 1, j, index, m, n, c)) //down\\n            return true;\\n        if (j > 0 && board[i][j - 1] == c && sub(board, word, i, j - 1, index, m, n, c)) //left\\n            return true;\\n        if (j < n - 1 && board[i][j + 1] == c) //right\\n            return sub(board, word, i, j + 1, index, m, n, c);\\n\\n        return false;\\n    }\\n\\n    boolean sub(char[][] board, String word, int i, int j,\\n                int index, int m, int n, char c) {\\n        board[i][j] = 0;\\n        if (exist(board, word, i, j, index + 1, m, n))\\n            return true;\\n        else board[i][j] = c;\\n        return false;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public boolean exist(char[][] board, String word) {\\n        char c = word.charAt(0);\\n        int m = board.length;\\n        int n = board[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (c == board[i][j] && sub(board, word, i, j, 0, m, n, c))\\n                    return true;\\n\\n        return false;\\n    }\\n\\n    boolean exist(char[][] board, String word, int i, int j, int index, int m, int n) {\\n        if (word.length() == index)\\n            return true;\\n        char c = word.charAt(index);\\n\\n        if (i > 0 && board[i - 1][j] == c\\n                && sub(board, word, i - 1, j, index, m, n, c)) //top\\n            return true;\\n        if (i < m - 1 && board[i + 1][j] == c\\n                && sub(board, word, i + 1, j, index, m, n, c)) //down\\n            return true;\\n        if (j > 0 && board[i][j - 1] == c && sub(board, word, i, j - 1, index, m, n, c)) //left\\n            return true;\\n        if (j < n - 1 && board[i][j + 1] == c) //right\\n            return sub(board, word, i, j + 1, index, m, n, c);\\n\\n        return false;\\n    }\\n\\n    boolean sub(char[][] board, String word, int i, int j,\\n                int index, int m, int n, char c) {\\n        board[i][j] = 0;\\n        if (exist(board, word, i, j, index + 1, m, n))\\n            return true;\\n        else board[i][j] = c;\\n        return false;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843886,
                "title": "c-dfs-99-faster",
                "content": "``` C++ []\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n*Upvote if you liked it*",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "``` C++ []\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843714,
                "title": "python-3-dfs-with-a-little-bit-of-pruning-t-m-97-94",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n\\n        row, col = len(board), len(board[0])\\n        R, C, seen = range(row), range(col), set()\\n\\n        def dfs(coord, i=0):\\n            \\n            if len(word) == i: return True\\n            \\n            r,c = coord\\n\\n            if (r not in R or c not in C or \\n                coord in seen            or \\n                board[r][c] != word[i]): return False\\n            \\n            seen.add(coord)\\n\\n            res = (dfs((r+1,c), i+1) or dfs((r,c+1), i+1) or\\n                   dfs((r-1,c), i+1) or dfs((r,c-1), i+1))\\n            \\n            seen.remove(coord)\\n\\n            return res\\n\\n        boardCt, wrdCt = Counter(chain(*board)), Counter(word)\\n        if any (boardCt[ch] < wrdCt[ch] for ch in wrdCt): return False\\n\\n        if boardCt[word[0]] > boardCt[word[-1]]: word = word[::-1]\\n        \\n        return any(dfs((r, c))  for c in C for r in R)\\n```\\nhttps://leetcode.com/submissions/detail/848874874/\\n\\nBefore you ask about time & space complexity, I do not know. Recursion baffles me.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n\\n        row, col = len(board), len(board[0])\\n        R, C, seen = range(row), range(col), set()\\n\\n        def dfs(coord, i=0):\\n            \\n            if len(word) == i: return True\\n            \\n            r,c = coord\\n\\n            if (r not in R or c not in C or \\n                coord in seen            or \\n                board[r][c] != word[i]): return False\\n            \\n            seen.add(coord)\\n\\n            res = (dfs((r+1,c), i+1) or dfs((r,c+1), i+1) or\\n                   dfs((r-1,c), i+1) or dfs((r,c-1), i+1))\\n            \\n            seen.remove(coord)\\n\\n            return res\\n\\n        boardCt, wrdCt = Counter(chain(*board)), Counter(word)\\n        if any (boardCt[ch] < wrdCt[ch] for ch in wrdCt): return False\\n\\n        if boardCt[word[0]] > boardCt[word[-1]]: word = word[::-1]\\n        \\n        return any(dfs((r, c))  for c in C for r in R)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843486,
                "title": "dfs-backtracking-in-c-js-python",
                "content": "# C++\\n```cpp\\nclass   Solution\\n{\\n    public:\\n\\n    bool    exist(vector<vector<char>>& board, string word)\\n    {\\n            int     rows, cols;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            for (int i = 0; i < rows; i++)\\n                for (int j = 0; j < cols; j++)\\n                    if (dfs(board, word, 0, i, j))\\n\\t\\t\\t    return (true);\\n            return (false);\\n    }\\n\\n    bool    dfs(vector<vector<char>> &board, string &word, int i, int x, int y)\\n    {\\n            int     rows, cols;\\n            bool    found;\\n            char    c;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            if (x < 0 || x == rows || y < 0 || y == cols || word[i] != board[x][y])\\n                return (false);\\n            if (i == (int) word.length() - 1)\\n                return (true);\\n            c = board[x][y];\\n            board[x][y] = 0;\\n            found = dfs(board, word, i + 1, x + 1, y) ||\\n                    dfs(board, word, i + 1, x - 1, y) ||\\n                    dfs(board, word, i + 1, x, y + 1) ||\\n                    dfs(board, word, i + 1, x, y - 1);\\n            board[x][y] = c;\\n            return (found);\\n    }\\n};\\n```\\n# Js\\n```js\\nvar exist = function(board, word) {\\n    let i = -1\\n    while (++i < board.length) {\\n        let j = -1\\n        while (++j < board[0].length) {\\n            if (dfs(board, word, 0, i, j))\\n                return true\\n        }\\n    }\\n    return false\\n};\\n\\nvar dfs = function(board, word, index, x, y) {\\n    if (index == word.length)\\n        return true\\n    let c = board[0].length\\n    let r = board.length\\n    if (x < 0 || y < 0 || x > r - 1 || y > c - 1 || board[x][y] != word[index])\\n        return false\\n    board[x][y] = \\'#\\'\\n    let isFound = (\\n        dfs(board, word, index + 1, x + 1, y) ||\\n        dfs(board, word, index + 1, x - 1, y) ||\\n        dfs(board, word, index + 1, x, y + 1) ||\\n        dfs(board, word, index + 1, x, y - 1)\\n    )\\n    board[x][y] = word[index]\\n    return isFound\\n}\\n```\\n# Python\\n```py\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                if self.DFS(board, word, 0, x, y):\\n                    return True\\n        return False\\n\\n    def DFS(self, board: List[List[str]], word:str, index: int, x: int, y: int) -> bool:\\n        if index == len(word):\\n            return True\\n        c = len(board[0])\\n        r = len(board)\\n        if x < 0 or y < 0 or x > r - 1 or y > c - 1 or word[index] != board[x][y] :\\n            return False\\n        board[x][y] = chr(0)\\n        found = (\\n            self.DFS(board, word, index + 1, x + 1, y) or\\n            self.DFS(board, word, index + 1, x - 1, y) or\\n            self.DFS(board, word, index + 1, x, y + 1) or\\n            self.DFS(board, word, index + 1, x, y - 1))\\n        board[x][y] = word[index]\\n        return found\\n```\\n# C\\n```c\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c);\\n\\nbool    exist(char** board, int boardSize, int* boardColSize, char * word)\\n{\\n        if (!board || !boardSize || !boardColSize) return (false);\\n        if (!word)  return (true);\\n        for (int i = 0; i < boardSize; i++)\\n            for (int j = 0; j < boardColSize[0]; j++)\\n                if (solve(board, word, 0, i, j, boardSize, boardColSize[0]))\\n                    return (true);\\n        return (false);\\n}\\n\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c)\\n{\\n        bool    found;\\n        char    temp;\\n\\n        if (x < 0 || x == r || y < 0 || y == c || word[i] != board[x][y])\\n\\t\\t    return (false);\\n        if (i == strlen(word) - 1)\\n\\t\\t    return (true);\\n        temp = board[x][y];\\n        board[x][y] = 0;\\n        found = solve(board, word, i + 1, x + 1, y, r, c) ||\\n                solve(board, word, i + 1, x - 1, y, r, c) ||\\n                solve(board, word, i + 1, x, y + 1, r, c) ||\\n                solve(board, word, i + 1, x, y - 1, r, c);\\n        board[x][y] = temp;\\n        return (found);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```cpp\\nclass   Solution\\n{\\n    public:\\n\\n    bool    exist(vector<vector<char>>& board, string word)\\n    {\\n            int     rows, cols;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            for (int i = 0; i < rows; i++)\\n                for (int j = 0; j < cols; j++)\\n                    if (dfs(board, word, 0, i, j))\\n\\t\\t\\t    return (true);\\n            return (false);\\n    }\\n\\n    bool    dfs(vector<vector<char>> &board, string &word, int i, int x, int y)\\n    {\\n            int     rows, cols;\\n            bool    found;\\n            char    c;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            if (x < 0 || x == rows || y < 0 || y == cols || word[i] != board[x][y])\\n                return (false);\\n            if (i == (int) word.length() - 1)\\n                return (true);\\n            c = board[x][y];\\n            board[x][y] = 0;\\n            found = dfs(board, word, i + 1, x + 1, y) ||\\n                    dfs(board, word, i + 1, x - 1, y) ||\\n                    dfs(board, word, i + 1, x, y + 1) ||\\n                    dfs(board, word, i + 1, x, y - 1);\\n            board[x][y] = c;\\n            return (found);\\n    }\\n};\\n```\n```js\\nvar exist = function(board, word) {\\n    let i = -1\\n    while (++i < board.length) {\\n        let j = -1\\n        while (++j < board[0].length) {\\n            if (dfs(board, word, 0, i, j))\\n                return true\\n        }\\n    }\\n    return false\\n};\\n\\nvar dfs = function(board, word, index, x, y) {\\n    if (index == word.length)\\n        return true\\n    let c = board[0].length\\n    let r = board.length\\n    if (x < 0 || y < 0 || x > r - 1 || y > c - 1 || board[x][y] != word[index])\\n        return false\\n    board[x][y] = \\'#\\'\\n    let isFound = (\\n        dfs(board, word, index + 1, x + 1, y) ||\\n        dfs(board, word, index + 1, x - 1, y) ||\\n        dfs(board, word, index + 1, x, y + 1) ||\\n        dfs(board, word, index + 1, x, y - 1)\\n    )\\n    board[x][y] = word[index]\\n    return isFound\\n}\\n```\n```py\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                if self.DFS(board, word, 0, x, y):\\n                    return True\\n        return False\\n\\n    def DFS(self, board: List[List[str]], word:str, index: int, x: int, y: int) -> bool:\\n        if index == len(word):\\n            return True\\n        c = len(board[0])\\n        r = len(board)\\n        if x < 0 or y < 0 or x > r - 1 or y > c - 1 or word[index] != board[x][y] :\\n            return False\\n        board[x][y] = chr(0)\\n        found = (\\n            self.DFS(board, word, index + 1, x + 1, y) or\\n            self.DFS(board, word, index + 1, x - 1, y) or\\n            self.DFS(board, word, index + 1, x, y + 1) or\\n            self.DFS(board, word, index + 1, x, y - 1))\\n        board[x][y] = word[index]\\n        return found\\n```\n```c\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c);\\n\\nbool    exist(char** board, int boardSize, int* boardColSize, char * word)\\n{\\n        if (!board || !boardSize || !boardColSize) return (false);\\n        if (!word)  return (true);\\n        for (int i = 0; i < boardSize; i++)\\n            for (int j = 0; j < boardColSize[0]; j++)\\n                if (solve(board, word, 0, i, j, boardSize, boardColSize[0]))\\n                    return (true);\\n        return (false);\\n}\\n\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c)\\n{\\n        bool    found;\\n        char    temp;\\n\\n        if (x < 0 || x == r || y < 0 || y == c || word[i] != board[x][y])\\n\\t\\t    return (false);\\n        if (i == strlen(word) - 1)\\n\\t\\t    return (true);\\n        temp = board[x][y];\\n        board[x][y] = 0;\\n        found = solve(board, word, i + 1, x + 1, y, r, c) ||\\n                solve(board, word, i + 1, x - 1, y, r, c) ||\\n                solve(board, word, i + 1, x, y + 1, r, c) ||\\n                solve(board, word, i + 1, x, y - 1, r, c);\\n        board[x][y] = temp;\\n        return (found);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733353,
                "title": "python-elegant-short-no-tle",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*m*k)\\n    Memory: O(k)\\n\\n    where k - word length\\n    \"\"\"\\n\\n    VISITED = \\'#\\'\\n\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        n, m = len(board), len(board[0])\\n\\n        beginning = end = 0\\n        for r in range(n):\\n            for c in range(m):\\n                if board[r][c] == word[0]:\\n                    beginning += 1\\n                elif board[r][c] == word[-1]:\\n                    end += 1\\n\\n        if beginning > end:\\n            word = word[::-1]\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if self.dfs(board, i, j, 0, word):\\n                    return True\\n\\n        return False\\n\\n    @classmethod\\n    def dfs(cls, board: List[List[str]], i: int, j: int, k: int, word: str) -> bool:\\n        if k == len(word):\\n            return True\\n\\n        n, m = len(board), len(board[0])\\n        if (i < 0 or i >= n) or (j < 0 or j >= m) or word[k] != board[i][j]:\\n            return False\\n\\n        board[i][j] = cls.VISITED\\n        res = cls.dfs(board, i + 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i - 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i, j + 1, k + 1, word) or \\\\\\n              cls.dfs(board, i, j - 1, k + 1, word)\\n        board[i][j] = word[k]\\n\\n        return res\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*m*k)\\n    Memory: O(k)\\n\\n    where k - word length\\n    \"\"\"\\n\\n    VISITED = \\'#\\'\\n\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        n, m = len(board), len(board[0])\\n\\n        beginning = end = 0\\n        for r in range(n):\\n            for c in range(m):\\n                if board[r][c] == word[0]:\\n                    beginning += 1\\n                elif board[r][c] == word[-1]:\\n                    end += 1\\n\\n        if beginning > end:\\n            word = word[::-1]\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if self.dfs(board, i, j, 0, word):\\n                    return True\\n\\n        return False\\n\\n    @classmethod\\n    def dfs(cls, board: List[List[str]], i: int, j: int, k: int, word: str) -> bool:\\n        if k == len(word):\\n            return True\\n\\n        n, m = len(board), len(board[0])\\n        if (i < 0 or i >= n) or (j < 0 or j >= m) or word[k] != board[i][j]:\\n            return False\\n\\n        board[i][j] = cls.VISITED\\n        res = cls.dfs(board, i + 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i - 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i, j + 1, k + 1, word) or \\\\\\n              cls.dfs(board, i, j - 1, k + 1, word)\\n        board[i][j] = word[k]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712727,
                "title": "java-easy-understandable-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visiting = new boolean[board.length][board[0].length];\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(word.charAt(0) == board[i][j]){\\n                    boolean found = dfs(0, i, j, visiting, board, word);\\n                    if(found){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean dfs(int idx, int row, int col, boolean[][] visiting, char[][] board, String word){\\n        if(idx == word.length()){\\n            return true;\\n        }\\n        if(row < 0 || row == board.length || col < 0 || col == board[0].length || visiting[row][col] || word.charAt(idx) != board[row][col]){\\n            return false;\\n        }\\n        visiting[row][col] = true;\\n        boolean left = dfs(idx + 1, row, col - 1, visiting, board, word);\\n        boolean right = dfs(idx + 1, row, col + 1, visiting, board, word);\\n        boolean up = dfs(idx + 1, row - 1, col, visiting, board, word);\\n        boolean down = dfs(idx + 1, row + 1, col, visiting, board, word);\\n        visiting[row][col] = false;\\n        return up || down || left || right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visiting = new boolean[board.length][board[0].length];\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(word.charAt(0) == board[i][j]){\\n                    boolean found = dfs(0, i, j, visiting, board, word);\\n                    if(found){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean dfs(int idx, int row, int col, boolean[][] visiting, char[][] board, String word){\\n        if(idx == word.length()){\\n            return true;\\n        }\\n        if(row < 0 || row == board.length || col < 0 || col == board[0].length || visiting[row][col] || word.charAt(idx) != board[row][col]){\\n            return false;\\n        }\\n        visiting[row][col] = true;\\n        boolean left = dfs(idx + 1, row, col - 1, visiting, board, word);\\n        boolean right = dfs(idx + 1, row, col + 1, visiting, board, word);\\n        boolean up = dfs(idx + 1, row - 1, col, visiting, board, word);\\n        boolean down = dfs(idx + 1, row + 1, col, visiting, board, word);\\n        visiting[row][col] = false;\\n        return up || down || left || right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936355,
                "title": "js-backtracking-read-this-if-you-are-having-problems-using-a-set",
                "content": "I spent some time confused as to why my solution, which was seamingly very similar to other\\'s in Java and Python was not working. There are two main ways to solve this problem with backtracking: changing the value of the board when visiting a position, or keeping a record of your visited positions and check against it. \\n\\nA Set is a great data structure for that record of visited positions. There is a caveat, however. In JavaScript, values put into the Set are stored by reference, so when looking them up, if you pass anything else other than the same reference, your item wont be found.\\n\\nWhy is this relevant?\\n\\n```\\nconst set = new Set();\\n//.....\\nconst arr = [1,4]\\nset.add(arr);\\n\\nset.has(arr) // true\\nset.has([1,4]) // false!\\n\\n```\\nAs you can see, looking up an array (or object) by values does not work, since when we pass the `[1,4]` array, we are essentially creating a new array, so the references are different.\\n\\nTo solve this, you have to convert your array to a unique value. I converted the coordinate array to a string with an \"r|c\" format. \\n\\nKeep in mind that the way in which you convert your array to a unique value has a runtime impact. Avoid `array.join()` or other iterartive approaches if possible.\\n\\nI hope this is helpful to anyone trying to implement this with a Set.\\n\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar exist = function(board, word) {\\n    \\n    const M = board.length;\\n    const N = board[0].length;\\n    \\n    const path = new Set();\\n    \\n    function backtrack(r,c,idx){\\n        \\n        if(idx === word.length) return true;\\n        if(r < 0 || c < 0 || r >= M || c >= N) return false;\\n        if(board[r][c] !== word.charAt(idx)) return false;\\n        \\n        const arrStr = `${r}|${c}`;\\n        if(path.has(arrStr)) return false;\\n        \\n        path.add(arrStr);\\n        const found = \\n              backtrack(r+1, c, idx+1) ||\\n              backtrack(r-1,c,idx+1) || \\n              backtrack(r,c+1, idx+1) ||               \\n              backtrack(r,c-1, idx+1);\\n        path.delete(arrStr);            \\n        return found;\\n    \\n    }\\n   \\n    \\n    for(let i = 0; i<M; i++){\\n        for(let j = 0; j<N; j++){\\n            if(board[i][j] === word.charAt(0))\\n                if(backtrack(i,j,0)) return true;        \\n        }\\n    }\\n\\t\\n    return false;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nconst set = new Set();\\n//.....\\nconst arr = [1,4]\\nset.add(arr);\\n\\nset.has(arr) // true\\nset.has([1,4]) // false!\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737606,
                "title": "java-easiest-code-with-comments-dfs-backtracking-80-faster",
                "content": "```\\nclass Solution {\\n    boolean flag = false; // Initially word not found\\n    public boolean exist(char[][] board, String word) {\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && !flag){ //only considering characters that are same as initial character of the string\\n                    boolean[][] visited = new boolean[board.length][board[0].length]; // boolean array to keep track of all the visited elements\\n                    backtrack(board,word,visited,i,j,0); // 0 is the pointer at first character of the word \\n                }\\n            }\\n        return flag;\\n    }\\n    public void backtrack(char[][] board,String word,boolean[][] visited,int i,int j,int idx){\\n        if(flag) return;\\n        if(idx == word.length() || i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j] == true || word.charAt(idx) != board[i][j]) return;\\n        if(idx == word.length()-1){\\n            flag = !flag; \\n            return;\\n        }\\n        idx++;\\n        visited[i][j] = true;\\n        backtrack(board,word,visited,i-1,j,idx);\\n        backtrack(board,word,visited,i,j+1,idx);\\n        backtrack(board,word,visited,i+1,j,idx);\\n        backtrack(board,word,visited,i,j-1,idx);\\n        idx--;\\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    boolean flag = false; // Initially word not found\\n    public boolean exist(char[][] board, String word) {\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && !flag){ //only considering characters that are same as initial character of the string\\n                    boolean[][] visited = new boolean[board.length][board[0].length]; // boolean array to keep track of all the visited elements\\n                    backtrack(board,word,visited,i,j,0); // 0 is the pointer at first character of the word \\n                }\\n            }\\n        return flag;\\n    }\\n    public void backtrack(char[][] board,String word,boolean[][] visited,int i,int j,int idx){\\n        if(flag) return;\\n        if(idx == word.length() || i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j] == true || word.charAt(idx) != board[i][j]) return;\\n        if(idx == word.length()-1){\\n            flag = !flag; \\n            return;\\n        }\\n        idx++;\\n        visited[i][j] = true;\\n        backtrack(board,word,visited,i-1,j,idx);\\n        backtrack(board,word,visited,i,j+1,idx);\\n        backtrack(board,word,visited,i+1,j,idx);\\n        backtrack(board,word,visited,i,j-1,idx);\\n        idx--;\\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706675,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\n// Please Upvote if you found it helpful\\n\\nclass Solution {\\npublic:\\n    bool visited[6][6];\\n    \\n    bool solve(vector<vector<char>>& board,string word,int m,int n,string s,int r,int c)\\n    {\\n        if(s==word) return true;\\n        if(r<0 || c<0 || r>=m || c>=n || board[r][c]!=word[s.size()] || visited[r][c]==true)\\n            return false;\\n        \\n        s+=board[r][c];\\n        visited[r][c]=true;\\n\\t\\tint d = solve(board,word,m,n,s,r+1,c);               // Moving downward\\n        int u = solve(board,word,m,n,s,r-1,c);               // Moving upward\\n        int f = solve(board,word,m,n,s,r,c+1);               // Moving right or forward\\n        int b = solve(board,word,m,n,s,r,c-1);               // Moving left or backward\\n        visited[r][c]=false;\\n        s.pop_back();\\n        return u || d || f || b;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size(),n=board[0].size();\\n        string s=\"\";\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(board[i][j]==word[0])\\n                    if(solve(board,word,m,n,s,i,j))\\n                        return true;\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool visited[6][6];\\n    \\n    bool solve(vector<vector<char>>& board,string word,int m,int n,string s,int r,int c)\\n    {\\n        if(s==word) return true;\\n        if(r<0 || c<0 || r>=m || c>=n || board[r][c]!=word[s.size()] || visited[r][c]==true)\\n            return false;\\n        \\n        s+=board[r][c];\\n        visited[r][c]=true;\\n\\t\\tint d = solve(board,word,m,n,s,r+1,c);               // Moving downward\\n        int u = solve(board,word,m,n,s,r-1,c);               // Moving upward\\n        int f = solve(board,word,m,n,s,r,c+1);               // Moving right or forward\\n        int b = solve(board,word,m,n,s,r,c-1);               // Moving left or backward\\n        visited[r][c]=false;\\n        s.pop_back();\\n        return u || d || f || b;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1507992,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507663,
                "title": "simple-java-solution-reusing-board-runtime-94-ms-faster-than-80-12-of-java-online-submissions",
                "content": "Here, I am not using any extra boolean multidimensional array to track found characters but reusing the board itself. Reason : adding a boolean[][] to the code just increases the space complexity for no reason.\\n\\n```\\nclass Solution {\\n    int row;\\n    int col;\\n    public boolean exist(char[][] board, String word) {\\n        row = board.length;\\n        col = board[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(crosswordUtil(board, i, j, 0, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean crosswordUtil(char[][] board, int i, int j, int startIndex, String word) {\\n        // this denotes that all chars have been found. index is from 0 to word.length() - 1\\n        if(startIndex == word.length())\\n            return true;\\n        // base case for exit criteria\\n        if(i > row -1 || i < 0 || j < 0 || j > col - 1|| board[i][j] != word.charAt(startIndex))\\n        return false;\\n        // mark the current board cell as visited\\n        board[i][j] = \\'$\\';\\n        // check if next char in word can be found in any of the four directions - North, South, West Or East of the current position denoted by startIndex.\\n        boolean exists = crosswordUtil(board, i-1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i+1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j-1, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j+1, startIndex+1, word);\\n        // restore the element of board[i][j] with the char at word\\'s startIndex\\n        board[i][j] = word.charAt(startIndex);\\n        // if everything is fine, then exist will be true. Else it will be false\\n        return exists;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int row;\\n    int col;\\n    public boolean exist(char[][] board, String word) {\\n        row = board.length;\\n        col = board[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(crosswordUtil(board, i, j, 0, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean crosswordUtil(char[][] board, int i, int j, int startIndex, String word) {\\n        // this denotes that all chars have been found. index is from 0 to word.length() - 1\\n        if(startIndex == word.length())\\n            return true;\\n        // base case for exit criteria\\n        if(i > row -1 || i < 0 || j < 0 || j > col - 1|| board[i][j] != word.charAt(startIndex))\\n        return false;\\n        // mark the current board cell as visited\\n        board[i][j] = \\'$\\';\\n        // check if next char in word can be found in any of the four directions - North, South, West Or East of the current position denoted by startIndex.\\n        boolean exists = crosswordUtil(board, i-1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i+1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j-1, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j+1, startIndex+1, word);\\n        // restore the element of board[i][j] with the char at word\\'s startIndex\\n        board[i][j] = word.charAt(startIndex);\\n        // if everything is fine, then exist will be true. Else it will be false\\n        return exists;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424255,
                "title": "python-clean",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        def dfs(row, column, index):\\n            if index == len(word): return True\\n            path.add((row, column))\\n            for r, c in [(row-1, column), (row, column-1), (row, column+1), (row+1, column)]:\\n                if r in range(M) and c in range(N) and board[r][c] == word[index] and (r, c) not in path:\\n                    if dfs(r, c, index+1): return True\\n            path.remove((row, column))\\n        \\n        M, N = len(board), len(board[0])\\n        path = set()\\n        for row in range(M):\\n            for column in range(N):\\n                if board[row][column] == word[0]:\\n                    if dfs(row, column, 1): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        def dfs(row, column, index):\\n            if index == len(word): return True\\n            path.add((row, column))\\n            for r, c in [(row-1, column), (row, column-1), (row, column+1), (row+1, column)]:\\n                if r in range(M) and c in range(N) and board[r][c] == word[index] and (r, c) not in path:\\n                    if dfs(r, c, index+1): return True\\n            path.remove((row, column))\\n        \\n        M, N = len(board), len(board[0])\\n        path = set()\\n        for row in range(M):\\n            for column in range(N):\\n                if board[row][column] == word[0]:\\n                    if dfs(row, column, 1): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419624,
                "title": "c-solution-dfs-backtracking-explanation",
                "content": "This is a standard problem of DFS + Backtracking. One of the most frequently asked question in **Interviews**\\n\\n**Basic Idea :**\\n\\nWe iterate over every element of grid checking if it is equals to first element of given word. If found then we call the dfs() function with current position of board with starting position of word. \\n\\n1. Lets see the Base Condition : \\n\\t* Now in DFS check if current position of board position matches with current index of word. If no then return false. Else continue checking its adjacent for a match using dfs(). \\n\\t* Also, if current index of word equals to size of word, return true.\\n\\n2. Moving on, let\\'s develop the logic for checking the adjacent positions that are not yet visited. Here we use a simple trick for backtracking : \\n\\t* When we enter the dfs(), we mark current position as visited using this line : \\n`char curr = board[i][j]; board[i][j] = \\'*\\' `. \\n\\t* When checking for all the adjacents is finished, we again flip the value of current position to original, `board[i][j] = curr;`.\\n\\n# Algorithm : \\n\\n```\\nstatic int X[4] = {-1,1,0,0};\\nstatic int Y[4] = {0,0,-1,1};\\nint m, n, s;    \\n\\nbool isSafe(vector<vector<char>>& board, int x, int y, int k)\\n{\\n\\treturn (x >= 0 && y >=0 && x < m && y < n && k+1 < s && board[x][y] != \\'*\\');\\n}\\nbool dfs(vector<vector<char>>& board, string& word, int i, int j, int k)\\n{   \\n\\tif(board[i][j] != word[k]) return false;\\n\\tif(k == s-1) return true;\\n\\tchar curr = board[i][j];\\n\\tboard[i][j] = \\'*\\';\\n\\tbool success = false;\\n\\n\\tfor(int p=0; p<4; p++)\\n\\t{\\n\\t\\tint x = i + X[p];\\n\\t\\tint y = j + Y[p];\\n\\t\\tif(isSafe(board, x, y, k))\\n\\t\\t{\\n\\t\\t\\tsuccess = (success || dfs(board, word, x, y, k+1));\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = curr;              // Backtrack\\n\\treturn success;  \\n}\\n    \\nbool exist(vector<vector<char>>& board, string word) {\\n\\tm = board.size();\\n\\tif(m==0) return false;\\n\\tn = board[0].size();\\n\\ts = word.size();\\n\\tfor(int i=0; i<m; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j] == word[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(board, word, i, j, 0)) return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Follow Up :**\\n\\n* Similar Problems : \\n\\t* [Word Search II](https://leetcode.com/problems/word-search-ii/)\\n\\n*Feel free to ask anything or correct me. \\nHope you understood the solution. If you liked it do upvote :)*\\n\\n**Update :**\\n\\nThanks [@Blast_d](https://leetcode.com/Blast_d/) for your suggestion to add `isSafe()`. \\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nstatic int X[4] = {-1,1,0,0};\\nstatic int Y[4] = {0,0,-1,1};\\nint m, n, s;    \\n\\nbool isSafe(vector<vector<char>>& board, int x, int y, int k)\\n{\\n\\treturn (x >= 0 && y >=0 && x < m && y < n && k+1 < s && board[x][y] != \\'*\\');\\n}\\nbool dfs(vector<vector<char>>& board, string& word, int i, int j, int k)\\n{   \\n\\tif(board[i][j] != word[k]) return false;\\n\\tif(k == s-1) return true;\\n\\tchar curr = board[i][j];\\n\\tboard[i][j] = \\'*\\';\\n\\tbool success = false;\\n\\n\\tfor(int p=0; p<4; p++)\\n\\t{\\n\\t\\tint x = i + X[p];\\n\\t\\tint y = j + Y[p];\\n\\t\\tif(isSafe(board, x, y, k))\\n\\t\\t{\\n\\t\\t\\tsuccess = (success || dfs(board, word, x, y, k+1));\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = curr;              // Backtrack\\n\\treturn success;  \\n}\\n    \\nbool exist(vector<vector<char>>& board, string word) {\\n\\tm = board.size();\\n\\tif(m==0) return false;\\n\\tn = board[0].size();\\n\\ts = word.size();\\n\\tfor(int i=0; i<m; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j] == word[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(board, word, i, j, 0)) return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168111,
                "title": "c-solution-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j, int r, int c){\\n        if(i >= r || j >= c || i < 0 || j < 0 || word[pos] != board[i][j])\\n            return false;\\n    \\n        if(pos == word.length()-1)\\n            return true;\\n        \\n        board[i][j] = \\'#\\'; // to avoid using of this character again in the backtracking\\n        if(backtrack(board, word, pos+1, i+1, j, r, c) || backtrack(board, word, pos+1, i-1, j, r, c) || backtrack(board, word, pos+1, i, j+1, r, c) || backtrack(board, word, pos+1, i, j-1, r, c))\\n            return true;\\n\\t\\n        board[i][j] = word[pos]; // Reassigning the character as backtracking is complete.\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                if(backtrack(board, word, 0, i, j, board.size(), board[0].size()))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j, int r, int c){\\n        if(i >= r || j >= c || i < 0 || j < 0 || word[pos] != board[i][j])\\n            return false;\\n    \\n        if(pos == word.length()-1)\\n            return true;\\n        \\n        board[i][j] = \\'#\\'; // to avoid using of this character again in the backtracking\\n        if(backtrack(board, word, pos+1, i+1, j, r, c) || backtrack(board, word, pos+1, i-1, j, r, c) || backtrack(board, word, pos+1, i, j+1, r, c) || backtrack(board, word, pos+1, i, j-1, r, c))\\n            return true;\\n\\t\\n        board[i][j] = word[pos]; // Reassigning the character as backtracking is complete.\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                if(backtrack(board, word, 0, i, j, board.size(), board[0].size()))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113871,
                "title": "cpp-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,1,-1,0};\\n    int y[4]={-1,0,0,1};\\n    bool solve(int i,int j,vector<vector<char>>& board,vector<vector<int>>&vis,int k,string word,int m,int n)\\n    {\\n        if(k==word.size())\\n            return true;\\n        if(i<0||j<0||i>=m||j>=n)\\n            return false;\\n        if(vis[i][j]||word[k]!=board[i][j])\\n            return false;\\n        vis[i][j]=1;\\n        for(int r=0;r<4;r++)\\n        {\\n            if(solve(i+x[r],j+y[r],board,vis,k+1,word,m,n))\\n                return true; \\n        } \\n        vis[i][j]=0;\\n       return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[i].size();j++)\\n            {\\n                if(word[0]==board[i][j])\\n                {\\n                    int k=0;\\n                    if(solve(i,j,board,vis,k,word,m,n))\\n                       return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n                       \\n                     \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,1,-1,0};\\n    int y[4]={-1,0,0,1};\\n    bool solve(int i,int j,vector<vector<char>>& board,vector<vector<int>>&vis,int k,string word,int m,int n)\\n    {\\n        if(k==word.size())\\n            return true;\\n        if(i<0||j<0||i>=m||j>=n)\\n            return false;\\n        if(vis[i][j]||word[k]!=board[i][j])\\n            return false;\\n        vis[i][j]=1;\\n        for(int r=0;r<4;r++)\\n        {\\n            if(solve(i+x[r],j+y[r],board,vis,k+1,word,m,n))\\n                return true; \\n        } \\n        vis[i][j]=0;\\n       return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[i].size();j++)\\n            {\\n                if(word[0]==board[i][j])\\n                {\\n                    int k=0;\\n                    if(solve(i,j,board,vis,k,word,m,n))\\n                       return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n                       \\n                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044373,
                "title": "java-dfs-solution",
                "content": "```java\\nclass Solution {\\n    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        // Traverse board until encounter first char of word\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && dfs(board, i, j, 0, word)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean dfs(char[][] board, int row, int col, int soFar, String word){\\n        // Word search complete\\n        if(soFar == word.length()) return true;\\n        // OUT OF BOUNDS\\n        if(row < 0 || row >= board.length || col < 0 || col >= board[0].length || board[row][col] != word.charAt(soFar)) return false;\\n        // Consecutive word so far\\n        else{\\n            char current = board[row][col];\\n            // Avoid using the cell twice\\n            board[row][col] = \\'#\\';\\n            // Explore Neighbors\\n            for(int[] dir: directions)\\n                if(dfs(board, row + dir[0], col + dir[1], soFar + 1, word)) return true;\\n            // In case all directions failed\\n            board[row][col] = current;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        // Traverse board until encounter first char of word\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && dfs(board, i, j, 0, word)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean dfs(char[][] board, int row, int col, int soFar, String word){\\n        // Word search complete\\n        if(soFar == word.length()) return true;\\n        // OUT OF BOUNDS\\n        if(row < 0 || row >= board.length || col < 0 || col >= board[0].length || board[row][col] != word.charAt(soFar)) return false;\\n        // Consecutive word so far\\n        else{\\n            char current = board[row][col];\\n            // Avoid using the cell twice\\n            board[row][col] = \\'#\\';\\n            // Explore Neighbors\\n            for(int[] dir: directions)\\n                if(dfs(board, row + dir[0], col + dir[1], soFar + 1, word)) return true;\\n            // In case all directions failed\\n            board[row][col] = current;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043968,
                "title": "python-only-need-to-pass-indices-no-board-or-word",
                "content": "```python\\nclass Solution:\\n    \\n    def exist(self, board, word):      \\n        self.board, self.word = board, word         \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):                \\n                if self.dfs(i, j, 0):\\n                    return True                    \\n        return False\\n    \\n    \\n    def dfs(self, i, j, k):                        \\n        \\n        if not self.board[i][j] == self.word[k]: return False # our termination condition  \\n        \\n        if len(self.word) == k+1: return True   # our success condition           \\n        \\n        self.board[i][j] = \"#\"   # start backtracking     \\n        \\n        for a, b in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n            if not (0 <= a < len(self.board) and 0 <= b < len(self.board[0])): continue\\n            if self.dfs(a, b, k+1): return True                        \\n            \\n        self.board[i][j] = self.word[k]    # end backtracking    \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def exist(self, board, word):      \\n        self.board, self.word = board, word         \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):                \\n                if self.dfs(i, j, 0):\\n                    return True                    \\n        return False\\n    \\n    \\n    def dfs(self, i, j, k):                        \\n        \\n        if not self.board[i][j] == self.word[k]: return False # our termination condition  \\n        \\n        if len(self.word) == k+1: return True   # our success condition           \\n        \\n        self.board[i][j] = \"#\"   # start backtracking     \\n        \\n        for a, b in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n            if not (0 <= a < len(self.board) and 0 <= b < len(self.board[0])): continue\\n            if self.dfs(a, b, k+1): return True                        \\n            \\n        self.board[i][j] = self.word[k]    # end backtracking    \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875183,
                "title": "java-solution-clean-code-with-full-comments-using-only-backtracking",
                "content": "```\\npublic boolean exist(char[][] board, String word) // Main method.\\n{\\n        for(int i = 0; i < board.length; i++)  // Iterate through the matrix, while doing so, call the support method so it will do the calculations.\\n        {\\n            for(int j = 0; j < board[0].length; j++) \\n            {                \\n                if(helper(board, i, j, word, 0))// Here the main method gets the results form the support method.\\n                {\\n                   return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean helper(char[][] board, int x, int y, String word, int end) // Support method.\\n    {     \\n        if(x < 0 || board.length-1 < x || y < 0 || board[0].length-1 < y || board[x][y] == \\'x\\' || word.charAt(end) != board[x][y]) // Check if we are in the boundaries, or the spot has been visited or that the current letter do not match to the letter in the matrix.\\n\\t    {\\n            return false;\\n        }\\n        \\n        if(end == word.length()-1) // If we have reached the end of the given word, we found it in the matrix.\\n        {\\n            return true;\\n        }\\n          \\n        char temp = board[x][y]; // Make a copy of the current spot that we are in.\\n\\t\\t\\tboard[x][y] = \\'x\\'; // Overwrite the current spot so that we will know that we have been here before (for the rest of the current iteration).\\n           \\n        boolean up = helper(board, x-1, y, word, end+1);       // Options of traversing the matrix.\\n        boolean down = helper(board, x+1, y, word, end+1);\\n        boolean left = helper(board, x, y-1, word, end+1);\\n        boolean right = helper(board, x, y+1, word, end+1);\\n        \\n        if(up || down || left || right) // If the options are valid, return true.\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n             board[x][y] = temp; // Else overwrite the current spot with the copy of the original value for the next iteration.\\n             return false;\\n\\t\\t}\\n\\t\\t\\t \\n          // Runtime: 5 ms, faster than 83.51% of Java online submissions for Word Search.\\n\\t\\t   // Memory Usage: 41.3 MB, less than 73.34% of Java online submissions for Word Search.\\n }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic boolean exist(char[][] board, String word) // Main method.\\n{\\n        for(int i = 0; i < board.length; i++)  // Iterate through the matrix, while doing so, call the support method so it will do the calculations.\\n        {\\n            for(int j = 0; j < board[0].length; j++) \\n            {                \\n                if(helper(board, i, j, word, 0))// Here the main method gets the results form the support method.\\n                {\\n                   return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean helper(char[][] board, int x, int y, String word, int end) // Support method.\\n    {     \\n        if(x < 0 || board.length-1 < x || y < 0 || board[0].length-1 < y || board[x][y] == \\'x\\' || word.charAt(end) != board[x][y]) // Check if we are in the boundaries, or the spot has been visited or that the current letter do not match to the letter in the matrix.\\n\\t    {\\n            return false;\\n        }\\n        \\n        if(end == word.length()-1) // If we have reached the end of the given word, we found it in the matrix.\\n        {\\n            return true;\\n        }\\n          \\n        char temp = board[x][y]; // Make a copy of the current spot that we are in.\\n\\t\\t\\tboard[x][y] = \\'x\\'; // Overwrite the current spot so that we will know that we have been here before (for the rest of the current iteration).\\n           \\n        boolean up = helper(board, x-1, y, word, end+1);       // Options of traversing the matrix.\\n        boolean down = helper(board, x+1, y, word, end+1);\\n        boolean left = helper(board, x, y-1, word, end+1);\\n        boolean right = helper(board, x, y+1, word, end+1);\\n        \\n        if(up || down || left || right) // If the options are valid, return true.\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n             board[x][y] = temp; // Else overwrite the current spot with the copy of the original value for the next iteration.\\n             return false;\\n\\t\\t}\\n\\t\\t\\t \\n          // Runtime: 5 ms, faster than 83.51% of Java online submissions for Word Search.\\n\\t\\t   // Memory Usage: 41.3 MB, less than 73.34% of Java online submissions for Word Search.\\n }",
                "codeTag": "Unknown"
            },
            {
                "id": 596775,
                "title": "short-c-code-directions-dfs-backtracking-explanations",
                "content": "\\n   my solution uses dfs to traverse the board with change in directions as dx, dy\\n   func--> it checks if a word matches or not recursively\\n   \\n   \\n   ```\\n   int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    bool func(int i,int j,string word,int in,vector<vector<char>>& board)\\n    {                                 \\n        int n=board.size();\\n        int m=board[0].size();\\n        if(in==word.size()) return true; \\n        if(i>=n||i<0||j>=m||j<0)  return false;   \\n        if(word[in]==board[i][j] )\\n        {\\n            board[i][j]=\\'@\\';               //  this prevents reusage of characters\\n            for(int l=0;l<4;l++)\\n                if(func(i+dx[l],j+dy[l],word,in+1,board)) return true;\\n            board[i][j]=word[in];      // again changing it to its previous state\\n        }\\n        return false;        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==word[0])              \\n                    if(func(i,j,word,0,board)) return true;\\n        return false;\\n    }\\n\\t\\n\\tNOTE- if any part is unclear feel free to leave a comment ;)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "\\n   my solution uses dfs to traverse the board with change in directions as dx, dy\\n   func--> it checks if a word matches or not recursively\\n   \\n   \\n   ```\\n   int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    bool func(int i,int j,string word,int in,vector<vector<char>>& board)\\n    {                                 \\n        int n=board.size();\\n        int m=board[0].size();\\n        if(in==word.size()) return true; \\n        if(i>=n||i<0||j>=m||j<0)  return false;   \\n        if(word[in]==board[i][j] )\\n        {\\n            board[i][j]=\\'@\\';               //  this prevents reusage of characters\\n            for(int l=0;l<4;l++)\\n                if(func(i+dx[l],j+dy[l],word,in+1,board)) return true;\\n            board[i][j]=word[in];      // again changing it to its previous state\\n        }\\n        return false;        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==word[0])              \\n                    if(func(i,j,word,0,board)) return true;\\n        return false;\\n    }\\n\\t\\n\\tNOTE- if any part is unclear feel free to leave a comment ;)",
                "codeTag": "Unknown"
            },
            {
                "id": 568692,
                "title": "100-swift",
                "content": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let m = board.count\\n        let n = board[0].count\\n        let array = Array(word)\\n        var visited = Array(repeating: Array(repeating: false, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                if board[i][j] == array[0] {\\n                    if dfs(m, n, i, j, &visited, 0, array, board) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func dfs(_ m: Int, _ n: Int, _ x: Int, _ y: Int, _ visited: inout [[Bool]], _ index: Int, _ array: [Character], _ board: [[Character]]) -> Bool {\\n        guard x < m, y < n, x >= 0, y >= 0 else { return false }\\n        \\n        if visited[x][y] {\\n            return false\\n        }\\n        \\n        if board[x][y] != array[index] {\\n            return false\\n        } \\n        \\n        if index == array.count - 1 {\\n            return true\\n        }\\n        \\n        visited[x][y] = true \\n        if dfs(m, n, x + 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x - 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y + 1, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y - 1, &visited, index + 1, array, board) {\\n            return true\\n        }\\n        visited[x][y] = false\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let m = board.count\\n        let n = board[0].count\\n        let array = Array(word)\\n        var visited = Array(repeating: Array(repeating: false, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                if board[i][j] == array[0] {\\n                    if dfs(m, n, i, j, &visited, 0, array, board) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func dfs(_ m: Int, _ n: Int, _ x: Int, _ y: Int, _ visited: inout [[Bool]], _ index: Int, _ array: [Character], _ board: [[Character]]) -> Bool {\\n        guard x < m, y < n, x >= 0, y >= 0 else { return false }\\n        \\n        if visited[x][y] {\\n            return false\\n        }\\n        \\n        if board[x][y] != array[index] {\\n            return false\\n        } \\n        \\n        if index == array.count - 1 {\\n            return true\\n        }\\n        \\n        visited[x][y] = true \\n        if dfs(m, n, x + 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x - 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y + 1, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y - 1, &visited, index + 1, array, board) {\\n            return true\\n        }\\n        visited[x][y] = false\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452463,
                "title": "python-dfs-well-documented-with-dfs-template",
                "content": "\"\"\"\\nclass Solution:\\n    \\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n         if len(board) == 0 or len(board[0]) == 0:\\n            return False\\n         self.Nrows, self.Ncols = len(board), len(board[0])\\n        \\n         for r in range(self.Nrows):\\n            for c in range(self.Ncols):\\n                if board[r][c]==word[0] and self.dfs(board, r, c, 0 , word):\\n                    return True\\n         return False\\n    \\n    def dfs(self,board,i,j,idx,word):\\n        #basecase (if we checked all letters of the word already)\\n        if idx==len(word):\\n            return True \\n        ## if we are outside the board or we do not have a matching letter\\n        if i< 0 or i > len(board)-1 or j < 0 or j > len(board[0])-1 or board[i][j]!=word[idx]:\\n            return False\\n        #### Now this is the template for DFS \\n        # 1) Make a choice and mark it\\n        \\n        original=board[i][j]  ## first store board[i][j] so you can restore it if dfs does not work\\n        board[i][j]=\"\" ## make this unavailable/non-matching\\n        ## 2) Explore Depth-wise\\n        if self.dfs(board,i-1,j,idx+1,word) or self.dfs(board,i+1,j,idx+1,word) or self.dfs(board,i,j-1,idx+1,word) or self.dfs(board,i,j+1,idx+1,word):\\n            return True \\n        else:\\n        ### 3) Unchoose\\n            board[i][j]=original\\n            \\n        \\n        \\n        \\n        \\n        \\n\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nclass Solution:\\n    \\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n         if len(board) == 0 or len(board[0]) == 0:\\n            return False\\n         self.Nrows, self.Ncols = len(board), len(board[0])\\n        \\n         for r in range(self.Nrows):\\n            for c in range(self.Ncols):\\n                if board[r][c]==word[0] and self.dfs(board, r, c, 0 , word):\\n                    return True\\n         return False\\n    \\n    def dfs(self,board,i,j,idx,word):\\n        #basecase (if we checked all letters of the word already)\\n        if idx==len(word):\\n            return True \\n        ## if we are outside the board or we do not have a matching letter\\n        if i< 0 or i > len(board)-1 or j < 0 or j > len(board[0])-1 or board[i][j]!=word[idx]:\\n            return False\\n        #### Now this is the template for DFS \\n        # 1) Make a choice and mark it\\n        \\n        original=board[i][j]  ## first store board[i][j] so you can restore it if dfs does not work\\n        board[i][j]=\"\" ## make this unavailable/non-matching\\n        ## 2) Explore Depth-wise\\n        if self.dfs(board,i-1,j,idx+1,word) or self.dfs(board,i+1,j,idx+1,word) or self.dfs(board,i,j-1,idx+1,word) or self.dfs(board,i,j+1,idx+1,word):\\n            return True \\n        else:\\n        ### 3) Unchoose\\n            board[i][j]=original\\n            \\n        \\n        \\n        \\n        \\n        \\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 429314,
                "title": "faster-96-low-memory-100-backtracking-python",
                "content": "Runtime: 260 ms, faster than 96.31% of Python3 online submissions for Word Search.\\nMemory Usage: 13.8 MB, less than 100.00% of Python3 online submissions for Word Search.\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        nrows = len(board)\\n        ncols = len(board[0])\\n        \\n        def backtrack(i, j, idx):\\n            char = board[i][j]\\n            if char != word[idx]:\\n                return False\\n            elif idx == len(word)-1:\\n                return True\\n            \\n            board[i][j] = \\'\\'\\n            \\n            if i > 0 and backtrack(i-1, j, idx+1):\\n                return True\\n            if j > 0 and backtrack(i, j-1, idx+1):\\n                return True\\n            if i < nrows-1 and backtrack(i+1, j, idx+1):\\n                return True\\n            if j < ncols-1 and backtrack(i, j+1, idx+1):\\n                return True            \\n            board[i][j] = char\\n            return False\\n                    \\n        for i in range(nrows):\\n            for j in range(ncols):\\n                if backtrack(i, j, 0):\\n                    return True\\n            \\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 260 ms, faster than 96.31% of Python3 online submissions for Word Search.\\nMemory Usage: 13.8 MB, less than 100.00% of Python3 online submissions for Word Search.\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        nrows = len(board)\\n        ncols = len(board[0])\\n        \\n        def backtrack(i, j, idx):\\n            char = board[i][j]\\n            if char != word[idx]:\\n                return False\\n            elif idx == len(word)-1:\\n                return True\\n            \\n            board[i][j] = \\'\\'\\n            \\n            if i > 0 and backtrack(i-1, j, idx+1):\\n                return True\\n            if j > 0 and backtrack(i, j-1, idx+1):\\n                return True\\n            if i < nrows-1 and backtrack(i+1, j, idx+1):\\n                return True\\n            if j < ncols-1 and backtrack(i, j+1, idx+1):\\n                return True            \\n            board[i][j] = char\\n            return False\\n                    \\n        for i in range(nrows):\\n            for j in range(ncols):\\n                if backtrack(i, j, 0):\\n                    return True\\n            \\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 325978,
                "title": "clean-javascript-dfs-backtracking-solution",
                "content": "JavaScript version of the solution: https://leetcode.com/problems/word-search/discuss/27835/C%2B%2B-dfs-solution.\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\n\\nconst dfs = (board, i, j, remain) => {\\n    if (remain.length === 0) return true;\\n    if (i<0 || i>=board.length || j<0 || j>=board[0].length) return false;\\n    if (board[i][j] !== remain[0]) return false;\\n    \\n    let char = board[i][j];\\n    board[i][j] = \\'-\\';\\n    let result = (dfs(board,i+1,j,remain.substring(1))||dfs(board,i-1,j,remain.substring(1))\\n        || dfs(board,i,j+1,remain.substring(1)) || dfs(board,i,j-1,remain.substring(1)));\\n    board[i][j]=char;\\n    return result;\\n}\\n\\nvar exist = function(board, word) {\\n    if (board.length===0 || word.length===0) return false;\\n    for (let i=0; i<board.length; i++){\\n        for (let j=0; j<board[0].length; j++){\\n            if (dfs(board,i,j,word)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\n\\nconst dfs = (board, i, j, remain) => {\\n    if (remain.length === 0) return true;\\n    if (i<0 || i>=board.length || j<0 || j>=board[0].length) return false;\\n    if (board[i][j] !== remain[0]) return false;\\n    \\n    let char = board[i][j];\\n    board[i][j] = \\'-\\';\\n    let result = (dfs(board,i+1,j,remain.substring(1))||dfs(board,i-1,j,remain.substring(1))\\n        || dfs(board,i,j+1,remain.substring(1)) || dfs(board,i,j-1,remain.substring(1)));\\n    board[i][j]=char;\\n    return result;\\n}\\n\\nvar exist = function(board, word) {\\n    if (board.length===0 || word.length===0) return false;\\n    for (let i=0; i<board.length; i++){\\n        for (let j=0; j<board[0].length; j++){\\n            if (dfs(board,i,j,word)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 283374,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    int n;\\n    int m;\\n    public bool Exist(char[][] board, string word) {\\n        n = board.Length;\\n        if (n == 0) return false;\\n        m = board[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var result = false;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                result = DFS(board, isVisited, i, j, word, 0);\\n                if (result) return true;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool DFS(char[][] board, bool[,] isVisited, int x, int y, string word, int wordIndex) {\\n        if (wordIndex == word.Length) {\\n            return true;\\n        }\\n        \\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return false;\\n        }\\n\\n        if (word[wordIndex] != board[x][y]) {\\n            return false;\\n        }\\n\\n        if (isVisited[x, y]) return false;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var oneResult = DFS(board, isVisited, x + direction.Item1, y + direction.Item2, word, wordIndex + 1);\\n            if (oneResult) return true;\\n        }\\n\\n        isVisited[x, y] = false;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int n;\\n    int m;\\n    public bool Exist(char[][] board, string word) {\\n        n = board.Length;\\n        if (n == 0) return false;\\n        m = board[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var result = false;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                result = DFS(board, isVisited, i, j, word, 0);\\n                if (result) return true;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool DFS(char[][] board, bool[,] isVisited, int x, int y, string word, int wordIndex) {\\n        if (wordIndex == word.Length) {\\n            return true;\\n        }\\n        \\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return false;\\n        }\\n\\n        if (word[wordIndex] != board[x][y]) {\\n            return false;\\n        }\\n\\n        if (isVisited[x, y]) return false;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var oneResult = DFS(board, isVisited, x + direction.Item1, y + direction.Item2, word, wordIndex + 1);\\n            if (oneResult) return true;\\n        }\\n\\n        isVisited[x, y] = false;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173887,
                "title": "swift-implementation",
                "content": "```\\nfunc exist(_ board: [[Character]], _ word: String) -> Bool {\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: 0)]\\n        \\n        for row in 0..<board.count {\\n            for col in 0..<board[0].count {\\n                if search(board, word, row, col, 0) { \\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func search(_ board: [[Character]], _ word: String, _ row: Int, _ col: Int, _ index: Int) -> Bool {\\n        if index >= word.count { return true }\\n        \\n        if row < 0  || row >= board.count || col < 0 || col >= board[0].count {\\n            return false\\n        }\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: index)]\\n        if board[row][col] == \"-\" || board[row][col] != char { \\n            return false \\n        }\\n        \\n        var board = board\\n        board[row][col] = \"-\"\\n        \\n        let ans = search(board, word, row+1, col, index+1) ||\\n                  search(board, word, row-1, col, index+1) ||\\n                  search(board, word, row, col+1, index+1) ||\\n                  search(board, word, row, col-1, index+1) \\n        \\n        return ans\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc exist(_ board: [[Character]], _ word: String) -> Bool {\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: 0)]\\n        \\n        for row in 0..<board.count {\\n            for col in 0..<board[0].count {\\n                if search(board, word, row, col, 0) { \\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func search(_ board: [[Character]], _ word: String, _ row: Int, _ col: Int, _ index: Int) -> Bool {\\n        if index >= word.count { return true }\\n        \\n        if row < 0  || row >= board.count || col < 0 || col >= board[0].count {\\n            return false\\n        }\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: index)]\\n        if board[row][col] == \"-\" || board[row][col] != char { \\n            return false \\n        }\\n        \\n        var board = board\\n        board[row][col] = \"-\"\\n        \\n        let ans = search(board, word, row+1, col, index+1) ||\\n                  search(board, word, row-1, col, index+1) ||\\n                  search(board, word, row, col+1, index+1) ||\\n                  search(board, word, row, col-1, index+1) \\n        \\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27796,
                "title": "share-my-java-code-straightforward-dfs",
                "content": "    public class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return false;\\n            }\\n            boolean[][] isBeingVisited = new boolean[board.length][board[0].length];\\n            for (int i = 0; i < board.length; ++i) {\\n                for (int j = 0; j < board[0].length; ++j) {\\n                    if (board[i][j] == word.charAt(0) &&\\n                        dfs(board, word, isBeingVisited, 0, i, j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private boolean dfs(char[][] board, String word, boolean[][] isBeingVisited, int index, int row, int col) {\\n            if (index == word.length()) {  // reached the end of the word\\n                return true;\\n            }\\n            if (row < 0 || row >= board.length || col < 0 || col >= board[0].length\\n                || isBeingVisited[row][col] || word.charAt(index) != board[row][col]) {\\n                return false;    \\n            }\\n            isBeingVisited[row][col] = true;\\n            if (dfs(board, word, isBeingVisited, index + 1, row - 1, col)) {\\n                return true;\\n            }\\n            if (dfs(board, word, isBeingVisited, index + 1, row + 1, col)) {\\n                return true;\\n            }\\n            if (dfs(board, word, isBeingVisited, index + 1, row, col - 1)) {\\n                return true;\\n            }\\n            if (dfs(board, word, isBeingVisited, index + 1, row, col + 1)) {\\n                return true;\\n            }\\n            isBeingVisited[row][col] = false;  // umark current point; it might be used in other routes\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 27853,
                "title": "c-accepted-simpe-depth-first-search-with-comments",
                "content": "    private int rows;\\n    private int columns;\\n    bool[,] visited;\\n    \\n    public bool Exist(char[,] board, string word) \\n    {\\n        // init\\n        rows = board.GetLength(0);\\n        columns = board.GetLength(1);\\n        visited = new bool[rows,columns];\\n        \\n        // search one by one\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (Search(board, word, 0, i, j))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public bool Search(char[,] board, string word, int wordIndex, int i, int j)\\n    {\\n        // word search is already finished\\n        if (wordIndex == word.Length) return true;\\n        \\n        if (i < 0 || i >= rows || j < 0 || j >= columns // illegal boundaries\\n           || visited[i, j] == true                     // already visited\\n           || board[i, j] != word[wordIndex])           // char does not match\\n        {\\n            return false;\\n        }\\n        \\n        // mark current position as visited\\n        visited[i, j] = true; \\n        \\n        // search four directions: right, down, left, up\\n        if (Search(board, word, wordIndex + 1, i, j + 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i - 1, j)) return true;\\n        if (Search(board, word, wordIndex + 1, i, j - 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i + 1, j)) return true;\\n        \\n        // not found, restore current position to unvisited\\n        visited[i, j] = false; \\n        return false;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "    private int rows;\\n    private int columns;\\n    bool[,] visited;\\n    \\n    public bool Exist(char[,] board, string word) \\n    {\\n        // init\\n        rows = board.GetLength(0);\\n        columns = board.GetLength(1);\\n        visited = new bool[rows,columns];\\n        \\n        // search one by one\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (Search(board, word, 0, i, j))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public bool Search(char[,] board, string word, int wordIndex, int i, int j)\\n    {\\n        // word search is already finished\\n        if (wordIndex == word.Length) return true;\\n        \\n        if (i < 0 || i >= rows || j < 0 || j >= columns // illegal boundaries\\n           || visited[i, j] == true                     // already visited\\n           || board[i, j] != word[wordIndex])           // char does not match\\n        {\\n            return false;\\n        }\\n        \\n        // mark current position as visited\\n        visited[i, j] = true; \\n        \\n        // search four directions: right, down, left, up\\n        if (Search(board, word, wordIndex + 1, i, j + 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i - 1, j)) return true;\\n        if (Search(board, word, wordIndex + 1, i, j - 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i + 1, j)) return true;\\n        \\n        // not found, restore current position to unvisited\\n        visited[i, j] = false; \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27872,
                "title": "accepted-16ms-c-solution-use-backtracking-easy-understand",
                "content": "    class Solution {\\n    public:\\n        bool exist(std::vector<std::vector<char> > &board, std::string word) {\\n            rows = static_cast<int>(board.size()), cols = static_cast<int>(board[0].size());\\n            for (int row = 0; row != rows; ++row)\\n                for (int col = 0; col != cols; ++col)\\n                    if (exist(board, word, row, col, 0))\\n                        return true;\\n            return false;\\n        }\\n    private:\\n        int rows, cols;\\n        bool exist(std::vector<std::vector<char> > &board, std::string &word, int row, int col, int pos) {\\n            if (board[row][col] != word[pos] || board[row][col] == ' ')\\n                return false;\\n            else if (pos == word.size() - 1)\\n                return true;\\n            char c = board[row][col];\\n            board[row][col] = ' ';\\n            if (row > 0 && exist(board, word, row - 1, col, pos + 1) ||\\n                row < rows - 1 && exist(board, word, row + 1, col, pos + 1) ||\\n                col > 0 && exist(board, word, row, col - 1, pos + 1) ||\\n                col < cols - 1 && exist(board, word, row, col + 1, pos + 1)) {\\n                board[row][col] = c;\\n                return true;\\n            }\\n            board[row][col] = c;\\n            return false;\\n        }\\n    };\\n\\n\\nUpdated **Jun 28:**\\n\\n    class Solution {\\n    public:\\n        bool exist(std::vector<std::vector<char> > &board, std::string word) {\\n            rows = static_cast<int>(board.size()), cols = static_cast<int>(board[0].size());\\n            for (int row = 0; row != rows; ++row)\\n                for (int col = 0; col != cols; ++col)\\n                    if (exist(board, word, row, col, 0))\\n                        return true;\\n            return false;\\n        }\\n    private:\\n        int rows, cols;\\n        bool exist(std::vector<std::vector<char> > &board, std::string &word, int row, int col, int pos) {\\n            if (board[row][col] != word[pos] || board[row][col] == ' ')\\n                return false;\\n            else if (pos == word.size() - 1)\\n                return true;\\n            char c = board[row][col];\\n            board[row][col] = ' ';\\n            bool next_exist = row > 0 && exist(board, word, row - 1, col, pos + 1) ||\\n                row < rows - 1 && exist(board, word, row + 1, col, pos + 1) ||\\n                col > 0 && exist(board, word, row, col - 1, pos + 1) ||\\n                col < cols - 1 && exist(board, word, row, col + 1, pos + 1);\\n            board[row][col] = c;\\n            return next_exist;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        bool exist(std::vector<std::vector<char> > &board, std::string word) {\\n            rows = static_cast<int>(board.size()), cols = static_cast<int>(board[0].size());\\n            for (int row = 0; row != rows; ++row)\\n                for (int col = 0; col != cols; ++col)\\n                    if (exist(board, word, row, col, 0))\\n                        return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 27692,
                "title": "my-java-accepted-solution-using-iterative-method-no-recursive-call",
                "content": "I saw a lot dfs recursive version. I happen to do it in a iterative way. Share my solution with you. \\n**Notice:** Need to trace back and reset visited from true->false once a wrong end encountered.\\n      \\n    public class Solution {\\n            public boolean exist(char[][] board, String word) {\\n                for(int i = 0;i < board.length;i++){\\n                    for(int j = 0;j < board[0].length;j++){\\n                        if(board[i][j] == word.charAt(0)){\\n                            // dfs\\n                            Stack<Integer> x_pos = new Stack<Integer>();\\n                            Stack<Integer> y_pos = new Stack<Integer>();\\n                            Stack<Integer> word_index = new Stack<Integer>();\\n                            Stack<Integer> x_track = new Stack<Integer>();\\n                            Stack<Integer> y_track = new Stack<Integer>();\\n                            int[][] subpath_num = new int[board.length][board[0].length];\\n                            boolean[][] visited = new boolean[board.length][board[0].length];\\n                            for(int q = 0;q < board.length;q++)\\n                                for(int p = 0;p < board[0].length;p++)\\n                                    visited[q][p] = false;\\n                            x_pos.add(i);y_pos.add(j);\\n                            word_index.add(0);\\n                            while(!x_pos.isEmpty()){\\n                                int x = x_pos.pop();\\n                                int y = y_pos.pop();\\n                                int index = word_index.pop()+1;\\n                                if(index == word.length()){return true;}\\n                                int count_subpath = 0;\\n                                x_track.add(x);y_track.add(y);\\n                                visited[x][y] = true;\\n                                if(x-1 >= 0){\\n                                    if(board[x-1][y] == word.charAt(index) && !visited[x-1][y]){\\n                                        x_pos.add(x-1);y_pos.add(y);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                if(x+1 < board.length){\\n                                    if(board[x+1][y] == word.charAt(index) && !visited[x+1][y]){\\n                                        x_pos.add(x+1);y_pos.add(y);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                if(y-1 >= 0){\\n                                    if(board[x][y-1] == word.charAt(index) && !visited[x][y-1]){\\n                                        x_pos.add(x);y_pos.add(y-1);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                if(y+1 < board[0].length){\\n                                    if(board[x][y+1] == word.charAt(index) && !visited[x][y+1]){\\n                                        x_pos.add(x);y_pos.add(y+1);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                subpath_num[x][y] = count_subpath;\\n                                // reset the visited mark\\n                                if(subpath_num[x][y] == 0){\\n                                    int cur_x = x_track.pop();\\n                                    int cur_y = y_track.pop();\\n                                    while(subpath_num[cur_x][cur_y] <= 1){\\n                                        visited[cur_x][cur_y] = false;\\n                                        if(x_track.isEmpty()){break;}\\n                                        cur_x = x_track.pop();\\n                                        cur_y = y_track.pop();\\n                                    }\\n                                    subpath_num[cur_x][cur_y]--;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public boolean exist(char[][] board, String word) {\\n                for(int i = 0;i < board.length;i++){\\n                    for(int j = 0;j < board[0].length;j++){\\n                        if(board[i][j] == word.charAt(0)){\\n                            // dfs\\n                            Stack<Integer> x_pos = new Stack<Integer>();\\n                            Stack<Integer> y_pos = new Stack<Integer>();\\n                            Stack<Integer> word_index = new Stack<Integer>();\\n                            Stack<Integer> x_track = new Stack<Integer>();\\n                            Stack<Integer> y_track = new Stack<Integer>();\\n                            int[][] subpath_num = new int[board.length][board[0].length];\\n                            boolean[][] visited = new boolean[board.length][board[0].length];\\n                            for(int q = 0;q < board.length;q++)\\n                                for(int p = 0;p < board[0].length;p++)\\n                                    visited[q][p] = false;\\n                            x_pos.add(i);y_pos.add(j);\\n                            word_index.add(0);\\n                            while(!x_pos.isEmpty()){\\n                                int x = x_pos.pop();\\n                                int y = y_pos.pop();\\n                                int index = word_index.pop()+1;\\n                                if(index == word.length()){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 3696604,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board, vector<vector<bool>>& vis, string &word, int i, int j, int start) {\\n        int m = board.size(), n = board[0].size();\\n        if(start == word.size()) return true;\\n        if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || board[i][j] != word[start]) return false;\\n        \\n        vis[i][j] = true;\\n        bool a = dfs(board, vis, word, i+1, j, start+1) ||\\n                 dfs(board, vis, word, i-1, j, start+1) ||\\n                 dfs(board, vis, word, i, j+1, start+1) ||\\n                 dfs(board, vis, word, i, j-1, start+1);\\n        \\n        vis[i][j] = false; // Reset the visited state for backtracking\\n        return a;\\n    }\\n\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(dfs(board, vis, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board, vector<vector<bool>>& vis, string &word, int i, int j, int start) {\\n        int m = board.size(), n = board[0].size();\\n        if(start == word.size()) return true;\\n        if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || board[i][j] != word[start]) return false;\\n        \\n        vis[i][j] = true;\\n        bool a = dfs(board, vis, word, i+1, j, start+1) ||\\n                 dfs(board, vis, word, i-1, j, start+1) ||\\n                 dfs(board, vis, word, i, j+1, start+1) ||\\n                 dfs(board, vis, word, i, j-1, start+1);\\n        \\n        vis[i][j] = false; // Reset the visited state for backtracking\\n        return a;\\n    }\\n\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(dfs(board, vis, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475730,
                "title": "java-solution-for-word-search-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to determine if a given word exists in a given 2D board of characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given solution is Depth First Search (DFS) algorithm. The solution iterates over each cell of the input matrix and calls the dfs function to check if the given word can be formed starting from that cell. The dfs function searches for the next character of the word in the neighbouring cells (up, down, left, right) and marks the current cell as visited by changing the value to \\'#\\' to avoid revisiting the same cell. If the entire word is found in the matrix, the function returns true; otherwise, it backtracks by restoring the value of the current cell and returns false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(mn4^k), where m and n are the number of rows and columns in the input matrix, and k is the length of the given word. This is because the solution iterates over each cell of the matrix, and for each cell, it makes at most four recursive calls, one for each neighbouring cell. The worst-case time complexity occurs when the word is not found, and the DFS algorithm traverses all possible paths, which can be up to 4^k paths.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k), where k is the length of the given word. This is because the solution uses the call stack to store the state of the recursive calls, and the maximum depth of the call stack is k.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        boolean result = false;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(dfs(board,word,i,j,0))\\n                {\\n                    result = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean dfs(char[][] board, String word, int i, int j, int k)\\n    {\\n        int m = board.length;\\n        int n = board[0].length;\\n        if(i<0 || j<0 || i>=m || j>=n)\\n        {\\n            return false;\\n        }\\n        if(board[i][j] == word.charAt(k))\\n        {\\n            char temp = board[i][j];\\n            board[i][j]=\\'#\\';\\n            if(k==word.length()-1)\\n            {\\n                return true;\\n            }\\n            else if(dfs(board, word, i-1, j, k+1) ||dfs(board, word, i+1, j, k+1) ||dfs(board, word, i, j-1, k+1) ||dfs(board, word, i, j+1, k+1))\\n            {\\n                return true;\\n            }\\n            board[i][j]=temp;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        boolean result = false;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(dfs(board,word,i,j,0))\\n                {\\n                    result = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean dfs(char[][] board, String word, int i, int j, int k)\\n    {\\n        int m = board.length;\\n        int n = board[0].length;\\n        if(i<0 || j<0 || i>=m || j>=n)\\n        {\\n            return false;\\n        }\\n        if(board[i][j] == word.charAt(k))\\n        {\\n            char temp = board[i][j];\\n            board[i][j]=\\'#\\';\\n            if(k==word.length()-1)\\n            {\\n                return true;\\n            }\\n            else if(dfs(board, word, i-1, j, k+1) ||dfs(board, word, i+1, j, k+1) ||dfs(board, word, i, j-1, k+1) ||dfs(board, word, i, j+1, k+1))\\n            {\\n                return true;\\n            }\\n            board[i][j]=temp;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100391,
                "title": "idea-of-backtracking-explained-c-detailed",
                "content": "**problem link \\uD83D\\uDC47\\u2714**\\n\\n[https://leetcode.com/problems/word-search/description/](https://leetcode.com/problems/word-search/description/)\\n\\n- We are given a *(m x n)* grid of characters , like one below.\\n   []()\\n![BACKTRACKING_0.jpeg](https://assets.leetcode.com/users/images/1527cb39-66ae-4e74-9804-172f43694185_1674711594.5905821.jpeg)\\n    \\n- We have been given a string *word=\\u201CABCCED\"* which we need to find if it can be formed using adjacent cells , horizontally or vertically grid.\\n- We can think of this of finding a ****path**** of this word if its exists in the gird.\\n- For example if the **word = \\u201C*ABCCED\\u201D,*  then the path would look something like this :\\n\\n![BACKTRACKING_1.PNG](https://assets.leetcode.com/users/images/11cfae2a-81c0-457e-b1b0-410fdd56124c_1674711681.5046153.png)\\n\\n\\n- Another example would be the word = ***\\u201CSFDEESE\\u201D**.*\\n![BACKTRACKING_2.PNG](https://assets.leetcode.com/users/images/dedd97ca-7f7b-4142-b7b3-5aa5f402aded_1674711707.833588.png)\\n\\n\\n## How we build solution using backtracking\\n\\n- Let\\u2019s look at the first testcase. We need to search for the word \\u201C*********ABCCED\\u201D.*********\\n![BACKTRACKING_3.PNG](https://assets.leetcode.com/users/images/6a9331e9-1ca0-4175-8ce8-cfff2e7f5f59_1674711730.6457713.png)\\n\\n- So my first letter is \\u2018A\\u2019 in the word \\u201CABCCED\\u201D.\\n- Let\\u2019s traverse the grid from (0,0).\\n\\n![BACKTRACKING_4.PNG](https://assets.leetcode.com/users/images/226d169d-7ea2-4fbf-b671-f97b9eb32536_1674711752.4014783.png)\\n\\n### **The basic strategy would be to traverse all paths and try seeing if those paths will build up the word which we are trying to find in the grid.**\\n\\n- Also, let\\u2019s make a sequence bag, which will show if the sequence or path we follow is building up our target word. Initially it would be empty.\\n- So we are currently at ****************(0,0)**************** and the character at (0,0) = ******\\u2018A\\u2019,****** which matches with the first letter of our target word.\\n- So we can say, that **since we have found a match, it *******may be******* possible that a path might follow from that particular cell to our target word.** So, from (0,0) a path might exists for the word = \\u201C***ABCCED\\u201D.***\\n\\n![BACKTRACKING_5.PNG](https://assets.leetcode.com/users/images/74873225-895f-48de-8f11-75ef23f920a7_1674711806.0440943.png)\\n\\n\\n- Let\\u2019s look at some possible paths from (0,0).\\n\\n![BACKTRACKING_6.PNG](https://assets.leetcode.com/users/images/7cc8a989-501d-47cb-90d5-9ac21d848554_1674711820.0786366.png)\\n\\n\\n- But **************from (0,0)************** (or \\u2018A\\u2019) you can either go right or down **************************************as the first move of ANY path.**************************************\\n- You cannot go diagonal or up from (0,0).\\n\\n![BACKTRACKING_7.PNG](https://assets.leetcode.com/users/images/b78c62e6-e1b0-47c3-9943-05df82e7ea79_1674711847.8853803.png)\\n\\n\\n- So there are two possible paths we may follow : \\u201CAB..\\u201D or \\u201CAS\\u2026\\u201D from (0,0) so as to build our target word.\\n- But in our target word = ********\\u201CABCCED\\u201D,******** the **************second word is \\u2018B\\u2019. Therefore , we have a guarantee that following the path \\u201CAS..\\u201D will NEVER  build our target word.  Therefore, we can refuse to traverse that path.**************\\n\\n ****************************\\n\\n![BACKTRACKING_8.PNG](https://assets.leetcode.com/users/images/a227ec2f-1093-4937-b107-60d35a843b6f_1674711866.3551629.png)\\n\\n\\n- Since \\u2018AB..\\u2019 path has a \\u2018B\\u2019 as a second character which matches with the second character of our target word, we can safely traverse this path, hoping it can lead to our target word.\\n- Now we are currently at the cell **************(0,1) ie \\u2018B\\u2019.************** From (0,1) we can go in 3 directions : left , right , bottom.\\n\\n![BACKTRACKING_9.PNG](https://assets.leetcode.com/users/images/b797d598-acda-4464-aed1-6e4d6b351c10_1674711890.9708087.png)\\n\\n\\n- Now we can either have the sequence as ****\\u201CABA..\\u201D if we go left, \\u201CABC..\\u201D if we go right, \\u201CABF..\\u201D if we go down.****\\n- But our third character is ************\\u2018C\\u2019,************ that\\u2019s why we don\\u2019t need to traverse the paths \\u201CABA..\\u201D or \\u201CABF\\u2026\\u201D since they won\\u2019t build our word. \\u201CABC..\\u201D path can possibly build our target word.\\n- And this is how we will keep on going, until we find our word\\u2026(see below)\\n\\n![BACKTRACKING_10.PNG](https://assets.leetcode.com/users/images/0e46d27f-84e5-4f47-9aaf-1d19c8fa4b31_1674711913.5524411.png)\\n\\n![BACKTRACKING_11.PNG](https://assets.leetcode.com/users/images/8e1f0581-08b7-4b09-b3de-6b1d7d90b9e3_1674711926.5692747.png)\\n\\n\\n![BACKTRACKING_12.PNG](https://assets.leetcode.com/users/images/433c6d42-cbbd-49b7-9745-8ec45f177cdc_1674711942.4101472.png)\\n\\n![BACKTRACKING_13.PNG](https://assets.leetcode.com/users/images/2692eec8-f8a0-427b-b50f-f72ed0a0fda1_1674711955.8107622.png)\\n\\n\\n- Finally we have found that a possible path/solution exists in the grid \\uD83D\\uDCAF\\uD83D\\uDCAF.\\n\\n## **What if multiple true paths exist?**\\n\\n- Let\\u2019s tweak the grid up a bit and go back to an intermediate step.\\n\\n![BACKTRACKING_14.PNG](https://assets.leetcode.com/users/images/2e4e6ffa-edd0-46c3-95c6-4dfe6112f554_1674711973.1489658.png)\\n\\n\\n- Here the paths \\u201C********************************************ABCCC..\\u201D by going UP,  \\u201CABCCF..\\u201D by going left******************************************** will be rejected since we need the character \\u2018E\\u2019 up next.\\n- Here, we have two paths \\u201C******ABCCE..\\u201D by going right, \\u201CABCCE..\\u201D also by going down.******\\n- Let\\u2019s say we traverse \\u201C**************************************************ABCCE..\\u201D by going RIGHT.**************************************************\\n\\n![BACKTRACKING_15.PNG](https://assets.leetcode.com/users/images/ee0af524-1831-4adb-b3e7-b14fb608b313_1674712001.3424916.png)\\n\\n\\n- From ************************************************\\u2018E\\u2019 , we will get \\u201CABCCEE\\u201D if we go UP , \\u201CABCCEEF\\u201D if we go down, \\u201CABCCEC\\u201D if we go left, which DON\\u2019T build the target word \\u201CABCCED\\u201D.************************************************\\n- So what we should do is , that we should go back a previous step, till where our solution was ************************going correct. And try some other direction to build the solution. So,************************\\n\\n![BACKTRACKING_16.PNG](https://assets.leetcode.com/users/images/adc3a9d8-3d7e-4563-9a43-644a34735aca_1674712019.407731.png)\\n\\n- Our traversal was correct up to ******\\u201CABCC..\\u201D , and since going RIGHT to \\u2018E\\u2019 did not build our solution, we will traverse \\u201CABCCE..\\u201D by going DOWN.**\\n- This path will eventually find that the target word \\u201C************ABCCED\\u201D************ exists in the grid.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rows;\\n  int cols;\\n  int dx[4] = {1,-1,0,0};\\n  int dy[4] = {0,0,1,-1};\\n\\n  bool backtrack(vector<vector<char>>&board , int i , int j , string word, int index)\\n  {\\n    if(index == word.size())\\n        return true;\\n    \\n    if(i >= rows or j >= cols or i < 0 or j < 0 or board[i][j] != word[index])\\n        return false;\\n\\n    char t = board[i][j];\\n    board[i][j] = \\'*\\';\\n    \\n    bool x =\\n    backtrack(board,i+dx[0],j+dy[0],word,index+1) or\\n    backtrack(board,i+dx[1],j+dy[1],word,index+1) or\\n    backtrack(board,i+dx[2],j+dy[2],word,index+1) or\\n    backtrack(board,i+dx[3],j+dy[3],word,index+1);\\n\\n    board[i][j] = t;\\n\\n    return x;\\n  }\\n\\n  bool exist(vector<vector<char>>& board, string word)\\n  {\\n    rows = board.size();\\n    cols = board[0].size();\\n\\n    for(int i=0;i<rows;i++)\\n    {\\n        for(int j=0;j<cols;j++)\\n        {\\n            if(backtrack(board,i,j,word,0))\\n                return true; \\n        }\\n    }\\n    return false;\\n  }\\n \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rows;\\n  int cols;\\n  int dx[4] = {1,-1,0,0};\\n  int dy[4] = {0,0,1,-1};\\n\\n  bool backtrack(vector<vector<char>>&board , int i , int j , string word, int index)\\n  {\\n    if(index == word.size())\\n        return true;\\n    \\n    if(i >= rows or j >= cols or i < 0 or j < 0 or board[i][j] != word[index])\\n        return false;\\n\\n    char t = board[i][j];\\n    board[i][j] = \\'*\\';\\n    \\n    bool x =\\n    backtrack(board,i+dx[0],j+dy[0],word,index+1) or\\n    backtrack(board,i+dx[1],j+dy[1],word,index+1) or\\n    backtrack(board,i+dx[2],j+dy[2],word,index+1) or\\n    backtrack(board,i+dx[3],j+dy[3],word,index+1);\\n\\n    board[i][j] = t;\\n\\n    return x;\\n  }\\n\\n  bool exist(vector<vector<char>>& board, string word)\\n  {\\n    rows = board.size();\\n    cols = board[0].size();\\n\\n    for(int i=0;i<rows;i++)\\n    {\\n        for(int j=0;j<cols;j++)\\n        {\\n            if(backtrack(board,i,j,word,0))\\n                return true; \\n        }\\n    }\\n    return false;\\n  }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844379,
                "title": "word-search-c-using-dfs-easy-to-learn-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word){\\n\\t// if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count)\\n            return true;\\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size()|| board[i][j]!=word[count]){\\n            return false;\\n        }\\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        bool ans =  dfs(i-1,j,count+1,board,word) ||\\n                    dfs(i+1,j,count+1,board,word) ||\\n                    dfs(i,j-1,count+1,board,word) ||\\n                    dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp; // make board as it is for the upcoming calls\\n        \\n        return ans;\\n        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n       for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0]) {\\n\\t\\t\\t\\t\\t  if(dfs(i,j,0,board,word))\\n                {\\n                    return true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\nIf you like it , please do **Upvote**\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word){\\n\\t// if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count)\\n            return true;\\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size()|| board[i][j]!=word[count]){\\n            return false;\\n        }\\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        bool ans =  dfs(i-1,j,count+1,board,word) ||\\n                    dfs(i+1,j,count+1,board,word) ||\\n                    dfs(i,j-1,count+1,board,word) ||\\n                    dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp; // make board as it is for the upcoming calls\\n        \\n        return ans;\\n        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n       for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0]) {\\n\\t\\t\\t\\t\\t  if(dfs(i,j,0,board,word))\\n                {\\n                    return true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844050,
                "title": "java-my-easy-to-understand-solution-with-comments-beginner-friendly",
                "content": "```\\n//TC : O(V + E) ~ O(m * n + 4 * m * n) ~ O(m * n)\\n//SC : O(m * n), visited array\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visited = new boolean[board.length][board[0].length];\\n        for(int r = 0; r < board.length; ++r){\\n            for(int c = 0; c < board[0].length; ++c){\\n                if(board[r][c] == word.charAt(0)){\\n                   boolean res = search(0, r, c, board, visited, word);\\n                   if(res) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean search(int idx, int r, int c, char[][] board, boolean[][] visited, String word){\\n        if(idx == word.length()) return true; //means all the character of the words are found\\n        \\n        if(r < 0 || c < 0 || r >= board.length || c >= board[0].length){ //out of boundry so return false\\n            return false;\\n        }else if(board[r][c] != word.charAt(idx)){ //different char than word.charAt(idx) so return false\\n            return false;\\n        }else if(visited[r][c] == true){ //already visited cell so return false \\n            return false;\\n        }\\n        \\n        visited[r][c] = true; //mark visited\\n        \\n        //up call\\n        boolean ans1 = search(idx + 1, r - 1, c, board, visited, word);\\n        if(ans1) return true;\\n        \\n        //left call\\n        boolean ans2 = search(idx + 1, r, c - 1, board, visited, word);\\n        if(ans2) return true;\\n        \\n        //down call\\n        boolean ans3 = search(idx + 1, r + 1, c, board, visited, word);\\n        if(ans3) return true;\\n        \\n        //right call\\n        boolean ans4 = search(idx + 1, r, c + 1, board, visited, word);\\n        if(ans4) return true;\\n        \\n        visited[r][c] = false; //backtrack\\n        \\n        return false;\\n    }\\n}\\n```\\n**If you liked the solution please do UPVOTE it, Thank You!**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n//TC : O(V + E) ~ O(m * n + 4 * m * n) ~ O(m * n)\\n//SC : O(m * n), visited array\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visited = new boolean[board.length][board[0].length];\\n        for(int r = 0; r < board.length; ++r){\\n            for(int c = 0; c < board[0].length; ++c){\\n                if(board[r][c] == word.charAt(0)){\\n                   boolean res = search(0, r, c, board, visited, word);\\n                   if(res) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean search(int idx, int r, int c, char[][] board, boolean[][] visited, String word){\\n        if(idx == word.length()) return true; //means all the character of the words are found\\n        \\n        if(r < 0 || c < 0 || r >= board.length || c >= board[0].length){ //out of boundry so return false\\n            return false;\\n        }else if(board[r][c] != word.charAt(idx)){ //different char than word.charAt(idx) so return false\\n            return false;\\n        }else if(visited[r][c] == true){ //already visited cell so return false \\n            return false;\\n        }\\n        \\n        visited[r][c] = true; //mark visited\\n        \\n        //up call\\n        boolean ans1 = search(idx + 1, r - 1, c, board, visited, word);\\n        if(ans1) return true;\\n        \\n        //left call\\n        boolean ans2 = search(idx + 1, r, c - 1, board, visited, word);\\n        if(ans2) return true;\\n        \\n        //down call\\n        boolean ans3 = search(idx + 1, r + 1, c, board, visited, word);\\n        if(ans3) return true;\\n        \\n        //right call\\n        boolean ans4 = search(idx + 1, r, c + 1, board, visited, word);\\n        if(ans4) return true;\\n        \\n        visited[r][c] = false; //backtrack\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843923,
                "title": "simple-java-solution-using-dfs-backtracking",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n         boolean visited[][]=new boolean[board.length][board[0].length];\\n          for(int i=0;i<board.length;i++){\\n              for(int j=0;j<board[0].length;j++){\\n                  if(board[i][j]==word.charAt(0) && search(board,word,i,j,0,visited)){\\n                      return true;\\n                  }\\n              }\\n          }\\n        return false;\\n        \\n    }\\n    public boolean search(char[][]board,String word,int i,int j,int idx,boolean visited[][]){\\n       if(idx==word.length()){\\n           return true;\\n       }\\n       if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]!=word.charAt(idx) || visited[i][j]){\\n            return false;\\n        }\\n        visited[i][j]=true;\\n        if(search(board,word,i+1,j,idx+1,visited) || search(board,word,i,j+1,idx+1,visited) || search(board,word,i-1,j,idx+1,visited) || search(board,word,i,j-1,idx+1,visited)){\\n            return true;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n         boolean visited[][]=new boolean[board.length][board[0].length];\\n          for(int i=0;i<board.length;i++){\\n              for(int j=0;j<board[0].length;j++){\\n                  if(board[i][j]==word.charAt(0) && search(board,word,i,j,0,visited)){\\n                      return true;\\n                  }\\n              }\\n          }\\n        return false;\\n        \\n    }\\n    public boolean search(char[][]board,String word,int i,int j,int idx,boolean visited[][]){\\n       if(idx==word.length()){\\n           return true;\\n       }\\n       if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]!=word.charAt(idx) || visited[i][j]){\\n            return false;\\n        }\\n        visited[i][j]=true;\\n        if(search(board,word,i+1,j,idx+1,visited) || search(board,word,i,j+1,idx+1,visited) || search(board,word,i-1,j,idx+1,visited) || search(board,word,i,j-1,idx+1,visited)){\\n            return true;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498848,
                "title": "simple-backtracking-with-go",
                "content": "```\\nfunc exist(board [][]byte, word string) bool {\\n    var backtrack func(int, int, int) bool\\n    backtrack = func(r, c int, i int)  bool {\\n        if r < 0 || r > len(board)-1 || c < 0 || c > len(board[0])-1 || board[r][c] == \\'0\\' {\\n            return false\\n        }\\n        \\n        if board[r][c] != word[i] {\\n            return false\\n        }\\n        \\n        if i == len(word)-1 {\\n            return word[i] == board[r][c]\\n        }\\n        \\n        originalValue := board[r][c]\\n        \\n        board[r][c] = \\'0\\'\\n        \\n        if backtrack(r, c-1, i+1) || backtrack(r, c+1, i+1) || backtrack(r-1, c, i+1) || backtrack(r+1, c, i+1) {\\n            return true\\n        }\\n        \\n        board[r][c] = originalValue\\n        \\n        return false\\n    }\\n\\n    for r := 0; r < len(board); r++ {\\n        for c := 0; c < len(board[0]); c++ {\\n            if backtrack(r, c, 0){\\n                return true\\n            }\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc exist(board [][]byte, word string) bool {\\n    var backtrack func(int, int, int) bool\\n    backtrack = func(r, c int, i int)  bool {\\n        if r < 0 || r > len(board)-1 || c < 0 || c > len(board[0])-1 || board[r][c] == \\'0\\' {\\n            return false\\n        }\\n        \\n        if board[r][c] != word[i] {\\n            return false\\n        }\\n        \\n        if i == len(word)-1 {\\n            return word[i] == board[r][c]\\n        }\\n        \\n        originalValue := board[r][c]\\n        \\n        board[r][c] = \\'0\\'\\n        \\n        if backtrack(r, c-1, i+1) || backtrack(r, c+1, i+1) || backtrack(r-1, c, i+1) || backtrack(r+1, c, i+1) {\\n            return true\\n        }\\n        \\n        board[r][c] = originalValue\\n        \\n        return false\\n    }\\n\\n    for r := 0; r < len(board); r++ {\\n        for c := 0; c < len(board[0]); c++ {\\n            if backtrack(r, c, 0){\\n                return true\\n            }\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276765,
                "title": "python3-simple-backtracking-with-dfs",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def find(i, j, pos = 0):\\n            if pos == len(word):\\n                return True\\n            if not(0 <= i < m) or not(0 <= j < n) or board[i][j] == \"#\":\\n                return False\\n            if board[i][j] == word[pos]:\\n                temp = board[i][j]\\n                board[i][j] = \"#\"\\n                if find(i, j-1, pos+1) or find(i, j+1, pos+1) or find(i-1, j, pos+1) or find(i+1, j, pos+1):\\n                    return True\\n                board[i][j] = temp\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                if find(i ,j):\\n                    return True\\n        return False\\n```\\nTime : O(MNL)\\nSpace : (L)\\nPlease **UPVOTE**.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def find(i, j, pos = 0):\\n            if pos == len(word):\\n                return True\\n            if not(0 <= i < m) or not(0 <= j < n) or board[i][j] == \"#\":\\n                return False\\n            if board[i][j] == word[pos]:\\n                temp = board[i][j]\\n                board[i][j] = \"#\"\\n                if find(i, j-1, pos+1) or find(i, j+1, pos+1) or find(i-1, j, pos+1) or find(i+1, j, pos+1):\\n                    return True\\n                board[i][j] = temp\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                if find(i ,j):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257923,
                "title": "c-backtracking-time-complexity-explanation-notes",
                "content": "**My Solution Using Backtracking Algorithm:**\\n```\\nbool solve(int row, int col, string &curr, string &word, vector<vector<char>> &board) {\\n        if(curr.size() == word.size()) return true;\\n        for(int i = 1; i <= 4; i++) {\\n            int newRow = row, newCol = col;\\n            if(i == 1) newRow = row - 1;\\n            else if(i == 2) newCol = col + 1;\\n            else if(i == 3) newRow = row + 1;\\n            else newCol = col - 1;\\n            if(newRow >= 0 && newRow < board.size() && newCol >= 0 && newCol < board[0].size() && board[newRow][newCol] != \\'.\\' && board[newRow][newCol] == word[curr.size()]){\\n                char ch = board[newRow][newCol];\\n                board[newRow][newCol] = \\'.\\';\\n                curr.push_back(ch);\\n                bool b = solve(newRow, newCol, curr, word, board);\\n                curr.pop_back();\\n                board[newRow][newCol] = ch;\\n                if(b) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        string curr;\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board[i].size(); j++) {\\n                curr.push_back(board[i][j]);\\n                char ch = board[i][j];\\n                board[i][j] = \\'.\\';\\n                if(word[0] == ch && solve(i, j, curr, word, board)) \\n                    return true;\\n                board[i][j] = ch;\\n                curr.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n```\\n**Time Complexity Analysis:**\\n```\\nTC = O(nm3^k), k = size of the given word\\n```\\n* The given word can start from any cell.\\n* So, We have to traverse each cell of the board. So, it will take nm time for two for loops. \\n* For each cell we will try to find the given word, we have 3 direction to explore (as we can\\'t go to the direction from which we came so there are 3 posibilities)\\n* The max depth of the recursion tree can be the length of the given word (let length be k)\\n* So, considering the depth (k) and and 3 direction to explore the TC for each cell will come out to be 3^k\\n* So, the overall time complexity will be O(nm3^k)\\n\\n**Space Complexity Analysis:**\\nI am calculating only stack space:\\n```\\nStack space = O(k)\\n```\\n* As maximum depth of the recursion tree can be equal to size of the given word, so stack space will be O(k)\\n\\n![image](https://assets.leetcode.com/users/images/42e54db2-378a-4303-bbcf-5264a8e6c3a8_1657357575.2659547.jpeg)\\n\\n\\n\\n* Please like and comment on the post if you really find it helpfull.\\n* If I have made some mistakes, I am open to suggestions. Please comment it down.\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nbool solve(int row, int col, string &curr, string &word, vector<vector<char>> &board) {\\n        if(curr.size() == word.size()) return true;\\n        for(int i = 1; i <= 4; i++) {\\n            int newRow = row, newCol = col;\\n            if(i == 1) newRow = row - 1;\\n            else if(i == 2) newCol = col + 1;\\n            else if(i == 3) newRow = row + 1;\\n            else newCol = col - 1;\\n            if(newRow >= 0 && newRow < board.size() && newCol >= 0 && newCol < board[0].size() && board[newRow][newCol] != \\'.\\' && board[newRow][newCol] == word[curr.size()]){\\n                char ch = board[newRow][newCol];\\n                board[newRow][newCol] = \\'.\\';\\n                curr.push_back(ch);\\n                bool b = solve(newRow, newCol, curr, word, board);\\n                curr.pop_back();\\n                board[newRow][newCol] = ch;\\n                if(b) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        string curr;\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board[i].size(); j++) {\\n                curr.push_back(board[i][j]);\\n                char ch = board[i][j];\\n                board[i][j] = \\'.\\';\\n                if(word[0] == ch && solve(i, j, curr, word, board)) \\n                    return true;\\n                board[i][j] = ch;\\n                curr.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nTC = O(nm3^k), k = size of the given word\\n```\n```\\nStack space = O(k)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200649,
                "title": "c-dfs-solution-tle-explanation",
                "content": "For those of you who are getting TLE, eventhough the logic seems correct, make sure you **pass board by reference** instead of passing by value.\\n\\nUse :\\n`bool dfsSearch(vector<vector<char>>& board, string word, int i, int j, int n) `\\n\\nInstead of :\\n`bool dfsSearch(vector<vector<char>> board, string word, int i, int j, int n) {`\\n\\nWhen it is passed by value, the function creates its own copy of the parameters passed as arguments. This means it makes a copy of board everytime the function is called.\\n\\nHere\\'s my code,\\n```\\nclass Solution {\\n    //always pass board by reference to avoid TLE\\n    bool dfsSearch(vector<vector<char>>& board,string& word,int i,int j,int n){\\n        if(n==word.size())  //if last position ,means if word ends, search is successful\\n            return true;\\n        \\n        //return false for out of bound condition\\n        if(i<0 || i>=board.size() || j<0 || j>=board[i].size() || board[i][j]!=word[n]) return false;\\n        \\n        //mark as visited\\n        board[i][j]=\\'0\\';\\n        \\n        bool status = dfsSearch(board,word,i+1,j,n+1) //down\\n                    ||dfsSearch(board,word,i-1,j,n+1) //up\\n                    ||dfsSearch(board,word,i,j-1,n+1) //left\\n                    ||dfsSearch(board,word,i,j+1,n+1); //right\\n        \\n        //change back the original character for other word searches\\n        board[i][j]=word[n];\\n        \\n        return status;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word==\"\")  //return false if word is empty\\n            return false;\\n        \\n        int n=board.size(), m=board[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(board[i][j]==word[0] and dfsSearch(board,word,i,j,0)) //return true if search is successful\\n                    return true;\\n            }\\n        }\\n        return false; //Search failed, WORD NOT FOUND!! :(\\n    }\\n};\\n```\\n\\n**Runtime:** 309 ms, faster than 81.59% of C++ online submissions for Word Search.\\n**Memory Usage:** 7.8 MB, less than 99.07% of C++ online submissions for Word Search.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    //always pass board by reference to avoid TLE\\n    bool dfsSearch(vector<vector<char>>& board,string& word,int i,int j,int n){\\n        if(n==word.size())  //if last position ,means if word ends, search is successful\\n            return true;\\n        \\n        //return false for out of bound condition\\n        if(i<0 || i>=board.size() || j<0 || j>=board[i].size() || board[i][j]!=word[n]) return false;\\n        \\n        //mark as visited\\n        board[i][j]=\\'0\\';\\n        \\n        bool status = dfsSearch(board,word,i+1,j,n+1) //down\\n                    ||dfsSearch(board,word,i-1,j,n+1) //up\\n                    ||dfsSearch(board,word,i,j-1,n+1) //left\\n                    ||dfsSearch(board,word,i,j+1,n+1); //right\\n        \\n        //change back the original character for other word searches\\n        board[i][j]=word[n];\\n        \\n        return status;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word==\"\")  //return false if word is empty\\n            return false;\\n        \\n        int n=board.size(), m=board[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(board[i][j]==word[0] and dfsSearch(board,word,i,j,0)) //return true if search is successful\\n                    return true;\\n            }\\n        }\\n        return false; //Search failed, WORD NOT FOUND!! :(\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679994,
                "title": "simple-dfs-backtracking-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string &word,int i,int j){\\n        \\n        //base case\\n        if(word.size()==0) return true;\\n        if(i<0 || j<0 || i>=board.size() || j>= board[0].size() || board[i][j]!=word[0]) return false;\\n        \\n        char c = board[i][j];\\n         board[i][j] =\\'X\\';\\n        string s = word.substr(1);\\n        \\n        //dfs call\\n        bool res = dfs(board,s,i+1,j)||dfs(board,s,i-1,j)||dfs(board,s,i,j+1)||dfs(board,s,i,j-1);\\n        \\n        //backtrack\\n        board[i][j] =c;\\n        return res;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dfs(board,word,i,j)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string &word,int i,int j){\\n        \\n        //base case\\n        if(word.size()==0) return true;\\n        if(i<0 || j<0 || i>=board.size() || j>= board[0].size() || board[i][j]!=word[0]) return false;\\n        \\n        char c = board[i][j];\\n         board[i][j] =\\'X\\';\\n        string s = word.substr(1);\\n        \\n        //dfs call\\n        bool res = dfs(board,s,i+1,j)||dfs(board,s,i-1,j)||dfs(board,s,i,j+1)||dfs(board,s,i,j-1);\\n        \\n        //backtrack\\n        board[i][j] =c;\\n        return res;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dfs(board,word,i,j)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640918,
                "title": "java-dfs-no-visited-array-beats-86-time-beats-99-space",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t// Call function for each board entry since any could be the start of a valid sequence\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n\\t\\t\\t\\t// If the function call returns true, this starting char lead to a valid word match\\n                if(dfs(board, word, 0, i, j) == true){\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t// If none of the grid entries lead to a matching word return false\\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, String word, int index, int i, int j){\\n        // Index is 1 past the last character in word, thus all letters in word have been checked return true\\n        if(index == word.length()){\\n            return true;\\n        }\\n        // Catch-all for common edge cases, if out of bounds, if seen before, if doesnt match expected index, return false\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || word.charAt(index) != board[i][j]){\\n            return false;\\n        }\\n        // At this point we\\'re at a valid letter in the sequence. Store current letter and set to placeholder for visited\\n        char tmp = board[i][j];\\n        board[i][j] = \\'0\\';\\n        // Do the same checks for all surrounding/later characters, if any returns true down the line, \\n        // pass \"true\" up the stack\\n        if(dfs(board, word, index + 1, i + 1, j) || \\n           dfs(board, word, index + 1, i - 1, j) ||\\n           dfs(board, word, index + 1, i, j + 1) ||\\n           dfs(board, word, index + 1, i, j - 1))\\n        {\\n            return true;\\n        }\\n        // This statement is met when we had a valid character but it did not lead to a valid match down the line\\n        // Change character back to unvisited while going back up the stack and return false for this character/path\\n        board[i][j] = tmp;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t// Call function for each board entry since any could be the start of a valid sequence\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n\\t\\t\\t\\t// If the function call returns true, this starting char lead to a valid word match\\n                if(dfs(board, word, 0, i, j) == true){\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t// If none of the grid entries lead to a matching word return false\\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, String word, int index, int i, int j){\\n        // Index is 1 past the last character in word, thus all letters in word have been checked return true\\n        if(index == word.length()){\\n            return true;\\n        }\\n        // Catch-all for common edge cases, if out of bounds, if seen before, if doesnt match expected index, return false\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || word.charAt(index) != board[i][j]){\\n            return false;\\n        }\\n        // At this point we\\'re at a valid letter in the sequence. Store current letter and set to placeholder for visited\\n        char tmp = board[i][j];\\n        board[i][j] = \\'0\\';\\n        // Do the same checks for all surrounding/later characters, if any returns true down the line, \\n        // pass \"true\" up the stack\\n        if(dfs(board, word, index + 1, i + 1, j) || \\n           dfs(board, word, index + 1, i - 1, j) ||\\n           dfs(board, word, index + 1, i, j + 1) ||\\n           dfs(board, word, index + 1, i, j - 1))\\n        {\\n            return true;\\n        }\\n        // This statement is met when we had a valid character but it did not lead to a valid match down the line\\n        // Change character back to unvisited while going back up the stack and return false for this character/path\\n        board[i][j] = tmp;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578096,
                "title": "simple-java-backtracking",
                "content": "```\\n\\tpublic boolean exist(char[][] board, String word) {\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        char[] words = word.toCharArray();\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board[0].length; j++) {\\n                if(solve(board, words, visited, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    boolean solve(char[][] board, char[] words, boolean[][] visited, int x, int y, int i) {\\n        if(i == words.length) {\\n            return true;\\n        }\\n        \\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || visited[x][y]) {\\n            return false;\\n        }\\n        \\n        if(board[x][y] != words[i]) {\\n            return false;\\n        }\\n        \\n        visited[x][y] = true;\\n        boolean exists = \\n            solve(board, words, visited, x + 1, y, i + 1) ||\\n            solve(board, words, visited, x - 1, y, i + 1) ||\\n            solve(board, words, visited, x, y + 1, i + 1) ||\\n            solve(board, words, visited, x, y - 1, i + 1);\\n        visited[x][y] = false;\\n        return exists;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\tpublic boolean exist(char[][] board, String word) {\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        char[] words = word.toCharArray();\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board[0].length; j++) {\\n                if(solve(board, words, visited, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    boolean solve(char[][] board, char[] words, boolean[][] visited, int x, int y, int i) {\\n        if(i == words.length) {\\n            return true;\\n        }\\n        \\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || visited[x][y]) {\\n            return false;\\n        }\\n        \\n        if(board[x][y] != words[i]) {\\n            return false;\\n        }\\n        \\n        visited[x][y] = true;\\n        boolean exists = \\n            solve(board, words, visited, x + 1, y, i + 1) ||\\n            solve(board, words, visited, x - 1, y, i + 1) ||\\n            solve(board, words, visited, x, y + 1, i + 1) ||\\n            solve(board, words, visited, x, y - 1, i + 1);\\n        visited[x][y] = false;\\n        return exists;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1571612,
                "title": "dfs-c-no-extra-space-backtracking-intution",
                "content": "Intution : We traverse the givin grid and try to find the first char of the given string word after that we do a dfs from the char to all the four directions and if we find the  ans we return true it else we backtrack.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board,int i,int j,int count,string word)\\n    {\\n        if(count==word.length()) return true;\\n        \\n        if(i<0||j<0||i>=board.size()||j>=board[0].size()||board[i][j]!=word[count]) return false;\\n        \\n        char temp=board[i][j];\\n        board[i][j]=\\' \\';\\n        \\n        bool found=dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||\\n                   dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        \\n        board[i][j]=temp;\\n        \\n        return found;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==word[0]&&dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Pls Give an upvote if you found this to be helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board,int i,int j,int count,string word)\\n    {\\n        if(count==word.length()) return true;\\n        \\n        if(i<0||j<0||i>=board.size()||j>=board[0].size()||board[i][j]!=word[count]) return false;\\n        \\n        char temp=board[i][j];\\n        board[i][j]=\\' \\';\\n        \\n        bool found=dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||\\n                   dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        \\n        board[i][j]=temp;\\n        \\n        return found;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==word[0]&&dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304308,
                "title": "c-dfs-clean-solution-clean-code-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]== word[0] && dfs(board,i,j,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n         return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,int i,int j,string word,int count) {\\n        if(count == word.size())\\n            return true;\\n        if(i<0 || j<0 || i>=board.size()|| j>=board[i].size() ||board[i][j] != word[count])\\n            return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,word,count+1) || dfs(board,i-1,j,word,count+1) ||\\n                     dfs(board,i,j+1,word,count+1) || dfs(board,i,j-1,word,count+1);\\n        board[i][j] = temp;\\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]== word[0] && dfs(board,i,j,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n         return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,int i,int j,string word,int count) {\\n        if(count == word.size())\\n            return true;\\n        if(i<0 || j<0 || i>=board.size()|| j>=board[i].size() ||board[i][j] != word[count])\\n            return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,word,count+1) || dfs(board,i-1,j,word,count+1) ||\\n                     dfs(board,i,j+1,word,count+1) || dfs(board,i,j-1,word,count+1);\\n        board[i][j] = temp;\\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983655,
                "title": "my-simple-java-solution-faster-than-99-07-of-java-online-submissions",
                "content": "Runtime: 4 ms, faster than 99.07% of Java online submissions\\n\\n```\\nclass Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        visited = new boolean[board.length][board[0].length];\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (backtrack(board, i, j, w, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int row, int col, char[] w, int index) {\\n        if (index == w.length) {\\n            return true;\\n        }\\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || visited[row][col]) {\\n            return false;\\n        }\\n        if (w[index] != board[row][col]) {\\n            return false;\\n        }\\n        \\n        visited[row][col] = true;\\n\\n        if (backtrack(board, row + 1, col, w, index+1) \\n            || backtrack(board, row - 1, col, w, index+1) \\n            || backtrack(board, row, col + 1, w, index+1) \\n            || backtrack(board, row, col - 1, w, index+1)) {\\n            return true;\\n        }\\n        \\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n**Time Complexity: O(N*3^min(L, N))**\\nEach cell has only 3 directions to be potentially explored because one direction has been already visited by its parent.\\nSo, the worst case can be expressed by N * 4 * 3^min(L - 1, N - 1) (4 means the beginning point) and by big O,\\nO(N * 3^min(L, N))\\n**Space complexity: O(L)**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        visited = new boolean[board.length][board[0].length];\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (backtrack(board, i, j, w, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int row, int col, char[] w, int index) {\\n        if (index == w.length) {\\n            return true;\\n        }\\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || visited[row][col]) {\\n            return false;\\n        }\\n        if (w[index] != board[row][col]) {\\n            return false;\\n        }\\n        \\n        visited[row][col] = true;\\n\\n        if (backtrack(board, row + 1, col, w, index+1) \\n            || backtrack(board, row - 1, col, w, index+1) \\n            || backtrack(board, row, col + 1, w, index+1) \\n            || backtrack(board, row, col - 1, w, index+1)) {\\n            return true;\\n        }\\n        \\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977776,
                "title": "java-simple-easy-line-by-line-explanation-dfs-backtracking",
                "content": "```\\nclass Solution {\\n  public boolean exist(char[][] board, String word) {\\n      \\n    /*\\n    Idea: Backtracking\\n    \\n    -> Iterate through each cell in the matrix & check if char matches index 0 of word\\n            -> if yes - increment index & find the boundary cells (top, down, bottom, left) to find the char at index 1 of word\\n            -> if No - return false;\\n    \\n    -> Keep visited matrix to avoid recounting visited cells & eliminating endless loop\\n            -> eg  [[\"a\",\"a\"]]   find if \"aaaaaaaa\" exists would return Yes without visited matrix but its a No.\\n    \\n    -> check for boundary conditions at each stage !important\\n    \\n    */\\n      \\n    boolean[][] visited = new boolean[board.length][board[0].length];\\n    int index = 0;\\n      \\n    // iterate all cells\\n    for (int i = 0; i < board.length; i++) {\\n      for (int j = 0; j < board[0].length; j++) {\\n\\n        if(findWordInBoard(board, word, visited, index, i, j))\\n        {\\n            return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n    \\n  // recursive calls for each cell\\n  public boolean findWordInBoard(char[][] board, String word, boolean[][] visited, int index, int i, int j) {\\n      \\n    // terminating condition if length of index reaches lenght of word\\n    if (index == word.length()) {\\n      return true;\\n    }\\n\\n    // else check bounds & if already visited\\n    if (!withinBounds(i, j, board.length, board[0].length) || visited[i][j]) {\\n      return false;\\n    }\\n\\n    // check index char\\n    char cell = board[i][j];\\n    char indexChar = word.charAt(index);\\n\\n    // mismatch\\n    if (cell != indexChar) {\\n      return false;\\n    }\\n\\n    // visit this cell if matched\\n    visited[i][j] = true;\\n\\n    // check boundary chars\\n    if (findWordInBoard(board, word, visited, index + 1, i - 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i + 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j - 1)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j + 1)) return true;\\n\\n    // unvisit cell - after checking all possibilites (would not come here if a valid answer existed using this cell \\n    // else clear up visiting for checking with other cells)\\n    visited[i][j] = false;\\n\\n    return false;\\n  }\\n\\n  // boundary condition checks\\n  public boolean withinBounds(int i, int j, int rows, int cols) {\\n    if (i < rows && i >= 0 && j < cols && j >= 0) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean exist(char[][] board, String word) {\\n      \\n    /*\\n    Idea: Backtracking\\n    \\n    -> Iterate through each cell in the matrix & check if char matches index 0 of word\\n            -> if yes - increment index & find the boundary cells (top, down, bottom, left) to find the char at index 1 of word\\n            -> if No - return false;\\n    \\n    -> Keep visited matrix to avoid recounting visited cells & eliminating endless loop\\n            -> eg  [[\"a\",\"a\"]]   find if \"aaaaaaaa\" exists would return Yes without visited matrix but its a No.\\n    \\n    -> check for boundary conditions at each stage !important\\n    \\n    */\\n      \\n    boolean[][] visited = new boolean[board.length][board[0].length];\\n    int index = 0;\\n      \\n    // iterate all cells\\n    for (int i = 0; i < board.length; i++) {\\n      for (int j = 0; j < board[0].length; j++) {\\n\\n        if(findWordInBoard(board, word, visited, index, i, j))\\n        {\\n            return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n    \\n  // recursive calls for each cell\\n  public boolean findWordInBoard(char[][] board, String word, boolean[][] visited, int index, int i, int j) {\\n      \\n    // terminating condition if length of index reaches lenght of word\\n    if (index == word.length()) {\\n      return true;\\n    }\\n\\n    // else check bounds & if already visited\\n    if (!withinBounds(i, j, board.length, board[0].length) || visited[i][j]) {\\n      return false;\\n    }\\n\\n    // check index char\\n    char cell = board[i][j];\\n    char indexChar = word.charAt(index);\\n\\n    // mismatch\\n    if (cell != indexChar) {\\n      return false;\\n    }\\n\\n    // visit this cell if matched\\n    visited[i][j] = true;\\n\\n    // check boundary chars\\n    if (findWordInBoard(board, word, visited, index + 1, i - 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i + 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j - 1)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j + 1)) return true;\\n\\n    // unvisit cell - after checking all possibilites (would not come here if a valid answer existed using this cell \\n    // else clear up visiting for checking with other cells)\\n    visited[i][j] = false;\\n\\n    return false;\\n  }\\n\\n  // boundary condition checks\\n  public boolean withinBounds(int i, int j, int rows, int cols) {\\n    if (i < rows && i >= 0 && j < cols && j >= 0) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713113,
                "title": "c-usiing-dfs-and-recursion-perfect-for-beginners",
                "content": "***Pls upvote if you find this helpful  :)***\\nThe basic idea is to iterate through the entire board and use dfs once we find a character matching the first character of the string and look if we could find the entire string on the board.\\n```\\nclass Solution {\\npublic:\\n     bool dfs(int i,int j,int count,string& word,vector<vector<char>>& board){\\n         if(count==word.size())return true;\\n         if(i<0||i>=board.size()||j<0||j>=board[0].size()||board[i][j]!=word[count])return false;\\n         char temp=board[i][j];\\n         board[i][j]=\\'#\\';\\n         bool answer=   dfs(i-1,j,count+1,word,board)||\\n                        dfs(i+1,j,count+1,word,board)||\\n                        dfs(i,j-1,count+1,word,board)||\\n                        dfs(i,j+1,count+1,word,board);\\n         board[i][j]=temp;\\n         return answer;\\n     }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if((board[i][j]==word[0])&&dfs(i,j,0,word,board))return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool dfs(int i,int j,int count,string& word,vector<vector<char>>& board){\\n         if(count==word.size())return true;\\n         if(i<0||i>=board.size()||j<0||j>=board[0].size()||board[i][j]!=word[count])return false;\\n         char temp=board[i][j];\\n         board[i][j]=\\'#\\';\\n         bool answer=   dfs(i-1,j,count+1,word,board)||\\n                        dfs(i+1,j,count+1,word,board)||\\n                        dfs(i,j-1,count+1,word,board)||\\n                        dfs(i,j+1,count+1,word,board);\\n         board[i][j]=temp;\\n         return answer;\\n     }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if((board[i][j]==word[0])&&dfs(i,j,0,word,board))return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598473,
                "title": "simple-python-solution-dfs-visited",
                "content": "```\\ndef dfs(board, word, r, c, visited):\\n    if not word:\\n        return True\\n\\n    if (\\n        (r, c) in visited\\n        or r < 0\\n        or r >= len(board)\\n        or c < 0\\n        or c >= len(board[0])\\n        or board[r][c] != word[0]\\n    ):\\n        return False\\n\\n    return (\\n        dfs(board, word[1:], r + 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r - 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c + 1, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c - 1, visited + [(r, c)])\\n    )\\n\\n\\nclass Solution:\\n    def exist(self, board, word):\\n        for r, row in enumerate(board):\\n            for c, l in enumerate(row):\\n                if dfs(board, word, r, c, []):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(board, word, r, c, visited):\\n    if not word:\\n        return True\\n\\n    if (\\n        (r, c) in visited\\n        or r < 0\\n        or r >= len(board)\\n        or c < 0\\n        or c >= len(board[0])\\n        or board[r][c] != word[0]\\n    ):\\n        return False\\n\\n    return (\\n        dfs(board, word[1:], r + 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r - 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c + 1, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c - 1, visited + [(r, c)])\\n    )\\n\\n\\nclass Solution:\\n    def exist(self, board, word):\\n        for r, row in enumerate(board):\\n            for c, l in enumerate(row):\\n                if dfs(board, word, r, c, []):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576945,
                "title": "simple-and-elegant-ruby-solution-using-dfs",
                "content": "```\\ndef exist(board, word)\\n  return false if board.empty? || word.empty?\\n  m = board.length\\n  n = board[0].length\\n  @board, @word = board, word\\n  (0...m).each { |i|\\n    (0...n).each { |j|\\n      return true if word_exists?(i, j, 0)\\n    }\\n  }\\n  p board\\n  false\\nend\\n\\ndef word_exists?(i, j, wi)\\n  return false if !within_bounds?(i, j) || @board[i][j] != @word[wi]\\n  return true if wi == @word.length-1\\n  @board[i][j] = \\'*\\'\\n  result = word_exists?(i+1, j, wi+1) ||\\n    word_exists?(i, j+1, wi+1) ||\\n    word_exists?(i-1, j, wi+1) ||\\n    word_exists?(i, j-1, wi+1)\\n  \\n  @board[i][j] = @word[wi]\\n  result\\nend\\n\\ndef within_bounds?(i, j)\\n  i >= 0 && j >= 0 && i < @board.length && j < @board[0].length\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search"
                ],
                "code": "```\\ndef exist(board, word)\\n  return false if board.empty? || word.empty?\\n  m = board.length\\n  n = board[0].length\\n  @board, @word = board, word\\n  (0...m).each { |i|\\n    (0...n).each { |j|\\n      return true if word_exists?(i, j, 0)\\n    }\\n  }\\n  p board\\n  false\\nend\\n\\ndef word_exists?(i, j, wi)\\n  return false if !within_bounds?(i, j) || @board[i][j] != @word[wi]\\n  return true if wi == @word.length-1\\n  @board[i][j] = \\'*\\'\\n  result = word_exists?(i+1, j, wi+1) ||\\n    word_exists?(i, j+1, wi+1) ||\\n    word_exists?(i-1, j, wi+1) ||\\n    word_exists?(i, j-1, wi+1)\\n  \\n  @board[i][j] = @word[wi]\\n  result\\nend\\n\\ndef within_bounds?(i, j)\\n  i >= 0 && j >= 0 && i < @board.length && j < @board[0].length\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 480038,
                "title": "clean-python-dfs",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not word or not any(board): return False\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(x:int, y:int, i: int = 0):\\n            if i == len(word) - 1: return board[x][y] == word[i]\\n            if board[x][y] != word[i]: return False\\n            value = board[x][y]\\n            board[x][y] = \\'#\\'\\n            for r, c in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n                if 0 <= r < m and 0 <= c < n and dfs(r, c, i + 1):\\n                    return True\\n            board[x][y] = value\\n            return False\\n\\n        return any(dfs(x, y) for x in range(m) for y in range(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not word or not any(board): return False\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(x:int, y:int, i: int = 0):\\n            if i == len(word) - 1: return board[x][y] == word[i]\\n            if board[x][y] != word[i]: return False\\n            value = board[x][y]\\n            board[x][y] = \\'#\\'\\n            for r, c in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n                if 0 <= r < m and 0 <= c < n and dfs(r, c, i + 1):\\n                    return True\\n            board[x][y] = value\\n            return False\\n\\n        return any(dfs(x, y) for x in range(m) for y in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214773,
                "title": "go-golang-4ms-100",
                "content": "```\\nfunc exist(board [][]byte, word string) bool {\\n    \\n    row := len(board)\\n    if row == 0{\\n        return false\\n    }\\n    col := len(board[0])\\n    words:= []byte(word)\\n    \\n    for i:=0; i<row; i++{\\n        for j:=0;j<col; j++{\\n            if helper(board, words, i, j, 0){\\n                return true\\n            }\\n        }\\n    }\\n    return false   \\n}\\n\\nfunc helper(board [][]byte, word []byte, i, j , k int) bool{\\n    if i<0 || j<0 || i >= len(board) || j>= len(board[0]){\\n        return false\\n    }\\n    \\n    if board[i][j] == word[k]{\\n        if k == len(word)-1{\\n        return true\\n       }\\n        temp := board[i][j]\\n        board[i][j] = 0\\n        found := helper(board,word, i+1, j , k+1) || helper(board,word, i, j+1 , k+1) ||helper(board,word, i-1, j , k+1) || helper(board,word, i, j-1 , k+1)\\n        board[i][j] = temp\\n        return found\\n    } else{\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc exist(board [][]byte, word string) bool {\\n    \\n    row := len(board)\\n    if row == 0{\\n        return false\\n    }\\n    col := len(board[0])\\n    words:= []byte(word)\\n    \\n    for i:=0; i<row; i++{\\n        for j:=0;j<col; j++{\\n            if helper(board, words, i, j, 0){\\n                return true\\n            }\\n        }\\n    }\\n    return false   \\n}\\n\\nfunc helper(board [][]byte, word []byte, i, j , k int) bool{\\n    if i<0 || j<0 || i >= len(board) || j>= len(board[0]){\\n        return false\\n    }\\n    \\n    if board[i][j] == word[k]{\\n        if k == len(word)-1{\\n        return true\\n       }\\n        temp := board[i][j]\\n        board[i][j] = 0\\n        found := helper(board,word, i+1, j , k+1) || helper(board,word, i, j+1 , k+1) ||helper(board,word, i-1, j , k+1) || helper(board,word, i, j-1 , k+1)\\n        board[i][j] = temp\\n        return found\\n    } else{\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209469,
                "title": "java-dfs-beats-99-6-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        // at each board[i][j] start a dfs traversal and try to match the given word.\\n        // dfs traverses top, left right and bottom cells.\\n        for(int i = 0 ; i < board.length; ++i) {\\n            for(int j = 0; j < board[0].length; ++j) {\\n                if(dfs(board, i, j, word, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // board[i][j] - current cell, under investigation.\\n    // off - starting index of unmatched part of the word.\\n    private boolean dfs(char[][] board, int i, int j, String word, int off) {\\n        // check out of bounce\\n        if(i < 0 || i >= board.length)\\n            return false;\\n        if(j < 0 || j >= board[0].length)\\n            return false;\\n        \\n        char c = board[i][j];\\n        // check visited\\n        if(c == \\'#\\')\\n            return false;\\n        // mismatch\\n        if(c != word.charAt(off))\\n            return false;\\n        // if we have reached the end of the word, then we found the word.\\n        if(off == word.length() - 1)\\n            return true;\\n        \\n        // mark node as visited\\n        board[i][j] = \\'#\\';\\n        boolean res = dfs(board, i + 1, j, word, off + 1) || \\n            dfs(board, i - 1, j, word, off + 1) || \\n            dfs(board, i, j + 1, word, off + 1) || \\n            dfs(board, i, j - 1, word, off + 1);\\n        // unmark vistied \\n        board[i][j] = c;\\n        return res;\\n    }\\n}\\n```\\nTime Complexity - `O(m * n * l)`\\nn - number of rows in board.\\nm - number of cols in board.\\nl - length of the word to be matched.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        // at each board[i][j] start a dfs traversal and try to match the given word.\\n        // dfs traverses top, left right and bottom cells.\\n        for(int i = 0 ; i < board.length; ++i) {\\n            for(int j = 0; j < board[0].length; ++j) {\\n                if(dfs(board, i, j, word, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // board[i][j] - current cell, under investigation.\\n    // off - starting index of unmatched part of the word.\\n    private boolean dfs(char[][] board, int i, int j, String word, int off) {\\n        // check out of bounce\\n        if(i < 0 || i >= board.length)\\n            return false;\\n        if(j < 0 || j >= board[0].length)\\n            return false;\\n        \\n        char c = board[i][j];\\n        // check visited\\n        if(c == \\'#\\')\\n            return false;\\n        // mismatch\\n        if(c != word.charAt(off))\\n            return false;\\n        // if we have reached the end of the word, then we found the word.\\n        if(off == word.length() - 1)\\n            return true;\\n        \\n        // mark node as visited\\n        board[i][j] = \\'#\\';\\n        boolean res = dfs(board, i + 1, j, word, off + 1) || \\n            dfs(board, i - 1, j, word, off + 1) || \\n            dfs(board, i, j + 1, word, off + 1) || \\n            dfs(board, i, j - 1, word, off + 1);\\n        // unmark vistied \\n        board[i][j] = c;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110930,
                "title": "python-dfs-solution-similar-to-max-area-of-islands",
                "content": "```class Solution(object):\\n    def exist(self, board, word):\\n        def backtracking(board, i, j, word):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board):\\n                return False\\n            if j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"#\"\\n                if backtracking(board, i+1, j, word[1:]) or backtracking(board, i-1, j, word[1:]) or backtracking(board, i, j+1, word[1:]) or backtracking(board, i, j-1, word[1:]):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if backtracking(board, i, j, word):\\n                    return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```class Solution(object):\\n    def exist(self, board, word):\\n        def backtracking(board, i, j, word):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board):\\n                return False\\n            if j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"#\"\\n                if backtracking(board, i+1, j, word[1:]) or backtracking(board, i-1, j, word[1:]) or backtracking(board, i, j+1, word[1:]) or backtracking(board, i, j-1, word[1:]):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if backtracking(board, i, j, word):\\n                    return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 27669,
                "title": "clean-and-short-c-code-9ms",
                "content": "DFS with backtracking\\n\\n \\n```\\nclass Solution {\\n    bool helper(vector<vector<char>>& board, string &word, int k, int i, int j) {\\n        if (k == word.length()) return true;\\n        if (i<0 || i>=board.size()) return false;\\n        if (j<0 || j>=board[i].size()) return false;\\n        \\n        \\n        if (word[k] == board[i][j]) {\\n            board[i][j] = ' ';\\n            if (helper(board, word, k+1, i+1, j)) return true;\\n            if (helper(board, word, k+1, i-1, j)) return true;\\n            if (helper(board, word, k+1, i, j+1)) return true;\\n            if (helper(board, word, k+1, i, j-1)) return true;\\n            board[i][j] = word[k];\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i=0; i<board.size(); ++i)\\n            for (int j=0; j<board[i].size(); ++j) {\\n                if (helper(board, word, 0, i, j)) {\\n                    return true;\\n                }\\n            }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool helper(vector<vector<char>>& board, string &word, int k, int i, int j) {\\n        if (k == word.length()) return true;\\n        if (i<0 || i>=board.size()) return false;\\n        if (j<0 || j>=board[i].size()) return false;\\n        \\n        \\n        if (word[k] == board[i][j]) {\\n            board[i][j] = ' ';\\n            if (helper(board, word, k+1, i+1, j)) return true;\\n            if (helper(board, word, k+1, i-1, j)) return true;\\n            if (helper(board, word, k+1, i, j+1)) return true;\\n            if (helper(board, word, k+1, i, j-1)) return true;\\n            board[i][j] = word[k];\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i=0; i<board.size(); ++i)\\n            for (int j=0; j<board[i].size(); ++j) {\\n                if (helper(board, word, 0, i, j)) {\\n                    return true;\\n                }\\n            }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27751,
                "title": "clean-python-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n\\n    def exist(self, board, word):\\n        char_to_pos = defaultdict(list)\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                char_to_pos[board[i][j]].append((i, j))\\n        return self._exist(char_to_pos, word, set())\\n\\n    def _exist(self, char_to_pos, word, used, last_pos=None):\\n        if not word:\\n            return True\\n        for p in char_to_pos[word[0]]:\\n            if p in used or (last_pos and not self._is_pos_valid(p, last_pos)):\\n                continue\\n            used.add(p)\\n            if self._exist(char_to_pos, word[1:], used, p):\\n                return True\\n            used.remove(p)\\n        return False\\n        \\n    def _is_pos_valid(self, (i1, j1), (i2, j2)):\\n        return (i1 == i2 and abs(j1-j2) == 1) or (j1 == j2 and abs(i1-i2) == 1)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n\\n    def exist(self, board, word):\\n        char_to_pos = defaultdict(list)\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                char_to_pos[board[i][j]].append((i, j))\\n        return self._exist(char_to_pos, word, set())\\n\\n    def _exist(self, char_to_pos, word, used, last_pos=None):\\n        if not word:\\n            return True\\n        for p in char_to_pos[word[0]]:\\n            if p in used or (last_pos and not self._is_pos_valid(p, last_pos)):\\n                continue\\n            used.add(p)\\n            if self._exist(char_to_pos, word[1:], used, p):\\n                return True\\n            used.remove(p)\\n        return False\\n        \\n    def _is_pos_valid(self, (i1, j1), (i2, j2)):\\n        return (i1 == i2 and abs(j1-j2) == 1) or (j1 == j2 and abs(i1-i2) == 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27800,
                "title": "java-dfs-solution",
                "content": "    public class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            \\n            for(int i=0;i<board.length;i++){\\n                for(int j=0;j<board[i].length;j++){\\n                    if(helper(board,i,j,word,0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private boolean helper(char[][] board, int i, int j, String word, int step){\\n            if(step==word.length()){\\n                return true;\\n            }\\n            if(i<0||i>=board.length||j<0||j>=board[i].length){\\n                return false;\\n            }\\n            if((board[i][j]-word.charAt(step))!=0){\\n                return false;\\n            }\\n            char record=board[i][j];\\n            board[i][j]='1';\\n            boolean res=helper(board,i-1,j,word,step+1)||helper(board,i,j-1,word,step+1)||helper(board,i,j+1,word,step+1)||helper(board,i+1,j,word,step+1);\\n            board[i][j]=record;\\n            return res;\\n            \\n        }\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            \\n            for(int i=0;i<board.length;i++){\\n                for(int j=0;j<board[i].length;j++){\\n                    if(helper(board,i,j,word,0)){\\n                        return true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 27803,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0)  return false;\\n            int m=board.size(), n=board[0].size();\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(help(board, i, j, 0, word))  return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        bool help(vector<vector<char>>& board, int i, int j, int len, string word){\\n            if(len==word.size())   return true;\\n            if(i<0 || j<0 || i>=board.size() || j>=board[0].size())  return false;\\n            if(board[i][j]!=word[len] || board[i][j]=='*')  return false;\\n            char ch=board[i][j];\\n            board[i][j]='*';\\n            bool result= help(board, i+1, j, len+1, word) ||\\n                         help(board, i-1, j, len+1, word) ||\\n                         help(board, i, j+1, len+1, word) ||\\n                         help(board, i, j-1, len+1, word);\\n            board[i][j]=ch;\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0)  return false;\\n            int m=board.size(), n=board[0].size();\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(help(board, i, j, 0, word))  return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27870,
                "title": "52ms-simple-dfs-without-extra-space",
                "content": "All words are ASCII, so they only use 7 bits. Is this cheating?\\n\\n    class Solution {\\n    public:\\n        bool exist(vector<vector<char> > &board, string word) {\\n            m = board.size() - 1;\\n            n = board[0].size() - 1;\\n            for (int i = 0; i <= m; i++)\\n                for (int j = 0; j <= n; j++)\\n                    if (board[i][j] == word[0])\\n                        if (dfs(board, i, j, word.c_str() + 1))\\n                            return true;\\n            return false;\\n        }\\n    private:\\n        int m, n;\\n        bool dfs(vector<vector<char> > &board, int i, int j, const char *w) {\\n            if (*w == 0)\\n                return true;\\n            board[i][j] ^= 0x80;\\n            for (int k = -(i != 0); k <= (i < m); k++)\\n                for (int l = -(j != 0); l <= (j < n); l++)\\n                    if ((k ^ l) & 1 && board[i + k][j + l] == *w)\\n                        if (dfs(board, i + k, j + l, w + 1))\\n                            return true;\\n            board[i][j] ^= 0x80;\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char> > &board, string word) {\\n            m = board.size() - 1;\\n            n = board[0].size() - 1;\\n            for (int i = 0; i <= m; i++)\\n                for (int j = 0; j <= n; j++)\\n                    if (board[i][j] == word[0])\\n                        if (dfs(board, i, j, word.c_str() + 1))\\n                            return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3848683,
                "title": "easiest-approach-recursion-backtracking-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThink for dfs approach with backtracking.\\nAs just search in four directions for word\\'s each character as you get it in adjacent then call dfs for next character in adjacent of current indexes where we get our previous character.\\n\\n\\uD83E\\uDDD0 Why Backtracking required ?\\n   In some cases there are repetative character present and whenever we are searching in four directions it gets ecvaluating the previous one which one is already taken by us for the previous same charcter (\\uD83D\\uDC40 take look at test case 3 \\uD83D\\uDC40).\\nSo we have to store the path\\'s visited status.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int dr[4]={0,1,0,-1};\\n    int dc[4]={1,0,-1,0};\\n    int vis[7][7];\\n    bool f(int i, int j, vector<vector<char>>&board , string word,int index){\\n        int m = board.size();\\n        int n = board[0].size();\\n        if(index == word.size()) return true;\\n        for(int k=0;k<4;k++){\\n            int nr = dr[k]+i;\\n            int nc = dc[k]+j;\\n            if(nr>=0 && nc>=0 && nr<m && nc<n){\\n                if(board[nr][nc] == word[index]){\\n                      if(!vis[nr][nc]){\\n                      vis[nr][nc]=1;\\n                      if(f(nr,nc,board,word,index+1)) return true;\\n                      vis[nr][nc]=0;\\n                      }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==word[0]){\\n                    vis[i][j]=1;\\n                    if(f(i,j,board,word,1)) return true;\\n                    vis[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        return false;\\n     \\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dr[4]={0,1,0,-1};\\n    int dc[4]={1,0,-1,0};\\n    int vis[7][7];\\n    bool f(int i, int j, vector<vector<char>>&board , string word,int index){\\n        int m = board.size();\\n        int n = board[0].size();\\n        if(index == word.size()) return true;\\n        for(int k=0;k<4;k++){\\n            int nr = dr[k]+i;\\n            int nc = dc[k]+j;\\n            if(nr>=0 && nc>=0 && nr<m && nc<n){\\n                if(board[nr][nc] == word[index]){\\n                      if(!vis[nr][nc]){\\n                      vis[nr][nc]=1;\\n                      if(f(nr,nc,board,word,index+1)) return true;\\n                      vis[nr][nc]=0;\\n                      }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==word[0]){\\n                    vis[i][j]=1;\\n                    if(f(i,j,board,word,1)) return true;\\n                    vis[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        return false;\\n     \\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757941,
                "title": "java-code-with-explanation",
                "content": "```\\nclass Solution {\\npublic boolean exist(char[][] board, String word) {\\n \\n        // len for matrix\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                // if backtracking result returned is true then return\\n                if(check(board, word, i, j, m, n, 0))\\n                    return true;\\n            }\\n        }\\n      \\n        return false;\\n    }\\n    \\n    public boolean check(char board[][], String word,\\n                          int i, int j, int m , int n, int curr){\\n        \\n        // meaning if it has reached abcced and then when it calls further tracks of \\'d\\' in recursion. you need to check length to see if whole word is already met.       \\n        if(curr >= word.length())\\n            return true;\\n      \\n        // corner cases\\n        if(i<0 || j<0 || i >=m || j>=n|| board[i][j] != word.charAt(curr))\\n            return false;\\n        \\n\\t\\t// if character match then mask board\\'s character so that we don\\'t visit it again\\n        if(board[i][j]== word.charAt(curr))\\n            board[i][j] += 100;\\n        \\n        // to return final results\\n        boolean exists = false;\\n        \\n        // check bottom right top left\\n        exists = check(board, word, i+1, j, m, n, curr+1) ||\\n                check(board, word, i, j+1, m, n, curr+1) ||\\n                check(board, word, i-1, j, m, n, curr+1) ||\\n                check(board, word, i, j-1, m, n, curr+1);\\n        \\n\\t\\t//unmask masked character\\n        board[i][j] -= 100;\\n            \\n        return exists;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic boolean exist(char[][] board, String word) {\\n \\n        // len for matrix\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                // if backtracking result returned is true then return\\n                if(check(board, word, i, j, m, n, 0))\\n                    return true;\\n            }\\n        }\\n      \\n        return false;\\n    }\\n    \\n    public boolean check(char board[][], String word,\\n                          int i, int j, int m , int n, int curr){\\n        \\n        // meaning if it has reached abcced and then when it calls further tracks of \\'d\\' in recursion. you need to check length to see if whole word is already met.       \\n        if(curr >= word.length())\\n            return true;\\n      \\n        // corner cases\\n        if(i<0 || j<0 || i >=m || j>=n|| board[i][j] != word.charAt(curr))\\n            return false;\\n        \\n\\t\\t// if character match then mask board\\'s character so that we don\\'t visit it again\\n        if(board[i][j]== word.charAt(curr))\\n            board[i][j] += 100;\\n        \\n        // to return final results\\n        boolean exists = false;\\n        \\n        // check bottom right top left\\n        exists = check(board, word, i+1, j, m, n, curr+1) ||\\n                check(board, word, i, j+1, m, n, curr+1) ||\\n                check(board, word, i-1, j, m, n, curr+1) ||\\n                check(board, word, i, j-1, m, n, curr+1);\\n        \\n\\t\\t//unmask masked character\\n        board[i][j] -= 100;\\n            \\n        return exists;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281598,
                "title": "an-in-depth-video-tutorial-for-word-search",
                "content": "An in-depth video tutorial/solution for Word Search leetcode problem : [Word Search](https://youtu.be/iOLyhjDWg2M)\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/iOLyhjDWg2M\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "An in-depth video tutorial/solution for Word Search leetcode problem : [Word Search](https://youtu.be/iOLyhjDWg2M)\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/iOLyhjDWg2M\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3176254,
                "title": "time-85-and-space-98-beats-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int &m,int &n,vector<vector<char>> &board,string &str,int s){\\n        if(s>=str.length()){\\n            return true;\\n        }\\n        if(i<0||j<0||i>=m||j>=n||board[i][j]==\\'#\\'){\\n            return false;\\n        }\\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        bool a = false;\\n        if(c==str[s])\\n        a = solve(i+1,j,m,n,board,str,s+1)||solve(i-1,j,m,n,board,str,s+1)||solve(i,j-1,m,n,board,str,s+1) ||  solve(i,j+1,m,n,board,str,s+1);\\n        board[i][j] = c;\\n        return a;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int i,j,m=board.size(),n=board[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(board[i][j]==word[0] && solve(i,j,m,n,board,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int &m,int &n,vector<vector<char>> &board,string &str,int s){\\n        if(s>=str.length()){\\n            return true;\\n        }\\n        if(i<0||j<0||i>=m||j>=n||board[i][j]==\\'#\\'){\\n            return false;\\n        }\\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        bool a = false;\\n        if(c==str[s])\\n        a = solve(i+1,j,m,n,board,str,s+1)||solve(i-1,j,m,n,board,str,s+1)||solve(i,j-1,m,n,board,str,s+1) ||  solve(i,j+1,m,n,board,str,s+1);\\n        board[i][j] = c;\\n        return a;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int i,j,m=board.size(),n=board[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(board[i][j]==word[0] && solve(i,j,m,n,board,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844777,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        R, C = len(board), len(board[0])\\n        \\n        \\n        def dfs(r, c, ci):\\n            \\n            if ci == len(word):\\n                return True\\n            \\n            if r < 0 or c < 0 or r >= R or c >= C:\\n                return False\\n            \\n            if board[r][c] != word[ci]:\\n                return False\\n            \\n            curr = board[r][c]\\n            board[r][c] = \"#\"\\n            a1 = dfs(r + 1, c, ci + 1)\\n            b1 = dfs(r - 1, c, ci + 1)\\n            c1 = dfs(r, c + 1, ci + 1)\\n            d1 = dfs(r, c - 1, ci + 1)\\n            board[r][c] = curr\\n            \\n            return a1 or b1 or c1 or d1\\n            \\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == word[0] and dfs(r, c, 0):\\n                    return True\\n                \\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        R, C = len(board), len(board[0])\\n        \\n        \\n        def dfs(r, c, ci):\\n            \\n            if ci == len(word):\\n                return True\\n            \\n            if r < 0 or c < 0 or r >= R or c >= C:\\n                return False\\n            \\n            if board[r][c] != word[ci]:\\n                return False\\n            \\n            curr = board[r][c]\\n            board[r][c] = \"#\"\\n            a1 = dfs(r + 1, c, ci + 1)\\n            b1 = dfs(r - 1, c, ci + 1)\\n            c1 = dfs(r, c + 1, ci + 1)\\n            d1 = dfs(r, c - 1, ci + 1)\\n            board[r][c] = curr\\n            \\n            return a1 or b1 or c1 or d1\\n            \\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == word[0] and dfs(r, c, 0):\\n                    return True\\n                \\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844084,
                "title": "c-intutive-dfs-easy-understanding-video-solution",
                "content": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/606RcnDuplY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int i,int j,int count){\\n//          Base case\\n\\n        // Complete traversal of word.\\n        if(count == word.size()){return true;}\\n        //  Return  cases.\\n        if(i<0 || i>=board.size() ||j<0 || j>=board[0].size() || word[count] != board[i][j])\\n\\u2003\\u2003{return false;}\\n\\n//         Make it visited.\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n\\n\\n//         Make traversal\\n\\u2003\\u2003bool isfound = dfs(board,word,i+1,j,count+1) || dfs(board,word,i-1,j,count+1) ||dfs(board,word,i,j+1,count+1)||dfs(board,word,i,j-1,count+1);\\n\\n//         Backtrack.\\n        board[i][j] = temp;\\n\\n        return isfound;\\n\\n\\n    }\\n\\n\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n//\\u2003\\u2003\\u2003if word[0] matches call dfs\\n                if(board[i][j]  == word[0] && dfs(board,word,i,j,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int i,int j,int count){\\n//          Base case\\n\\n        // Complete traversal of word.\\n        if(count == word.size()){return true;}\\n        //  Return  cases.\\n        if(i<0 || i>=board.size() ||j<0 || j>=board[0].size() || word[count] != board[i][j])\\n\\u2003\\u2003{return false;}\\n\\n//         Make it visited.\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n\\n\\n//         Make traversal\\n\\u2003\\u2003bool isfound = dfs(board,word,i+1,j,count+1) || dfs(board,word,i-1,j,count+1) ||dfs(board,word,i,j+1,count+1)||dfs(board,word,i,j-1,count+1);\\n\\n//         Backtrack.\\n        board[i][j] = temp;\\n\\n        return isfound;\\n\\n\\n    }\\n\\n\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n//\\u2003\\u2003\\u2003if word[0] matches call dfs\\n                if(board[i][j]  == word[0] && dfs(board,word,i,j,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843615,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size(), n = board[0].size();\\n        int index = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == word[index])\\n                {\\n                    if(search(i, j, index, board, word))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(int i, int j, int index, vector<vector<char>>& board, string& word)\\n    {\\n        int m = board.size(), n = board[0].size();\\n        \\n        if(index == word.size()) return true;\\n        if(i < 0 or j < 0 or i >= m or j >= n) return false;\\n        \\n        bool all = false;\\n        if(word[index] == board[i][j])\\n        {\\n            char temp = word[index];\\n            board[i][j] = \\'#\\';\\n            all = search(i+1, j, index+1, board, word) or search(i-1, j, index+1, board, word) or \\n                search(i, j+1, index+1, board, word) or search(i, j-1, index+1, board, word);\\n            \\n            board[i][j] = temp;\\n        }\\n        \\n        return all;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size(), n = board[0].size();\\n        int index = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == word[index])\\n                {\\n                    if(search(i, j, index, board, word))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(int i, int j, int index, vector<vector<char>>& board, string& word)\\n    {\\n        int m = board.size(), n = board[0].size();\\n        \\n        if(index == word.size()) return true;\\n        if(i < 0 or j < 0 or i >= m or j >= n) return false;\\n        \\n        bool all = false;\\n        if(word[index] == board[i][j])\\n        {\\n            char temp = word[index];\\n            board[i][j] = \\'#\\';\\n            all = search(i+1, j, index+1, board, word) or search(i-1, j, index+1, board, word) or \\n                search(i, j+1, index+1, board, word) or search(i, j-1, index+1, board, word);\\n            \\n            board[i][j] = temp;\\n        }\\n        \\n        return all;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838651,
                "title": "c-backtracking-with-time-complexity-explanation",
                "content": "<a name=a1></a>\\n### Approach-1, Backtracking\\n#### Logic\\n```c++\\n- Start from board[0][0]\\n- if(board[i][j] == word[0])\\n        -> Compare neighbours (left,right,top,bottom)\\n        -> Keep on comparing neighbours until\\n                - Find a mis-match\\n                - OR word ends\\n        -> if alphabets keep matching replace with \\'#\\'\\n           so that it should not be retravelled.\\n```\\n- **Backtrack Tree**\\n```c\\nA B C E A B\\t\\t//Search:ABCCED\\nS F C S B C\\nA D E E R Z\\n\\t\\t\\t\\t\\t\\t[]\\n\\t\\t\\t\\t-------------------------------------------\\n\\t\\t\\t\\t|\\t\\t\\t|\\t\\t\\n\\t\\t\\t\\tA(0,0)\\t\\t\\tA(0,4)\\n\\t\\t\\t------------------\\t\\t----------------\\n\\t\\t\\t|\\t|\\t\\t\\t|\\t\\t|\\n\\t\\t\\tAB\\tAS\\t\\t\\tAB(1,4)\\t\\tAB\\n\\t\\t\\t|\\t(stop)\\t\\t\\t|\\n  \\t\\t-------------------------\\t\\t-----------------\\n  \\t\\t|     |\\t\\t\\t\\t\\t|\\t|\\t|\\n \\t\\tABC\\tABF\\t\\t\\t\\tABS\\tABR\\tABC\\n  \\t\\t|\\t(stop)\\n\\t-------------------\\n\\t|\\t   |\\t   |\\n\\tABCE\\t  ABCC\\t   \\n\\t(stop)\\t   |\\n\\t --------------------------------\\n\\t |\\t\\t|\\t\\t|\\n\\t ABCCS\\t\\tABCCF\\t\\tABCCE\\t\\t//At any level 3 directions can be traversed.\\n\\t (stop)\\t\\t(stop)\\t\\t|\\n\\t \\t\\t\\t-----------------------------\\n\\t\\t\\t\\t|\\t\\t|\\n\\t\\t\\t\\tABCCEE\\t\\tABCCED\\n\\t\\t\\t\\t(stop)\\t\\t(found)\\n```\\n ### Code\\n ```cpp\\n#include<iostream>\\n#include<string>\\n#include<vector>\\nusing namespace std;\\nusing VecC = vector<char>;\\nusing VecVecC = vector<VecC>;\\nusing VecC = vector<char>;\\nusing vecVecC = vector<VecC>;\\n\\nclass Solution {\\n        int maxRows, maxCols;\\n        string target;\\npublic:\\n    bool recursive_backtrack(int row, int col, vecVecC& board, int presentIndex) {\\n    \\n        /// Base cases\\n        if (presentIndex >= target.size())\\n            return true;\\n\\n        /// Character does not match\\n        if (board[row][col] != target[presentIndex])\\n            return false;\\n        \\n        //Iterate thru all directions\\n        /*\\n                    N(r-1,c)(-1,0)\\n        (0,-1)E(r,c-1)   rc      W(r,c+1)(0,1)\\n                    S(r+1,c)(1,0)\\n        */\\n        bool ret = false;\\n        \\n        int ch = board[row][col];\\n        board[row][col] = \\'#\\';\\n\\t\\t\\n        int dRow[] = {-1,0,0,1};\\n        int dCol[] = {0,-1,1,0};\\n        for (int i=0; i<4; ++i) {\\n            int nextRow = row + dRow[i];\\n            int nextCol = col + dCol[i];\\n            \\n            if (nextRow >= maxRows || nextCol >= maxCols || nextRow < 0 || nextCol < 0)\\n                    continue;\\n        \\n            /// Break only when matching character is found\\n            /// Donot break if after going on path we donot find match\\n            ret = recursive_backtrack(nextRow, nextCol, board, presentIndex+1);\\n            if (ret)\\n                break;\\n        }\\n\\n        /// Place character on board again\\n        /// This is same as Removing last element from candidate list\\n        board[row][col] = ch;\\n        return ret;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        maxRows = board.size();\\n        maxCols = board[0].size();\\n        target = word;\\n        int presentIndex = 0;   //This is index of character in target word to be searched\\n        \\n        /// if board has 1 alphabet and word also has 1\\n        if(maxRows == 1 && maxCols == 1 && target.size() == 1 && board[0][0] == target[0])\\n                return true;\\n\\n        /// Iterate thru every character on board\\n        for (int i=0; i < maxRows; ++i) {\\n            for (int j=0; j < maxCols; ++j) {\\n                if (board[i][j] == target[presentIndex]) {\\n                        if (recursive_backtrack(i, j, board, presentIndex))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n#### [Complexity Analysis for Backtracking](https://github.com/amitkumar50/Code-examples/blob/master/DS_Questions/Algorithms/Backtracking/README.md#t)\\n- **Time:** O(N x 3<sup>L</sup>)\\n  - Look at backtrack Tree above. At any level 3 children are allowed, since we cannot traverse back to path from where we came. if levels=L. Complexity = 3<sup>L</sup>\\n  - N=Number of letters in grid. From Every letter there can be a path to target word.\\n- **Space:** \\n  - O(k) where k is the length of the word to be matched.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\n- Start from board[0][0]\\n- if(board[i][j] == word[0])\\n        -> Compare neighbours (left,right,top,bottom)\\n        -> Keep on comparing neighbours until\\n                - Find a mis-match\\n                - OR word ends\\n        -> if alphabets keep matching replace with \\'#\\'\\n           so that it should not be retravelled.\\n```\n```c\\nA B C E A B\\t\\t//Search:ABCCED\\nS F C S B C\\nA D E E R Z\\n\\t\\t\\t\\t\\t\\t[]\\n\\t\\t\\t\\t-------------------------------------------\\n\\t\\t\\t\\t|\\t\\t\\t|\\t\\t\\n\\t\\t\\t\\tA(0,0)\\t\\t\\tA(0,4)\\n\\t\\t\\t------------------\\t\\t----------------\\n\\t\\t\\t|\\t|\\t\\t\\t|\\t\\t|\\n\\t\\t\\tAB\\tAS\\t\\t\\tAB(1,4)\\t\\tAB\\n\\t\\t\\t|\\t(stop)\\t\\t\\t|\\n  \\t\\t-------------------------\\t\\t-----------------\\n  \\t\\t|     |\\t\\t\\t\\t\\t|\\t|\\t|\\n \\t\\tABC\\tABF\\t\\t\\t\\tABS\\tABR\\tABC\\n  \\t\\t|\\t(stop)\\n\\t-------------------\\n\\t|\\t   |\\t   |\\n\\tABCE\\t  ABCC\\t   \\n\\t(stop)\\t   |\\n\\t --------------------------------\\n\\t |\\t\\t|\\t\\t|\\n\\t ABCCS\\t\\tABCCF\\t\\tABCCE\\t\\t//At any level 3 directions can be traversed.\\n\\t (stop)\\t\\t(stop)\\t\\t|\\n\\t \\t\\t\\t-----------------------------\\n\\t\\t\\t\\t|\\t\\t|\\n\\t\\t\\t\\tABCCEE\\t\\tABCCED\\n\\t\\t\\t\\t(stop)\\t\\t(found)\\n```\n```cpp\\n#include<iostream>\\n#include<string>\\n#include<vector>\\nusing namespace std;\\nusing VecC = vector<char>;\\nusing VecVecC = vector<VecC>;\\nusing VecC = vector<char>;\\nusing vecVecC = vector<VecC>;\\n\\nclass Solution {\\n        int maxRows, maxCols;\\n        string target;\\npublic:\\n    bool recursive_backtrack(int row, int col, vecVecC& board, int presentIndex) {\\n    \\n        /// Base cases\\n        if (presentIndex >= target.size())\\n            return true;\\n\\n        /// Character does not match\\n        if (board[row][col] != target[presentIndex])\\n            return false;\\n        \\n        //Iterate thru all directions\\n        /*\\n                    N(r-1,c)(-1,0)\\n        (0,-1)E(r,c-1)   rc      W(r,c+1)(0,1)\\n                    S(r+1,c)(1,0)\\n        */\\n        bool ret = false;\\n        \\n        int ch = board[row][col];\\n        board[row][col] = \\'#\\';\\n\\t\\t\\n        int dRow[] = {-1,0,0,1};\\n        int dCol[] = {0,-1,1,0};\\n        for (int i=0; i<4; ++i) {\\n            int nextRow = row + dRow[i];\\n            int nextCol = col + dCol[i];\\n            \\n            if (nextRow >= maxRows || nextCol >= maxCols || nextRow < 0 || nextCol < 0)\\n                    continue;\\n        \\n            /// Break only when matching character is found\\n            /// Donot break if after going on path we donot find match\\n            ret = recursive_backtrack(nextRow, nextCol, board, presentIndex+1);\\n            if (ret)\\n                break;\\n        }\\n\\n        /// Place character on board again\\n        /// This is same as Removing last element from candidate list\\n        board[row][col] = ch;\\n        return ret;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        maxRows = board.size();\\n        maxCols = board[0].size();\\n        target = word;\\n        int presentIndex = 0;   //This is index of character in target word to be searched\\n        \\n        /// if board has 1 alphabet and word also has 1\\n        if(maxRows == 1 && maxCols == 1 && target.size() == 1 && board[0][0] == target[0])\\n                return true;\\n\\n        /// Iterate thru every character on board\\n        for (int i=0; i < maxRows; ++i) {\\n            for (int j=0; j < maxCols; ++j) {\\n                if (board[i][j] == target[presentIndex]) {\\n                        if (recursive_backtrack(i, j, board, presentIndex))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2779254,
                "title": "python-intuitive-dfs-solution",
                "content": "```\\nfrom collections import deque, Counter\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(row, col, i):\\n            if i == len(word):\\n                return True\\n            original, board[row][col] = board[row][col], \\'#\\'\\n            spreaded = False\\n            for dy, dx in ((1, 0), (-1,0), (0, 1), (0, -1)):\\n                nr, nc = row + dy, col + dx\\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] == word[i] and dfs(nr, nc, i+1):\\n                    spreaded = True\\n                    break\\n            board[row][col] = original\\n            return spreaded\\n                                \\n                    \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0] and dfs(i, j, 1):\\n                        return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, Counter\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(row, col, i):\\n            if i == len(word):\\n                return True\\n            original, board[row][col] = board[row][col], \\'#\\'\\n            spreaded = False\\n            for dy, dx in ((1, 0), (-1,0), (0, 1), (0, -1)):\\n                nr, nc = row + dy, col + dx\\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] == word[i] and dfs(nr, nc, i+1):\\n                    spreaded = True\\n                    break\\n            board[row][col] = original\\n            return spreaded\\n                                \\n                    \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0] and dfs(i, j, 1):\\n                        return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564941,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565218,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1575694,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1809106,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1804756,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565829,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566547,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1572297,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566820,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1576664,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1564941,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565218,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1575694,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1809106,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1804756,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565829,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566547,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1572297,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566820,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1576664,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565426,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1568484,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1568483,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1568063,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1567187,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1783736,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1694965,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1576320,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1575038,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1574421,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1876348,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1576383,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1576238,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1573681,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1569283,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568899,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568900,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568901,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568902,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 2035547,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 2034059,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 2018376,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 2007044,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1845454,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1811825,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1795858,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1788965,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1694967,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1672474,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1576276,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1574086,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1573547,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1573281,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571849,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571183,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571184,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571185,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571186,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571880,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 2058630,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 2046552,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2042347,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2026877,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2014112,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2001553,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1999399,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1994483,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1989782,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1986354,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1985849,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1967439,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1965816,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1964607,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1951506,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1935422,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1929276,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1914068,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1910606,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1905517,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1893767,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1877860,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1873785,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1871913,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1858909,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1846172,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1837842,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1832796,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1810962,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1802218,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1795182,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1793344,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1780978,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1754134,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1749991,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1719807,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1716975,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1705157,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1703370,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1695221,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1695168,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            }
        ]
    }
]