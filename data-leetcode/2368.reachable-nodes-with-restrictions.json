[
    {
        "title": "Reachable Nodes With Restrictions",
        "question_content": "There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.\nReturn the maximum number of nodes you can reach from node 0 without visiting a restricted node.\nNote that node 0 will not be a restricted node.\n&nbsp;\nExample 1:\n\nInput: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\nOutput: 4\nExplanation: The diagram above shows the tree.\nWe have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\nExample 2:\n\nInput: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\nOutput: 3\nExplanation: The diagram above shows the tree.\nWe have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 105\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tedges represents a valid tree.\n\t1 <= restricted.length < n\n\t1 <= restricted[i] < n\n\tAll the values of restricted are unique.",
        "solutions": [
            {
                "id": 2390929,
                "title": "c-simple-dfs-detailed-explaination-marking-restricted-nodes-as-visited-before-dfs",
                "content": "```\\n/*\\nintution -\\nwe can mark restricted nodes as visited , then we can start dfs with 0 as source, and whenever we reach a new node while performing dfs, we increment out count by 1. after performing dfs, this count will give us maximum number of nodes we can reach from node 0 without visiting a restricted node.\\nIn this dfs, we would automatically not visit the restricted nodes, as they would have been already marked visited before performing dfs\\n*/\\nclass Solution\\n{\\npublic:\\n    void dfs(int u, vector<int> adj[], int &cnt, vector<bool> &vis)\\n    {\\n        vis[u] = true;\\n        // if we reach a new node, while performing dfs, we increase our count by 1\\n        cnt++; \\n        for (auto v : adj[u])\\n        {\\n            if (vis[v] == false)\\n            {\\n                dfs(v, adj, cnt, vis);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted)\\n    {\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n]; // adjency list\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for (auto a : restricted)\\n        {\\n            visited[a] = true; // marking the restricted nodes  as visited.\\n        }\\n        int count = 0;\\n        dfs(0, adj, count, visited);\\n        return count;\\n    }\\n};\\n```\\nPlease upvote if helpful :)",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\nintution -\\nwe can mark restricted nodes as visited , then we can start dfs with 0 as source, and whenever we reach a new node while performing dfs, we increment out count by 1. after performing dfs, this count will give us maximum number of nodes we can reach from node 0 without visiting a restricted node.\\nIn this dfs, we would automatically not visit the restricted nodes, as they would have been already marked visited before performing dfs\\n*/\\nclass Solution\\n{\\npublic:\\n    void dfs(int u, vector<int> adj[], int &cnt, vector<bool> &vis)\\n    {\\n        vis[u] = true;\\n        // if we reach a new node, while performing dfs, we increase our count by 1\\n        cnt++; \\n        for (auto v : adj[u])\\n        {\\n            if (vis[v] == false)\\n            {\\n                dfs(v, adj, cnt, vis);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted)\\n    {\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n]; // adjency list\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for (auto a : restricted)\\n        {\\n            visited[a] = true; // marking the restricted nodes  as visited.\\n        }\\n        int count = 0;\\n        dfs(0, adj, count, visited);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390579,
                "title": "dfs",
                "content": "When populating adjacency list, we ignore edges from and to restricted nodes.\\n\\nThen, it\\'s just a DFS on a tree.\\n\\n**C++**\\n```cpp\\nint dfs(int i, int from, vector<vector<int>> &al) {\\n    return accumulate(begin(al[i]), end(al[i]), 1, [&](int s, int j){ \\n        return s + (j == from ? 0 : dfs(j, i, al));\\n    });\\n}\\nint reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n    vector<vector<int>> al(n);\\n    unordered_set<int> rs(begin(restricted), end(restricted));      \\n    for (auto &e : edges)\\n        if (rs.count(e[0]) + rs.count(e[1]) == 0) {\\n            al[e[0]].push_back(e[1]);\\n            al[e[1]].push_back(e[0]);\\n        }\\n    return dfs(0, 0, al);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(int i, int from, vector<vector<int>> &al) {\\n    return accumulate(begin(al[i]), end(al[i]), 1, [&](int s, int j){ \\n        return s + (j == from ? 0 : dfs(j, i, al));\\n    });\\n}\\nint reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n    vector<vector<int>> al(n);\\n    unordered_set<int> rs(begin(restricted), end(restricted));      \\n    for (auto &e : edges)\\n        if (rs.count(e[0]) + rs.count(e[1]) == 0) {\\n            al[e[0]].push_back(e[1]);\\n            al[e[1]].push_back(e[0]);\\n        }\\n    return dfs(0, 0, al);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390445,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        List<Integer>[] al = new ArrayList[n];\\n        for(int i=0;i<n;i++) al[i] = new ArrayList<>();\\n        for(int e[] : edges){\\n            al[e[0]].add(e[1]); al[e[1]].add(e[0]);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : restricted) set.add(i);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);  set.add(0);\\n        int ans = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                ans++;\\n                int curr = q.remove();\\n                for(int next : al[curr]) \\n                    if(set.add(next)) q.add(next);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nNo need for explanation right ? If any do let me know.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        List<Integer>[] al = new ArrayList[n];\\n        for(int i=0;i<n;i++) al[i] = new ArrayList<>();\\n        for(int e[] : edges){\\n            al[e[0]].add(e[1]); al[e[1]].add(e[0]);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : restricted) set.add(i);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);  set.add(0);\\n        int ans = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                ans++;\\n                int curr = q.remove();\\n                for(int next : al[curr]) \\n                    if(set.add(next)) q.add(next);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390603,
                "title": "java-python-3-bfs-and-dfs-codes-w-brief-explanation-and-analysis",
                "content": "1. Use a `HashSet` to hold the restricted nodes and then visited nodes; \\n2. Do BFS/DFS to explore the tree, and upon completing exploration the `HashSet` contains all reachable and all restricted nodes. \\n3. We can use the size of the restricted to deduct the size of `HashSet` to get the number of the reachable ones.\\n\\n**BFS**\\n\\n```java\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int r : restricted) {\\n            seen.add(r);\\n        }\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        while (!q.isEmpty()) {\\n            int node = q.poll();\\n            seen.add(node);\\n            for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                if (seen.add(kid)) {\\n                    q.offer(kid);\\n                }\\n            }\\n        }\\n        return seen.size() - restricted.length;\\n    }\\n```\\n**@hj96998** provides the following comments:\\n\\nSome explanation of the BFS python version of codes:\\n\\nPoint #1 : defaultdict\\na sub-class of the dictionary class that returns a dictionary-like object.\\nOne smart thing here is the type is set so that the values have type set. Since we only need to make a map of how nodes connect.\\nPoint #2: deque\\na double-ended queue in which elements can be both inserted and deleted from either the left or the right end of the queue.\\n\\nFollowed by BFS algorithm and return length of visited nodes without restricted nodes\\n\\n\\n```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        seen = set(restricted)\\n        g = defaultdict(set)\\n        for a, b in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n        dq = deque([0])\\n        while dq:\\n            node = dq.popleft()\\n            seen.add(node)\\n            for kid in g[node]:\\n                if kid not in seen:\\n                    seen.add(kid)\\n                    dq.append(kid)\\n        return len(seen) - len(restricted) \\n```\\n\\n----\\n\\n**DFS**\\n\\n```java\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        for (int r : restricted) {\\n            seen.add(r);\\n        }\\n        dfs(g, seen, 0);\\n        return seen.size() - restricted.length;\\n    }\\n    private void dfs(Map<Integer, Set<Integer>> g, Set<Integer> seen, int node) {\\n        if (seen.add(node)) {\\n            for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                dfs(g, seen, kid);\\n            }\\n        }\\n    }\\n```\\n```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        \\n        def dfs(node: int) -> None:\\n            if node not in seen:\\n                seen.add(node)\\n                for kid in g[node]:\\n                    dfs(kid)\\n    \\n        seen = set(restricted)\\n        g = defaultdict(set)\\n        for a, b in edges:\\n            g[a].add(b)\\n            g[b].add(a)        \\n        dfs(0)\\n        return len(seen) - len(restricted)  \\n```\\n\\n**Analysis for both DFS and BFS codes:**\\n\\nTime & space: `O(V + E)`, where `V = # of nodes, E = # of edges`.\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int r : restricted) {\\n            seen.add(r);\\n        }\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        while (!q.isEmpty()) {\\n            int node = q.poll();\\n            seen.add(node);\\n            for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                if (seen.add(kid)) {\\n                    q.offer(kid);\\n                }\\n            }\\n        }\\n        return seen.size() - restricted.length;\\n    }\\n```\n```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        seen = set(restricted)\\n        g = defaultdict(set)\\n        for a, b in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n        dq = deque([0])\\n        while dq:\\n            node = dq.popleft()\\n            seen.add(node)\\n            for kid in g[node]:\\n                if kid not in seen:\\n                    seen.add(kid)\\n                    dq.append(kid)\\n        return len(seen) - len(restricted) \\n```\n```java\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        for (int r : restricted) {\\n            seen.add(r);\\n        }\\n        dfs(g, seen, 0);\\n        return seen.size() - restricted.length;\\n    }\\n    private void dfs(Map<Integer, Set<Integer>> g, Set<Integer> seen, int node) {\\n        if (seen.add(node)) {\\n            for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                dfs(g, seen, kid);\\n            }\\n        }\\n    }\\n```\n```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        \\n        def dfs(node: int) -> None:\\n            if node not in seen:\\n                seen.add(node)\\n                for kid in g[node]:\\n                    dfs(kid)\\n    \\n        seen = set(restricted)\\n        g = defaultdict(set)\\n        for a, b in edges:\\n            g[a].add(b)\\n            g[b].add(a)        \\n        dfs(0)\\n        return len(seen) - len(restricted)  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2390558,
                "title": "bfs-vs-dfs",
                "content": "# BFS  \\nWe simple do **BFS** from `0` in iterative way and while doing bfs we simply discard the restricted nodes.\\nFor check if node is restricted or not , we use `SET`\\n# C++\\n    int reachableNodes(int n, vector<vector<int>>&e , vector<int>& r) {\\n        unordered_set<int> s(begin(r),end(r));\\n        vector<vector<int>> graph(n);\\n        for(auto i:e) graph[i[0]].push_front(i[1]) , graph[i[1]].push_front(i[0]);\\n        queue<int> q;\\n        vector<bool> seen(n);\\n        int cnt=0;\\n        q.push(0);\\n        seen[0]=true;\\n        while(q.size()){\\n            auto node= q.front(); q.pop();\\n            if(s.count(node)) continue;\\n            cnt++;\\n            for(auto j:graph[node]) //Put Neighbours\\n                if(!seen[j]) seen[j]=true , q.push(j);\\n        }\\n        return cnt;\\n    }\\n\\t\\n# DFS\\nSame as BFS , But in # **Functional Programming** #  Way i.e **`Recursion`**\\nIn which we just represent the subtree with a **function** instead of traversing on our own in an iterative manner, like we did in `BFS`.\\n\\n# C++\\n    vector<vector<int>> graph;\\n    int dfs(int src,vector<bool> &seen,unordered_set<int> &s){\\n        int cnt=0;\\n        for(auto j: graph[src])\\n            if(!seen[j] && !s.count(j)) seen[j]=true , cnt+= dfs(j,seen,s); \\n        return 1+cnt;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>&e , vector<int>& r) {\\n        unordered_set<int> s(begin(r),end(r));\\n        graph.resize(n);\\n        for(auto i:e) graph[i[0]].push_back(i[1])  , graph[i[1]].push_back(i[0]);\\n        vector<bool> seen(n);\\n        seen[0]=true;\\n        return dfs(0,seen,s);\\n    }\\n\\t\\n**Time** - O(n+e)\\n**Space** - O(n)",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "# BFS  \\nWe simple do **BFS** from `0` in iterative way and while doing bfs we simply discard the restricted nodes.\\nFor check if node is restricted or not , we use `SET`\\n# C++\\n    int reachableNodes(int n, vector<vector<int>>&e , vector<int>& r) {\\n        unordered_set<int> s(begin(r),end(r));\\n        vector<vector<int>> graph(n);\\n        for(auto i:e) graph[i[0]].push_front(i[1]) , graph[i[1]].push_front(i[0]);\\n        queue<int> q;\\n        vector<bool> seen(n);\\n        int cnt=0;\\n        q.push(0);\\n        seen[0]=true;\\n        while(q.size()){\\n            auto node= q.front(); q.pop();\\n            if(s.count(node)) continue;\\n            cnt++;\\n            for(auto j:graph[node]) //Put Neighbours\\n                if(!seen[j]) seen[j]=true , q.push(j);\\n        }\\n        return cnt;\\n    }\\n\\t\\n# DFS\\nSame as BFS , But in # **Functional Programming** #  Way i.e **`Recursion`**\\nIn which we just represent the subtree with a **function** instead of traversing on our own in an iterative manner, like we did in `BFS`.\\n\\n# C++\\n    vector<vector<int>> graph;\\n    int dfs(int src,vector<bool> &seen,unordered_set<int> &s){\\n        int cnt=0;\\n        for(auto j: graph[src])\\n            if(!seen[j] && !s.count(j)) seen[j]=true , cnt+= dfs(j,seen,s); \\n        return 1+cnt;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>&e , vector<int>& r) {\\n        unordered_set<int> s(begin(r),end(r));\\n        graph.resize(n);\\n        for(auto i:e) graph[i[0]].push_back(i[1])  , graph[i[1]].push_back(i[0]);\\n        vector<bool> seen(n);\\n        seen[0]=true;\\n        return dfs(0,seen,s);\\n    }\\n\\t\\n**Time** - O(n+e)\\n**Space** - O(n)",
                "codeTag": "Unknown"
            },
            {
                "id": 2390476,
                "title": "dfs-c",
                "content": "\\t// Mark all restricted nodes as visited and run dfs from 0\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dfs(int node,vector<int>&vis,vector<int>adj[]){\\n\\t\\t\\tif(vis[node]) return 0;\\n\\t\\t\\tvis[node] = 1;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(auto edge:adj[node]) if(!vis[edge]) res+=dfs(edge,vis,adj);\\n\\t\\t\\t\\treturn res+1;\\n\\t\\t}\\n\\n\\t\\tint reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n\\t\\t\\tvector<int>vis(n,0);\\n\\t\\t\\tfor(auto x:restricted) vis[x] = 1;\\n\\t\\t\\tvector<int>adj[n];\\n\\t\\t\\tfor(auto node:edges) adj[node[0]].push_back(node[1]),adj[node[1]].push_back(node[0]);\\n\\t\\t\\treturn dfs(0,vis,adj);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dfs(int node,vector<int>&vis,vector<int>adj[]){\\n\\t\\t\\tif(vis[node]) return 0;\\n\\t\\t\\tvis[node] = 1;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(auto edge:adj[node]) if(!vis[edge]) res+=dfs(edge,vis,adj);\\n\\t\\t\\t\\treturn res+1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2397086,
                "title": "easiest-code-dfs-traversal-explained",
                "content": "## **Easiest Code Just Do A DFS Traversal With Condition Of Restricted Node.**\\n- During Traversal We Check If Current Node Is Not In Restricted Vector Then An Only Run DFS.\\n- And Other Code Is Simple DFS Of Graph.\\n- restricted2 Is A Vector For Checking The Current Element Is Present In Main restricted Array Or Not, It Is A Vector For Storing Element Of restricted Vector Indexwise.\\n\\n\\n\\n```\\nconst int N = 1e5+10;\\nclass Solution {\\npublic:\\n    int count1 = 1;\\n    vector<int> t[N];\\n    bool vis[N];\\n\\t\\n    void dfs(int node, vector<int> &restricted, vector<int> &restricted2){\\n    vis[node] = true;\\n    for (int i = 0; i < t[node].size(); ++i)\\n    {\\n        if (!vis[t[node][i]])\\n        {\\n            if(!restricted2[t[node][i]])\\n            {\\n                count1++;\\n                dfs(t[node][i],restricted,restricted2);\\n            }\\n        }\\n    }\\n}\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> restricted2(100010);    \\n        for(int i=0; i<edges.size(); i++){\\n            t[edges[i][0]].push_back(edges[i][1]);\\n            t[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for (int i = 0; i < restricted.size(); ++i){\\n            restricted2[restricted[i]]++;\\n        }\\n        dfs(0,restricted,restricted2);\\n        return count1;\\n    }\\n};\\n```\\n\\n**Don\\'t Forget To \\uD83D\\uDC96 & \\uD83D\\uDC4D And Also Ask Query Below If You Have.**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nconst int N = 1e5+10;\\nclass Solution {\\npublic:\\n    int count1 = 1;\\n    vector<int> t[N];\\n    bool vis[N];\\n\\t\\n    void dfs(int node, vector<int> &restricted, vector<int> &restricted2){\\n    vis[node] = true;\\n    for (int i = 0; i < t[node].size(); ++i)\\n    {\\n        if (!vis[t[node][i]])\\n        {\\n            if(!restricted2[t[node][i]])\\n            {\\n                count1++;\\n                dfs(t[node][i],restricted,restricted2);\\n            }\\n        }\\n    }\\n}\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> restricted2(100010);    \\n        for(int i=0; i<edges.size(); i++){\\n            t[edges[i][0]].push_back(edges[i][1]);\\n            t[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for (int i = 0; i < restricted.size(); ++i){\\n            restricted2[restricted[i]]++;\\n        }\\n        dfs(0,restricted,restricted2);\\n        return count1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391976,
                "title": "java-dfs",
                "content": "```\\nprivate final Set<Integer> reachableSet = new HashSet<>(List.of(0));\\n\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> restrictedNodes = Arrays.stream(restricted).boxed().collect(Collectors.toSet());\\n        Map<Integer, List<Integer>> nodes = new HashMap<>();\\n\\n        for (int[] edge : edges) {\\n            nodes.computeIfAbsent(edge[0], value -> new ArrayList<>()).add(edge[1]);\\n            nodes.computeIfAbsent(edge[1], value -> new ArrayList<>()).add(edge[0]);\\n        }\\n\\n        dfs(nodes, 0, restrictedNodes, new HashSet<>());\\n        return reachableSet.size();\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> nodes, int current, Set<Integer> restricted, Set<Integer> seen) {\\n        for (int node : nodes.get(current)) {\\n            if (!restricted.contains(node) && !seen.contains(node)) {\\n                reachableSet.add(node);\\n                seen.add(node);\\n                dfs(nodes, node, restricted, seen);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate final Set<Integer> reachableSet = new HashSet<>(List.of(0));\\n\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> restrictedNodes = Arrays.stream(restricted).boxed().collect(Collectors.toSet());\\n        Map<Integer, List<Integer>> nodes = new HashMap<>();\\n\\n        for (int[] edge : edges) {\\n            nodes.computeIfAbsent(edge[0], value -> new ArrayList<>()).add(edge[1]);\\n            nodes.computeIfAbsent(edge[1], value -> new ArrayList<>()).add(edge[0]);\\n        }\\n\\n        dfs(nodes, 0, restrictedNodes, new HashSet<>());\\n        return reachableSet.size();\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> nodes, int current, Set<Integer> restricted, Set<Integer> seen) {\\n        for (int node : nodes.get(current)) {\\n            if (!restricted.contains(node) && !seen.contains(node)) {\\n                reachableSet.add(node);\\n                seen.add(node);\\n                dfs(nodes, node, restricted, seen);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2392429,
                "title": "c-dfs-without-using-set-for-restricted-nodes-explained",
                "content": "The Idea is very simple :\\n**We will not do anything different than normal DFS.**\\n\\n* It has been said that we cannot traverse the nodes given in the restricted array.\\n* It just means that we don\\'t have to visit those restricted nodes.\\n* So we will mark those nodes already visited in visited array. So that we won\\'t traverse them in DFS.\\n* Then we can normally traverse using DFS and keep count of nodes traversed.\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        vector<int> adj[n];\\n        \\n        // A visited array.\\n        vector<int> vis(n,0);\\n        \\n        // Count varable to keep count of traversed nodes.\\n        int cnt = 0;\\n        \\n        // Mark all restricted node as visited.\\n        for(int i=0;i<restricted.size();i++)\\n            vis[restricted[i]] = 1;\\n        \\n        // Make adjency list.\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        // Perform normal DFS starting from 0th node.\\n        dfs(adj, vis, 0, cnt);\\n        \\n        return cnt;\\n        \\n    }\\n    \\n    \\n    void dfs(vector<int> adj[], vector<int> &vis, int node, int &cnt)\\n    {\\n        vis[node] = 1;\\n        cnt++;\\n        \\n        for(auto it : adj[node])\\n        {\\n            if(!vis[it])\\n                dfs(adj, vis, it, cnt);\\n        }\\n    }\\n    \\n};\\n```\\n\\n# Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        vector<int> adj[n];\\n        \\n        // A visited array.\\n        vector<int> vis(n,0);\\n        \\n        // Count varable to keep count of traversed nodes.\\n        int cnt = 0;\\n        \\n        // Mark all restricted node as visited.\\n        for(int i=0;i<restricted.size();i++)\\n            vis[restricted[i]] = 1;\\n        \\n        // Make adjency list.\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        // Perform normal DFS starting from 0th node.\\n        dfs(adj, vis, 0, cnt);\\n        \\n        return cnt;\\n        \\n    }\\n    \\n    \\n    void dfs(vector<int> adj[], vector<int> &vis, int node, int &cnt)\\n    {\\n        vis[node] = 1;\\n        cnt++;\\n        \\n        for(auto it : adj[node])\\n        {\\n            if(!vis[it])\\n                dfs(adj, vis, it, cnt);\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390466,
                "title": "dfs-count-reachable-nodes",
                "content": "\\n    class Solution { \\n    int reach_node=0;\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        //creating the adjacency list\\n        List<List<Integer>> adj=new ArrayList<>();\\n        //creating the visited array to put restricted nodes\\n        boolean vis[]=new boolean[n];\\n        for(int x:restricted){\\n            vis[x]=true;\\n        }\\n        for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n        for(int p[]:edges){\\n            adj.get(p[1]).add(p[0]);\\n            adj.get(p[0]).add(p[1]);\\n        }\\n        //calling dfs from node 0 \\n        dfs(0,adj,vis);\\n            \\n        return reach_node;\\n    }\\n    //making the dfs function\\n    public void dfs(int node,List<List<Integer>> adj,boolean vis[]){\\n        vis[node]=true;\\n        //counting no of nodes which we can visit\\n        reach_node++;\\n        //going through the adjacency list and checking which node is unvisited\\n        for(int it:adj.get(node)){\\n            if(!vis[it]){\\n                dfs(it,adj,vis);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution { \\n    int reach_node=0;\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        //creating the adjacency list\\n        List<List<Integer>> adj=new ArrayList<>();\\n        //creating the visited array to put restricted nodes\\n        boolean vis[]=new boolean[n];\\n        for(int x:restricted){\\n            vis[x]=true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2390464,
                "title": "simple-bfs-easy-to-understand-c",
                "content": "First of all, build a graph out of the given edges.\\nWe are given some resticted nodes, so I\\'ve created a set  and pushed all the restricted nodes into that.\\n\\nThen Check is node  0 is present in that  set or not.\\nIf yes, then you can;t visit any of the nodes: return 0,\\nIf no, then start BFS traversal \\n\\nPush node 0 into queue, then start your BFS  traversal.\\nCreate a visited array and keep track of visited nodes.\\nif you find the neighbour of the node which is niether present in visited array nor present in restricted set  , then simply push that node into the queue and mark it as visited.\\n\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        set<int>stk;\\n        for(auto ele:restricted) stk.insert(ele);\\n        \\n        if(stk.count(0))return 0;\\n        queue<int>q;\\n        vector<int>vis(n,0);\\n        \\n        q.push(0);\\n        vis[0]=1;\\n        \\n        int cnt=0;\\n        while(q.size()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            \\n            \\n            for(auto ele:adj[node]){\\n                if(vis[ele]==0 and stk.count(ele)==0){\\n                    q.push(ele);\\n                    vis[ele]=1;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Hope this helps**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        set<int>stk;\\n        for(auto ele:restricted) stk.insert(ele);\\n        \\n        if(stk.count(0))return 0;\\n        queue<int>q;\\n        vector<int>vis(n,0);\\n        \\n        q.push(0);\\n        vis[0]=1;\\n        \\n        int cnt=0;\\n        while(q.size()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            \\n            \\n            for(auto ele:adj[node]){\\n                if(vis[ele]==0 and stk.count(ele)==0){\\n                    q.push(ele);\\n                    vis[ele]=1;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391194,
                "title": "python-simple-dfs",
                "content": "Ignore edges that have a node from the restricted list.\\n\\nThen we run a simple DFS and count how many nodes we can reach.\\n\\nWe start the DFS from node 0, so disconnected components won\\'t be reached. We can form a disconnected component between nodes after the restricted nodes.\\n\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        res = set(restricted)\\n        graph = defaultdict(list)\\n        vis = set()\\n        \\n        for u, v in edges:\\n            if u in res or v in res: continue\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def dfs(node):\\n            r = 1\\n            for nei in graph[node]:\\n                if nei in vis: continue\\n                vis.add(nei)\\n                r += dfs(nei)\\n            return r\\n        \\n        vis.add(0)\\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        res = set(restricted)\\n        graph = defaultdict(list)\\n        vis = set()\\n        \\n        for u, v in edges:\\n            if u in res or v in res: continue\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def dfs(node):\\n            r = 1\\n            for nei in graph[node]:\\n                if nei in vis: continue\\n                vis.add(nei)\\n                r += dfs(nei)\\n            return r\\n        \\n        vis.add(0)\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390913,
                "title": "python-bfs-get-tle-why-solved",
                "content": "My submission here: https://leetcode.com/submissions/detail/767252194/\\n\\nit only passed 60/62 test cases.\\nThe 61st test case get time limit exceeded.\\nDoes anyone can suggest me to improve my solution? million thanks!\\n\\n```python\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        # ignore restricted node\\n        # bfs from 0\\n        \\n        # O(E), EDITED: the time complexity here is wrong, plz see my comment\\n        adj_dict = collections.defaultdict(list)\\n        for u, v in edges:\\n            if u in restricted or v in restricted:  # EDITED: not O(1)\\n                continue\\n            adj_dict[u].append(v)\\n            adj_dict[v].append(u)\\n        \\n        # O(V + E)\\n        queue = collections.deque([0])\\n        visited = {0}\\n        while queue:\\n            cur = queue.popleft()\\n            for neighbor in adj_dict[cur]:\\n                if neighbor in visited:\\n                    continue\\n                visited.add(neighbor)\\n                queue.append(neighbor)\\n\\n        return len(visited)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        # ignore restricted node\\n        # bfs from 0\\n        \\n        # O(E), EDITED: the time complexity here is wrong, plz see my comment\\n        adj_dict = collections.defaultdict(list)\\n        for u, v in edges:\\n            if u in restricted or v in restricted:  # EDITED: not O(1)\\n                continue\\n            adj_dict[u].append(v)\\n            adj_dict[v].append(u)\\n        \\n        # O(V + E)\\n        queue = collections.deque([0])\\n        visited = {0}\\n        while queue:\\n            cur = queue.popleft()\\n            for neighbor in adj_dict[cur]:\\n                if neighbor in visited:\\n                    continue\\n                visited.add(neighbor)\\n                queue.append(neighbor)\\n\\n        return len(visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390695,
                "title": "dfs-simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],int uu,vector<int>&res,vector <int>&vis){\\n        vis[uu]=1;\\n        int count=1;\\n        for(auto nn:adj[uu]){\\n            if(res[nn]==1){\\n                continue;\\n            }\\n            \\n            if(vis[nn]==-1){\\n                count+=dfs(adj,nn,res,vis);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector <int> adj[n];\\n        vector <int> vis(n,-1);\\n   \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector <int> res(n,0);\\n        for(int i=0;i<restricted.size();i++){\\n            res[restricted[i]]=1;\\n        }\\n        return dfs(adj,0,res,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],int uu,vector<int>&res,vector <int>&vis){\\n        vis[uu]=1;\\n        int count=1;\\n        for(auto nn:adj[uu]){\\n            if(res[nn]==1){\\n                continue;\\n            }\\n            \\n            if(vis[nn]==-1){\\n                count+=dfs(adj,nn,res,vis);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector <int> adj[n];\\n        vector <int> vis(n,-1);\\n   \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector <int> res(n,0);\\n        for(int i=0;i<restricted.size();i++){\\n            res[restricted[i]]=1;\\n        }\\n        return dfs(adj,0,res,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395280,
                "title": "python-graph-unionfind-easy-approach",
                "content": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        \\n        restrictedSet = set(restricted)\\n        uf = UnionFindSet(n)\\n        for edge in edges:\\n            if edge[0] in restrictedSet or edge[1] in restrictedSet:\\n                continue\\n            else:\\n                uf.union(edge[0], edge[1])\\n\\n        ans = 1\\n        rootNode = uf.find(0)\\n        for i in range(1, n):\\n            if uf.find(i) == rootNode:\\n                ans += 1\\n        return ans\\n\\nclass UnionFindSet:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\\n        # The initial \"rank\" of each vertex is 1, because each of them is\\n        # a standalone vertex with no connection to other vertices.\\n        self.rank = [1] * size\\n\\n    # The find function here is the same as that in the disjoint set with path compression.\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    # The union function with union by rank\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        \\n        restrictedSet = set(restricted)\\n        uf = UnionFindSet(n)\\n        for edge in edges:\\n            if edge[0] in restrictedSet or edge[1] in restrictedSet:\\n                continue\\n            else:\\n                uf.union(edge[0], edge[1])\\n\\n        ans = 1\\n        rootNode = uf.find(0)\\n        for i in range(1, n):\\n            if uf.find(i) == rootNode:\\n                ans += 1\\n        return ans\\n\\nclass UnionFindSet:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\\n        # The initial \"rank\" of each vertex is 1, because each of them is\\n        # a standalone vertex with no connection to other vertices.\\n        self.rank = [1] * size\\n\\n    # The find function here is the same as that in the disjoint set with path compression.\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    # The union function with union by rank\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392624,
                "title": "2368-reachable-nodes-with-restrictions",
                "content": "**Simple dfs only thing is restricted nodes should not be traversed so one of the solution is to make these nodes visited already so they will not be traversed during dfs ....Now do the dfs and mantain a count on each recursive call  then return that count and u r good**\\n\\n```\\n void dfs(int n,vector<int>adj[],vector<int>&vis,int &c){\\n        vis[n]=1;\\n        c++;\\n      for(auto it:adj[n]){\\n          if(!vis[it] ){\\n              dfs(it,adj,vis,c);\\n          }\\n      }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<int>vis(n,0);\\n        int c=0;\\n        vector<int>v[n];\\n        for(int i=0;i<res.size();i++){\\n            vis[res[i]]++;\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            \\n                v[edges[i][0]].push_back(edges[i][1]);\\n                v[edges[i][1]].push_back(edges[i][0]);\\n            \\n         }\\n        \\n        dfs(0,v,vis,c);\\n        return c;\\n    }\\n```\\n\\t",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n void dfs(int n,vector<int>adj[],vector<int>&vis,int &c){\\n        vis[n]=1;\\n        c++;\\n      for(auto it:adj[n]){\\n          if(!vis[it] ){\\n              dfs(it,adj,vis,c);\\n          }\\n      }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<int>vis(n,0);\\n        int c=0;\\n        vector<int>v[n];\\n        for(int i=0;i<res.size();i++){\\n            vis[res[i]]++;\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            \\n                v[edges[i][0]].push_back(edges[i][1]);\\n                v[edges[i][1]].push_back(edges[i][0]);\\n            \\n         }\\n        \\n        dfs(0,v,vis,c);\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391260,
                "title": "c-dfs-easy-explanation",
                "content": "We use a similar concept of dfs keeping a visited array.\\n\\nHere as we\\'ve restricted nodes and we can\\'t go to these nodes, hence we keep a visited array and make all these nodes visited in the array, then our recursive dfs won\\'t be traversing through these nodes.\\n\\nRest is all simple DFS traversal of the tree and counting the number of nodes we\\'re going to.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, int& ans, vector<int>& vis, vector<int> adj[]) {\\n        vis[node] = 1;\\n        ans++;\\n        for(auto it: adj[node]) {\\n            if(vis[it] != 1)\\n                dfs(it, ans, vis, adj);\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n+1];\\n        for(int i = 0; i < n - 1; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n+1, 0);\\n        for(int i = 0; i < restricted.size(); i++) {\\n            vis[restricted[i]] = 1;\\n        }\\n        dfs(0, ans, vis, adj);\\n        return ans;\\n    }\\n};\\n```\\n\\nDo upvote if you like the explanation.\\nThank You, Happy Coding.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, int& ans, vector<int>& vis, vector<int> adj[]) {\\n        vis[node] = 1;\\n        ans++;\\n        for(auto it: adj[node]) {\\n            if(vis[it] != 1)\\n                dfs(it, ans, vis, adj);\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n+1];\\n        for(int i = 0; i < n - 1; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n+1, 0);\\n        for(int i = 0; i < restricted.size(); i++) {\\n            vis[restricted[i]] = 1;\\n        }\\n        dfs(0, ans, vis, adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654602,
                "title": "dfs-c",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    void dfs(int u, vector<int> adj[], int &cnt, vector<bool> &vis)\\n    {\\n        vis[u] = true;\\n        cnt++; \\n        for (auto v : adj[u])\\n        {\\n            if (vis[v] == false)\\n            {\\n                dfs(v, adj, cnt, vis);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted)\\n    {\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n];\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for (auto a : restricted)\\n        {\\n            visited[a] = true; \\n        }\\n        int count = 0;\\n        dfs(0, adj, count, visited);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void dfs(int u, vector<int> adj[], int &cnt, vector<bool> &vis)\\n    {\\n        vis[u] = true;\\n        cnt++; \\n        for (auto v : adj[u])\\n        {\\n            if (vis[v] == false)\\n            {\\n                dfs(v, adj, cnt, vis);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted)\\n    {\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n];\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for (auto a : restricted)\\n        {\\n            visited[a] = true; \\n        }\\n        int count = 0;\\n        dfs(0, adj, count, visited);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395115,
                "title": "c-dfs-commented-readable",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], int& ans, vector<bool>& vis){\\n        vis[node] = true;\\n\\n//         adding 1 to our answer with every visited node\\n        ans++;\\n\\n//         going for the dfs traversal for its adjacent unvisited nodes\\n        for(auto n: adj[node]){\\n            if(vis[n] == false){\\n                dfs(n, adj, ans, vis);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n];\\n        int ans = 0;\\n        \\n//         creating our adjacency list\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n//         marking all the restricted nodes as visited\\n        for(auto i: restricted){\\n            visited[i] = true;\\n        }\\n        \\n        dfs(0, adj, ans, visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], int& ans, vector<bool>& vis){\\n        vis[node] = true;\\n\\n//         adding 1 to our answer with every visited node\\n        ans++;\\n\\n//         going for the dfs traversal for its adjacent unvisited nodes\\n        for(auto n: adj[node]){\\n            if(vis[n] == false){\\n                dfs(n, adj, ans, vis);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n];\\n        int ans = 0;\\n        \\n//         creating our adjacency list\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n//         marking all the restricted nodes as visited\\n        for(auto i: restricted){\\n            visited[i] = true;\\n        }\\n        \\n        dfs(0, adj, ans, visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393535,
                "title": "reachable-nodes-with-restrictions-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        //Creating a hashmap\\n        HashMap<Integer,List<Integer>> map=new HashMap<Integer,List<Integer>>();\\n        //Creating a hashset\\n        HashSet<Integer> set=new HashSet<Integer>();\\n        int ans=0;\\n        //Adding restricted nodes to the hashset\\n        for(int num:restricted){\\n            set.add(num);\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            //Checking if whether the given edge is among any restricted node, if no adding them to the hashset\\n            if(!set.contains(edges[i][0]) && !set.contains(edges[i][1])){\\n                //if hashmap contains that node already, adding it to the array of reachable nodes from that node\\n                if(map.containsKey(edges[i][0])){\\n                    List<Integer> list=map.get(edges[i][0]);\\n                    list.add(edges[i][1]);\\n                }\\n                //Else creating a new arraylist and add that node to that list and putting it in hashmap\\n                else{\\n                    List<Integer> list=new ArrayList<Integer>();\\n                    list.add(edges[i][1]);\\n                    map.put(edges[i][0],list);\\n                }\\n                //Doing the same thing for second node in pair as it is an undirected graph\\n                if(map.containsKey(edges[i][1])){\\n                    List<Integer> list=map.get(edges[i][1]);\\n                    list.add(edges[i][0]);\\n                }\\n                else{\\n                    List<Integer> list=new ArrayList<Integer>();\\n                    list.add(edges[i][0]);\\n                    map.put(edges[i][1],list);\\n                }\\n                \\n            }\\n        }\\n        //Creating a visited array\\n        int[] visited=new int[n];\\n        //Creating a queue\\n        Queue<Integer> queue=new LinkedList<Integer>();\\n        //Adding initial node 0 to the queue\\n        queue.add(0);\\n        visited[0]=1;\\n        while(!queue.isEmpty()){\\n            int node=queue.poll();\\n            //ans keeps track of number of reachable nodes\\n            ans++;\\n            if(map.containsKey(node)){\\n                //list contains all nodes reachable from the current node\\n                List<Integer> list=map.get(node);\\n                //Traversing over all the nodes in list\\n                for(int num:list){\\n                    //if node not visited then adding it to the queue and marking it as visited\\n                    if(visited[num]!=1){\\n                        queue.add(num);\\n                        visited[num]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        //Creating a hashmap\\n        HashMap<Integer,List<Integer>> map=new HashMap<Integer,List<Integer>>();\\n        //Creating a hashset\\n        HashSet<Integer> set=new HashSet<Integer>();\\n        int ans=0;\\n        //Adding restricted nodes to the hashset\\n        for(int num:restricted){\\n            set.add(num);\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            //Checking if whether the given edge is among any restricted node, if no adding them to the hashset\\n            if(!set.contains(edges[i][0]) && !set.contains(edges[i][1])){\\n                //if hashmap contains that node already, adding it to the array of reachable nodes from that node\\n                if(map.containsKey(edges[i][0])){\\n                    List<Integer> list=map.get(edges[i][0]);\\n                    list.add(edges[i][1]);\\n                }\\n                //Else creating a new arraylist and add that node to that list and putting it in hashmap\\n                else{\\n                    List<Integer> list=new ArrayList<Integer>();\\n                    list.add(edges[i][1]);\\n                    map.put(edges[i][0],list);\\n                }\\n                //Doing the same thing for second node in pair as it is an undirected graph\\n                if(map.containsKey(edges[i][1])){\\n                    List<Integer> list=map.get(edges[i][1]);\\n                    list.add(edges[i][0]);\\n                }\\n                else{\\n                    List<Integer> list=new ArrayList<Integer>();\\n                    list.add(edges[i][0]);\\n                    map.put(edges[i][1],list);\\n                }\\n                \\n            }\\n        }\\n        //Creating a visited array\\n        int[] visited=new int[n];\\n        //Creating a queue\\n        Queue<Integer> queue=new LinkedList<Integer>();\\n        //Adding initial node 0 to the queue\\n        queue.add(0);\\n        visited[0]=1;\\n        while(!queue.isEmpty()){\\n            int node=queue.poll();\\n            //ans keeps track of number of reachable nodes\\n            ans++;\\n            if(map.containsKey(node)){\\n                //list contains all nodes reachable from the current node\\n                List<Integer> list=map.get(node);\\n                //Traversing over all the nodes in list\\n                for(int num:list){\\n                    //if node not visited then adding it to the queue and marking it as visited\\n                    if(visited[num]!=1){\\n                        queue.add(num);\\n                        visited[num]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390734,
                "title": "exclude-restricted-nodes-bfs-c",
                "content": "class Solution {\\npublic:\\n    \\n    int bfs(int s, vector<int> adj[], vector<bool>&vis){\\n        \\n        queue<int>q;\\n        q.push(s);\\n        int ans =0;\\n        \\n        vis[s] = true;\\n        \\n        while(!q.empty()){\\n            \\n            int u = q.front();\\n            q.pop();\\n            \\n            for(auto it: adj[u]){\\n                \\n                if(!vis[it] ){\\n                    \\n                    vis[it] = true;\\n                    ans++;\\n                    q.push(it);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        vector<int>adj[n];\\n        \\n        for(auto &it: edges){\\n            \\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);  \\n        }\\n        vector<bool >vis(n, false);\\n\\t\\t//do not include the restrcted nodes into solution\\n        for(int i =0;i<restricted.size();i++)\\n            vis[restricted[i]] = true;\\n        int res= 0;\\n        res  = bfs(0, adj, vis);\\n        \\n        return res+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int bfs(int s, vector<int> adj[], vector<bool>&vis){\\n        \\n        queue<int>q;\\n        q.push(s);\\n        int ans =0;\\n        \\n        vis[s] = true;\\n        \\n        while(!q.empty()){\\n            \\n            int u = q.front();\\n            q.pop();\\n            \\n            for(auto it: adj[u]){\\n                \\n                if(!vis[it] ){\\n                    \\n                    vis[it] = true;\\n                    ans++;\\n                    q.push(it);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2390470,
                "title": "depth-first-search-c",
                "content": "- Convert given edges to adjacency list.\\n- Create a set of restriction nodes.\\n- Run DFS on root node.\\n- If we find restricted node, do not move forward in DFS.\\n- Else mark the node as visited and increase the count and continue with DFS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    void dfs(unordered_map<int, vector<int>> &G, int &cnt, vector<int> &vis, set<int> &R, int start) {\\n        \\n        for(auto u : G[start]) {\\n            if(R.count(u)) continue;\\n            \\n            if(!vis[u]) {\\n                vis[u] = 1;\\n                cnt++;\\n                dfs(G, cnt, vis, R, u);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        unordered_map<int, vector<int>> G;\\n        set<int> R(restricted.begin(), restricted.end());\\n        \\n        for(auto &e : edges) {\\n            int u = e[0], v = e[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        \\n        int cnt = 0;\\n\\t\\t// Create a visited array to keep track of visited nodes.\\n        vector<int> vis(n, 0);\\n\\n        dfs(G, cnt, vis, R, 0);\\n        \\n        if(cnt == 0) {\\n            return 1;\\n        } else {\\n            return cnt;\\n        }\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    void dfs(unordered_map<int, vector<int>> &G, int &cnt, vector<int> &vis, set<int> &R, int start) {\\n        \\n        for(auto u : G[start]) {\\n            if(R.count(u)) continue;\\n            \\n            if(!vis[u]) {\\n                vis[u] = 1;\\n                cnt++;\\n                dfs(G, cnt, vis, R, u);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        unordered_map<int, vector<int>> G;\\n        set<int> R(restricted.begin(), restricted.end());\\n        \\n        for(auto &e : edges) {\\n            int u = e[0], v = e[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        \\n        int cnt = 0;\\n\\t\\t// Create a visited array to keep track of visited nodes.\\n        vector<int> vis(n, 0);\\n\\n        dfs(G, cnt, vis, R, 0);\\n        \\n        if(cnt == 0) {\\n            return 1;\\n        } else {\\n            return cnt;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390462,
                "title": "c-using-bfs-with-explanation-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up Vote if you like the solution\\n1. Create the graph from the edges\\n2. Stores the restriced nodes in a unordered set, to check for restriceted node in order of O(1)\\n3. Run BFS to each node and avoid restricted node\\n4. Keep counting the visited node\\'s number and return it as answer\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n\\t\\t//store the restriceted node in set for easier access\\n        unordered_set<int> st;\\n        for(auto r: restricted) st.insert(r);\\n\\t\\t\\n\\t\\t//Create Graph\\n\\t\\tvector<vector<int>> g(n);\\n        for(auto e: edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n\\t\\t\\n\\t\\t//Run BFS from 0, as zero is never be a restricted one\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        q.push(0);\\n        vis[0] = 1;\\n        int ans = 0;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans++;\\n            for(auto i: g[node]){\\n\\t\\t\\t\\t//if not visited and not in restricted node set then consider it \\n                if(vis[i] == 0 && st.find(i) == st.end()){\\n                    vis[i] = 1;\\n                    q.push(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n\\t\\t//store the restriceted node in set for easier access\\n        unordered_set<int> st;\\n        for(auto r: restricted) st.insert(r);\\n\\t\\t\\n\\t\\t//Create Graph\\n\\t\\tvector<vector<int>> g(n);\\n        for(auto e: edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n\\t\\t\\n\\t\\t//Run BFS from 0, as zero is never be a restricted one\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        q.push(0);\\n        vis[0] = 1;\\n        int ans = 0;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans++;\\n            for(auto i: g[node]){\\n\\t\\t\\t\\t//if not visited and not in restricted node set then consider it \\n                if(vis[i] == 0 && st.find(i) == st.end()){\\n                    vis[i] = 1;\\n                    q.push(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610960,
                "title": "c-bfs-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        set<int> rest(restricted.begin(),restricted.end());\\n\\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        queue<int> q;\\n        vector<int> vis(n,0);\\n        q.push(0);\\n        vis[0] = 1;\\n        int count = 0;\\n        while(q.size()){\\n            int curr = q.front();\\n            q.pop();\\n            for(auto i : adj[curr]){\\n                if(!vis[i] && !rest.count(i)){\\n                    vis[i] = 1;\\n                    q.push(i);\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        set<int> rest(restricted.begin(),restricted.end());\\n\\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        queue<int> q;\\n        vector<int> vis(n,0);\\n        q.push(0);\\n        vis[0] = 1;\\n        int count = 0;\\n        while(q.size()){\\n            int curr = q.front();\\n            q.pop();\\n            for(auto i : adj[curr]){\\n                if(!vis[i] && !rest.count(i)){\\n                    vis[i] = 1;\\n                    q.push(i);\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418671,
                "title": "dfs-solution-easy-explanation-c-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* The makeAdjList function is used to create an adjacency list representation of the graph from the given edges vector, which contains pairs of nodes representing edges. It iterates through each edge and adds both nodes to each other\\'s adjacency lists, assuming an undirected graph.\\n\\n* The dfs function implements a depth-first search algorithm to traverse the graph starting from a given node (start). It marks visited nodes by setting the corresponding value in the vis vector to 1.\\n\\n* The reachableNodes function takes three inputs: n (the number of nodes in the graph), edges (a vector of edges representing the graph), and restricted (a vector of nodes that are restricted and cannot be visited). It initializes a vis vector of size n with all values set to 0, which will be used to keep track of visited nodes.\\n\\n* Next, the restricted nodes are marked as visited by setting the corresponding values in the vis vector to 2.\\n\\n* The adjacency list representation of the graph is created using the makeAdjList function.\\n\\n* The depth-first search (dfs) function is called starting from node 0 (assuming 0-based indexing of nodes) to traverse the graph and mark reachable nodes as visited.\\n\\n* Finally, the vis vector is iterated through to count the number of nodes that are marked as visited (vis[i] == 1), and the count is returned as the result, which represents the number of reachable nodes in the graph given the restrictions.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    using vi = vector<int>;\\n    vvi makeAdjList(vvi& edges,int n){\\n        vvi adjList(n);\\n        for(int i=0;i<edges.size();i++){\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return adjList;\\n    }\\n    void dfs(vvi& adjList,vi& vis,int start){\\n        if(vis[start]==0){\\n            vis[start]=1;\\n            for(int i=0;i<adjList[start].size();i++){\\n                dfs(adjList,vis,adjList[start][i]);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vi vis(n,0);\\n        for(int i=0;i<restricted.size();i++){\\n            vis[restricted[i]]=2;\\n        }\\n        vvi adjList = makeAdjList(edges,n);\\n        dfs(adjList,vis,0);\\n        int count=0;\\n        for(int i=0;i<vis.size();i++){\\n            if(vis[i]==1){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    using vi = vector<int>;\\n    vvi makeAdjList(vvi& edges,int n){\\n        vvi adjList(n);\\n        for(int i=0;i<edges.size();i++){\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return adjList;\\n    }\\n    void dfs(vvi& adjList,vi& vis,int start){\\n        if(vis[start]==0){\\n            vis[start]=1;\\n            for(int i=0;i<adjList[start].size();i++){\\n                dfs(adjList,vis,adjList[start][i]);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vi vis(n,0);\\n        for(int i=0;i<restricted.size();i++){\\n            vis[restricted[i]]=2;\\n        }\\n        vvi adjList = makeAdjList(edges,n);\\n        dfs(adjList,vis,0);\\n        int count=0;\\n        for(int i=0;i<vis.size();i++){\\n            if(vis[i]==1){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140721,
                "title": "scala-dfs-functional-style-beat-100-explained",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe algorithm uses a HashMap \"connections\" to store the connections between nodes, with node labels as keys and a list of neighboring nodes as values. A HashSet \"restrictedSet\" is used to store the restricted nodes for efficient lookups.\\n\\nInitially, the connections are constructed by iterating through the edges array and adding the edges to the connections HashMap, excluding the restricted nodes.\\n\\nA DFS function \"dfs(node: Int, seen: Set[Int])\" is then used to traverse the tree and visit all reachable nodes from node 0. The function takes a node and a set \"seen\" of nodes that have been visited as inputs and returns the number of nodes reachable from the node. The function collects all neighbors of the current node that have not been seen and not restricted, adds them to the set \"seen\", and recursively calls itself on the neighbors. The sum of all nodes reached from the neighbors is then returned.\\n\\nThe algorithm returns the number of reachable nodes by calling the DFS function on node 0 and adding 1 to account for node 0 itself. If node 0 is not present in the connections HashMap, 1 is returned as the only node that can be reached.\\n\\n# Complexity\\n- Time complexity: O(N + M), where *N* is the number of nodes in the graph and *M* is the number of edges in the graph\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N + M), where *N* is the number of nodes in the graph and *M* is the number of edges in the graph\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport scala.collection.immutable.HashSet\\nimport scala.collection.mutable.HashMap\\n\\nobject Solution {\\n  def reachableNodes(n: Int, edges: Array[Array[Int]], restricted: Array[Int]): Int = {\\n\\n    val connections = new HashMap[Int, List[Int]]()\\n    val restrictedSet = HashSet(restricted: _*)\\n\\n    edges.foreach { edge =>\\n      val s = edge(0)\\n      val d = edge(1)\\n      if (!restrictedSet.contains(d) && !restrictedSet.contains(s)) {\\n\\n        if (connections.contains(s)) connections.update(s, d :: connections(s))\\n        else connections(s) = List(d)\\n\\n        if (connections.contains(d)) connections.update(d, s :: connections(d))\\n        else connections(d) = List(s)\\n      }\\n    }\\n\\n    def dfs(node: Int, seen: Set[Int]): Int =\\n      connections(node).collect {\\n        case neighbor if !seen.contains(neighbor) && connections.contains(neighbor) =>\\n          1 + dfs(neighbor, seen + node)\\n      }.sum\\n\\n    if(connections.contains(0)) 1 + dfs(0, HashSet(0)) else 1\\n\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.immutable.HashSet\\nimport scala.collection.mutable.HashMap\\n\\nobject Solution {\\n  def reachableNodes(n: Int, edges: Array[Array[Int]], restricted: Array[Int]): Int = {\\n\\n    val connections = new HashMap[Int, List[Int]]()\\n    val restrictedSet = HashSet(restricted: _*)\\n\\n    edges.foreach { edge =>\\n      val s = edge(0)\\n      val d = edge(1)\\n      if (!restrictedSet.contains(d) && !restrictedSet.contains(s)) {\\n\\n        if (connections.contains(s)) connections.update(s, d :: connections(s))\\n        else connections(s) = List(d)\\n\\n        if (connections.contains(d)) connections.update(d, s :: connections(d))\\n        else connections(d) = List(s)\\n      }\\n    }\\n\\n    def dfs(node: Int, seen: Set[Int]): Int =\\n      connections(node).collect {\\n        case neighbor if !seen.contains(neighbor) && connections.contains(neighbor) =>\\n          1 + dfs(neighbor, seen + node)\\n      }.sum\\n\\n    if(connections.contains(0)) 1 + dfs(0, HashSet(0)) else 1\\n\\n  }\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2983349,
                "title": "fastest-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+2E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        st=[0]\\n        adj=[[] for _ in range(n)]\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        visited=[0]*n\\n        visited[0]=1\\n        for i in restricted:\\n            visited[i]=-1\\n        ct=0\\n        while st:\\n            x=st.pop(0)\\n            ct+=1\\n            for i in adj[x]:\\n                if visited[i]==0:\\n                    st.append(i)\\n                    visited[i]=1\\n        return ct\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        st=[0]\\n        adj=[[] for _ in range(n)]\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        visited=[0]*n\\n        visited[0]=1\\n        for i in restricted:\\n            visited[i]=-1\\n        ct=0\\n        while st:\\n            x=st.pop(0)\\n            ct+=1\\n            for i in adj[x]:\\n                if visited[i]==0:\\n                    st.append(i)\\n                    visited[i]=1\\n        return ct\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686381,
                "title": "c-simple-than-you-think",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 1;\\n    void solve(vector<int> adj[],vector<int>& vis,int index){\\n        vis[index] = 1;\\n        for(auto &x : adj[index]){\\n            if(vis[x]) continue;\\n            ans++;\\n            solve(adj,vis,x);\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>  adj[n];\\n        for(auto &x : edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n\\n        vector<int> vis(n,0);\\n        // unordered_set<int> st;\\n        for(auto &x : restricted) vis[x] = 1;\\n\\n        solve(adj,vis,0);\\n        return ans;\\n\\n\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 1;\\n    void solve(vector<int> adj[],vector<int>& vis,int index){\\n        vis[index] = 1;\\n        for(auto &x : adj[index]){\\n            if(vis[x]) continue;\\n            ans++;\\n            solve(adj,vis,x);\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>  adj[n];\\n        for(auto &x : edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n\\n        vector<int> vis(n,0);\\n        // unordered_set<int> st;\\n        for(auto &x : restricted) vis[x] = 1;\\n\\n        solve(adj,vis,0);\\n        return ans;\\n\\n\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410360,
                "title": "simple-c-bfs-solution-with-explanation",
                "content": "1. First we can store all the restricted nodes in a map - that would make easy to check if the node is restricted or not.\\n\\n2. We can run our usual bfs and start marking nodes only if they are not restricted and not visited before. With each node we visit, we increase our count as it will be our final answer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n\\t\\n        vector<int> v[n];    // initialising the graph\\n\\t\\t\\n\\t\\t//storing the graph\\n        for(auto it:edges){\\n            v[it[0]].push_back(it[1]);\\n            v[it[1]].push_back(it[0]);\\n        }\\n\\t\\t\\n        map<int,int> IsRestricted; // to check whether the node is restricted or not\\n        \\n\\t\\t// storing all the restricted nodes\\n        for(auto node:restricted){\\n            IsRestricted [node]  = 1;\\n        }\\n\\t\\t\\n\\t\\t// if \"0\" is restricted, you cannot go to any other nodes, because we start from \"0\"\\n        if(IsRestricted [0] > 0 ){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Doing bfs\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> vis(n,false);   // for checking if node is already visited or not \\n        vis[0] = true;\\n        int ans = 1;\\n        while(!q.empty()){\\n            int parent = q.front();\\n            q.pop();\\n            for(auto child : v [parent] ){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//  if node is not visited yet and it is not restricted\\n                if(!vis[child] and IsRestricted [child] == 0 ){\\n                    vis[child] = true; // marking node visited\\n                    ans++;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n\\t\\t\\n        return ans; // number of reachable nodes\\n    }\\n};\\n```\\n\\n**Please upvote if you found it helpful in any way :)**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n\\t\\n        vector<int> v[n];    // initialising the graph\\n\\t\\t\\n\\t\\t//storing the graph\\n        for(auto it:edges){\\n            v[it[0]].push_back(it[1]);\\n            v[it[1]].push_back(it[0]);\\n        }\\n\\t\\t\\n        map<int,int> IsRestricted; // to check whether the node is restricted or not\\n        \\n\\t\\t// storing all the restricted nodes\\n        for(auto node:restricted){\\n            IsRestricted [node]  = 1;\\n        }\\n\\t\\t\\n\\t\\t// if \"0\" is restricted, you cannot go to any other nodes, because we start from \"0\"\\n        if(IsRestricted [0] > 0 ){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Doing bfs\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> vis(n,false);   // for checking if node is already visited or not \\n        vis[0] = true;\\n        int ans = 1;\\n        while(!q.empty()){\\n            int parent = q.front();\\n            q.pop();\\n            for(auto child : v [parent] ){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//  if node is not visited yet and it is not restricted\\n                if(!vis[child] and IsRestricted [child] == 0 ){\\n                    vis[child] = true; // marking node visited\\n                    ans++;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n\\t\\t\\n        return ans; // number of reachable nodes\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399872,
                "title": "python3-bfs-and-dfs",
                "content": "BFS\\n\\n```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\tgraph = defaultdict(list)\\n        visited = [False]*n\\n        queue = deque([0])\\n        res = 0\\n        \\n        for u in restricted:\\n            visited[u] = True\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        while queue:\\n            res += len(queue)\\n            for _ in range(len(queue)):\\n                u = queue.popleft()\\n                visited[u] = True\\n                queue.extend([v for v in graph[u] if not visited[v]])\\n        \\n        return res\\n```\\n\\nDFS\\n```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\tgraph = defaultdict(list)\\n        visited = [False]*n\\n        \\n        for u in restricted:\\n            visited[u] = True\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n                \\n        def dfs(u=0):\\n            if visited[u]: return 0\\n            visited[u] = True\\n            return sum((dfs(v) for v in graph[u]), 1)\\n        \\n        return dfs()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\tgraph = defaultdict(list)\\n        visited = [False]*n\\n        queue = deque([0])\\n        res = 0\\n        \\n        for u in restricted:\\n            visited[u] = True\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        while queue:\\n            res += len(queue)\\n            for _ in range(len(queue)):\\n                u = queue.popleft()\\n                visited[u] = True\\n                queue.extend([v for v in graph[u] if not visited[v]])\\n        \\n        return res\\n```\n```python\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\tgraph = defaultdict(list)\\n        visited = [False]*n\\n        \\n        for u in restricted:\\n            visited[u] = True\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n                \\n        def dfs(u=0):\\n            if visited[u]: return 0\\n            visited[u] = True\\n            return sum((dfs(v) for v in graph[u]), 1)\\n        \\n        return dfs()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2393358,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] e, int[] r) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        for(int i=0;i<e.length+1;i++)\\n        {\\n            nm.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<e.length;i++)\\n        {\\n            nm.get(e[i][0]).add(e[i][1]);\\n            nm.get(e[i][1]).add(e[i][0]);\\n        }\\n        int c=0;\\n        Queue<Integer> kk=new LinkedList<>();\\n        kk.offer(0);\\n        Set<Integer> k=new HashSet<>();\\n        k.add(0);\\n        for(int i:r)\\n        {\\n            k.add(i);\\n        }\\n        while(!kk.isEmpty())\\n        {\\n            int p=kk.size();\\n            while(p>0)\\n            {\\n                c++;\\n                int f=kk.poll();\\n                for(int i:nm.get(f))\\n                {\\n                    if(!k.contains(i))\\n                    {\\n                        kk.offer(i);\\n                        k.add(i);\\n                    }\\n                }\\n                p--;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public int reachableNodes(int n, int[][] e, int[] r) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        for(int i=0;i<e.length+1;i++)\\n        {\\n            nm.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2393081,
                "title": "easy-c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_map<int,int> m;\\n        for(auto x :restricted )\\n        {\\n            m[x]++;\\n        }\\n        \\n        vector<int> adj[n];\\n        for(auto e : edges)\\n        {\\n            if(m.find(e[1]) == m.end() && m.find(e[0]) == m.end())\\n            {\\n                adj[e[0]].push_back(e[1]);\\n                adj[e[1]].push_back(e[0]);\\n            }\\n        }\\n        vector<int> v;\\n        vector<int> vis(n , 0);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] = 1;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            v.push_back(node);\\n            for(auto it : adj[node])\\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it] = 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_map<int,int> m;\\n        for(auto x :restricted )\\n        {\\n            m[x]++;\\n        }\\n        \\n        vector<int> adj[n];\\n        for(auto e : edges)\\n        {\\n            if(m.find(e[1]) == m.end() && m.find(e[0]) == m.end())\\n            {\\n                adj[e[0]].push_back(e[1]);\\n                adj[e[1]].push_back(e[0]);\\n            }\\n        }\\n        vector<int> v;\\n        vector<int> vis(n , 0);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] = 1;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            v.push_back(node);\\n            for(auto it : adj[node])\\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it] = 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392991,
                "title": "reachable-nodes-with-restrictions-queue-hashmap-dfs",
                "content": "Hi All,\\n\\nI approched this problem using queue, add the items to the queue for dfs.\\n\\nMaking use of Map for storing and retriving the items without recursion. Please upvote if its helpful.\\n\\n```\\npublic int reachableNodes(int n, int[][] edges, int[] restricted) {\\n\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap();\\n        Set<Integer> restrict = new HashSet<Integer>();\\n        for(int i=0; i<edges.length; i++){\\n        \\tArrayList<Integer> list = map.getOrDefault(edges[i][0], new ArrayList<Integer>());\\n        \\tlist.add(edges[i][1]);\\n        \\tmap.put(edges[i][0], list);\\n        \\tlist = map.getOrDefault(edges[i][1], new ArrayList<Integer>());\\n        \\tlist.add(edges[i][0]);\\n        \\tmap.put(edges[i][1], list);\\n        }\\n        for(int i:restricted){\\n        \\trestrict.add(i);\\n        }\\n        int res=0;\\n        q.add(0);\\n        if(!restrict.contains(0))\\n        \\tres++;\\n        while(!q.isEmpty()){\\n        \\tif(restrict.contains(q.peek()))\\n        \\t\\t\\tcontinue;\\n        \\trestrict.add(q.peek());\\n        \\tArrayList<Integer> tmp = map.get(q.poll());\\n        \\tif(tmp!=null)\\n        \\tfor(int i: tmp){\\n        \\t\\tif(restrict.contains(i))\\n        \\t\\t\\tcontinue;\\n        \\t\\tres++;\\n        \\t\\tq.add(i);\\n        \\t}\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "Hi All,\\n\\nI approched this problem using queue, add the items to the queue for dfs.\\n\\nMaking use of Map for storing and retriving the items without recursion. Please upvote if its helpful.\\n\\n```\\npublic int reachableNodes(int n, int[][] edges, int[] restricted) {\\n\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap();\\n        Set<Integer> restrict = new HashSet<Integer>();\\n        for(int i=0; i<edges.length; i++){\\n        \\tArrayList<Integer> list = map.getOrDefault(edges[i][0], new ArrayList<Integer>());\\n        \\tlist.add(edges[i][1]);\\n        \\tmap.put(edges[i][0], list);\\n        \\tlist = map.getOrDefault(edges[i][1], new ArrayList<Integer>());\\n        \\tlist.add(edges[i][0]);\\n        \\tmap.put(edges[i][1], list);\\n        }\\n        for(int i:restricted){\\n        \\trestrict.add(i);\\n        }\\n        int res=0;\\n        q.add(0);\\n        if(!restrict.contains(0))\\n        \\tres++;\\n        while(!q.isEmpty()){\\n        \\tif(restrict.contains(q.peek()))\\n        \\t\\t\\tcontinue;\\n        \\trestrict.add(q.peek());\\n        \\tArrayList<Integer> tmp = map.get(q.poll());\\n        \\tif(tmp!=null)\\n        \\tfor(int i: tmp){\\n        \\t\\tif(restrict.contains(i))\\n        \\t\\t\\tcontinue;\\n        \\t\\tres++;\\n        \\t\\tq.add(i);\\n        \\t}\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2392948,
                "title": "java-simple-clean-bfs",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        \\n        List<List<Integer>> adj = new ArrayList<>(n);\\n\\t\\t// Changing edges[][] to Adj List.\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n        for(int[] edg: edges) {\\n            adj.get(edg[0]).add(edg[1]);\\n            adj.get(edg[1]).add(edg[0]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        boolean[] visited = new boolean[n];\\n        for(int i=0; i<restricted.length; i++)\\n            visited[restricted[i]] = true;\\n\\t\\t// Marking restricted nodes as visited as we cant visit them.\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0); visited[0] = true;\\n\\t\\t// Starting BFS from node 0 and marking it as visited.\\n        \\n\\t\\t// While loop = Number of nodes that can be visited avoiding restricted.\\n        while(!q.isEmpty()) {\\n            int cur = q.poll();\\n            ans++;\\n            \\n            for(Integer nei: adj.get(cur)) {\\n                if(visited[nei] == false) {\\n                    q.add(nei);\\n                    visited[nei] = true;\\n                }      \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        \\n        List<List<Integer>> adj = new ArrayList<>(n);\\n\\t\\t// Changing edges[][] to Adj List.\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n        for(int[] edg: edges) {\\n            adj.get(edg[0]).add(edg[1]);\\n            adj.get(edg[1]).add(edg[0]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        boolean[] visited = new boolean[n];\\n        for(int i=0; i<restricted.length; i++)\\n            visited[restricted[i]] = true;\\n\\t\\t// Marking restricted nodes as visited as we cant visit them.\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0); visited[0] = true;\\n\\t\\t// Starting BFS from node 0 and marking it as visited.\\n        \\n\\t\\t// While loop = Number of nodes that can be visited avoiding restricted.\\n        while(!q.isEmpty()) {\\n            int cur = q.poll();\\n            ans++;\\n            \\n            for(Integer nei: adj.get(cur)) {\\n                if(visited[nei] == false) {\\n                    q.add(nei);\\n                    visited[nei] = true;\\n                }      \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391591,
                "title": "idea-explained-with-comments-graph-traversal-bfs-c-clean-code",
                "content": "**Intution :**\\n------------------------------\\n\\n* Idea here is very straightforward. First we need to create an undirected graph by connecting given edges.\\n\\n* Also insert all restricted nodes into a set for fast lookups.\\n* Then in next step simply do a BFS over the graph starting from `source = 0`.\\n* And whenever we reach a node that is unrestricted and which is not already visited, increment count by 1.\\n------------------------------\\n# Code :\\n-----------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);  // Adjacency Matrix to represent graph\\n        \\n\\t\\t// Create an undirected graph\\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n\\t\\t// Store all restricted nodes in a set for fast lookup\\n        unordered_set<int> restrictedSet(restricted.begin(), restricted.end());\\n        \\n\\t\\t// Keep track of Visited nodes\\n        vector<bool> visited(n, false);\\n        \\n\\t\\t// Queue to perform BFS\\n        queue<int> que;\\n        \\n\\t\\tint source = 0;\\n        que.push(source);  // Add first element source into our queue\\n        \\n        int count = 0;  // To keep track of all reachable unrestricted nodes\\n        \\n\\t\\t\\n\\t\\t// Perform BFS\\n        while(que.size()) {\\n            \\n            int node = que.front(); que.pop();\\n            \\n            visited[node] = true;  //Mark current node as visited\\n\\t\\t\\t\\n\\t\\t\\t// If current node is not restricted then only move further \\n            if(restrictedSet.find(node) == restrictedSet.end()) {\\n                count++;  // Increment count of reachable nodes\\n                \\n\\t\\t\\t\\t// Iterate over all adjacent nodes and add them into queue \\n\\t\\t\\t\\t// And only insert if it is not visited and unrestricted\\n                for(auto& adjacentNode : adj[node]) {\\n                    if(!visited[adjacentNode] && restrictedSet.find(adjacentNode) == restrictedSet.end()) {\\n                        que.push(adjacentNode);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n-------------------------\\n\\n**Complexity ;**\\n-----------------------------------\\n\\n* **Time :** `O(N)`, to create graph and perform BFS \\n* **Space :** `O(N)`, to store graph, set of restricted nodes, and queue for BFS\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);  // Adjacency Matrix to represent graph\\n        \\n\\t\\t// Create an undirected graph\\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n\\t\\t// Store all restricted nodes in a set for fast lookup\\n        unordered_set<int> restrictedSet(restricted.begin(), restricted.end());\\n        \\n\\t\\t// Keep track of Visited nodes\\n        vector<bool> visited(n, false);\\n        \\n\\t\\t// Queue to perform BFS\\n        queue<int> que;\\n        \\n\\t\\tint source = 0;\\n        que.push(source);  // Add first element source into our queue\\n        \\n        int count = 0;  // To keep track of all reachable unrestricted nodes\\n        \\n\\t\\t\\n\\t\\t// Perform BFS\\n        while(que.size()) {\\n            \\n            int node = que.front(); que.pop();\\n            \\n            visited[node] = true;  //Mark current node as visited\\n\\t\\t\\t\\n\\t\\t\\t// If current node is not restricted then only move further \\n            if(restrictedSet.find(node) == restrictedSet.end()) {\\n                count++;  // Increment count of reachable nodes\\n                \\n\\t\\t\\t\\t// Iterate over all adjacent nodes and add them into queue \\n\\t\\t\\t\\t// And only insert if it is not visited and unrestricted\\n                for(auto& adjacentNode : adj[node]) {\\n                    if(!visited[adjacentNode] && restrictedSet.find(adjacentNode) == restrictedSet.end()) {\\n                        que.push(adjacentNode);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391227,
                "title": "c-bfs-adj-list",
                "content": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& arr, vector<int>& v) {\\n        vector<vector<int>>adj(n);\\n        vector<bool>vis(n,false);\\n        unordered_set<int>s(begin(v),end(v));\\n        if(s.find(0)!=s.end())return 0;\\n        for(auto e:arr){\\n            adj[e[0]].pb(e[1]);\\n            adj[e[1]].pb(e[0]);\\n        }\\n        int count=1;\\n        queue<int>q;\\n        q.push(0);\\n        vis[0]=true;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int temp=q.front();\\n                q.pop();\\n                for(int i=0;i<adj[temp].size();i++){\\n                    if(!vis[adj[temp][i]] and s.find(adj[temp][i])==s.end()){\\n                        q.push(adj[temp][i]);\\n                        count++;\\n                        vis[adj[temp][i]]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& arr, vector<int>& v) {\\n        vector<vector<int>>adj(n);\\n        vector<bool>vis(n,false);\\n        unordered_set<int>s(begin(v),end(v));\\n        if(s.find(0)!=s.end())return 0;\\n        for(auto e:arr){\\n            adj[e[0]].pb(e[1]);\\n            adj[e[1]].pb(e[0]);\\n        }\\n        int count=1;\\n        queue<int>q;\\n        q.push(0);\\n        vis[0]=true;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int temp=q.front();\\n                q.pop();\\n                for(int i=0;i<adj[temp].size();i++){\\n                    if(!vis[adj[temp][i]] and s.find(adj[temp][i])==s.end()){\\n                        q.push(adj[temp][i]);\\n                        count++;\\n                        vis[adj[temp][i]]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390986,
                "title": "javascript-dfs-solution",
                "content": "> Runtime: 701 ms, faster than 100.00% of JavaScript online submissions for Reachable Nodes With Restrictions.\\nMemory Usage: 146.3 MB, less than 100.00% of JavaScript online submissions for Reachable Nodes With Restrictions.\\n\\n```js\\nvar reachableNodes = function (n, edges, restricted) {\\n  let res = 0;\\n  const newVisitMap = {}\\n  edges.forEach(([l, r]) => {\\n    newVisitMap[l] ? newVisitMap[l].add(r) : newVisitMap[l] = new Set([r]);\\n    newVisitMap[r] ? newVisitMap[r].add(l) : newVisitMap[r] = new Set([l]);\\n  })\\n  const map = new Set(restricted);\\n  function dfs(node) {\\n    if (map.has(node)) return;\\n    map.add(node)\\n    res++;\\n    newVisitMap[node].forEach(e => dfs(e))\\n  }\\n  dfs(0);\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```js\\nvar reachableNodes = function (n, edges, restricted) {\\n  let res = 0;\\n  const newVisitMap = {}\\n  edges.forEach(([l, r]) => {\\n    newVisitMap[l] ? newVisitMap[l].add(r) : newVisitMap[l] = new Set([r]);\\n    newVisitMap[r] ? newVisitMap[r].add(l) : newVisitMap[r] = new Set([l]);\\n  })\\n  const map = new Set(restricted);\\n  function dfs(node) {\\n    if (map.has(node)) return;\\n    map.add(node)\\n    res++;\\n    newVisitMap[node].forEach(e => dfs(e))\\n  }\\n  dfs(0);\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390837,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> impossible ;\\n    vector<int> visited , adj[100001] ;\\n        \\n    void dfs(int src){\\n        visited[src] = 1 ;\\n        \\n        for(auto &nbr : adj[src]){\\n            if(!visited[nbr] and impossible.find(nbr) == end(impossible)){\\n                dfs(nbr);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        for(auto &x : restricted) impossible.insert(x) ;\\n        visited.resize(n,0) ;\\n        for(auto &x : edges) adj[x[0]].push_back(x[1]) , adj[x[1]].push_back(x[0]) ;\\n        dfs(0) ;\\n        return count(begin(visited),end(visited),1) ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> impossible ;\\n    vector<int> visited , adj[100001] ;\\n        \\n    void dfs(int src){\\n        visited[src] = 1 ;\\n        \\n        for(auto &nbr : adj[src]){\\n            if(!visited[nbr] and impossible.find(nbr) == end(impossible)){\\n                dfs(nbr);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        for(auto &x : restricted) impossible.insert(x) ;\\n        visited.resize(n,0) ;\\n        for(auto &x : edges) adj[x[0]].push_back(x[1]) , adj[x[1]].push_back(x[0]) ;\\n        dfs(0) ;\\n        return count(begin(visited),end(visited),1) ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390814,
                "title": "python-bfs",
                "content": "Beats 100%\\n\\n```python\\nclass Solution(object):\\n    def reachableNodes(self, n, edges, restricted):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type restricted: List[int]\\n        :rtype: int\\n        \"\"\"\\n        adj = defaultdict(set)\\n        for u, v in edges:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        total = 0\\n        q = deque()\\n        q.append(0)\\n        visited = set()\\n        restricted = set(restricted)\\n        \\n        while len(q):\\n            node = q.popleft()\\n            for val in adj[node]:\\n                if val not in restricted and val not in visited:\\n                    q.append(val)\\n                    total += 1 \\n                    visited.add(val)                    \\n\\n        return 1 if not total else total\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution(object):\\n    def reachableNodes(self, n, edges, restricted):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type restricted: List[int]\\n        :rtype: int\\n        \"\"\"\\n        adj = defaultdict(set)\\n        for u, v in edges:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        total = 0\\n        q = deque()\\n        q.append(0)\\n        visited = set()\\n        restricted = set(restricted)\\n        \\n        while len(q):\\n            node = q.popleft()\\n            for val in adj[node]:\\n                if val not in restricted and val not in visited:\\n                    q.append(val)\\n                    total += 1 \\n                    visited.add(val)                    \\n\\n        return 1 if not total else total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390754,
                "title": "dfs-unordered-set",
                "content": "step1. create adj list\\nstep2. insert restricted nodes to a set, store its count\\nstep3. call dfs on 0 and its neighbours if not present in set(no yet visited or restricted), once the dfs call for 0 is over, set contains vis+restriced nodes so return size(vis+ restricted)-the count that was stored earlier(restricted)\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],unordered_set<int>& hash,int v){\\n        hash.insert(v);\\n        for(int i=0;i<adj[v].size();i++){\\n            if(!hash.count(adj[v][i])) dfs(adj,hash,adj[v][i]);\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_set<int> hash; vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<restricted.size();i++) hash.insert(restricted[i]);\\n        int count=hash.size();\\n        dfs(adj,hash,0);\\n        return hash.size()-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],unordered_set<int>& hash,int v){\\n        hash.insert(v);\\n        for(int i=0;i<adj[v].size();i++){\\n            if(!hash.count(adj[v][i])) dfs(adj,hash,adj[v][i]);\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_set<int> hash; vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<restricted.size();i++) hash.insert(restricted[i]);\\n        int count=hash.size();\\n        dfs(adj,hash,0);\\n        return hash.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390747,
                "title": "dfs-easy-solution",
                "content": "Just mark Visited all the restricted Node.AND then do simple DFS.\\nWhy its working?\\nbecuase marking visited restricted node make sure that you will not go and visit any other node using them. \\n\\n```\\nclass Solution {\\n    int count=0;\\n    ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        boolean[] vis=new boolean[n];\\n        for(int i:restricted){\\n            vis[i]=true;\\n        }\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] ii:edges){\\n            adj.get(ii[0]).add(ii[1]);\\n            adj.get(ii[1]).add(ii[0]);\\n        }\\n        dfs(0,vis);\\n        return count;\\n    }\\n    private void dfs(int node,boolean[] vis){\\n        vis[node]=true;\\n        count++;\\n        for(int it:adj.get(node)){\\n            if(vis[it]==false){\\n                dfs(it,vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        boolean[] vis=new boolean[n];\\n        for(int i:restricted){\\n            vis[i]=true;\\n        }\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] ii:edges){\\n            adj.get(ii[0]).add(ii[1]);\\n            adj.get(ii[1]).add(ii[0]);\\n        }\\n        dfs(0,vis);\\n        return count;\\n    }\\n    private void dfs(int node,boolean[] vis){\\n        vis[node]=true;\\n        count++;\\n        for(int it:adj.get(node)){\\n            if(vis[it]==false){\\n                dfs(it,vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390587,
                "title": "simple-dfs",
                "content": "Simply do dfs and if found any node that is restricted dont visit that node else increment the ans as you visit new node.\\n\\n`\\nclass Solution {\\n\\n    int ans = 0;\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        boolean[] restric = new boolean[n];\\n        for(int i : restricted){\\n            restric[i] = true;\\n        }\\n        List<List<Integer>> ls = new ArrayList<>();\\n        for(int i = 0 ; i < n ;i++){\\n            ls.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges){\\n            ls.get(edge[0]).add(edge[1]);\\n            ls.get(edge[1]).add(edge[0]);\\n        }\\n        dfs(ls , 0 , restric , new boolean[n]);\\n        return ans;\\n    }\\n    private void dfs(List<List<Integer>> ls , int i , boolean[] restricted , boolean[] visited ){\\n        if(restricted[i])return;\\n        if(visited[i])return;\\n        ans++;\\n        visited[i] = true;\\n        for(int n : ls.get(i)){\\n            dfs(ls , n ,restricted , visited);\\n        }\\n    }\\n}`\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int ans = 0;\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        boolean[] restric = new boolean[n];\\n        for(int i : restricted){\\n            restric[i] = true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2390477,
                "title": "c-dfs-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&vis,vector<int>graph[],int &c)\\n    {\\n        vis[node]=1;\\n        c++;\\n        for(auto i:graph[node])\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,graph,c);\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        vector<int>graph[n+1];\\n        \\n        for(auto i:edges)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        vector<int>vis(n+1,0);\\n        for(auto i:restricted)\\n            vis[i]=1;\\n        \\n        int c=0;\\n        dfs(0,vis,graph,c);\\n        return c;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&vis,vector<int>graph[],int &c)\\n    {\\n        vis[node]=1;\\n        c++;\\n        for(auto i:graph[node])\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,graph,c);\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        vector<int>graph[n+1];\\n        \\n        for(auto i:edges)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        vector<int>vis(n+1,0);\\n        for(auto i:restricted)\\n            vis[i]=1;\\n        \\n        int c=0;\\n        dfs(0,vis,graph,c);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390455,
                "title": "c-solution-using-dfs",
                "content": "**This is my way**\\nJust tick the array with restricted access and then you will browse dfs from 0 by topic to find the maximum number of nodes.\\n**Please upvote if you like this solution:**\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    int cnt = 1;\\n    vector<bool> visited;\\n    \\npublic:\\n    void dfs(int u) {\\n        visited[u] = true;\\n        for (int v : adj[u]) {\\n            if (!visited[v]) {\\n                cnt++;\\n                dfs(v);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        adj.resize(n);\\n        visited.resize(n, false);\\n        for (int x : restricted) {\\n            visited[x] = true;\\n        }\\n        for (auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs(0);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    int cnt = 1;\\n    vector<bool> visited;\\n    \\npublic:\\n    void dfs(int u) {\\n        visited[u] = true;\\n        for (int v : adj[u]) {\\n            if (!visited[v]) {\\n                cnt++;\\n                dfs(v);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        adj.resize(n);\\n        visited.resize(n, false);\\n        for (int x : restricted) {\\n            visited[x] = true;\\n        }\\n        for (auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs(0);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897459,
                "title": "concise-java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic BFS knowledge would suffice\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart with node 0 do traverse all possible nodes (without restriction) and which isn\\'t visited\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n      \\n        // Just to fetch restricted nodes on O(1)\\n        HashSet<Integer> restr = new HashSet<>();\\n        for(int i:restricted)restr.add(i);\\n        // Creating the graph\\n        ArrayList<Integer>[] adj = new ArrayList[n];\\n    \\n        for(int i=0;i<n;i++) adj[i] = new ArrayList<>();\\n        for(int[] ed:edges){\\n            adj[ed[0]].add(ed[1]);\\n            adj[ed[1]].add(ed[0]);\\n        }\\n        \\n        // BFS traversal\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] vis = new boolean[n];\\n        // Don\\'t forget to check condition for 0 as well\\n        if(!restr.contains(0)){q.add(0);vis[0]=true;}\\n\\n        int cnt = 0;\\n        while(!q.isEmpty()){\\n            int cur = q.poll();\\n            vis[cur] = true;\\n            //This node is reachable from 0 so increment count\\n            cnt++;\\n            for(int i:adj[cur]){\\n                if(!restr.contains(i) && !vis[i]) q.offer(i);\\n            }\\n        }\\n\\n        // Finally return all the reachable nodes \\n        return cnt; \\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n      \\n        // Just to fetch restricted nodes on O(1)\\n        HashSet<Integer> restr = new HashSet<>();\\n        for(int i:restricted)restr.add(i);\\n        // Creating the graph\\n        ArrayList<Integer>[] adj = new ArrayList[n];\\n    \\n        for(int i=0;i<n;i++) adj[i] = new ArrayList<>();\\n        for(int[] ed:edges){\\n            adj[ed[0]].add(ed[1]);\\n            adj[ed[1]].add(ed[0]);\\n        }\\n        \\n        // BFS traversal\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] vis = new boolean[n];\\n        // Don\\'t forget to check condition for 0 as well\\n        if(!restr.contains(0)){q.add(0);vis[0]=true;}\\n\\n        int cnt = 0;\\n        while(!q.isEmpty()){\\n            int cur = q.poll();\\n            vis[cur] = true;\\n            //This node is reachable from 0 so increment count\\n            cnt++;\\n            for(int i:adj[cur]){\\n                if(!restr.contains(i) && !vis[i]) q.offer(i);\\n            }\\n        }\\n\\n        // Finally return all the reachable nodes \\n        return cnt; \\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701993,
                "title": "simple-python-solution-using-union-find",
                "content": "\\n# Code\\n```\\nclass Disjointset :\\n\\n    def __init__(self,n):\\n        self.rank = [0 for i in range(n+1)]   # n+1 because of 0 or 1 based indexing\\n        self.parent = [i for i in range(n+1)]\\n        self.size = [1 for i in range(n+1)]\\n\\n    def findparent(self,node) :\\n        if node == self.parent[node] :\\n            return node \\n        self.parent[node] = self.findparent(self.parent[node]) \\n        return self.parent[node]\\n\\n    # union by rank\\n    def unionbyrank(self, u , v) :\\n        uutp = self.findparent(u)\\n        vutp = self.findparent(v)\\n        if uutp == vutp :\\n            return \\n        urank = self.rank[u]\\n        vrank = self.rank[v]\\n        if urank < vrank :\\n            self.parent[uutp] = vutp\\n        elif urank > vrank :\\n            self.parent[vutp] = uutp\\n        else :\\n            self.parent[vutp] = uutp\\n            self.rank[uutp] += 1\\n\\n    # union by size\\n    def unionbysize(self,u,v) :\\n        uutp = self.findparent(u)\\n        vutp = self.findparent(v)\\n        if uutp == vutp :\\n            return \\n\\n        # finding size\\n        usize = self.size[uutp]\\n        vsize = self.size[vutp]\\n        if usize < vsize :\\n            self.parent[uutp] = vutp\\n            self.size[vutp] += self.size[uutp]\\n        else:\\n            self.parent[vutp] = uutp \\n            self.size[uutp] += self.size[vutp]\\n\\n\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n    \\n        obj = Disjointset(n)\\n        restricted = set(restricted)\\n        for x in edges :\\n            if x[0] in restricted or x[1] in restricted :\\n                continue \\n            \\n            obj.unionbysize(x[0] , x[1])\\n\\n        return obj.size[obj.parent[0]]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Disjointset :\\n\\n    def __init__(self,n):\\n        self.rank = [0 for i in range(n+1)]   # n+1 because of 0 or 1 based indexing\\n        self.parent = [i for i in range(n+1)]\\n        self.size = [1 for i in range(n+1)]\\n\\n    def findparent(self,node) :\\n        if node == self.parent[node] :\\n            return node \\n        self.parent[node] = self.findparent(self.parent[node]) \\n        return self.parent[node]\\n\\n    # union by rank\\n    def unionbyrank(self, u , v) :\\n        uutp = self.findparent(u)\\n        vutp = self.findparent(v)\\n        if uutp == vutp :\\n            return \\n        urank = self.rank[u]\\n        vrank = self.rank[v]\\n        if urank < vrank :\\n            self.parent[uutp] = vutp\\n        elif urank > vrank :\\n            self.parent[vutp] = uutp\\n        else :\\n            self.parent[vutp] = uutp\\n            self.rank[uutp] += 1\\n\\n    # union by size\\n    def unionbysize(self,u,v) :\\n        uutp = self.findparent(u)\\n        vutp = self.findparent(v)\\n        if uutp == vutp :\\n            return \\n\\n        # finding size\\n        usize = self.size[uutp]\\n        vsize = self.size[vutp]\\n        if usize < vsize :\\n            self.parent[uutp] = vutp\\n            self.size[vutp] += self.size[uutp]\\n        else:\\n            self.parent[vutp] = uutp \\n            self.size[uutp] += self.size[vutp]\\n\\n\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n    \\n        obj = Disjointset(n)\\n        restricted = set(restricted)\\n        for x in edges :\\n            if x[0] in restricted or x[1] in restricted :\\n                continue \\n            \\n            obj.unionbysize(x[0] , x[1])\\n\\n        return obj.size[obj.parent[0]]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572318,
                "title": "python-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        #building a undirected graph\\n        graph=collections.defaultdict(list)\\n        def buildgraph(edge):\\n            for x in edge:\\n                graph[x[0]].append(x[1])\\n                graph[x[1]].append(x[0])\\n        restricted=set(restricted)\\n        buildgraph(edges)\\n\\n        #breadth first search of a graph\\n        count=0\\n        q=[]\\n        q.append(0)\\n        visited=[True]*n\\n        while q:\\n            cur=q[0]\\n            q.remove(cur)\\n            #if not visited,taken into account\\n            if visited[cur]:\\n                count+=1\\n                visited[cur]=False\\n            for x in graph[cur]:\\n                if visited[x] and x not in restricted :\\n                    q.append(x)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        #building a undirected graph\\n        graph=collections.defaultdict(list)\\n        def buildgraph(edge):\\n            for x in edge:\\n                graph[x[0]].append(x[1])\\n                graph[x[1]].append(x[0])\\n        restricted=set(restricted)\\n        buildgraph(edges)\\n\\n        #breadth first search of a graph\\n        count=0\\n        q=[]\\n        q.append(0)\\n        visited=[True]*n\\n        while q:\\n            cur=q[0]\\n            q.remove(cur)\\n            #if not visited,taken into account\\n            if visited[cur]:\\n                count+=1\\n                visited[cur]=False\\n            for x in graph[cur]:\\n                if visited[x] and x not in restricted :\\n                    q.append(x)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548638,
                "title": "pure-bfs-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) \\n    {\\n        int res =0;\\n\\n        vector<int> adj[n];\\n        unordered_set<int> s(r.begin(),r.end());\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        queue<int>q ; \\n        q.push(0);\\n        s.insert(0);\\n        while(q.size())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            res++;\\n            for(auto x:adj[node])\\n            {\\n                if(s.find(x)==s.end())\\n                {\\n                    q.push(x);\\n                    s.insert(x);\\n                }\\n            }\\n        }\\n        \\n\\n\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) \\n    {\\n        int res =0;\\n\\n        vector<int> adj[n];\\n        unordered_set<int> s(r.begin(),r.end());\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        queue<int>q ; \\n        q.push(0);\\n        s.insert(0);\\n        while(q.size())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            res++;\\n            for(auto x:adj[node])\\n            {\\n                if(s.find(x)==s.end())\\n                {\\n                    q.push(x);\\n                    s.insert(x);\\n                }\\n            }\\n        }\\n        \\n\\n\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454677,
                "title": "simple-python-bfs-solution-beats-86-82-and-memory-beats-91-56",
                "content": "# Intuition\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        adj_list = defaultdict(list)\\n        for x,y in edges:\\n            adj_list[x].append(y)\\n            adj_list[y].append(x)\\n    \\n        que = deque()\\n        que.append(0)\\n        result = 0\\n        visited = set()\\n        for node in restricted:\\n            visited.add(node)\\n\\n        while que:\\n            cur = que.popleft()\\n            if cur in visited:\\n                continue    \\n            visited.add(cur)\\n            result += 1\\n            for node in adj_list[cur]:\\n                que.append(node)\\n        \\n        return result\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        adj_list = defaultdict(list)\\n        for x,y in edges:\\n            adj_list[x].append(y)\\n            adj_list[y].append(x)\\n    \\n        que = deque()\\n        que.append(0)\\n        result = 0\\n        visited = set()\\n        for node in restricted:\\n            visited.add(node)\\n\\n        while que:\\n            cur = que.popleft()\\n            if cur in visited:\\n                continue    \\n            visited.add(cur)\\n            result += 1\\n            for node in adj_list[cur]:\\n                que.append(node)\\n        \\n        return result\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417198,
                "title": "easy-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i ,vector<vector<int>>&v,map<int,int>&mp,vector<int>&vis){\\n        cout<<i<<\"//\"<<endl;\\n        vis[i]=0;\\n        for(auto j:v[i]){\\n            if(vis[j]==-1 && mp.find(j)==mp.end()){\\n                dfs(j,v,mp,vis);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& ed, vector<int>& res) {\\n        map<int,int>mp;\\n        for(int i =0; i<res.size(); i++){\\n            mp[res[i]]++;\\n        }\\n        vector<vector<int>>v(n);\\n        int m = ed.size();\\n        for(int i=0; i<m; i++){\\n            int a = ed[i][0];\\n            int b = ed[i][1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        int i=0;\\n        vector<int>vis(n,-1);\\n        dfs(i,v,mp,vis);\\n        int ans =0;\\n        for(int i=0; i<vis.size(); i++){\\n            if(vis[i]==0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i ,vector<vector<int>>&v,map<int,int>&mp,vector<int>&vis){\\n        cout<<i<<\"//\"<<endl;\\n        vis[i]=0;\\n        for(auto j:v[i]){\\n            if(vis[j]==-1 && mp.find(j)==mp.end()){\\n                dfs(j,v,mp,vis);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& ed, vector<int>& res) {\\n        map<int,int>mp;\\n        for(int i =0; i<res.size(); i++){\\n            mp[res[i]]++;\\n        }\\n        vector<vector<int>>v(n);\\n        int m = ed.size();\\n        for(int i=0; i<m; i++){\\n            int a = ed[i][0];\\n            int b = ed[i][1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        int i=0;\\n        vector<int>vis(n,-1);\\n        dfs(i,v,mp,vis);\\n        int ans =0;\\n        for(int i=0; i<vis.size(); i++){\\n            if(vis[i]==0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3239021,
                "title": "c-solution-with-comments-for-better-understanding-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=1;  // node 0 is already reached as it is starting point\\n    vector<vector<int>> graph;\\n    unordered_set<int> res;  // to store restricted numbers for fast fetch\\n    vector<bool> vis;  // visited array for DFS\\n    \\n    void dfs(int i){\\n        for(int y: graph[i]){\\n            if(!vis[y] && res.count(y)==0){\\n                vis[y]= true;\\n                dfs(y);\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        for(int x:restricted) res.insert(x);\\n        \\n        // creating graph\\n        graph.resize(n);\\n        vis.resize(n);\\n        for(auto &x:edges){\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        // mark 0 as visited coz it is starting point and is already reached \\n        vis[0]= true;\\n        dfs(0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=1;  // node 0 is already reached as it is starting point\\n    vector<vector<int>> graph;\\n    unordered_set<int> res;  // to store restricted numbers for fast fetch\\n    vector<bool> vis;  // visited array for DFS\\n    \\n    void dfs(int i){\\n        for(int y: graph[i]){\\n            if(!vis[y] && res.count(y)==0){\\n                vis[y]= true;\\n                dfs(y);\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        for(int x:restricted) res.insert(x);\\n        \\n        // creating graph\\n        graph.resize(n);\\n        vis.resize(n);\\n        for(auto &x:edges){\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        // mark 0 as visited coz it is starting point and is already reached \\n        vis[0]= true;\\n        dfs(0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193855,
                "title": "python-begineer-friendly-solution-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\t# stores final ans\\n        self.ans = 0\\n\\t\\t\\n\\t\\t# adjacency list for graph\\n        self.adj = [[] for i in range(n)]\\n        for pair in edges:\\n            self.adj[pair[0]].append(pair[1])\\n            self.adj[pair[1]].append(pair[0])\\n\\t\\t\\t\\n\\t\\t# start visiting nodes from 0, pass the restriction as set for fast lookup, and a set for track of visited nodes\\n        self.find(0,set(restricted),set())\\n        return self.ans\\n    \\n    def find(self,idx,rest,visited):\\n\\t\\t# if node is visited or is in restriction return\\n        if idx in visited or idx in rest:\\n            return\\n\\t\\t\\t\\n\\t\\t# mark current node as visited and increment the counter\\n        visited.add(idx)\\n        self.ans += 1\\n\\t\\t\\n\\t\\t# traverse the neighbours of the current node recursively\\n        for elm in self.adj[idx]:\\n            self.find(elm,rest,visited)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\t# stores final ans\\n        self.ans = 0\\n\\t\\t\\n\\t\\t# adjacency list for graph\\n        self.adj = [[] for i in range(n)]\\n        for pair in edges:\\n            self.adj[pair[0]].append(pair[1])\\n            self.adj[pair[1]].append(pair[0])\\n\\t\\t\\t\\n\\t\\t# start visiting nodes from 0, pass the restriction as set for fast lookup, and a set for track of visited nodes\\n        self.find(0,set(restricted),set())\\n        return self.ans\\n    \\n    def find(self,idx,rest,visited):\\n\\t\\t# if node is visited or is in restriction return\\n        if idx in visited or idx in rest:\\n            return\\n\\t\\t\\t\\n\\t\\t# mark current node as visited and increment the counter\\n        visited.add(idx)\\n        self.ans += 1\\n\\t\\t\\n\\t\\t# traverse the neighbours of the current node recursively\\n        for elm in self.adj[idx]:\\n            self.find(elm,rest,visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020042,
                "title": "simple-bfs",
                "content": "it iz what it iz\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>vis(n+1,0);\\n        vector<int>adj[n+1];\\n        set<int>s,s1;\\n\\n        for(auto it :restricted) s.insert(it);\\n        for(auto it:edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        queue<int>q;\\n        q.push(0);\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            if(vis[node]==1 || s.find(node)!=s.end() ) continue;           \\n            vis[node]=1;\\n            for(auto adjnode : adj[node]){\\n                q.push(adjnode);\\n\\n\\n            }\\n        }\\n        int count=0;\\n        for(auto it :vis){\\n            if(it ==1) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>vis(n+1,0);\\n        vector<int>adj[n+1];\\n        set<int>s,s1;\\n\\n        for(auto it :restricted) s.insert(it);\\n        for(auto it:edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        queue<int>q;\\n        q.push(0);\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            if(vis[node]==1 || s.find(node)!=s.end() ) continue;           \\n            vis[node]=1;\\n            for(auto adjnode : adj[node]){\\n                q.push(adjnode);\\n\\n\\n            }\\n        }\\n        int count=0;\\n        for(auto it :vis){\\n            if(it ==1) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760780,
                "title": "crisp-n-clear-o-n-javascript-runtime-25-88-meaningful-vars",
                "content": "Runtime: 1047 ms, faster than 25.88% of JavaScript online submissions for Reachable Nodes With Restrictions.\\nMemory Usage: 184.9 MB, less than 5.88% of JavaScript online submissions for Reachable Nodes With Restrictions.\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n```\\nvar reachableNodes = function (n, edges, restricted) {\\n    const restrictedConfig = (function () {\\n        const config = {};\\n        for (const iterator of restricted) {\\n            config[iterator] = true;\\n        }\\n        return config;\\n    })();\\n    const config = {};\\n    for (const [from, to] of edges) {\\n        if (!config[from]) {\\n            config[from] = {};\\n        }\\n        if (!config[to]) {\\n            config[to] = {};\\n        }\\n        config[from][to] = true;\\n        config[to][from] = true;\\n    }\\n    const visited = {};\\n    function visit(from) {\\n        if (restrictedConfig[from]) {\\n            return;\\n        }\\n        if (visited[from]) {\\n            return;\\n        }\\n        visited[from] = true;\\n        for (const key in config[from]) {\\n            visit(key);\\n        }\\n    }\\n    visit((from = 0));\\n\\n    return Object.keys(visited).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar reachableNodes = function (n, edges, restricted) {\\n    const restrictedConfig = (function () {\\n        const config = {};\\n        for (const iterator of restricted) {\\n            config[iterator] = true;\\n        }\\n        return config;\\n    })();\\n    const config = {};\\n    for (const [from, to] of edges) {\\n        if (!config[from]) {\\n            config[from] = {};\\n        }\\n        if (!config[to]) {\\n            config[to] = {};\\n        }\\n        config[from][to] = true;\\n        config[to][from] = true;\\n    }\\n    const visited = {};\\n    function visit(from) {\\n        if (restrictedConfig[from]) {\\n            return;\\n        }\\n        if (visited[from]) {\\n            return;\\n        }\\n        visited[from] = true;\\n        for (const key in config[from]) {\\n            visit(key);\\n        }\\n    }\\n    visit((from = 0));\\n\\n    return Object.keys(visited).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500990,
                "title": "simplest-c-solution",
                "content": "Just don\\'t add edges which involve restricted nodes and do dfs from source ( which is \\'0\\' here). \\n\\n```\\nclass Solution {\\npublic:\\n    \\n      int cnt = 0;\\n    \\n       void dfs(int v, vector<int> adj[], int p)\\n       {\\n          \\n           cnt++;\\n           for(int u: adj[v])\\n               if(u != p)\\n                   dfs(u, adj, v);\\n           \\n           return;\\n       }\\n    \\n    \\n        int reachableNodes(int n, vector<vector<int>>& arr, vector<int>& res) {\\n        \\n            \\n            vector<int> mark(n, 0);\\n            \\n            for(int i = 0; i < res.size(); i++)\\n                mark[res[i]] = 1;\\n            \\n            vector<int> adj[n];\\n            \\n            for(int i = 0; i < arr.size(); i++)\\n            {\\n                if(mark[arr[i][0]] or mark[arr[i][1]])\\n                    continue;\\n                \\n                 adj[arr[i][0]].push_back(arr[i][1]);\\n                 adj[arr[i][1]].push_back(arr[i][0]);\\n                \\n            }\\n            \\n            \\n            cnt = 0;\\n            \\n            dfs(0, adj, -1);\\n        \\n            return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n      int cnt = 0;\\n    \\n       void dfs(int v, vector<int> adj[], int p)\\n       {\\n          \\n           cnt++;\\n           for(int u: adj[v])\\n               if(u != p)\\n                   dfs(u, adj, v);\\n           \\n           return;\\n       }\\n    \\n    \\n        int reachableNodes(int n, vector<vector<int>>& arr, vector<int>& res) {\\n        \\n            \\n            vector<int> mark(n, 0);\\n            \\n            for(int i = 0; i < res.size(); i++)\\n                mark[res[i]] = 1;\\n            \\n            vector<int> adj[n];\\n            \\n            for(int i = 0; i < arr.size(); i++)\\n            {\\n                if(mark[arr[i][0]] or mark[arr[i][1]])\\n                    continue;\\n                \\n                 adj[arr[i][0]].push_back(arr[i][1]);\\n                 adj[arr[i][1]].push_back(arr[i][0]);\\n                \\n            }\\n            \\n            \\n            cnt = 0;\\n            \\n            dfs(0, adj, -1);\\n        \\n            return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485054,
                "title": "bfs-simple-explanation-graph-python",
                "content": "CODE ::\\n\\n\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        #Storing visited nodes data in visited dict\\n        visited={}.fromkeys([i for i in range(n+1)],False)\\n        \\n        #Restricted nodes stored in a dict as well\\n        restricted_d={ i:True for i in restricted}\\n            \\n        #Finding all the reachable nodes from a particular node in a single pass;\\n        connected_nodes=defaultdict(list)\\n        for i in edges:\\n            connected_nodes[i[0]].append(i[1])\\n            connected_nodes[i[1]].append(i[0])\\n            \\n        #BFS traversal to find the count of reachable nodes with restrictions\\n            \\n        c,queue=0,[0]\\n        while queue:\\n            t=queue.pop(0)\\n            c+=1\\n            visited[t]=True\\n            for i in connected_nodes[t]: \\n                if (not visited[i]) and (restricted_d.get(i)==None): queue.append(i)\\n        return c\\n\\n        \\n```\\n\\nDO UPVOTE IF IT HELPED YOU !",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        #Storing visited nodes data in visited dict\\n        visited={}.fromkeys([i for i in range(n+1)],False)\\n        \\n        #Restricted nodes stored in a dict as well\\n        restricted_d={ i:True for i in restricted}\\n            \\n        #Finding all the reachable nodes from a particular node in a single pass;\\n        connected_nodes=defaultdict(list)\\n        for i in edges:\\n            connected_nodes[i[0]].append(i[1])\\n            connected_nodes[i[1]].append(i[0])\\n            \\n        #BFS traversal to find the count of reachable nodes with restrictions\\n            \\n        c,queue=0,[0]\\n        while queue:\\n            t=queue.pop(0)\\n            c+=1\\n            visited[t]=True\\n            for i in connected_nodes[t]: \\n                if (not visited[i]) and (restricted_d.get(i)==None): queue.append(i)\\n        return c\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475431,
                "title": "cpp-dfs-bfs",
                "content": "**DFS**\\n```\\nclass Solution {\\npublic:\\n    int count =0 ;\\n    \\n    void solve(int node, vector<bool>& vis, vector<vector<int>>& graph, set<int>& st){\\n        vis[node] =true ;\\n        \\n        if(st.find(node) != st.end()) return ;\\n        \\n        for(auto it : graph[node]){\\n            if(!vis[it]){\\n                solve(it, vis, graph, st) ;\\n            }\\n        }\\n        \\n        count++ ;\\n    }\\n        \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> vis(n, false) ;\\n        vector<vector<int>> graph(n) ;\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0] ;\\n            int v = edges[i][1] ;\\n            \\n            graph[u].push_back(v) ;\\n            graph[v].push_back(u) ;\\n        }\\n        \\n        set<int> st ;\\n        for(int i=0; i<restricted.size(); i++){\\n            st.insert(restricted[i]) ;\\n        }\\n        \\n        solve(0, vis, graph, st) ;\\n        return count ;\\n    }\\n};\\n```\\n\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> graph(n) ;\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0] ;\\n            int v = edges[i][1] ;\\n            \\n            graph[u].push_back(v) ;\\n            graph[v].push_back(u) ;\\n        }\\n        \\n        set<int> st ;\\n        for(int i=0; i<restricted.size(); i++){\\n            st.insert(restricted[i]) ;\\n        }\\n        \\n        \\n        queue<int> q ;\\n        q.push(0) ;\\n        vector<bool> vis(n, false) ;\\n        vis[0] = true ;\\n            \\n        int count =0 ;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int node = q.front() ;\\n                q.pop() ;\\n                \\n                if(st.find(node) != st.end())   continue ;\\n                count++ ;\\n                \\n                for(auto it : graph[node]){\\n                    if(!vis[it]){\\n                        q.push(it) ;\\n                        vis[it] = true ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```\\n\\n\\n**PLEASE UPVOTE!!**\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count =0 ;\\n    \\n    void solve(int node, vector<bool>& vis, vector<vector<int>>& graph, set<int>& st){\\n        vis[node] =true ;\\n        \\n        if(st.find(node) != st.end()) return ;\\n        \\n        for(auto it : graph[node]){\\n            if(!vis[it]){\\n                solve(it, vis, graph, st) ;\\n            }\\n        }\\n        \\n        count++ ;\\n    }\\n        \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> vis(n, false) ;\\n        vector<vector<int>> graph(n) ;\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0] ;\\n            int v = edges[i][1] ;\\n            \\n            graph[u].push_back(v) ;\\n            graph[v].push_back(u) ;\\n        }\\n        \\n        set<int> st ;\\n        for(int i=0; i<restricted.size(); i++){\\n            st.insert(restricted[i]) ;\\n        }\\n        \\n        solve(0, vis, graph, st) ;\\n        return count ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> graph(n) ;\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0] ;\\n            int v = edges[i][1] ;\\n            \\n            graph[u].push_back(v) ;\\n            graph[v].push_back(u) ;\\n        }\\n        \\n        set<int> st ;\\n        for(int i=0; i<restricted.size(); i++){\\n            st.insert(restricted[i]) ;\\n        }\\n        \\n        \\n        queue<int> q ;\\n        q.push(0) ;\\n        vector<bool> vis(n, false) ;\\n        vis[0] = true ;\\n            \\n        int count =0 ;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int node = q.front() ;\\n                q.pop() ;\\n                \\n                if(st.find(node) != st.end())   continue ;\\n                count++ ;\\n                \\n                for(auto it : graph[node]){\\n                    if(!vis[it]){\\n                        q.push(it) ;\\n                        vis[it] = true ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472456,
                "title": "clean-c-bfs-code",
                "content": "```\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\n#define pb push_back\\n#define pii pair<int,int>\\n#define S second\\n#define F first\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& rest) {\\n        vvi g(n);\\n        for(auto &it : edges) g[it[0]].pb(it[1]), g[it[1]].pb(it[0]);\\n        unordered_map<int,int> mp;\\n        for(auto it : rest) mp[it]++;\\n        queue<pii> q;\\n        q.push({0,-1});\\n        int ans = 1;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currNode = q.front().F, perNode = q.front().S;\\n                q.pop();\\n                for(auto &child : g[currNode])\\n                {\\n                    if(child != perNode && mp[child]==0) q.push({child,currNode}), ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\n#define pb push_back\\n#define pii pair<int,int>\\n#define S second\\n#define F first\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& rest) {\\n        vvi g(n);\\n        for(auto &it : edges) g[it[0]].pb(it[1]), g[it[1]].pb(it[0]);\\n        unordered_map<int,int> mp;\\n        for(auto it : rest) mp[it]++;\\n        queue<pii> q;\\n        q.push({0,-1});\\n        int ans = 1;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currNode = q.front().F, perNode = q.front().S;\\n                q.pop();\\n                for(auto &child : g[currNode])\\n                {\\n                    if(child != perNode && mp[child]==0) q.push({child,currNode}), ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459530,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        boolean[] vis = new boolean[n];\\n        \\n        Set<Integer> set = new HashSet<>();            //you can also use arraylist but the contains() method of set take less time then arraylist.\\n        for(int i : restricted) set.add(i);\\n        \\n        for(int i=0;i<n;i++) adj.add(new ArrayList<>());\\n        \\n        for(int[] i : edges){                                           //creating bi-directional edges in the the graph \\n            adj.get(i[0]).add(i[1]);\\n            adj.get(i[1]).add(i[0]);\\n        }\\n        \\n\\t\\tint ans = 1;                                                   // ind zero is already counted thus initializing ans with 1.\\n        Queue<Integer> q = new LinkedList<>();    \\n        q.add(0);                                                       // as we are only to know the reachable nodes from zero. \\n      \\n        vis[0] = true;\\n        while(!q.isEmpty()){\\n            int ind = q.remove();\\n        \\n            for(int i : adj.get(ind)){\\n                if(!vis[i] && !set.contains(i)){\\n                    vis[i] = true;\\n                    q.add(i);\\n                    ans++;                                            // ans is increased everytime we got a reachable node. \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        boolean[] vis = new boolean[n];\\n        \\n        Set<Integer> set = new HashSet<>();            //you can also use arraylist but the contains() method of set take less time then arraylist.\\n        for(int i : restricted) set.add(i);\\n        \\n        for(int i=0;i<n;i++) adj.add(new ArrayList<>());\\n        \\n        for(int[] i : edges){                                           //creating bi-directional edges in the the graph \\n            adj.get(i[0]).add(i[1]);\\n            adj.get(i[1]).add(i[0]);\\n        }\\n        \\n\\t\\tint ans = 1;                                                   // ind zero is already counted thus initializing ans with 1.\\n        Queue<Integer> q = new LinkedList<>();    \\n        q.add(0);                                                       // as we are only to know the reachable nodes from zero. \\n      \\n        vis[0] = true;\\n        while(!q.isEmpty()){\\n            int ind = q.remove();\\n        \\n            for(int i : adj.get(ind)){\\n                if(!vis[i] && !set.contains(i)){\\n                    vis[i] = true;\\n                    q.add(i);\\n                    ans++;                                            // ans is increased everytime we got a reachable node. \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455626,
                "title": "c-simple-dfs-binary-search",
                "content": "Idea:\\n->First sort the given restricted array so that we can find whether a value is present in it or not in O(logn) time.\\n\\n->Then represent the edges in adjacency list format\\n\\n->Finally call for dfs(0) and count each node while traversing, break if encouter a restricted node.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    void dfs(int root,vector<bool> &vis,vector<vector<int>>& edges, vector<int>& restricted){\\n        vis[root] = 1;\\n        if(binary_search(restricted.begin(),restricted.end(),root))\\n            return;\\n        cnt++;\\n        for(auto i:edges[root]){\\n            if(!vis[i]){\\n                dfs(i,vis,edges,restricted);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> vis (n);\\n        sort(restricted.begin(),restricted.end());\\n        vector<vector<int>> v (n);\\n        for(int i=0;i<n-1;i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        dfs(0,vis,v,restricted);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    void dfs(int root,vector<bool> &vis,vector<vector<int>>& edges, vector<int>& restricted){\\n        vis[root] = 1;\\n        if(binary_search(restricted.begin(),restricted.end(),root))\\n            return;\\n        cnt++;\\n        for(auto i:edges[root]){\\n            if(!vis[i]){\\n                dfs(i,vis,edges,restricted);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> vis (n);\\n        sort(restricted.begin(),restricted.end());\\n        vector<vector<int>> v (n);\\n        for(int i=0;i<n-1;i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        dfs(0,vis,v,restricted);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425976,
                "title": "java-bfs-solution",
                "content": "```\\n\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        ArrayList<Integer> arr[] = new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            arr[i] = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++){\\n            arr[edges[i][0]].add(edges[i][1]);\\n            arr[edges[i][1]].add(edges[i][0]);\\n        }\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<restricted.length;i++){\\n            hs.add(restricted[i]);\\n        }\\n        boolean visited[] = new boolean[n];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        while(!q.isEmpty()){\\n            int qsize = q.size();\\n            for(int i=0;i<qsize;i++){\\n                int temp = q.poll();\\n                if(hs.contains(temp))\\n                    continue;\\n                visited[temp]=true;\\n                \\n                for(int j=0;j<arr[temp].size();j++){\\n                    \\n                    int val = arr[temp].get(j);\\n                    if(!visited[val]){\\n                    if(hs.contains(val))\\n                        continue;\\n                   // System.out.println(val+\" \"+j);\\n                    q.add(val);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n            if(visited[i])\\n                ans++;\\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        ArrayList<Integer> arr[] = new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            arr[i] = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++){\\n            arr[edges[i][0]].add(edges[i][1]);\\n            arr[edges[i][1]].add(edges[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2425228,
                "title": "c-bfs-vs-dfs-90-time-438ms-50-space-144-2mb",
                "content": "Handbook tree traversal problem, with the extra spice of some blocked nodes, that we can (and will) consider with the same logic of already visited ones; the rest is all about converting two parameters (`edges` and `restricted`) into more performing DSes.\\n\\nWe will start with a BFS approach, since most problems around here are more on the DFS side and I was getting bored otherwise.\\n\\nIn order to work our way around the problem, we will start with a few support variables:\\n* `available` is going to be an array of `n` elements, recording both the `restricted` and the already visited ones;\\n* `connections` is an array of vectors we will use in place of `edges`;\\n* `qLen` will store the length of our list, initially set to be `1`, since we know we will always have a valid starting point (`0`);\\n* `res` is our accumulator variable, initially set to `1` for the same reason as the one on the line above (`0` will never be blocked);\\n* `curr` will hold our current node in our BFS routine;\\n* `q` will store the nodes to visit at each level/layer of our BFS, initially populated with the `0` node as per specs.\\n\\nWe will populate `available` setting all its values initially to `true`, then flagging `0` and all the nodes in `restricted` as `false`.\\n\\nTo populate connections, we will push for each `edge` `edge[1]` in `connections[edge[0]]` and the other way around (`edge[0]` in `connections[edge[1]]`).\\n\\nWe can now access this bit of information in a much faster way, so time for our BFS loop(s), with the outer one running `while` we have elements in the queue (ie: `qLen != 0`) and:\\n* traversing all the level, running `qLen` times and:\\n\\t* assing the current front of `q` to `curr`;\\n\\t* pop it from `q`;\\n\\t* for each node `n` in `connections[curr]`, we will:\\n\\t\\t* check if `n` was not blocked or visited before (ie: `available[n] == true`) and:\\n\\t\\t\\t* flag it as visited (ie: `available[n] = false`);\\n\\t\\t\\t* push `n` into `q`;\\n\\t\\t\\t* increase `res` by `1`;\\n* to be ready for the next loop, we now have only to set `qLen` to be the current length of `q`.\\n\\nOnce done, we can `return` `res` :)\\n\\n\\nThe BFS code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted) {\\n        // support variables\\n        bool available[n];\\n        vector<int> connections[n];\\n        int qLen = 1, res = 1, curr;\\n        queue<int> q{{0}};\\n        // populating available\\n        fill(available, available + n, true);\\n        available[0] = false;\\n        for (int n: restricted) available[n] = false;\\n        // populating connections\\n        for (auto &edge: edges) {\\n            connections[edge[0]].push_back(edge[1]);\\n            connections[edge[1]].push_back(edge[0]);\\n        }\\n        while (qLen) {\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // adding its connections to q, if any, while increasing our counter\\n                for (int n: connections[curr]) {\\n                    if (available[n]) {\\n                        available[n] = false;\\n                        q.push(n);\\n                        res++;\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSame logic, moving more variables at instance level (since I really hate to have those DFS calls passing an insane amount of parameters) and refactoring it all in DFS sauce; we get comparable speed, burning much more memory:\\n\\n```cpp\\nclass Solution {\\n    bool *available;\\n    vector<int> *connections;\\n    int res = 1;\\n    void dfs(int curr = 0) {\\n        for (int n: connections[curr]) {\\n            if (available[n]) {\\n                available[n] = false;\\n                dfs(n);\\n                res++;\\n            }\\n        }\\n    }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted) {\\n        // support variables\\n        available = new bool[n];\\n        connections = new vector<int>[n];\\n        // populating available\\n        fill(available, available + n, true);\\n        available[0] = false;\\n        for (int n: restricted) available[n] = false;\\n        // populating connections\\n        for (auto &edge: edges) {\\n            connections[edge[0]].push_back(edge[1]);\\n            connections[edge[1]].push_back(edge[0]);\\n        }\\n        // computing res\\n        dfs();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted) {\\n        // support variables\\n        bool available[n];\\n        vector<int> connections[n];\\n        int qLen = 1, res = 1, curr;\\n        queue<int> q{{0}};\\n        // populating available\\n        fill(available, available + n, true);\\n        available[0] = false;\\n        for (int n: restricted) available[n] = false;\\n        // populating connections\\n        for (auto &edge: edges) {\\n            connections[edge[0]].push_back(edge[1]);\\n            connections[edge[1]].push_back(edge[0]);\\n        }\\n        while (qLen) {\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // adding its connections to q, if any, while increasing our counter\\n                for (int n: connections[curr]) {\\n                    if (available[n]) {\\n                        available[n] = false;\\n                        q.push(n);\\n                        res++;\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    bool *available;\\n    vector<int> *connections;\\n    int res = 1;\\n    void dfs(int curr = 0) {\\n        for (int n: connections[curr]) {\\n            if (available[n]) {\\n                available[n] = false;\\n                dfs(n);\\n                res++;\\n            }\\n        }\\n    }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted) {\\n        // support variables\\n        available = new bool[n];\\n        connections = new vector<int>[n];\\n        // populating available\\n        fill(available, available + n, true);\\n        available[0] = false;\\n        for (int n: restricted) available[n] = false;\\n        // populating connections\\n        for (auto &edge: edges) {\\n            connections[edge[0]].push_back(edge[1]);\\n            connections[edge[1]].push_back(edge[0]);\\n        }\\n        // computing res\\n        dfs();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420960,
                "title": "concise-dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, int &ans) {\\n        vis[node] = 1;\\n        \\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) ans++, dfs(ad, adj, vis, ans);\\n        }\\n    }\\n    \\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<int> adj[n];\\n        \\n        for(auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i : res) vis[i] = 1;\\n        \\n        int ans = 1;\\n        dfs(0, adj, vis, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, int &ans) {\\n        vis[node] = 1;\\n        \\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) ans++, dfs(ad, adj, vis, ans);\\n        }\\n    }\\n    \\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<int> adj[n];\\n        \\n        for(auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i : res) vis[i] = 1;\\n        \\n        int ans = 1;\\n        dfs(0, adj, vis, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419304,
                "title": "beginner-friendly-solution-c-bfs-easy",
                "content": "class Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_map<int,list<int>>adj;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int count=1;\\n        queue<int>q;\\n        q.push(0);\\n        set<int>s;\\n        for(int i=0;i<restricted.size();i++)\\n        {\\n            s.insert(restricted[i]);\\n        }\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node])\\n            {  \\n                if(s.find(it)==s.end() && vis[it]==0)\\n                {\\n                    q.push(it);\\n                    count++;\\n                    vis[it]=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_map<int,list<int>>adj;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2418822,
                "title": "c-easy-dfs",
                "content": "Just Construct a Tree by removing restricted nodes and nodes that are connected beneath that node.\\nAnd perform Normal DFS on the tree hence constructed.\\n```\\nclass Solution {\\nprivate:\\n   void dfs(vector<int>adj[],vector<bool>&visited,int i,int &cnt)\\n   {\\n       visited[i]=true;\\n       cnt++;\\n       for(auto &x:adj[i])\\n       {\\n           if(!visited[x])\\n           {\\n               dfs(adj,visited,x,cnt);\\n           }\\n       }\\n   }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_set<int>s;\\n        for(auto &x:restricted)\\n        { \\n            s.insert(x);\\n        }\\n        vector<int>adj[n];\\n        for(auto &edge:edges)\\n        {\\n            if(s.find(edge[0])==s.end() && s.find(edge[1])==s.end())\\n            {\\n                 adj[edge[0]].push_back(edge[1]);\\n                 adj[edge[1]].push_back(edge[0]);\\n            }\\n        }\\n        int cnt=0;\\n        vector<bool>visited(n,false);\\n        dfs(adj,visited,0,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n   void dfs(vector<int>adj[],vector<bool>&visited,int i,int &cnt)\\n   {\\n       visited[i]=true;\\n       cnt++;\\n       for(auto &x:adj[i])\\n       {\\n           if(!visited[x])\\n           {\\n               dfs(adj,visited,x,cnt);\\n           }\\n       }\\n   }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_set<int>s;\\n        for(auto &x:restricted)\\n        { \\n            s.insert(x);\\n        }\\n        vector<int>adj[n];\\n        for(auto &edge:edges)\\n        {\\n            if(s.find(edge[0])==s.end() && s.find(edge[1])==s.end())\\n            {\\n                 adj[edge[0]].push_back(edge[1]);\\n                 adj[edge[1]].push_back(edge[0]);\\n            }\\n        }\\n        int cnt=0;\\n        vector<bool>visited(n,false);\\n        dfs(adj,visited,0,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410037,
                "title": "c-code-using-dfs-easy-to-understand",
                "content": "**Algorithm**:\\n1. Store the restricted nodes in an unordered set so that they can be searched in O(1) time(average case).\\n2. Make graph using adjacency list and if the node is present in the set, implies that it is a restricted node and do not add it in the adjacency list. All the nodes connected to the restricted nodes will also not be added in the adjacency list.\\n3. Now apply DFS on the graph and count the number of nodes.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> adj[],vector<bool> &visited,int &count) {\\n        visited[node]=true;\\n        for(auto it: adj[node]) {\\n            if(!visited[it]) {\\n                count++;\\n                dfs(it,adj,visited,count);\\n            }\\n        }\\n        return;\\n        \\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n        unordered_set<int> s;\\n        for(int i=0;i<restricted.size();i++) {\\n            s.insert(restricted[i]);\\n        }\\n        for(int i=0;i<edges.size();i++) {\\n            if(s.find(edges[i][0])!=s.end() || s.find(edges[i][1])!=s.end()) continue;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int count=1;\\n        vector<bool> visited(n,false);\\n        dfs(0,adj,visited,count);\\n        return count;\\n        \\n        \\n    }\\n};\\n```\\n\\nThere could be better approaches for this question, but this was the one that came to my mind during the contest and was accepted in the first attempt, so i thought of posting it \\uD83D\\uDE01. \\nDo upvote.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> adj[],vector<bool> &visited,int &count) {\\n        visited[node]=true;\\n        for(auto it: adj[node]) {\\n            if(!visited[it]) {\\n                count++;\\n                dfs(it,adj,visited,count);\\n            }\\n        }\\n        return;\\n        \\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n        unordered_set<int> s;\\n        for(int i=0;i<restricted.size();i++) {\\n            s.insert(restricted[i]);\\n        }\\n        for(int i=0;i<edges.size();i++) {\\n            if(s.find(edges[i][0])!=s.end() || s.find(edges[i][1])!=s.end()) continue;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int count=1;\\n        vector<bool> visited(n,false);\\n        dfs(0,adj,visited,count);\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409777,
                "title": "simple-sol-normal-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    void dfs ( int cur_node , vector<int> grp[] , vector<int> &vis , int &ans ){\\n        vis[cur_node] = 1 ;\\n       \\n        for ( auto child : grp[cur_node]){\\n            if ( !vis[child]){\\n                ans ++ ;\\n                dfs ( child , grp , vis , ans );\\n            }\\n        }\\n    }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        // what we can do is , lets us mark the resitricted nodes as marked initially and simply apply dfs\\n        \\n        vector<int> vis (n  , 0 );\\n        vector<int> grp[n+1];\\n        \\n        for ( int i = 0 ;i < restricted.size() ; i ++) vis[restricted[i]] = 1;\\n        \\n        for ( auto i : edges ){\\n            grp[i[0]].push_back(i[1]);\\n            grp[i[1]].push_back(i[0]);\\n        }\\n        \\n        int ans = 1 ;\\n        dfs ( 0 , grp , vis , ans );\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs ( int cur_node , vector<int> grp[] , vector<int> &vis , int &ans ){\\n        vis[cur_node] = 1 ;\\n       \\n        for ( auto child : grp[cur_node]){\\n            if ( !vis[child]){\\n                ans ++ ;\\n                dfs ( child , grp , vis , ans );\\n            }\\n        }\\n    }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        // what we can do is , lets us mark the resitricted nodes as marked initially and simply apply dfs\\n        \\n        vector<int> vis (n  , 0 );\\n        vector<int> grp[n+1];\\n        \\n        for ( int i = 0 ;i < restricted.size() ; i ++) vis[restricted[i]] = 1;\\n        \\n        for ( auto i : edges ){\\n            grp[i[0]].push_back(i[1]);\\n            grp[i[1]].push_back(i[0]);\\n        }\\n        \\n        int ans = 1 ;\\n        dfs ( 0 , grp , vis , ans );\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408124,
                "title": "my-java-solution-with-simple-dfs-idea-with-comments",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        // base case will be if 0 is already restricted\\n        // my idea is to mark the restricted nodes as visited in a boolean array so that it does not conflict with our recursion\\n        // then build the graph from the given edges matrix and do a simple dfs from the starting node 0.\\n        // increment the counter whenever we are able to make a move further\\n        // if we already gets visited, it means either the node is visited before or its been marked as restricted becuase we are using same visited array to track both.\\n        boolean [] visited = new boolean [n];\\n        for (int restrict : restricted) {\\n            visited[restrict] = true;\\n        }\\n        if (visited[0]) {\\n            return 0;\\n        }\\n        List<List<Integer>> graph = buildGraph(n, edges);\\n        return findAllReachables(graph, visited, n, 0);\\n    }\\n    \\n    private int findAllReachables(List<List<Integer>> graph, boolean [] visited, int n, int node) {\\n        if (visited[node]) {\\n            return 0;\\n        }\\n        int count = 1;\\n        visited[node] = true;\\n        List<Integer> children = graph.get(node);\\n        for (Integer child : children) {\\n            if (!visited[child]) {\\n                count += findAllReachables(graph, visited, n, child);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private List<List<Integer>> buildGraph(int n, int [][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        // base case will be if 0 is already restricted\\n        // my idea is to mark the restricted nodes as visited in a boolean array so that it does not conflict with our recursion\\n        // then build the graph from the given edges matrix and do a simple dfs from the starting node 0.\\n        // increment the counter whenever we are able to make a move further\\n        // if we already gets visited, it means either the node is visited before or its been marked as restricted becuase we are using same visited array to track both.\\n        boolean [] visited = new boolean [n];\\n        for (int restrict : restricted) {\\n            visited[restrict] = true;\\n        }\\n        if (visited[0]) {\\n            return 0;\\n        }\\n        List<List<Integer>> graph = buildGraph(n, edges);\\n        return findAllReachables(graph, visited, n, 0);\\n    }\\n    \\n    private int findAllReachables(List<List<Integer>> graph, boolean [] visited, int n, int node) {\\n        if (visited[node]) {\\n            return 0;\\n        }\\n        int count = 1;\\n        visited[node] = true;\\n        List<Integer> children = graph.get(node);\\n        for (Integer child : children) {\\n            if (!visited[child]) {\\n                count += findAllReachables(graph, visited, n, child);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private List<List<Integer>> buildGraph(int n, int [][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406734,
                "title": "c-using-dfs-with-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& rest) {\\n        \\n        vector<int>adj[n+1];\\n        vector<bool>vis(n+1,1);\\n        \\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        stack<int>st;\\n        st.push(0);\\n        \\n        for(auto &x:rest){\\n            vis[x]=0;\\n        }\\n        \\n        long long cnt=0;\\n        \\n        while(!st.empty()){\\n            \\n            auto k=st.top();\\n            st.pop();\\n            \\n            cnt++;\\n            vis[k]=0;\\n            \\n            for(auto &x:adj[k]){\\n                if(vis[x]){\\n                    st.push(x);\\n                    vis[x]=0;\\n                }\\n            }\\n            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& rest) {\\n        \\n        vector<int>adj[n+1];\\n        vector<bool>vis(n+1,1);\\n        \\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        stack<int>st;\\n        st.push(0);\\n        \\n        for(auto &x:rest){\\n            vis[x]=0;\\n        }\\n        \\n        long long cnt=0;\\n        \\n        while(!st.empty()){\\n            \\n            auto k=st.top();\\n            st.pop();\\n            \\n            cnt++;\\n            vis[k]=0;\\n            \\n            for(auto &x:adj[k]){\\n                if(vis[x]){\\n                    st.push(x);\\n                    vis[x]=0;\\n                }\\n            }\\n            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403014,
                "title": "bfs",
                "content": "\\t\\tdp = defaultdict(list) \\n        restricted = set(restricted) \\n        \\n        for i,j in edges:\\n            if i not in restricted: dp[i].append(j) \\n            if j not in restricted: dp[j].append(i)\\n                \\n        q = deque([0]) \\n        res = {0} \\n        \\n        while q:\\n            for i in range(len(q)): \\n                node = q.popleft()  \\n                for j in dp[node]:\\n                    if j not in res and j not in restricted: \\n                        res.add(j)\\n                        q.append(j) \\n        return len(res)",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\t\\tdp = defaultdict(list) \\n        restricted = set(restricted) \\n        \\n        for i,j in edges:\\n            if i not in restricted: dp[i].append(j) \\n            if j not in restricted: dp[j].append(i)\\n                \\n        q = deque([0]) \\n        res = {0} \\n        \\n        while q:\\n            for i in range(len(q)): \\n                node = q.popleft()  \\n                for j in dp[node]:\\n                    if j not in res and j not in restricted: \\n                        res.add(j)\\n                        q.append(j) \\n        return len(res)",
                "codeTag": "Unknown"
            },
            {
                "id": 2402181,
                "title": "python3-bft-using-sets-comments-explanation",
                "content": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        #Convert restricted list into restricted set to increase processing speed\\n        #Create a dictionary of non-restricted nodes \\n        #Thus the key is the node and the value is the adjacency set for that node\\n        resSet = set(restricted)        \\n        nodes_dict = dict()     \\n        for x in range(0, n):\\n            if(x not in resSet):\\n                nodes_dict[x] = set()\\n\\n        #Fill adjacency set only with non-restricted nodes\\n        #We can check for non-restricted nodes by using the keys of the dict\\n        for pair0, pair1 in edges:\\n            if(pair0 in nodes_dict and pair1 in nodes_dict):\\n                nodes_dict[pair0].add(pair1)\\n                nodes_dict[pair1].add(pair0)\\n\\n        #We will always start at node 0, so I add 0 to the traversalQueue\\n        #Add 0 to counting set since we always have 0\\n        traversalQueue = deque([0])\\n        count = {0}\\n\\n        #Utilize set operations\\n        #Starting at 0 look at 0\\'s adjacency set\\n        #Use difference operation to find which of 0\\'s neighbors are not visited to add to the traversalQueue\\n        #####\\n        #Obviously none of 0\\'s neighbors have been visited but...\\n        #...for rest of the nodes, you don\\'t want to traverse backwards and get stuck\\n        #The reason why you will get stuck if you don\\'t do the difference operation is because:\\n        #The edge comes in pairs. So [0,1] means that 0 will have 1 in its adjacency set. However...\\n        #...1 will also have 0. If you do not account for this, when you get to node 1 in the dict...\\n        #...all of 1\\'s neighbors INCLUDING 0 will be added to the traversalQueue. Thus an infinite loop occurs.\\n        #####\\n        #Add the neighbors to the traversalQueue\\n        #Add all neighbors to counting set\\n        #Remove node from traversalQueue FIFO style. At the start that will obviously be node 0.\\n        #Repeat until you have traversed all nodes\\n        while(len(traversalQueue) != 0):\\n            current = traversalQueue[0]\\n            diff = nodes_dict[current].difference(count)\\n            traversalQueue.extend(diff)\\n            count.update(diff)\\n            traversalQueue.popleft()\\n\\n        return len(count)\\n```\\n\\nOverall the code is broken up into 3 parts.\\n1. Create the dictionary of non-restricted nodes. Each key maps directly to the node it represents and the value it holds is a set of its neighbors, aka an adjacency set.\\n2. From the edge list, find which pairs have no restricted nodes in them, and use them to fill out the adjacency set.\\n3. Begin traversing the graph starting at node 0. Adding each layer in breadth-first traversal (BFT) fashion.\\n\\nIf there is some confusion, using example 1 we can walk through what has happened.\\n\\nExample 1 gives us this:\\n* n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\\n\\nLooking at part 1 of the 3 steps, we create a dictionary that has all nodes from 0-6 except 4 and 5. So the dictionary looks like this:\\n\\n{0 : set(), 1 : set(), 2 : set(), 3 : set(), 6 : set()}\\n\\nNow we move onto part 2. We must fill up the dictionary with the neighbors, but only if both are non-restricted. Once we do it will look like this:\\n\\n{0 : {1}, 1 : {0, 2, 3}, 2 : {1}, 3 : {1}, 6 : set()}\\n\\nWe are sitting on a representation of the graph that we can traverse. So we move to part 3. This can be a bit confusing, so let\\'s walk through several iterations.\\n\\nWe start with the traversalQueue holding 0 in it. Same with our counting set.\\n\\nGoing into our while loop, we grab the front of the queue, which is 0. We then do the difference of 0\\'s adjacency set from the counting set. In other words, {1} difference {0}. Now this operation is not normal subtraction. Because what happens is the difference operation looks for all the same things between the two sets. And then removes them from the LEFT set (the set that\\'s calling the method). For example, we have set A and set B. A = {1, 2, 3, 4} and B = {3, 4, 5, 6}. So if we do A.difference(B) we get an answer of {1, 2}. 3 and 4 were equal between both sets, so those elements were removed from the calling set, which was set A. If we were to do B.difference(A), we would get {5, 6}.\\n\\nWith this understanding of set operations, we can see that {1} difference {0} will be {1}. This 1 gets added to the traversalQueue changing it to [0, 1]. It also gets added to the count set changing it to {0, 1}. Now that we have completed that round, we are done with node 0, and we remove it. Since it is first in the traversalQueue, we pop the first element at index 0, which is node 0.\\n\\nSo traversalQueue is [1] and count is {0, 1}. Let\\'s do one more round to see that happens.\\n\\nSo our current node is the one at the front of the traversalQueue, which is now 1. Let\\'s find the difference between 1\\'s neighbors and the people we\\'ve already checked. 1 has the neighbors {0, 2, 3} and we have visited {0, 1} so far. The difference is then {2, 3}. We add 2 and 3 to the traversalQueue making it [1, 2, 3]. We also add it to the count which is {0, 1, 2, 3}. We are now done with node 1, and can remove it from the traversalQueue making it now [2, 3]. Thus the next node you do this with is node 2. You can follow this all the way to the conclusion. \\n\\nFrom this you can see how we are going layer by layer (breadth) rather than following a pathway all the way down (depth).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        #Convert restricted list into restricted set to increase processing speed\\n        #Create a dictionary of non-restricted nodes \\n        #Thus the key is the node and the value is the adjacency set for that node\\n        resSet = set(restricted)        \\n        nodes_dict = dict()     \\n        for x in range(0, n):\\n            if(x not in resSet):\\n                nodes_dict[x] = set()\\n\\n        #Fill adjacency set only with non-restricted nodes\\n        #We can check for non-restricted nodes by using the keys of the dict\\n        for pair0, pair1 in edges:\\n            if(pair0 in nodes_dict and pair1 in nodes_dict):\\n                nodes_dict[pair0].add(pair1)\\n                nodes_dict[pair1].add(pair0)\\n\\n        #We will always start at node 0, so I add 0 to the traversalQueue\\n        #Add 0 to counting set since we always have 0\\n        traversalQueue = deque([0])\\n        count = {0}\\n\\n        #Utilize set operations\\n        #Starting at 0 look at 0\\'s adjacency set\\n        #Use difference operation to find which of 0\\'s neighbors are not visited to add to the traversalQueue\\n        #####\\n        #Obviously none of 0\\'s neighbors have been visited but...\\n        #...for rest of the nodes, you don\\'t want to traverse backwards and get stuck\\n        #The reason why you will get stuck if you don\\'t do the difference operation is because:\\n        #The edge comes in pairs. So [0,1] means that 0 will have 1 in its adjacency set. However...\\n        #...1 will also have 0. If you do not account for this, when you get to node 1 in the dict...\\n        #...all of 1\\'s neighbors INCLUDING 0 will be added to the traversalQueue. Thus an infinite loop occurs.\\n        #####\\n        #Add the neighbors to the traversalQueue\\n        #Add all neighbors to counting set\\n        #Remove node from traversalQueue FIFO style. At the start that will obviously be node 0.\\n        #Repeat until you have traversed all nodes\\n        while(len(traversalQueue) != 0):\\n            current = traversalQueue[0]\\n            diff = nodes_dict[current].difference(count)\\n            traversalQueue.extend(diff)\\n            count.update(diff)\\n            traversalQueue.popleft()\\n\\n        return len(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397068,
                "title": "c-simple-bfs-solution",
                "content": "We construct the graph while excluding edges that connect to a restricted node. Once the graph is obtained, we perform BFS and return count of nodes visited. \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    int bfs(int n){\\n        int cnt = 0;\\n        queue<int> q;\\n        vector<bool> visited(n,false);\\n        q.push(0);\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n            visited[front] = true;\\n            cnt++;\\n            for(auto it:adj[front]){\\n                if(!visited[it])\\n                    q.push(it);\\n            }\\n        }\\n        return cnt;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        adj = vector<vector<int>>(n);\\n        unordered_set<int> res;\\n        for(auto it:restricted)\\n            res.insert(it);\\n        for(int i=0;i<edges.size();i++){\\n            int f = edges[i][0],s = edges[i][1];\\n\\t\\t\\t//if either of the nodes are restricted, we exclude the current edge \\n            if(res.count(f) || res.count(s))\\n                continue;\\n            adj[f].push_back(s);\\n            adj[s].push_back(f);\\n        }\\n        return bfs(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    int bfs(int n){\\n        int cnt = 0;\\n        queue<int> q;\\n        vector<bool> visited(n,false);\\n        q.push(0);\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n            visited[front] = true;\\n            cnt++;\\n            for(auto it:adj[front]){\\n                if(!visited[it])\\n                    q.push(it);\\n            }\\n        }\\n        return cnt;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        adj = vector<vector<int>>(n);\\n        unordered_set<int> res;\\n        for(auto it:restricted)\\n            res.insert(it);\\n        for(int i=0;i<edges.size();i++){\\n            int f = edges[i][0],s = edges[i][1];\\n\\t\\t\\t//if either of the nodes are restricted, we exclude the current edge \\n            if(res.count(f) || res.count(s))\\n                continue;\\n            adj[f].push_back(s);\\n            adj[s].push_back(f);\\n        }\\n        return bfs(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396176,
                "title": "simple-dfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> adj[100007];\\n    int vis[100007];\\n    \\n    void dfs(int node)\\n    {\\n        vis[node]=1;\\n        for(auto it : adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        for(int i=0; i<n-1; i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        memset(vis, 0, sizeof vis);\\n        \\n        for(auto x : restricted)\\n        {\\n            vis[x]=2;\\n        }\\n        \\n        dfs(0);\\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(vis[i]==1)cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};``\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> adj[100007];\\n    int vis[100007];\\n    \\n    void dfs(int node)\\n    {\\n        vis[node]=1;\\n        for(auto it : adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        for(int i=0; i<n-1; i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        memset(vis, 0, sizeof vis);\\n        \\n        for(auto x : restricted)\\n        {\\n            vis[x]=2;\\n        }\\n        \\n        dfs(0);\\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(vis[i]==1)cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394729,
                "title": "striver-solutions-approach-normal-bfs-code-without-extra-change-in-bfs",
                "content": "**BREATH FIRST SEARCH (BFS)**\\n```\\nclass Solution {\\n    class Pair{\\n        int node;\\n        List<Integer> child;\\n        \\n        Pair(int node, List<Integer> child){\\n            this.node=node;\\n            this.child=child;\\n        }\\n    }\\n    public int reachableNodes(int n, int[][] edges, int[] rest) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Set<Integer> st=  new HashSet<>();\\n        \\n        for(int i=0;i<n;i++){\\n            res.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<rest.length;i++){\\n            st.add(rest[i]);\\n        }\\n        \\n        for(int []edge:edges){\\n            if(!res.get(edge[0]).contains(edge[1]))\\n            res.get(edge[0]).add(edge[1]);\\n            if(!res.get(edge[1]).contains(edge[0]))\\n            res.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        boolean vis[] = new boolean[n];\\n        Queue<Pair> q = new LinkedList<>();\\n        int count=0;\\n        q.add(new Pair(0,res.get(0)));\\n        while(!q.isEmpty()){\\n            Pair temp = q.poll();\\n            vis[temp.node]=true;\\n            if(st.contains(temp.node)){\\n                continue;\\n            }\\n            count++;\\n            for(int neigh:res.get(temp.node)){\\n                if(vis[neigh]==false){\\n                    q.add(new Pair(neigh,res.get(neigh)));\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    class Pair{\\n        int node;\\n        List<Integer> child;\\n        \\n        Pair(int node, List<Integer> child){\\n            this.node=node;\\n            this.child=child;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2394134,
                "title": "java-easy",
                "content": "``````\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n\\t//Dekho phale kya hai ki question me bola hai ki undirected graph hi matlb a to b and b to a connect hai\\n\\t//to mane ak Arrylist ka graph banaya  or us me ArrayList daali\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] nbr : edges) {\\n\\t\\t   //a to b\\n            graph[nbr[0]].add(nbr[1]);\\n\\t\\t\\t//b to a\\n            graph[nbr[1]].add(nbr[0]);\\n        }\\n\\t\\t//ak queue li hai jis se hum bfs chala sake\\n        LinkedList<Integer> q = new LinkedList<>();\\n\\t\\t//question me given hai zero se chale ga\\n        q.addLast(0);\\n\\t\\t//hash kuki jab hum bfs chale ge or bo node jis pe nhi jana bo aye ga to hashset se pta kare ge\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < restricted.length; i++) {\\n            set.add(restricted[i]);\\n        }\\n\\t\\t//ak node ko bar bar visit na kare\\n        boolean[] visit = new boolean[n];\\n        int count = 0;\\n        while (q.size() > 0) {\\n            int rem = q.removeFirst();\\n            if (visit[rem]) continue;\\n\\t\\t\\t//boi ki agar ye node non reachableNodes hai to aage nhi jana \\n            if (set.contains(rem)) continue;\\n            visit[rem] = true;\\n            ++count;\\n            for (int nbr : graph[rem]) {\\n                if (!visit[nbr]) {\\n                    // System.out.println(nbr);\\n                    q.addLast(nbr);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n//bina hashSet ke\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] nbr : edges) {\\n            graph[nbr[0]].add(nbr[1]);\\n            graph[nbr[1]].add(nbr[0]);\\n        }\\n        LinkedList<Integer> q = new LinkedList<>();\\n        q.addLast(0);\\n        boolean[] visit = new boolean[n];\\n        for (int i = 0; i < restricted.length; i++) {\\n            visit[restricted[i]] = true;\\n        }\\n        int count = 0;\\n        while (q.size() > 0) {\\n            int rem = q.removeFirst();\\n            if (visit[rem]) continue;\\n\\n            visit[rem] = true;\\n            ++count;\\n            for (int nbr : graph[rem]) {\\n                if (!visit[nbr]) {\\n                    // System.out.println(nbr);\\n                    q.addLast(nbr);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2392078,
                "title": "c-simple-bfs-detailed-explaination-marking-restricted-nodes-as-visited-before-dfs",
                "content": "we can mark restricted nodes as visited , then we can start dfs with 0 as source, and whenever we reach a new node while performing BFS, we increment out count by 1. after performing dfs, this count will give us maximum number of nodes we can reach from node 0 without visiting a restricted node.\\nIn this BFS, we would automatically not visit the restricted nodes, as they would have been already marked visited before performing BFS.\\n\\n```\\nclass Solution {\\npublic:\\n    void BFS(int node, map<int,vector<int>> &g, vector<int> &vis){\\n        vis[node] = 1;\\n        \\n        for(auto it:g[node]){\\n            if(!vis[it]){\\n                BFS(it,g,vis);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) {\\n        map<int,vector<int>> g;\\n        \\n        for(int i= 0;i<edges.size();i++){\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            \\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        \\n        \\n        vector<int> vis(n,0);\\n        \\n        \\n        for(int i=0;i<r.size();i++){\\n            vis[r[i]] = 2;\\n        }\\n        \\n        int ans = 0;\\n        \\n        BFS(0,g,vis);\\n        \\n        for(int i=0;i<n;i++){\\n            if(vis[i] == 1) {\\n                ans ++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Do not forget to upvote if you like the solution**\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void BFS(int node, map<int,vector<int>> &g, vector<int> &vis){\\n        vis[node] = 1;\\n        \\n        for(auto it:g[node]){\\n            if(!vis[it]){\\n                BFS(it,g,vis);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) {\\n        map<int,vector<int>> g;\\n        \\n        for(int i= 0;i<edges.size();i++){\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            \\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        \\n        \\n        vector<int> vis(n,0);\\n        \\n        \\n        for(int i=0;i<r.size();i++){\\n            vis[r[i]] = 2;\\n        }\\n        \\n        int ans = 0;\\n        \\n        BFS(0,g,vis);\\n        \\n        for(int i=0;i<n;i++){\\n            if(vis[i] == 1) {\\n                ans ++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391545,
                "title": "bfs-c",
                "content": "class Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>adj[n];\\n        set<int>st;\\n        for(auto it:restricted)\\n        {\\n            st.insert(it);\\n        }\\n        int m=edges.size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<2;j++)\\n            {\\n                adj[edges[i][0]].push_back(edges[i][1]);\\n                adj[edges[i][1]].push_back(edges[i][0]);\\n            }\\n        }\\n        queue<int>q;\\n        vector<int>v(n,0);\\n        int count=0;\\n        q.push(0);\\n        v[0]=1;\\n        count++;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(v[it]==0)\\n                {\\n                    if(st.find(it)!=st.end())\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        q.push(it);\\n                        v[it]=1;\\n                        count++;\\n                    }\\n                }\\n            }  \\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n[](http://)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>adj[n];\\n        set<int>st;\\n        for(auto it:restricted)\\n        {\\n            st.insert(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2391343,
                "title": "use-only-map-logic-no-need-of-this-dangerous-word-dfs",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int[] e : edges){\\n            \\n            if(!map.containsKey(e[0])){\\n                map.put(e[0], new ArrayList<Integer>());\\n            }\\n            if(!map.containsKey(e[1])){\\n                map.put(e[1], new ArrayList<Integer>());\\n            }\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        \\n                   \\n        }\\n        boolean[] visited = new boolean[n];\\n        for(int r : restricted){\\n            visited[r] = true;\\n        }\\n        \\n        \\n        for(int i : map.get(0)){\\n            System.out.print(i + \" \");\\n        }\\n        System.out.println();\\n        int count = traverseToEachNode(map,visited,0);\\n        return count;\\n    }\\n    \\n    \\n    private int traverseToEachNode(Map<Integer,List<Integer>> map, boolean[] visited,int node){\\n        int count = 1;\\n        if(visited[node] == true){\\n            return 0;\\n        }\\n        visited[node] = true;\\n                   \\n        for(int i : map.get(node)){\\n\\n            count += traverseToEachNode(map,visited,i);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int[] e : edges){\\n            \\n            if(!map.containsKey(e[0])){\\n                map.put(e[0], new ArrayList<Integer>());\\n            }\\n            if(!map.containsKey(e[1])){\\n                map.put(e[1], new ArrayList<Integer>());\\n            }\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        \\n                   \\n        }\\n        boolean[] visited = new boolean[n];\\n        for(int r : restricted){\\n            visited[r] = true;\\n        }\\n        \\n        \\n        for(int i : map.get(0)){\\n            System.out.print(i + \" \");\\n        }\\n        System.out.println();\\n        int count = traverseToEachNode(map,visited,0);\\n        return count;\\n    }\\n    \\n    \\n    private int traverseToEachNode(Map<Integer,List<Integer>> map, boolean[] visited,int node){\\n        int count = 1;\\n        if(visited[node] == true){\\n            return 0;\\n        }\\n        visited[node] = true;\\n                   \\n        for(int i : map.get(node)){\\n\\n            count += traverseToEachNode(map,visited,i);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391082,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(V + E)***\\n\\n* ***Space Complexity :- O(V + E)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[], int u, vector<bool>& vis, int &count)\\n    {\\n        // increment count\\n        \\n        count++;\\n        \\n        // mark curr node as visited\\n        \\n        vis[u] = true;\\n        \\n        // traverse all the adjacent node which is not visited\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(vis[v] == false)\\n            {\\n                dfs(adj, v, vis, count);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        // create a adjacency list\\n        \\n        vector<int> adj[n];\\n        \\n        for(auto x : edges)\\n        {\\n            int u = x[0];\\n            \\n            int v = x[1];\\n            \\n            adj[u].push_back(v);\\n            \\n            adj[v].push_back(u);\\n        }\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        // mark all the restricted node as visited\\n        \\n        for(auto x : restricted)\\n        {\\n            vis[x] = true;\\n        }\\n        \\n        // now count maximum no of node that can be reached from 0\\n        \\n        int count = 0;\\n        \\n        dfs(adj, 0, vis, count);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[], int u, vector<bool>& vis, int &count)\\n    {\\n        // increment count\\n        \\n        count++;\\n        \\n        // mark curr node as visited\\n        \\n        vis[u] = true;\\n        \\n        // traverse all the adjacent node which is not visited\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(vis[v] == false)\\n            {\\n                dfs(adj, v, vis, count);\\n            }\\n        }\\n    }\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        // create a adjacency list\\n        \\n        vector<int> adj[n];\\n        \\n        for(auto x : edges)\\n        {\\n            int u = x[0];\\n            \\n            int v = x[1];\\n            \\n            adj[u].push_back(v);\\n            \\n            adj[v].push_back(u);\\n        }\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        // mark all the restricted node as visited\\n        \\n        for(auto x : restricted)\\n        {\\n            vis[x] = true;\\n        }\\n        \\n        // now count maximum no of node that can be reached from 0\\n        \\n        int count = 0;\\n        \\n        dfs(adj, 0, vis, count);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391078,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dfs",
                "content": "```C#\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        Dictionary<int, List<int>> d = new ();\\n        for (int i = 0; i < edges.Length; i++) {\\n            if (!d.ContainsKey(edges[i][0])) d[edges[i][0]] = new ();\\n            d[edges[i][0]].Add(edges[i][1]);\\n            \\n            if (!d.ContainsKey(edges[i][1])) d[edges[i][1]] = new ();\\n            d[edges[i][1]].Add(edges[i][0]);\\n        }\\n        \\n        HashSet<int> h = new ();\\n        for (int i = 0; i < restricted.Length; i++) h.Add(restricted[i]);\\n    \\n        bool[] visited = new bool[n];\\n        return Solve(0);\\n        \\n        int Solve(int node) {\\n            if (h.Contains(node) || visited[node]) return 0;\\n            \\n            int count = 1;\\n            visited[node] = true;\\n            if (d.ContainsKey(node)) {\\n                foreach (int connectedNode in d[node]) count += Solve(connectedNode);\\n            }\\n            \\n            return count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        Dictionary<int, List<int>> d = new ();\\n        for (int i = 0; i < edges.Length; i++) {\\n            if (!d.ContainsKey(edges[i][0])) d[edges[i][0]] = new ();\\n            d[edges[i][0]].Add(edges[i][1]);\\n            \\n            if (!d.ContainsKey(edges[i][1])) d[edges[i][1]] = new ();\\n            d[edges[i][1]].Add(edges[i][0]);\\n        }\\n        \\n        HashSet<int> h = new ();\\n        for (int i = 0; i < restricted.Length; i++) h.Add(restricted[i]);\\n    \\n        bool[] visited = new bool[n];\\n        return Solve(0);\\n        \\n        int Solve(int node) {\\n            if (h.Contains(node) || visited[node]) return 0;\\n            \\n            int count = 1;\\n            visited[node] = true;\\n            if (d.ContainsKey(node)) {\\n                foreach (int connectedNode in d[node]) count += Solve(connectedNode);\\n            }\\n            \\n            return count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391039,
                "title": "java-dfs-recursion-commented-code-with-time-and-space-complexity",
                "content": "### Java Solution Using DFS:\\n\\n```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        /*\\n            Storing the restricted nodes in a hashset so as to check whether a node is restricted or not\\n            in a constant time.\\n        */\\n        Set<Integer> restrictedNodes = new HashSet<>();\\n        for(int node: restricted)\\n            restrictedNodes.add(node);\\n        \\n        //Storing the edges from each node in a map.\\n        Map<Integer, List<Integer>> e = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            List<Integer> paths1 = e.getOrDefault(edges[i][0], new ArrayList<>());\\n            List<Integer> paths2 = e.getOrDefault(edges[i][1], new ArrayList<>());\\n            \\n            paths1.add(edges[i][1]);\\n            paths2.add(edges[i][0]);\\n            \\n            e.put(edges[i][0], paths1);\\n            e.put(edges[i][1], paths2);\\n            \\n        }\\n        \\n        //Creating a boolean array visited, so as to avoid visiting any node repeatedly.\\n        boolean[] visited = new boolean[edges.length + 1];\\n        \\n        return countNodes(0, e, restrictedNodes, visited);\\n    }\\n    \\n    private int countNodes(int currNode, Map<Integer, List<Integer>> m, Set<Integer> r, boolean[] visited) {\\n        //If the node is restricted.\\n        if(r.contains(currNode))\\n            return 0;\\n        \\n        //Get every node(path) which could be visited from the current node.\\n        List<Integer> paths = m.get(currNode);\\n        \\n        //DFS: Explore evey path; initializing ans = 1 so as to denote that this current node has been counted.\\n        int ans = 1;\\n        for(int i = 0; i < paths.size(); i++) {\\n            //Marking visited for the currNode to true so that it won\\'t be explored again further.\\n            visited[currNode] = true;\\n            //Checking if the next node has already been explored or not.\\n            if(!visited[paths.get(i)])\\n                ans += countNodes(paths.get(i), m, r, visited);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Time Complexity:** **O(R)** (For Putting Restricted Nodes in HashSet) + **O(N)** (For putting edges in HashMap, **considering keys only**) + **O(N)** (For exploring every node) = **O(N)**\\n\\n**Space Complexity:** **O(R)** (For putting Restricted Nodes) + **O(2(N - 1))** (For putting all the edges + **O(N)**(Visited array) = **O(N)** (Equivalent to O(N))\\n\\n**Auxiliary Space:** **O(N)**, if nodes would have been linked consecutively, at max recusive stack would be storing N calls to the function.\\n\\n#### Please correct me, if I am wrong, I am learning and it would help me in improvizing.\\n#### Thanks and Happy Coding!",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        /*\\n            Storing the restricted nodes in a hashset so as to check whether a node is restricted or not\\n            in a constant time.\\n        */\\n        Set<Integer> restrictedNodes = new HashSet<>();\\n        for(int node: restricted)\\n            restrictedNodes.add(node);\\n        \\n        //Storing the edges from each node in a map.\\n        Map<Integer, List<Integer>> e = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            List<Integer> paths1 = e.getOrDefault(edges[i][0], new ArrayList<>());\\n            List<Integer> paths2 = e.getOrDefault(edges[i][1], new ArrayList<>());\\n            \\n            paths1.add(edges[i][1]);\\n            paths2.add(edges[i][0]);\\n            \\n            e.put(edges[i][0], paths1);\\n            e.put(edges[i][1], paths2);\\n            \\n        }\\n        \\n        //Creating a boolean array visited, so as to avoid visiting any node repeatedly.\\n        boolean[] visited = new boolean[edges.length + 1];\\n        \\n        return countNodes(0, e, restrictedNodes, visited);\\n    }\\n    \\n    private int countNodes(int currNode, Map<Integer, List<Integer>> m, Set<Integer> r, boolean[] visited) {\\n        //If the node is restricted.\\n        if(r.contains(currNode))\\n            return 0;\\n        \\n        //Get every node(path) which could be visited from the current node.\\n        List<Integer> paths = m.get(currNode);\\n        \\n        //DFS: Explore evey path; initializing ans = 1 so as to denote that this current node has been counted.\\n        int ans = 1;\\n        for(int i = 0; i < paths.size(); i++) {\\n            //Marking visited for the currNode to true so that it won\\'t be explored again further.\\n            visited[currNode] = true;\\n            //Checking if the next node has already been explored or not.\\n            if(!visited[paths.get(i)])\\n                ans += countNodes(paths.get(i), m, r, visited);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391031,
                "title": "rust-dfs",
                "content": "~~~\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn reachable_nodes(n: i32, edges: Vec<Vec<i32>>, restricted: Vec<i32>) -> i32 {\\n        let mut graph: Vec<Vec<usize>> = vec![vec![]; n as usize];\\n        let mut s: HashSet<usize> = HashSet::new();\\n        \\n        for r in restricted { s.insert(r as usize); }\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            if s.contains(&u) || s.contains(&v) { continue; }\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        \\n        if s.contains(&0) { return 0 }\\n        \\n        let mut sk: Vec<usize> = vec![];\\n        let mut ret = 0;\\n        let mut flag = vec![0; n as usize];\\n        \\n        sk.push(0);\\n        flag[0] = 1;\\n        while let Some(u) = sk.pop() {\\n            ret += 1;\\n            for v in &graph[u] {\\n                if flag[*v] == 1 { continue; }\\n                flag[*v] = 1;\\n                sk.push(*v);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "~~~\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn reachable_nodes(n: i32, edges: Vec<Vec<i32>>, restricted: Vec<i32>) -> i32 {\\n        let mut graph: Vec<Vec<usize>> = vec![vec![]; n as usize];\\n        let mut s: HashSet<usize> = HashSet::new();\\n        \\n        for r in restricted { s.insert(r as usize); }\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            if s.contains(&u) || s.contains(&v) { continue; }\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        \\n        if s.contains(&0) { return 0 }\\n        \\n        let mut sk: Vec<usize> = vec![];\\n        let mut ret = 0;\\n        let mut flag = vec![0; n as usize];\\n        \\n        sk.push(0);\\n        flag[0] = 1;\\n        while let Some(u) = sk.pop() {\\n            ret += 1;\\n            for v in &graph[u] {\\n                if flag[*v] == 1 { continue; }\\n                flag[*v] = 1;\\n                sk.push(*v);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2390865,
                "title": "c-dfs-recursion-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int> vis(n,0);\\n        for(auto x:restricted)\\n            vis[x]=1;\\n        dfs(adj,vis,0);\\n        int res=0;\\n        for(auto x:vis)\\n            res+=x;\\n        res-=restricted.size();\\n        return res;\\n    }\\n    void dfs(vector<vector<int>>& adj,vector<int>& vis,int n)\\n    {\\n        vis[n]=1;\\n        for(auto x:adj[n])\\n        {\\n            if(vis[x]==0)\\n                dfs(adj,vis,x);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int> vis(n,0);\\n        for(auto x:restricted)\\n            vis[x]=1;\\n        dfs(adj,vis,0);\\n        int res=0;\\n        for(auto x:vis)\\n            res+=x;\\n        res-=restricted.size();\\n        return res;\\n    }\\n    void dfs(vector<vector<int>>& adj,vector<int>& vis,int n)\\n    {\\n        vis[n]=1;\\n        for(auto x:adj[n])\\n        {\\n            if(vis[x]==0)\\n                dfs(adj,vis,x);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390857,
                "title": "java-dfs-easy-count",
                "content": "```\\nclass Solution {\\n    boolean[] visited;\\n    int count=0;\\n    LinkedList<Integer> adj[];\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        adj=new LinkedList[n];\\n        visited=new boolean[n];\\n        for(int i=0;i<restricted.length;i++){\\n            visited[restricted[i]]=true;\\n        }\\n        for (int i = 0; i < n; i++)  \\n            adj[i] = new LinkedList<Integer>();  \\n        for(int a[]:edges){\\n            adj[a[0]].add(a[1]);\\n            adj[a[1]].add(a[0]);\\n        }\\n        dfs(0);\\n        return count;\\n    }\\n    public void dfs(int vertex){\\n        visited[vertex]=true;\\n        count++;\\n        Iterator<Integer> ite = adj[vertex].listIterator();\\n        while (ite.hasNext()) {\\n            int ad = ite.next();\\n            if (!visited[ad])\\n                dfs(ad);\\n        }\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH THEN PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] visited;\\n    int count=0;\\n    LinkedList<Integer> adj[];\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        adj=new LinkedList[n];\\n        visited=new boolean[n];\\n        for(int i=0;i<restricted.length;i++){\\n            visited[restricted[i]]=true;\\n        }\\n        for (int i = 0; i < n; i++)  \\n            adj[i] = new LinkedList<Integer>();  \\n        for(int a[]:edges){\\n            adj[a[0]].add(a[1]);\\n            adj[a[1]].add(a[0]);\\n        }\\n        dfs(0);\\n        return count;\\n    }\\n    public void dfs(int vertex){\\n        visited[vertex]=true;\\n        count++;\\n        Iterator<Integer> ite = adj[vertex].listIterator();\\n        while (ite.hasNext()) {\\n            int ad = ite.next();\\n            if (!visited[ad])\\n                dfs(ad);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390856,
                "title": "secret-python-answer-dfs",
                "content": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        \\n        e = defaultdict(set)\\n        restricted = set(restricted)\\n        for ed in edges:\\n\\n            if ed[1] not in restricted and ed[0] not in restricted:\\n                e[ed[0]].add(ed[1])\\n                e[ed[1]].add(ed[0])\\n                \\n        \\n\\n        visited = set()\\n\\n        def dfs(node):\\n            if node in visited:\\n                return \\n            \\n            visited.add(node)\\n            self.total+=1\\n            \\n            for s in e[node]:\\n                dfs(s)\\n\\n        \\n        self.total = 1\\n        visited.add(0)\\n        for s in e[0]:\\n            dfs(s)\\n        \\n        return self.total\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        \\n        e = defaultdict(set)\\n        restricted = set(restricted)\\n        for ed in edges:\\n\\n            if ed[1] not in restricted and ed[0] not in restricted:\\n                e[ed[0]].add(ed[1])\\n                e[ed[1]].add(ed[0])\\n                \\n        \\n\\n        visited = set()\\n\\n        def dfs(node):\\n            if node in visited:\\n                return \\n            \\n            visited.add(node)\\n            self.total+=1\\n            \\n            for s in e[node]:\\n                dfs(s)\\n\\n        \\n        self.total = 1\\n        visited.add(0)\\n        for s in e[0]:\\n            dfs(s)\\n        \\n        return self.total\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2390800,
                "title": "recursive-simple-ish-solution",
                "content": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        \\n        rest = set(restricted)\\n        \\n        for i, j in edges:\\n            d[i].add(j)\\n            d[j].add(i)\\n            \\n        count = 0\\n        \\n        added = set()\\n        \\n        self.count = 0\\n        \\n        self.recus(0, d, rest, added)\\n        \\n        return self.count\\n        \\n        \\n    def recus(self, val, d, rest, s):\\n        if val in rest:\\n            return 0\\n        if val in s:\\n            return 0\\n        s.add(val)\\n        for i in d[val]:\\n            \\n            self.recus(i, d, rest, s)\\n            \\n        self.count += 1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        \\n        rest = set(restricted)\\n        \\n        for i, j in edges:\\n            d[i].add(j)\\n            d[j].add(i)\\n            \\n        count = 0\\n        \\n        added = set()\\n        \\n        self.count = 0\\n        \\n        self.recus(0, d, rest, added)\\n        \\n        return self.count\\n        \\n        \\n    def recus(self, val, d, rest, s):\\n        if val in rest:\\n            return 0\\n        if val in s:\\n            return 0\\n        s.add(val)\\n        for i in d[val]:\\n            \\n            self.recus(i, d, rest, s)\\n            \\n        self.count += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390771,
                "title": "dfs-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    void dfs(int i,vector<int> &vis,vector<int> adj[]){\\n        if(vis[i]==1) return;\\n        if(mp.find(i)!=mp.end()){\\n            vis[i]=-2;\\n            return;\\n        }\\n        vis[i]=1;\\n        for(auto j:adj[i]){\\n            if(vis[j]==-1){\\n                dfs(j,vis,adj);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(auto i:restricted) mp[i++];\\n        vector<int> vis(n,-1);\\n        dfs(0,vis,adj);\\n        int cnt=0;\\n        for(auto i:vis){\\n            if(i>0) cnt++;\\n        } \\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    map<int,int> mp;\\n    void dfs(int i,vector<int> &vis,vector<int> adj[]){\\n        if(vis[i]==1) return;\\n        if(mp.find(i)!=mp.end()){\\n            vis[i]=-2;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2390743,
                "title": "bfs-cpp",
                "content": "\\n**TC : O(N)\\nSC : O(N)**\\n```\\n\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        unordered_set<int> res (restricted.begin() , restricted.end());\\n        vector<int> adj[n];\\n        for(auto e: edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vector<int> vis(n , 0);\\n        while(q.size()){\\n            int sz = q.size();\\n            while(sz--){\\n                int node = q.front(); q.pop();\\n                vis[node] = 1;\\n                \\n                for(int it : adj[node]){\\n                    if(vis[it] )continue;\\n                    if(res.count(it)) continue;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i< n; i++) {\\n            if(vis[i] == 1) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        unordered_set<int> res (restricted.begin() , restricted.end());\\n        vector<int> adj[n];\\n        for(auto e: edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vector<int> vis(n , 0);\\n        while(q.size()){\\n            int sz = q.size();\\n            while(sz--){\\n                int node = q.front(); q.pop();\\n                vis[node] = 1;\\n                \\n                for(int it : adj[node]){\\n                    if(vis[it] )continue;\\n                    if(res.count(it)) continue;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i< n; i++) {\\n            if(vis[i] == 1) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390733,
                "title": "can-we-use-dsu-to-solve-this-problem",
                "content": "disjoint set union is there any way?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2390716,
                "title": "python-3-dfs",
                "content": "\\tclass Solution:\\n\\t\\tdef reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\t\\tG=[[] for _ in range(n)]\\n\\t\\t\\tfor u,v in edges:\\n\\t\\t\\t\\tG[v].append(u)\\n\\t\\t\\t\\tG[u].append(v)\\n\\t\\t\\ta=set(restricted)\\n\\t\\t\\tdef dfs(node,parent):\\n\\t\\t\\t\\tif node in a:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tb=0\\n\\t\\t\\t\\tfor child in G[node]:\\n\\t\\t\\t\\t\\tif child==parent:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tb+=dfs(child,node)\\n\\t\\t\\t\\treturn 1+b\\n\\t\\t\\treturn dfs(0,None)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\t\\tG=[[] for _ in range(n)]\\n\\t\\t\\tfor u,v in edges:\\n\\t\\t\\t\\tG[v].append(u)\\n\\t\\t\\t\\tG[u].append(v)\\n\\t\\t\\ta=set(restricted)\\n\\t\\t\\tdef dfs(node,parent):\\n\\t\\t\\t\\tif node in a:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tb=0\\n\\t\\t\\t\\tfor child in G[node]:\\n\\t\\t\\t\\t\\tif child==parent:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tb+=dfs(child,node)\\n\\t\\t\\t\\treturn 1+b\\n\\t\\t\\treturn dfs(0,None)",
                "codeTag": "Java"
            },
            {
                "id": 2390706,
                "title": "javascript-graph-dfs-tc-o-n-e-sc-o-n",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} restricted\\n * @return {number}\\n */\\nvar reachableNodes = function(n, edges, restricted) {\\n    const adj = {};\\n    \\n    for (const [u, v] of edges) {\\n        if (adj[u]) {\\n            adj[u].add(v);\\n        } else {\\n            adj[u] = new Set().add(v);\\n        }\\n        if (adj[v]) {\\n            adj[v].add(u);\\n        } else {\\n            adj[v] = new Set().add(u);\\n        }\\n    }\\n    \\n    const restrictedSet = new Set(restricted);\\n    const visited = new Set();\\n    \\n    let ans = 0;\\n    \\n    function dfs(node) {\\n        if (restrictedSet.has(node) || visited.has(node)) {\\n            return;\\n        }\\n        \\n        ans++;\\n        visited.add(node);\\n        \\n        for (const adjNode of adj[node]) {\\n            dfs(adjNode);\\n        }\\n    }\\n    \\n    dfs(0);\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} restricted\\n * @return {number}\\n */\\nvar reachableNodes = function(n, edges, restricted) {\\n    const adj = {};\\n    \\n    for (const [u, v] of edges) {\\n        if (adj[u]) {\\n            adj[u].add(v);\\n        } else {\\n            adj[u] = new Set().add(v);\\n        }\\n        if (adj[v]) {\\n            adj[v].add(u);\\n        } else {\\n            adj[v] = new Set().add(u);\\n        }\\n    }\\n    \\n    const restrictedSet = new Set(restricted);\\n    const visited = new Set();\\n    \\n    let ans = 0;\\n    \\n    function dfs(node) {\\n        if (restrictedSet.has(node) || visited.has(node)) {\\n            return;\\n        }\\n        \\n        ans++;\\n        visited.add(node);\\n        \\n        for (const adjNode of adj[node]) {\\n            dfs(adjNode);\\n        }\\n    }\\n    \\n    dfs(0);\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390669,
                "title": "simple-java-bfs",
                "content": "\\n\\n```\\n    public static int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> restrictedSet = Arrays.stream(restricted).boxed().collect(Collectors.toSet());\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n\\n        for (int[] edge : edges){\\n            graph.putIfAbsent(edge[0], new HashSet<>());\\n            graph.putIfAbsent(edge[1], new HashSet<>());\\n\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        queue.add(0);\\n        visited.add(0);\\n\\n        while (!queue.isEmpty()){\\n            int current = queue.poll();\\n\\n            for (int neighbor : graph.get(current)){\\n                if ((!restrictedSet.contains(neighbor)) && (!visited.contains(neighbor))){\\n                    queue.add(neighbor);\\n                    visited.add(neighbor);\\n                }\\n            }\\n        }\\n\\n        return visited.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> restrictedSet = Arrays.stream(restricted).boxed().collect(Collectors.toSet());\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n\\n        for (int[] edge : edges){\\n            graph.putIfAbsent(edge[0], new HashSet<>());\\n            graph.putIfAbsent(edge[1], new HashSet<>());\\n\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        queue.add(0);\\n        visited.add(0);\\n\\n        while (!queue.isEmpty()){\\n            int current = queue.poll();\\n\\n            for (int neighbor : graph.get(current)){\\n                if ((!restrictedSet.contains(neighbor)) && (!visited.contains(neighbor))){\\n                    queue.add(neighbor);\\n                    visited.add(neighbor);\\n                }\\n            }\\n        }\\n\\n        return visited.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390664,
                "title": "python3-dfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/efb9e28eb957e92a045ca4abae50d7e022d9ead5) for solutions of weekly 305. \\n\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        ans = 0 \\n        seen = set(restricted)\\n        stack = [0]\\n        while stack: \\n            u = stack.pop()\\n            ans += 1\\n            seen.add(u)\\n            for v in graph[u]: \\n                if v not in seen: stack.append(v)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        ans = 0 \\n        seen = set(restricted)\\n        stack = [0]\\n        while stack: \\n            u = stack.pop()\\n            ans += 1\\n            seen.add(u)\\n            for v in graph[u]: \\n                if v not in seen: stack.append(v)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390646,
                "title": "rust-dfs-recursive-and-bfs",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc2368)\\n\\n<b>Problem List</b>\\n#UndirectedGraph - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/graph/by_data_structure/undirected_graph)\\n#DFS - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/search/depth_first_search)\\n#BFS - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/search/breath_first_search)\\n\\n```\\nuse std::collections::HashSet;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/reachable-nodes-with-restrictions/\\n/// Time Complexity:    O(V + E) ~ O(`n` + `_len_es`)\\n/// Space Complexity:   O(V + E) ~ O(`n` + `_len_es`)\\nimpl Solution {\\n    pub fn reachable_nodes(n: i32, edges: Vec<Vec<i32>>, restricted: Vec<i32>) -> i32 {\\n\\t\\tlet _len_es: usize = edges.len();\\n        let graph: Vec<Vec<usize>> = Self::build_graph(n as usize, &edges);\\n        let mut seen: HashSet<usize> = {\\n            let mut seen: HashSet<usize> = restricted.into_iter().map(|e| e as usize).collect();\\n            seen.insert(0);\\n            seen\\n        };\\n        let mut res: Vec<usize> = vec![0];\\n        Self::dfs(0, &mut seen, &graph, &mut res);\\n        res.len() as i32\\n    }\\n    fn dfs(cur: usize, seen: &mut HashSet<usize>, graph: &Vec<Vec<usize>>, res: &mut Vec<usize>){\\n        for &nxt in &graph[cur]{\\n            if seen.insert(nxt){\\n                res.push(nxt);\\n                Self::dfs(nxt, seen, graph, res);\\n            }\\n        }\\n    }\\n    fn build_graph(n: usize, edges: &Vec<Vec<i32>>) -> Vec<Vec<usize>>{\\n        let mut graph: Vec<Vec<usize>> = vec![Vec::with_capacity(n); n];\\n        for edge in edges{\\n            let u: usize = edge[0] as usize;\\n            let v: usize = edge[1] as usize;\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        } \\n        graph\\n    }\\n}\\n```\\n\\n\\n```\\nuse std::collections::{HashSet, VecDeque};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/reachable-nodes-with-restrictions/\\n/// Time Complexity:    O(V + E) ~ O(`n` + `_len_es`)\\n/// Space Complexity:   O(V + E) ~ O(`n` + `_len_es`)\\nimpl Solution {\\n    pub fn reachable_nodes(n: i32, edges: Vec<Vec<i32>>, restricted: Vec<i32>) -> i32 {\\n        let _len_es: usize = edges.len();\\n        let n: usize = n as usize;\\n        let graph: Vec<Vec<usize>> = Self::build_graph(n as usize, &edges);\\n        let mut seen: HashSet<usize> = {\\n            let mut seen: HashSet<usize> = restricted.into_iter().map(|e| e as usize).collect();\\n            seen.insert(0);\\n            seen\\n        };\\n        let mut res: Vec<usize> = {\\n            let mut res: Vec<usize> = Vec::with_capacity(n);\\n            res.push(0);\\n            res\\n        };\\n        let mut queue: VecDeque<usize> = {\\n            let mut queue = VecDeque::with_capacity(n);\\n            queue.push_back(0);\\n            queue\\n        };\\n        while !queue.is_empty() {\\n            let len_q: usize = queue.len();\\n            for _ in 0..len_q {\\n                if let Some(cur) = queue.pop_front() {\\n                    for &nxt in &graph[cur] {\\n                        if seen.insert(nxt) {\\n                            res.push(nxt);\\n                            queue.push_back(nxt);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        res.len() as i32\\n    }\\n    fn build_graph(n: usize, edges: &Vec<Vec<i32>>) -> Vec<Vec<usize>> {\\n        let mut graph: Vec<Vec<usize>> = vec![Vec::with_capacity(n); n];\\n        for edge in edges {\\n            let u: usize = edge[0] as usize;\\n            let v: usize = edge[1] as usize;\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        graph\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/reachable-nodes-with-restrictions/\\n/// Time Complexity:    O(V + E) ~ O(`n` + `_len_es`)\\n/// Space Complexity:   O(V + E) ~ O(`n` + `_len_es`)\\nimpl Solution {\\n    pub fn reachable_nodes(n: i32, edges: Vec<Vec<i32>>, restricted: Vec<i32>) -> i32 {\\n\\t\\tlet _len_es: usize = edges.len();\\n        let graph: Vec<Vec<usize>> = Self::build_graph(n as usize, &edges);\\n        let mut seen: HashSet<usize> = {\\n            let mut seen: HashSet<usize> = restricted.into_iter().map(|e| e as usize).collect();\\n            seen.insert(0);\\n            seen\\n        };\\n        let mut res: Vec<usize> = vec![0];\\n        Self::dfs(0, &mut seen, &graph, &mut res);\\n        res.len() as i32\\n    }\\n    fn dfs(cur: usize, seen: &mut HashSet<usize>, graph: &Vec<Vec<usize>>, res: &mut Vec<usize>){\\n        for &nxt in &graph[cur]{\\n            if seen.insert(nxt){\\n                res.push(nxt);\\n                Self::dfs(nxt, seen, graph, res);\\n            }\\n        }\\n    }\\n    fn build_graph(n: usize, edges: &Vec<Vec<i32>>) -> Vec<Vec<usize>>{\\n        let mut graph: Vec<Vec<usize>> = vec![Vec::with_capacity(n); n];\\n        for edge in edges{\\n            let u: usize = edge[0] as usize;\\n            let v: usize = edge[1] as usize;\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        } \\n        graph\\n    }\\n}\\n```\n```\\nuse std::collections::{HashSet, VecDeque};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/reachable-nodes-with-restrictions/\\n/// Time Complexity:    O(V + E) ~ O(`n` + `_len_es`)\\n/// Space Complexity:   O(V + E) ~ O(`n` + `_len_es`)\\nimpl Solution {\\n    pub fn reachable_nodes(n: i32, edges: Vec<Vec<i32>>, restricted: Vec<i32>) -> i32 {\\n        let _len_es: usize = edges.len();\\n        let n: usize = n as usize;\\n        let graph: Vec<Vec<usize>> = Self::build_graph(n as usize, &edges);\\n        let mut seen: HashSet<usize> = {\\n            let mut seen: HashSet<usize> = restricted.into_iter().map(|e| e as usize).collect();\\n            seen.insert(0);\\n            seen\\n        };\\n        let mut res: Vec<usize> = {\\n            let mut res: Vec<usize> = Vec::with_capacity(n);\\n            res.push(0);\\n            res\\n        };\\n        let mut queue: VecDeque<usize> = {\\n            let mut queue = VecDeque::with_capacity(n);\\n            queue.push_back(0);\\n            queue\\n        };\\n        while !queue.is_empty() {\\n            let len_q: usize = queue.len();\\n            for _ in 0..len_q {\\n                if let Some(cur) = queue.pop_front() {\\n                    for &nxt in &graph[cur] {\\n                        if seen.insert(nxt) {\\n                            res.push(nxt);\\n                            queue.push_back(nxt);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        res.len() as i32\\n    }\\n    fn build_graph(n: usize, edges: &Vec<Vec<i32>>) -> Vec<Vec<usize>> {\\n        let mut graph: Vec<Vec<usize>> = vec![Vec::with_capacity(n); n];\\n        for edge in edges {\\n            let u: usize = edge[0] as usize;\\n            let v: usize = edge[1] as usize;\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        graph\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390644,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_set<int>s;\\n        for(int x:restricted) s.insert(x);\\n        if(s.find(0)!=s.end()) return 0;\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int>visited(n,0);\\n        int ans=0;\\n        queue<int>q;\\n        q.push(0);\\n        visited[0]=1;\\n        while(q.size()){\\n            int count=q.size();\\n            while(count--){\\n                int x=q.front();\\n                q.pop();\\n                ans++;\\n                for(int i:adj[x]){\\n                    if(s.find(i)==s.end() && !visited[i]){\\n                        q.push(i);\\n                        visited[i]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        unordered_set<int>s;\\n        for(int x:restricted) s.insert(x);\\n        if(s.find(0)!=s.end()) return 0;\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int>visited(n,0);\\n        int ans=0;\\n        queue<int>q;\\n        q.push(0);\\n        visited[0]=1;\\n        while(q.size()){\\n            int count=q.size();\\n            while(count--){\\n                int x=q.front();\\n                q.pop();\\n                ans++;\\n                for(int i:adj[x]){\\n                    if(s.find(i)==s.end() && !visited[i]){\\n                        q.push(i);\\n                        visited[i]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390627,
                "title": "java-graph-bfs",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        Set<Integer> restrictSet = new HashSet<>();\\n        buildGraph(graph, edges);\\n        buildRestrictNode(restrictSet, restricted);\\n        return traverse(graph, restrictSet);\\n    }\\n    \\n    private int traverse(Map<Integer, List<Integer>> graph, Set<Integer> restrictSet) {\\n        int res = 1;\\n        Set<Integer> seen = new HashSet<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        seen.add(0);\\n        \\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                int curNode = q.poll();\\n                \\n                for(int nextNode : graph.get(curNode)) {\\n                    if(seen.contains(nextNode) || restrictSet.contains(nextNode)) {\\n                        continue;\\n                    }\\n                    q.offer(nextNode);\\n                    seen.add(nextNode);\\n                    res++;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    private void buildRestrictNode(Set<Integer> restrictSet, int[] restricted) {\\n        for(int i : restricted) {\\n            restrictSet.add(i);\\n        }\\n    }\\n    \\n    private void buildGraph(Map<Integer, List<Integer>> graph, int[][] edges) {\\n        for(int[] curEdge : edges) {\\n            int start = curEdge[0];\\n            int end = curEdge[1];\\n            if(!graph.containsKey(start)) {\\n                graph.put(start, new ArrayList<>());\\n            }\\n            if(!graph.containsKey(end)) {\\n                graph.put(end, new ArrayList<>());\\n            }\\n            \\n            graph.get(start).add(end);\\n            graph.get(end).add(start);\\n            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        Set<Integer> restrictSet = new HashSet<>();\\n        buildGraph(graph, edges);\\n        buildRestrictNode(restrictSet, restricted);\\n        return traverse(graph, restrictSet);\\n    }\\n    \\n    private int traverse(Map<Integer, List<Integer>> graph, Set<Integer> restrictSet) {\\n        int res = 1;\\n        Set<Integer> seen = new HashSet<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        seen.add(0);\\n        \\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                int curNode = q.poll();\\n                \\n                for(int nextNode : graph.get(curNode)) {\\n                    if(seen.contains(nextNode) || restrictSet.contains(nextNode)) {\\n                        continue;\\n                    }\\n                    q.offer(nextNode);\\n                    seen.add(nextNode);\\n                    res++;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    private void buildRestrictNode(Set<Integer> restrictSet, int[] restricted) {\\n        for(int i : restricted) {\\n            restrictSet.add(i);\\n        }\\n    }\\n    \\n    private void buildGraph(Map<Integer, List<Integer>> graph, int[][] edges) {\\n        for(int[] curEdge : edges) {\\n            int start = curEdge[0];\\n            int end = curEdge[1];\\n            if(!graph.containsKey(start)) {\\n                graph.put(start, new ArrayList<>());\\n            }\\n            if(!graph.containsKey(end)) {\\n                graph.put(end, new ArrayList<>());\\n            }\\n            \\n            graph.get(start).add(end);\\n            graph.get(end).add(start);\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390591,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int curr , int par , set<int> &s, int &cnt,vector<int> gr[]){\\n        cnt++;\\n        \\n        for(auto x:  gr[curr]){\\n            if(x!=par and s.count(x)==0){\\n                dfs(x,curr,s,cnt,gr);\\n            }\\n        }\\n        return;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> gr[n];\\n        \\n        for(auto x :edges){\\n            gr[x[0]].push_back(x[1]);\\n            gr[x[1]].push_back(x[0]);\\n        }\\n        int cnt= 0;\\n        set<int> s;\\n        for(auto x : restricted) s.insert(x);\\n        dfs(0,-1,s,cnt,gr);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int curr , int par , set<int> &s, int &cnt,vector<int> gr[]){\\n        cnt++;\\n        \\n        for(auto x:  gr[curr]){\\n            if(x!=par and s.count(x)==0){\\n                dfs(x,curr,s,cnt,gr);\\n            }\\n        }\\n        return;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> gr[n];\\n        \\n        for(auto x :edges){\\n            gr[x[0]].push_back(x[1]);\\n            gr[x[1]].push_back(x[0]);\\n        }\\n        int cnt= 0;\\n        set<int> s;\\n        for(auto x : restricted) s.insert(x);\\n        dfs(0,-1,s,cnt,gr);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390590,
                "title": "c-bfs",
                "content": "BFS solution , just add restriction to visited list.\\n```\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        Dictionary<int, List<int>> map = new();\\n        bool[] visited = new bool[n];\\n        int count = 0;\\n        \\n        foreach(int vertex in restricted)\\n            visited[vertex] = true;\\n        \\n        foreach(int[] edge in edges){\\n            map.TryAdd(edge[0], new List<int>());\\n            map.TryAdd(edge[1], new List<int>());\\n            \\n            map[edge[0]].Add(edge[1]);\\n            map[edge[1]].Add(edge[0]);\\n        }\\n        \\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        \\n        while(queue.Count > 0){\\n            var node = queue.Dequeue();\\n            count++;\\n            \\n            foreach(int child in map[node]){\\n                if(!visited[child]){\\n                    queue.Enqueue(child);\\n                    visited[child] = true;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        Dictionary<int, List<int>> map = new();\\n        bool[] visited = new bool[n];\\n        int count = 0;\\n        \\n        foreach(int vertex in restricted)\\n            visited[vertex] = true;\\n        \\n        foreach(int[] edge in edges){\\n            map.TryAdd(edge[0], new List<int>());\\n            map.TryAdd(edge[1], new List<int>());\\n            \\n            map[edge[0]].Add(edge[1]);\\n            map[edge[1]].Add(edge[0]);\\n        }\\n        \\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        \\n        while(queue.Count > 0){\\n            var node = queue.Dequeue();\\n            count++;\\n            \\n            foreach(int child in map[node]){\\n                if(!visited[child]){\\n                    queue.Enqueue(child);\\n                    visited[child] = true;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390588,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> visited = new HashSet();\\n        Set<Integer> rest = new HashSet();\\n        for(int i : restricted) {\\n            rest.add(i);\\n        }\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList();\\n        }\\n        for(int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        \\n        dfs(0, graph, visited, rest);\\n        return visited.size();\\n    }\\n    \\n    private void dfs(int node, List<Integer>[] graph, Set<Integer> visited, Set<Integer> rest) {\\n        if(visited.contains(node) || rest.contains(node)) {\\n            return;\\n        }\\n        visited.add(node);\\n        for(int adj : graph[node]) {\\n            dfs(adj, graph, visited, rest);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        Set<Integer> visited = new HashSet();\\n        Set<Integer> rest = new HashSet();\\n        for(int i : restricted) {\\n            rest.add(i);\\n        }\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList();\\n        }\\n        for(int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        \\n        dfs(0, graph, visited, rest);\\n        return visited.size();\\n    }\\n    \\n    private void dfs(int node, List<Integer>[] graph, Set<Integer> visited, Set<Integer> rest) {\\n        if(visited.contains(node) || rest.contains(node)) {\\n            return;\\n        }\\n        visited.add(node);\\n        for(int adj : graph[node]) {\\n            dfs(adj, graph, visited, rest);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390556,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        \\n       \\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        \\n        boolean[] vis = new boolean[n];\\n        \\n        for(int i=0;i<restricted.length;i++){\\n            int a = restricted[i];\\n            vis[a]=true;\\n        }\\n       \\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\tgraph[i]=new ArrayList<>();\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            \\n            graph[b].add(a);\\n            graph[a].add(b);\\n        }\\n        \\n        return count(graph,vis,0);\\n        \\n        \\n    }\\n    \\n    \\n    \\n         public static int count( ArrayList<Integer>[] graph,boolean[] visited,int v){\\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        queue.add(v);\\n             \\n        int count=0;\\n        \\n        while(queue.size()>0){\\n            \\n            int rem = queue.removeFirst();\\n            \\n           // System.out.println(rem);\\n            \\n            if(visited[rem]){\\n                continue;\\n            }\\n            \\n            count++;\\n            \\n            visited[rem] = true;\\n            \\n            for(int ed : graph[rem]){\\n                if(!visited[ed]){\\n                    queue.add(ed);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        \\n       \\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        \\n        boolean[] vis = new boolean[n];\\n        \\n        for(int i=0;i<restricted.length;i++){\\n            int a = restricted[i];\\n            vis[a]=true;\\n        }\\n       \\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\tgraph[i]=new ArrayList<>();\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            \\n            graph[b].add(a);\\n            graph[a].add(b);\\n        }\\n        \\n        return count(graph,vis,0);\\n        \\n        \\n    }\\n    \\n    \\n    \\n         public static int count( ArrayList<Integer>[] graph,boolean[] visited,int v){\\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        queue.add(v);\\n             \\n        int count=0;\\n        \\n        while(queue.size()>0){\\n            \\n            int rem = queue.removeFirst();\\n            \\n           // System.out.println(rem);\\n            \\n            if(visited[rem]){\\n                continue;\\n            }\\n            \\n            count++;\\n            \\n            visited[rem] = true;\\n            \\n            for(int ed : graph[rem]){\\n                if(!visited[ed]){\\n                    queue.add(ed);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390487,
                "title": "simple-bfs-dfs",
                "content": "**Using BREADTH FIRST SEARCH**\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        int visitedNodes = 0;\\n        \\n        vector<int> tree[n], visited(n,0);\\n        set<int> blocked;\\n        \\n        for(auto node : restricted) blocked.insert(node);\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            tree[edges[i][0]].push_back(edges[i][1]);\\n            tree[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        queue<int> queue;\\n        \\n        queue.push(0); \\n        visited[0] = true;\\n        \\n        while(!queue.empty())\\n        {\\n            int currNode = queue.front();\\n            queue.pop();\\n            visitedNodes++;\\n            \\n            for(auto node : tree[currNode])\\n            {\\n                if(blocked.find(node) == blocked.end() && !visited[node])\\n                {\\n                    queue.push(node);\\n\\t\\t\\t\\t\\tvisited[node] = true;\\n                }\\n            }\\n        }\\n        return visitedNodes;\\n    }\\n};\\n```\\n\\n**Using DEPTH FIRST SEARCH**\\n\\n```\\nclass Solution {\\nprivate:\\n    void findReachableNodes(int currNode, int& visitedNodes, vector<int> tree[], vector<int>& visited, set<int>& blocked)\\n    {\\n        visited[currNode] = true;\\n        visitedNodes++;\\n        \\n        for(auto node : tree[currNode])\\n        {\\n            if(blocked.find(node) == blocked.end() && !visited[node])\\n            {\\n                findReachableNodes(node, visitedNodes, tree, visited, blocked);\\n            }\\n        }\\n    }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        int visitedNodes = 0;\\n        \\n        vector<int> tree[n], visited(n,0);\\n        set<int> blocked;\\n        \\n        for(auto node : restricted) blocked.insert(node);\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            tree[edges[i][0]].push_back(edges[i][1]);\\n            tree[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        findReachableNodes(0, visitedNodes, tree, visited, blocked);\\n        return visitedNodes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        int visitedNodes = 0;\\n        \\n        vector<int> tree[n], visited(n,0);\\n        set<int> blocked;\\n        \\n        for(auto node : restricted) blocked.insert(node);\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            tree[edges[i][0]].push_back(edges[i][1]);\\n            tree[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        queue<int> queue;\\n        \\n        queue.push(0); \\n        visited[0] = true;\\n        \\n        while(!queue.empty())\\n        {\\n            int currNode = queue.front();\\n            queue.pop();\\n            visitedNodes++;\\n            \\n            for(auto node : tree[currNode])\\n            {\\n                if(blocked.find(node) == blocked.end() && !visited[node])\\n                {\\n                    queue.push(node);\\n\\t\\t\\t\\t\\tvisited[node] = true;\\n                }\\n            }\\n        }\\n        return visitedNodes;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void findReachableNodes(int currNode, int& visitedNodes, vector<int> tree[], vector<int>& visited, set<int>& blocked)\\n    {\\n        visited[currNode] = true;\\n        visitedNodes++;\\n        \\n        for(auto node : tree[currNode])\\n        {\\n            if(blocked.find(node) == blocked.end() && !visited[node])\\n            {\\n                findReachableNodes(node, visitedNodes, tree, visited, blocked);\\n            }\\n        }\\n    }\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        \\n        int visitedNodes = 0;\\n        \\n        vector<int> tree[n], visited(n,0);\\n        set<int> blocked;\\n        \\n        for(auto node : restricted) blocked.insert(node);\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            tree[edges[i][0]].push_back(edges[i][1]);\\n            tree[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        findReachableNodes(0, visitedNodes, tree, visited, blocked);\\n        return visitedNodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390479,
                "title": "dfs-with-already-visited-nodes",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def DFS(self, i, graph, v):\\n        for j in graph[i]:\\n            if j not in v:\\n                v.add(j)\\n                self.DFS(j, graph, v)\\n    \\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        v = set([0] + restricted)\\n        self.DFS(0, graph, v)\\n        return len(v) - len(restricted)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def DFS(self, i, graph, v):\\n        for j in graph[i]:\\n            if j not in v:\\n                v.add(j)\\n                self.DFS(j, graph, v)\\n    \\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        v = set([0] + restricted)\\n        self.DFS(0, graph, v)\\n        return len(v) - len(restricted)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097565,
                "title": "dfs-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   \\n    static void dfs(int node, List<List<Integer>> adj,List<Integer> list ,int vis[])\\n    {\\n        vis[node] = 1;\\n        list.add(node);\\n       \\n            for(int it : adj.get(node))\\n            {\\n              if(vis[it] == 0){\\n\\n                 dfs(it,adj,list,vis);\\n\\n                }\\n            }\\n    }\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n       //int count = 0;\\n      //  List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n\\n         int vis[] = new int[n];\\n\\n        for(int i=0;i<restricted.length;i++)\\n        {\\n           vis[restricted[i]] = 1;\\n        }\\n\\n        dfs(0,adj,list,vis);\\n        System.out.print(list);\\n\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    static void dfs(int node, List<List<Integer>> adj,List<Integer> list ,int vis[])\\n    {\\n        vis[node] = 1;\\n        list.add(node);\\n       \\n            for(int it : adj.get(node))\\n            {\\n              if(vis[it] == 0){\\n\\n                 dfs(it,adj,list,vis);\\n\\n                }\\n            }\\n    }\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n       //int count = 0;\\n      //  List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n\\n         int vis[] = new int[n];\\n\\n        for(int i=0;i<restricted.length;i++)\\n        {\\n           vis[restricted[i]] = 1;\\n        }\\n\\n        dfs(0,adj,list,vis);\\n        System.out.print(list);\\n\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093662,
                "title": "100-faster-full-explaination-beginner-friendly",
                "content": "# Intuition\\nThe first comes to mind is to do a DFS traversal with little modification and count the neighbours of 0 as we have to find max no. of nodes to traverse from 0\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach that comes to mind is to already mark the restricted node as visited and then do a DFS traversal from node 0 to all its neighbours and always increase the count+1 to ans, that you have visited that node from 0.\\nAt last return the ans\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n### ****- O(V)****\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>adj[], vector<int>&vis,int &cnt){\\n        vis[node]=1;\\n        cnt++;\\n\\n        for(auto i:adj[node]){\\n            if(!vis[i]){\\n                dfs(i,adj,vis,cnt);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> vis(n,0);\\n\\n        for(int i=0;i<restricted.size();i++){\\n            vis[restricted[i]]=1;\\n        }\\n\\n        int cnt=0;\\n        dfs(0,adj,vis,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>adj[], vector<int>&vis,int &cnt){\\n        vis[node]=1;\\n        cnt++;\\n\\n        for(auto i:adj[node]){\\n            if(!vis[i]){\\n                dfs(i,adj,vis,cnt);\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> vis(n,0);\\n\\n        for(int i=0;i<restricted.size();i++){\\n            vis[restricted[i]]=1;\\n        }\\n\\n        int cnt=0;\\n        dfs(0,adj,vis,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038660,
                "title": "easiest-solution-using-dfs-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe basic intution is normal dfs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a boolean array vis and for all restricted nodes make it true in vis array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(v+e)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n# Code\\n```\\nclass Solution {\\n    int count=0;\\n    HashMap<Integer,ArrayList<Integer>> hm= new HashMap<>(); \\n// making hasmap \\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n       // putting key as node and its value as neighbour of node\\n       for(int i[]:edges){\\n hm.computeIfAbsent(i[0], k-> new ArrayList<Integer>()).add(i[1]);\\n\\n  hm.computeIfAbsent(i[1], k-> new ArrayList<Integer>()).add(i[0]);\\n       }\\n       boolean vis[]=new boolean[n];\\n// for all restricted node make it true in vis array\\n       for(int i:restricted){\\n           vis[i]=true;\\n       }\\n     \\n              \\n               dfs(vis,0);\\n     \\n       \\n       return count;\\n    }\\n\\n     public void dfs(boolean vis[], int curr) {\\n    vis[curr] = true;\\n//whenever visiting the node count it in count var\\n     count++;\\n    if (hm.get(curr) != null) { // Check if the key exists in the HashMap\\n        for (int i : hm.get(curr)) { // Loop over the ArrayList at the current key\\n            if (vis[i]==false) {\\n                vis[i] = true;\\n                dfs( vis, i);\\n            }\\n        }\\n    }\\n}\\n\\n}\\n// upvote if you like the solution\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    HashMap<Integer,ArrayList<Integer>> hm= new HashMap<>(); \\n// making hasmap \\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n       // putting key as node and its value as neighbour of node\\n       for(int i[]:edges){\\n hm.computeIfAbsent(i[0], k-> new ArrayList<Integer>()).add(i[1]);\\n\\n  hm.computeIfAbsent(i[1], k-> new ArrayList<Integer>()).add(i[0]);\\n       }\\n       boolean vis[]=new boolean[n];\\n// for all restricted node make it true in vis array\\n       for(int i:restricted){\\n           vis[i]=true;\\n       }\\n     \\n              \\n               dfs(vis,0);\\n     \\n       \\n       return count;\\n    }\\n\\n     public void dfs(boolean vis[], int curr) {\\n    vis[curr] = true;\\n//whenever visiting the node count it in count var\\n     count++;\\n    if (hm.get(curr) != null) { // Check if the key exists in the HashMap\\n        for (int i : hm.get(curr)) { // Loop over the ArrayList at the current key\\n            if (vis[i]==false) {\\n                vis[i] = true;\\n                dfs( vis, i);\\n            }\\n        }\\n    }\\n}\\n\\n}\\n// upvote if you like the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023334,
                "title": "python-3-dfs-dictionary",
                "content": "\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        seen = {0}\\n        graph = defaultdict(list)\\n        restrictedSet = set(restricted)\\n\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        def dfs(node):\\n            ans = 1\\n            for neighbor in graph[node]:\\n                if neighbor in restrictedSet:\\n                    continue\\n                else:\\n                    if neighbor not in seen:\\n                        seen.add(neighbor)\\n                        ans += dfs(neighbor)\\n            return ans\\n        \\n        \\n        return dfs(0)\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        seen = {0}\\n        graph = defaultdict(list)\\n        restrictedSet = set(restricted)\\n\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        def dfs(node):\\n            ans = 1\\n            for neighbor in graph[node]:\\n                if neighbor in restrictedSet:\\n                    continue\\n                else:\\n                    if neighbor not in seen:\\n                        seen.add(neighbor)\\n                        ans += dfs(neighbor)\\n            return ans\\n        \\n        \\n        return dfs(0)\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994450,
                "title": "5-liner-dfs",
                "content": "##### Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n##### Code\\n```\\nclass Solution {\\n\\n    int dfs(int N, Map<Integer, List<Integer>> adj, HashSet<Integer> R) {\\n        if(R.contains(N)) return 0;\\n        R.add(N);                          // mark visited\\n        int max = 1;                       // take self\\n        for(int n: adj.getOrDefault(N,  new ArrayList<>()))\\n            max += dfs(n, adj, R);         // count adjecent \\n        return max;                        // return max reachable count from N\\n    }\\n\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        HashSet<Integer> R = new HashSet<>();\\n        int maxNodes = 0;\\n\\n        for(int[] edge: edges) {\\n            List<Integer> p1 = adj.getOrDefault(edge[0], new ArrayList<>());\\n            List<Integer> p2 = adj.getOrDefault(edge[1], new ArrayList<>());\\n            p1.add(edge[1]);\\n            p2.add(edge[0]);\\n            adj.put(edge[0], p1);\\n            adj.put(edge[1], p2);\\n        }\\n\\n        for(int k: restricted) R.add(k);\\n\\n        return dfs(0, adj, R);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dfs(int N, Map<Integer, List<Integer>> adj, HashSet<Integer> R) {\\n        if(R.contains(N)) return 0;\\n        R.add(N);                          // mark visited\\n        int max = 1;                       // take self\\n        for(int n: adj.getOrDefault(N,  new ArrayList<>()))\\n            max += dfs(n, adj, R);         // count adjecent \\n        return max;                        // return max reachable count from N\\n    }\\n\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        HashSet<Integer> R = new HashSet<>();\\n        int maxNodes = 0;\\n\\n        for(int[] edge: edges) {\\n            List<Integer> p1 = adj.getOrDefault(edge[0], new ArrayList<>());\\n            List<Integer> p2 = adj.getOrDefault(edge[1], new ArrayList<>());\\n            p1.add(edge[1]);\\n            p2.add(edge[0]);\\n            adj.put(edge[0], p1);\\n            adj.put(edge[1], p2);\\n        }\\n\\n        for(int k: restricted) R.add(k);\\n\\n        return dfs(0, adj, R);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971594,
                "title": "just-a-pro-hint",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn a normal dfs/bfs problem, when do not a visit a node?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust mark the restricted nodes as visited.\\n\\n\\n# No Code\\n```\\nTry it yourself, its not tough at all!!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nTry it yourself, its not tough at all!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962433,
                "title": "solution-using-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void dfs(int node, vector<vector<int>>& adj, unordered_map<int, int>& mp, vector<int>& vis) {\\n    vis[node] = 1;\\n    for (auto it : adj[node]) {\\n        if (!vis[it] && mp.find(it) == mp.end()) {\\n            dfs(it, adj, mp, vis);\\n        }\\n    }\\n}\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>vis(n,0);\\n        unordered_map<int,int>mp;\\n        for(auto it:restricted){\\n            mp[it]++;\\n        }\\n        vector<vector<int>>adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,adj,mp,vis);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==1){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void dfs(int node, vector<vector<int>>& adj, unordered_map<int, int>& mp, vector<int>& vis) {\\n    vis[node] = 1;\\n    for (auto it : adj[node]) {\\n        if (!vis[it] && mp.find(it) == mp.end()) {\\n            dfs(it, adj, mp, vis);\\n        }\\n    }\\n}\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>vis(n,0);\\n        unordered_map<int,int>mp;\\n        for(auto it:restricted){\\n            mp[it]++;\\n        }\\n        vector<vector<int>>adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,adj,mp,vis);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==1){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950104,
                "title": "ts-easy-solution-via-bfs",
                "content": "# Intuition\\nThe problem requires finding the maximum number of nodes that can be reached from node 0 in an undirected tree, while avoiding restricted nodes. This suggests a graph traversal approach to explore the reachable nodes from the starting node, ensuring that restricted nodes are not visited.\\n\\n# Approach\\n1. Initialize a boolean array seen to keep track of visited nodes. Set all values to false initially. Mark nodes specified in the restricted array as true.\\n2. Create a graph representation using an adjacency list based on the given edges array.\\n3. Initialize a count variable to track the number of reachable nodes.\\n4. Start with node 0 and perform a breadth-first search (BFS) traversal. Enqueue node 0 into a queue.\\n5. While the queue is not empty, dequeue a node. If the node hasn\\'t been visited and is not restricted, increment the count, mark it as visited, and enqueue its neighbors into the queue.\\n6. Return the count as the maximum number of reachable nodes.\\n\\n# Code\\n```\\nfunction reachableNodes(n: number, edges: number[][], restricted: number[]): number {\\n    let seen = new Array(n).fill(false)\\n    for (let res of restricted) {\\n        seen[res] = true\\n    }\\n    let graph = {}\\n    for (let i = 0; i < n; i++) {\\n        graph[i] = []\\n    }\\n    for (let [a, b] of edges) {\\n        graph[a].push(b)\\n        graph[b].push(a)\\n    }\\n\\n    let count = 0\\n    let queue = [0]\\n\\n    while (queue.length) {\\n        let curr_node = queue.shift()\\n        if (!seen[curr_node]) {\\n            count++\\n            seen[curr_node] = true\\n            for (let next_node of graph[curr_node]) {\\n                queue.push(next_node)\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction reachableNodes(n: number, edges: number[][], restricted: number[]): number {\\n    let seen = new Array(n).fill(false)\\n    for (let res of restricted) {\\n        seen[res] = true\\n    }\\n    let graph = {}\\n    for (let i = 0; i < n; i++) {\\n        graph[i] = []\\n    }\\n    for (let [a, b] of edges) {\\n        graph[a].push(b)\\n        graph[b].push(a)\\n    }\\n\\n    let count = 0\\n    let queue = [0]\\n\\n    while (queue.length) {\\n        let curr_node = queue.shift()\\n        if (!seen[curr_node]) {\\n            count++\\n            seen[curr_node] = true\\n            for (let next_node of graph[curr_node]) {\\n                queue.push(next_node)\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930566,
                "title": "simple-c-solution-using-bfs-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) {\\n        unordered_map<int,int>m;\\n        for(int i=0; i<r.size(); i++){\\n            m[r[i]]=1;\\n        }\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        queue<int>q;\\n        q.push(0);\\n        int ans = 0;\\n        vector<int>vis(n,0);\\n        vis[0] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans++;\\n            for(auto it : adj[node]){\\n                if(!m[it] && !vis[it]){\\n                    vis[it] = 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) {\\n        unordered_map<int,int>m;\\n        for(int i=0; i<r.size(); i++){\\n            m[r[i]]=1;\\n        }\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        queue<int>q;\\n        q.push(0);\\n        int ans = 0;\\n        vector<int>vis(n,0);\\n        vis[0] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans++;\\n            for(auto it : adj[node]){\\n                if(!m[it] && !vis[it]){\\n                    vis[it] = 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925102,
                "title": "c-simple-dfs-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&rest, int curr, int pre, int&ans)\\n    {\\n        ans++;\\n        for(int x: adj[curr])\\n        {\\n            if(x!=pre && rest[x]==false)\\n            {\\n                dfs(adj, rest, x, curr, ans);\\n            }\\n        }\\n        return;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted)\\n    {\\n        vector<vector<int>> adj(n);\\n        for(vector<int>& e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> rest(n, false);\\n        for(int x: restricted){rest[x]=true;}\\n        int ans = 0;\\n        dfs(adj, rest, 0, -1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&rest, int curr, int pre, int&ans)\\n    {\\n        ans++;\\n        for(int x: adj[curr])\\n        {\\n            if(x!=pre && rest[x]==false)\\n            {\\n                dfs(adj, rest, x, curr, ans);\\n            }\\n        }\\n        return;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted)\\n    {\\n        vector<vector<int>> adj(n);\\n        for(vector<int>& e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> rest(n, false);\\n        for(int x: restricted){rest[x]=true;}\\n        int ans = 0;\\n        dfs(adj, rest, 0, -1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920608,
                "title": "kotlin-graph-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun reachableNodes(n: Int, edges: Array<IntArray>, restricted: IntArray): Int {\\n\\n        var ans = 0\\n        val graph = mutableMapOf<Int, MutableList<Int>>()\\n        val seen = Array(n) { false }\\n\\n        // Initialize the graph with empty lists\\n        repeat(n) { node ->\\n            graph[node] = mutableListOf()\\n        }\\n\\n        // Initialize the neighbors with the given edges\\n        for ((a, b) in edges) {\\n            graph[a]!!.add(b)\\n            graph[b]!!.add(a)\\n        }\\n\\n        // Mark restricted nodes as seen to prevent DFS on those nodes and their neighbors\\n        restricted.forEach { node ->\\n            seen[node] = true\\n        }\\n\\n        // Perform the DFS only on the neighbors which are not neighbor to a restricted node\\n        fun dfs(node: Int, neighbors: List<Int>) {\\n            seen[node] = true\\n            ans++\\n\\n            for (neighbor in neighbors) {\\n                if (!seen[neighbor]) {\\n                    dfs(neighbor, graph[neighbor]!!)\\n                }\\n            }\\n        }\\n\\n        dfs(0, graph[0]!!)\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun reachableNodes(n: Int, edges: Array<IntArray>, restricted: IntArray): Int {\\n\\n        var ans = 0\\n        val graph = mutableMapOf<Int, MutableList<Int>>()\\n        val seen = Array(n) { false }\\n\\n        // Initialize the graph with empty lists\\n        repeat(n) { node ->\\n            graph[node] = mutableListOf()\\n        }\\n\\n        // Initialize the neighbors with the given edges\\n        for ((a, b) in edges) {\\n            graph[a]!!.add(b)\\n            graph[b]!!.add(a)\\n        }\\n\\n        // Mark restricted nodes as seen to prevent DFS on those nodes and their neighbors\\n        restricted.forEach { node ->\\n            seen[node] = true\\n        }\\n\\n        // Perform the DFS only on the neighbors which are not neighbor to a restricted node\\n        fun dfs(node: Int, neighbors: List<Int>) {\\n            seen[node] = true\\n            ans++\\n\\n            for (neighbor in neighbors) {\\n                if (!seen[neighbor]) {\\n                    dfs(neighbor, graph[neighbor]!!)\\n                }\\n            }\\n        }\\n\\n        dfs(0, graph[0]!!)\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919654,
                "title": "js-queue-bfs-beats-99-5-w-intuitive-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} restricted\\n * @return {number}\\n */\\nvar reachableNodes = function(n, edges, restricted) {\\n    //create a set of restrictions so we can omit them from our map\\n    const restrictions = new Set(restricted)\\n    //create a set to track what nodes we have seen\\n    const seen = new Set()\\n    const map = {}\\n    let result = 0\\n    //initialize an array of edges for each node\\n    for (let i = 0; i < n; i++) {\\n        map[i] = []\\n    }\\n    //omit restricted nodes, otherwise create graph in map\\n    for (const [x,y] of edges) {\\n        if (restrictions.has(x) || restrictions.has(y)) {\\n            continue;\\n        }\\n        map[x].push(y)\\n        map[y].push(x)\\n    }\\n    //initialize queue at 0\\n    let queue = [0]\\n    //add 0 to seen\\n    seen.add(0)\\n    //0 can visit itself so we increase result\\n    result++\\n    \\n    while (queue.length > 0) {\\n        //shift a node off of the queue\\n        let node = queue.shift()\\n        //if we have that node in our map\\n        if (map[node]) {\\n            //iterate over its connections as they are nodes that 0 can also visit\\n            for (let connection of map[node]) {\\n                //if we haven\\'t seen it before, add it to seen, push it into the que, and increase our result\\n                if (!seen.has(connection)) {\\n                    seen.add(connection)\\n                    queue.push(connection)\\n                    result++\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} restricted\\n * @return {number}\\n */\\nvar reachableNodes = function(n, edges, restricted) {\\n    //create a set of restrictions so we can omit them from our map\\n    const restrictions = new Set(restricted)\\n    //create a set to track what nodes we have seen\\n    const seen = new Set()\\n    const map = {}\\n    let result = 0\\n    //initialize an array of edges for each node\\n    for (let i = 0; i < n; i++) {\\n        map[i] = []\\n    }\\n    //omit restricted nodes, otherwise create graph in map\\n    for (const [x,y] of edges) {\\n        if (restrictions.has(x) || restrictions.has(y)) {\\n            continue;\\n        }\\n        map[x].push(y)\\n        map[y].push(x)\\n    }\\n    //initialize queue at 0\\n    let queue = [0]\\n    //add 0 to seen\\n    seen.add(0)\\n    //0 can visit itself so we increase result\\n    result++\\n    \\n    while (queue.length > 0) {\\n        //shift a node off of the queue\\n        let node = queue.shift()\\n        //if we have that node in our map\\n        if (map[node]) {\\n            //iterate over its connections as they are nodes that 0 can also visit\\n            for (let connection of map[node]) {\\n                //if we haven\\'t seen it before, add it to seen, push it into the que, and increase our result\\n                if (!seen.has(connection)) {\\n                    seen.add(connection)\\n                    queue.push(connection)\\n                    result++\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909060,
                "title": "python-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph = defaultdict(list)\\n        visited = set(restricted)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        def dfs(start , previous):\\n            visited.add(start)        \\n            result = 0\\n            \\n            for i in graph[start]:\\n                if i not in visited:                        \\n                        temp = dfs(i,start)\\n                        result = result + temp + 1\\n                else:\\n                    continue\\n      \\n            return result\\n        \\n        return dfs(0,-1)+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph = defaultdict(list)\\n        visited = set(restricted)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        def dfs(start , previous):\\n            visited.add(start)        \\n            result = 0\\n            \\n            for i in graph[start]:\\n                if i not in visited:                        \\n                        temp = dfs(i,start)\\n                        result = result + temp + 1\\n                else:\\n                    continue\\n      \\n            return result\\n        \\n        return dfs(0,-1)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882573,
                "title": "bfs-with-and-without-using-map-or-set-2-soln-c",
                "content": "**By Using Map**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& grid, vector<int>& rest) {\\n        vector<vector<int>> adj(n);\\n        int cnt=0;\\n        \\n        for(auto nodes: grid)\\n        {\\n          adj[nodes[0]].push_back(nodes[1]);\\n           adj[nodes[1]].push_back(nodes[0]);\\n        }\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x: rest)\\n        {\\n            m[x]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> vis(n,0);\\n        \\n        // if(m.find(0)!=m.end())\\n        //     return 0;\\n        q.push(0);\\n        vis[0]=1;\\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            \\n            q.pop();\\n            cnt++;\\n            \\n            for(auto x: adj[node] )\\n            {\\n               \\n               if(!vis[x] && m.find(x)==m.end() )\\n               {\\n                    cout<<x<<endl;\\n                   vis[x]=1;\\n                   q.push(x);\\n               }\\n                \\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```\\n\\n**Without Using Map**\\n```\\nclass Solution\\n{\\n    public:\\n        int reachableNodes(int n, vector<vector < int>> &grid, vector< int > &rest)\\n        {\\n            vector<vector < int>> adj(n);\\n            int cnt = 0;\\n\\n            for (auto nodes: grid)\\n            {\\n                adj[nodes[0]].push_back(nodes[1]);\\n                adj[nodes[1]].push_back(nodes[0]);\\n            }\\n\\n        \\n            queue<int> q;\\n            vector<int> vis(n, 0);\\n\\n            for (int i = 0; i < rest.size(); i++)\\n            {\\n                vis[rest[i]] = 1;\\n            }\\n\\n            q.push(0);\\n            vis[0] = 1;\\n\\n            while (!q.empty())\\n            {\\n                int node = q.front();\\n\\n                q.pop();\\n                cnt++;\\n\\n                for (auto x: adj[node])\\n                {\\n\\n                    if (!vis[x])\\n                    {\\n                        cout << x << endl;\\n                        vis[x] = 1;\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& grid, vector<int>& rest) {\\n        vector<vector<int>> adj(n);\\n        int cnt=0;\\n        \\n        for(auto nodes: grid)\\n        {\\n          adj[nodes[0]].push_back(nodes[1]);\\n           adj[nodes[1]].push_back(nodes[0]);\\n        }\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x: rest)\\n        {\\n            m[x]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> vis(n,0);\\n        \\n        // if(m.find(0)!=m.end())\\n        //     return 0;\\n        q.push(0);\\n        vis[0]=1;\\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            \\n            q.pop();\\n            cnt++;\\n            \\n            for(auto x: adj[node] )\\n            {\\n               \\n               if(!vis[x] && m.find(x)==m.end() )\\n               {\\n                    cout<<x<<endl;\\n                   vis[x]=1;\\n                   q.push(x);\\n               }\\n                \\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public:\\n        int reachableNodes(int n, vector<vector < int>> &grid, vector< int > &rest)\\n        {\\n            vector<vector < int>> adj(n);\\n            int cnt = 0;\\n\\n            for (auto nodes: grid)\\n            {\\n                adj[nodes[0]].push_back(nodes[1]);\\n                adj[nodes[1]].push_back(nodes[0]);\\n            }\\n\\n        \\n            queue<int> q;\\n            vector<int> vis(n, 0);\\n\\n            for (int i = 0; i < rest.size(); i++)\\n            {\\n                vis[rest[i]] = 1;\\n            }\\n\\n            q.push(0);\\n            vis[0] = 1;\\n\\n            while (!q.empty())\\n            {\\n                int node = q.front();\\n\\n                q.pop();\\n                cnt++;\\n\\n                for (auto x: adj[node])\\n                {\\n\\n                    if (!vis[x])\\n                    {\\n                        cout << x << endl;\\n                        vis[x] = 1;\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3872567,
                "title": "bfs-solution",
                "content": "We can solve it using bfs. So, just mark all the restricted nodes as visited and perform the bfs starting from 0. That\\'s it.\\n\\n# Code\\n```\\nimport queue\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n      g,mark,q,ans = [[] for _ in range(n)], [False]*n, queue.Queue(),0 \\n      q.put(0)\\n      mark[0] = True \\n      for x,y in edges:\\n        g[x].append(y)\\n        g[y].append(x)\\n      for i in restricted: mark[i] = True \\n      while(not q.empty()):\\n        k = q.get()\\n        ans += 1 \\n        for i in g[k]:\\n          if not mark[i]:\\n            q.put(i) \\n            mark[i] = True \\n      return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport queue\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n      g,mark,q,ans = [[] for _ in range(n)], [False]*n, queue.Queue(),0 \\n      q.put(0)\\n      mark[0] = True \\n      for x,y in edges:\\n        g[x].append(y)\\n        g[y].append(x)\\n      for i in restricted: mark[i] = True \\n      while(not q.empty()):\\n        k = q.get()\\n        ans += 1 \\n        for i in g[k]:\\n          if not mark[i]:\\n            q.put(i) \\n            mark[i] = True \\n      return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869012,
                "title": "c-simple-traversal-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n        set<int> st;\\n        for(auto it : restricted){\\n            st.insert(it);\\n        }\\n        vector<int> vis(n, 0);\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n\\n        }\\n        queue<int> q;\\n        int ans = 0;\\n        q.push(0);\\n        vis[0] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans++;\\n            for(auto it : adj[node]){\\n                if(st.find(it)==st.end() && vis[it]==0){\\n                    vis[it] = 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n        set<int> st;\\n        for(auto it : restricted){\\n            st.insert(it);\\n        }\\n        vector<int> vis(n, 0);\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n\\n        }\\n        queue<int> q;\\n        int ans = 0;\\n        q.push(0);\\n        vis[0] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans++;\\n            for(auto it : adj[node]){\\n                if(st.find(it)==st.end() && vis[it]==0){\\n                    vis[it] = 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862917,
                "title": "simplest-possible-dfs-solution-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n    Creating the forbidden set: O(r), where r is the number of restricted nodes.\\n    Initializing the visited array: O(n), where n is the number of nodes.\\n    Creating the adjList adjacency list: O(e), where e is the number of edges.\\n    DFS traversal: In the worst case, each node and each edge is visited once, resulting in O(n + e) time complexity.\\n\\nOverall, the time complexity is O(n + e + r), where n is the number of nodes, e is the number of edges, and r is the number of restricted nodes.\\n\\n- Space complexity:\\n    forbidden set: O(r), where r is the number of restricted nodes.\\n    visited array: O(n), where n is the number of nodes.\\n    adjList adjacency list: O(e + n), where e is the number of edges and n is the number of nodes.\\n    Recursive call stack for DFS: O(n) in the worst case (if the graph is a connected chain).\\n\\nOverall, the space complexity is O(n + e + r).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   void DFS(vector<vector<int>>& adjList, unordered_set<int>& forbidden, int starting, int& counter, bool* visited) {\\n    if (!visited[starting]) {\\n        visited[starting] = true;\\n        if (forbidden.find(starting) == forbidden.end()) {\\n            counter++;\\n        } else {\\n            return; // Don\\'t explore further from forbidden nodes\\n        }\\n    }\\n\\n    for (int neighbor : adjList[starting]) {\\n        if (!visited[neighbor]) {\\n            DFS(adjList, forbidden, neighbor, counter, visited);\\n        }\\n    }\\n}\\n\\nint reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n    int ans = 0;\\n    unordered_set<int> forbidden(restricted.begin(), restricted.end());\\n\\n    bool visited[n];\\n    for (int i = 0; i < n; ++i) {\\n        visited[i] = false;\\n    }\\n\\n    vector<vector<int>> adjList(n);\\n    for (int j = 0; j < edges.size(); j++) {\\n        int source = edges[j][0];\\n        int target = edges[j][1];\\n        adjList[source].push_back(target);\\n        adjList[target].push_back(source); \\n    }\\n\\n    DFS(adjList, forbidden, 0, ans, visited);\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   void DFS(vector<vector<int>>& adjList, unordered_set<int>& forbidden, int starting, int& counter, bool* visited) {\\n    if (!visited[starting]) {\\n        visited[starting] = true;\\n        if (forbidden.find(starting) == forbidden.end()) {\\n            counter++;\\n        } else {\\n            return; // Don\\'t explore further from forbidden nodes\\n        }\\n    }\\n\\n    for (int neighbor : adjList[starting]) {\\n        if (!visited[neighbor]) {\\n            DFS(adjList, forbidden, neighbor, counter, visited);\\n        }\\n    }\\n}\\n\\nint reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n    int ans = 0;\\n    unordered_set<int> forbidden(restricted.begin(), restricted.end());\\n\\n    bool visited[n];\\n    for (int i = 0; i < n; ++i) {\\n        visited[i] = false;\\n    }\\n\\n    vector<vector<int>> adjList(n);\\n    for (int j = 0; j < edges.size(); j++) {\\n        int source = edges[j][0];\\n        int target = edges[j][1];\\n        adjList[source].push_back(target);\\n        adjList[target].push_back(source); \\n    }\\n\\n    DFS(adjList, forbidden, 0, ans, visited);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841870,
                "title": "beats-99-92-bfs-c",
                "content": "# Approach\\nThe graph will be stored as a sparse matrix.\\nNext step - classic BFS, but we mark as used restricted vertexes before start BFS.\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$ (n - count of vertexes, m - count of edges)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> nedges(n);\\n        for (auto& x : edges)\\n        {\\n            nedges[x[0]].push_back(x[1]);\\n            nedges[x[1]].push_back(x[0]);\\n        }\\n        vector<bool> used(n, false);\\n        for (auto& x : restricted) used[x] = true;\\n\\n        used[0] = true;\\n        queue<int> que;\\n        que.push(0);\\n        int cnt = 1;\\n\\n        while (!que.empty())\\n        {\\n            for (auto& x : nedges[que.front()])\\n            {\\n                if (used[x]) continue;\\n                used[x] = true;\\n                que.push(x);\\n                cnt++;\\n            }\\n            que.pop();\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> nedges(n);\\n        for (auto& x : edges)\\n        {\\n            nedges[x[0]].push_back(x[1]);\\n            nedges[x[1]].push_back(x[0]);\\n        }\\n        vector<bool> used(n, false);\\n        for (auto& x : restricted) used[x] = true;\\n\\n        used[0] = true;\\n        queue<int> que;\\n        que.push(0);\\n        int cnt = 1;\\n\\n        while (!que.empty())\\n        {\\n            for (auto& x : nedges[que.front()])\\n            {\\n                if (used[x]) continue;\\n                used[x] = true;\\n                que.push(x);\\n                cnt++;\\n            }\\n            que.pop();\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831367,
                "title": "python-bfs-with-adjustment",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        from collections import deque, defaultdict\\n        graph = defaultdict(list)\\n        seen = set(restricted)\\n        for x, y in edges:\\n            if x not in seen:\\n                graph[x].append(y)\\n            if y not in seen:\\n                graph[y].append(x)\\n                \\n        queue = deque([0])\\n        ans = 0\\n        while queue:\\n            length = len(queue)\\n            node = queue.pop()\\n            if node not in seen:\\n                seen.add(node)\\n                ans += 1\\n                queue.extend(graph[node])\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        from collections import deque, defaultdict\\n        graph = defaultdict(list)\\n        seen = set(restricted)\\n        for x, y in edges:\\n            if x not in seen:\\n                graph[x].append(y)\\n            if y not in seen:\\n                graph[y].append(x)\\n                \\n        queue = deque([0])\\n        ans = 0\\n        while queue:\\n            length = len(queue)\\n            node = queue.pop()\\n            if node not in seen:\\n                seen.add(node)\\n                ans += 1\\n                queue.extend(graph[node])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806212,
                "title": "c-easyyyyyiest-solution-ever-bfs-with-truncated-edge-set-fastest-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        queue<int> dfs;\\n        int ans = 0;\\n\\n        vector<vector<int>> adjList(n);\\n        unordered_set<int> restrict;\\n\\n        for(int &res: restricted)\\n            restrict.insert(res);\\n\\n        for(auto &edge: edges){\\n            if(restrict.count(edge[0])==0 && restrict.count(edge[1])==0){\\n                adjList[edge[0]].push_back(edge[1]);\\n                adjList[edge[1]].push_back(edge[0]);\\n            }\\n        }\\n\\n        dfs.push(0);\\n        int size, curr;\\n        vector<bool> visited(n, false);\\n        while(!dfs.empty()){\\n            size = dfs.size();\\n            while(size--){\\n                curr = dfs.front();\\n                dfs.pop();\\n                visited[curr] = true;\\n                ans++;\\n                for(int &node: adjList[curr])\\n                    if(!visited[node])dfs.push(node);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        queue<int> dfs;\\n        int ans = 0;\\n\\n        vector<vector<int>> adjList(n);\\n        unordered_set<int> restrict;\\n\\n        for(int &res: restricted)\\n            restrict.insert(res);\\n\\n        for(auto &edge: edges){\\n            if(restrict.count(edge[0])==0 && restrict.count(edge[1])==0){\\n                adjList[edge[0]].push_back(edge[1]);\\n                adjList[edge[1]].push_back(edge[0]);\\n            }\\n        }\\n\\n        dfs.push(0);\\n        int size, curr;\\n        vector<bool> visited(n, false);\\n        while(!dfs.empty()){\\n            size = dfs.size();\\n            while(size--){\\n                curr = dfs.front();\\n                dfs.pop();\\n                visited[curr] = true;\\n                ans++;\\n                for(int &node: adjList[curr])\\n                    if(!visited[node])dfs.push(node);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799290,
                "title": "python3-17-lines-t-s-o-v-e-o-v-e-t-99",
                "content": "# Intuition\\nGraph traversal via pre-built adjacency list that does not contain restricted nodes.\\n\\n# Complexity\\n- Time complexity: $$O(V+E)$$\\nwhere $$V$$ is the number of nodes and $$E$$ is the number of edges.\\n\\n\\n- Space complexity: $$O(V+E)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        # build adjacency list without restricted nodes\\n        banned = set(restricted)\\n        adj = defaultdict(list)\\n        for p, c in edges:\\n            if p not in banned and c not in banned:\\n                adj[p].append(c)\\n                adj[c].append(p)\\n\\n        # traverse from node 0 (DFS)\\n        seen = set({0})\\n        stack = [0]\\n        count = 1\\n        while stack:\\n            cur = stack.pop()\\n            for child in adj[cur]:\\n                if child not in seen:\\n                    seen.add(child)\\n                    stack.append(child)\\n                    count += 1\\n\\n        return count\\n\\n```\\n\\nhttps://leetcode.com/problems/reachable-nodes-with-restrictions/submissions/1000644705/",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        # build adjacency list without restricted nodes\\n        banned = set(restricted)\\n        adj = defaultdict(list)\\n        for p, c in edges:\\n            if p not in banned and c not in banned:\\n                adj[p].append(c)\\n                adj[c].append(p)\\n\\n        # traverse from node 0 (DFS)\\n        seen = set({0})\\n        stack = [0]\\n        count = 1\\n        while stack:\\n            cur = stack.pop()\\n            for child in adj[cur]:\\n                if child not in seen:\\n                    seen.add(child)\\n                    stack.append(child)\\n                    count += 1\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795356,
                "title": "bfs-o-v-e",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        visited = set([0])\\n        q, res = deque([0]), 0\\n        restricted = set(restricted)\\n        while q:\\n            node = q.popleft()\\n            res += 1\\n            for nei in g[node]:\\n                if nei not in restricted and nei not in visited:\\n                    q.append(nei)\\n                    visited.add(nei)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        visited = set([0])\\n        q, res = deque([0]), 0\\n        restricted = set(restricted)\\n        while q:\\n            node = q.popleft()\\n            res += 1\\n            for nei in g[node]:\\n                if nei not in restricted and nei not in visited:\\n                    q.append(nei)\\n                    visited.add(nei)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786835,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        g=defaultdict(list)\\n        seen=set(restricted)\\n        for e,d in edges:\\n            g[e].append(d)\\n            g[d].append(e)\\n        res=0\\n\\n        def dfs(node):\\n            if node in seen:\\n                return\\n            nonlocal res\\n            res+=1\\n            seen.add(node)    \\n            for n in g[node]:\\n                dfs(n)\\n        dfs(0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        g=defaultdict(list)\\n        seen=set(restricted)\\n        for e,d in edges:\\n            g[e].append(d)\\n            g[d].append(e)\\n        res=0\\n\\n        def dfs(node):\\n            if node in seen:\\n                return\\n            nonlocal res\\n            res+=1\\n            seen.add(node)    \\n            for n in g[node]:\\n                dfs(n)\\n        dfs(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785636,
                "title": "easy-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>adj[], vector<int>&vis, unordered_set<int>&s, int &cnt){\\n        vis[node] =1 ;\\n        cnt ++;\\n        for(auto it : adj[node]){\\n            if(s.find(it) == s.end()){\\n                if(!vis[it]){\\n                    dfs(it, adj, vis, s, cnt);\\n                }\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        unordered_set<int>s(restricted.begin(),restricted.end());\\n        int cnt =0;\\n        vector<int>vis(n,0);\\n        dfs(0, adj, vis, s, cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>adj[], vector<int>&vis, unordered_set<int>&s, int &cnt){\\n        vis[node] =1 ;\\n        cnt ++;\\n        for(auto it : adj[node]){\\n            if(s.find(it) == s.end()){\\n                if(!vis[it]){\\n                    dfs(it, adj, vis, s, cnt);\\n                }\\n            }\\n        }\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        unordered_set<int>s(restricted.begin(),restricted.end());\\n        int cnt =0;\\n        vector<int>vis(n,0);\\n        dfs(0, adj, vis, s, cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784496,
                "title": "dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        var graph = new Dictionary<int, IList<int>>();\\n        var visited = new HashSet<int>();\\n        var hide = new HashSet<int>();\\n\\n        foreach (var value in restricted)\\n        {\\n            hide.Add(value);\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (hide.Contains(i))\\n            {\\n                continue;\\n            }\\n            \\n            graph.Add(i, new List<int>());\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            var from = edge[0];\\n            var to = edge[1];\\n\\n            if (hide.Contains(from) || hide.Contains(to))\\n            {\\n                continue;\\n            }\\n            \\n            graph[from].Add(to);\\n            graph[to].Add(from);\\n        }\\n        \\n        visited.Add(0);\\n        Traverse(graph, visited, 0);\\n\\n        return visited.Count;\\n    }\\n\\n    void Traverse(Dictionary<int, IList<int>> graph, HashSet<int> visited, int start)\\n    {\\n        foreach (var edge in graph[start])\\n        {\\n            if (!visited.Contains(edge))\\n            {\\n                visited.Add(edge);\\n                Traverse(graph, visited, edge);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        var graph = new Dictionary<int, IList<int>>();\\n        var visited = new HashSet<int>();\\n        var hide = new HashSet<int>();\\n\\n        foreach (var value in restricted)\\n        {\\n            hide.Add(value);\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (hide.Contains(i))\\n            {\\n                continue;\\n            }\\n            \\n            graph.Add(i, new List<int>());\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            var from = edge[0];\\n            var to = edge[1];\\n\\n            if (hide.Contains(from) || hide.Contains(to))\\n            {\\n                continue;\\n            }\\n            \\n            graph[from].Add(to);\\n            graph[to].Add(from);\\n        }\\n        \\n        visited.Add(0);\\n        Traverse(graph, visited, 0);\\n\\n        return visited.Count;\\n    }\\n\\n    void Traverse(Dictionary<int, IList<int>> graph, HashSet<int> visited, int start)\\n    {\\n        foreach (var edge in graph[start])\\n        {\\n            if (!visited.Contains(edge))\\n            {\\n                visited.Add(edge);\\n                Traverse(graph, visited, edge);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784495,
                "title": "dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        var graph = new Dictionary<int, IList<int>>();\\n        var visited = new HashSet<int>();\\n        var hide = new HashSet<int>();\\n\\n        foreach (var value in restricted)\\n        {\\n            hide.Add(value);\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (hide.Contains(i))\\n            {\\n                continue;\\n            }\\n            \\n            graph.Add(i, new List<int>());\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            var from = edge[0];\\n            var to = edge[1];\\n\\n            if (hide.Contains(from) || hide.Contains(to))\\n            {\\n                continue;\\n            }\\n            \\n            graph[from].Add(to);\\n            graph[to].Add(from);\\n        }\\n        \\n        visited.Add(0);\\n        Traverse(graph, visited, 0);\\n\\n        return visited.Count;\\n    }\\n\\n    void Traverse(Dictionary<int, IList<int>> graph, HashSet<int> visited, int start)\\n    {\\n        foreach (var edge in graph[start])\\n        {\\n            if (!visited.Contains(edge))\\n            {\\n                visited.Add(edge);\\n                Traverse(graph, visited, edge);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\\n        var graph = new Dictionary<int, IList<int>>();\\n        var visited = new HashSet<int>();\\n        var hide = new HashSet<int>();\\n\\n        foreach (var value in restricted)\\n        {\\n            hide.Add(value);\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (hide.Contains(i))\\n            {\\n                continue;\\n            }\\n            \\n            graph.Add(i, new List<int>());\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            var from = edge[0];\\n            var to = edge[1];\\n\\n            if (hide.Contains(from) || hide.Contains(to))\\n            {\\n                continue;\\n            }\\n            \\n            graph[from].Add(to);\\n            graph[to].Add(from);\\n        }\\n        \\n        visited.Add(0);\\n        Traverse(graph, visited, 0);\\n\\n        return visited.Count;\\n    }\\n\\n    void Traverse(Dictionary<int, IList<int>> graph, HashSet<int> visited, int start)\\n    {\\n        foreach (var edge in graph[start])\\n        {\\n            if (!visited.Contains(edge))\\n            {\\n                visited.Add(edge);\\n                Traverse(graph, visited, edge);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763668,
                "title": "easy-java-solution-using-bfs-just-mark-restricted-one-visited",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int bfs(ArrayList<ArrayList<Integer>>adj,int[]vis)\\n    {\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int count=0;\\n        vis[0]=1;\\n        while(!q.isEmpty())\\n        {\\n            int node=q.poll();\\n            count++;\\n            for(Integer it:adj.get(node))\\n            {\\n                if(vis[it]==0)\\n                {\\n                    vis[it]=1;\\n                    q.add(it);\\n                }\\n            }\\n\\n        }\\n        return count;\\n\\n    }\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0; i<n; i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        int[]vis=new int[n];\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        for(int i=0; i<restricted.length; i++)\\n        {\\n            vis[restricted[i]]=1;\\n        }\\n\\n        return bfs(adj,vis);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int bfs(ArrayList<ArrayList<Integer>>adj,int[]vis)\\n    {\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int count=0;\\n        vis[0]=1;\\n        while(!q.isEmpty())\\n        {\\n            int node=q.poll();\\n            count++;\\n            for(Integer it:adj.get(node))\\n            {\\n                if(vis[it]==0)\\n                {\\n                    vis[it]=1;\\n                    q.add(it);\\n                }\\n            }\\n\\n        }\\n        return count;\\n\\n    }\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0; i<n; i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        int[]vis=new int[n];\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        for(int i=0; i<restricted.length; i++)\\n        {\\n            vis[restricted[i]]=1;\\n        }\\n\\n        return bfs(adj,vis);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754432,
                "title": "easy-python-solution-using-dfs",
                "content": "# Intuition\\nPerform DFS on the Graph\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph= defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        visited = [False] *n\\n        traversed = []\\n        for i in restricted:\\n            visited[i] = True\\n            \\n        def dfs(node):\\n            traversed.append(node)\\n            visited[node] = True\\n            for i in graph[node]:\\n                if not visited[i]:\\n                    dfs(i)\\n        \\n\\n        dfs(0)\\n        return len(traversed)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        graph= defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        visited = [False] *n\\n        traversed = []\\n        for i in restricted:\\n            visited[i] = True\\n            \\n        def dfs(node):\\n            traversed.append(node)\\n            visited[node] = True\\n            for i in graph[node]:\\n                if not visited[i]:\\n                    dfs(i)\\n        \\n\\n        dfs(0)\\n        return len(traversed)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744397,
                "title": "easy-java-bfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS implementation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst create a graph,\\nmark the restricted nodes as visited.\\nAdd the src node to the queue and keep a counter, each time you visit an unrestricted node, increament the counter.\\nreturn the counter value when there are no more node to be visited.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBuilding the adjacency list: O(E)\\nBFS Traversal: O(V + E)\\nOverall: O(V + E)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAdjacency List: O(V + E)\\nVisited Array: O(V)\\nQueue: O(V)\\nOverall: O(V + E)\\n\\n# Code\\n```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for(int i=0;i<restricted.length;i++){\\n            int j = restricted[i];\\n            visited[j] = true;\\n        }\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        q.add(0);\\n        visited[0] = true;\\n        int count = 1;\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n            \\n\\n            for(int i=0;i<adj.get(x).size();i++){\\n                int nei = adj.get(x).get(i);\\n                if(!visited[nei]){\\n                    visited[nei] = true;\\n                    q.add(nei);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for(int i=0;i<restricted.length;i++){\\n            int j = restricted[i];\\n            visited[j] = true;\\n        }\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        q.add(0);\\n        visited[0] = true;\\n        int count = 1;\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n            \\n\\n            for(int i=0;i<adj.get(x).size();i++){\\n                int nei = adj.get(x).get(i);\\n                if(!visited[nei]){\\n                    visited[nei] = true;\\n                    q.add(nei);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742655,
                "title": "javascript-dfs-o-e-v",
                "content": "```\\nvar reachableNodes = function(n, edges, restricted) {\\n  const list = [];\\n  edges.forEach(([u,v]) => {\\n    if (!list[u]) list[u] = [];\\n    if (!list[v]) list[v] = [];\\n    list[u].push(v);\\n    list[v].push(u);\\n  })\\n\\n  restricted = new Set(restricted);\\n\\n  const set = new Set();\\n  let count = 0;\\n  dfs(0);\\n\\n  return count;\\n    \\n  function dfs(node) {\\n    if (set.has(node) || restricted.has(node)) return;\\n    set.add(node);\\n    count++;\\n    if (!list[node]) return;\\n    list[node].forEach(n => dfs(n));\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reachableNodes = function(n, edges, restricted) {\\n  const list = [];\\n  edges.forEach(([u,v]) => {\\n    if (!list[u]) list[u] = [];\\n    if (!list[v]) list[v] = [];\\n    list[u].push(v);\\n    list[v].push(u);\\n  })\\n\\n  restricted = new Set(restricted);\\n\\n  const set = new Set();\\n  let count = 0;\\n  dfs(0);\\n\\n  return count;\\n    \\n  function dfs(node) {\\n    if (set.has(node) || restricted.has(node)) return;\\n    set.add(node);\\n    count++;\\n    if (!list[node]) return;\\n    list[node].forEach(n => dfs(n));\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740596,
                "title": "standard-dfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n+e)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(\\n        self, n: int, edges: List[List[int]], restricted: List[int]\\n    ) -> int:\\n        # convert edges to graph (node : neighbours) pairs\\n        nodes = list(set([item for sublist in edges for item in sublist]))\\n        graph = {node: [] for node in nodes}\\n        for e in edges:\\n            # bi-directional\\n            graph[e[0]].append(e[1])\\n            graph[e[1]].append(e[0])\\n\\n        def dfs(root: int, path: set, graph: dict, restricted: set):\\n            if root in path or root in restricted:\\n                # stop graph dfs if we land visited or restricted node\\n                return 0\\n            path.add(root)\\n            for neighbour in graph[root]:\\n                dfs(neighbour, path, graph, restricted)\\n            return len(path)\\n\\n        path = set()  # this should save longest dfs traversal path from root node\\n        restricted_hash_set = set(restricted) # hashset for O(1) queries\\n        return dfs(\\n            0, path, graph, restricted_hash_set\\n        )  # start dfs from node 0 and keep update dfs path for with every valid node\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(\\n        self, n: int, edges: List[List[int]], restricted: List[int]\\n    ) -> int:\\n        # convert edges to graph (node : neighbours) pairs\\n        nodes = list(set([item for sublist in edges for item in sublist]))\\n        graph = {node: [] for node in nodes}\\n        for e in edges:\\n            # bi-directional\\n            graph[e[0]].append(e[1])\\n            graph[e[1]].append(e[0])\\n\\n        def dfs(root: int, path: set, graph: dict, restricted: set):\\n            if root in path or root in restricted:\\n                # stop graph dfs if we land visited or restricted node\\n                return 0\\n            path.add(root)\\n            for neighbour in graph[root]:\\n                dfs(neighbour, path, graph, restricted)\\n            return len(path)\\n\\n        path = set()  # this should save longest dfs traversal path from root node\\n        restricted_hash_set = set(restricted) # hashset for O(1) queries\\n        return dfs(\\n            0, path, graph, restricted_hash_set\\n        )  # start dfs from node 0 and keep update dfs path for with every valid node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720469,
                "title": "dfs-solution",
                "content": "# NOTE--> If you get TLE in your code then just use HashSet for rectricted array instead of list or any other\\n\\n# Code\\n```\\nclass Solution {\\n    int res=0;\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        ArrayList<ArrayList<Integer>>li=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            li.add(new ArrayList<>());\\n        }\\n        for(int edge[]:edges){\\n            int a=edge[0];\\n            int b=edge[1];\\n            li.get(a).add(b);\\n            li.get(b).add(a);\\n        }\\n        Set<Integer>restrictset=new HashSet<>();\\n        for(int x:restricted)restrictset.add(x);\\n        boolean visited[]=new boolean[n];\\n    \\n        dfs(0,li,restrictset,visited);\\n        \\n        // for(boolean isTrue:visited){\\n        //     if(isTrue)res++;\\n        // }\\n\\n        return res;\\n    }\\n    public void dfs(int s,ArrayList<ArrayList<Integer>>li,Set<Integer>restrictset,boolean visited[])\\n    {\\n        \\n        visited[s]=true;\\n        res++;\\n\\n        for(int u:li.get(s) )\\n        {\\n            if(restrictset.contains(u)){\\n                continue;\\n\\n            }\\n            if(!visited[u]){\\n                dfs(u,li,restrictset,visited);\\n            }\\n    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        ArrayList<ArrayList<Integer>>li=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            li.add(new ArrayList<>());\\n        }\\n        for(int edge[]:edges){\\n            int a=edge[0];\\n            int b=edge[1];\\n            li.get(a).add(b);\\n            li.get(b).add(a);\\n        }\\n        Set<Integer>restrictset=new HashSet<>();\\n        for(int x:restricted)restrictset.add(x);\\n        boolean visited[]=new boolean[n];\\n    \\n        dfs(0,li,restrictset,visited);\\n        \\n        // for(boolean isTrue:visited){\\n        //     if(isTrue)res++;\\n        // }\\n\\n        return res;\\n    }\\n    public void dfs(int s,ArrayList<ArrayList<Integer>>li,Set<Integer>restrictset,boolean visited[])\\n    {\\n        \\n        visited[s]=true;\\n        res++;\\n\\n        for(int u:li.get(s) )\\n        {\\n            if(restrictset.contains(u)){\\n                continue;\\n\\n            }\\n            if(!visited[u]){\\n                dfs(u,li,restrictset,visited);\\n            }\\n    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703313,
                "title": "c-simple-dfs-and-hash",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int>arr;\\n     void dfs(vector<vector<int>>& edges,unordered_map<int,int>&mp,int node,int par,vector<int>adj[])\\n     {\\n    arr[node]=1;\\n       for(auto child:adj[node])\\n       {\\n     if(child!=par && !mp[child])\\n     {\\n         dfs(edges,mp,child,node,adj);\\n         arr[node]+=arr[child];\\n     }\\n       }\\n     }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& re) {\\n        \\n        arr.resize(n+1,0);\\n        unordered_map<int,int>mp;\\n        for(auto r:re) mp[r]=1;\\n        vector<int>adj[n+1];\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        dfs(edges,mp,0,-1,adj);    \\n        return arr[0];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int>arr;\\n     void dfs(vector<vector<int>>& edges,unordered_map<int,int>&mp,int node,int par,vector<int>adj[])\\n     {\\n    arr[node]=1;\\n       for(auto child:adj[node])\\n       {\\n     if(child!=par && !mp[child])\\n     {\\n         dfs(edges,mp,child,node,adj);\\n         arr[node]+=arr[child];\\n     }\\n       }\\n     }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& re) {\\n        \\n        arr.resize(n+1,0);\\n        unordered_map<int,int>mp;\\n        for(auto r:re) mp[r]=1;\\n        vector<int>adj[n+1];\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        dfs(edges,mp,0,-1,adj);    \\n        return arr[0];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701117,
                "title": "easy-dfs-solution-graph-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>& adj,  map<int,int> &mp,int &ans,vector<int> &vis)\\n    {\\n        vis[node]=1;\\n        for(auto it:adj[node])\\n        {\\n            if(vis[it]==-1 && mp.find(it)==mp.end())\\n            {\\n                ans++;\\n                vis[it]=1;\\n                dfs(it,adj,mp,ans,vis);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> vis(n,-1);\\n        map<int,int> mp;//for easy searching\\n        for(int i=0;i<restricted.size();i++)\\n        {\\n            mp[restricted[i]]++;\\n        }\\n        vis[0]=1;\\n        int ans=1;\\n        dfs(0,adj,mp,ans,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>& adj,  map<int,int> &mp,int &ans,vector<int> &vis)\\n    {\\n        vis[node]=1;\\n        for(auto it:adj[node])\\n        {\\n            if(vis[it]==-1 && mp.find(it)==mp.end())\\n            {\\n                ans++;\\n                vis[it]=1;\\n                dfs(it,adj,mp,ans,vis);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> vis(n,-1);\\n        map<int,int> mp;//for easy searching\\n        for(int i=0;i<restricted.size();i++)\\n        {\\n            mp[restricted[i]]++;\\n        }\\n        vis[0]=1;\\n        int ans=1;\\n        dfs(0,adj,mp,ans,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695923,
                "title": "easy-java-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int count=0;\\n    private void dfs(ArrayList<ArrayList<Integer>> adj,int node, HashSet<Integer> s, boolean[] visited){\\n        visited[node]=true;\\n        count++;\\n        for(int it:adj.get(node)){\\n            if(!visited[it] && !s.contains(it)){\\n                dfs(adj,it,s,visited);\\n            }\\n        }\\n    }\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        HashSet<Integer> s=new HashSet<>();\\n        for(int i=0;i<restricted.length;i++){\\n            s.add(restricted[i]);\\n        }\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        boolean[] visited=new boolean[n];\\n        dfs(adj,0,s,visited);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int count=0;\\n    private void dfs(ArrayList<ArrayList<Integer>> adj,int node, HashSet<Integer> s, boolean[] visited){\\n        visited[node]=true;\\n        count++;\\n        for(int it:adj.get(node)){\\n            if(!visited[it] && !s.contains(it)){\\n                dfs(adj,it,s,visited);\\n            }\\n        }\\n    }\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        HashSet<Integer> s=new HashSet<>();\\n        for(int i=0;i<restricted.length;i++){\\n            s.add(restricted[i]);\\n        }\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        boolean[] visited=new boolean[n];\\n        dfs(adj,0,s,visited);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682383,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node , vector<int>& vis , vector<int> adj[] , int& count){\\n        vis[node] = 1;\\n        count++;\\n        for (auto neighbour : adj[node]){\\n            if (!vis[neighbour]){\\n                dfs(neighbour , vis , adj , count);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n        for (int i=0 ; i<n-1 ; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        } \\n\\n        vector<int> vis(n , 0);\\n        for (int i : restricted)\\n            vis[i] = 1;\\n\\n        int count = 0;\\n        dfs(0 , vis , adj , count);\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node , vector<int>& vis , vector<int> adj[] , int& count){\\n        vis[node] = 1;\\n        count++;\\n        for (auto neighbour : adj[node]){\\n            if (!vis[neighbour]){\\n                dfs(neighbour , vis , adj , count);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int> adj[n];\\n        for (int i=0 ; i<n-1 ; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        } \\n\\n        vector<int> vis(n , 0);\\n        for (int i : restricted)\\n            vis[i] = 1;\\n\\n        int count = 0;\\n        dfs(0 , vis , adj , count);\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651587,
                "title": "using-disjointset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        int cnt = 0;\\n        Set<Integer> st = new HashSet<>();\\n        DisjointSet ds = new DisjointSet(n);\\n        for(int it : restricted) st.add(it);\\n        for(int[] it : edges){\\n            int u = it[0], v = it[1];\\n            if(st.contains(ds.findUPar(u)) || st.contains(ds.findUPar(v))) continue;\\n            ds.unionBySize(u, v);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ds.findUPar(0) == ds.findUPar(i)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\nclass DisjointSet{\\n    List<Integer> rank = new ArrayList<>(), parent = new ArrayList<>(), size = new ArrayList<>();\\n    public DisjointSet(int n){\\n        for(int i = 0; i <= n; i++){\\n            parent.add(i, i);\\n            rank.add(i, 0);\\n            size.add(i, 1);\\n        }\\n    }\\n    public int findUPar(int node){\\n        if(parent.get(node) == node) return node;\\n        int ulp = findUPar(parent.get(node));\\n        parent.set(node, ulp);\\n        return ulp;\\n    }\\n    public void unionBySize(int u, int v){\\n        int ulp_u = findUPar(u), ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(size.get(ulp_v) > size.get(ulp_u)){\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_u) + size.get(ulp_v));\\n        } else {\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_v) + size.get(ulp_u)); \\n        }\\n    }\\n    public void unionByRank(int u, int v){\\n        int ulp_u = findUPar(u), ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank.get(ulp_u) > rank.get(ulp_v)){\\n            parent.set(ulp_v, ulp_u);\\n        } else if(rank.get(ulp_v) > rank.get(ulp_u)){\\n            parent.set(ulp_u, ulp_v);\\n        } else {\\n            parent.set(ulp_u, ulp_v); \\n            int ri = rank.get(ulp_v);\\n            rank.set(ulp_v, ri + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\\n        int cnt = 0;\\n        Set<Integer> st = new HashSet<>();\\n        DisjointSet ds = new DisjointSet(n);\\n        for(int it : restricted) st.add(it);\\n        for(int[] it : edges){\\n            int u = it[0], v = it[1];\\n            if(st.contains(ds.findUPar(u)) || st.contains(ds.findUPar(v))) continue;\\n            ds.unionBySize(u, v);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ds.findUPar(0) == ds.findUPar(i)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\nclass DisjointSet{\\n    List<Integer> rank = new ArrayList<>(), parent = new ArrayList<>(), size = new ArrayList<>();\\n    public DisjointSet(int n){\\n        for(int i = 0; i <= n; i++){\\n            parent.add(i, i);\\n            rank.add(i, 0);\\n            size.add(i, 1);\\n        }\\n    }\\n    public int findUPar(int node){\\n        if(parent.get(node) == node) return node;\\n        int ulp = findUPar(parent.get(node));\\n        parent.set(node, ulp);\\n        return ulp;\\n    }\\n    public void unionBySize(int u, int v){\\n        int ulp_u = findUPar(u), ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(size.get(ulp_v) > size.get(ulp_u)){\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_u) + size.get(ulp_v));\\n        } else {\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_v) + size.get(ulp_u)); \\n        }\\n    }\\n    public void unionByRank(int u, int v){\\n        int ulp_u = findUPar(u), ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank.get(ulp_u) > rank.get(ulp_v)){\\n            parent.set(ulp_v, ulp_u);\\n        } else if(rank.get(ulp_v) > rank.get(ulp_u)){\\n            parent.set(ulp_u, ulp_v);\\n        } else {\\n            parent.set(ulp_u, ulp_v); \\n            int ri = rank.get(ulp_v);\\n            rank.set(ulp_v, ri + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642618,
                "title": "faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are not considering edges which involves restricted nodes and apply union find and count number of nodes in each connected group and output which has 0 in it.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int find(int a){\\n        return nums[a] < 0?a:nums[a]=find(nums[a]);\\n    }\\n    void help(int a, int b){\\n        nums[a] += nums[b];\\n        nums[b] = a;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) {\\n        nums.resize(n, -1);\\n        unordered_set<int> s(r.begin(), r.end());\\n        for(auto e:edges){\\n            if(s.find(e[0]) != s.end() || s.find(e[1]) != s.end()){\\n                continue;\\n            }\\n            int x = find(e[0]);\\n            int y = find(e[1]);\\n            if(x != y){\\n                help(x, y);\\n            }\\n        }\\n        return abs(nums[find(0)]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int find(int a){\\n        return nums[a] < 0?a:nums[a]=find(nums[a]);\\n    }\\n    void help(int a, int b){\\n        nums[a] += nums[b];\\n        nums[b] = a;\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& r) {\\n        nums.resize(n, -1);\\n        unordered_set<int> s(r.begin(), r.end());\\n        for(auto e:edges){\\n            if(s.find(e[0]) != s.end() || s.find(e[1]) != s.end()){\\n                continue;\\n            }\\n            int x = find(e[0]);\\n            int y = find(e[1]);\\n            if(x != y){\\n                help(x, y);\\n            }\\n        }\\n        return abs(nums[find(0)]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640835,
                "title": "c-dfs",
                "content": "Impossible to have cycle with n nodes and n-1 edges.\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> v(n);\\n        for (auto& n : restricted) v[n] = true;\\n        vector<vector<int>> g(n);\\n        for (auto& v : edges){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n        return dfs(v, 0, g);      \\n    }\\n    int dfs(vector<bool>& v, int node, vector<vector<int>>& g){\\n        if (v[node]) return 0;\\n        v[node] = true;\\n        int ans = 1;\\n        for (auto& e : g[node]) ans += dfs(v, e, g);\\n        return ans;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool> v(n);\\n        for (auto& n : restricted) v[n] = true;\\n        vector<vector<int>> g(n);\\n        for (auto& v : edges){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n        return dfs(v, 0, g);      \\n    }\\n    int dfs(vector<bool>& v, int node, vector<vector<int>>& g){\\n        if (v[node]) return 0;\\n        v[node] = true;\\n        int ans = 1;\\n        for (auto& e : g[node]) ans += dfs(v, e, g);\\n        return ans;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633828,
                "title": "easy-solution-using-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate: void dfs(int node, vector<int>& vis, vector<int>adj[]){\\n     vis[node]=1;\\n     for(auto it: adj[node]){\\n         if(vis[it]==0 && vis[it]!=-1){\\n             dfs(it, vis, adj);\\n         }\\n     }\\n}\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n           vector<int>adj[n];\\n           vector<int>vis(n,0);\\n           for(auto it: edges){\\n               adj[it[0]].push_back(it[1]);\\n               adj[it[1]].push_back(it[0]);\\n           }\\n           for(int i=0; i<restricted.size(); i++){\\n                vis[restricted[i]]=-1;\\n           }\\n           dfs(0 , vis, adj);\\n           int p=0;\\n           for(int i=0; i<n; i++){\\n               if(vis[i]==1){\\n                   p++;\\n               }\\n           }\\n           return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate: void dfs(int node, vector<int>& vis, vector<int>adj[]){\\n     vis[node]=1;\\n     for(auto it: adj[node]){\\n         if(vis[it]==0 && vis[it]!=-1){\\n             dfs(it, vis, adj);\\n         }\\n     }\\n}\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n           vector<int>adj[n];\\n           vector<int>vis(n,0);\\n           for(auto it: edges){\\n               adj[it[0]].push_back(it[1]);\\n               adj[it[1]].push_back(it[0]);\\n           }\\n           for(int i=0; i<restricted.size(); i++){\\n                vis[restricted[i]]=-1;\\n           }\\n           dfs(0 , vis, adj);\\n           int p=0;\\n           for(int i=0; i<n; i++){\\n               if(vis[i]==1){\\n                   p++;\\n               }\\n           }\\n           return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630092,
                "title": "c-solution-simple-easy-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void DFS(int i, vector<int> vec[], vector<pair<int,int>> &vis, vector<int>& res, int &ans)\\n    {\\n        vis[i].first=1;\\n        if(vis[i].second==1)\\n        return ;\\n        \\n        ans++;\\n        for(auto it: vec[i])\\n        {\\n            if(vis[it].first==0)\\n            {\\n                DFS(it,vec,vis,res,ans);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<int> vec[n+1];\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            vec[edges[i][0]].push_back(edges[i][1]);\\n            vec[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<pair<int,int>> vis(n+1);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            vis[i].first = 0;\\n            vis[i].second = 0;\\n        }\\n\\n        for(int i=0; i<res.size(); i++)\\n        {\\n            vis[res[i]].second = 1;\\n        }\\n\\n        int ans = 0;\\n\\n        DFS(0,vec,vis,res,ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void DFS(int i, vector<int> vec[], vector<pair<int,int>> &vis, vector<int>& res, int &ans)\\n    {\\n        vis[i].first=1;\\n        if(vis[i].second==1)\\n        return ;\\n        \\n        ans++;\\n        for(auto it: vec[i])\\n        {\\n            if(vis[it].first==0)\\n            {\\n                DFS(it,vec,vis,res,ans);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<int> vec[n+1];\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            vec[edges[i][0]].push_back(edges[i][1]);\\n            vec[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<pair<int,int>> vis(n+1);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            vis[i].first = 0;\\n            vis[i].second = 0;\\n        }\\n\\n        for(int i=0; i<res.size(); i++)\\n        {\\n            vis[res[i]].second = 1;\\n        }\\n\\n        int ans = 0;\\n\\n        DFS(0,vec,vis,res,ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613968,
                "title": "easy-c-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int src,vector<int>& vis,int &ans,vector<int> adj[]){\\n        vis[src] = 1;\\n        ans++;\\n        // cout<<src<<endl;\\n        for(auto it:adj[src]){\\n            if(vis[it] == 0){\\n                dfs(it,vis,ans,adj);\\n            }\\n        }\\n\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n         vector<int> adj[n];\\n         for(int i = 0;i<edges.size();i++){\\n             adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n         }\\n      \\n         int ans =0;\\n         vector<int> vis(n,0);\\n         for(auto it:restricted){\\n             vis[it] = 1;\\n         }\\n         dfs(0,vis,ans,adj);\\n         return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int src,vector<int>& vis,int &ans,vector<int> adj[]){\\n        vis[src] = 1;\\n        ans++;\\n        // cout<<src<<endl;\\n        for(auto it:adj[src]){\\n            if(vis[it] == 0){\\n                dfs(it,vis,ans,adj);\\n            }\\n        }\\n\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n         vector<int> adj[n];\\n         for(int i = 0;i<edges.size();i++){\\n             adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n         }\\n      \\n         int ans =0;\\n         vector<int> vis(n,0);\\n         for(auto it:restricted){\\n             vis[it] = 1;\\n         }\\n         dfs(0,vis,ans,adj);\\n         return ans; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3613963,
                "title": "c-easy-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int src,vector<int>& vis,int &ans,vector<int> adj[]){\\n        vis[src] = 1;\\n        ans++;\\n        \\n        for(auto it:adj[src]){\\n            if(vis[it] == 0){\\n                dfs(it,vis,ans,adj);\\n            }\\n        }\\n\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n         vector<int> adj[n],vis(n,0);\\n         for(int i = 0;i<edges.size();i++){\\n             adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n         }\\n         \\n        \\n         for(auto it:restricted){\\n             vis[it] = 1;\\n         }\\n         if(vis[0] == 1) return 0;\\n         queue<int> q;\\n         q.push(0);\\n         int ans = 0;\\n         while(!q.empty()){\\n             int temp = q.front();\\n             q.pop();\\n            //  ans++;\\n             for(auto it:adj[temp]){\\n                 if(!vis[it]){\\n                     vis[it] = 1;\\n                     ans++;\\n                     q.push(it);\\n                 }\\n             }\\n         }\\n         if(ans == 0) ans +=1;\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int src,vector<int>& vis,int &ans,vector<int> adj[]){\\n        vis[src] = 1;\\n        ans++;\\n        \\n        for(auto it:adj[src]){\\n            if(vis[it] == 0){\\n                dfs(it,vis,ans,adj);\\n            }\\n        }\\n\\n    }\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n         vector<int> adj[n],vis(n,0);\\n         for(int i = 0;i<edges.size();i++){\\n             adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n         }\\n         \\n        \\n         for(auto it:restricted){\\n             vis[it] = 1;\\n         }\\n         if(vis[0] == 1) return 0;\\n         queue<int> q;\\n         q.push(0);\\n         int ans = 0;\\n         while(!q.empty()){\\n             int temp = q.front();\\n             q.pop();\\n            //  ans++;\\n             for(auto it:adj[temp]){\\n                 if(!vis[it]){\\n                     vis[it] = 1;\\n                     ans++;\\n                     q.push(it);\\n                 }\\n             }\\n         }\\n         if(ans == 0) ans +=1;\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592428,
                "title": "easy-c-solution-using-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int s,vector<int>adj[],vector<bool>&visited,int &count)\\n{\\n    visited[s]=true;\\n    count++;\\n    for(auto i:adj[s]) {\\n        if(!visited[i]){\\n            dfs(i,adj,visited,count);\\n        }\\n    }\\n}\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool>visited(n,false);\\n        vector<int>adj[n];\\n        int count=0;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n       for(int i=0;i<restricted.size();i++){\\n           visited[restricted[i]]=true;\\n       }\\n           dfs(0,adj,visited,count);\\n       return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int s,vector<int>adj[],vector<bool>&visited,int &count)\\n{\\n    visited[s]=true;\\n    count++;\\n    for(auto i:adj[s]) {\\n        if(!visited[i]){\\n            dfs(i,adj,visited,count);\\n        }\\n    }\\n}\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<bool>visited(n,false);\\n        vector<int>adj[n];\\n        int count=0;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n       for(int i=0;i<restricted.size();i++){\\n           visited[restricted[i]]=true;\\n       }\\n           dfs(0,adj,visited,count);\\n       return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591649,
                "title": "c-code-96-beats-easy-solution-bfs-with-intuition",
                "content": "# Intuition\\nThe given graph is an undirected graph. so there exists no loops or cycles in the given graph.The intution is to traverse the whole graph without travelling the restricted nodes.So prepare the new adjacency list cancelling or removing the edges whichh consist of restrictd nodes. And the do normal BFS traversal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Average TC-O(E+n-Restricted)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        vector<int> safe(n,0);\\n\\n        for(auto x:restricted) safe[x]++;\\n\\n        for(auto it:edges)\\n        {\\n            if(safe[it[0]]==0 && safe[it[1]]==0)\\n            {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            }\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n        safe[0]=1;\\n        int count=0;\\n        while(q.size())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            count++;\\n            for(auto it:adj[node])\\n            {\\n                if(safe[it]==0)\\n                {\\n                    safe[it]=1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return count;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<vector<int>> adj(n);\\n        vector<int> safe(n,0);\\n\\n        for(auto x:restricted) safe[x]++;\\n\\n        for(auto it:edges)\\n        {\\n            if(safe[it[0]]==0 && safe[it[1]]==0)\\n            {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            }\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n        safe[0]=1;\\n        int count=0;\\n        while(q.size())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            count++;\\n            for(auto it:adj[node])\\n            {\\n                if(safe[it]==0)\\n                {\\n                    safe[it]=1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return count;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581734,
                "title": "easy-dfs-code-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i, vector<vector<int>>& graph, vector<int>& vis, int& ans, vector<int>& res) {\\n        // Mark the current node as visited\\n        vis[i] = 1;\\n\\n        // If the current node is restricted, return\\n        if (res[i] == 1) return;\\n\\n        // Increment the answer count\\n        ans++;\\n\\n        // Traverse the neighbors of the current node\\n        for (int j = 0; j < graph[i].size(); j++) {\\n            if (!vis[graph[i][j]]) {\\n                // Recursively visit the unvisited neighbors\\n                dfs(graph[i][j], graph, vis, ans, res);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> graph(n);\\n\\n        // Build the graph using the given edges\\n        for (auto x : edges) {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n\\n        // Initialize the visited array and restricted nodes array\\n        vector<int> vis(n, 0);\\n        vector<int> res(n, 0);\\n\\n        // Mark the restricted nodes as restricted\\n        for (int i = 0; i < restricted.size(); i++) {\\n            res[restricted[i]] = 1;\\n        }\\n\\n        // Initialize the answer count\\n        int ans = 0;\\n\\n        // Perform a depth-first search starting from node 0\\n        dfs(0, graph, vis, ans, res);\\n\\n        // Return the total reachable nodes count\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i, vector<vector<int>>& graph, vector<int>& vis, int& ans, vector<int>& res) {\\n        // Mark the current node as visited\\n        vis[i] = 1;\\n\\n        // If the current node is restricted, return\\n        if (res[i] == 1) return;\\n\\n        // Increment the answer count\\n        ans++;\\n\\n        // Traverse the neighbors of the current node\\n        for (int j = 0; j < graph[i].size(); j++) {\\n            if (!vis[graph[i][j]]) {\\n                // Recursively visit the unvisited neighbors\\n                dfs(graph[i][j], graph, vis, ans, res);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> graph(n);\\n\\n        // Build the graph using the given edges\\n        for (auto x : edges) {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n\\n        // Initialize the visited array and restricted nodes array\\n        vector<int> vis(n, 0);\\n        vector<int> res(n, 0);\\n\\n        // Mark the restricted nodes as restricted\\n        for (int i = 0; i < restricted.size(); i++) {\\n            res[restricted[i]] = 1;\\n        }\\n\\n        // Initialize the answer count\\n        int ans = 0;\\n\\n        // Perform a depth-first search starting from node 0\\n        dfs(0, graph, vis, ans, res);\\n\\n        // Return the total reachable nodes count\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570510,
                "title": "python-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+e) (visits each node and edge once)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        def dfs(node):\\n            nonlocal ans\\n            if node not in seen:\\n                seen.add(node)\\n                ans += 1\\n                for neighbor in graph[node]:\\n                    dfs(neighbor)\\n\\n        ans = 0\\n        seen = set(restricted)\\n        graph = collections.defaultdict(list)\\n\\n        for first, second in edges:\\n            graph[first].append(second)\\n            graph[second].append(first)\\n\\n        dfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\n        def dfs(node):\\n            nonlocal ans\\n            if node not in seen:\\n                seen.add(node)\\n                ans += 1\\n                for neighbor in graph[node]:\\n                    dfs(neighbor)\\n\\n        ans = 0\\n        seen = set(restricted)\\n        graph = collections.defaultdict(list)\\n\\n        for first, second in edges:\\n            graph[first].append(second)\\n            graph[second].append(first)\\n\\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565377,
                "title": "c-bfs-memory-beats-98-4-time-beats-84",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>graph[n+5];\\n        int e=edges.size();\\n        int rs=restricted.size();\\n        int vis[n+5];\\n        for(int i=0;i<=n;i++)vis[i]=0;\\n        for(int i=0;i<rs;i++)vis[restricted[i]]=1;\\n        for(int i=0;i<e;i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        vis[0]=1;\\n        int ans=1;\\n        while(!q.empty())\\n        {\\n            int f=q.front();\\n            q.pop();\\n            for(auto x:graph[f])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    q.push(x);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\\n        vector<int>graph[n+5];\\n        int e=edges.size();\\n        int rs=restricted.size();\\n        int vis[n+5];\\n        for(int i=0;i<=n;i++)vis[i]=0;\\n        for(int i=0;i<rs;i++)vis[restricted[i]]=1;\\n        for(int i=0;i<e;i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        vis[0]=1;\\n        int ans=1;\\n        while(!q.empty())\\n        {\\n            int f=q.front();\\n            q.pop();\\n            for(auto x:graph[f])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    q.push(x);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1727595,
                "content": [
                    {
                        "username": "XOFJO",
                        "content": "this is supposed to be a easy quesiton"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "If your DFS gets TLE in Python 3, make sure to turn \\'restriced\\' into a SET or add it to a SET to check the visited nodes.\\nThe operation \"For xxxx in LIST\" is super slow."
                    },
                    {
                        "username": "kishor045",
                        "content": "n =\\n10\\nedges =\\n[[8,2],[2,5],[5,0],[2,7],[1,7],[3,8],[0,4],[3,9],[1,6]]\\nrestricted =\\n[9,8,4,5,3,1]\\n\\nFor the above input it is clear that the answer should be 2 as we can reach 7 from 2 and vice versa but the output is 1 could somebody explain me this?"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "as I understand now the only maximum you need to find is for starting node 0 (?!) initially I thought for 0 to n-1...."
                    },
                    {
                        "username": "Kiricon",
                        "content": "You HAVE to start from node 0. [2,7] doesn\\'t work because 2 is not a valid starting point. "
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Definitely should be an easy question"
                    },
                    {
                        "username": "aezyy",
                        "content": "Should be marked easy"
                    },
                    {
                        "username": "adeshsengar156",
                        "content": "Actually my recursive code works but its creates tle  (time limit exceeded) for large number of inputs. I am so much glad if somebody help me out that how to apply the dp solution in this code.\\n"
                    },
                    {
                        "username": "OkoksNeDam",
                        "content": "Try to convert restricted to set, because the operation of finding x in list is slow"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "\\n    void dfs(int u , int p , vector<int> adj[] , vector<bool> &isRes , int &cnt) {\\n        ans = max(ans , cnt);\\n        for(int v : adj[u]) {\\n            if(v != p && !isRes[v]) {\\n                cnt++;\\n                dfs(v , u , adj , isRes , cnt);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<bool> isRes(n , false);\\n        for(int i=0 ; i<res.size() ; i++) {\\n            isRes[res[i]] = true;\\n        }\\n        ans = 0;\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt = 1;\\n        dfs(0 , -1 , adj , isRes , cnt);\\n        return ans;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1787937,
                "content": [
                    {
                        "username": "XOFJO",
                        "content": "this is supposed to be a easy quesiton"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "If your DFS gets TLE in Python 3, make sure to turn \\'restriced\\' into a SET or add it to a SET to check the visited nodes.\\nThe operation \"For xxxx in LIST\" is super slow."
                    },
                    {
                        "username": "kishor045",
                        "content": "n =\\n10\\nedges =\\n[[8,2],[2,5],[5,0],[2,7],[1,7],[3,8],[0,4],[3,9],[1,6]]\\nrestricted =\\n[9,8,4,5,3,1]\\n\\nFor the above input it is clear that the answer should be 2 as we can reach 7 from 2 and vice versa but the output is 1 could somebody explain me this?"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "as I understand now the only maximum you need to find is for starting node 0 (?!) initially I thought for 0 to n-1...."
                    },
                    {
                        "username": "Kiricon",
                        "content": "You HAVE to start from node 0. [2,7] doesn\\'t work because 2 is not a valid starting point. "
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Definitely should be an easy question"
                    },
                    {
                        "username": "aezyy",
                        "content": "Should be marked easy"
                    },
                    {
                        "username": "adeshsengar156",
                        "content": "Actually my recursive code works but its creates tle  (time limit exceeded) for large number of inputs. I am so much glad if somebody help me out that how to apply the dp solution in this code.\\n"
                    },
                    {
                        "username": "OkoksNeDam",
                        "content": "Try to convert restricted to set, because the operation of finding x in list is slow"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "\\n    void dfs(int u , int p , vector<int> adj[] , vector<bool> &isRes , int &cnt) {\\n        ans = max(ans , cnt);\\n        for(int v : adj[u]) {\\n            if(v != p && !isRes[v]) {\\n                cnt++;\\n                dfs(v , u , adj , isRes , cnt);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<bool> isRes(n , false);\\n        for(int i=0 ; i<res.size() ; i++) {\\n            isRes[res[i]] = true;\\n        }\\n        ans = 0;\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt = 1;\\n        dfs(0 , -1 , adj , isRes , cnt);\\n        return ans;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1676302,
                "content": [
                    {
                        "username": "XOFJO",
                        "content": "this is supposed to be a easy quesiton"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "If your DFS gets TLE in Python 3, make sure to turn \\'restriced\\' into a SET or add it to a SET to check the visited nodes.\\nThe operation \"For xxxx in LIST\" is super slow."
                    },
                    {
                        "username": "kishor045",
                        "content": "n =\\n10\\nedges =\\n[[8,2],[2,5],[5,0],[2,7],[1,7],[3,8],[0,4],[3,9],[1,6]]\\nrestricted =\\n[9,8,4,5,3,1]\\n\\nFor the above input it is clear that the answer should be 2 as we can reach 7 from 2 and vice versa but the output is 1 could somebody explain me this?"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "as I understand now the only maximum you need to find is for starting node 0 (?!) initially I thought for 0 to n-1...."
                    },
                    {
                        "username": "Kiricon",
                        "content": "You HAVE to start from node 0. [2,7] doesn\\'t work because 2 is not a valid starting point. "
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Definitely should be an easy question"
                    },
                    {
                        "username": "aezyy",
                        "content": "Should be marked easy"
                    },
                    {
                        "username": "adeshsengar156",
                        "content": "Actually my recursive code works but its creates tle  (time limit exceeded) for large number of inputs. I am so much glad if somebody help me out that how to apply the dp solution in this code.\\n"
                    },
                    {
                        "username": "OkoksNeDam",
                        "content": "Try to convert restricted to set, because the operation of finding x in list is slow"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "\\n    void dfs(int u , int p , vector<int> adj[] , vector<bool> &isRes , int &cnt) {\\n        ans = max(ans , cnt);\\n        for(int v : adj[u]) {\\n            if(v != p && !isRes[v]) {\\n                cnt++;\\n                dfs(v , u , adj , isRes , cnt);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<bool> isRes(n , false);\\n        for(int i=0 ; i<res.size() ; i++) {\\n            isRes[res[i]] = true;\\n        }\\n        ans = 0;\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt = 1;\\n        dfs(0 , -1 , adj , isRes , cnt);\\n        return ans;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1973308,
                "content": [
                    {
                        "username": "XOFJO",
                        "content": "this is supposed to be a easy quesiton"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "If your DFS gets TLE in Python 3, make sure to turn \\'restriced\\' into a SET or add it to a SET to check the visited nodes.\\nThe operation \"For xxxx in LIST\" is super slow."
                    },
                    {
                        "username": "kishor045",
                        "content": "n =\\n10\\nedges =\\n[[8,2],[2,5],[5,0],[2,7],[1,7],[3,8],[0,4],[3,9],[1,6]]\\nrestricted =\\n[9,8,4,5,3,1]\\n\\nFor the above input it is clear that the answer should be 2 as we can reach 7 from 2 and vice versa but the output is 1 could somebody explain me this?"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "as I understand now the only maximum you need to find is for starting node 0 (?!) initially I thought for 0 to n-1...."
                    },
                    {
                        "username": "Kiricon",
                        "content": "You HAVE to start from node 0. [2,7] doesn\\'t work because 2 is not a valid starting point. "
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Definitely should be an easy question"
                    },
                    {
                        "username": "aezyy",
                        "content": "Should be marked easy"
                    },
                    {
                        "username": "adeshsengar156",
                        "content": "Actually my recursive code works but its creates tle  (time limit exceeded) for large number of inputs. I am so much glad if somebody help me out that how to apply the dp solution in this code.\\n"
                    },
                    {
                        "username": "OkoksNeDam",
                        "content": "Try to convert restricted to set, because the operation of finding x in list is slow"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "\\n    void dfs(int u , int p , vector<int> adj[] , vector<bool> &isRes , int &cnt) {\\n        ans = max(ans , cnt);\\n        for(int v : adj[u]) {\\n            if(v != p && !isRes[v]) {\\n                cnt++;\\n                dfs(v , u , adj , isRes , cnt);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<bool> isRes(n , false);\\n        for(int i=0 ; i<res.size() ; i++) {\\n            isRes[res[i]] = true;\\n        }\\n        ans = 0;\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt = 1;\\n        dfs(0 , -1 , adj , isRes , cnt);\\n        return ans;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1936024,
                "content": [
                    {
                        "username": "XOFJO",
                        "content": "this is supposed to be a easy quesiton"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "If your DFS gets TLE in Python 3, make sure to turn \\'restriced\\' into a SET or add it to a SET to check the visited nodes.\\nThe operation \"For xxxx in LIST\" is super slow."
                    },
                    {
                        "username": "kishor045",
                        "content": "n =\\n10\\nedges =\\n[[8,2],[2,5],[5,0],[2,7],[1,7],[3,8],[0,4],[3,9],[1,6]]\\nrestricted =\\n[9,8,4,5,3,1]\\n\\nFor the above input it is clear that the answer should be 2 as we can reach 7 from 2 and vice versa but the output is 1 could somebody explain me this?"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "as I understand now the only maximum you need to find is for starting node 0 (?!) initially I thought for 0 to n-1...."
                    },
                    {
                        "username": "Kiricon",
                        "content": "You HAVE to start from node 0. [2,7] doesn\\'t work because 2 is not a valid starting point. "
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Definitely should be an easy question"
                    },
                    {
                        "username": "aezyy",
                        "content": "Should be marked easy"
                    },
                    {
                        "username": "adeshsengar156",
                        "content": "Actually my recursive code works but its creates tle  (time limit exceeded) for large number of inputs. I am so much glad if somebody help me out that how to apply the dp solution in this code.\\n"
                    },
                    {
                        "username": "OkoksNeDam",
                        "content": "Try to convert restricted to set, because the operation of finding x in list is slow"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "\\n    void dfs(int u , int p , vector<int> adj[] , vector<bool> &isRes , int &cnt) {\\n        ans = max(ans , cnt);\\n        for(int v : adj[u]) {\\n            if(v != p && !isRes[v]) {\\n                cnt++;\\n                dfs(v , u , adj , isRes , cnt);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<bool> isRes(n , false);\\n        for(int i=0 ; i<res.size() ; i++) {\\n            isRes[res[i]] = true;\\n        }\\n        ans = 0;\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt = 1;\\n        dfs(0 , -1 , adj , isRes , cnt);\\n        return ans;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1842795,
                "content": [
                    {
                        "username": "XOFJO",
                        "content": "this is supposed to be a easy quesiton"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "If your DFS gets TLE in Python 3, make sure to turn \\'restriced\\' into a SET or add it to a SET to check the visited nodes.\\nThe operation \"For xxxx in LIST\" is super slow."
                    },
                    {
                        "username": "kishor045",
                        "content": "n =\\n10\\nedges =\\n[[8,2],[2,5],[5,0],[2,7],[1,7],[3,8],[0,4],[3,9],[1,6]]\\nrestricted =\\n[9,8,4,5,3,1]\\n\\nFor the above input it is clear that the answer should be 2 as we can reach 7 from 2 and vice versa but the output is 1 could somebody explain me this?"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "as I understand now the only maximum you need to find is for starting node 0 (?!) initially I thought for 0 to n-1...."
                    },
                    {
                        "username": "Kiricon",
                        "content": "You HAVE to start from node 0. [2,7] doesn\\'t work because 2 is not a valid starting point. "
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Definitely should be an easy question"
                    },
                    {
                        "username": "aezyy",
                        "content": "Should be marked easy"
                    },
                    {
                        "username": "adeshsengar156",
                        "content": "Actually my recursive code works but its creates tle  (time limit exceeded) for large number of inputs. I am so much glad if somebody help me out that how to apply the dp solution in this code.\\n"
                    },
                    {
                        "username": "OkoksNeDam",
                        "content": "Try to convert restricted to set, because the operation of finding x in list is slow"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "\\n    void dfs(int u , int p , vector<int> adj[] , vector<bool> &isRes , int &cnt) {\\n        ans = max(ans , cnt);\\n        for(int v : adj[u]) {\\n            if(v != p && !isRes[v]) {\\n                cnt++;\\n                dfs(v , u , adj , isRes , cnt);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<bool> isRes(n , false);\\n        for(int i=0 ; i<res.size() ; i++) {\\n            isRes[res[i]] = true;\\n        }\\n        ans = 0;\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt = 1;\\n        dfs(0 , -1 , adj , isRes , cnt);\\n        return ans;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1803154,
                "content": [
                    {
                        "username": "XOFJO",
                        "content": "this is supposed to be a easy quesiton"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "If your DFS gets TLE in Python 3, make sure to turn \\'restriced\\' into a SET or add it to a SET to check the visited nodes.\\nThe operation \"For xxxx in LIST\" is super slow."
                    },
                    {
                        "username": "kishor045",
                        "content": "n =\\n10\\nedges =\\n[[8,2],[2,5],[5,0],[2,7],[1,7],[3,8],[0,4],[3,9],[1,6]]\\nrestricted =\\n[9,8,4,5,3,1]\\n\\nFor the above input it is clear that the answer should be 2 as we can reach 7 from 2 and vice versa but the output is 1 could somebody explain me this?"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "as I understand now the only maximum you need to find is for starting node 0 (?!) initially I thought for 0 to n-1...."
                    },
                    {
                        "username": "Kiricon",
                        "content": "You HAVE to start from node 0. [2,7] doesn\\'t work because 2 is not a valid starting point. "
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Definitely should be an easy question"
                    },
                    {
                        "username": "aezyy",
                        "content": "Should be marked easy"
                    },
                    {
                        "username": "adeshsengar156",
                        "content": "Actually my recursive code works but its creates tle  (time limit exceeded) for large number of inputs. I am so much glad if somebody help me out that how to apply the dp solution in this code.\\n"
                    },
                    {
                        "username": "OkoksNeDam",
                        "content": "Try to convert restricted to set, because the operation of finding x in list is slow"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "\\n    void dfs(int u , int p , vector<int> adj[] , vector<bool> &isRes , int &cnt) {\\n        ans = max(ans , cnt);\\n        for(int v : adj[u]) {\\n            if(v != p && !isRes[v]) {\\n                cnt++;\\n                dfs(v , u , adj , isRes , cnt);\\n            }\\n        }\\n    }\\n\\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& res) {\\n        vector<bool> isRes(n , false);\\n        for(int i=0 ; i<res.size() ; i++) {\\n            isRes[res[i]] = true;\\n        }\\n        ans = 0;\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt = 1;\\n        dfs(0 , -1 , adj , isRes , cnt);\\n        return ans;\\n    }\\n"
                    }
                ]
            }
        ]
    }
]