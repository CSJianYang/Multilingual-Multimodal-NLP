[
    {
        "title": "Shortest Distance to Target String in a Circular Array",
        "question_content": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\n\tFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.\n&nbsp;\nExample 1:\n\nInput: words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\nOutput: 1\nExplanation: We start from index 1 and can reach \"hello\" by\n- moving 3 units to the right to reach index 4.\n- moving 2 units to the left to reach index 4.\n- moving 4 units to the right to reach index 0.\n- moving 1 unit to the left to reach index 0.\nThe shortest distance to reach \"hello\" is 1.\n\nExample 2:\n\nInput: words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\nOutput: 1\nExplanation: We start from index 0 and can reach \"leetcode\" by\n- moving 2 units to the right to reach index 3.\n- moving 1 unit to the left to reach index 3.\nThe shortest distance to reach \"leetcode\" is 1.\nExample 3:\n\nInput: words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\nOutput: -1\nExplanation: Since \"ate\" does not exist in words, we return -1.\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 100\n\t1 <= words[i].length <= 100\n\twords[i] and target consist of only lowercase English letters.\n\t0 <= startIndex < words.length",
        "solutions": [
            {
                "id": 2948194,
                "title": "java-one-pass",
                "content": "```\\n    //1.one pass\\n    //Runtime: 1ms 100%; Memory: 43.1MB 100%\\n    //Time: O(N); Space: O(1)\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int res = Integer.MAX_VALUE;\\n        int n = words.length;\\n        for (int i = 0; i < words.length; i++) {\\n            if (target.equals(words[i])) {\\n                int d = Math.abs(i - startIndex);\\n                res = Math.min(res, d);\\n                res = Math.min(res, n - d);\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //1.one pass\\n    //Runtime: 1ms 100%; Memory: 43.1MB 100%\\n    //Time: O(N); Space: O(1)\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int res = Integer.MAX_VALUE;\\n        int n = words.length;\\n        for (int i = 0; i < words.length; i++) {\\n            if (target.equals(words[i])) {\\n                int d = Math.abs(i - startIndex);\\n                res = Math.min(res, d);\\n                res = Math.min(res, n - d);\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947991,
                "title": "c-explanation-4-line-of-code",
                "content": "**If you liked solution please upvote!**\\n\\n * **Approach** - \\n    - Simple, calculate distance from `starting_index` to `target_index` and also `starting_index` to `target_index` but reverse direction and take min of both.\\n\\n* *Time Complexity - O(N)*\\n\\n* *Space Complexity - O(1)*\\n    \\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int s) {\\n        int n = words.size(), ans = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++) \\n            if(words[i] == target) \\n                ans = min(ans, min(abs(s - i), abs(n - abs(s - i)))); \\n                // abs(s - i) => distance from starting index to target index, \\n                // abs(n - abs(s - i)) => distance from starting index to target index but reverse direction\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n\\n**Thank You!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int s) {\\n        int n = words.size(), ans = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++) \\n            if(words[i] == target) \\n                ans = min(ans, min(abs(s - i), abs(n - abs(s - i)))); \\n                // abs(s - i) => distance from starting index to target index, \\n                // abs(n - abs(s - i)) => distance from starting index to target index but reverse direction\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948046,
                "title": "java-c-python-solution-explained",
                "content": "```\\n# Intuition behind this solution:\\n```\\nThe problem asks us to find the shortest distance from the start index to the target string in a circular array. This means that we can move either to the left or right with each step, and if we reach the end of the array, we can continue from the beginning.\\n\\nTo solve this problem, we can iterate over the array and calculate the distance from each index to the target. This allows us to find the shortest distance to the target from any index in the array.\\n\\nTo calculate the distance from an index to the target, we can check if the index is before or after the start index. If it is before, we can calculate the distance to the left of the start index and also check if it is shorter to go around the array to the right and then to the target. If the index is after the start index, we can calculate the distance to the right of the start index and also check if it is shorter to go around the array to the left and then to the target.\\n\\nFinally, we can update the shortest distance if the current index is the target, and return the shortest distance at the end. This should give us the shortest distance from the start index to the target in the circular array.\\n```\\n# Approach to solve this problem:\\n```\\n\\n* First, check if the target exists in the array. If it does not, return -1.\\n* Initialize the shortest distance to be the maximum possible value.\\n* Iterate over the array and calculate the distance from each index to the target. To do this, check if the current index is before or after the start index. If it is before, calculate the distance to the left of the start index and also check if it is shorter to go around the array to the right and then to the target. If the current index is after the start index, calculate the distance to the right of the start index and also check if it is shorter to go around the array to the left and then to the target.\\n* If the current index is the target, update the shortest distance.\\n\\n\\n* Return the shortest distance.\\n\\n\\nThis approach involves iterating over the array and calculating the distance from each index to the target. It then updates the shortest distance if the current index is the target. This allows us to find the shortest distance to the target from any index in the array.\\n\\n**Java**\\n\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        // First check if the target exists in the array\\n        boolean targetExists = false;\\n        for (String word : words) {\\n            if (word.equals(target)) {\\n                targetExists = true;\\n                break;\\n            }\\n        }\\n        if (!targetExists) {\\n            return -1;\\n        }\\n\\n        // Initialize the shortest distance to be the maximum possible value\\n        int shortestDistance = Integer.MAX_VALUE;\\n\\n        // Iterate over the array and check the distance from each index to the target\\n        for (int i = 0; i < words.length; i++) {\\n            // Calculate the distance from index i to the target\\n            int distance = 0;\\n            if (i < startIndex) {\\n                // If i is before startIndex, the distance is the number of steps to the left of startIndex\\n                distance = startIndex - i;\\n                // Check if it is shorter to go around the array to the right and then to the target\\n                int distanceToRight = words.length - startIndex + i;\\n                if (distanceToRight < distance) {\\n                    distance = distanceToRight;\\n                }\\n            } else if (i > startIndex) {\\n                // If i is after startIndex, the distance is the number of steps to the right of startIndex\\n                distance = i - startIndex;\\n                // Check if it is shorter to go around the array to the left and then to the target\\n                int distanceToLeft = startIndex + words.length - i;\\n                if (distanceToLeft < distance) {\\n                    distance = distanceToLeft;\\n                }\\n            }\\n\\n            // If the current index is the target, update the shortest distance\\n            if (words[i].equals(target)) {\\n                shortestDistance = Math.min(shortestDistance, distance);\\n            }\\n        }\\n\\n        return shortestDistance;\\n    }\\n}\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        // First check if the target exists in the array\\n        bool targetExists = false;\\n        for (string word : words) {\\n            if (word == target) {\\n                targetExists = true;\\n                break;\\n            }\\n        }\\n        if (!targetExists) {\\n            return -1;\\n        }\\n\\n        // Initialize the shortest distance to be the maximum possible value\\n        int shortestDistance = INT_MAX;\\n\\n        // Iterate over the array and check the distance from each index to the target\\n        for (int i = 0; i < words.size(); i++) {\\n            // Calculate the distance from index i to the target\\n            int distance = 0;\\n            if (i < startIndex) {\\n                // If i is before startIndex, the distance is the number of steps to the left of startIndex\\n                distance = startIndex - i;\\n                // Check if it is shorter to go around the array to the right and then to the target\\n                int distanceToRight = words.size() - startIndex + i;\\n                if (distanceToRight < distance) {\\n                    distance = distanceToRight;\\n                }\\n            } else if (i > startIndex) {\\n                // If i is after startIndex, the distance is the number of steps to the right of startIndex\\n                distance = i - startIndex;\\n                // Check if it is shorter to go around the array to the left and then to the target\\n                int distanceToLeft = startIndex + words.size() - i;\\n                if (distanceToLeft < distance) {\\n                    distance = distanceToLeft;\\n                }\\n            }\\n\\n            // If the current index is the target, update the shortest distance\\n            if (words[i] == target) {\\n                shortestDistance = min(shortestDistance, distance);\\n            }\\n        }\\n\\n        return shortestDistance;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        # First check if the target exists in the array\\n        target_exists = False\\n        for word in words:\\n            if word == target:\\n                target_exists = True\\n                break\\n        if not target_exists:\\n            return -1\\n\\n        # Initialize the shortest distance to be the maximum possible value\\n        shortest_distance = float(\\'inf\\')\\n\\n        # Iterate over the array and check the distance from each index to the target\\n        for i in range(len(words)):\\n            # Calculate the distance from index i to the target\\n            distance = 0\\n            if i < startIndex:\\n                # If i is before startIndex, the distance is the number of steps to the left of startIndex\\n                distance = startIndex - i\\n                # Check if it is shorter to go around the array to the right and then to the target\\n                distance_to_right = len(words) - startIndex + i\\n                if distance_to_right < distance:\\n                    distance = distance_to_right\\n            elif i > startIndex:\\n                # If i is after startIndex, the distance is the number of steps to the right of startIndex\\n                distance = i - startIndex\\n                # Check if it is shorter to go around the array to the left and then to the target\\n                distance_to_left = startIndex + len(words) - i\\n                if distance_to_left < distance:\\n                    distance = distance_to_left\\n\\n            # If the current index is the target, update the shortest distance\\n            if words[i] == target:\\n                shortest_distance = min(shortest_distance, distance)\\n\\n        return shortest_distance\\n```\\n\\n**Analysis**\\n\\n* **The time complexity :-** of this solution is `O(n)`, where n is the length of the array words. This is because we iterate over the array once to calculate the shortest distance.\\n\\n* **The space complexity :-** of this solution is `O(1)`, as we only use a constant amount of space regardless of the size of the input.\\n\\nTherefore, this solution has an efficient time complexity and a low space complexity, making it a good solution for this problem.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n# Intuition behind this solution:\\n```\n```\\n# Approach to solve this problem:\\n```\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        // First check if the target exists in the array\\n        boolean targetExists = false;\\n        for (String word : words) {\\n            if (word.equals(target)) {\\n                targetExists = true;\\n                break;\\n            }\\n        }\\n        if (!targetExists) {\\n            return -1;\\n        }\\n\\n        // Initialize the shortest distance to be the maximum possible value\\n        int shortestDistance = Integer.MAX_VALUE;\\n\\n        // Iterate over the array and check the distance from each index to the target\\n        for (int i = 0; i < words.length; i++) {\\n            // Calculate the distance from index i to the target\\n            int distance = 0;\\n            if (i < startIndex) {\\n                // If i is before startIndex, the distance is the number of steps to the left of startIndex\\n                distance = startIndex - i;\\n                // Check if it is shorter to go around the array to the right and then to the target\\n                int distanceToRight = words.length - startIndex + i;\\n                if (distanceToRight < distance) {\\n                    distance = distanceToRight;\\n                }\\n            } else if (i > startIndex) {\\n                // If i is after startIndex, the distance is the number of steps to the right of startIndex\\n                distance = i - startIndex;\\n                // Check if it is shorter to go around the array to the left and then to the target\\n                int distanceToLeft = startIndex + words.length - i;\\n                if (distanceToLeft < distance) {\\n                    distance = distanceToLeft;\\n                }\\n            }\\n\\n            // If the current index is the target, update the shortest distance\\n            if (words[i].equals(target)) {\\n                shortestDistance = Math.min(shortestDistance, distance);\\n            }\\n        }\\n\\n        return shortestDistance;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        // First check if the target exists in the array\\n        bool targetExists = false;\\n        for (string word : words) {\\n            if (word == target) {\\n                targetExists = true;\\n                break;\\n            }\\n        }\\n        if (!targetExists) {\\n            return -1;\\n        }\\n\\n        // Initialize the shortest distance to be the maximum possible value\\n        int shortestDistance = INT_MAX;\\n\\n        // Iterate over the array and check the distance from each index to the target\\n        for (int i = 0; i < words.size(); i++) {\\n            // Calculate the distance from index i to the target\\n            int distance = 0;\\n            if (i < startIndex) {\\n                // If i is before startIndex, the distance is the number of steps to the left of startIndex\\n                distance = startIndex - i;\\n                // Check if it is shorter to go around the array to the right and then to the target\\n                int distanceToRight = words.size() - startIndex + i;\\n                if (distanceToRight < distance) {\\n                    distance = distanceToRight;\\n                }\\n            } else if (i > startIndex) {\\n                // If i is after startIndex, the distance is the number of steps to the right of startIndex\\n                distance = i - startIndex;\\n                // Check if it is shorter to go around the array to the left and then to the target\\n                int distanceToLeft = startIndex + words.size() - i;\\n                if (distanceToLeft < distance) {\\n                    distance = distanceToLeft;\\n                }\\n            }\\n\\n            // If the current index is the target, update the shortest distance\\n            if (words[i] == target) {\\n                shortestDistance = min(shortestDistance, distance);\\n            }\\n        }\\n\\n        return shortestDistance;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        # First check if the target exists in the array\\n        target_exists = False\\n        for word in words:\\n            if word == target:\\n                target_exists = True\\n                break\\n        if not target_exists:\\n            return -1\\n\\n        # Initialize the shortest distance to be the maximum possible value\\n        shortest_distance = float(\\'inf\\')\\n\\n        # Iterate over the array and check the distance from each index to the target\\n        for i in range(len(words)):\\n            # Calculate the distance from index i to the target\\n            distance = 0\\n            if i < startIndex:\\n                # If i is before startIndex, the distance is the number of steps to the left of startIndex\\n                distance = startIndex - i\\n                # Check if it is shorter to go around the array to the right and then to the target\\n                distance_to_right = len(words) - startIndex + i\\n                if distance_to_right < distance:\\n                    distance = distance_to_right\\n            elif i > startIndex:\\n                # If i is after startIndex, the distance is the number of steps to the right of startIndex\\n                distance = i - startIndex\\n                # Check if it is shorter to go around the array to the left and then to the target\\n                distance_to_left = startIndex + len(words) - i\\n                if distance_to_left < distance:\\n                    distance = distance_to_left\\n\\n            # If the current index is the target, update the shortest distance\\n            if words[i] == target:\\n                shortest_distance = min(shortest_distance, distance)\\n\\n        return shortest_distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950712,
                "title": "python-3-7-lines-two-loops-one-pass-t-m-42-ms-13-9-mb",
                "content": "```class Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        n = len(words)\\n\\n        for left in range(n):\\n            if words[(startIndex+left)%n ] == target: break\\n        else: return -1    \\n\\n        for right in range(n):\\n            if words[(startIndex-right)%n] == target: break\\n  \\n        return  min(left, right)\\n```\\n[https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/submissions/865367549/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        n = len(words)\\n\\n        for left in range(n):\\n            if words[(startIndex+left)%n ] == target: break\\n        else: return -1    \\n\\n        for right in range(n):\\n            if words[(startIndex-right)%n] == target: break\\n  \\n        return  min(left, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948216,
                "title": "c-two-pointer-approach-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake use of a visited array to track visited indices, and you can move the left and right pointers outwards to search for the target\\n# Complexity\\n- Time complexity: \\n**O(n*s)** where s is the max length of a string in words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n**O(n)**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size();\\n        bool visited[n];\\n        for (int i = 0; i < n; i++) {\\n            visited[i] = false;\\n        }\\n        int l = startIndex;\\n        int r = startIndex;\\n        int dist = 0;\\n        while (!visited[l] && !visited[r]) {\\n            if (words[l] == target || words[r] == target) {\\n                return dist;\\n            }\\n            visited[l] = true;\\n            visited[r] = true;\\n            dist++;\\n            l--;\\n            r++;\\n            if (l == -1) {\\n                l = n - 1;\\n            }\\n            if (r == n) {\\n                r = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size();\\n        bool visited[n];\\n        for (int i = 0; i < n; i++) {\\n            visited[i] = false;\\n        }\\n        int l = startIndex;\\n        int r = startIndex;\\n        int dist = 0;\\n        while (!visited[l] && !visited[r]) {\\n            if (words[l] == target || words[r] == target) {\\n                return dist;\\n            }\\n            visited[l] = true;\\n            visited[r] = true;\\n            dist++;\\n            l--;\\n            r++;\\n            if (l == -1) {\\n                l = n - 1;\\n            }\\n            if (r == n) {\\n                r = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951631,
                "title": "one-pass",
                "content": "The description does not specify it but beware that there could be more than one target.\\n\\n**C++**\\n```cpp\\nint closetTarget(vector<string>& words, string target, int si) {\\n    int res = INT_MAX, sz = words.size();\\n    for (int i = 0; i < sz; ++i)\\n        if (words[i] == target)\\n            res = min({res, abs(i - si), sz - abs(i - si)});\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint closetTarget(vector<string>& words, string target, int si) {\\n    int res = INT_MAX, sz = words.size();\\n    for (int i = 0; i < sz; ++i)\\n        if (words[i] == target)\\n            res = min({res, abs(i - si), sz - abs(i - si)});\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2948051,
                "title": "javascript-easy-understanding-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    let left = startIndex\\n    let right = startIndex\\n    let step = 0\\n    let n = words.length\\n    \\n    while(step <= n){\\n        if(words[left]===target||words[right]===target){\\n            return step\\n        } else {\\n            right = (right + 1) % n\\n            left = (left - 1 + n) % n\\n        }\\n        step ++\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    let left = startIndex\\n    let right = startIndex\\n    let step = 0\\n    let n = words.length\\n    \\n    while(step <= n){\\n        if(words[left]===target||words[right]===target){\\n            return step\\n        } else {\\n            right = (right + 1) % n\\n            left = (left - 1 + n) % n\\n        }\\n        step ++\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129646,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if words[startIndex] == target:\\n            return 0\\n\\n        for index in range(len(words)):\\n            if  words[(startIndex+index) % len(words)] == target or words[(startIndex-index) % len(words)] == target:\\n                return index\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if words[startIndex] == target:\\n            return 0\\n\\n        for index in range(len(words)):\\n            if  words[(startIndex+index) % len(words)] == target or words[(startIndex-index) % len(words)] == target:\\n                return index\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948166,
                "title": "c-simple-iteration-easy-for-all",
                "content": "**Just take care of 4 conditions and u will abe to solve**\\n1.  if startindex elemnt is equal to target than return 0.\\n2.  if target is not present return -1.\\n3.  from startIndex iterate circularly from left until target is found and store the distance\\n4.  from startIndex iterate circularly  from right until target is found and store it and return the minimum of distance i.e either left or right\\n**SIMPLE!**\\nUPVOTE if it was helpful !\\n```\\nclass Solution\\n{\\npublic:\\n  int closetTarget(vector<string> &words, string target, int startIndex)\\n  {\\n    if (words[startIndex] == target)\\n    return 0;\\n    long long right = 0, left = 0;\\n    int n = words.size();\\n    bool check = false;\\n    for (auto &it : words)\\n    {\\n      if (it == target)\\n        check = true;\\n    }\\n    if (!check)\\n      return -1;\\n\\n    for (int i = startIndex; i < 2 * n; i++)\\n    {\\n      right++;\\n      if (words[(i + 1) % n] == target)\\n      {\\n        break;\\n      }\\n    }\\n      \\n    for (int i = startIndex; i > -n; i--)\\n    {\\n      left++;\\n      if (words[(i - 1 + n) % n] == target)\\n      {\\n        break;\\n      }\\n    }\\n\\n    return min(right,left);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int closetTarget(vector<string> &words, string target, int startIndex)\\n  {\\n    if (words[startIndex] == target)\\n    return 0;\\n    long long right = 0, left = 0;\\n    int n = words.size();\\n    bool check = false;\\n    for (auto &it : words)\\n    {\\n      if (it == target)\\n        check = true;\\n    }\\n    if (!check)\\n      return -1;\\n\\n    for (int i = startIndex; i < 2 * n; i++)\\n    {\\n      right++;\\n      if (words[(i + 1) % n] == target)\\n      {\\n        break;\\n      }\\n    }\\n      \\n    for (int i = startIndex; i > -n; i--)\\n    {\\n      left++;\\n      if (words[(i - 1 + n) % n] == target)\\n      {\\n        break;\\n      }\\n    }\\n\\n    return min(right,left);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949415,
                "title": "java-one-pass-easy",
                "content": "# Please Upvote :D\\nCalculate the distance from both directions. The minimum is the answer.\\n``` java []\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].equals(target)) {\\n                int dist = Math.abs(i - startIndex);\\n                int oppDist = words.length - dist;\\n                ans = Math.min(ans, Math.min(dist, oppDist));\\n            }\\n        }\\n\\n        return ans == Integer.MAX_VALUE? -1: ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].equals(target)) {\\n                int dist = Math.abs(i - startIndex);\\n                int oppDist = words.length - dist;\\n                ans = Math.min(ans, Math.min(dist, oppDist));\\n            }\\n        }\\n\\n        return ans == Integer.MAX_VALUE? -1: ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948819,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int f=-1;\\n        vector<int> v;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i]==target)\\n            {\\n                f=1;\\n                v.push_back(i);\\n            }\\n        }\\n        if(f==-1)\\n            return -1;\\n        int ans=INT_MAX;\\n        int n=words.size();\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int k=abs(v[i]-startIndex);\\n            ans=min({ans, k, n-k});\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int f=-1;\\n        vector<int> v;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i]==target)\\n            {\\n                f=1;\\n                v.push_back(i);\\n            }\\n        }\\n        if(f==-1)\\n            return -1;\\n        int ans=INT_MAX;\\n        int n=words.size();\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int k=abs(v[i]-startIndex);\\n            ans=min({ans, k, n-k});\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947987,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) \\n    {\\n        if (words[startIndex] == target) return 0;\\n        \\n        int n = words.size();\\n        int ans = INT_MAX;\\n        //===============================================================================================================\\n        //GO FROM [start-> (n - 1)-> (0) -> (start - 1)]\\n        //MAKING CYLCE FROM RIGHT\\n        int currIdx = (startIndex + 1 == n)? 0 : startIndex + 1;\\n        int steps = 1;\\n        bool found = false;\\n        while(currIdx != startIndex)\\n        {\\n            if (words[currIdx] == target) { found = true; break; }\\n            currIdx = (currIdx + 1) % n;\\n            steps++;\\n        }\\n        if (found) ans = min(ans, steps);\\n        //===============================================================================================================\\n        //GO FROM [start -> (0) -> (n - 1) -> (start + 1)]\\n        //MAKING CYCLE FROM LEFT\\n        steps = 1;\\n        found = false;\\n        currIdx = (startIndex - 1 < 0)? n - 1 : startIndex - 1;\\n        while(currIdx != startIndex)\\n        {\\n            if (words[currIdx] == target) { found = true; break; }\\n            currIdx = (currIdx - 1 + n) % n;\\n            steps++;\\n        }\\n        if (found) ans = min(ans, steps);\\n        //===============================================================================================================\\n        return (ans == INT_MAX? -1 : ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) \\n    {\\n        if (words[startIndex] == target) return 0;\\n        \\n        int n = words.size();\\n        int ans = INT_MAX;\\n        //===============================================================================================================\\n        //GO FROM [start-> (n - 1)-> (0) -> (start - 1)]\\n        //MAKING CYLCE FROM RIGHT\\n        int currIdx = (startIndex + 1 == n)? 0 : startIndex + 1;\\n        int steps = 1;\\n        bool found = false;\\n        while(currIdx != startIndex)\\n        {\\n            if (words[currIdx] == target) { found = true; break; }\\n            currIdx = (currIdx + 1) % n;\\n            steps++;\\n        }\\n        if (found) ans = min(ans, steps);\\n        //===============================================================================================================\\n        //GO FROM [start -> (0) -> (n - 1) -> (start + 1)]\\n        //MAKING CYCLE FROM LEFT\\n        steps = 1;\\n        found = false;\\n        currIdx = (startIndex - 1 < 0)? n - 1 : startIndex - 1;\\n        while(currIdx != startIndex)\\n        {\\n            if (words[currIdx] == target) { found = true; break; }\\n            currIdx = (currIdx - 1 + n) % n;\\n            steps++;\\n        }\\n        if (found) ans = min(ans, steps);\\n        //===============================================================================================================\\n        return (ans == INT_MAX? -1 : ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948015,
                "title": "8-line-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        n = len(words)\\n        final_posn = float(\"inf\")\\n        for i in range(n):\\n            if words[i] == target:\\n                final_posn = min(final_posn, abs(i-startIndex), n-abs(i-startIndex))\\n        return final_posn\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        n = len(words)\\n        final_posn = float(\"inf\")\\n        for i in range(n):\\n            if words[i] == target:\\n                final_posn = min(final_posn, abs(i-startIndex), n-abs(i-startIndex))\\n        return final_posn\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585223,
                "title": "c-4-line-solution-easy-to-understand",
                "content": "**Approach** - As we are told to find the shortest distance from **startIndex**, we can take a variable **dist** representing the distance from the startIndex. We can check if at any distance                  either to **left** or **right** from *startIndex* there exists **target** string.  To check left we can use **words[(dist + 1) % n]** and for right we can use **words[(dist - 1 + n) % n]**              (n is the size of the array). If neither at left or right the *target* exists increment *dist*. If exists return the *dist*. If *dist* becomes greater than or equal to *n* that means no target strings                exist in the array. \\n\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex){\\n        int n=words.size();\\n        int dist=0;\\n        while(dist<n && words[(startIndex+dist)%n]!=target && words[(startIndex-dist+n)%n]!=target){dist++;}\\n        return (dist<n)?dist:-1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex){\\n        int n=words.size();\\n        int dist=0;\\n        while(dist<n && words[(startIndex+dist)%n]!=target && words[(startIndex-dist+n)%n]!=target){dist++;}\\n        return (dist<n)?dist:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962298,
                "title": "c-5-lines-two-pointer-approach-easy-to-understand-t-m-35-ms-14-7-mb",
                "content": "**If you found this solution helpful, please consider upvoting.**\\n* **Approach:** starting from two pointers at start Index check for target on both directions.\\n* Time Complexity - O(N)\\n* Space Complexity - O(1)\\n\\n``` \\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        \\n        for(int i=0;i<=n/2;i++){\\n            if(words[(i + startIndex) % n]==target || words[(startIndex - i + n) % n]==target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        \\n        for(int i=0;i<=n/2;i++){\\n            if(words[(i + startIndex) % n]==target || words[(startIndex - i + n) % n]==target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960897,
                "title": "using-mod-formulas-from-description-simple-pythonic",
                "content": "This solution uses some information given in the problem description: \\n\\n> * *Formally, the next element of `words[i]` is `words[(i + 1) % n]` and the previous element of `words[i]` is `words[(i - 1 + n) % n]`, where `n` is the length of `words`.*\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n = len(words)\\n        # The provided formula gives the next and previous \\n        # index \"1\" step away from a starting position \"i\". \\n        # Our start position for this problem is startIndex.\\n        # If we applied words[(startIndex + 1) % n], we would \\n        # only be able to move 1 letter away from the start position.\\n        # Since we want to know the index for any number of steps,\\n        # we also replace 1 in the formula with a variable j.\\n\\n        next_index = lambda j : (startIndex + j) % n\\n        prev_index = lambda j : (startIndex - j + n) % n\\n   \\n        # steps is our \"j\" and counts the steps from startIndex\\n        steps = 0\\n        \\n        while steps < n:\\n            if words[next_index(steps)] == target or words[prev_index(steps)] == target:\\n                return steps\\n            steps += 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n = len(words)\\n        # The provided formula gives the next and previous \\n        # index \"1\" step away from a starting position \"i\". \\n        # Our start position for this problem is startIndex.\\n        # If we applied words[(startIndex + 1) % n], we would \\n        # only be able to move 1 letter away from the start position.\\n        # Since we want to know the index for any number of steps,\\n        # we also replace 1 in the formula with a variable j.\\n\\n        next_index = lambda j : (startIndex + j) % n\\n        prev_index = lambda j : (startIndex - j + n) % n\\n   \\n        # steps is our \"j\" and counts the steps from startIndex\\n        steps = 0\\n        \\n        while steps < n:\\n            if words[next_index(steps)] == target or words[prev_index(steps)] == target:\\n                return steps\\n            steps += 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948031,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Traverse word array : \\n   if any word matches with target : \\n    then check clockwise and anticlockwise distance required \\n    take minimum \\nreturn minimum among all path\\n- distance : \\n   word array =  w1  t  w2  w3 w4 \\n- if w3 is start then  : distnace abs(w3 index -t index )\\nto complete cirecle other path : size of array - abs(w3index-tindex) \\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n        int ans = INT_MAX , n = words.size();\\n        for( int i = 0 ; i < words.size() ; ++i )\\n        {\\n            if(words[i]==target)\\n            {\\n                 int t  = min( abs(startIndex-i),n-abs(startIndex-i));\\n                 ans = min(ans,t);\\n            }\\n        }\\n        if( ans==INT_MAX) return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n        int ans = INT_MAX , n = words.size();\\n        for( int i = 0 ; i < words.size() ; ++i )\\n        {\\n            if(words[i]==target)\\n            {\\n                 int t  = min( abs(startIndex-i),n-abs(startIndex-i));\\n                 ans = min(ans,t);\\n            }\\n        }\\n        if( ans==INT_MAX) return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947984,
                "title": "c-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int> a;int mn=INT_MAX;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i]==target)\\n                a.push_back(i);\\n        }\\n        if(a.size()==0)\\n            return -1;\\n        int n=words.size();\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int temp=abs(a[i]-startIndex);\\n            int t=n-temp;\\n            int x=min(t,temp);\\n            mn=min(mn,x);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int> a;int mn=INT_MAX;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i]==target)\\n                a.push_back(i);\\n        }\\n        if(a.size()==0)\\n            return -1;\\n        int n=words.size();\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int temp=abs(a[i]-startIndex);\\n            int t=n-temp;\\n            int x=min(t,temp);\\n            mn=min(mn,x);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808569,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size(), ans = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            if(words[i] == target) {\\n                ans = min({ans, abs(i - startIndex), n - abs(i - startIndex)});\\n            }\\n        }\\n        if (ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size(), ans = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            if(words[i] == target) {\\n                ans = min({ans, abs(i - startIndex), n - abs(i - startIndex)});\\n            }\\n        }\\n        if (ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100571,
                "title": "easy-java-solution",
                "content": "*****Italic*****\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n     int m=startIndex;\\n     int n=startIndex;\\n     int len=words.length;\\n     int count=0;\\n\\n     while(count<len)\\n     {\\n         if((words[m].equals(target)) || (words[n]).equals(target))\\n         {\\n             return count;\\n         }\\n         \\n             if(m==len-1)\\n             {\\n                 m=0;\\n             }\\n             else\\n             {\\n                 m+=1;\\n             }\\n             if(n==0)\\n             {\\n                 n=len-1;\\n             }\\n             else\\n             {\\n                 n-=1;\\n             }\\n             count++;\\n        }\\n        return -1;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n     int m=startIndex;\\n     int n=startIndex;\\n     int len=words.length;\\n     int count=0;\\n\\n     while(count<len)\\n     {\\n         if((words[m].equals(target)) || (words[n]).equals(target))\\n         {\\n             return count;\\n         }\\n         \\n             if(m==len-1)\\n             {\\n                 m=0;\\n             }\\n             else\\n             {\\n                 m+=1;\\n             }\\n             if(n==0)\\n             {\\n                 n=len-1;\\n             }\\n             else\\n             {\\n                 n-=1;\\n             }\\n             count++;\\n        }\\n        return -1;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971597,
                "title": "simple-python-solution-o-n-3-lines-of-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if words[startIndex] == target:\\n            return 0\\n        \\n        for i in range(1, len(words)):\\n            if words[(startIndex-i) % len(words)] == target or words[(startIndex+i) % len(words)] == target:\\n                return i\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if words[startIndex] == target:\\n            return 0\\n        \\n        for i in range(1, len(words)):\\n            if words[(startIndex-i) % len(words)] == target or words[(startIndex+i) % len(words)] == target:\\n                return i\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964534,
                "title": "python-easy-fast-solution-with-explanation",
                "content": "# Intuition\\n\\n$\\\\cdot$ Target can appear more than once\\n$\\\\cdot$ Each target has two possible shortest distance i.e. left or right\\n$\\\\cdot$ Instead of infinite circle loop think of finite segment of concatenated arrays\\n\\n# Approach\\nLoop through array to find each target. Then determine if target index is above or below starting index. This will determine where are the two shortest distances and which segment to consider.\\n\\nIf target below start:\\nwords $words+1$\\n[target, start, start+1] $[target, start, start+1]$\\n\\nIf target above start:\\n$words-1$ words\\n$[start, start+1, target]$ [start, start+1, target] \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        min_distance = len(words) - 1\\n        for index, word in enumerate(words):\\n            if word == target:\\n                if index < startIndex:\\n                    distance = min(startIndex - index, index + len(words) - startIndex)\\n                else:\\n                    distance = min(index - startIndex, startIndex + len(words) - index)\\n                min_distance = min(distance, min_distance)\\n        return min_distance\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        min_distance = len(words) - 1\\n        for index, word in enumerate(words):\\n            if word == target:\\n                if index < startIndex:\\n                    distance = min(startIndex - index, index + len(words) - startIndex)\\n                else:\\n                    distance = min(index - startIndex, startIndex + len(words) - index)\\n                min_distance = min(distance, min_distance)\\n        return min_distance\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964049,
                "title": "100-0ms-easy-one-pass-proof",
                "content": "# UPVOTE PLS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/41cf0286-f1b3-46a7-8518-b05043319b03_1672248041.0209374.png)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] W, String T, int s) {\\n        int a=Integer.MAX_VALUE,n=W.length;\\n       for(int i=0;i<n;i++){\\n            if(W[i].equals(T)) {\\n                int d=Math.abs(i-s);\\n                a=Math.min(a,d);\\n                a=Math.min(a,n-d);\\n            }\\n        }\\n        return a==Integer.MAX_VALUE?-1:a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] W, String T, int s) {\\n        int a=Integer.MAX_VALUE,n=W.length;\\n       for(int i=0;i<n;i++){\\n            if(W[i].equals(T)) {\\n                int d=Math.abs(i-s);\\n                a=Math.min(a,d);\\n                a=Math.min(a,n-d);\\n            }\\n        }\\n        return a==Integer.MAX_VALUE?-1:a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962696,
                "title": "java-two-pointers",
                "content": "# Approach\\nUse two pointers which will move in oposite directions starting from `startIndex`.\\n\\n# Complexity\\n- Time complexity - O(n):\\nIn the worst case we will make `n/2` steps when `target` is not present in `words`, otherwise we\\'ll return the answer as soon as meet the `target`.\\n\\n- Space complexity O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if (target.equals(words[startIndex])) {\\n            return 0;\\n        }\\n        int n = words.length, l = (startIndex - 1 + n) % n, r = (startIndex + 1) % n, steps = 1;\\n        while (l != r) {\\n            if (target.equals(words[l]) || target.equals(words[r])) {\\n                return steps;\\n            } else {\\n                l = (l - 1 + n) % n;\\n                r = (r + 1) % n;\\n                steps++;\\n            }\\n        }\\n        return target.equals(words[l]) ? steps : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if (target.equals(words[startIndex])) {\\n            return 0;\\n        }\\n        int n = words.length, l = (startIndex - 1 + n) % n, r = (startIndex + 1) % n, steps = 1;\\n        while (l != r) {\\n            if (target.equals(words[l]) || target.equals(words[r])) {\\n                return steps;\\n            } else {\\n                l = (l - 1 + n) % n;\\n                r = (r + 1) % n;\\n                steps++;\\n            }\\n        }\\n        return target.equals(words[l]) ? steps : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950178,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i<n; i++){\\n            if(words[i].equals(target)){\\n                int dist = Math.abs(startIndex - i);\\n               ans = Math.min(ans ,Math.min(dist,n-dist));\\n            }\\n        } \\n        return ans == Integer.MAX_VALUE? -1:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i<n; i++){\\n            if(words[i].equals(target)){\\n                int dist = Math.abs(startIndex - i);\\n               ans = Math.min(ans ,Math.min(dist,n-dist));\\n            }\\n        } \\n        return ans == Integer.MAX_VALUE? -1:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949902,
                "title": "simple-c-easy-explanation-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is circular array so if words[i] is target so we can have 4 cases:\\n\\n0......... i---<-------<-----startindex..........n-1 (startindex to i)\\n0......... startindex----->--->----i..........n-1\\n\\ndist= abs(i-startindex)\\n\\n\\nn-1----<---<---0--<----<-startindex..............i--<-<---n-1---<---0\\nn-1---->>---0--->-->---i....................startindex-->--->---n-1--->0\\ndist= abs(total-abs(i-startindex))\\n![image.png](https://assets.leetcode.com/users/images/0e273682-a726-4687-a0d6-d902d422e552_1672335760.5820668.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the target in words array using for loop\\nand take min of all 4 cases\\nIf ans=n+1 means no target word found return -1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n``O(N*S) S is the length of word``\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n``O(1)``\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int ans=n+1;\\n        for(int i=0;i<n;i++){\\n         if(words[i]==target){\\n            ans=min(ans,min(abs(startIndex-i),n-abs(startIndex-i)));\\n         }\\n        }\\n        if(ans==n+1) ans=-1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int ans=n+1;\\n        for(int i=0;i<n;i++){\\n         if(words[i]==target){\\n            ans=min(ans,min(abs(startIndex-i),n-abs(startIndex-i)));\\n         }\\n        }\\n        if(ans==n+1) ans=-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949141,
                "title": "c-easy-to-understand-code",
                "content": "# Intuition\\n We just have to use two for loops for the traversal. \\n\\n# Approach\\nFirst traversal would be from next right element of the startIndex  and second traversal would be from the next left element. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        bool a=0;\\n        if(words[startIndex] == target){\\n            return 0;\\n        }\\n        int c1=0,c2=0;\\n        int n=words.size();\\n        for(int i = startIndex+1 ; i != startIndex  ;i=(i + 1) % n){\\n            if(words[i]!=target){\\n                c1++;\\n            }\\n            else{\\n                a=1;\\n                c1++;\\n                break;\\n            }\\n            \\n        }\\n        for(int i = (startIndex-1+n) %n ; i != startIndex  ;i=(i - 1 + n)%n){\\n            if(words[i]!=target){\\n                c2++;\\n            }\\n            else{\\n                \\n                c2++;\\n                break;\\n            }\\n            \\n            \\n        }\\n            if(c1<c2){\\n                return c1;\\n            }\\n            else if(c1>c2){\\n                return c2;\\n            }\\n            else if((c1==c2) && (a==1) ){\\n                return c1;\\n            }\\n            else {\\n                return -1;\\n            }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        bool a=0;\\n        if(words[startIndex] == target){\\n            return 0;\\n        }\\n        int c1=0,c2=0;\\n        int n=words.size();\\n        for(int i = startIndex+1 ; i != startIndex  ;i=(i + 1) % n){\\n            if(words[i]!=target){\\n                c1++;\\n            }\\n            else{\\n                a=1;\\n                c1++;\\n                break;\\n            }\\n            \\n        }\\n        for(int i = (startIndex-1+n) %n ; i != startIndex  ;i=(i - 1 + n)%n){\\n            if(words[i]!=target){\\n                c2++;\\n            }\\n            else{\\n                \\n                c2++;\\n                break;\\n            }\\n            \\n            \\n        }\\n            if(c1<c2){\\n                return c1;\\n            }\\n            else if(c1>c2){\\n                return c2;\\n            }\\n            else if((c1==c2) && (a==1) ){\\n                return c1;\\n            }\\n            else {\\n                return -1;\\n            }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949113,
                "title": "my-solution-easy-logic-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n                \\n                min=Math.min(min,Math.abs(startIndex-i));\\n                min=Math.min(min, Math.abs(words.length-startIndex+i));\\n                min=Math.min(min, Math.abs(words.length+startIndex-i));\\n\\n                    \\n            }\\n           \\n            \\n        }return min==Integer.MAX_VALUE?-1:min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n                \\n                min=Math.min(min,Math.abs(startIndex-i));\\n                min=Math.min(min, Math.abs(words.length-startIndex+i));\\n                min=Math.min(min, Math.abs(words.length+startIndex-i));\\n\\n                    \\n            }\\n           \\n            \\n        }return min==Integer.MAX_VALUE?-1:min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948228,
                "title": "most-easiest-beginner-friendly-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n      int ans = INT_MAX;\\n        for( int i = 0 ; i < words.size() ; ++i )\\n        {\\n            if(words[i] == target)\\n            {\\n                int forward = abs(startIndex-i);\\n                int backward = words.size()-forward;\\n                ans = min(ans, min(forward, backward));\\n            }\\n        }\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n      int ans = INT_MAX;\\n        for( int i = 0 ; i < words.size() ; ++i )\\n        {\\n            if(words[i] == target)\\n            {\\n                int forward = abs(startIndex-i);\\n                int backward = words.size()-forward;\\n                ans = min(ans, min(forward, backward));\\n            }\\n        }\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948141,
                "title": "c-easy-array-circular-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        if(words[startIndex] == target) return 0;\\n        \\n        int n = words.size(), cnt = 1;\\n        int l = (startIndex - 1 + n) % n, r = (startIndex + 1) % n;\\n        \\n        while(l != startIndex and r != startIndex) {\\n            if(words[l] == target or words[r] == target) return cnt;\\n            l = (l - 1 + n) % n;\\n            r = (r + 1) % n;\\n            cnt++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        if(words[startIndex] == target) return 0;\\n        \\n        int n = words.size(), cnt = 1;\\n        int l = (startIndex - 1 + n) % n, r = (startIndex + 1) % n;\\n        \\n        while(l != startIndex and r != startIndex) {\\n            if(words[l] == target or words[r] == target) return cnt;\\n            l = (l - 1 + n) % n;\\n            r = (r + 1) % n;\\n            cnt++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948111,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans=INT_MAX, cnt=0, chk=1, n=words.size();\\n        int i=startIndex;\\n        while(true){\\n            if(i%n==startIndex && chk==-1){break;}\\n            if(words[i%n]==target){\\n                // if(startIndex==n-1 && words[i%n]==target && i==0){\\n                //     ans=min(ans, 1);\\n                // }\\n                ans=min(ans, cnt);\\n            }\\n            i++; chk=-1; cnt++;\\n        }\\n        chk=1; i=startIndex; cnt=0;\\n        while(true){\\n            if(i%n==startIndex && chk==-1){break;}\\n            //cout<<words[i]<<endl;\\n            if(words[i%n]==target){\\n                // if(startIndex==0 && words[i]==target && i==n-1){\\n                //     ans=min(ans, 1);\\n                // }\\n                ans=min(ans, cnt);\\n            }\\n            i--; chk=-1;\\n            cnt++;\\n            i=(i+n)%n;\\n        }\\n        if(ans==INT_MAX){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans=INT_MAX, cnt=0, chk=1, n=words.size();\\n        int i=startIndex;\\n        while(true){\\n            if(i%n==startIndex && chk==-1){break;}\\n            if(words[i%n]==target){\\n                // if(startIndex==n-1 && words[i%n]==target && i==0){\\n                //     ans=min(ans, 1);\\n                // }\\n                ans=min(ans, cnt);\\n            }\\n            i++; chk=-1; cnt++;\\n        }\\n        chk=1; i=startIndex; cnt=0;\\n        while(true){\\n            if(i%n==startIndex && chk==-1){break;}\\n            //cout<<words[i]<<endl;\\n            if(words[i%n]==target){\\n                // if(startIndex==0 && words[i]==target && i==n-1){\\n                //     ans=min(ans, 1);\\n                // }\\n                ans=min(ans, cnt);\\n            }\\n            i--; chk=-1;\\n            cnt++;\\n            i=(i+n)%n;\\n        }\\n        if(ans==INT_MAX){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2948055,
                "title": "easy-java-hashmap",
                "content": "# Intuition\\n1. Store target word and list of its index in a HashMap. HashMap<String, List<Integer>> Stores targetWord -> [indices].\\n2. Now traverse over index list of the target word and find shortest distance in left and right direction both.\\n3. Choose whichever is minimum.\\n4. Now update the ans.\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        for (int i=0; i<words.length; i++) {\\n            if (map.containsKey(words[i])) {\\n                map.get(words[i]).add(i);\\n            } else {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(i);\\n                map.put(words[i], list);\\n            }\\n        }\\n        \\n        if (!map.containsKey(target)) {\\n            return -1;\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        int len = words.length;\\n        for (int index : map.get(target)) {\\n            if (startIndex > index) {\\n                min = Math.min(min, (startIndex - index));\\n                min = Math.min(min, ((len-startIndex) + index));\\n            } else if (startIndex < index) {\\n                min = Math.min(min, (index - startIndex));\\n                min = Math.min(min, (startIndex + (len-index)));\\n            } else {\\n                min = 0;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        for (int i=0; i<words.length; i++) {\\n            if (map.containsKey(words[i])) {\\n                map.get(words[i]).add(i);\\n            } else {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(i);\\n                map.put(words[i], list);\\n            }\\n        }\\n        \\n        if (!map.containsKey(target)) {\\n            return -1;\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        int len = words.length;\\n        for (int index : map.get(target)) {\\n            if (startIndex > index) {\\n                min = Math.min(min, (startIndex - index));\\n                min = Math.min(min, ((len-startIndex) + index));\\n            } else if (startIndex < index) {\\n                min = Math.min(min, (index - startIndex));\\n                min = Math.min(min, (startIndex + (len-index)));\\n            } else {\\n                min = 0;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948004,
                "title": "python-3-check-left-and-right-brute-force",
                "content": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        \\n        words = words + words\\n        \\n        n = len(words)\\n        r = l = startIndex\\n        res = inf\\n        \\n        while words[l] != target:\\n            l = l - 1\\n        res = min(res, abs(startIndex - l))\\n        \\n        while words[r] != target:\\n            r = r + 1\\n        res = min(res, abs(startIndex - r))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        \\n        words = words + words\\n        \\n        n = len(words)\\n        r = l = startIndex\\n        res = inf\\n        \\n        while words[l] != target:\\n            l = l - 1\\n        res = min(res, abs(startIndex - l))\\n        \\n        while words[r] != target:\\n            r = r + 1\\n        res = min(res, abs(startIndex - r))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948002,
                "title": "java-one-simple-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne loop and find all indice equal target.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck distance in normal and circular way.\\n\\nThe distance of two indice is `distance`, then distance in circular way wiil be `n - distance`.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int closetTarget(String[] words, String target, int startIndex) {\\n    final int n = words.length;\\n    int result = 200;\\n    for (int i = 0; i < n; i++) {\\n      if (words[i].equals(target)) {\\n        int distance = Math.abs(startIndex - i);\\n        result = Math.min(result, Math.min(distance, n - distance));\\n      }\\n    }\\n\\n    return result == 200 ? -1 : result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int closetTarget(String[] words, String target, int startIndex) {\\n    final int n = words.length;\\n    int result = 200;\\n    for (int i = 0; i < n; i++) {\\n      if (words[i].equals(target)) {\\n        int distance = Math.abs(startIndex - i);\\n        result = Math.min(result, Math.min(distance, n - distance));\\n      }\\n    }\\n\\n    return result == 200 ? -1 : result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947982,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n = len(words)\\n        # moving right\\n        moveright = 0\\n        flag = False\\n        for i in range(startIndex,len(words)+startIndex):\\n            if words[(i+1)%n] == target:\\n                flag = True\\n                moveright += 1\\n                break\\n            else:\\n                moveright += 1\\n        # If target is not present so its no use searching to the left so we return -1\\n        if flag == False:\\n            return -1\\n        \\n        # moving left\\n        moveleft = 0\\n        pointer = startIndex\\n        while True:\\n            if words[pointer] == target:\\n                break\\n            else:\\n                pointer = (pointer - 1 + n) % n\\n                moveleft += 1\\n        return min(moveleft,moveright)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n = len(words)\\n        # moving right\\n        moveright = 0\\n        flag = False\\n        for i in range(startIndex,len(words)+startIndex):\\n            if words[(i+1)%n] == target:\\n                flag = True\\n                moveright += 1\\n                break\\n            else:\\n                moveright += 1\\n        # If target is not present so its no use searching to the left so we return -1\\n        if flag == False:\\n            return -1\\n        \\n        # moving left\\n        moveleft = 0\\n        pointer = startIndex\\n        while True:\\n            if words[pointer] == target:\\n                break\\n            else:\\n                pointer = (pointer - 1 + n) % n\\n                moveleft += 1\\n        return min(moveleft,moveright)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518117,
                "title": "o-n-shortest-distance-to-target-string-in-a-circular-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int i=startIndex, j=startIndex, k, dis1=0, dis2=0;\\n        k=0;\\n        while(k<words.size())\\n        {\\n            if(words[i]!=target)\\n            {\\n                dis1++;\\n                if((i+1)<words.size())\\n                {\\n                    i++;\\n                }\\n                else\\n                {\\n                    i = 0;\\n                }\\n            }\\n            if(words[j]!=target)\\n            {\\n                dis2++;\\n                if((j-1)>=0)\\n                {\\n                    j--;\\n                }\\n                else\\n                {\\n                    j = words.size()-1;\\n                }\\n            }\\n            if(words[i]==target && words[j]==target)\\n            {\\n                if(dis1<=dis2)\\n                    return dis1;\\n                return dis2;\\n            }\\n            k++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6979327f-9ff1-4dfa-83cc-0804123eb294_1683949366.8510556.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int i=startIndex, j=startIndex, k, dis1=0, dis2=0;\\n        k=0;\\n        while(k<words.size())\\n        {\\n            if(words[i]!=target)\\n            {\\n                dis1++;\\n                if((i+1)<words.size())\\n                {\\n                    i++;\\n                }\\n                else\\n                {\\n                    i = 0;\\n                }\\n            }\\n            if(words[j]!=target)\\n            {\\n                dis2++;\\n                if((j-1)>=0)\\n                {\\n                    j--;\\n                }\\n                else\\n                {\\n                    j = words.size()-1;\\n                }\\n            }\\n            if(words[i]==target && words[j]==target)\\n            {\\n                if(dis1<=dis2)\\n                    return dis1;\\n                return dis2;\\n            }\\n            k++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418565,
                "title": "simple-c-o-n-time-complexity-constant-extra-space-beats-94",
                "content": "# Intuition\\nUse the index property in a circular array , when we find a target , check from both ends , and store the minimum of 2.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n         int n =words.size();\\n         if(target==words[startIndex])\\n           return 0;\\n         int i=(startIndex+1)%n;\\n         int minDis = INT_MAX;\\n         while(i!=startIndex)\\n         {\\n             if(words[i]==target)\\n             {\\n                 int dis = min(abs(i-startIndex) , n-abs(i-startIndex));\\n                 minDis= min(minDis,dis);\\n             }\\n             i= (i+1)%n;\\n         }\\n        \\n         return minDis!=INT_MAX ? minDis:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n         int n =words.size();\\n         if(target==words[startIndex])\\n           return 0;\\n         int i=(startIndex+1)%n;\\n         int minDis = INT_MAX;\\n         while(i!=startIndex)\\n         {\\n             if(words[i]==target)\\n             {\\n                 int dis = min(abs(i-startIndex) , n-abs(i-startIndex));\\n                 minDis= min(minDis,dis);\\n             }\\n             i= (i+1)%n;\\n         }\\n        \\n         return minDis!=INT_MAX ? minDis:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409460,
                "title": "python-two-directions-around-the-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom the start index, we can fan out away from it and use the rotation function in case the end of the array is reached.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe increment starting from the starting point and fan out in both directions until they both go opposite directions around the array.  They should meet on the other side.  If the target is found, we immediately return the increment value since that is how far the starting point is from the position that matches the target.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the number of elements in the list.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) for a variable to hold the count.\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        n = len(words)\\n\\n        for i in range(n//2 + 1):\\n            if target in (words[(startIndex+i) % n],\\n                          words[(startIndex-i) % n]):\\n                return i\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        n = len(words)\\n\\n        for i in range(n//2 + 1):\\n            if target in (words[(startIndex+i) % n],\\n                          words[(startIndex-i) % n]):\\n                return i\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237859,
                "title": "eazy-math-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBascially, we can find the index difference between each target and startIndex, then append another set of value that is revered index of the whole list to find complementary index differences. Return the minimum answer of result is what we want. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :type startIndex: int\\n        :rtype: int\\n        \"\"\"\\n        if target not in words:\\n            return -1\\n        else:\\n            res = []\\n            for index,value in enumerate(words):\\n                if value == target:\\n                    res.append(abs(index-startIndex))\\n                    res.append(abs(len(words)-abs(index-startIndex)))\\n            return min(res)\\n\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :type startIndex: int\\n        :rtype: int\\n        \"\"\"\\n        if target not in words:\\n            return -1\\n        else:\\n            res = []\\n            for index,value in enumerate(words):\\n                if value == target:\\n                    res.append(abs(index-startIndex))\\n                    res.append(abs(len(words)-abs(index-startIndex)))\\n            return min(res)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116407,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        unordered_map<string,vector<int>>m;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(m.find(words[i])!=m.end())\\n            {\\n                m[words[i]].push_back(i);\\n            }\\n            else\\n            {\\n                m[words[i]]={i};\\n            }\\n        }\\n        int ans=INT_MAX,ans1=INT_MAX;\\n        int n=words.size();\\n        for(int i=0;i<m[target].size();i++)\\n        {\\n            int t=m[target][i]-startIndex;\\n        \\n            ans=min(abs(t),ans);\\n            if(startIndex>m[target][i])\\n            {\\n                ans1=min(abs(n-startIndex)+m[target][i],ans1);\\n            }\\n            else\\n            {\\n                ans1=min(abs(n-m[target][i])+startIndex,ans1);\\n            }\\n            \\n        }\\n        ans=min(ans,ans1);\\n        return ans!=INT_MAX?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        unordered_map<string,vector<int>>m;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(m.find(words[i])!=m.end())\\n            {\\n                m[words[i]].push_back(i);\\n            }\\n            else\\n            {\\n                m[words[i]]={i};\\n            }\\n        }\\n        int ans=INT_MAX,ans1=INT_MAX;\\n        int n=words.size();\\n        for(int i=0;i<m[target].size();i++)\\n        {\\n            int t=m[target][i]-startIndex;\\n        \\n            ans=min(abs(t),ans);\\n            if(startIndex>m[target][i])\\n            {\\n                ans1=min(abs(n-startIndex)+m[target][i],ans1);\\n            }\\n            else\\n            {\\n                ans1=min(abs(n-m[target][i])+startIndex,ans1);\\n            }\\n            \\n        }\\n        ans=min(ans,ans1);\\n        return ans!=INT_MAX?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987945,
                "title": "simple-short-python-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        for i in range(0, len(words)):\\n            if target in [words[(startIndex - i) % len(words)], words[(startIndex + i) % len(words)]]:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        for i in range(0, len(words)):\\n            if target in [words[(startIndex - i) % len(words)], words[(startIndex + i) % len(words)]]:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974918,
                "title": "0ms-rust-one-long-line",
                "content": "```\\nimpl Solution {\\n    pub fn closet_target(words: Vec<String>, t: String, s: i32) -> i32 {\\n        words[s as usize..].iter().chain(words.iter()).zip(words[..=s as usize].iter().rev().chain(words.iter().rev())).position(|(s1,s2)|s1==&t||s2==&t).map_or(-1,|x| x as i32)\\n    }\\n}\\n```\\n\\nGiven `[A,B,C,D,E]`, where `target = A` and `start = C`, we:\\n1. Generate an iterator moving to the right, yielding: `[C,D,E,A,B,C,D,E]`:\\n```\\nwords[s as usize..].iter().chain(words.iter())\\n```\\n2. Generate an iterator moving to the left, yielding: `[C,B,A,E,D,C,B,A]`:\\n```\\nwords[..=s as usize].iter().rev().chain(words.iter().rev())\\n```\\n3. zip them together to yield the sequence `[(C,C),(D,B),(E,A),(A,E),(B,D),...]`:\\n```\\nwords[s as usize..].iter().chain(words.iter())\\n.zip(\\n    words[..=s as usize].iter().rev().chain(words.iter().rev())\\n)\\n```\\n4. Count how many pairs we have to get through before we find the target:\\n```\\n...\\n.position(|(s1,s2)|s1==&t||s2==&t)\\n```\\n5. Finally, account for the case that we don\\'t find anything with:\\n```\\n...\\n.map_or(-1,|x| x as i32)\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn closet_target(words: Vec<String>, t: String, s: i32) -> i32 {\\n        words[s as usize..].iter().chain(words.iter()).zip(words[..=s as usize].iter().rev().chain(words.iter().rev())).position(|(s1,s2)|s1==&t||s2==&t).map_or(-1,|x| x as i32)\\n    }\\n}\\n```\n```\\nwords[s as usize..].iter().chain(words.iter())\\n```\n```\\nwords[..=s as usize].iter().rev().chain(words.iter().rev())\\n```\n```\\nwords[s as usize..].iter().chain(words.iter())\\n.zip(\\n    words[..=s as usize].iter().rev().chain(words.iter().rev())\\n)\\n```\n```\\n...\\n.position(|(s1,s2)|s1==&t||s2==&t)\\n```\n```\\n...\\n.map_or(-1,|x| x as i32)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955178,
                "title": "python-o-n",
                "content": "```python\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        m = float(\\'inf\\')\\n\\n        for i in range(len(words)):\\n            if words[i] == target:\\n                m = min(m, abs(startIndex - i), len(words) - abs(startIndex - i))\\n\\n        return m if m != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        m = float(\\'inf\\')\\n\\n        for i in range(len(words)):\\n            if words[i] == target:\\n                m = min(m, abs(startIndex - i), len(words) - abs(startIndex - i))\\n\\n        return m if m != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954844,
                "title": "q2515-accepted-c-100-fastest-o-n-easiest-approach-simple",
                "content": "CRUX\\nCalculating Minimum Distance from Right & Left traversal of the circular array\\nPlease Upvote\\nThis solution provides 100% Fastest Sol and I really simple \\uD83E\\uDEF6\\uD83C\\uDFFB\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int t=n-1;\\n        int ansIdx=INT_MAX;\\n        int i=startIndex;\\n        int count=0;\\n        while(t--){\\n            count++;\\n            if(words[(i)%n]==target){ //We go towards right untill the target isn\\'t found\\n                ansIdx=count-1;\\n                break;\\n            }\\n            i++;    \\n        }\\n        t=n-1;\\n        i=startIndex;\\n        count=0;\\n        while(t--){\\n            count++;\\n            if(words[(i+n)%n]==target){\\n                ansIdx=min(ansIdx,count-1); //We go towards left untill the target isn\\'t found\\n                break;\\n            }\\n            i--;\\n        }\\n         cout<<ansIdx<<endl;\\n        return ansIdx!=INT_MAX?ansIdx:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int t=n-1;\\n        int ansIdx=INT_MAX;\\n        int i=startIndex;\\n        int count=0;\\n        while(t--){\\n            count++;\\n            if(words[(i)%n]==target){ //We go towards right untill the target isn\\'t found\\n                ansIdx=count-1;\\n                break;\\n            }\\n            i++;    \\n        }\\n        t=n-1;\\n        i=startIndex;\\n        count=0;\\n        while(t--){\\n            count++;\\n            if(words[(i+n)%n]==target){\\n                ansIdx=min(ansIdx,count-1); //We go towards left untill the target isn\\'t found\\n                break;\\n            }\\n            i--;\\n        }\\n         cout<<ansIdx<<endl;\\n        return ansIdx!=INT_MAX?ansIdx:-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2952350,
                "title": "python-easy-understanding",
                "content": "# Intuition\\nMy first instinct was that It is circular, so in terms of calculation, I can\\'t just count positive numbers, I have to count negative numbers too.\\nIf I want to follow the intuitive way of writing in Python, I would just cut it into two parts, the front and the back, and then reverse them to form a new variable.\\nFinally, I would find the positive and negative indices of the target, compare their sizes, and that would be the final answer.\\n\\nI also explained my thoughts on YouTube.\\n[Link](https://youtu.be/quOs3SYgL-o)\\n\\n# Code\\n```\\nclass Solution:\\n    #1. circular\\n    #2. \\u627E\\u51FAstarIndex\\u8207target\\u4E4B\\u9593\\u7684\\u6700\\u77ED\\u8DDD\\u96E2\\n    def closetTarget(self, words: List[str], target: str, start: int) -> int:\\n        #\\u7B2C\\u4E00\\u6B65\\u9A5F\\uFF1A\\u5148\\u6392\\u9664\\u4E0D\\u53EF\\u80FD\\u7684\\u6771\\u897F\\n        if target not in words:\\n            return -1\\n        #\\u7B2C\\u4E8C\\u6B65\\u9A5F\\uFF1Awords\\u5207\\u5272\\u6210newWords\\uFF0C\\u628Astart\\u653E\\u5728\\u6700\\u524D\\u9762\\u7684\\u4F4D\\u7F6E\\u4E0A\\n        newWords = words[start:] + words[:start] #\\u65B0\\u7684words\\n        index1 = newWords.index(target)\\n        for i in range(-1,-len(words)-1,-1):\\n            if target == newWords[i]:\\n                index2 = -i\\n                break\\n\\n        return min(index1,index2)\\n\\n\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    #1. circular\\n    #2. \\u627E\\u51FAstarIndex\\u8207target\\u4E4B\\u9593\\u7684\\u6700\\u77ED\\u8DDD\\u96E2\\n    def closetTarget(self, words: List[str], target: str, start: int) -> int:\\n        #\\u7B2C\\u4E00\\u6B65\\u9A5F\\uFF1A\\u5148\\u6392\\u9664\\u4E0D\\u53EF\\u80FD\\u7684\\u6771\\u897F\\n        if target not in words:\\n            return -1\\n        #\\u7B2C\\u4E8C\\u6B65\\u9A5F\\uFF1Awords\\u5207\\u5272\\u6210newWords\\uFF0C\\u628Astart\\u653E\\u5728\\u6700\\u524D\\u9762\\u7684\\u4F4D\\u7F6E\\u4E0A\\n        newWords = words[start:] + words[:start] #\\u65B0\\u7684words\\n        index1 = newWords.index(target)\\n        for i in range(-1,-len(words)-1,-1):\\n            if target == newWords[i]:\\n                index2 = -i\\n                break\\n\\n        return min(index1,index2)\\n\\n\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950174,
                "title": "c-solution-time-complexity-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Use Two Pointers, one that goes to left and one that goes to right, get the minimum distance from either pointers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two pointers (suppose i and j), i goes to left and j goes to right. Decrement i until you reach the target, if your i pointer reaches -1, then start it from the last index of the array as we have to treat it as a circular array, break the loop if i comes back to start index.\\nDo the Same with j pointer and increment it until you reach the target, if the pointer reaches the end of array, then reset the pointer to 0 and start traversing again. \\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n        if(words[startIndex]==target)\\n                return 0;\\n      //start both i and j from the start\\n    int i = startIndex,j=startIndex;\\n    int countFori=0,countForj=0;\\n      //Decrement i until you reach target or you get back to startIndex\\n   while (words[i]!=target)\\n   {\\n        i--;\\n\\n        if(i==-1)\\n            i=words.size()-1;\\n\\n        if(i==startIndex)\\n            break;\\n\\n        countFori++;\\n   }\\n   //Increment j until you reach target or you get back to startIndex\\n    while (words[j]!=target)\\n    {\\n        j++;\\n\\n        if(j==words.size())\\n            j=0;\\n\\n        if(j==startIndex)\\n            break;\\n\\n        countForj++;\\n    }\\n\\n    //if i,j and startIndex all are at same position after traversal, then the element is not present, so return -1\\n    if(i==j && j==startIndex)\\n        return -1;\\n    \\n    return min(countFori,countForj);\\n\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n        if(words[startIndex]==target)\\n                return 0;\\n      //start both i and j from the start\\n    int i = startIndex,j=startIndex;\\n    int countFori=0,countForj=0;\\n      //Decrement i until you reach target or you get back to startIndex\\n   while (words[i]!=target)\\n   {\\n        i--;\\n\\n        if(i==-1)\\n            i=words.size()-1;\\n\\n        if(i==startIndex)\\n            break;\\n\\n        countFori++;\\n   }\\n   //Increment j until you reach target or you get back to startIndex\\n    while (words[j]!=target)\\n    {\\n        j++;\\n\\n        if(j==words.size())\\n            j=0;\\n\\n        if(j==startIndex)\\n            break;\\n\\n        countForj++;\\n    }\\n\\n    //if i,j and startIndex all are at same position after traversal, then the element is not present, so return -1\\n    if(i==j && j==startIndex)\\n        return -1;\\n    \\n    return min(countFori,countForj);\\n\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949162,
                "title": "beats-100-java-simple-string-concept",
                "content": "\\n\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i =0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n             int d = Math.abs(startIndex-i);\\n              min = Math.min(min,Math.min(d,words.length-d));\\n            }\\n        }\\n        \\n        if(min == Integer.MAX_VALUE){\\n            return -1;\\n        }else{\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i =0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n             int d = Math.abs(startIndex-i);\\n              min = Math.min(min,Math.min(d,words.length-d));\\n            }\\n        }\\n        \\n        if(min == Integer.MAX_VALUE){\\n            return -1;\\n        }else{\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949069,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\n#define MIN(a,b) (a<b?a:b)\\n#define MINIMAL(a,b,c) MIN(MIN(a,b),c)\\n\\nint closetTarget(char ** words, int wordsSize, char * target, int startIndex){\\n    int len = strlen(target), ans = INT_MAX;\\n    for(int i = 0; i < wordsSize; i++){\\n        if(!strncmp(words[i], target, len)){\\n            ans = MINIMAL(abs(wordsSize+i-startIndex)%wordsSize,abs(wordsSize+startIndex-i)%wordsSize,ans);\\n        }\\n    }\\n    return (ans == INT_MAX)? -1 : ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MIN(a,b) (a<b?a:b)\\n#define MINIMAL(a,b,c) MIN(MIN(a,b),c)\\n\\nint closetTarget(char ** words, int wordsSize, char * target, int startIndex){\\n    int len = strlen(target), ans = INT_MAX;\\n    for(int i = 0; i < wordsSize; i++){\\n        if(!strncmp(words[i], target, len)){\\n            ans = MINIMAL(abs(wordsSize+i-startIndex)%wordsSize,abs(wordsSize+startIndex-i)%wordsSize,ans);\\n        }\\n    }\\n    return (ans == INT_MAX)? -1 : ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2948779,
                "title": "o-n-short-easy-cpp-math",
                "content": "\\n# Approach\\nans is minimum of 3 distances:\\nstarting indx to target directly\\nstarting indx to target through 0\\nstarting indx to target through n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& a, string t, int indx) {\\n        vector<int>v;\\n        bool ok=false;\\n        int d=0,ans=1e5,n=a.size();\\n        for(int i=0;i<n;i++){\\n            if(a[i]==t){\\n                ok=true;\\n                v.push_back(i);\\n            }\\n        }\\n        if(!ok)return -1;\\n        for(auto i:v){\\n            ans=min(ans,abs(i-indx));\\n            ans=min(ans,indx+(n-i));\\n            ans=min(ans,i+(n-indx));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& a, string t, int indx) {\\n        vector<int>v;\\n        bool ok=false;\\n        int d=0,ans=1e5,n=a.size();\\n        for(int i=0;i<n;i++){\\n            if(a[i]==t){\\n                ok=true;\\n                v.push_back(i);\\n            }\\n        }\\n        if(!ok)return -1;\\n        for(auto i:v){\\n            ans=min(ans,abs(i-indx));\\n            ans=min(ans,indx+(n-i));\\n            ans=min(ans,i+(n-indx));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948639,
                "title": "simplest-and-easy-to-understand-solution",
                "content": "```\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int leftdist=-1;\\n        bool flag=false;\\n       if(words[startIndex]==target){\\n           return 0;\\n       }\\n        int i=(startIndex+1)%n;\\n        int count=0;\\n        while(i!=startIndex){\\n            if(words[i]==target){\\n                flag=true;\\n                count++;\\n                break;\\n            }\\n            count++;\\n            i=(i+1)%n;\\n            \\n        }\\n        cout<<count;\\n        if(flag){\\n            leftdist=count;\\n        }\\n        int j=(startIndex-1+n)%n;\\n        bool jhanda=false;\\n        int rightdist=-1;\\n        int counter=0;\\n        \\n         while(j!=startIndex){\\n            if(words[j]==target){\\n                jhanda=true;\\n            counter++;\\n                break;\\n            }\\n            counter++;\\n            j=(j-1+n)%n;\\n            \\n        }\\n        cout<<counter;\\n         if(jhanda){\\n            rightdist=counter;\\n            \\n        }\\n        \\n        if(flag&&jhanda){\\n            return min(leftdist,rightdist);\\n        }else if(flag&&!jhanda){\\n            return leftdist;\\n        }else if(!flag&&jhanda){\\n            return jhanda;\\n        }else{\\n            return -1;\\n        }\\n            }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int leftdist=-1;\\n        bool flag=false;\\n       if(words[startIndex]==target){\\n           return 0;\\n       }\\n        int i=(startIndex+1)%n;\\n        int count=0;\\n        while(i!=startIndex){\\n            if(words[i]==target){\\n                flag=true;\\n                count++;\\n                break;\\n            }\\n            count++;\\n            i=(i+1)%n;\\n            \\n        }\\n        cout<<count;\\n        if(flag){\\n            leftdist=count;\\n        }\\n        int j=(startIndex-1+n)%n;\\n        bool jhanda=false;\\n        int rightdist=-1;\\n        int counter=0;\\n        \\n         while(j!=startIndex){\\n            if(words[j]==target){\\n                jhanda=true;\\n            counter++;\\n                break;\\n            }\\n            counter++;\\n            j=(j-1+n)%n;\\n            \\n        }\\n        cout<<counter;\\n         if(jhanda){\\n            rightdist=counter;\\n            \\n        }\\n        \\n        if(flag&&jhanda){\\n            return min(leftdist,rightdist);\\n        }else if(flag&&!jhanda){\\n            return leftdist;\\n        }else if(!flag&&jhanda){\\n            return jhanda;\\n        }else{\\n            return -1;\\n        }\\n            }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 2948526,
                "title": "c-simple-approach-copy-vector-2-times-beats-83-33",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n        int n = words.size();\\n        unordered_map<string, int> m;\\n        \\n        for(int i=0; i<n; i++) m[words[i]]++;\\n        if(m[target] <= 0) return -1; //  If the string target does not exist in words (Given Example 3:)\\n        \\n        vector<string> v;\\n        // we are copying \\'words\\' vector into \\'v\\' vector \\'3\\' times\\n        // the 1st and 3rd vectors are copy vector, and 2nd vector is our main vector\\n        \\n        int k=3;\\n        while(k--) {\\n            for(int i=0; i<n; i++) v.push_back(words[i]);\\n        }\\n        \\n        int cnt1 = 0, cnt2 = 0;\\n        \\n        // loop from 2nd Vector to 3rd vector\\n        for(int i=n+startIndex; i<v.size(); i++) { // moving forward in \\'v\\' vector\\n            \\n            if(v[i] == target) break; // as soon as we found target, break\\n            cnt1++;\\n        }\\n        \\n        // loop from 2nd Vector to 1st vector\\n        for(int i=n+startIndex; i>=0; i--) { // moving backward in \\'v\\' vector\\n            \\n            if(v[i] == target) break; // as soon as we found target, break\\n            cnt2++;\\n        }\\n        \\n        return min(cnt1, cnt2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n        int n = words.size();\\n        unordered_map<string, int> m;\\n        \\n        for(int i=0; i<n; i++) m[words[i]]++;\\n        if(m[target] <= 0) return -1; //  If the string target does not exist in words (Given Example 3:)\\n        \\n        vector<string> v;\\n        // we are copying \\'words\\' vector into \\'v\\' vector \\'3\\' times\\n        // the 1st and 3rd vectors are copy vector, and 2nd vector is our main vector\\n        \\n        int k=3;\\n        while(k--) {\\n            for(int i=0; i<n; i++) v.push_back(words[i]);\\n        }\\n        \\n        int cnt1 = 0, cnt2 = 0;\\n        \\n        // loop from 2nd Vector to 3rd vector\\n        for(int i=n+startIndex; i<v.size(); i++) { // moving forward in \\'v\\' vector\\n            \\n            if(v[i] == target) break; // as soon as we found target, break\\n            cnt1++;\\n        }\\n        \\n        // loop from 2nd Vector to 1st vector\\n        for(int i=n+startIndex; i>=0; i--) { // moving backward in \\'v\\' vector\\n            \\n            if(v[i] == target) break; // as soon as we found target, break\\n            cnt2++;\\n        }\\n        \\n        return min(cnt1, cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948239,
                "title": "easy-simple-c-solution",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n         int ind= find(words.begin(),words.end(),target)-words.begin();\\n        int n= words.size();\\n        if (ind==n)return -1;\\n        if (words[startIndex]==target) return 0;\\n        int i= startIndex-1;\\n        int j= startIndex+1;\\n        int cnt1=0; int cnt2=0;\\n        while (true){\\n            cnt1++; cnt2++;\\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\\n                return cnt1;\\n            }\\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\\n                return cnt2;\\n            }\\n            i--; j++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n         int ind= find(words.begin(),words.end(),target)-words.begin();\\n        int n= words.size();\\n        if (ind==n)return -1;\\n        if (words[startIndex]==target) return 0;\\n        int i= startIndex-1;\\n        int j= startIndex+1;\\n        int cnt1=0; int cnt2=0;\\n        while (true){\\n            cnt1++; cnt2++;\\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\\n                return cnt1;\\n            }\\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\\n                return cnt2;\\n            }\\n            i--; j++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948104,
                "title": "optimal-c-java-python-sloved-time-complexity-o-n-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\npls like the solution \\ncomment pls\\n```\\nclass Solution\\n{\\npublic:\\n    int closetTarget(vector<string> &words, string target, int startIndex)\\n    {\\n        int ans = INT_MAX, n = words.size(); \\n        for (int i = 0; i < n; ++i) {\\n            if (words[i] == target) {\\n                int res = abs(i - startIndex); \\n                ans = min({ans, res, n - res}); \\n            }\\n        }\\n        return ans < INT_MAX ? ans : -1; \\n    }\\n    \\n};\\n```\\nPYTHON SOLUTION:\\n```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        poss = []\\n        \\n        for i in range(len(words)):\\n            if words[i] == target:\\n                poss += [(startIndex - i) % len(words),(- startIndex + i) % len(words) ]\\n                \\n                \\n        if poss:\\n            return min(poss)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int closetTarget(vector<string> &words, string target, int startIndex)\\n    {\\n        int ans = INT_MAX, n = words.size(); \\n        for (int i = 0; i < n; ++i) {\\n            if (words[i] == target) {\\n                int res = abs(i - startIndex); \\n                ans = min({ans, res, n - res}); \\n            }\\n        }\\n        return ans < INT_MAX ? ans : -1; \\n    }\\n    \\n};\\n```\n```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        poss = []\\n        \\n        for i in range(len(words)):\\n            if words[i] == target:\\n                poss += [(startIndex - i) % len(words),(- startIndex + i) % len(words) ]\\n                \\n                \\n        if poss:\\n            return min(poss)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948101,
                "title": "simple-c-solution-with-explanation",
                "content": "```\\nApproach:\\n\\nCalculate the distance from startIndex to the target index in both directions (clockwise and counterclockwise).\\nReturn the minimum of the two distances(which should be greater than 0 because there is a possibility that it would return -1).\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        if(words[startIndex]==target)\\n        {\\n            return 0;\\n        }\\n        int countr=0;\\n        int z=0;\\n        int i=(startIndex + 1)%n;\\n        while(i!=startIndex)\\n        {\\n            countr++;\\n            if(words[i]==target)\\n            {\\n                z=1;\\n                break;\\n            }\\n            i=(i + 1)%n;\\n        }\\n        \\n        int countl=0;\\n        i=(startIndex-1+n)%n;\\n        while(i!=startIndex)\\n        {\\n            countl++;\\n            if(words[i]==target)\\n            {\\n                break;\\n            }\\n            i=(i-1+n)%n;\\n        }\\n        if(countl>countr&&countl>0&&countr>0)\\n        {\\n            return countr;\\n        }\\n        else if(countr>countl&&countl>0&&countr>0)\\n        {\\n            return countl;\\n        }\\n        if(z==1&&countl==countr)\\n        {\\n            return countr;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nApproach:\\n\\nCalculate the distance from startIndex to the target index in both directions (clockwise and counterclockwise).\\nReturn the minimum of the two distances(which should be greater than 0 because there is a possibility that it would return -1).\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        if(words[startIndex]==target)\\n        {\\n            return 0;\\n        }\\n        int countr=0;\\n        int z=0;\\n        int i=(startIndex + 1)%n;\\n        while(i!=startIndex)\\n        {\\n            countr++;\\n            if(words[i]==target)\\n            {\\n                z=1;\\n                break;\\n            }\\n            i=(i + 1)%n;\\n        }\\n        \\n        int countl=0;\\n        i=(startIndex-1+n)%n;\\n        while(i!=startIndex)\\n        {\\n            countl++;\\n            if(words[i]==target)\\n            {\\n                break;\\n            }\\n            i=(i-1+n)%n;\\n        }\\n        if(countl>countr&&countl>0&&countr>0)\\n        {\\n            return countr;\\n        }\\n        else if(countr>countl&&countl>0&&countr>0)\\n        {\\n            return countl;\\n        }\\n        if(z==1&&countl==countr)\\n        {\\n            return countr;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948026,
                "title": "to-the-point-simple-c-code",
                "content": "```\\nint closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int>v;\\n        int n= words.size();\\n        int ans=INT_MAX;\\n        for(int i=0; i<words.size(); i++){\\n            if(words[i]==target){\\n                v.push_back(i);\\n                int k= abs(i-startIndex);\\n                int y= n-k;\\n                k=min(y,k);\\n                ans = min(k,ans);\\n            }\\n        }\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int>v;\\n        int n= words.size();\\n        int ans=INT_MAX;\\n        for(int i=0; i<words.size(); i++){\\n            if(words[i]==target){\\n                v.push_back(i);\\n                int k= abs(i-startIndex);\\n                int y= n-k;\\n                k=min(y,k);\\n                ans = min(k,ans);\\n            }\\n        }\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2948019,
                "title": "c-easy-solution-with-explanation",
                "content": "# Intuition\\nAs the question required, we have to find the minimum distance from startIndex in a circular array, we can find whole indexes of the target, and append indexes value added with the size of words to the indexes array, so that makes this question a linear question, and just to compare the distance between startIndex and target indexes.\\n# Approach\\n1. Find all indexes of the target string in words.\\n2. Append all indexes value added with the size of words\\n3. Get the minimum distance between the indexes and startIndex (include startIndex + size of words)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int> idxs;\\n        int n = words.size();\\n        int res = n;\\n        int idx = 0;\\n        for(string s : words){ \\n            if(s == target)\\n                idxs.push_back(idx);\\n            idx++;\\n        }\\n        if(idxs.size()==0) return -1;\\n        int m = idxs.size();\\n        for(int i=0; i<m; i++){\\n            idxs.push_back(idxs[i]+n);\\n        }\\n        m = idxs.size();\\n        for(int i=0; i<m; i++){\\n            res = min(res, abs(idxs[i] - startIndex));\\n            res = min(res, abs(idxs[i] - (startIndex + n)));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int> idxs;\\n        int n = words.size();\\n        int res = n;\\n        int idx = 0;\\n        for(string s : words){ \\n            if(s == target)\\n                idxs.push_back(idx);\\n            idx++;\\n        }\\n        if(idxs.size()==0) return -1;\\n        int m = idxs.size();\\n        for(int i=0; i<m; i++){\\n            idxs.push_back(idxs[i]+n);\\n        }\\n        m = idxs.size();\\n        for(int i=0; i<m; i++){\\n            res = min(res, abs(idxs[i] - startIndex));\\n            res = min(res, abs(idxs[i] - (startIndex + n)));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069064,
                "title": "java-solution-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int min = Integer.MAX_VALUE;\\n        int front = startIndex,back = startIndex;\\n        // int back = startIndex;\\n        int count = 0;\\n        while(count<=words.length)\\n        {\\n            if((words[back].equals(target)))\\n            {\\n                return count;\\n            }\\n            if((words[front].equals(target)))\\n            {\\n                return count;\\n            }\\n        front = (front+1)%n;\\n        back = (back-1+n)%n;\\n        count++;\\n        }\\n        min=(min==Integer.MAX_VALUE)?-1:min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int min = Integer.MAX_VALUE;\\n        int front = startIndex,back = startIndex;\\n        // int back = startIndex;\\n        int count = 0;\\n        while(count<=words.length)\\n        {\\n            if((words[back].equals(target)))\\n            {\\n                return count;\\n            }\\n            if((words[front].equals(target)))\\n            {\\n                return count;\\n            }\\n        front = (front+1)%n;\\n        back = (back-1+n)%n;\\n        count++;\\n        }\\n        min=(min==Integer.MAX_VALUE)?-1:min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044057,
                "title": "c-easy-solution-beats-97-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int i,key=INT_MAX;\\n        for( i=0;i<n;i++)\\n        {\\n            if(words[i]==target)\\n             {  //checks the distance from clockwise direction\\n                int a=abs(i-startIndex);\\n                //checks the distance from anti-clockwise direction\\n                int b=n-abs(i-startIndex);\\n                key=min(key,min(a,b));\\n             }\\n        }  \\n        if(key==INT_MAX)return -1;    \\n        return key;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n=words.size();\\n        int i,key=INT_MAX;\\n        for( i=0;i<n;i++)\\n        {\\n            if(words[i]==target)\\n             {  //checks the distance from clockwise direction\\n                int a=abs(i-startIndex);\\n                //checks the distance from anti-clockwise direction\\n                int b=n-abs(i-startIndex);\\n                key=min(key,min(a,b));\\n             }\\n        }  \\n        if(key==INT_MAX)return -1;    \\n        return key;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017250,
                "title": "easy-to-understand-java-solution-100-beats-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        boolean found = false;\\n        if(words[startIndex].equals(target)) return 0;\\n        int c= startIndex+1,lPosition =0;\\n        if(c==words.length) c=0;\\n        while(c!= startIndex){\\n                if(words[c].equals(target)){\\n                    found = true;\\n                     lPosition++;\\n                     break;\\n                }\\n                lPosition++;\\n                c++;\\n                if(c==words.length) c=0; \\n        }\\n        if(!found) return -1;\\n        int d= startIndex-1,rPosition=0;\\n        if(d==-1) d=words.length-1;\\n        while(d!= startIndex){\\n                if(words[d].equals(target)){\\n                    found= true;\\n                     rPosition++;\\n                     break;\\n                }\\n                rPosition++; \\n                d--;\\n                if(d==-1) d=words.length-1;\\n        }\\n        \\n        return Math.min(lPosition,rPosition);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        boolean found = false;\\n        if(words[startIndex].equals(target)) return 0;\\n        int c= startIndex+1,lPosition =0;\\n        if(c==words.length) c=0;\\n        while(c!= startIndex){\\n                if(words[c].equals(target)){\\n                    found = true;\\n                     lPosition++;\\n                     break;\\n                }\\n                lPosition++;\\n                c++;\\n                if(c==words.length) c=0; \\n        }\\n        if(!found) return -1;\\n        int d= startIndex-1,rPosition=0;\\n        if(d==-1) d=words.length-1;\\n        while(d!= startIndex){\\n                if(words[d].equals(target)){\\n                    found= true;\\n                     rPosition++;\\n                     break;\\n                }\\n                rPosition++; \\n                d--;\\n                if(d==-1) d=words.length-1;\\n        }\\n        \\n        return Math.min(lPosition,rPosition);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017031,
                "title": "shortest-distance-js-two-pointers",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    let half = Math.floor(words.length / 2)\\n    let len = words.length\\n    let a = b = startIndex\\n    let step = 0\\n\\n    for (let i = 0; i <= half; i++) {\\n        if (words[a] == target || words[b] == target) {\\n            return step\\n        }\\n\\n        step ++, a ++, b --\\n\\n        if (a >= len) a -= len\\n        if (b < 0) b += len\\n    }\\n\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    let half = Math.floor(words.length / 2)\\n    let len = words.length\\n    let a = b = startIndex\\n    let step = 0\\n\\n    for (let i = 0; i <= half; i++) {\\n        if (words[a] == target || words[b] == target) {\\n            return step\\n        }\\n\\n        step ++, a ++, b --\\n\\n        if (a >= len) a -= len\\n        if (b < 0) b += len\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005845,
                "title": "easy-to-understand-by-using-question-hints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n=len(words)\\n        c1=0\\n        c2=0\\n        flag=False\\n        for i in range(startIndex,len(words)+startIndex):\\n            if words[(i+1)%n]==target:\\n                c1+=1\\n                flag=True\\n                break\\n            else:\\n                c1+=1\\n        if flag==False:\\n            return -1\\n        i = startIndex\\n        while True:\\n            if words[i] == target:\\n                break\\n            else:\\n                i = (i - 1 + n) % n\\n                c2+=1\\n        return min(c1,c2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n=len(words)\\n        c1=0\\n        c2=0\\n        flag=False\\n        for i in range(startIndex,len(words)+startIndex):\\n            if words[(i+1)%n]==target:\\n                c1+=1\\n                flag=True\\n                break\\n            else:\\n                c1+=1\\n        if flag==False:\\n            return -1\\n        i = startIndex\\n        while True:\\n            if words[i] == target:\\n                break\\n            else:\\n                i = (i - 1 + n) % n\\n                c2+=1\\n        return min(c1,c2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997634,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int ans=words.length;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n                if(Math.abs(startIndex-i)>(words.length/2))\\n                    if(startIndex<i)\\n                        ans=Math.min(ans,Math.abs(startIndex+words.length-i));\\n                    else\\n                        ans=Math.min(ans,Math.abs(-startIndex+words.length+i));\\n                else\\n                     ans=Math.min(ans,Math.abs(startIndex-i));\\n            }\\n        }\\n        if(ans!=words.length)\\n            return ans;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int ans=words.length;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n                if(Math.abs(startIndex-i)>(words.length/2))\\n                    if(startIndex<i)\\n                        ans=Math.min(ans,Math.abs(startIndex+words.length-i));\\n                    else\\n                        ans=Math.min(ans,Math.abs(-startIndex+words.length+i));\\n                else\\n                     ans=Math.min(ans,Math.abs(startIndex-i));\\n            }\\n        }\\n        if(ans!=words.length)\\n            return ans;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992650,
                "title": "solution-elixir",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec closet_target(words :: [String.t], target :: String.t, start_index :: integer) :: integer\\n  def closet_target(words, target, start_index) do\\n    distances = Enum.with_index(words)\\n    |> Enum.filter(fn {word, index} -> word == target end)\\n    |> Enum.map(fn {word, index} -> min_distance(start_index, index, length(words)) end)\\n    \\n    if length(distances) == 0, do: -1, else: Enum.min(distances)\\n  end\\n\\n  defp min_distance(start_index, goal_index, len) when start_index > goal_index do\\n    min_distance(goal_index, start_index, len)\\n  end\\n\\n  defp min_distance(start_index, goal_index, len) do\\n    min(goal_index - start_index, start_index - (goal_index - len))\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec closet_target(words :: [String.t], target :: String.t, start_index :: integer) :: integer\\n  def closet_target(words, target, start_index) do\\n    distances = Enum.with_index(words)\\n    |> Enum.filter(fn {word, index} -> word == target end)\\n    |> Enum.map(fn {word, index} -> min_distance(start_index, index, length(words)) end)\\n    \\n    if length(distances) == 0, do: -1, else: Enum.min(distances)\\n  end\\n\\n  defp min_distance(start_index, goal_index, len) when start_index > goal_index do\\n    min_distance(goal_index, start_index, len)\\n  end\\n\\n  defp min_distance(start_index, goal_index, len) do\\n    min(goal_index - start_index, start_index - (goal_index - len))\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3988917,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        targets = []\\n\\n        for i, word in enumerate(words):\\n            if word == target:\\n                targets.append(i)\\n        \\n        if not len(targets):\\n            return -1\\n        \\n        distances = []\\n\\n        for t in targets:\\n            if startIndex == t:\\n                return 0\\n            \\n            if startIndex > t:\\n                distances.append(startIndex - t)\\n                distances.append((len(words)- startIndex) + t)\\n            \\n            if startIndex < t:\\n                distances.append(t-startIndex)\\n                distances.append(startIndex + (len(words)-t))\\n\\n        return min(distances)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        targets = []\\n\\n        for i, word in enumerate(words):\\n            if word == target:\\n                targets.append(i)\\n        \\n        if not len(targets):\\n            return -1\\n        \\n        distances = []\\n\\n        for t in targets:\\n            if startIndex == t:\\n                return 0\\n            \\n            if startIndex > t:\\n                distances.append(startIndex - t)\\n                distances.append((len(words)- startIndex) + t)\\n            \\n            if startIndex < t:\\n                distances.append(t-startIndex)\\n                distances.append(startIndex + (len(words)-t))\\n\\n        return min(distances)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980601,
                "title": "c-two-pointers-easy-to-understand-simple",
                "content": "# Intuition\\nSince we can find the target from left side and right side **centered on startIndex**, so we can use **two pointers** to solve it.\\n\\n# Approach\\nDuring traversaling the string array, using **words[(startIndex + i) % len]** to find the target **from right side of startIndex**, and using **words[(startIndex - i + len) % len]** to find the target **from left side of startIndex**, and get the shortest distance.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$: n means the length of the string array.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int len = words.size(), minDis = len;\\n        for (int i = 0; i < len; ++i) {\\n            if (words[(startIndex + i) % len] == target || \\n                words[(startIndex - i + len) % len] == target) {\\n                    minDis = min(i, minDis);\\n                }\\n        }\\n        return minDis == len ? -1 : minDis;\\n    }\\n};        \\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int len = words.size(), minDis = len;\\n        for (int i = 0; i < len; ++i) {\\n            if (words[(startIndex + i) % len] == target || \\n                words[(startIndex - i + len) % len] == target) {\\n                    minDis = min(i, minDis);\\n                }\\n        }\\n        return minDis == len ? -1 : minDis;\\n    }\\n};        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979055,
                "title": "easy-solution-6-lines-2-pointers-single-pass",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, s: int) -> int:\\n        n = len(words)\\n        for c in range(n // 2 + 1):\\n            i, j = (s + c) % n, (s - c + n) % n\\n            if words[i] == target or words[j] == target:\\n                return c\\n        return -1\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, s: int) -> int:\\n        n = len(words)\\n        for c in range(n // 2 + 1):\\n            i, j = (s + c) % n, (s - c + n) % n\\n            if words[i] == target or words[j] == target:\\n                return c\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969312,
                "title": "performance-beats-100",
                "content": "\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String T, int i) {\\n\\n        int j  = i, fs = 0, bs = 0 , N = words.length;\\n\\n        while(true) {\\n            \\n            if(fs > N || bs > N) break;\\n\\n            if(j < 0) j = N - 1;\\n            if(i == N) i = 0;\\n\\n            if(words[i].equals(T)) {\\n                return fs;\\n            }\\n            else if(words[j].equals(T)) {\\n                return bs;\\n            }\\n\\n            i++;\\n            j--;\\n            fs++;\\n            bs++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String T, int i) {\\n\\n        int j  = i, fs = 0, bs = 0 , N = words.length;\\n\\n        while(true) {\\n            \\n            if(fs > N || bs > N) break;\\n\\n            if(j < 0) j = N - 1;\\n            if(i == N) i = 0;\\n\\n            if(words[i].equals(T)) {\\n                return fs;\\n            }\\n            else if(words[j].equals(T)) {\\n                return bs;\\n            }\\n\\n            i++;\\n            j--;\\n            fs++;\\n            bs++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962154,
                "title": "easy-java-solution-for-begginers",
                "content": "# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if(words[startIndex].equals(target)) return 0;\\n        int count=0;\\n        int i=startIndex + 1;\\n        int j=startIndex - 1;\\n        while(count<words.length){\\n            count++;\\n            if(i>=words.length) i=0;\\n            if(j<0) j=words.length-1;\\n            if(words[i].equals(target) || words[j].equals(target)) return count;\\n            i++;\\n            j--;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if(words[startIndex].equals(target)) return 0;\\n        int count=0;\\n        int i=startIndex + 1;\\n        int j=startIndex - 1;\\n        while(count<words.length){\\n            count++;\\n            if(i>=words.length) i=0;\\n            if(j<0) j=words.length-1;\\n            if(words[i].equals(target) || words[j].equals(target)) return count;\\n            i++;\\n            j--;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931855,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int ans = 101;\\n\\n        for(int i = 0; i < words.length; i++){\\n            if(words[i].equals(target)){\\n                ans = Math.min(ans,Math.abs(startIndex - i));\\n                ans = Math.min(ans,n - Math.abs(startIndex - i));\\n            }\\n        }\\n\\n        return ans != 101 ? ans : -1;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int ans = 101;\\n\\n        for(int i = 0; i < words.length; i++){\\n            if(words[i].equals(target)){\\n                ans = Math.min(ans,Math.abs(startIndex - i));\\n                ans = Math.min(ans,n - Math.abs(startIndex - i));\\n            }\\n        }\\n\\n        return ans != 101 ? ans : -1;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919458,
                "title": "two-pointers-python-algorithm-beginner-friendly",
                "content": "# Intuition\\nThis problems we can solve by using two pointers algorithm. Leet\\'s look at approach!\\n\\n# Approach\\nInitially we can check if target is exist in array by \\'in\\' method - if not return -1 or continue. Then let\\'s think:\\nDefinitely we can move only right side and left otherwise. In this case we should think, what we just cheking lenght to way from startIndex in left side to target and on right side to target exactly. For this just create two pointers - left, right. Making loop for each way to target and count his way.\\nIn the end we just cheking minimum way from side to target by usin min() method. For better understanding watch code solution below. Good luck!\\n\\n# Complexity\\n- Time complexity: In worst case we have O(n + n) => O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        left, right = -1, -1\\n        while True:\\n            left += 1\\n            if words[(startIndex - left + len(words)) % len(words)] == target:\\n                break\\n        while True:\\n            right += 1\\n            if words[(startIndex + right) % len(words)] == target:\\n                break\\n        return min(left, right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:\\n            return -1\\n        left, right = -1, -1\\n        while True:\\n            left += 1\\n            if words[(startIndex - left + len(words)) % len(words)] == target:\\n                break\\n        while True:\\n            right += 1\\n            if words[(startIndex + right) % len(words)] == target:\\n                break\\n        return min(left, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879239,
                "title": "java-0ms-beats-100-00",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 0ms Beats 100.00%\\n\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        if (words[startIndex].equals(target)) {\\n            return 0;\\n        }\\n\\n        int n = words.length;\\n        \\n        for (int distance = 1; distance < n; ++distance) {\\n            int idxLeftward = (startIndex - distance + n) % n;\\n            int idxRightward = (startIndex + distance) % n;\\n\\n            if (words[idxLeftward].equals(target) || words[idxRightward].equals(target)) {\\n                return distance;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 0ms Beats 100.00%\\n\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        if (words[startIndex].equals(target)) {\\n            return 0;\\n        }\\n\\n        int n = words.length;\\n        \\n        for (int distance = 1; distance < n; ++distance) {\\n            int idxLeftward = (startIndex - distance + n) % n;\\n            int idxRightward = (startIndex + distance) % n;\\n\\n            if (words[idxLeftward].equals(target) || words[idxRightward].equals(target)) {\\n                return distance;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876892,
                "title": "one-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        inds = []\\n        for i in range(len(words)):\\n            if words[i] == target:\\n                inds.append(abs(i-startIndex))\\n                inds.append(len(words) - i + startIndex)\\n                inds.append(len(words) + i - startIndex)\\n        if not inds:\\n            return -1\\n        print(inds)\\n        return min(inds)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        inds = []\\n        for i in range(len(words)):\\n            if words[i] == target:\\n                inds.append(abs(i-startIndex))\\n                inds.append(len(words) - i + startIndex)\\n                inds.append(len(words) + i - startIndex)\\n        if not inds:\\n            return -1\\n        print(inds)\\n        return min(inds)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872840,
                "title": "easy-c-solution-90-beats-online-c-submission",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        if(words[startIndex]==target){\\n            return 0;\\n        }\\n        int n=words.size();\\n        int i=(startIndex+1)%n;\\n        int cnt1=1;\\n        while(i!=startIndex){\\n            if(words[i]==target){\\n                break;\\n            }\\n            cnt1++;\\n            i=(i+1)%n;\\n        }\\n        if(i==startIndex){\\n            return -1;\\n        }\\n        i=(startIndex-1+n)%n;\\n        int cnt2=1;\\n        while(i!=startIndex){\\n            if(words[i]==target){\\n                break;\\n            }\\n            cnt2++;\\n            i=(i-1+n)%n;\\n        }\\n        return min(cnt1,cnt2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        if(words[startIndex]==target){\\n            return 0;\\n        }\\n        int n=words.size();\\n        int i=(startIndex+1)%n;\\n        int cnt1=1;\\n        while(i!=startIndex){\\n            if(words[i]==target){\\n                break;\\n            }\\n            cnt1++;\\n            i=(i+1)%n;\\n        }\\n        if(i==startIndex){\\n            return -1;\\n        }\\n        i=(startIndex-1+n)%n;\\n        int cnt2=1;\\n        while(i!=startIndex){\\n            if(words[i]==target){\\n                break;\\n            }\\n            cnt2++;\\n            i=(i-1+n)%n;\\n        }\\n        return min(cnt1,cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867897,
                "title": "java-solution",
                "content": "\\n\\n# Approach\\nTraverse both rightwards and leftwards and count the steps, Return the minimum stepcount.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        int n = words.length;\\n\\n        int fromleft =0;\\n        int start = startIndex;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n             if(words[start].equals(target))break;\\n             start = (start+1)%n;\\n             fromleft++;\\n        }\\n\\n        int fromright =0;\\n        start = startIndex;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(words[start].equals(target))break;\\n            start= (start-1+n)%n;\\n            fromright++;\\n        }\\n\\n        if(fromleft==n && fromright==n)return -1;\\n\\n        return Math.min(fromleft, fromright);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        int n = words.length;\\n\\n        int fromleft =0;\\n        int start = startIndex;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n             if(words[start].equals(target))break;\\n             start = (start+1)%n;\\n             fromleft++;\\n        }\\n\\n        int fromright =0;\\n        start = startIndex;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(words[start].equals(target))break;\\n            start= (start-1+n)%n;\\n            fromright++;\\n        }\\n\\n        if(fromleft==n && fromright==n)return -1;\\n\\n        return Math.min(fromleft, fromright);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866457,
                "title": "simplest-c-solution-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int si) {\\n        int n=words.size();\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(words[i]==target){\\n               ans = min(ans,min(abs(si-i),abs(n-abs(si-i))));\\n       //abs(si-i) gives distance from StartingIndex to target\\n\\n        //abs(n-abs(si-i)) gives distance from StartingIndex \\n                    //to target but in reverse\\n             }\\n         }\\n         if(ans==INT_MAX){\\n             return -1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int si) {\\n        int n=words.size();\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(words[i]==target){\\n               ans = min(ans,min(abs(si-i),abs(n-abs(si-i))));\\n       //abs(si-i) gives distance from StartingIndex to target\\n\\n        //abs(n-abs(si-i)) gives distance from StartingIndex \\n                    //to target but in reverse\\n             }\\n         }\\n         if(ans==INT_MAX){\\n             return -1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823128,
                "title": "python-2-approaches-2-loops-single-loop",
                "content": "# 2 Loops\\n### Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(1)$$ -->\\n\\n### Code\\n```\\nclass Solution:\\n  def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n    if words[startIndex] == target:\\n        return 0\\n    n = len(words)\\n    right_counter = 0\\n    right_index = (startIndex + 1) % n\\n    while right_index != startIndex:\\n        right_counter += 1\\n        if words[right_index] != target:\\n            right_index = (right_index + 1) % n\\n        else:\\n            break\\n    left_counter = 0\\n    left_index = (startIndex - 1 + n) % n\\n    while left_index != startIndex:\\n        left_counter += 1\\n        if words[left_index] != target:\\n            left_index = (left_index - 1 + n) % n\\n        else:\\n            break\\n\\n    if left_index == startIndex and right_index == startIndex:\\n        return -1\\n    return min(right_counter, left_counter)\\n```\\n\\n# 1 Loop\\n### Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(1)$$ -->\\n\\n### Code\\n```\\nclass Solution:\\n  def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n    n = len(words)\\n    shortest_distance = float(\\'inf\\')\\n    for i in range(n):\\n        if words[i] == target:\\n            distance = abs(i - startIndex)\\n            shortest_distance = min(distance, shortest_distance)\\n            shortest_distance = min(n - distance, shortest_distance)\\n\\n    return -1 if shortest_distance == float(\\'inf\\') else shortest_distance\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n  def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n    if words[startIndex] == target:\\n        return 0\\n    n = len(words)\\n    right_counter = 0\\n    right_index = (startIndex + 1) % n\\n    while right_index != startIndex:\\n        right_counter += 1\\n        if words[right_index] != target:\\n            right_index = (right_index + 1) % n\\n        else:\\n            break\\n    left_counter = 0\\n    left_index = (startIndex - 1 + n) % n\\n    while left_index != startIndex:\\n        left_counter += 1\\n        if words[left_index] != target:\\n            left_index = (left_index - 1 + n) % n\\n        else:\\n            break\\n\\n    if left_index == startIndex and right_index == startIndex:\\n        return -1\\n    return min(right_counter, left_counter)\\n```\n```\\nclass Solution:\\n  def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n    n = len(words)\\n    shortest_distance = float(\\'inf\\')\\n    for i in range(n):\\n        if words[i] == target:\\n            distance = abs(i - startIndex)\\n            shortest_distance = min(distance, shortest_distance)\\n            shortest_distance = min(n - distance, shortest_distance)\\n\\n    return -1 if shortest_distance == float(\\'inf\\') else shortest_distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821338,
                "title": "simple-typescript-solution",
                "content": "# Code\\n```ts\\nfunction closetTarget(words: string[], target: string, startIndex: number): number {\\n    // moveCnt: -1 or 1 only for left and right.\\n    const move = (originalIndex: number, moveCnt: number, count = 0) => {\\n        if (originalIndex === words.length) originalIndex = 0\\n        if (originalIndex === -1) originalIndex = words.length - 1\\n        if (words[originalIndex] === target) return count\\n        if (count > words.length) return -1\\n        return move(originalIndex + moveCnt, moveCnt, count + 1)\\n    }\\n\\n    return Math.min(move(startIndex, -1), move(startIndex, 1))\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction closetTarget(words: string[], target: string, startIndex: number): number {\\n    // moveCnt: -1 or 1 only for left and right.\\n    const move = (originalIndex: number, moveCnt: number, count = 0) => {\\n        if (originalIndex === words.length) originalIndex = 0\\n        if (originalIndex === -1) originalIndex = words.length - 1\\n        if (words[originalIndex] === target) return count\\n        if (count > words.length) return -1\\n        return move(originalIndex + moveCnt, moveCnt, count + 1)\\n    }\\n\\n    return Math.min(move(startIndex, -1), move(startIndex, 1))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799193,
                "title": "short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>&w , string t , int s){\\n        int l=s , r=s , n=w.size() , d=0;\\n        while(d<n){\\n            if(w[l]==t || w[r]==t){\\n                return d;\\n            }\\n            d++;\\n            l=(l-1+n)%n;\\n            r=(r+1)%n;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>&w , string t , int s){\\n        int l=s , r=s , n=w.size() , d=0;\\n        while(d<n){\\n            if(w[l]==t || w[r]==t){\\n                return d;\\n            }\\n            d++;\\n            l=(l-1+n)%n;\\n            r=(r+1)%n;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774089,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun closetTarget(words: Array<String>, target: String, startIndex: Int): Int {\\n        val n = words.size\\n        var i = startIndex\\n        var j = startIndex\\n        var forwardCount = 0\\n        var backwardCount = 0\\n\\n        while (forwardCount < n) {\\n            if (words[i] == target || words[j] == target)\\n                return Math.min(forwardCount, backwardCount)\\n\\n            forwardCount++\\n            backwardCount++\\n\\n            i = (i + 1) % n\\n            j = (j - 1 + n) % n\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun closetTarget(words: Array<String>, target: String, startIndex: Int): Int {\\n        val n = words.size\\n        var i = startIndex\\n        var j = startIndex\\n        var forwardCount = 0\\n        var backwardCount = 0\\n\\n        while (forwardCount < n) {\\n            if (words[i] == target || words[j] == target)\\n                return Math.min(forwardCount, backwardCount)\\n\\n            forwardCount++\\n            backwardCount++\\n\\n            i = (i + 1) % n\\n            j = (j - 1 + n) % n\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759982,
                "title": "java-simple-o-n-100-both-one-loop-traverse-magic-of-math-min",
                "content": "# Approach\\nsimple loop traversal from start to finish, and check for if target is equal to current word or not. If both matches, then get the minimum between `distance between current index and startIndex` and `words.length-distance between current index and startIndex`.\\nWe\\'ve to keep min variable to track minimum of all such answers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<words.length; i++){\\n            if(words[i].equals(target)){\\n                min = Math.min(min, Math.min(words.length-Math.abs(i-startIndex), Math.abs(i-startIndex)));\\n            }\\n        }\\n        return min==Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<words.length; i++){\\n            if(words[i].equals(target)){\\n                min = Math.min(min, Math.min(words.length-Math.abs(i-startIndex), Math.abs(i-startIndex)));\\n            }\\n        }\\n        return min==Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754707,
                "title": "easy-to-understand-solution-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        min_distance = 10e400\\n        \\n        for i in range(len(words)):\\n            if words[i] == target:\\n                # distance between the two indices without wrapping over the array end\\n                inner_distance = abs(i - startIndex)\\n                # distance over wrapping the end of the array, it will be\\n                # the index closer to the beginning + array length - the index closer to the end\\n                outer_distance = min(i, startIndex) + len(words) - max(i, startIndex)\\n                # calculate the min distance between all indices\\n                min_distance = min(inner_distance, outer_distance, min_distance)\\n        \\n        if min_distance == 10e400:\\n            return -1\\n\\n        return min_distance\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        min_distance = 10e400\\n        \\n        for i in range(len(words)):\\n            if words[i] == target:\\n                # distance between the two indices without wrapping over the array end\\n                inner_distance = abs(i - startIndex)\\n                # distance over wrapping the end of the array, it will be\\n                # the index closer to the beginning + array length - the index closer to the end\\n                outer_distance = min(i, startIndex) + len(words) - max(i, startIndex)\\n                # calculate the min distance between all indices\\n                min_distance = min(inner_distance, outer_distance, min_distance)\\n        \\n        if min_distance == 10e400:\\n            return -1\\n\\n        return min_distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751048,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    let res = Infinity;\\n    let i = startIndex+1;\\n    let j = startIndex-1;\\n    let jApart = 1;\\n    let iApart = 1;\\n    let k = 0;\\n    if (words[startIndex]==target) return 0;\\n\\n    while(k < words.length){\\n        let curr = -1;\\n        if (i > words.length-1) i = 0;\\n        if (j < 0 ) j = words.length-1;\\n        if (words[i]==target)res = Math.min(res,iApart);\\n        if (words[j]==target)res = Math.min(res,jApart);\\n        k+=1;\\n        i+=1;\\n        j-=1;\\n        jApart+=1;\\n        iApart+=1;\\n    }\\n\\n    if (res == Infinity) return -1;\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    let res = Infinity;\\n    let i = startIndex+1;\\n    let j = startIndex-1;\\n    let jApart = 1;\\n    let iApart = 1;\\n    let k = 0;\\n    if (words[startIndex]==target) return 0;\\n\\n    while(k < words.length){\\n        let curr = -1;\\n        if (i > words.length-1) i = 0;\\n        if (j < 0 ) j = words.length-1;\\n        if (words[i]==target)res = Math.min(res,iApart);\\n        if (words[j]==target)res = Math.min(res,jApart);\\n        k+=1;\\n        i+=1;\\n        j-=1;\\n        jApart+=1;\\n        iApart+=1;\\n    }\\n\\n    if (res == Infinity) return -1;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3747633,
                "title": "java-simple-explained",
                "content": "**Idea:** For each target in words, find the min of its left and right distances from startIndex. Then find the min of all such mins\\n>**T/S:** O(n)/O(1), where n = size(words)\\n```\\npublic int closetTarget(String[] words, String target, int startIndex) {\\n\\tvar n = words.length;\\n\\tvar minDistance = Integer.MAX_VALUE;\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (words[i].equals(target)) {\\n\\t\\t\\tvar left = Math.abs(i - startIndex);\\n\\t\\t\\tvar right = n - left;\\n\\t\\t\\tminDistance = min(minDistance, left, right);\\n\\t\\t}\\n\\n\\treturn minDistance == Integer.MAX_VALUE ? -1 : minDistance;\\n}\\n\\nprivate int min(int a, int b, int c) {\\n\\treturn Math.min(a, Math.min(b, c));\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int closetTarget(String[] words, String target, int startIndex) {\\n\\tvar n = words.length;\\n\\tvar minDistance = Integer.MAX_VALUE;\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (words[i].equals(target)) {\\n\\t\\t\\tvar left = Math.abs(i - startIndex);\\n\\t\\t\\tvar right = n - left;\\n\\t\\t\\tminDistance = min(minDistance, left, right);\\n\\t\\t}\\n\\n\\treturn minDistance == Integer.MAX_VALUE ? -1 : minDistance;\\n}\\n\\nprivate int min(int a, int b, int c) {\\n\\treturn Math.min(a, Math.min(b, c));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3735040,
                "title": "java-linear-check-for-clockwise-anticlockwise-distances-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        int n = words.length;\\n\\n        int minDist = Integer.MAX_VALUE;\\n\\n        for(int destIndex = 0; destIndex < n; destIndex++){\\n\\n            String word = words[destIndex];\\n\\n            //skip, if curr word is not equals to target\\n            if(!word.equals(target)) continue;\\n\\n            int clockwise = Math.abs(destIndex - startIndex) % n;\\n            int antiClockwise = (n - Math.abs(destIndex - startIndex)) % n;\\n\\n            minDist = Math.min(minDist, Math.min(clockwise, antiClockwise));\\n        }\\n\\n        return minDist == Integer.MAX_VALUE ? -1 : minDist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        int n = words.length;\\n\\n        int minDist = Integer.MAX_VALUE;\\n\\n        for(int destIndex = 0; destIndex < n; destIndex++){\\n\\n            String word = words[destIndex];\\n\\n            //skip, if curr word is not equals to target\\n            if(!word.equals(target)) continue;\\n\\n            int clockwise = Math.abs(destIndex - startIndex) % n;\\n            int antiClockwise = (n - Math.abs(destIndex - startIndex)) % n;\\n\\n            minDist = Math.min(minDist, Math.min(clockwise, antiClockwise));\\n        }\\n\\n        return minDist == Integer.MAX_VALUE ? -1 : minDist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734361,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n     let left = startIndex\\n    let right = startIndex\\n    let count = 0\\n    let n = words.length\\n    while(count <= n){\\n        if(words[left] === target || words[right] === target){\\n            return count\\n        } else {\\n            right = (right + 1) % n\\n            left = (left - 1 + n) % n\\n        }\\n        count++\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n     let left = startIndex\\n    let right = startIndex\\n    let count = 0\\n    let n = words.length\\n    while(count <= n){\\n        if(words[left] === target || words[right] === target){\\n            return count\\n        } else {\\n            right = (right + 1) % n\\n            left = (left - 1 + n) % n\\n        }\\n        count++\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733059,
                "title": "simple-java-solution-using-inbuilt-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(words[i].equals(target))\\n            {\\n                int d = Math.abs(i-startIndex);\\n                res=Math.min(res,d);\\n                res=Math.min(res, words.length-d);\\n            }\\n        }\\n        return res==Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(words[i].equals(target))\\n            {\\n                int d = Math.abs(i-startIndex);\\n                res=Math.min(res,d);\\n                res=Math.min(res, words.length-d);\\n            }\\n        }\\n        return res==Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727735,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int left = startIndex;\\n        int right = startIndex;\\n        int distance = 0;\\n        while(distance < words.size())\\n        {\\n            if(words[left] == target || words[right] == target)\\n                return distance;\\n\\n            distance++;\\n            left = (left - 1 + words.size()) % words.size();\\n            right = (right + 1) % words.size();\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int left = startIndex;\\n        int right = startIndex;\\n        int distance = 0;\\n        while(distance < words.size())\\n        {\\n            if(words[left] == target || words[right] == target)\\n                return distance;\\n\\n            distance++;\\n            left = (left - 1 + words.size()) % words.size();\\n            right = (right + 1) % words.size();\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709743,
                "title": "python3-beats-99-8-easy-as-f-with-detailed-description",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate 2 counters to count the minimum steps to reach the target by going to the left and going to the right.\\n\\nFirst of all check whether target is present in the list or not.To avoid getting end in the infinite loop.\\n\\nthen initialize two pointers at the start index. along with 2 booleans to check if thew target is found or not.\\n\\nCreate 2 while loops which will keep running until the target var is found. If the target var is found then break the loop else increase the step of that direction and also increment (or decrement) the pointer of that respective direction.\\n\\nFinally return the minimum of the steps either the left or the right.\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        right,left = 0,0\\n        n = len(words)\\n\\n        if target not in words:\\n            return -1\\n\\n        lptr = startIndex\\n        rptr = startIndex\\n\\n        lfound = 0\\n        rfound = 0\\n\\n        while not lfound:\\n            if words[lptr]==target:\\n                lfound = 1\\n            else:\\n                left+=1\\n                lptr = (lptr-1+n)%n\\n\\n        while not rfound:\\n            if words[rptr]==target:\\n                rfound = 1\\n            else:\\n                right+=1\\n                rptr = (rptr+1)%n\\n\\n        # print(left,right)\\n\\n        return min(left,right)\\n        \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        right,left = 0,0\\n        n = len(words)\\n\\n        if target not in words:\\n            return -1\\n\\n        lptr = startIndex\\n        rptr = startIndex\\n\\n        lfound = 0\\n        rfound = 0\\n\\n        while not lfound:\\n            if words[lptr]==target:\\n                lfound = 1\\n            else:\\n                left+=1\\n                lptr = (lptr-1+n)%n\\n\\n        while not rfound:\\n            if words[rptr]==target:\\n                rfound = 1\\n            else:\\n                right+=1\\n                rptr = (rptr+1)%n\\n\\n        # print(left,right)\\n\\n        return min(left,right)\\n        \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677027,
                "title": "c-easy-and-readable-solution-faster-than-64-less-than-64",
                "content": "![image.png](https://assets.leetcode.com/users/images/fab4f2ba-ee73-49db-93e3-8e98981057bd_1687608550.2170725.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int ClosetTarget(string[] words, string target, int startIndex) {\\n        int ans = int.MaxValue;\\n        for (int i = 0; i < words.Length; i++)\\n            if (words[i] == target)\\n            {\\n                int abs = Math.Abs(i - startIndex);\\n                ans = Math.Min(ans, Math.Min(abs, words.Length - abs));\\n            }\\n        return ans != int.MaxValue? ans : -1;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ClosetTarget(string[] words, string target, int startIndex) {\\n        int ans = int.MaxValue;\\n        for (int i = 0; i < words.Length; i++)\\n            if (words[i] == target)\\n            {\\n                int abs = Math.Abs(i - startIndex);\\n                ans = Math.Min(ans, Math.Min(abs, words.Length - abs));\\n            }\\n        return ans != int.MaxValue? ans : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665582,
                "title": "neatest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string t, int s) \\n    {\\n        int  i = s, n = words.size();\\n        int j = s, x = 0 , y = 0 ; \\n        while(words[i%n]!=t && x<n)\\n        {   \\n            i++;\\n            x++;\\n        }\\n        while(words[(j+n)%n]!=t && y<n)\\n        {\\n            j--;\\n            y++;\\n        }\\n\\n        if(x>=n && y>=n)\\n        return -1;\\n        return min(x,y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string t, int s) \\n    {\\n        int  i = s, n = words.size();\\n        int j = s, x = 0 , y = 0 ; \\n        while(words[i%n]!=t && x<n)\\n        {   \\n            i++;\\n            x++;\\n        }\\n        while(words[(j+n)%n]!=t && y<n)\\n        {\\n            j--;\\n            y++;\\n        }\\n\\n        if(x>=n && y>=n)\\n        return -1;\\n        return min(x,y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658511,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int distance=Integer.MAX_VALUE;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].equals(target))\\n            {\\n                distance=Math.min(distance,Math.min(Math.abs(i-startIndex),words.length-Math.abs(i-startIndex)));\\n            }\\n                \\n        }\\n        if(distance==Integer.MAX_VALUE) return -1;\\n        return distance;\\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int distance=Integer.MAX_VALUE;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].equals(target))\\n            {\\n                distance=Math.min(distance,Math.min(Math.abs(i-startIndex),words.length-Math.abs(i-startIndex)));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3636860,
                "title": "works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimilar to a circular queue except the fifo stuff\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimilar to 2 pointers.\\nrun a loop n/2 and two vars (or one expr in this case {base_counter +/- size_of_arr % size of arr})\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: insignificant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint closetTarget(char ** words, int wordsSize, char * target, int startIndex){\\n    //int s = sizeof(target)-1;\\n    //use if you want to do strncmp (slightly slower)\\n\\n    //check edge case if distance is 0\\n    if(strcmp(words[startIndex], target)==0)\\n    {\\n        return 0;\\n    }\\n\\n    //check distance\\n    for(int i = 0; i <= wordsSize/2; i+=1)\\n    {\\n        if(strcmp( words[(startIndex + i) % wordsSize], target)==0 ||\\n           strcmp( words[(startIndex - i + wordsSize) % wordsSize], target)==0)\\n        {\\n            return i;\\n        }\\n\\n    }\\n\\n    //not found\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint closetTarget(char ** words, int wordsSize, char * target, int startIndex){\\n    //int s = sizeof(target)-1;\\n    //use if you want to do strncmp (slightly slower)\\n\\n    //check edge case if distance is 0\\n    if(strcmp(words[startIndex], target)==0)\\n    {\\n        return 0;\\n    }\\n\\n    //check distance\\n    for(int i = 0; i <= wordsSize/2; i+=1)\\n    {\\n        if(strcmp( words[(startIndex + i) % wordsSize], target)==0 ||\\n           strcmp( words[(startIndex - i + wordsSize) % wordsSize], target)==0)\\n        {\\n            return i;\\n        }\\n\\n    }\\n\\n    //not found\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3635903,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        chk=[]\\n        res=[]\\n        for i in range(len(words)):\\n            if words[i]==target:\\n                chk.append(i)\\n        if len(chk)==0:\\n            return -1\\n        for i in chk:\\n            if i>=startIndex:\\n                res.append(min((i-startIndex),len(words)-i+startIndex))\\n            else:\\n                res.append(min((startIndex-i),len(words)-startIndex+i))\\n        return min(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        chk=[]\\n        res=[]\\n        for i in range(len(words)):\\n            if words[i]==target:\\n                chk.append(i)\\n        if len(chk)==0:\\n            return -1\\n        for i in chk:\\n            if i>=startIndex:\\n                res.append(min((i-startIndex),len(words)-i+startIndex))\\n            else:\\n                res.append(min((startIndex-i),len(words)-startIndex+i))\\n        return min(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622255,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        const int size = words.size();\\n        if (words[startIndex] == target) return 0;\\n        for (auto i = startIndex + 1, j = startIndex + size - 1; i % size != startIndex; ++i, --j) {\\n            if (words[i % size] == target) return i - startIndex;\\n            if (words[j % size] == target) return startIndex + size - j;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        const int size = words.size();\\n        if (words[startIndex] == target) return 0;\\n        for (auto i = startIndex + 1, j = startIndex + size - 1; i % size != startIndex; ++i, --j) {\\n            if (words[i % size] == target) return i - startIndex;\\n            if (words[j % size] == target) return startIndex + size - j;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618102,
                "title": "easy-and-pretty-fast-solution-with-the-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will need iterate over the input array in direct and reverse order and the same time. Consequently, we will need two vars that will mean index of the array for direct order and reverse order. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create two vars to use them for array indexes of direct and reverse iterating. Also, we create var steps. Then we have \"while\" loop where we increment direct order index and reverse order index. On the every iteration we check if we found the target and count every step. If number of steps is greater than words length, it means that we have already check all the array and there isn`t target here, so we should return -1. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        int backIndex=startIndex;\\n        int forwardIndex=startIndex;\\n\\n        int steps=0;\\n\\n        while (steps<words.length){\\n            if((words[backIndex--].equals(target))||(words[forwardIndex++].equals(target))) return steps;\\n            else {\\n                steps++;\\n                if(backIndex==-1)backIndex=words.length-1;\\n                if(forwardIndex==words.length) forwardIndex=0;\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n\\n        int backIndex=startIndex;\\n        int forwardIndex=startIndex;\\n\\n        int steps=0;\\n\\n        while (steps<words.length){\\n            if((words[backIndex--].equals(target))||(words[forwardIndex++].equals(target))) return steps;\\n            else {\\n                steps++;\\n                if(backIndex==-1)backIndex=words.length-1;\\n                if(forwardIndex==words.length) forwardIndex=0;\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610357,
                "title": "java-soln",
                "content": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int countUp = startIndex, countDown = startIndex;\\n        int dist = 0, len = words.length;\\n\\n        while (dist < len) {\\n            if (words[countUp].equals(target) || words[countDown].equals(target))\\n                return dist;\\n            \\n\\n            if (countUp == len-1)\\n                countUp = 0;\\n            else\\n                ++countUp;\\n            \\n\\n            if (countDown == 0)\\n                countDown = len-1;\\n            else\\n                --countDown;\\n            \\n\\n            ++dist;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int countUp = startIndex, countDown = startIndex;\\n        int dist = 0, len = words.length;\\n\\n        while (dist < len) {\\n            if (words[countUp].equals(target) || words[countDown].equals(target))\\n                return dist;\\n            \\n\\n            if (countUp == len-1)\\n                countUp = 0;\\n            else\\n                ++countUp;\\n            \\n\\n            if (countDown == 0)\\n                countDown = len-1;\\n            else\\n                --countDown;\\n            \\n\\n            ++dist;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602354,
                "title": "intuitive-java-and-python-solution-crushes-100-of-submissions-o-n",
                "content": "![image.png](https://assets.leetcode.com/users/images/feb05cd3-c5e2-4148-9dae-bdda2cc00ec9_1686003678.6602106.png)\\n\\n\\n# Intuition\\nThe objective is to return the shortest number of steps to reach a target string in a string array. We are also told that the string array is circular meaning that after reaching the end we start over from the beginning when indexing and that the string existing in the array is not guaranteed.\\n\\nOne way we could do this is traversing in both directions as we iterate through the array. For instance, assume we have an array `[\"some\", \"array\", \"contents]` and the `startIndex` is 1, that is \"array\" in this case, also assume that the target is \"contents\", which is in index `2`. So, traversing this array in both directions:\\n1. going left, we land on \"some\" at index `1`\\n2. going right, we land on \"contents\" which so happens to be our target and is at index `2`\\n\\nWe immediately stop the traversing and return the number of steps taken so far to reach the target since, the it\\'ll be the least number of steps, in this case 1.\\n\\n# Approach\\nA high-level description of this algorithm would be:\\n\\n1. keep a reference `steps` to how many steps we\\'ve taken to arrive at the target string. It will be 0 by default.\\n2. Iterate through the array and store the values of the string at the left and right of the current index.\\n    - this is achieved by getting the value before  the current index, which is effectively `i - 1` for left, and the value after the current index, `i + 1` for right.\\n    - we do have to keep in mind that this **is** a circular array, so what happens when `i - 1` is negative or `i + 1` is greater than or equal to the array\\'s length? A well-known walk-around is using the modulus operator `%` so instead of `i - 1` and `i + 1`, we\\'ll be doing `(i - 1) % size` and `(i + 1) % size` respectively.\\n    - But there is a catch, in Java, if the index is negative, using the modulus operator still results in a negative number so we use `(i + 1 + size) % size ` to effectively address that issue. So assuming we have `i - 1` to be -1, `(i - 1) + size` will be `-1 + 3` which is `2` in our case, and `2 % 3` is 2. Whew! That was *alot* to cover, the rest is strawberry cake!\\n3. We then check if the string at the left or right of the word is equal to the target, returning `steps` so far if it is or incrementing steps otherwise.\\n4. Remember, we\\'re not guaranteed to find the target in the array, to we return -1 if the loop completes without returning `steps`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int steps = 0;\\n        int size = words.length;\\n\\n        for (int i = 0; i < size; i++) {\\n            String left = words[(startIndex - i + size) % size];\\n            String right = words[(startIndex + i) % size];\\n\\n            if (target.equals(left) || target.equals(right)) {\\n                return steps;\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        steps = 0\\n        size = len(words)\\n\\n        for i in range(size):\\n            left = words[(startIndex - i) % size]\\n            right = words[(startIndex + i) % size]\\n\\n            if target in [left, right]:\\n                return steps\\n\\n            steps += 1\\n\\n        return -1\\n```\\n\\n### Thank you for reviewing my solution! If you found it helpful, I would greatly appreciate an upvote from you!",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int steps = 0;\\n        int size = words.length;\\n\\n        for (int i = 0; i < size; i++) {\\n            String left = words[(startIndex - i + size) % size];\\n            String right = words[(startIndex + i) % size];\\n\\n            if (target.equals(left) || target.equals(right)) {\\n                return steps;\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        steps = 0\\n        size = len(words)\\n\\n        for i in range(size):\\n            left = words[(startIndex - i) % size]\\n            right = words[(startIndex + i) % size]\\n\\n            if target in [left, right]:\\n                return steps\\n\\n            steps += 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550365,
                "title": "c-85-time-82-space-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every target string in ***words***, the distance between startIndex and target word can be covered in two ways, one is linearly i.e abs(index of target word-startIndex) or circularly i.e. (size of ***words***)- linear distance we earlier calculated. Find the min of these two distances and update the ans with min(ans,min of dist that we just calculated).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans=200,ind=-1;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]==target){\\n                ind=i;\\n                ans=min(ans,min((abs(ind-startIndex)),(int)(words.size()-abs(ind-startIndex))));\\n            }\\n        }\\n        if(ind==-1) return -1;\\n        return ans;\\n    }\\n};\\n// 0 1 2 3 a 5 6 7 8 9 10 b 12 13 14 15\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans=200,ind=-1;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]==target){\\n                ind=i;\\n                ans=min(ans,min((abs(ind-startIndex)),(int)(words.size()-abs(ind-startIndex))));\\n            }\\n        }\\n        if(ind==-1) return -1;\\n        return ans;\\n    }\\n};\\n// 0 1 2 3 a 5 6 7 8 9 10 b 12 13 14 15\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542768,
                "title": "easiest-to-understand-explaination-included",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s a breakdown of how the function works:\\n\\n1. It first checks if the string at the startIndex position in the words vector is equal to the target. If it is, it immediately returns 0 since the target is found at the starting index.\\n\\n2. It initializes two variables: n to store the size of the words vector and k to 1. The variable k represents the distance from the startIndex.\\n\\n3. The function enters a while loop that continues until k becomes equal to n. Inside the loop, it performs the following checks:\\n    \\n    3.1) It checks if the string at the position (startIndex+k)%n in the words vector is equal to the target. If it is, it returns the current value of k since the target is found at a distance of k from the startIndex.\\n\\n    3.2) It checks if the string at the position (startIndex-k+n)%n in the words vector is equal to the target. If it is, it returns the current value of k since the target is found at a distance of k from the startIndex. The expression (startIndex-k+n)%n calculates the correct index even if k goes beyond the bounds of the words vector.\\n\\n    3.3) If none of the above conditions are met, it increments k by 1 and continues to the next iteration of the loop.\\n\\n4. If the loop completes without finding the target string, it means the target is not present in the words vector within the given constraints. In this case, the function returns -1 to indicate the target was not found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        if(words[startIndex]==target) return 0;\\n        int n = words.size();\\n        int k = 1;  \\n        while(k!=n){\\n            if(words[(startIndex+k)%n]==target) return k;\\n            if(words[(startIndex-k+n)%n]==target) return k;\\n            k++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        if(words[startIndex]==target) return 0;\\n        int n = words.size();\\n        int k = 1;  \\n        while(k!=n){\\n            if(words[(startIndex+k)%n]==target) return k;\\n            if(words[(startIndex-k+n)%n]==target) return k;\\n            k++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505840,
                "title": "very-easy-jebas-raja",
                "content": "# Intuition:Karunya university::accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex)\\n     {\\n        \\n        int timesitratingright = words.length-1;\\n        \\n        int i = 1;\\n        \\n        int towardsright=startIndex;\\n        \\n        int firstcase=0;\\n        \\n  \\nif(target.equals(words[startIndex]))\\n{\\n    return 0;\\n}\\n\\n//FORWARD\\nwhile(i <=timesitratingright) \\n{   \\n    \\n    towardsright++;\\n\\n     if (towardsright < words.length) {\\n        System.out.println(\"owardsright\"+towardsright);     \\n        if (target.equals(words[towardsright])) {\\n               \\n            firstcase=i;\\n            System.out.println(\"firstcasenadar\"+firstcase);\\n            break;\\n        }\\n    }\\n     else  \\n    {\\n        if(target.equals(words[towardsright%words.length]))\\n        { \\n            //System.out.println(\"firs\");\\n            firstcase=i;\\n            break;\\n        }\\n        // handle the else case here\\n    }\\n    i++;\\n}\\n\\n\\n \\n//BACKWARDint \\nint timesitratingleft = words.length-1;\\n \\nint j = 1;\\n \\nint secondcase=0;\\n \\nint  towardsleft=startIndex-1;\\n\\nwhile (j<=timesitratingleft)\\n{    \\n    //System.out.println(\"towardsleft\"+towardsleft);\\n   if (target.equals(words[(words.length+towardsleft)%words.length])) \\n   {\\n    secondcase=j;\\n    break;\\n   } \\n    j++;\\n    towardsleft--; \\n}\\nSystem.out.println(\"firstcase\"+firstcase);\\nSystem.out.println(\"secondcase\"+secondcase);\\n  \\nif (firstcase==0 && secondcase==0) {\\n    \\n    //System.out.println(-1);\\n    return -1;\\n}\\nelse\\n{\\n   //System.out.println(Math.min(secondcase, firstcase));\\n   return Math.min(secondcase, firstcase);\\n}\\n\\n//return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex)\\n     {\\n        \\n        int timesitratingright = words.length-1;\\n        \\n        int i = 1;\\n        \\n        int towardsright=startIndex;\\n        \\n        int firstcase=0;\\n        \\n  \\nif(target.equals(words[startIndex]))\\n{\\n    return 0;\\n}\\n\\n//FORWARD\\nwhile(i <=timesitratingright) \\n{   \\n    \\n    towardsright++;\\n\\n     if (towardsright < words.length) {\\n        System.out.println(\"owardsright\"+towardsright);     \\n        if (target.equals(words[towardsright])) {\\n               \\n            firstcase=i;\\n            System.out.println(\"firstcasenadar\"+firstcase);\\n            break;\\n        }\\n    }\\n     else  \\n    {\\n        if(target.equals(words[towardsright%words.length]))\\n        { \\n            //System.out.println(\"firs\");\\n            firstcase=i;\\n            break;\\n        }\\n        // handle the else case here\\n    }\\n    i++;\\n}\\n\\n\\n \\n//BACKWARDint \\nint timesitratingleft = words.length-1;\\n \\nint j = 1;\\n \\nint secondcase=0;\\n \\nint  towardsleft=startIndex-1;\\n\\nwhile (j<=timesitratingleft)\\n{    \\n    //System.out.println(\"towardsleft\"+towardsleft);\\n   if (target.equals(words[(words.length+towardsleft)%words.length])) \\n   {\\n    secondcase=j;\\n    break;\\n   } \\n    j++;\\n    towardsleft--; \\n}\\nSystem.out.println(\"firstcase\"+firstcase);\\nSystem.out.println(\"secondcase\"+secondcase);\\n  \\nif (firstcase==0 && secondcase==0) {\\n    \\n    //System.out.println(-1);\\n    return -1;\\n}\\nelse\\n{\\n   //System.out.println(Math.min(secondcase, firstcase));\\n   return Math.min(secondcase, firstcase);\\n}\\n\\n//return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504433,
                "title": "an-easy-to-understand-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly I saw I had 2 equations:\\nOne to go forward and one to go backward... My thought proccess was to create a function which make you go one step at a time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThen I had a better Idea, since `1` is defined for the number of steps we take, than we can just use a `for` loop and 2 functions, one for going forwad and one for going backward, and both of them will have a custom parameter which is the number of steps.\\nIn the for loop, I used `i` as the number of steps of which iteration of the loop. until I\\'ve found the best distance!\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nArrays And Math Equations\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function (words, target, startIndex) {\\n    if (!words.includes(target)) {\\n        return -1;\\n    }\\n    if (words[startIndex] === target) {\\n        return 0;\\n    }\\n    function toGoNext(steps) {\\n        return (startIndex + steps) % words.length;\\n    }\\n    function toGoPrevious(steps) {\\n        return (startIndex - steps + words.length) % words.length;\\n    }\\n    for (let i = 1; i<words.length; i++){\\n        if(words[toGoNext(i)] === target | words[toGoPrevious(i)] === target) {\\n            return i;\\n        }\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function (words, target, startIndex) {\\n    if (!words.includes(target)) {\\n        return -1;\\n    }\\n    if (words[startIndex] === target) {\\n        return 0;\\n    }\\n    function toGoNext(steps) {\\n        return (startIndex + steps) % words.length;\\n    }\\n    function toGoPrevious(steps) {\\n        return (startIndex - steps + words.length) % words.length;\\n    }\\n    for (let i = 1; i<words.length; i++){\\n        if(words[toGoNext(i)] === target | words[toGoPrevious(i)] === target) {\\n            return i;\\n        }\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493801,
                "title": "java-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n= words.length, dist=Integer.MAX_VALUE, flag =0;\\n        for(int i=0; i<n; i++){\\n            if(words[i].equals(target)){\\n                flag=1;\\n                if(dist> mod(startIndex-i))  dist = mod(startIndex-i);\\n                \\n                if(startIndex==i) return 0;\\n                else if(startIndex>i && dist>(n-startIndex+i)) dist = n-startIndex+i;\\n                else if(startIndex<i && dist>(n-i+startIndex)) dist = n-i+startIndex; \\n            }\\n        }\\n        if(flag ==0) return -1;\\n        return dist;\\n    }\\n\\n    public int mod(int a){\\n        if(a<0) a*=-1;\\n        return a; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n= words.length, dist=Integer.MAX_VALUE, flag =0;\\n        for(int i=0; i<n; i++){\\n            if(words[i].equals(target)){\\n                flag=1;\\n                if(dist> mod(startIndex-i))  dist = mod(startIndex-i);\\n                \\n                if(startIndex==i) return 0;\\n                else if(startIndex>i && dist>(n-startIndex+i)) dist = n-startIndex+i;\\n                else if(startIndex<i && dist>(n-i+startIndex)) dist = n-i+startIndex; \\n            }\\n        }\\n        if(flag ==0) return -1;\\n        return dist;\\n    }\\n\\n    public int mod(int a){\\n        if(a<0) a*=-1;\\n        return a; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484074,
                "title": "java-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if(equal(words[startIndex],target)==true) return 0;\\n        int c1=startIndex;\\n        int c2=startIndex;\\n        int len = words.length;\\n        int range =0;\\n        int count1=0;\\n        int count2=0;\\n        while(range<len){\\n            if(equal(words[c1],target) || equal(words[c2],target)){\\n                return Math.min(count1,count2); \\n            }\\n            if(c1==len-1) c1=0;\\n            else c1+=1;\\n            if(c2==0) c2=len-1;\\n            else c2-=1;\\n\\n            count1++;\\n            count2++;\\n            range++;\\n        }\\n        return -1;\\n        \\n    }\\n    public boolean equal(String s1, String s2){\\n        if(s1.length()!=s2.length()) return false;\\n        int i=0,j=0;\\n        char[] ch1=s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        while(i<ch1.length && j<ch2.length){\\n            if(ch1[i]!=ch2[j]){\\n                return false;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if(equal(words[startIndex],target)==true) return 0;\\n        int c1=startIndex;\\n        int c2=startIndex;\\n        int len = words.length;\\n        int range =0;\\n        int count1=0;\\n        int count2=0;\\n        while(range<len){\\n            if(equal(words[c1],target) || equal(words[c2],target)){\\n                return Math.min(count1,count2); \\n            }\\n            if(c1==len-1) c1=0;\\n            else c1+=1;\\n            if(c2==0) c2=len-1;\\n            else c2-=1;\\n\\n            count1++;\\n            count2++;\\n            range++;\\n        }\\n        return -1;\\n        \\n    }\\n    public boolean equal(String s1, String s2){\\n        if(s1.length()!=s2.length()) return false;\\n        int i=0,j=0;\\n        char[] ch1=s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        while(i<ch1.length && j<ch2.length){\\n            if(ch1[i]!=ch2[j]){\\n                return false;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480005,
                "title": "java-simple-solution-o-n-math-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int shortestDistance = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (words[i].equals(target)) {\\n                int distance = Math.abs(i - startIndex);\\n                shortestDistance = Math.min(distance, shortestDistance);\\n                shortestDistance = Math.min(n - distance, shortestDistance);\\n            }\\n        }\\n\\n        return shortestDistance == Integer.MAX_VALUE ? -1 : shortestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int shortestDistance = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (words[i].equals(target)) {\\n                int distance = Math.abs(i - startIndex);\\n                shortestDistance = Math.min(distance, shortestDistance);\\n                shortestDistance = Math.min(n - distance, shortestDistance);\\n            }\\n        }\\n\\n        return shortestDistance == Integer.MAX_VALUE ? -1 : shortestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475263,
                "title": "c-two-pointer-approach-easy-intuitive-one-pass",
                "content": "# Intuition\\nTwo pointer approach, we can do one pass if we increment one and decrement the other each iteration.\\n\\n# Approach\\nTwo pointers, one visiting every previous element and one visiting every next element until they arrive at the same index. Then before returning we check to see if the element at that last index is our target, else the element does not exist.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size(), i = 0, goRight = startIndex, goLeft = startIndex;\\n        do{\\n            if(words[goLeft] == target || words[goRight] == target)\\n                return i;\\n            goRight = (goRight + 1) % n;\\n            goLeft = (goLeft - 1 + n) % n; \\n            i++;\\n        }while(goRight != goLeft);\\n        return words[goRight] == target ? goRight : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size(), i = 0, goRight = startIndex, goLeft = startIndex;\\n        do{\\n            if(words[goLeft] == target || words[goRight] == target)\\n                return i;\\n            goRight = (goRight + 1) % n;\\n            goLeft = (goLeft - 1 + n) % n; \\n            i++;\\n        }while(goRight != goLeft);\\n        return words[goRight] == target ? goRight : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475032,
                "title": "5-lines-of-code-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        if target not in words:\\n            return -1\\n\\n        start = startIndex + len(words)\\n        words = words * 3\\n        \\n        return min(words[:start + 1][::-1].index(target), words[start:].index(target))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        if target not in words:\\n            return -1\\n\\n        start = startIndex + len(words)\\n        words = words * 3\\n        \\n        return min(words[:start + 1][::-1].index(target), words[start:].index(target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467723,
                "title": "easy-python-solution-using-one-while-loop",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake circular list by concatinating words list 3 times\\n\\n`words = words + words + words` that is: \\n[\"a\",\"b\",\"leetcode\", **\"a\",\"b\",\"leetcode\"**, \"a\",\"b\",\"leetcode\"]\\n \\nStart checking for target from middle portion of circular list\\n\\nSet startIndex to `startIndex = len(words) + startIndex`, before concatinating words list, so that we can check for target from the middle of concatinated words list.\\n\\nMake counter, that moves forward through list by adding it to startIndex and moves through list backwards at the same time by subtracting counter from startIndex. \\n\\n`if words[startIndex + counter] == target or\\n words[startIndex - counter] == target`\\n\\nIf target is found, return counter, since it is the amount of our shortest iteration to our target.\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) because of `words = words + words  + words`\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        #check if target in words list\\n        if target in words:  \\n\\n            # set startIndex to length of words list + startIndex\\n            startIndex = len(words) + startIndex\\n\\n            #make triple of words list, so that we can start checking from middle words list\\n            words = words + words + words\\n            counter = 0\\n            while True:\\n\\n                # start checking for target by going forward and backwards at the same time.\\n                if words[startIndex + counter] == target or words[startIndex - counter] == target:\\n                    return counter\\n                counter += 1\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        #check if target in words list\\n        if target in words:  \\n\\n            # set startIndex to length of words list + startIndex\\n            startIndex = len(words) + startIndex\\n\\n            #make triple of words list, so that we can start checking from middle words list\\n            words = words + words + words\\n            counter = 0\\n            while True:\\n\\n                # start checking for target by going forward and backwards at the same time.\\n                if words[startIndex + counter] == target or words[startIndex - counter] == target:\\n                    return counter\\n                counter += 1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462206,
                "title": "straightforward-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        res = float(\"inf\")\\n        for i in range(len(words)):\\n            if words[i] == target:\\n                res = min(res, abs(i-startIndex), len(words)-abs(i-startIndex))\\n        if res == float(\"inf\"):\\n            return -1\\n        else:\\n            return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        res = float(\"inf\")\\n        for i in range(len(words)):\\n            if words[i] == target:\\n                res = min(res, abs(i-startIndex), len(words)-abs(i-startIndex))\\n        if res == float(\"inf\"):\\n            return -1\\n        else:\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445066,
                "title": "writing-possibilities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        \\n        l=[]\\n        for i in range(len(words)):\\n            if words[i]==target:\\n                l.append(i)\\n        \\n        m=0\\n        p=[]\\n        for i in l:\\n            j=len(words)\\n            m = min(abs(i-startIndex),j-startIndex+i,j+startIndex-i)\\n            p.append(m)\\n            \\n        if len(l)>0:\\n            return min(p)\\n            \\n        else:\\n            return -1\\n\\n        \\n\\n\\n    \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        \\n        l=[]\\n        for i in range(len(words)):\\n            if words[i]==target:\\n                l.append(i)\\n        \\n        m=0\\n        p=[]\\n        for i in l:\\n            j=len(words)\\n            m = min(abs(i-startIndex),j-startIndex+i,j+startIndex-i)\\n            p.append(m)\\n            \\n        if len(l)>0:\\n            return min(p)\\n            \\n        else:\\n            return -1\\n\\n        \\n\\n\\n    \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439552,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int ClosetTarget(string[] words, string target, int startIndex) {\\n        int shortestDistance = Int32.MaxValue, n = words.Length;\\n        int i = startIndex;\\n        int count = 0;\\n        while(count < n) {\\n            if(words[i % n] == target) {\\n                shortestDistance = Math.Min(shortestDistance, count);\\n                break;\\n            }\\n            i++;\\n            count++;\\n        }\\n\\n        i = startIndex;\\n        count  = 0;\\n        while(count < n) {\\n             if(words[(i + n) % n] == target) {\\n                shortestDistance = Math.Min(shortestDistance, count);\\n                break;\\n            }\\n            i--;\\n            count++;\\n        }\\n\\n\\n        return  shortestDistance == Int32.MaxValue ? -1 : shortestDistance; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ClosetTarget(string[] words, string target, int startIndex) {\\n        int shortestDistance = Int32.MaxValue, n = words.Length;\\n        int i = startIndex;\\n        int count = 0;\\n        while(count < n) {\\n            if(words[i % n] == target) {\\n                shortestDistance = Math.Min(shortestDistance, count);\\n                break;\\n            }\\n            i++;\\n            count++;\\n        }\\n\\n        i = startIndex;\\n        count  = 0;\\n        while(count < n) {\\n             if(words[(i + n) % n] == target) {\\n                shortestDistance = Math.Min(shortestDistance, count);\\n                break;\\n            }\\n            i--;\\n            count++;\\n        }\\n\\n\\n        return  shortestDistance == Int32.MaxValue ? -1 : shortestDistance; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425660,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n  const n = words.length;\\n  let minDist = Infinity;\\n  let i = startIndex;\\n  let dist = 0;\\n\\n  do {\\n    if (words[i] === target) {\\n      minDist = Math.min(minDist, dist);\\n    }\\n    i = (i + 1) % n;\\n    dist++;\\n  } while (i !== startIndex);\\n\\n  i = startIndex;\\n  dist = 0;\\n\\n  do {\\n    if (words[i] === target) {\\n      minDist = Math.min(minDist, dist);\\n    }\\n    i = (i - 1 + n) % n;\\n    dist++;\\n  } while (i !== startIndex);\\n\\n  return minDist !== Infinity ? minDist : -1;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n  const n = words.length;\\n  let minDist = Infinity;\\n  let i = startIndex;\\n  let dist = 0;\\n\\n  do {\\n    if (words[i] === target) {\\n      minDist = Math.min(minDist, dist);\\n    }\\n    i = (i + 1) % n;\\n    dist++;\\n  } while (i !== startIndex);\\n\\n  i = startIndex;\\n  dist = 0;\\n\\n  do {\\n    if (words[i] === target) {\\n      minDist = Math.min(minDist, dist);\\n    }\\n    i = (i - 1 + n) % n;\\n    dist++;\\n  } while (i !== startIndex);\\n\\n  return minDist !== Infinity ? minDist : -1;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408482,
                "title": "python-explained-runtime-22-ms-beats-99-31",
                "content": "![Screenshot 2023-04-12 4.06.37 PM.png](https://assets.leetcode.com/users/images/b52fd287-d8ae-4211-98ac-69f6e9bac2c4_1681295913.4535987.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :type startIndex: int\\n        :rtype: int\\n        \"\"\"\\n\\n        # When target word is not present in the words list.\\n        if target not in words:\\n                return -1\\n\\n        # When target word is in the words list.\\n\\n        # Getting length of the list.\\n        l = len(words)\\n\\n        # Initializing a variable for minimum distance comparison.\\n        a = len(words) - 1\\n\\n        # Iterating into list using enumerate for index.\\n        for i, word in enumerate(words):\\n\\n            # When target is found.\\n            if word == target:\\n\\n                # Checking if index value is smaller than startIndex.\\n                if i < startIndex:\\n\\n                    # Getting first distance, by subtracting index from startIndex. [Going to the left]\\n                    # Getting second distance, by subtracting startIndex from l & adding index. [Going to the right]\\n                    # Getting the minimum value between the 2.\\n                    b = min(startIndex - i, i + (l - startIndex))\\n\\n                # Checking if index value is greater than startIndex.\\n                else:\\n\\n                    # Getting first distance, by subtracting startIndex from index. [Going to the left]\\n                    # Getting second distance, by subtracting i from l & adding startIndex. [Going to the right]\\n                    # Getting the minimum value between the 2.\\n                    b = min(i - startIndex, startIndex + l - i)\\n\\n                # Putting the minimum value into a.\\n                a = min(a, b)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :type startIndex: int\\n        :rtype: int\\n        \"\"\"\\n\\n        # When target word is not present in the words list.\\n        if target not in words:\\n                return -1\\n\\n        # When target word is in the words list.\\n\\n        # Getting length of the list.\\n        l = len(words)\\n\\n        # Initializing a variable for minimum distance comparison.\\n        a = len(words) - 1\\n\\n        # Iterating into list using enumerate for index.\\n        for i, word in enumerate(words):\\n\\n            # When target is found.\\n            if word == target:\\n\\n                # Checking if index value is smaller than startIndex.\\n                if i < startIndex:\\n\\n                    # Getting first distance, by subtracting index from startIndex. [Going to the left]\\n                    # Getting second distance, by subtracting startIndex from l & adding index. [Going to the right]\\n                    # Getting the minimum value between the 2.\\n                    b = min(startIndex - i, i + (l - startIndex))\\n\\n                # Checking if index value is greater than startIndex.\\n                else:\\n\\n                    # Getting first distance, by subtracting startIndex from index. [Going to the left]\\n                    # Getting second distance, by subtracting i from l & adding startIndex. [Going to the right]\\n                    # Getting the minimum value between the 2.\\n                    b = min(i - startIndex, startIndex + l - i)\\n\\n                # Putting the minimum value into a.\\n                a = min(a, b)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402729,
                "title": "simple-and-easy-c-solution",
                "content": "# Intuition\\nWe need to iterate the given array in both the directions completely.\\n\\n# Approach\\niterating the given array in both the directions and then finding the minimum of the steps required to reach the target.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        bool got=false;\\n        int ans=INT_MAX;\\n        if(words[startIndex]==target){\\n            return 0;\\n        }\\n        int currIndex=startIndex+1;\\n        if(currIndex==words.size()){\\n            currIndex=0;\\n        }\\n        int steps=1;\\n        while(currIndex!=startIndex){\\n            if(words[currIndex]==target){\\n                got=true;\\n                break;\\n            }\\n            steps++;\\n            currIndex=(currIndex+1)%words.size();\\n        }\\n        if(got==true){\\n            ans=min(ans,steps);\\n        }\\n        steps=1;got=false;\\n        currIndex=startIndex-1;\\n        if(currIndex<0){\\n            currIndex=words.size()-1;\\n        }\\n        while(currIndex!=startIndex){\\n            if(words[currIndex]==target){\\n                got=true;\\n                break;\\n            }\\n            steps++;\\n            currIndex=(currIndex-1+words.size())%words.size();\\n        }\\n        if(got==true){\\n            ans=min(ans,steps);\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        bool got=false;\\n        int ans=INT_MAX;\\n        if(words[startIndex]==target){\\n            return 0;\\n        }\\n        int currIndex=startIndex+1;\\n        if(currIndex==words.size()){\\n            currIndex=0;\\n        }\\n        int steps=1;\\n        while(currIndex!=startIndex){\\n            if(words[currIndex]==target){\\n                got=true;\\n                break;\\n            }\\n            steps++;\\n            currIndex=(currIndex+1)%words.size();\\n        }\\n        if(got==true){\\n            ans=min(ans,steps);\\n        }\\n        steps=1;got=false;\\n        currIndex=startIndex-1;\\n        if(currIndex<0){\\n            currIndex=words.size()-1;\\n        }\\n        while(currIndex!=startIndex){\\n            if(words[currIndex]==target){\\n                got=true;\\n                break;\\n            }\\n            steps++;\\n            currIndex=(currIndex-1+words.size())%words.size();\\n        }\\n        if(got==true){\\n            ans=min(ans,steps);\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388093,
                "title": "python-don-t-go-in-circles-many-times-the-fastest-math-solution-4-rows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach time one of the paths is shorter than other (except for the opposite point on the circle). Thus, it\\'s redundant to check the both. Also, after you find the nearest target, you don\\'t need to go further.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust find the minimum distance to the target from the left or the right.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$: One path for each point on the circle.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$: Constant space is required.\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        n = len(words)\\n        for step in range(n // 2 + 1):\\n                if (words[(startIndex + step) % n] == target or \\n                    words[(startIndex + n - step) % n] == target):\\n                    return step\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        n = len(words)\\n        for step in range(n // 2 + 1):\\n                if (words[(startIndex + step) % n] == target or \\n                    words[(startIndex + n - step) % n] == target):\\n                    return step\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387574,
                "title": "simple-python-solution-beats-91-45",
                "content": "# Approach\\nReally simple logic: the first loop will check how many moves it will take to reach the target on the right, and the second loop will check how many moves it will take to reach the target on the left. Finally, we will return the minimum value.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:return -1\\n        if words[startIndex]==target:return 0\\n        n=len(words)\\n        l,r=startIndex,startIndex\\n        left,right=1,1\\n        while words[(r+1)%n]!=target:\\n            right+=1\\n            r+=1\\n        while words[(l - 1 + n) % n]!=target:\\n            left+=1\\n            l-=1\\n        return min(right,left)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if target not in words:return -1\\n        if words[startIndex]==target:return 0\\n        n=len(words)\\n        l,r=startIndex,startIndex\\n        left,right=1,1\\n        while words[(r+1)%n]!=target:\\n            right+=1\\n            r+=1\\n        while words[(l - 1 + n) % n]!=target:\\n            left+=1\\n            l-=1\\n        return min(right,left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385545,
                "title": "shortest-distance-to-target-string-in-a-circular-array",
                "content": "-------------- Easy C++ Solution ----------------\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n         const int n = words.size();\\n\\n    for (int i = 0; i < n; ++i) {\\n      if (words[(startIndex + i + n) % n] == target)\\n        return i;\\n      if (words[(startIndex - i + n) % n] == target)\\n        return i;\\n    }\\n    return -1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        \\n         const int n = words.size();\\n\\n    for (int i = 0; i < n; ++i) {\\n      if (words[(startIndex + i + n) % n] == target)\\n        return i;\\n      if (words[(startIndex - i + n) % n] == target)\\n        return i;\\n    }\\n    return -1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382172,
                "title": "ai-solution",
                "content": "# Intuition\\nNothing new, tried to use ChatGPT\\n\\n# Approach\\nCopy pasted the problem in ChatGPT\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is O(n), where n is the length of the words list. This is because in the worst case, we need to iterate over all n elements of the list to find the target word.\\n\\n- Space complexity:\\nThe space complexity of the code is O(1), because we only use a constant amount of additional space to store the variables n, i, startIndex, and target. We don\\'t use any additional data structures or allocate any memory dynamically, so the space used by the program does not depend on the size of the input.\\n\\n- Note:\\nNote that the space complexity does not include the space used by the input words, target, and startIndex, since these are part of the input and not created by the function.\\n\\n*THIS DATA IS ALSO FROM CHATGPT*\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n = len(words)\\n        for i in range(n):\\n            if words[(startIndex + i) % n] == target or words[(startIndex - i) % n] == target:\\n                return i\\n        return -1\\n\\n```\\n\\nRuntime51 ms Beats 77.40%\\nMemory14 MB Beats 49.64%",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        n = len(words)\\n        for i in range(n):\\n            if words[(startIndex + i) % n] == target or words[(startIndex - i) % n] == target:\\n                return i\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378018,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int i = startIndex;\\n        int j = startIndex;\\n        int length = words.length;\\n        int count =0;\\n        while(count<length){\\n            if(words[i].equals(target) || words[j].equals(target)){\\n                return count;\\n            }\\n            if(i == length-1){\\n                i = 0;\\n            }\\n            else{\\n                i++;\\n            }\\n            if(j == 0){\\n                j = length-1;\\n            }\\n            else{\\n                j--;\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int i = startIndex;\\n        int j = startIndex;\\n        int length = words.length;\\n        int count =0;\\n        while(count<length){\\n            if(words[i].equals(target) || words[j].equals(target)){\\n                return count;\\n            }\\n            if(i == length-1){\\n                i = 0;\\n            }\\n            else{\\n                i++;\\n            }\\n            if(j == 0){\\n                j = length-1;\\n            }\\n            else{\\n                j--;\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375740,
                "title": "c-easy-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int minn = INT_MAX;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i] == target) {\\n                int first = abs(i - startIndex);\\n                int second;\\n                if(i > startIndex) second = words.size() - i + startIndex;\\n                else second = words.size() - startIndex + i;\\n                minn = min(minn,min(first,abs(second)));\\n            }\\n        }\\n        return minn==INT_MAX ? -1 : minn;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int minn = INT_MAX;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i] == target) {\\n                int first = abs(i - startIndex);\\n                int second;\\n                if(i > startIndex) second = words.size() - i + startIndex;\\n                else second = words.size() - startIndex + i;\\n                minn = min(minn,min(first,abs(second)));\\n            }\\n        }\\n        return minn==INT_MAX ? -1 : minn;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375506,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        inds = [] \\n\\n        for i, w in enumerate(words):\\n            if w == target:\\n                inds.append(i) \\n\\n        if len(inds) == 0 : return -1 \\n\\n        min_ = abs(inds[0] - startIndex)\\n        for i in inds:\\n            min_ = min(min_,min(abs(i-startIndex),abs(len(words)-abs(i-startIndex))))\\n        return min_\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        inds = [] \\n\\n        for i, w in enumerate(words):\\n            if w == target:\\n                inds.append(i) \\n\\n        if len(inds) == 0 : return -1 \\n\\n        min_ = abs(inds[0] - startIndex)\\n        for i in inds:\\n            min_ = min(min_,min(abs(i-startIndex),abs(len(words)-abs(i-startIndex))))\\n        return min_\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372613,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int result = Integer.MAX_VALUE;\\n        int n = words.length;\\n        \\n        for (int i = startIndex; i<n+startIndex; i++)\\n        {\\n            if (words[i%n].equals(target))\\n            {\\n                int min = Math.min(i-startIndex, n-i+startIndex);\\n                result = Math.min(min, result);\\n            }\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int result = Integer.MAX_VALUE;\\n        int n = words.length;\\n        \\n        for (int i = startIndex; i<n+startIndex; i++)\\n        {\\n            if (words[i%n].equals(target))\\n            {\\n                int min = Math.min(i-startIndex, n-i+startIndex);\\n                result = Math.min(min, result);\\n            }\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367655,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function (words, target, startIndex) {\\n    if (!words.includes(target)) return -1\\n    let result = -1\\n    for (let i = startIndex; ; i++) {\\n        const index = i % words.length\\n        const el = words[index]\\n        result++\\n        if (el === target) break\\n    }\\n    let tempResult = -1\\n    for (let i = startIndex; ; i--) {\\n        const index = (words.length + i) % words.length\\n        const el = words[index]\\n        tempResult++\\n        if (el === target) break\\n    }\\n    return result >= tempResult ? tempResult : result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function (words, target, startIndex) {\\n    if (!words.includes(target)) return -1\\n    let result = -1\\n    for (let i = startIndex; ; i++) {\\n        const index = i % words.length\\n        const el = words[index]\\n        result++\\n        if (el === target) break\\n    }\\n    let tempResult = -1\\n    for (let i = startIndex; ; i--) {\\n        const index = (words.length + i) % words.length\\n        const el = words[index]\\n        tempResult++\\n        if (el === target) break\\n    }\\n    return result >= tempResult ? tempResult : result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359711,
                "title": "java-simple-using-program-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] s, String target, int start) {\\n        ArrayList<Integer> as=new ArrayList<>();\\n      for(int i=0;i<s.length;i++){\\n          if(s[i].equals(target))\\n          as.add(i);\\n      }\\n      int min=Integer.MAX_VALUE,a1=0,a2=0,ans=0;\\n      for(int k:as){\\n          a1=Math.abs(k-start);\\n          a2=(s.length-a1);\\n          ans=(a1<a2)?a1:a2;\\n          min=Math.min(ans,min);\\n          System.out.println(a1+\" \"+a2+\" \"+ans+\" \"+min);\\n      }\\n      return (as.size()==0)?-1:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] s, String target, int start) {\\n        ArrayList<Integer> as=new ArrayList<>();\\n      for(int i=0;i<s.length;i++){\\n          if(s[i].equals(target))\\n          as.add(i);\\n      }\\n      int min=Integer.MAX_VALUE,a1=0,a2=0,ans=0;\\n      for(int k:as){\\n          a1=Math.abs(k-start);\\n          a2=(s.length-a1);\\n          ans=(a1<a2)?a1:a2;\\n          min=Math.min(ans,min);\\n          System.out.println(a1+\" \"+a2+\" \"+ans+\" \"+min);\\n      }\\n      return (as.size()==0)?-1:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351245,
                "title": "time-complexity-o-n-and-constant-space-cpp-fast-easy",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size(); //size of given array\\n        if(words[startIndex] == target) return 0;\\n\\n        int ans = 1;\\n        int i = (startIndex+1)%n; //to move right\\n        int j = (startIndex-1+n)%n; //to move left\\n\\n        while(i != startIndex && j != startIndex){\\n            if(words[i] == target || words[j] == target) break;\\n            ans++;\\n            i = (i+1)%n;\\n            j = (j-1+n)%n;\\n        }\\n        //if no target found in words array\\n        //then this while loop run through the whole array and ans will be eqaul to size of words\\n        return ans == n ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int n = words.size(); //size of given array\\n        if(words[startIndex] == target) return 0;\\n\\n        int ans = 1;\\n        int i = (startIndex+1)%n; //to move right\\n        int j = (startIndex-1+n)%n; //to move left\\n\\n        while(i != startIndex && j != startIndex){\\n            if(words[i] == target || words[j] == target) break;\\n            ans++;\\n            i = (i+1)%n;\\n            j = (j-1+n)%n;\\n        }\\n        //if no target found in words array\\n        //then this while loop run through the whole array and ans will be eqaul to size of words\\n        return ans == n ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345501,
                "title": "worst-approach-ever-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] a, String t, int s) {\\n        int left=s-1;\\n        int c1=0;\\n        int right=s+1;\\n        int c2=0;\\n        if(a[s].equals(t)){\\n            return 0;\\n        }\\n        while(left!=s || !a[left].equals(t)){\\n            if(left==-1){\\n                left=a.length-1;\\n                continue;\\n            }\\n            if(a[left].equals(t)){\\n                c1++;\\n                break;\\n            }\\n            c1++;\\n            if(left==s){\\n                c1=-1;\\n                break;\\n            }\\n            left--;\\n        }\\n        while(right!=s || !a[right].equals(t)){\\n            if(right==a.length){\\n                right=0;\\n                continue;\\n            }\\n            if(a[right].equals(t)){\\n                c2++;\\n                break;\\n            }\\n            c2++;\\n            if(right==s){\\n                c2=-1;\\n                break;\\n            }\\n            right++;\\n        }\\n        System.out.printf(\"Left : %d\\\\n Right : %d\",c1,c2);\\n        return Math.min(c1,c2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] a, String t, int s) {\\n        int left=s-1;\\n        int c1=0;\\n        int right=s+1;\\n        int c2=0;\\n        if(a[s].equals(t)){\\n            return 0;\\n        }\\n        while(left!=s || !a[left].equals(t)){\\n            if(left==-1){\\n                left=a.length-1;\\n                continue;\\n            }\\n            if(a[left].equals(t)){\\n                c1++;\\n                break;\\n            }\\n            c1++;\\n            if(left==s){\\n                c1=-1;\\n                break;\\n            }\\n            left--;\\n        }\\n        while(right!=s || !a[right].equals(t)){\\n            if(right==a.length){\\n                right=0;\\n                continue;\\n            }\\n            if(a[right].equals(t)){\\n                c2++;\\n                break;\\n            }\\n            c2++;\\n            if(right==s){\\n                c2=-1;\\n                break;\\n            }\\n            right++;\\n        }\\n        System.out.printf(\"Left : %d\\\\n Right : %d\",c1,c2);\\n        return Math.min(c1,c2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343048,
                "title": "javascript-one-pass",
                "content": "1. when a target word is found - find abs distance\\n2. if it\\'s less than half or equal of the whole arr then take an abs distance.\\n3. if it\\'s bigger then take both points and find the distance to the nearest edges.\\n4. compare with exist `minDistance`\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction closetTarget(words: string[], target: string, startIndex: number): number {\\n    let minDistance = Number.MAX_SAFE_INTEGER;\\n\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === target) {\\n            const n = words.length - 1;\\n            const absDiff = Math.abs(i - startIndex);\\n            let diff = absDiff > n / 2\\n                ? n + 1 - absDiff\\n                : absDiff;\\n\\n            if (diff < minDistance) {\\n                minDistance = diff;\\n            }\\n        }\\n    }\\n\\n    return minDistance === Number.MAX_SAFE_INTEGER ? -1 : minDistance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction closetTarget(words: string[], target: string, startIndex: number): number {\\n    let minDistance = Number.MAX_SAFE_INTEGER;\\n\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === target) {\\n            const n = words.length - 1;\\n            const absDiff = Math.abs(i - startIndex);\\n            let diff = absDiff > n / 2\\n                ? n + 1 - absDiff\\n                : absDiff;\\n\\n            if (diff < minDistance) {\\n                minDistance = diff;\\n            }\\n        }\\n    }\\n\\n    return minDistance === Number.MAX_SAFE_INTEGER ? -1 : minDistance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341688,
                "title": "python-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        if target not in words:\\n            return (-1)\\n        return(min([abs(i-startIndex) for i in [i for i in range(len(words)) if words[i] ==target]]+[(len(words)+startIndex)-i for i in [i for i in range(len(words)) if words[i] ==target]]+[(i+len(words))-startIndex for i in [i for i in range(len(words)) if words[i] ==target]]))\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def closetTarget(self, words, target, startIndex):\\n        if target not in words:\\n            return (-1)\\n        return(min([abs(i-startIndex) for i in [i for i in range(len(words)) if words[i] ==target]]+[(len(words)+startIndex)-i for i in [i for i in range(len(words)) if words[i] ==target]]+[(i+len(words))-startIndex for i in [i for i in range(len(words)) if words[i] ==target]]))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323606,
                "title": "c",
                "content": "```C []\\nint closetTarget(\\n\\tconst char * const * const words,\\n\\tconst int wordsLen,\\n\\tconst char * const target,\\n\\tconst int startIndex\\n){\\n\\tif ( 0 == strcmp(words[startIndex], target) ){\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor (int i = 1; i <= wordsLen / 2; i += 1){\\n\\t\\tif (\\n\\t\\t\\t0 == strcmp(words[(startIndex + i) % wordsLen], target) ||\\n\\t\\t\\t0 == strcmp(words[(startIndex - i + wordsLen) % wordsLen], target)\\n\\t\\t){\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nint closetTarget(\\n\\tconst char * const * const words,\\n\\tconst int wordsLen,\\n\\tconst char * const target,\\n\\tconst int startIndex\\n){\\n\\tif ( 0 == strcmp(words[startIndex], target) ){\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor (int i = 1; i <= wordsLen / 2; i += 1){\\n\\t\\tif (\\n\\t\\t\\t0 == strcmp(words[(startIndex + i) % wordsLen], target) ||\\n\\t\\t\\t0 == strcmp(words[(startIndex - i + wordsLen) % wordsLen], target)\\n\\t\\t){\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3313316,
                "title": "python-single-loop-solution",
                "content": "```\\n# https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if not target in words:\\n            return -1\\n        \\n        res = []\\n        if words[startIndex] == target:\\n            res.append(0)\\n        n = len(words)\\n        i = (startIndex + 1) % n\\n        j = (startIndex - 1 + n) % n\\n        step = 1\\n        \\n        while step <= n:\\n            if words[i] == target or words[j] == target:\\n                res.append(step)\\n            step += 1\\n            i = (i + 1) % n\\n            j = (j - 1 + n) % n\\n        \\n        return min(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        if not target in words:\\n            return -1\\n        \\n        res = []\\n        if words[startIndex] == target:\\n            res.append(0)\\n        n = len(words)\\n        i = (startIndex + 1) % n\\n        j = (startIndex - 1 + n) % n\\n        step = 1\\n        \\n        while step <= n:\\n            if words[i] == target or words[j] == target:\\n                res.append(step)\\n            step += 1\\n            i = (i + 1) % n\\n            j = (j - 1 + n) % n\\n        \\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313243,
                "title": "easy-to-understand-solution",
                "content": "\\n    \\tint closetTarget(vector<string>& words, string target, int sI) {\\n      \\n        int n=words.size();\\n        int ans=n+1;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           if(words[i]==target)\\n           {\\n               ans=min(ans,min(n+sI-i,min(abs(sI-i),i+n-sI)));\\n           }\\n        }\\n        return ans==n+1?-1:ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    \\tint closetTarget(vector<string>& words, string target, int sI) {\\n      \\n        int n=words.size();\\n        int ans=n+1;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           if(words[i]==target)\\n           {\\n               ans=min(ans,min(n+sI-i,min(abs(sI-i),i+n-sI)));\\n           }\\n        }\\n        return ans==n+1?-1:ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3307634,
                "title": "easy-but-complicated-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        ans = len(words)\\n        if target not in words:\\n            return -1\\n        \\n        for i , k in enumerate(words):\\n            if k == target:\\n                right = abs(startIndex - i)\\n                left = abs(len(words)-i+startIndex)\\n                middle = abs(len(words)+i-startIndex)\\n                ans = min(ans , right , left , middle)\\n        return ans \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n        ans = len(words)\\n        if target not in words:\\n            return -1\\n        \\n        for i , k in enumerate(words):\\n            if k == target:\\n                right = abs(startIndex - i)\\n                left = abs(len(words)-i+startIndex)\\n                middle = abs(len(words)+i-startIndex)\\n                ans = min(ans , right , left , middle)\\n        return ans \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302694,
                "title": "java-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int temp = 0;\\n        int temp2 = 0;\\n        boolean check = false;\\n         for(int i=0 ; i<words.length ; i++){\\n            if(words[i].equals(target)){\\n                check = true;  break;\\n            }\\n        }\\n        if(check == false) return -1;\\n    \\n        for(int i=startIndex-1 ; true ; i++){\\n            if(words[(i +1 + n) % n].equals(target)){\\n                break;\\n            }\\n            else{\\n                temp += 1;\\n            }\\n        }\\n        \\n        for(int i = startIndex+1  ; true ;  i--){  \\n            if(words[(i - 1 + n) % n].equals(target)){\\n                break;\\n            }\\n            else{\\n                temp2 += 1;\\n            }\\n        } \\n        return Math.min(temp , temp2);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int temp = 0;\\n        int temp2 = 0;\\n        boolean check = false;\\n         for(int i=0 ; i<words.length ; i++){\\n            if(words[i].equals(target)){\\n                check = true;  break;\\n            }\\n        }\\n        if(check == false) return -1;\\n    \\n        for(int i=startIndex-1 ; true ; i++){\\n            if(words[(i +1 + n) % n].equals(target)){\\n                break;\\n            }\\n            else{\\n                temp += 1;\\n            }\\n        }\\n        \\n        for(int i = startIndex+1  ; true ;  i--){  \\n            if(words[(i - 1 + n) % n].equals(target)){\\n                break;\\n            }\\n            else{\\n                temp2 += 1;\\n            }\\n        } \\n        return Math.min(temp , temp2);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300889,
                "title": "javascript-logic-2-pointers",
                "content": "# Code\\n```\\n// O(log n)\\nvar closetTarget = function(words, target, startIndex) {\\n    const n = words.length;\\n    let i = startIndex;\\n    let j = startIndex;\\n    let cnt = 0;\\n    while (true) {\\n        if (words[i] === target || words[j] === target) return cnt;\\n        i++;\\n        if (i === n) i = 0;\\n        j--;\\n        if (j < 0) j = n - 1;\\n        cnt++;\\n        if (i === startIndex || j === startIndex) return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(log n)\\nvar closetTarget = function(words, target, startIndex) {\\n    const n = words.length;\\n    let i = startIndex;\\n    let j = startIndex;\\n    let cnt = 0;\\n    while (true) {\\n        if (words[i] === target || words[j] === target) return cnt;\\n        i++;\\n        if (i === n) i = 0;\\n        j--;\\n        if (j < 0) j = n - 1;\\n        cnt++;\\n        if (i === startIndex || j === startIndex) return -1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3299538,
                "title": "step-by-step-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove forward and backward while recording number of jumps taken in both direction.\\n\\nIf the ith word matches the target then store the minimum jumps taken in the variable\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        // Initialize required variables\\n        // jumps will store minimum jumps taken to reach the target\\n        // jumps_back stores jumps taken in backward direction\\n        // jumps_forward stores jumps taken in forward direction\\n        int n = words.size(), jumps = -1, jumps_back = 1, jumps_forward = 1;\\n\\n        // If target matches at the startIndex then return 0\\n        if(words[startIndex] == target)\\n            return 0;\\n\\n        // Declare variables to get previous and next index values\\n        int prev_index = startIndex-1, next_index = startIndex+1;\\n\\n        // Move in forward and backward direction of the vector\\n        while(prev_index != startIndex && next_index != startIndex){\\n            // Constrain the prev_index within the scope\\n            if(prev_index < 0)\\n                prev_index = n-1;\\n\\n            // Constrain the next_index withinthe scope\\n            if(next_index > n-1)\\n                next_index = 0;\\n\\n            // Calculate jumps if the index matches the target\\n            if(words[prev_index] == target){\\n                if(jumps == -1)\\n                    jumps = jumps_back;\\n\\n                if(jumps_back <= jumps)\\n                    jumps = jumps_back;\\n            }\\n\\n            if(words[next_index] == target){\\n                if(jumps == -1)\\n                    jumps = jumps_forward;\\n                    \\n                if(jumps_forward <= jumps)\\n                    jumps = jumps_forward;\\n            }\\n            \\n            // Increment the prev_index and backward jumps\\n            if(prev_index != startIndex){\\n                prev_index--;\\n                jumps_back++;\\n            }\\n\\n            // Increment the next_index and forward jumps\\n            if(next_index != startIndex){\\n                next_index++;\\n                jumps_forward++;\\n            }\\n            \\n        }   \\n\\n        return jumps;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        // Initialize required variables\\n        // jumps will store minimum jumps taken to reach the target\\n        // jumps_back stores jumps taken in backward direction\\n        // jumps_forward stores jumps taken in forward direction\\n        int n = words.size(), jumps = -1, jumps_back = 1, jumps_forward = 1;\\n\\n        // If target matches at the startIndex then return 0\\n        if(words[startIndex] == target)\\n            return 0;\\n\\n        // Declare variables to get previous and next index values\\n        int prev_index = startIndex-1, next_index = startIndex+1;\\n\\n        // Move in forward and backward direction of the vector\\n        while(prev_index != startIndex && next_index != startIndex){\\n            // Constrain the prev_index within the scope\\n            if(prev_index < 0)\\n                prev_index = n-1;\\n\\n            // Constrain the next_index withinthe scope\\n            if(next_index > n-1)\\n                next_index = 0;\\n\\n            // Calculate jumps if the index matches the target\\n            if(words[prev_index] == target){\\n                if(jumps == -1)\\n                    jumps = jumps_back;\\n\\n                if(jumps_back <= jumps)\\n                    jumps = jumps_back;\\n            }\\n\\n            if(words[next_index] == target){\\n                if(jumps == -1)\\n                    jumps = jumps_forward;\\n                    \\n                if(jumps_forward <= jumps)\\n                    jumps = jumps_forward;\\n            }\\n            \\n            // Increment the prev_index and backward jumps\\n            if(prev_index != startIndex){\\n                prev_index--;\\n                jumps_back++;\\n            }\\n\\n            // Increment the next_index and forward jumps\\n            if(next_index != startIndex){\\n                next_index++;\\n                jumps_forward++;\\n            }\\n            \\n        }   \\n\\n        return jumps;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289796,
                "title": "rust-as-simple-as-it-gets",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn closet_target(words: Vec<String>, target: String, start_index: i32) -> i32 {\\n        let start_index = start_index as usize;\\n        let len = words.len();\\n        for i in 0..len {\\n            if words[(start_index + i) % len] == target || words[(len + start_index - i) % len] == target {\\n                return i as i32;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn closet_target(words: Vec<String>, target: String, start_index: i32) -> i32 {\\n        let start_index = start_index as usize;\\n        let len = words.len();\\n        for i in 0..len {\\n            if words[(start_index + i) % len] == target || words[(len + start_index - i) % len] == target {\\n                return i as i32;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3283944,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>&arr, string target, int ind)   \\n    {\\n        \\n\\n   int mini=arr.size();\\n   int n=arr.size();\\n     for(int i=0;i<arr.size();i++)\\n     {\\n         \\n         if(arr[i]==target)\\n         {\\n                mini=min(mini,min(abs(ind-i),abs(n-abs(ind-i))));\\n            \\n          }\\n     }\\n    if(mini==arr.size())mini=-1;\\n      return mini;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>&arr, string target, int ind)   \\n    {\\n        \\n\\n   int mini=arr.size();\\n   int n=arr.size();\\n     for(int i=0;i<arr.size();i++)\\n     {\\n         \\n         if(arr[i]==target)\\n         {\\n                mini=min(mini,min(abs(ind-i),abs(n-abs(ind-i))));\\n            \\n          }\\n     }\\n    if(mini==arr.size())mini=-1;\\n      return mini;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275087,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<string>circularWords(words.begin(), words.end());\\n        int rightDistance = 0;\\n        int leftDistance = 0;\\n        bool find = false;\\n\\n        for(int i=0; i<words.size(); i++){\\n            circularWords.push_back(words[i]);\\n        }\\n\\n        for(int i=startIndex; i< circularWords.size(); i++){\\n            if(circularWords[i] == target){\\n                find = true;\\n                break;\\n            }\\n            rightDistance++;\\n        }\\n        for(int i=words.size()+startIndex; i>= 0; i--){\\n            if(circularWords[i] == target){\\n                find = true;\\n                break;\\n            }\\n            leftDistance++;\\n        }\\n\\n        if(!find){\\n            return -1;\\n        }else{\\n            return rightDistance < leftDistance ? rightDistance : leftDistance;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<string>circularWords(words.begin(), words.end());\\n        int rightDistance = 0;\\n        int leftDistance = 0;\\n        bool find = false;\\n\\n        for(int i=0; i<words.size(); i++){\\n            circularWords.push_back(words[i]);\\n        }\\n\\n        for(int i=startIndex; i< circularWords.size(); i++){\\n            if(circularWords[i] == target){\\n                find = true;\\n                break;\\n            }\\n            rightDistance++;\\n        }\\n        for(int i=words.size()+startIndex; i>= 0; i--){\\n            if(circularWords[i] == target){\\n                find = true;\\n                break;\\n            }\\n            leftDistance++;\\n        }\\n\\n        if(!find){\\n            return -1;\\n        }else{\\n            return rightDistance < leftDistance ? rightDistance : leftDistance;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273214,
                "title": "short-and-easy-to-understand-1-pass-solution",
                "content": "\\n# Approach\\n1) make two pointers, one will travel in backward direction from starting index and another will travel in forward direction.\\n2) use formula given in question to make pointers travel in backward and forward direction.\\n3) make a distance variable to measure distance which will increment on each step taken by both pointers.\\n4) the pointer which will find the target, will return the distance.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int st) {\\n        int n=words.size(),distance=1;\\n      if(words[st]==target)return 0;\\n\\n      int  i=(st-1+n)%n,j=(st+1)%n;;\\n      while(i!=st and j!=st){\\n        if(words[j]==target || words[i]==target){\\n              return distance;\\n        }\\n    \\n        j=(j+1)%n;\\n        i=(i-1+n)%n;\\n        distance++;\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int st) {\\n        int n=words.size(),distance=1;\\n      if(words[st]==target)return 0;\\n\\n      int  i=(st-1+n)%n,j=(st+1)%n;;\\n      while(i!=st and j!=st){\\n        if(words[j]==target || words[i]==target){\\n              return distance;\\n        }\\n    \\n        j=(j+1)%n;\\n        i=(i-1+n)%n;\\n        distance++;\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271743,
                "title": "java-solution-100-runtime",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < words.length; i++) {\\n            if(target.equals(words[i])) {\\n                res = Math.min(res, Math.abs(i - startIndex));\\n                if(i > startIndex) res = Math.min(res, startIndex + words.length - i);\\n                else res = Math.min(res, words.length - startIndex + i);\\n            }\\n        }\\n        if(res == Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < words.length; i++) {\\n            if(target.equals(words[i])) {\\n                res = Math.min(res, Math.abs(i - startIndex));\\n                if(i > startIndex) res = Math.min(res, startIndex + words.length - i);\\n                else res = Math.min(res, words.length - startIndex + i);\\n            }\\n        }\\n        if(res == Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264308,
                "title": "10-line-c-code-simplest-approach",
                "content": "# Intuition\\nSimplest & Shortest Approach to solve this problem.\\n\\n# Approach\\nFormula approach\\n\\n# Complexity\\n- Time complexity:\\n\\nBest Case Time complexity = O(1);\\nWorst Case Time complexity = O(N);\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n\\n        if(target == words[startIndex])\\n        {\\n            return 0;\\n        }\\n\\n        int i=1, n = words.size(); \\n        while(i<n){\\n            if(words[(startIndex-i+n)%n] == target)\\n            {\\n                return i;\\n            }\\n            if(words[(startIndex+i)%n] == target)\\n            {\\n                return i;\\n            }\\n            i++;\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n\\n        if(target == words[startIndex])\\n        {\\n            return 0;\\n        }\\n\\n        int i=1, n = words.size(); \\n        while(i<n){\\n            if(words[(startIndex-i+n)%n] == target)\\n            {\\n                return i;\\n            }\\n            if(words[(startIndex+i)%n] == target)\\n            {\\n                return i;\\n            }\\n            i++;\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253893,
                "title": "c-simple-iteration-easy-for-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int left = 0,right = 0, flag = 0;\\n        for(int i = 0; i < words.size() && !flag; i++)\\n                if (words[i] == target) flag = 1;\\n        if (!flag) return -1;\\n        int i =  startIndex;\\n        do{\\n            if (i == words.size()) i = 0;\\n            if (words[i] == target) break;\\n            left++;\\n        }while(startIndex != ++i);\\n        i = startIndex;\\n        do{\\n            if (i == -1) i = words.size()-1;\\n            if (words[i] == target) break;\\n            right++;\\n        }while(startIndex != --i);\\n        return (right < left) ? right : left;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int left = 0,right = 0, flag = 0;\\n        for(int i = 0; i < words.size() && !flag; i++)\\n                if (words[i] == target) flag = 1;\\n        if (!flag) return -1;\\n        int i =  startIndex;\\n        do{\\n            if (i == words.size()) i = 0;\\n            if (words[i] == target) break;\\n            left++;\\n        }while(startIndex != ++i);\\n        i = startIndex;\\n        do{\\n            if (i == -1) i = words.size()-1;\\n            if (words[i] == target) break;\\n            right++;\\n        }while(startIndex != --i);\\n        return (right < left) ? right : left;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243188,
                "title": "simple-o-n-solution-in-python",
                "content": "# Approach\\nWe start from startIndex and on each for-loop iteration we explore a new word that is \\'i\\' steps from the startIndex (starting with 0 as target can already be at startIndex). We will return i in case if 1 of the words is equal to target. If we fell out of the loop it means there\\'s no such word and we can return -1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\ndef closetTarget(self, words, target, startIndex):\\n    n = len(words)\\n    for i in range(len(words)):\\n        forward = (startIndex + i) % n\\n        back = (startIndex - i + n) % n\\n        if words[forward] == target or words[back] == target:\\n            return i\\n    return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef closetTarget(self, words, target, startIndex):\\n    n = len(words)\\n    for i in range(len(words)):\\n        forward = (startIndex + i) % n\\n        back = (startIndex - i + n) % n\\n        if words[forward] == target or words[back] == target:\\n            return i\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3232465,
                "title": "c-golang-1-pass",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans = INT_MAX;\\n        int n = words.size();\\n        for(int i = 0; i < n; i++) {\\n            if(words[i] == target)\\n                ans = min(min(abs(i - startIndex), min(n + i - startIndex, n - i + startIndex)), ans);\\n        }\\n        return ans == INT_MAX? -1: ans;\\n    }\\n};\\n\\n// Golang\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {return -a}\\n    return a\\n}\\n\\nfunc closetTarget(words []string, target string, startIndex int) int {\\n    var ans int = math.MaxInt\\n    var n int = len(words)\\n    for i := 0; i < n; i++ {\\n        if words[i] == target {\\n            ans = min(min(abs(i - startIndex), min(n + i - startIndex, n - i + startIndex)), ans)\\n        }\\n    }\\n    if ans == math.MaxInt {return -1}\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans = INT_MAX;\\n        int n = words.size();\\n        for(int i = 0; i < n; i++) {\\n            if(words[i] == target)\\n                ans = min(min(abs(i - startIndex), min(n + i - startIndex, n - i + startIndex)), ans);\\n        }\\n        return ans == INT_MAX? -1: ans;\\n    }\\n};\\n\\n// Golang\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {return -a}\\n    return a\\n}\\n\\nfunc closetTarget(words []string, target string, startIndex int) int {\\n    var ans int = math.MaxInt\\n    var n int = len(words)\\n    for i := 0; i < n; i++ {\\n        if words[i] == target {\\n            ans = min(min(abs(i - startIndex), min(n + i - startIndex, n - i + startIndex)), ans)\\n        }\\n    }\\n    if ans == math.MaxInt {return -1}\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228629,
                "title": "c-short-and-sweet-and-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans = INT_MAX;\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            if(words[i]==target){\\n                int chk=abs(i-startIndex);\\n                int cnt = 0;\\n                if(i>startIndex)\\n                    cnt = startIndex+n-i;\\n                else\\n                    cnt = i+n-startIndex;\\n                cnt = min(chk,cnt);\\n                ans = min(ans,cnt);\\n            }\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int ans = INT_MAX;\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            if(words[i]==target){\\n                int chk=abs(i-startIndex);\\n                int cnt = 0;\\n                if(i>startIndex)\\n                    cnt = startIndex+n-i;\\n                else\\n                    cnt = i+n-startIndex;\\n                cnt = min(chk,cnt);\\n                ans = min(ans,cnt);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3228542,
                "title": "java-simle-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if(words[startIndex].equals(target)) {\\n            return 0;\\n        }\\n        int[] i ={(startIndex - 1 + words.length)%words.length,-1};\\n        int[] j ={(startIndex + 1)%words.length,1};\\n        int min = Integer.MAX_VALUE;\\n        int decrement = startIndex;\\n        int current = startIndex;\\n        decrement--;\\n        startIndex++;\\n        while(i[0] != j[0]) {\\n            if(words[i[0]].equals(target)) {\\n                min = (int)Math.min(min,Math.abs(i[1]));\\n                return min;\\n            }\\n            if(words[j[0]].equals(target)) {\\n                 min = (int)Math.min(min,j[1]);\\n                 return min;\\n            }\\n            startIndex++;\\n            decrement--;\\n            i[0] = (decrement + words.length)%words.length;\\n            --i[1];\\n            j[0] = (startIndex)%words.length;\\n            ++j[1];\\n        }\\n        if(i[0] == j[0] && words[i[0]].equals(target)) {\\n            return j[1];\\n        }\\n        return min == Integer.MAX_VALUE?-1:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        if(words[startIndex].equals(target)) {\\n            return 0;\\n        }\\n        int[] i ={(startIndex - 1 + words.length)%words.length,-1};\\n        int[] j ={(startIndex + 1)%words.length,1};\\n        int min = Integer.MAX_VALUE;\\n        int decrement = startIndex;\\n        int current = startIndex;\\n        decrement--;\\n        startIndex++;\\n        while(i[0] != j[0]) {\\n            if(words[i[0]].equals(target)) {\\n                min = (int)Math.min(min,Math.abs(i[1]));\\n                return min;\\n            }\\n            if(words[j[0]].equals(target)) {\\n                 min = (int)Math.min(min,j[1]);\\n                 return min;\\n            }\\n            startIndex++;\\n            decrement--;\\n            i[0] = (decrement + words.length)%words.length;\\n            --i[1];\\n            j[0] = (startIndex)%words.length;\\n            ++j[1];\\n        }\\n        if(i[0] == j[0] && words[i[0]].equals(target)) {\\n            return j[1];\\n        }\\n        return min == Integer.MAX_VALUE?-1:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223896,
                "title": "very-strange-approach-o-o-c-detailed-explanation",
                "content": "# Intuition\\n![IMG_20230224_102501.jpg](https://assets.leetcode.com/users/images/184dc2d8-d1c9-49c2-b7b1-d85465e5ecae_1677214633.7385929.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1-> In first loop we are storing index of every target word present in words in vector-v.\\n2-> if no target element found it means v is null hence return -1;\\n3-> else do these 3 operations and at last return minimum element present in res.\\n\\n<!-- Describe your approach to solving the problem. -->\\n**This reminds me the Line--**\\n\\n## **DON\\'T TOUCH THE CODE IF IT WORKS LOL\\uD83D\\uDE05**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int>v,res;\\n        int size = words.size();\\n        for(int i=0; i<size; i++){\\n            if(words[i] == target) v.push_back(i);\\n        }\\n        if(v.size() == 0) return -1;\\n        for(auto i:v){\\n            res.push_back((size+startIndex-i));\\n            res.push_back(abs(size-startIndex+i));\\n            res.push_back(abs(startIndex-i));     \\n        } return *min_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        vector<int>v,res;\\n        int size = words.size();\\n        for(int i=0; i<size; i++){\\n            if(words[i] == target) v.push_back(i);\\n        }\\n        if(v.size() == 0) return -1;\\n        for(auto i:v){\\n            res.push_back((size+startIndex-i));\\n            res.push_back(abs(size-startIndex+i));\\n            res.push_back(abs(startIndex-i));     \\n        } return *min_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223637,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int s=startIndex;\\n        int r=0;\\n        int l=0;\\n        int n=words.size();\\n        while(words[s]!=target&&r<n){\\n            s=(s+1)%n;\\n            r++;\\n        }\\n        if(r>=n){\\n            return -1;\\n        }\\n        s=startIndex;\\n          while(words[s]!=target&&l<n){\\n            s=(s-1+n)%n;\\n            l++;\\n        }\\n        if(l>=n){\\n            return -1;\\n        }\\n        int ans=min(r,l);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n        int s=startIndex;\\n        int r=0;\\n        int l=0;\\n        int n=words.size();\\n        while(words[s]!=target&&r<n){\\n            s=(s+1)%n;\\n            r++;\\n        }\\n        if(r>=n){\\n            return -1;\\n        }\\n        s=startIndex;\\n          while(words[s]!=target&&l<n){\\n            s=(s-1+n)%n;\\n            l++;\\n        }\\n        if(l>=n){\\n            return -1;\\n        }\\n        int ans=min(r,l);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223153,
                "title": "simple-approach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int si = startIndex, count = 0, n = words.length, check = 0;\\n        while(check<n)\\n        {\\n            if((words[(si + check) % n].equals(target))|| (words[(si - check + n) % n].equals(target)))\\n                return count;\\n            else\\n            {\\n                count++;\\n                check++;\\n            }\\n\\n        }\\n        return -1;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int si = startIndex, count = 0, n = words.length, check = 0;\\n        while(check<n)\\n        {\\n            if((words[(si + check) % n].equals(target))|| (words[(si - check + n) % n].equals(target)))\\n                return count;\\n            else\\n            {\\n                count++;\\n                check++;\\n            }\\n\\n        }\\n        return -1;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217473,
                "title": "easy-javascript-solution-short-simple",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    if(!words.includes(target))return -1\\n    let n=words.length\\n    let l=0 ,r=0\\n    while(words[(startIndex + r) % n]!==target)r++\\n    while(words[(startIndex - l + n) % n]!==target)l++\\n    return Math.min(r,l)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @param {number} startIndex\\n * @return {number}\\n */\\nvar closetTarget = function(words, target, startIndex) {\\n    if(!words.includes(target))return -1\\n    let n=words.length\\n    let l=0 ,r=0\\n    while(words[(startIndex + r) % n]!==target)r++\\n    while(words[(startIndex - l + n) % n]!==target)l++\\n    return Math.min(r,l)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216158,
                "title": "java-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int d1=Integer.MAX_VALUE;\\n        int d2=Integer.MAX_VALUE;\\n        if(words[startIndex].equals(target)){\\n            return 0;\\n        }\\n        int ld =-1, rd =-1, ans = Integer.MAX_VALUE;\\n        for(int i=(startIndex+1)%n;i!=startIndex;i=(i+1)%n){\\n            if(words[i].equals(target)){\\n                ld = i>startIndex ? startIndex+(n-i): startIndex-i;\\n                rd = i>startIndex? i-startIndex: n-startIndex+i;\\n                ans = Math.min(ans, Math.min(ld,rd));\\n            }\\n        }\\n        if(ld == -1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int n = words.length;\\n        int d1=Integer.MAX_VALUE;\\n        int d2=Integer.MAX_VALUE;\\n        if(words[startIndex].equals(target)){\\n            return 0;\\n        }\\n        int ld =-1, rd =-1, ans = Integer.MAX_VALUE;\\n        for(int i=(startIndex+1)%n;i!=startIndex;i=(i+1)%n){\\n            if(words[i].equals(target)){\\n                ld = i>startIndex ? startIndex+(n-i): startIndex-i;\\n                rd = i>startIndex? i-startIndex: n-startIndex+i;\\n                ans = Math.min(ans, Math.min(ld,rd));\\n            }\\n        }\\n        if(ld == -1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1731546,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1727747,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1728950,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1962608,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1855994,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1808078,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1802353,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1775138,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1735802,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1728961,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1731546,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1727747,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1728950,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1962608,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1855994,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1808078,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1802353,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1775138,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1735802,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            },
            {
                "id": 1728961,
                "content": [
                    {
                        "username": "belinskyi",
                        "content": "Method name has a typo"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "ans=Math.min(ans,Math.min(diff,words.length-diff));\\n\\nWhy words.length - diff .......reason"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "[@pulkitrajpal](/pulkitrajpal) ok i got it .....thanks man\\n"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Because our array is circular and we want to check the diffs from both sides."
                    },
                    {
                        "username": "sachin_khapariye",
                        "content": "How i traverse till startindex -1"
                    },
                    {
                        "username": "Irving09",
                        "content": "Can't believe I was attempting to do binary search when we have to look at all words in array anyways lol"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It's redundant to check both paths to each target each time. If you don't want to do it this way, the easiest four-line (maybe even three) math solution is [here](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/solutions/3388093/python-don-t-go-in-circles-many-times-the-fastest-solution-4-rows/)."
                    },
                    {
                        "username": "sakshitmeshram",
                        "content": "can anyone tell me what\\'s an issue  with code\\n\\nclass Solution {\\n   public static int closetTarget(String[] words, String target, int startIndex) {\\n        int countOfLeft=0;\\n        for(int i=0;i<words.length;i++){\\n            if(target==words[i]){\\n                countOfLeft++;\\n            }\\n        }\\n        int countOfRight=0;\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i]==target){\\n                countOfRight++;\\n            }\\n        }\\n        if(countOfRight>countOfLeft){\\n            return countOfLeft;\\n        }\\n        else if(countOfRight<countOfLeft){\\n            return countOfRight;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Rosh_Spy",
                        "content": "use equals() method instead of == operator"
                    },
                    {
                        "username": "max77445",
                        "content": "I just attached words like words + words + words\\n\\nthen start search from words.length + startIndex\\nwhile(0 < i )  {\\n check target\\n}\\n\\nwhile(forward < words+words+words.len )  {\\n check target\\n}\\n\\nreturn min moving step.\\nAccepted.\\n346ms"
                    },
                    {
                        "username": "weknewit007",
                        "content": "can anyone find the error in my answer\\n//\\n public int closetTarget(String[] words, String target, int startIndex) {\\n         int left =0;\\n        int right =0;\\n        int i= startIndex;\\n        int count =0;\\n        while(count<words.length && words[i]!= target){\\n            i++;\\n            if(i==words.length) i=0;\\n            count++;\\n            right++;\\n        }\\n           i= startIndex;\\n        count =0;\\n         while(count<words.length && words[i]!= target){\\n            i--;\\n            if(i<0) i=words.length-1;\\n            count++;\\n            left++;\\n        }\\n\\n\\n       return Math.min(left,right);\\n        \\n    }"
                    },
                    {
                        "username": "tejas_j_shah",
                        "content": "For the 3rd use case, Math.min(left,right); will yeild Math.min(0,0) which is 0 or 3 instead of -1"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "For left traverse, You should decrease value by (i - 1 + n) % n;and for right, increase by i=(i + 1) % n; and answer should be min(((startIndex-left+n)%n),((right-startIndex+n)%n));"
                    },
                    {
                        "username": "Anuj08",
                        "content": "which topic  to understand this type of problems?"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I\\'ve implemented by using two pointers"
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "how will i find the shortest path"
                    }
                ]
            }
        ]
    }
]