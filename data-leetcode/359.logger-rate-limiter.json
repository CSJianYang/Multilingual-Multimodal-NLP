[
    {
        "title": "Spiral Matrix II",
        "question_content": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\nExample 2:\n\nInput: n = 1\nOutput: [[1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 20",
        "solutions": [
            {
                "id": 22282,
                "title": "4-9-lines-python-solutions",
                "content": "**Solution 1: *Build it inside-out*** - 44 ms, 5 lines\\n\\nStart with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row:\\n\\n        ||  =>  |9|  =>  |8|      |6 7|      |4 5|      |1 2 3|\\n                         |9|  =>  |9 8|  =>  |9 6|  =>  |8 9 4|\\n                                             |8 7|      |7 6 5|\\n\\nThe code:\\n\\n    def generateMatrix(self, n):\\n        A, lo = [], n*n+1\\n        while lo > 1:\\n            lo, hi = lo - len(A), lo\\n            A = [range(lo, hi)] + zip(*A[::-1])\\n        return A\\n\\nWhile this isn't O(n^2), it's actually quite fast, presumably due to me not doing much in Python but relying on `zip` and `range` and `+` being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page).\\n\\n---\\n\\n**Solution 2: *Ugly inside-out*** - 48 ms, 4 lines\\n\\nSame as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently.\\n\\n    def generateMatrix(self, n):\\n        A = [[n*n]]\\n        while A[0][0] > 1:\\n            A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n        return A * (n>0)\\n\\n---\\n\\n**Solution 3: *Walk the spiral*** - 52 ms, 9 lines\\n\\nInitialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero.\\n\\n    def generateMatrix(self, n):\\n        A = [[0] * n for _ in range(n)]\\n        i, j, di, dj = 0, 0, 0, 1\\n        for k in xrange(n*n):\\n            A[i][j] = k + 1\\n            if A[(i+di)%n][(j+dj)%n]:\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return A",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1: *Build it inside-out*** - 44 ms, 5 lines\\n\\nStart with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row:\\n\\n        ||  =>  |9|  =>  |8|      |6 7|      |4 5|      |1 2 3|\\n                         |9|  =>  |9 8|  =>  |9 6|  =>  |8 9 4|\\n                                             |8 7|      |7 6 5|\\n\\nThe code:\\n\\n    def generateMatrix(self, n):\\n        A, lo = [], n*n+1\\n        while lo > 1:\\n            lo, hi = lo - len(A), lo\\n            A = [range(lo, hi)] + zip(*A[::-1])\\n        return A\\n\\nWhile this isn't O(n^2), it's actually quite fast, presumably due to me not doing much in Python but relying on `zip` and `range` and `+` being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page).\\n\\n---\\n\\n**Solution 2: *Ugly inside-out*** - 48 ms, 4 lines\\n\\nSame as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently.\\n\\n    def generateMatrix(self, n):\\n        A = [[n*n]]\\n        while A[0][0] > 1:\\n            A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n        return A * (n>0)\\n\\n---\\n\\n**Solution 3: *Walk the spiral*** - 52 ms, 9 lines\\n\\nInitialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero.\\n\\n    def generateMatrix(self, n):\\n        A = [[0] * n for _ in range(n)]\\n        i, j, di, dj = 0, 0, 0, 1\\n        for k in xrange(n*n):\\n            A[i][j] = k + 1\\n            if A[(i+di)%n][(j+dj)%n]:\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return A",
                "codeTag": "Python3"
            },
            {
                "id": 22289,
                "title": "my-super-simple-solution-can-be-used-for-both-spiral-matrix-i-and-ii",
                "content": "This is my solution for Spiral Matrix I, [https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution][1]. If you can understand that, this one is a no brainer :)\\n\\nGuess what? I just made several lines of change (with comment \"//change\") from that and I have the following AC code:\\n\\n    public class Solution {\\n        public int[][] generateMatrix(int n) {\\n            // Declaration\\n            int[][] matrix = new int[n][n];\\n            \\n            // Edge Case\\n            if (n == 0) {\\n                return matrix;\\n            }\\n            \\n            // Normal Case\\n            int rowStart = 0;\\n            int rowEnd = n-1;\\n            int colStart = 0;\\n            int colEnd = n-1;\\n            int num = 1; //change\\n            \\n            while (rowStart <= rowEnd && colStart <= colEnd) {\\n                for (int i = colStart; i <= colEnd; i ++) {\\n                    matrix[rowStart][i] = num ++; //change\\n                }\\n                rowStart ++;\\n                \\n                for (int i = rowStart; i <= rowEnd; i ++) {\\n                    matrix[i][colEnd] = num ++; //change\\n                }\\n                colEnd --;\\n                \\n                for (int i = colEnd; i >= colStart; i --) {\\n                    if (rowStart <= rowEnd)\\n                        matrix[rowEnd][i] = num ++; //change\\n                }\\n                rowEnd --;\\n                \\n                for (int i = rowEnd; i >= rowStart; i --) {\\n                    if (colStart <= colEnd)\\n                        matrix[i][colStart] = num ++; //change\\n                }\\n                colStart ++;\\n            }\\n            \\n            return matrix;\\n        }\\n    }\\n\\nObviously, you could merge colStart and colEnd into rowStart and rowEnd because it is a square matrix. But this is easily extensible to matrices that are m*n.\\n\\nHope this helps :)\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[][] generateMatrix(int n) {\\n            // Declaration\\n            int[][] matrix = new int[n][n];\\n            \\n            // Edge Case\\n            if (n == 0) {\\n                return matrix;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963128,
                "title": "python-rotate-when-need-explained",
                "content": "Let us notice one clue property about our spiral matrix: first we need to go to the right and rotate clockwise 90 degrees, then we go down and again when we reached bottom, we rotate 90 degrees clockwise and so on. So, all we need to do is to rotate 90 degrees clockwise when we need:\\n1. When we reached border of our matrix\\n2. When we reached cell which is already filled.\\n\\nLet `x, y` be coordinates on our `grid` and `dx, dy` is current direction we need to move. In geometrical sense, rotate by `90` degrees clockwise is written as `dx, dy = -dy, dx`.\\n\\nNote, that `matrix[y][x]` is cell with coordinates `(x,y)`, which is not completely obvious.\\n\\n**Complexity**: time complexity is `O(n^2)`, we process each element once. Space complexity is `O(n^2)` as well.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = [[0] * n for _ in range(n)]\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(n*n):\\n            matrix[y][x] = i + 1\\n            if not 0 <= x + dx < n or not 0 <= y + dy < n or matrix[y+dy][x+dx] != 0:\\n                dx, dy = -dy, dx\\n            x, y = x + dx, y + dy\\n        return matrix\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = [[0] * n for _ in range(n)]\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(n*n):\\n            matrix[y][x] = i + 1\\n            if not 0 <= x + dx < n or not 0 <= y + dy < n or matrix[y+dy][x+dx] != 0:\\n                dx, dy = -dy, dx\\n            x, y = x + dx, y + dy\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22309,
                "title": "simple-c-solution-with-explaination",
                "content": "   \\n    class Solution {\\n        public:\\n            vector<vector<int> > generateMatrix(int n) {\\n                vector<vector<int> > ret( n, vector<int>(n) );\\n            \\tint k = 1, i = 0;\\n            \\twhile( k <= n * n )\\n            \\t{\\n            \\t\\tint j = i;\\n                        // four steps\\n            \\t\\twhile( j < n - i )             // 1. horizonal, left to right\\n            \\t\\t\\tret[i][j++] = k++;\\n            \\t\\tj = i + 1;\\n            \\t\\twhile( j < n - i )             // 2. vertical, top to bottom\\n            \\t\\t\\tret[j++][n-i-1] = k++;\\n            \\t\\tj = n - i - 2;\\n            \\t\\twhile( j > i )                  // 3. horizonal, right to left \\n            \\t\\t\\tret[n-i-1][j--] = k++;\\n            \\t\\tj = n - i - 1;\\n            \\t\\twhile( j > i )                  // 4. vertical, bottom to  top \\n            \\t\\t\\tret[j--][i] = k++;\\n            \\t\\ti++;      // next loop\\n            \\t}\\n            \\treturn ret;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<vector<int> > generateMatrix(int n) {\\n                vector<vector<int> > ret( n, vector<int>(n) );\\n            \\tint k = 1, i = 0;\\n            \\twhile( k <= n * n )\\n            \\t{\\n            \\t\\tint j = i;\\n                        // four steps\\n            \\t\\twhile( j < n - i )             // 1. horizonal, left to right\\n            \\t\\t\\tret[i][j++] = k++;\\n            \\t\\tj = i + 1;\\n            \\t\\twhile( j < n - i )             // 2. vertical, top to bottom\\n            \\t\\t\\tret[j++][n-i-1] = k++;\\n            \\t\\tj = n - i - 2;\\n            \\t\\twhile( j > i )                  // 3. horizonal, right to left \\n            \\t\\t\\tret[n-i-1][j--] = k++;\\n            \\t\\tj = n - i - 1;\\n            \\t\\twhile( j > i )                  // 4. vertical, bottom to  top \\n            \\t\\t\\tret[j--][i] = k++;\\n            \\t\\ti++;      // next loop\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1941068,
                "title": "c-0ms-100-easy-to-understand",
                "content": "# 59. Spiral Matrix II\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n* We **have to fill the matrix layer by layer in four direction**.\\n* From **left to right** \\u27A1\\uFE0F:\\n\\t*  the **row will remain constant** while **column is updated till reaches n-1**.\\n* From **Top to bottom** \\u2B07\\uFE0F(moving down)\\n\\t* The **column will remain constant as n-1** and **we will start filling from r1 + 1**, as first row is filled in previous step & row will be updated.\\n* From **right to left** \\u2B05\\uFE0F\\n\\t* we will **start filling from c2 - 1 because c2 is filled in previous step**.\\n\\t* so the **row will be fixed** and c2 will be updated from c2-1 till its greater than c1.\\n* From **botom to up** \\u2B06\\uFE0F (move up)\\n\\t* the **column will be fixed as c1** while row will be updated form r2 till it greater than r1.\\n* After that we will **updates the row and column pointers, as now we will have to fill the inner layers.**\\n\\n**ANALYSIS -:**\\n* TIME COMPLEXITY = **O(N^2)**\\n* SPACE COMPLEXITY = **O(1)**\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int r1 = 0, r2 = n-1;\\n        int c1 = 0, c2 = n-1;\\n        int val = 0;\\n\\t\\t\\n\\t\\t// result matrix\\n        vector<vector<int>> v(n, vector<int> (n));\\n        while(r1 <= r2 && c1 <= c2)\\n        {\\n            // left to right (row will be fixed)\\n            for(int i = c1; i <= c2; ++i)\\n                v[r1][i] = ++val;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move down(col will be fixed)\\n            for(int i = r1+1; i <= r2; ++i)\\n                v[i][c2] = ++val;\\n\\t\\t\\t\\t\\n            // move right to left\\n            // move  up\\n            if(r1 < r2 && c1 < c2)\\n            {\\n                // move right to left (row will be fixed)\\n                for(int i = c2-1; i>c1; --i)\\n                    v[r2][i] = ++val;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// move up (col will be fixed)\\n\\t\\t\\t\\t\\tfor(int i = r2; i>r1; --i) \\n                    v[i][c1] = ++val;\\n            }\\n            ++r1;\\n            --r2;\\n            ++c1;\\n            --c2;\\n        }\\n        return v;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int r1 = 0, r2 = n-1;\\n        int c1 = 0, c2 = n-1;\\n        int val = 0;\\n\\t\\t\\n\\t\\t// result matrix\\n        vector<vector<int>> v(n, vector<int> (n));\\n        while(r1 <= r2 && c1 <= c2)\\n        {\\n            // left to right (row will be fixed)\\n            for(int i = c1; i <= c2; ++i)\\n                v[r1][i] = ++val;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move down(col will be fixed)\\n            for(int i = r1+1; i <= r2; ++i)\\n                v[i][c2] = ++val;\\n\\t\\t\\t\\t\\n            // move right to left\\n            // move  up\\n            if(r1 < r2 && c1 < c2)\\n            {\\n                // move right to left (row will be fixed)\\n                for(int i = c2-1; i>c1; --i)\\n                    v[r2][i] = ++val;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// move up (col will be fixed)\\n\\t\\t\\t\\t\\tfor(int i = r2; i>r1; --i) \\n                    v[i][c1] = ++val;\\n            }\\n            ++r1;\\n            --r2;\\n            ++c1;\\n            --c2;\\n        }\\n        return v;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22290,
                "title": "python-easy-to-follow-solution",
                "content": "        \\n    def generateMatrix(self, n):\\n        if not n:\\n            return []\\n        res = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        left, right, top, down, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= down:\\n            for i in xrange(left, right+1):\\n                res[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in xrange(top, down+1):\\n                res[i][right] = num\\n                num += 1\\n            right -= 1\\n            for i in xrange(right, left-1, -1):\\n                res[down][i] = num\\n                num += 1\\n            down -= 1\\n            for i in xrange(down, top-1, -1):\\n                res[i][left] = num\\n                num += 1\\n            left += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def generateMatrix(self, n):\\n        if not n:\\n            return []\\n        res = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        left, right, top, down, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= down:\\n            for i in xrange(left, right+1):\\n                res[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in xrange(top, down+1):\\n                res[i][right] = num\\n                num += 1\\n            right -= 1\\n            for i in xrange(right, left-1, -1):\\n                res[down][i] = num\\n                num += 1\\n            down -= 1\\n            for i in xrange(down, top-1, -1):\\n                res[i][left] = num\\n                num += 1\\n            left += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 22292,
                "title": "share-my-java-solution",
                "content": "    public static int[][] generateMatrix(int n) {\\n\\t\\tint[][] ret = new int[n][n];\\n\\t\\tint left = 0,top = 0;\\n\\t\\tint right = n -1,down = n - 1;\\n\\t\\tint count = 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tfor (int j = left; j <= right; j ++) {\\n\\t\\t\\t\\tret[top][j] = count++;\\n\\t\\t\\t}\\n\\t\\t\\ttop ++;\\n\\t\\t\\tfor (int i = top; i <= down; i ++) {\\n\\t\\t\\t\\tret[i][right] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tright --;\\n\\t\\t\\tfor (int j = right; j >= left; j --) {\\n\\t\\t\\t\\tret[down][j] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tdown --;\\n\\t\\t\\tfor (int i = down; i >= top; i --) {\\n\\t\\t\\t\\tret[i][left] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tleft ++;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static int[][] generateMatrix(int n) {\\n\\t\\tint[][] ret = new int[n][n];\\n\\t\\tint left = 0,top = 0;\\n\\t\\tint right = n -1,down = n - 1;\\n\\t\\tint count = 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tfor (int j = left; j <= right; j ++) {\\n\\t\\t\\t\\tret[top][j] = count++;\\n\\t\\t\\t}\\n\\t\\t\\ttop ++;\\n\\t\\t\\tfor (int i = top; i <= down; i ++) {\\n\\t\\t\\t\\tret[i][right] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tright --;\\n\\t\\t\\tfor (int j = right; j >= left; j --) {\\n\\t\\t\\t\\tret[down][j] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tdown --;\\n\\t\\t\\tfor (int i = down; i >= top; i --) {\\n\\t\\t\\t\\tret[i][left] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tleft ++;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 22454,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > generateMatrix(int n) {\\n            vector<vector<int> > vv(n, vector<int>(n));\\n        \\n            int rowStart = 0, rowEnd = n - 1;\\n            int colStart = 0, colEnd = n - 1;\\n            int cnt = 1;\\n        \\n            while(rowStart <= rowEnd && colStart <= colEnd)\\n            {\\n                for(int i = colStart; i<= colEnd; i++)\\n                    vv[rowStart][i] = cnt++;\\n                rowStart++;\\n            \\n                for(int i = rowStart; i<= rowEnd; i++)\\n                    vv[i][colEnd] = cnt++;\\n                colEnd--;\\n            \\n                for(int i = colEnd; i>= colStart; i--)\\n                    vv[rowEnd][i] = cnt++;\\n                rowEnd--;\\n            \\n                for(int i = rowEnd; i>= rowStart; i--)\\n                    vv[i][colStart] = cnt++;\\n                colStart++;\\n            }\\n        \\n            return vv;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > generateMatrix(int n) {\\n            vector<vector<int> > vv(n, vector<int>(n));\\n        \\n            int rowStart = 0, rowEnd = n - 1;\\n            int colStart = 0, colEnd = n - 1;\\n            int cnt = 1;\\n        \\n            while(rowStart <= rowEnd && colStart <= colEnd)\\n            {\\n                for(int i = colStart; i<= colEnd; i++)\\n                    vv[rowStart][i] = cnt++;\\n                rowStart++;\\n            \\n                for(int i = rowStart; i<= rowEnd; i++)\\n                    vv[i][colEnd] = cnt++;\\n                colEnd--;\\n            \\n                for(int i = colEnd; i>= colStart; i--)\\n                    vv[rowEnd][i] = cnt++;\\n                rowEnd--;\\n            \\n                for(int i = rowEnd; i>= rowStart; i--)\\n                    vv[i][colStart] = cnt++;\\n                colStart++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3506445,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers as well. If you\\'re interested **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- Initialize an empty matrix of size n x n with all elements set to zero.\\n- Define variables left, right, top, bottom, and num.\\n- Use a while loop to iterate over the matrix in a spiral order.\\n- In each iteration, fill in the top row, right column, bottom row, and left column of the remaining submatrix, in that order.\\n- Increment/decrement the values of left, right, top, and bottom accordingly after each iteration, and update the value of num to be filled in the next iteration.\\n- Return the generated matrix.\\n# Intuition:\\n\\nThe code generates the matrix by filling in its elements in a spiral order, starting from the top-left corner and moving clockwise. It uses the variables left, right, top, and bottom to keep track of the current submatrix being filled in, and the variable num to keep track of the next number to be filled in the matrix. The algorithm fills in the matrix in four steps:\\n\\n- Fill in the top row from left to right.\\n- Fill in the right column from top to bottom.\\n- Fill in the bottom row from right to left.\\n- Fill in the left column from bottom to top.\\n\\nAfter each step, the corresponding variable (left, right, top, or bottom) is incremented or decremented to exclude the already filled elements in the next iteration. The algorithm stops when the submatrix being filled in becomes empty, i.e., left > right or top > bottom. Finally, the generated matrix is returned.\\n\\n\\n```Python []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        left, right, top, bottom, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= bottom:\\n            for i in range(left, right+1):\\n                matrix[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in range(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1\\n            right -= 1\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                bottom -= 1\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    matrix[i][left] = num\\n                    num += 1\\n                left += 1\\n        return matrix\\n\\n```\\n```Java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n == 0) {\\n            return new int[0][0];\\n        }\\n        int[][] matrix = new int[n][n];\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        if (n == 0) {\\n            return {};\\n        }\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```Python []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        left, right, top, bottom, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= bottom:\\n            for i in range(left, right+1):\\n                matrix[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in range(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1\\n            right -= 1\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                bottom -= 1\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    matrix[i][left] = num\\n                    num += 1\\n                left += 1\\n        return matrix\\n\\n```\n```Java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n == 0) {\\n            return new int[0][0];\\n        }\\n        int[][] matrix = new int[n][n];\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        if (n == 0) {\\n            return {};\\n        }\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468207,
                "title": "python-smart-simulate-by-marking-as-visited-super-clean-concise",
                "content": "**Idea**\\n- Initially, we move by the RIGHT direction.\\n- If we meet the boundary or we meet visited cell then we change to the next direction.\\n- Directions are in order [RIGHT, DOWN, LEFT, TOP].\\n- We iterate `n^2` times to fill `n^2` values to our answer.\\n\\n![image](https://assets.leetcode.com/users/images/8cc7cea1-b48b-48d2-9dfb-fbf541631d25_1631860276.5949159.png)\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c = 0, 0  # start at cell (0, 0)\\n        d = 0  # start with RIGHT direction\\n        for num in range(1, n*n+1):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < n or not 0 <= nc < n or ans[nr][nc] != 0:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n                \\n            ans[r][c] = num\\n            r, c = nr, nc\\n        \\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 20` is length of side of the square matrix.\\n- Extra space (without couting output as space): `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c = 0, 0  # start at cell (0, 0)\\n        d = 0  # start with RIGHT direction\\n        for num in range(1, n*n+1):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < n or not 0 <= nc < n or ans[nr][nc] != 0:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n                \\n            ans[r][c] = num\\n            r, c = nr, nc\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506760,
                "title": "day-405-brute-better-optimal-3-liner-0ms-100-python-java-c-explained",
                "content": "\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![image.png](https://assets.leetcode.com/users/images/6c06c3b7-3f00-49f3-8e49-5c21b8ef8460_1683686244.3385067.png)\\n\\n\\n# BRUTE\\nThe brute force solution to generate a matrix in spiral order is to simulate the process of filling the matrix in a spiral order. We can start by initializing the matrix with zeros and then fill the matrix in a spiral order by moving right, down, left, and up. We keep track of the current position in the matrix and the direction of movement. Whenever we reach the boundary of the matrix or encounter a non-zero element, we change the direction of movement. We continue this process until all the elements in the matrix are filled.\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row = 0;\\n        int col = 0;\\n        int direction = 0;\\n        int[] dr = {0, 1, 0, -1};\\n        int[] dc = {1, 0, -1, 0};\\n        while (num <= n * n) {\\n            matrix[row][col] = num;\\n            num++;\\n            int nextRow = row + dr[direction];\\n            int nextCol = col + dc[direction];\\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n                direction = (direction + 1) % 4;\\n            }\\n            row += dr[direction];\\n            col += dc[direction];\\n        }\\n        return matrix;\\n    }\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int num = 1;\\n    int row = 0;\\n    int col = 0;\\n    int direction = 0;\\n    vector<int> dr = {0, 1, 0, -1};\\n    vector<int> dc = {1, 0, -1, 0};\\n    while (num <= n * n) {\\n        matrix[row][col] = num;\\n        num++;\\n        int nextRow = row + dr[direction];\\n        int nextCol = col + dc[direction];\\n        if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n            direction = (direction + 1) % 4;\\n        }\\n        row += dr[direction];\\n        col += dc[direction];\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    num = 1\\n    row = 0\\n    col = 0\\n    direction = 0\\n    dr = [0, 1, 0, -1]\\n    dc = [1, 0, -1, 0]\\n    while num <= n * n:\\n        matrix[row][col] = num\\n        num += 1\\n        nextRow = row + dr[direction]\\n        nextCol = col + dc[direction]\\n        if nextRow < 0 or nextRow >= n or nextCol < 0 or nextCol >= n or matrix[nextRow][nextCol] != 0:\\n            direction = (direction + 1) % 4\\n        row += dr[direction]\\n        col += dc[direction]\\n    return matrix\\n```\\n# Complexity\\nThe time complexity of the brute force solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is also O(n^2)+2*O(1D) because we need to create a matrix of size n x n to store the elements and two direction 1D arrays.\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Better Solution:\\n\\nA better solution to generate a matrix in spiral order is to use a recursive approach. We can divide the matrix into four sub-matrices and fill each sub-matrix in a spiral order recursively. We start by filling the top row of the matrix, then fill the right column, then the bottom row, and finally the left column. We repeat this process for the remaining sub-matrix until all the elements in the matrix are filled.\\n\\n```java []\\npublic  int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n        return matrix;\\n    }\\n\\n    public  void fillMatrix(int[][] matrix, int top, int bottom, int left, int right, int num) {\\n        if (top > bottom || left > right) {\\n            return;\\n        }\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        for (int i = top + 1; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        if (top < bottom && left < right) {\\n            for (int i = right - 1; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            for (int i = bottom - 1; i > top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n        }\\n        fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n    }\\n\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n    return matrix;\\n}\\n\\nvoid fillMatrix(vector<vector<int>>& matrix, int top, int bottom, int left, int right, int num) {\\n    if (top > bottom || left > right) {\\n        return;\\n    }\\n    for (int i = left; i <= right; i++) {\\n        matrix[top][i] = num;\\n        num++;\\n    }\\n    for (int i = top + 1; i <= bottom; i++) {\\n        matrix[i][right] = num;\\n        num++;\\n    }\\n    if (top < bottom && left < right) {\\n        for (int i = right - 1; i >= left; i--) {\\n            matrix[bottom][i] = num;\\n            num++;\\n        }\\n        for (int i = bottom - 1; i > top; i--) {\\n            matrix[i][left] = num;\\n            num++;\\n        }\\n    }\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1)\\n    return matrix\\n\\ndef fillMatrix(matrix: List[List[int]], top: int, bottom: int, left: int, right: int, num: int) -> None:\\n    if top > bottom or left > right:\\n        return\\n    for i in range(left, right + 1):\\n        matrix[top][i] = num\\n        num += 1\\n    for i in range(top + 1, bottom + 1):\\n        matrix[i][right] = num\\n        num += 1\\n    if top < bottom and left < right:\\n        for i in range(right - 1, left - 1, -1):\\n            matrix[bottom][i] = num\\n            num += 1\\n        for i in range(bottom - 1, top, -1):\\n            matrix[i][left] = num\\n            num += 1\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num)\\n```\\n# Complexity\\nThe time complexity of the better solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is also O(n^2) because we need to create a matrix of size n x n to store the elements. However, the space complexity of the recursive approach is O(n2)+o(log n) because we use the call stack to store the recursive calls, which has a maximum depth of log n.\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n# optimal\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num;\\n                num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num;\\n                num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num;\\n                    num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num;\\n                    num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int top = 0;\\n    int bottom = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    int num = 1;\\n    while (top <= bottom && <= right) {\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        top++;\\n        for (int i = top; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        right--;\\n        if (top <= bottom) {\\n            for (int i = right; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            bottom--;\\n        }\\n        if (left <= right) {\\n            for (int i = bottom; i >= top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n            left++;\\n        }\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    top = 0\\n    bottom = n - 1\\n    left = 0\\n    right = n - 1\\n    num = 1\\n    while top <= bottom and left <= right:\\n        for i in range(left, right + 1):\\n            matrix[top][i] = num\\n            num += 1\\n        top += 1\\n        for i in range(top, bottom + 1):\\n            matrix[i][right] = num\\n            num += 1\\n        right -= 1\\n        if top <= bottom:\\n            for i in range(right, left - 1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1\\n        if left <= right:\\n            for i in range(bottom, top - 1, -1):\\n                matrix[i][left] = num\\n                num += 1\\n            left += 1\\n    return matrix\\n```\\n# Complexity\\nThe time complexity of the optimal solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is o(n2)+ O(1) because we only need to create a constant number of variables to store the boundaries of the matrix and the current number to fill.\\n\\nIn terms of time complexity, the optimal solution is the best because it has the same time complexity as the other two solutions but uses a single loop instead of recursion or simulating the process of filling the matrix. In terms of space complexity, the optimal solution is the best because it only uses a constant amount of space, whereas the other two solutions use a matrix of size n x n or a call stack of size log n.\\n\\n# concise code\\n# Algorithm\\n##### \\u2022\\tUse four variables i, j, di, and dj to keep track of the current position and direction\\n##### \\u2022\\tThen starts by initializing the matrix with all zeros\\n##### \\u2022\\tIt then fills the matrix in a spiral order by moving in the current direction and changing direction when it encounters a non-zero element\\n##### \\u2022\\tThe loop variable k starts from 1 and goes up to n * n\\n##### \\u2022\\tIn each iteration, then sets the value of the current position (i, j) to k\\n##### \\u2022\\tIt then checks if the next position in the current direction (i + di, j + dj) is already filled with a non-zero value\\n##### \\u2022\\tIf it is, changes the direction by swapping di and dj and negating one of them\\n##### \\u2022\\tFinally, updates the current position by adding di to i and dj to j\\n##### \\u2022\\tOnce the loop is complete, the matrix is filled in a spiral order and returns the matrix\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n    int matrix[][] = new int[n][n],i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    } return matrix;\\n}\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(self, n):\\n    A = [[0] * n for _ in range(n)]\\n    i, j, di, dj = 0, 0, 0, 1\\n    for k in xrange(n*n):\\n        A[i][j] = k + 1\\n        if A[(i+di)%n][(j+dj)%n]:\\n            di, dj = dj, -di\\n        i += di\\n        j += dj\\n    return A\\n```\\n\\n# dry run for n=3\\n##### \\u2022\\tInitially, we create a new n x n matrix filled with zeros\\n##### \\u2022\\tWe also initialize i and j to 0, and di and dj to 0 and 1 respectively\\n##### \\u2022\\tWe then enter a loop that runs from k=1 to k=n*n\\n##### \\u2022\\tIn each iteration of the loop, we do the following:We set the value of the current cell to k\\n##### \\u2022\\tWe check if the next cell in the direction of (di, dj) is already filled\\n##### \\u2022\\tIf it is, we change the direction of motion by swapping di and dj and negating the new value of dj\\n##### \\u2022\\tWe update the values of i and j by adding di and dj respectively\\n##### \\u2022\\tAfter the loop completes, we return the filled matrix\\n##### \\u2022\\tThe final matrix is:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\n# 3 LINES code\\n# Algorithm\\n##### \\u2022\\tFirst initializes an empty list A and a variable lo to n*n+1\\n##### \\u2022\\tIt then enters a loop that continues until lo is less than or equal to 1\\n##### \\u2022\\tIn each iteration, set hi to the current value of lo and updates lo to lo - len(A)\\n##### \\u2022\\tIt then creates a new list of integers from lo to hi and appends it to the beginning of A\\n##### \\u2022\\tThen reverses the order of the remaining elements in A and transposes the resulting list of lists using the zip() function\\n##### \\u2022\\tThis effectively rotates the matrix by 90 degrees counterclockwise\\n##### \\u2022\\tThe loop continues until lo is less than or equal to 1, at which point the matrix is filled in a spiral order and  returns A\\n\\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A = [[n*n]]\\n    while A[0][0] > 1:\\n        A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n    return A * (n>0)\\n```\\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A, lo = [], n*n+1\\n    while lo > 1:\\n        lo, hi = lo - len(A), lo\\n        A = [range(lo, hi)] + zip(*A[::-1])\\n    return A\\n```\\n# dry run for n=3\\n##### \\u2022\\tInitially, A is set to [[9]]\\n##### \\u2022\\tIn the while loop, we check if the first element of A is greater than 1\\n##### \\u2022\\tSince it is, we perform the following steps:We create a new list B containing a range of numbers from A[0][0] - len(A) to A[0][0] - 1\\n##### \\u2022\\tIn this case, B is equal to range(7, 9)\\n##### \\u2022\\tWe then take the transpose of A using zip(*A[::-1])\\n##### \\u2022\\tThe [::-1] reverses the order of the elements in A, and the * unpacks the elements of A as arguments to zip\\n##### \\u2022\\tThe zip function then groups the elements of each sub-list of A with the corresponding elements of B, effectively rotating the matrix by 90 degrees counterclockwise\\n##### \\u2022\\tWe concatenate B with the result of step 2 to form a new matrix A\\n##### \\u2022\\tWe repeat steps 1-3 until the first element of A is equal to 1\\n##### \\u2022\\tFinally, we return A multiplied by (n>0), which is equivalent to returning A if n is positive and an empty list if n is zero\\n\\nAt each iteration, the code fills in one element of the matrix in a spiral order. The final matrix is filled in the following order:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row = 0;\\n        int col = 0;\\n        int direction = 0;\\n        int[] dr = {0, 1, 0, -1};\\n        int[] dc = {1, 0, -1, 0};\\n        while (num <= n * n) {\\n            matrix[row][col] = num;\\n            num++;\\n            int nextRow = row + dr[direction];\\n            int nextCol = col + dc[direction];\\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n                direction = (direction + 1) % 4;\\n            }\\n            row += dr[direction];\\n            col += dc[direction];\\n        }\\n        return matrix;\\n    }\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int num = 1;\\n    int row = 0;\\n    int col = 0;\\n    int direction = 0;\\n    vector<int> dr = {0, 1, 0, -1};\\n    vector<int> dc = {1, 0, -1, 0};\\n    while (num <= n * n) {\\n        matrix[row][col] = num;\\n        num++;\\n        int nextRow = row + dr[direction];\\n        int nextCol = col + dc[direction];\\n        if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n            direction = (direction + 1) % 4;\\n        }\\n        row += dr[direction];\\n        col += dc[direction];\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    num = 1\\n    row = 0\\n    col = 0\\n    direction = 0\\n    dr = [0, 1, 0, -1]\\n    dc = [1, 0, -1, 0]\\n    while num <= n * n:\\n        matrix[row][col] = num\\n        num += 1\\n        nextRow = row + dr[direction]\\n        nextCol = col + dc[direction]\\n        if nextRow < 0 or nextRow >= n or nextCol < 0 or nextCol >= n or matrix[nextRow][nextCol] != 0:\\n            direction = (direction + 1) % 4\\n        row += dr[direction]\\n        col += dc[direction]\\n    return matrix\\n```\n```java []\\npublic  int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n        return matrix;\\n    }\\n\\n    public  void fillMatrix(int[][] matrix, int top, int bottom, int left, int right, int num) {\\n        if (top > bottom || left > right) {\\n            return;\\n        }\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        for (int i = top + 1; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        if (top < bottom && left < right) {\\n            for (int i = right - 1; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            for (int i = bottom - 1; i > top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n        }\\n        fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n    }\\n\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n    return matrix;\\n}\\n\\nvoid fillMatrix(vector<vector<int>>& matrix, int top, int bottom, int left, int right, int num) {\\n    if (top > bottom || left > right) {\\n        return;\\n    }\\n    for (int i = left; i <= right; i++) {\\n        matrix[top][i] = num;\\n        num++;\\n    }\\n    for (int i = top + 1; i <= bottom; i++) {\\n        matrix[i][right] = num;\\n        num++;\\n    }\\n    if (top < bottom && left < right) {\\n        for (int i = right - 1; i >= left; i--) {\\n            matrix[bottom][i] = num;\\n            num++;\\n        }\\n        for (int i = bottom - 1; i > top; i--) {\\n            matrix[i][left] = num;\\n            num++;\\n        }\\n    }\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1)\\n    return matrix\\n\\ndef fillMatrix(matrix: List[List[int]], top: int, bottom: int, left: int, right: int, num: int) -> None:\\n    if top > bottom or left > right:\\n        return\\n    for i in range(left, right + 1):\\n        matrix[top][i] = num\\n        num += 1\\n    for i in range(top + 1, bottom + 1):\\n        matrix[i][right] = num\\n        num += 1\\n    if top < bottom and left < right:\\n        for i in range(right - 1, left - 1, -1):\\n            matrix[bottom][i] = num\\n            num += 1\\n        for i in range(bottom - 1, top, -1):\\n            matrix[i][left] = num\\n            num += 1\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num)\\n```\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num;\\n                num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num;\\n                num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num;\\n                    num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num;\\n                    num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int top = 0;\\n    int bottom = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    int num = 1;\\n    while (top <= bottom && <= right) {\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        top++;\\n        for (int i = top; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        right--;\\n        if (top <= bottom) {\\n            for (int i = right; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            bottom--;\\n        }\\n        if (left <= right) {\\n            for (int i = bottom; i >= top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n            left++;\\n        }\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    top = 0\\n    bottom = n - 1\\n    left = 0\\n    right = n - 1\\n    num = 1\\n    while top <= bottom and left <= right:\\n        for i in range(left, right + 1):\\n            matrix[top][i] = num\\n            num += 1\\n        top += 1\\n        for i in range(top, bottom + 1):\\n            matrix[i][right] = num\\n            num += 1\\n        right -= 1\\n        if top <= bottom:\\n            for i in range(right, left - 1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1\\n        if left <= right:\\n            for i in range(bottom, top - 1, -1):\\n                matrix[i][left] = num\\n                num += 1\\n            left += 1\\n    return matrix\\n```\n```java []\\npublic int[][] generateMatrix(int n) {\\n    int matrix[][] = new int[n][n],i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    } return matrix;\\n}\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(self, n):\\n    A = [[0] * n for _ in range(n)]\\n    i, j, di, dj = 0, 0, 0, 1\\n    for k in xrange(n*n):\\n        A[i][j] = k + 1\\n        if A[(i+di)%n][(j+dj)%n]:\\n            di, dj = dj, -di\\n        i += di\\n        j += dj\\n    return A\\n```\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A = [[n*n]]\\n    while A[0][0] > 1:\\n        A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n    return A * (n>0)\\n```\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A, lo = [], n*n+1\\n    while lo > 1:\\n        lo, hi = lo - len(A), lo\\n        A = [range(lo, hi)] + zip(*A[::-1])\\n    return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 460726,
                "title": "python-easy-to-understand-solution-with-fully-commented-code-ref-caikehe-s-solution",
                "content": "NOTE: this solution is an adaption of @caikehe\\'s [brilliant and clean solution](https://leetcode.com/problems/spiral-matrix-ii/discuss/22290/Python-easy-to-follow-solution).\\n\\nintuition:\\n\\n- initialize a matrix of zeros\\n- fill in the numbers in a spiral order layer-by-layer\\n\\nie. if n =3, initialize a 3-by-3 matrix\\n```\\n[\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\\ndivide up the matrix into 4 types of layers\\n```python\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n```\\n\\n```\\n[  \\n [ X, 0, 0 ], <-- you start filling in numbers at the top-left position\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\\n\\nwhen filling the top layer (horizontal row), fix the row index and increment the col index.\\nafter you are done with the top layer (horizontal row), move the top layer inward(downward) \\n\\n```python\\n for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n\\t matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n     num += 1 # update num\\n top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n```\\n\\nyour matrix will be\\n\\n\\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, X ], <--- since you increment the top layer by 1, you will start fillin in the next number here at the \\'x\\' position\\n [ 0, 0, 0 ]\\n]\\n```\\n\\nrepeat for the right col (vertical layer going down), bottom row (horizontal layer going right to left), left col (vertical layer going from bottom up)\\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, 4 ], \\n [ 0, X, 5 ] <--- since you increment the right layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n]\\n```\\n\\n```\\n[\\n [ 1, 2, 3 ],\\n [ X, 0, 4 ], <--- since you increment the bottom layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n [ 7, 6, 5 ]\\n]\\n```\\n\\ntime O(n by n)\\nspace O(n by n)\\n\\n```python\\n# 59 Spiral Matrix II\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = []\\n        if not n: return matrix\\n\\n        # construct a matrix of zeros\\n        for row in range(n):\\n            rowArray = []\\n            for col in range(n):\\n                rowArray.append(0)\\n            matrix.append(rowArray)\\n\\n        # layer by layer strategy\\n        num = 1\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n\\t\\t \\n\\t\\t # while layers closing inward but not overlapping. if overlap = reached end of spiral matrix\\n        while left <= right and top <= down: \\n            # top row\\n            for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n                matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n                num += 1 # update num\\n            top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n\\n            # right col\\n            for i in range(top, down+1): # from top to bottom. bottom + 1 to reach the last positin in a col\\n                matrix[i][right] = num # to fill the right col, fix the right col index and increment the row position\\n                num += 1 # update num\\n            right -= 1 # after traversing right col, move right col index inward(towards the left) by one unit\\n\\n            # bottom row\\n            for i in range(right, left-1, -1): # from left to right, in reverse order. left-1 to reach the leftmost position in a row\\n                matrix[down][i] = num\\n                num += 1 # update num\\n            down -= 1 # after traversing bottom row, move bottom row index inward(upward) by one unit\\n\\n            # left col\\n            for i in range(down, top-1, -1): # from bottom to top, in reverse order. top-1 to reach the topmost position in a col\\n                matrix[i][left] = num # to fill the left col, fix the left col index and increment the row position\\n                num += 1\\n            left += 1 # after traversing left col, move left col index inward(towards the right) by one unit\\n\\n            # repeat until top-bottom or left-right indices collide (ie. have completed all layers)\\n        return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n[\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\n```python\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n```\n```\\n[  \\n [ X, 0, 0 ], <-- you start filling in numbers at the top-left position\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\n```python\\n for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n\\t matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n     num += 1 # update num\\n top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, X ], <--- since you increment the top layer by 1, you will start fillin in the next number here at the \\'x\\' position\\n [ 0, 0, 0 ]\\n]\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, 4 ], \\n [ 0, X, 5 ] <--- since you increment the right layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n]\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ X, 0, 4 ], <--- since you increment the bottom layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n [ 7, 6, 5 ]\\n]\\n```\n```python\\n# 59 Spiral Matrix II\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = []\\n        if not n: return matrix\\n\\n        # construct a matrix of zeros\\n        for row in range(n):\\n            rowArray = []\\n            for col in range(n):\\n                rowArray.append(0)\\n            matrix.append(rowArray)\\n\\n        # layer by layer strategy\\n        num = 1\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n\\t\\t \\n\\t\\t # while layers closing inward but not overlapping. if overlap = reached end of spiral matrix\\n        while left <= right and top <= down: \\n            # top row\\n            for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n                matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n                num += 1 # update num\\n            top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n\\n            # right col\\n            for i in range(top, down+1): # from top to bottom. bottom + 1 to reach the last positin in a col\\n                matrix[i][right] = num # to fill the right col, fix the right col index and increment the row position\\n                num += 1 # update num\\n            right -= 1 # after traversing right col, move right col index inward(towards the left) by one unit\\n\\n            # bottom row\\n            for i in range(right, left-1, -1): # from left to right, in reverse order. left-1 to reach the leftmost position in a row\\n                matrix[down][i] = num\\n                num += 1 # update num\\n            down -= 1 # after traversing bottom row, move bottom row index inward(upward) by one unit\\n\\n            # left col\\n            for i in range(down, top-1, -1): # from bottom to top, in reverse order. top-1 to reach the topmost position in a col\\n                matrix[i][left] = num # to fill the left col, fix the left col index and increment the row position\\n                num += 1\\n            left += 1 # after traversing left col, move left col index inward(towards the right) by one unit\\n\\n            # repeat until top-bottom or left-right indices collide (ie. have completed all layers)\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941112,
                "title": "python3-straightforward-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use helper function here that fills only one circle at the time.\\n\\nTime: **O(n^2)**\\nSpace: **O(1)**\\n\\nRuntime: 35 ms, faster than **82.95%** of Python3 online submissions for Spiral Matrix II.\\nMemory Usage: 13.9 MB, less than **85.84%** of Python3 online submissions for Spiral Matrix II.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        \\n        def fill_circle(el, start, n):\\n            i, j = start, start            \\n            for k in range(j, j + n): \\n                res[i][k], el = el, el + 1\\n            for k in range(i + 1, i + n): \\n                res[k][j + n - 1], el = el, el + 1\\n            for k in reversed(range(j, j + n - 1)): \\n                res[i + n - 1][k], el = el, el + 1\\n            for k in reversed(range(i + 1, i + n - 1)): \\n                res[k][j], el = el, el + 1\\n        \\n        el, start = 1, 0\\n        while n > 0:\\n            fill_circle(el, start, n)\\n            el = el + 4*(n - 1)\\n            n, start = n - 2, start + 1\\n            \\n        return res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        \\n        def fill_circle(el, start, n):\\n            i, j = start, start            \\n            for k in range(j, j + n): \\n                res[i][k], el = el, el + 1\\n            for k in range(i + 1, i + n): \\n                res[k][j + n - 1], el = el, el + 1\\n            for k in reversed(range(j, j + n - 1)): \\n                res[i + n - 1][k], el = el, el + 1\\n            for k in reversed(range(i + 1, i + n - 1)): \\n                res[k][j], el = el, el + 1\\n        \\n        el, start = 1, 0\\n        while n > 0:\\n            fill_circle(el, start, n)\\n            el = el + 4*(n - 1)\\n            n, start = n - 2, start + 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22443,
                "title": "9-lines-python-solution",
                "content": "(1) Create a matrix to store the coordinates\\n> (0,0) (0,1) (0,2)\\n\\n> (1,0) (1,1) (1,2)\\n\\n> (2,0) (2,1) (2,2)\\n\\n(2) Read it out using the trick of \"[Spiral Matrix I][1]\"\\n\\n> (0,0) (0,1) (0,2) (1,2) (2,2) ...\\n\\n(3) Put 1, 2, 3, ... n**2 at these coordinates sequentially.  Done.\\n\\n    def generateMatrix(self, n):\\n        \\n        result = [[0 for i in range(n)] for j in range(n)]\\n        coord = [[(i,j) for j in range(n)] for i in range(n)]\\n        \\n        count = 1\\n        \\n        while coord:\\n            for x, y in coord.pop(0):\\n                result[x][y] = count\\n                count += 1\\n            coord = zip(*coord)[::-1]\\n\\n        return result\\n\\n\\n  [1]: https://leetcode.com/discuss/46516/lines-recursive-python-solution-lines-solution-recursion",
                "solutionTags": [
                    "Python"
                ],
                "code": "(1) Create a matrix to store the coordinates\\n> (0,0) (0,1) (0,2)\\n\\n> (1,0) (1,1) (1,2)\\n\\n> (2,0) (2,1) (2,2)\\n\\n(2) Read it out using the trick of \"[Spiral Matrix I][1]\"\\n\\n> (0,0) (0,1) (0,2) (1,2) (2,2) ...\\n\\n(3) Put 1, 2, 3, ... n**2 at these coordinates sequentially.  Done.\\n\\n    def generateMatrix(self, n):\\n        \\n        result = [[0 for i in range(n)] for j in range(n)]\\n        coord = [[(i,j) for j in range(n)] for i in range(n)]\\n        \\n        count = 1\\n        \\n        while coord:\\n            for x, y in coord.pop(0):\\n                result[x][y] = count\\n                count += 1\\n            coord = zip(*coord)[::-1]\\n\\n        return result\\n\\n\\n  [1]: https://leetcode.com/discuss/46516/lines-recursive-python-solution-lines-solution-recursion",
                "codeTag": "Python3"
            },
            {
                "id": 22469,
                "title": "if-we-can-t-write-data-to-the-matrix-we-change-the-direction-a-simple-python-solution",
                "content": "    class Solution:\\n    # @return a list of lists of integer\\n    def generateMatrix(self, n):\\n        matrix = [[0]*n for _ in range(n)]\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        d = 0\\n        y, x = 0, 0\\n        for i in range(1, n*n+1):\\n            matrix[y][x] = i\\n            dy, dx = directions[d % 4]\\n            if -1 < y+dy < n and -1 < x+dx < n and matrix[y+dy][x+dx] == 0:\\n                y, x = y+dy, x+dx\\n            else:\\n                d += 1\\n                dy, dx = directions[d % 4]\\n                y, x = y+dy, x+dx\\n        return matrix\\n\\nChange the direction If the we can't write to the matrix",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return a list of lists of integer\\n    def generateMatrix(self, n):\\n        matrix = [[0]*n for _ in range(n)]\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        d = 0\\n        y, x = 0, 0\\n        for i in range(1, n*n+1):\\n            matrix[y][x] = i\\n            dy, dx = directions[d % 4]\\n            if -1 < y+dy < n and -1 < x+dx < n and matrix[y+dy][x+dx] == 0:\\n                y, x = y+dy, x+dx\\n            else:\\n                d += 1\\n                dy, dx = directions[d % 4]\\n                y, x = y+dy, x+dx\\n        return matrix\\n\\nChange the direction If the we can't write to the matrix",
                "codeTag": "Java"
            },
            {
                "id": 1511479,
                "title": "java-tc-o-n-2-sc-o-1-multiple-optimized-ways-to-solve-this-question",
                "content": "**Using Switch-Case - Simulating the spiral traversal**\\n```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Left\\n                    for (int i = left; i <= right; i++) {\\n                        result[top][i] = num++;\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result[i][right] = num++;\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Right\\n                    for (int i = right; i >= left; i--) {\\n                        result[bottom][i] = num++;\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Up\\n                    for (int i = bottom; i >= top; i--) {\\n                        result[i][left] = num++;\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Without using Switch-Case - Simulating the spiral traversal**\\n\\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int rowBegin = 0;\\n        int rowEnd = n - 1;\\n        int colBegin = 0;\\n        int colEnd = n - 1;\\n        int num = 1;\\n\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // Traverse Right\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                result[rowBegin][i] = num++;\\n            }\\n            rowBegin++;\\n            // Traverse Down\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                result[i][colEnd] = num++;\\n            }\\n            colEnd--;\\n            // Traverse Left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    result[rowEnd][i] = num++;\\n                }\\n                rowEnd--;\\n            }\\n            // Traverse Up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    result[i][colBegin] = num++;\\n                }\\n                colBegin++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Using 2D Directions array to calculate the next valid position - Simulating the spiral traversal**\\n\\n```java\\n/**\\n * Using 2D Directions array to calculate the next valid position. Traverse\\n * Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int row = 0;\\n        int col = 0;\\n        int dirIdx = 0;\\n        int num = 1;\\n\\n        while (num <= n * n) {\\n            result[row][col] = num++;\\n            row += dirs[dirIdx][0];\\n            col += dirs[dirIdx][1];\\n\\n            if (row < 0 || row >= n || col < 0 || col >= n || result[row][col] != 0) {\\n                // Moving back from invalid position\\n                row -= dirs[dirIdx][0];\\n                col -= dirs[dirIdx][1];\\n                // Going to next dir\\n                dirIdx = (dirIdx + 1) % 4;\\n                // Updating row and col to valid next position\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/1511476/Java-or-TC:-O(M*N)-or-SC:-O(1)-or-Optimized-solution-using-Switch-Case)\\n- [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/discuss/1511489/Java-or-TC:-O(max(R-C)2)-or-SC:-O(1)-or-Simulating-a-Spiral-Walk)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Left\\n                    for (int i = left; i <= right; i++) {\\n                        result[top][i] = num++;\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result[i][right] = num++;\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Right\\n                    for (int i = right; i >= left; i--) {\\n                        result[bottom][i] = num++;\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Up\\n                    for (int i = bottom; i >= top; i--) {\\n                        result[i][left] = num++;\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int rowBegin = 0;\\n        int rowEnd = n - 1;\\n        int colBegin = 0;\\n        int colEnd = n - 1;\\n        int num = 1;\\n\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // Traverse Right\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                result[rowBegin][i] = num++;\\n            }\\n            rowBegin++;\\n            // Traverse Down\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                result[i][colEnd] = num++;\\n            }\\n            colEnd--;\\n            // Traverse Left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    result[rowEnd][i] = num++;\\n                }\\n                rowEnd--;\\n            }\\n            // Traverse Up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    result[i][colBegin] = num++;\\n                }\\n                colBegin++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Using 2D Directions array to calculate the next valid position. Traverse\\n * Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int row = 0;\\n        int col = 0;\\n        int dirIdx = 0;\\n        int num = 1;\\n\\n        while (num <= n * n) {\\n            result[row][col] = num++;\\n            row += dirs[dirIdx][0];\\n            col += dirs[dirIdx][1];\\n\\n            if (row < 0 || row >= n || col < 0 || col >= n || result[row][col] != 0) {\\n                // Moving back from invalid position\\n                row -= dirs[dirIdx][0];\\n                col -= dirs[dirIdx][1];\\n                // Going to next dir\\n                dirIdx = (dirIdx + 1) % 4;\\n                // Updating row and col to valid next position\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941264,
                "title": "runtime-0-ms-faster-than-100-00-0-easy-to-understand",
                "content": "***Runtime: 0 ms, faster than 100.00% of Java online submissions for Spiral Matrix II.***\\n\\n***LOGIC***=We have to keep insering the number while moving in a particular direction and changing the direction when `certain condtion` occur:\\n\\n* next row index is -1\\n* next col index is -1\\n* next col index is n\\n* next row index is n\\n* next cell in current direction is already filled.\\n\\nIf `any one` of the following conditions arise, the direction should be changed\\n\\nThere is a `proper order` which we have to follow while `changing the direction`:\\n\\n* initial: right -> new: down\\n* initial: down -> new: left\\n* initial: left -> new: up\\n* initial: up -> new: right\\n\\n\\n\\n```\\nclass Solution {\\n    Integer rowDir = 0, colDir = 1;\\n    \\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row =0, col=0;\\n        \\n        \\n        while(num<= n*n) {\\n            matrix[row][col] = num;\\n            \\n            int tempRow = row+rowDir;\\n            int tempCol = col+colDir;\\n\\t\\t\\t\\n\\t\\t\\t//Condition to change direction \\n            if(tempRow < 0 || tempCol <0 || tempRow == n || tempCol == n || matrix[tempRow][tempCol] != 0) {\\n                changeDirection();\\n            }\\n            \\n            row += rowDir;\\n            col += colDir;\\n            \\n            num++;\\n        }\\n        \\n        return matrix;\\n    }\\n    \\n    public void changeDirection() {\\n\\t\\t\\n        if(rowDir == 0 && colDir ==1) {\\n\\t\\t\\t// initial: right -> new: down\\n            colDir = 0;\\n            rowDir = 1;\\n        } else if (colDir == 0 && rowDir ==1) {\\n\\t\\t\\t// initial: down -> new: left\\n            rowDir = 0;\\n            colDir = -1;\\n        } else if (colDir == -1 && rowDir == 0) {\\n\\t\\t\\t// initial: left -> new: up\\n            rowDir = -1;\\n            colDir = 0;\\n        } else if (rowDir == -1 && colDir == 0) {\\n\\t\\t\\t// initial: up -> new: right\\n            colDir = 1;\\n            rowDir = 0;\\n        }\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n**Time Complexity =O(N*N)**\\n**Space Complexity = O(N)**\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer rowDir = 0, colDir = 1;\\n    \\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row =0, col=0;\\n        \\n        \\n        while(num<= n*n) {\\n            matrix[row][col] = num;\\n            \\n            int tempRow = row+rowDir;\\n            int tempCol = col+colDir;\\n\\t\\t\\t\\n\\t\\t\\t//Condition to change direction \\n            if(tempRow < 0 || tempCol <0 || tempRow == n || tempCol == n || matrix[tempRow][tempCol] != 0) {\\n                changeDirection();\\n            }\\n            \\n            row += rowDir;\\n            col += colDir;\\n            \\n            num++;\\n        }\\n        \\n        return matrix;\\n    }\\n    \\n    public void changeDirection() {\\n\\t\\t\\n        if(rowDir == 0 && colDir ==1) {\\n\\t\\t\\t// initial: right -> new: down\\n            colDir = 0;\\n            rowDir = 1;\\n        } else if (colDir == 0 && rowDir ==1) {\\n\\t\\t\\t// initial: down -> new: left\\n            rowDir = 0;\\n            colDir = -1;\\n        } else if (colDir == -1 && rowDir == 0) {\\n\\t\\t\\t// initial: left -> new: up\\n            rowDir = -1;\\n            colDir = 0;\\n        } else if (rowDir == -1 && colDir == 0) {\\n\\t\\t\\t// initial: up -> new: right\\n            colDir = 1;\\n            rowDir = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22409,
                "title": "c-concise-solution",
                "content": "        \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n, vector<int> (n, 1));\\n        int left, right, top, down, index;\\n        left = top = index = 0, right = down = n-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res[top][j] = ++index;\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res[i][right] = ++index;\\n            right--;\\n            for (int j = right; j >= left; j--)\\n                res[down][j] = ++index;\\n            down--;\\n            for (int i = down; i >= top; i--)\\n                res[i][left] = ++index;\\n            left++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n, vector<int> (n, 1));\\n        int left, right, top, down, index;\\n        left = top = index = 0, right = down = n-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res[top][j] = ++index;\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res[i][right] = ++index;\\n            right--;\\n            for (int j = right; j >= left; j--)\\n                res[down][j] = ++index;\\n            down--;\\n            for (int i = down; i >= top; i--)\\n                res[i][left] = ++index;\\n            left++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1804819,
                "title": "c-0ms-fastest-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n            \\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n            \\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n            \\n             \\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n            \\n        }\\n        return m;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 22466,
                "title": "my-ac-solution-with-using-direction-variable",
                "content": "      \\n     vector<vector<int> > generateMatrix(int n) {\\n                int dir = 0;\\n                vector< vector<int> > matrix(n, vector<int> (n, 0));\\n                int i = 0, j = 0, k = 1;\\n                while (k <= n * n) {\\n                    matrix[i][j] = k++;\\n                    if (dir == 0){\\n                        j++;\\n                        if (j == n || matrix[i][j] != 0) dir = 1, j--, i++;\\n                    } else\\n                    if (dir == 1) {\\n                        i++;\\n                        if (i == n || matrix[i][j] != 0) dir = 2, i--, j--;\\n                    } else\\n                    if (dir == 2) {\\n                        j--;\\n                        if (j < 0 || matrix[i][j] != 0) dir = 3, j++, i--;\\n                    } else\\n                    if (dir == 3) {\\n                        i--;\\n                        if (i < 0 || matrix[i][j] != 0) dir = 0, i++, j++;\\n                    }\\n                }\\n                return matrix;\\n            }",
                "solutionTags": [],
                "code": "      \\n     vector<vector<int> > generateMatrix(int n) {\\n                int dir = 0;\\n                vector< vector<int> > matrix(n, vector<int> (n, 0));\\n                int i = 0, j = 0, k = 1;\\n                while (k <= n * n) {\\n                    matrix[i][j] = k++;\\n                    if (dir == 0){\\n                        j++;\\n                        if (j == n || matrix[i][j] != 0) dir = 1, j--, i++;\\n                    } else\\n                    if (dir == 1) {\\n                        i++;\\n                        if (i == n || matrix[i][j] != 0) dir = 2, i--, j--;\\n                    } else\\n                    if (dir == 2) {\\n                        j--;\\n                        if (j < 0 || matrix[i][j] != 0) dir = 3, j++, i--;\\n                    } else\\n                    if (dir == 3) {\\n                        i--;\\n                        if (i < 0 || matrix[i][j] != 0) dir = 0, i++, j++;\\n                    }\\n                }\\n                return matrix;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 3506464,
                "title": "easy-c-java-code-beats-100-step-by-step-explanattion-begginers-freindly",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe matrix is initialized with all elements set to 0.\\n\\nThe goal is to fill the matrix with integers from 1 to n x n in a spiral order. \\nFor example, for n = 3, the matrix should look like this:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nInitialize the matrix with all elements set to 0.\\n```\\n0 0 0\\n0 0 0\\n0 0 0\\n```\\nInitialize variables to keep track of the starting and ending rows and columns. Initially, the starting row and column are both 0, and the ending row and column are both n - 1.\\n```\\nstartingrow = 0\\nstartingcol = 0\\nendingrow = 2\\nendingcol = 2\\n```\\nStart filling the matrix in a clockwise spiral order. The first step is to fill the top row from left to right. The count variable keeps track of the current number being filled in the matrix. After each number is placed in the matrix, count is incremented.\\n```\\n1 2 3\\n0 0 0\\n0 0 0\\ncount = 1\\n```\\nMove the starting row down by one, so that the next step will fill the right column from top to bottom.\\n```\\n0 0 0\\n0 0 0\\n0 0 0\\ncount = 1\\nstartingrow = 1\\n```\\nFill the right column from top to bottom.\\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\n```\\nMove the ending column left by one, so that the next step will fill the bottom row from right to left.\\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\nendingcol = 1\\n```\\nFill the bottom row from right to left.\\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\n```\\nMove the ending row up by one, so that the next step will fill the left column from bottom to top.\\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\nendingrow = 1\\n```\\nFill the left column from bottom to top.\\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\n```\\nMove the starting column right by one, so that the next step will fill the top row from left to right again.\\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\nstartingcol = 1\\n```\\nRepeat steps 3 through 10 until the entire matrix is filled with numbers.\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nThe matrix filled with integers from 1 to n x n in a clockwise spiral order.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# ---------------------------------------------------------\\n# Please Upvote If It helps You\\n# ---------------------------------------------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n# java code \\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        // creating a matrix of n x n\\n        \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        // initialize variables for keeping track of starting and ending rows and columns\\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // fill in the top row from left to right\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // fill in the right column from top to bottom\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // fill in the bottom row from right to left\\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // fill in the left column from bottom to top\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\n0 0 0\\n0 0 0\\n0 0 0\\n```\n```\\nstartingrow = 0\\nstartingcol = 0\\nendingrow = 2\\nendingcol = 2\\n```\n```\\n1 2 3\\n0 0 0\\n0 0 0\\ncount = 1\\n```\n```\\n0 0 0\\n0 0 0\\n0 0 0\\ncount = 1\\nstartingrow = 1\\n```\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\n```\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\nendingcol = 1\\n```\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\n```\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\nendingrow = 1\\n```\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\n```\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\nstartingcol = 1\\n```\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        // creating a matrix of n x n\\n        \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        // initialize variables for keeping track of starting and ending rows and columns\\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // fill in the top row from left to right\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // fill in the right column from top to bottom\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // fill in the bottom row from right to left\\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // fill in the left column from bottom to top\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978960,
                "title": "0ms-faster-than-100-easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n));\\n        int top = 0, bottom = n-1, left = 0, right = n-1;\\n        int val = 1,direction=1;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction == 1)    \\n            {   \\n                for(int i=left;i<=right;i++)\\n                {\\n                    res[top][i]=val++;\\n                }\\n                top++;\\n                direction=2;\\n            }\\n            else if(direction == 2)\\n            {\\n                for(int i = top;i<=bottom;i++)\\n                {\\n                    res[i][right]=val++;\\n                }\\n                right--;\\n                direction = 3;\\n            }\\n            else if(direction == 3)\\n            {\\n                for(int i = right;i>=left;i--)\\n                {\\n                    res[bottom][i]=val++;\\n                }\\n                bottom--;\\n                direction=4;\\n            }\\n            else if(direction == 4)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    res[i][left]=val++;\\n                }\\n                left++;\\n                direction = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n));\\n        int top = 0, bottom = n-1, left = 0, right = n-1;\\n        int val = 1,direction=1;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction == 1)    \\n            {   \\n                for(int i=left;i<=right;i++)\\n                {\\n                    res[top][i]=val++;\\n                }\\n                top++;\\n                direction=2;\\n            }\\n            else if(direction == 2)\\n            {\\n                for(int i = top;i<=bottom;i++)\\n                {\\n                    res[i][right]=val++;\\n                }\\n                right--;\\n                direction = 3;\\n            }\\n            else if(direction == 3)\\n            {\\n                for(int i = right;i>=left;i--)\\n                {\\n                    res[bottom][i]=val++;\\n                }\\n                bottom--;\\n                direction=4;\\n            }\\n            else if(direction == 4)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    res[i][left]=val++;\\n                }\\n                left++;\\n                direction = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941099,
                "title": "python3-solution-using-spiral-traversal-in-o-n-n-time",
                "content": "I have seen some of the solutions to this problem in the discussion section which is mostly related to checking the matrix bounds or validating if the current cell is zero to determine the change of direction. \\n\\nI have actually solved a similar problem before -> https://leetcode.com/problems/spiral-matrix/ and I will try to explain the same approach that I used there as I think its easier to comprehend and seemed more intuitive.\\n\\nThe main idea here is that we initialize **bounds** for four directions: **up**, **down**, **left** and **right**. For each iteration, we **traverse the complete spiral** i.e in all 4 directions. At the end, we just need to **increment or decrement the bounds** accordingly. The code has an extra check after traversing right and down directions to determine if it has landed on same row or column. \\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        up, down, left, right = 0, n-1, 0, n-1\\n        \\n        num = 1\\n        while num <= (n * n):\\n            for idx in range(left, right + 1):\\n                matrix[up][idx] = num\\n                num+=1\\n            \\n            for idx in range(up + 1, down + 1):\\n                matrix[idx][right] = num\\n                num+=1\\n            \\n            # not the same row\\n            if up != down:\\n                for idx in range(right - 1, left - 1, -1):\\n                    matrix[down][idx] = num\\n                    num+=1\\n            #not the same column\\n            if left != right:\\n                for idx in range(down - 1, up, -1):\\n                    matrix[idx][left] = num\\n                    num+=1\\n            \\n            left+=1\\n            up+=1\\n            right-=1\\n            down-=1\\n        return matrix\\n```\\n\\nPlease upvote if you find it useful\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        up, down, left, right = 0, n-1, 0, n-1\\n        \\n        num = 1\\n        while num <= (n * n):\\n            for idx in range(left, right + 1):\\n                matrix[up][idx] = num\\n                num+=1\\n            \\n            for idx in range(up + 1, down + 1):\\n                matrix[idx][right] = num\\n                num+=1\\n            \\n            # not the same row\\n            if up != down:\\n                for idx in range(right - 1, left - 1, -1):\\n                    matrix[down][idx] = num\\n                    num+=1\\n            #not the same column\\n            if left != right:\\n                for idx in range(down - 1, up, -1):\\n                    matrix[idx][left] = num\\n                    num+=1\\n            \\n            left+=1\\n            up+=1\\n            right-=1\\n            down-=1\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471809,
                "title": "javascript-simple",
                "content": "Runtime: 68 ms, faster than 90.62% of JavaScript online submissions for Spiral Matrix II.\\nMemory Usage: 38.7 MB, less than 83.38% of JavaScript online submissions for Spiral Matrix II.\\n\\n```\\nvar generateMatrix = function(n) {\\n    \\n    let output = new Array(n).fill(0).map(() => new Array(n).fill(0))\\n    \\n    let count = 0;\\n    \\n    let size = n * n;\\n    \\n    let left = 0;\\n    \\n    let right = n - 1;\\n    \\n    let top = 0;\\n    \\n    let bottom = n -1;\\n    \\n    while(count < size){\\n        \\n        //going left\\n        for(let i = left; i <= right; i++){\\n            count++;\\n            output[top][i] = count;\\n        }\\n        top++;\\n                \\n        // going down\\n        for(let i = top; i <= bottom; i++){\\n            count++;\\n            output[i][right] = count;\\n        }\\n        right--;\\n        \\n        //going left\\n        for(let i = right; i >= left; i--){\\n            count++;\\n            output[bottom][i] = count;\\n        }\\n        bottom--;\\n        \\n        //going up\\n        for(let i = bottom; i >= top; i--){\\n            count++;\\n            output[i][left] = count;\\n        }\\n        left++;\\n    }\\n    \\n    return output;\\n    \\n};\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateMatrix = function(n) {\\n    \\n    let output = new Array(n).fill(0).map(() => new Array(n).fill(0))\\n    \\n    let count = 0;\\n    \\n    let size = n * n;\\n    \\n    let left = 0;\\n    \\n    let right = n - 1;\\n    \\n    let top = 0;\\n    \\n    let bottom = n -1;\\n    \\n    while(count < size){\\n        \\n        //going left\\n        for(let i = left; i <= right; i++){\\n            count++;\\n            output[top][i] = count;\\n        }\\n        top++;\\n                \\n        // going down\\n        for(let i = top; i <= bottom; i++){\\n            count++;\\n            output[i][right] = count;\\n        }\\n        right--;\\n        \\n        //going left\\n        for(let i = right; i >= left; i--){\\n            count++;\\n            output[bottom][i] = count;\\n        }\\n        bottom--;\\n        \\n        //going up\\n        for(let i = bottom; i >= top; i--){\\n            count++;\\n            output[i][left] = count;\\n        }\\n        left++;\\n    }\\n    \\n    return output;\\n    \\n};\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22295,
                "title": "java-simple-and-clear-easy-understood",
                "content": "```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // similar to spiral matrix I,done by myself\\n        int[][] rs = new int[n][n];\\n        int top = 0,bottom = n-1,left = 0,right = n-1;\\n        int num = 1;\\n        \\n        while(left<=right && top <=bottom){\\n            for(int i=left;i<=right;i++){\\n                rs[top][i] = num++;\\n            }\\n            top++;\\n            for(int i= top;i<=bottom;i++){\\n                rs[i][right] = num++;\\n            }\\n            right--;\\n            for(int i= right;i>=left;i-- ){\\n                rs[bottom][i] = num++;\\n            }\\n            bottom--;\\n            for(int i = bottom;i>=top;i--){\\n                rs[i][left] = num++;\\n            }\\n            left++;\\n        }\\n        return rs;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // similar to spiral matrix I,done by myself\\n        int[][] rs = new int[n][n];\\n        int top = 0,bottom = n-1,left = 0,right = n-1;\\n        int num = 1;\\n        \\n        while(left<=right && top <=bottom){\\n            for(int i=left;i<=right;i++){\\n                rs[top][i] = num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1738824,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        let map = [Int](repeating: -1, count: n)\\n        var res = [[Int]](repeating: map, count: n)\\n        let grid = (n * n)\\n        var top = 0, btm = n - 1, lhs = 0, rhs = (n - 1)\\n        var elm = 1\\n        \\n        while elm <= grid {\\n            if lhs <= rhs && elm <= grid { // left -> right\\n                for i in lhs...rhs {\\n                    res[top][i] = elm\\n                    elm += 1\\n                }\\n                top += 1\\n            }\\n            if top <= btm && elm <= grid { // top -> bottom\\n                for i in top...btm {\\n                    res[i][rhs] =  elm\\n                    elm += 1\\n                }\\n                rhs -= 1\\n            }\\n            if lhs <= rhs && elm <= grid { // right -> left\\n                for i in (lhs...rhs).reversed() {\\n                    res[btm][i] = elm\\n                    elm +=  1\\n                }\\n                btm -= 1\\n            }\\n            if top <= btm && elm <= grid { // bottom -> top\\n                for i in (top...btm).reversed() {\\n                    res[i][lhs] = elm\\n                    elm += 1\\n                }\\n                lhs += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateMatrix(3)\\n        XCTAssertEqual(value, [[1,2,3],[8,9,4],[7,6,5]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateMatrix(1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        let map = [Int](repeating: -1, count: n)\\n        var res = [[Int]](repeating: map, count: n)\\n        let grid = (n * n)\\n        var top = 0, btm = n - 1, lhs = 0, rhs = (n - 1)\\n        var elm = 1\\n        \\n        while elm <= grid {\\n            if lhs <= rhs && elm <= grid { // left -> right\\n                for i in lhs...rhs {\\n                    res[top][i] = elm\\n                    elm += 1\\n                }\\n                top += 1\\n            }\\n            if top <= btm && elm <= grid { // top -> bottom\\n                for i in top...btm {\\n                    res[i][rhs] =  elm\\n                    elm += 1\\n                }\\n                rhs -= 1\\n            }\\n            if lhs <= rhs && elm <= grid { // right -> left\\n                for i in (lhs...rhs).reversed() {\\n                    res[btm][i] = elm\\n                    elm +=  1\\n                }\\n                btm -= 1\\n            }\\n            if top <= btm && elm <= grid { // bottom -> top\\n                for i in (top...btm).reversed() {\\n                    res[i][lhs] = elm\\n                    elm += 1\\n                }\\n                lhs += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateMatrix(3)\\n        XCTAssertEqual(value, [[1,2,3],[8,9,4],[7,6,5]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateMatrix(1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941149,
                "title": "c-easy-to-understand-solved-live-on-stream",
                "content": "Pretty straight forward.  No special algo.  \\nWe solve problems EVERYDAY 6pm PT.  There are dozens of us.\\n**Link in profile**\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        \\n        int top = 0;\\n        int bot = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int dir = 0; \\n        int num = 1;\\n        \\n        while(top <= bot && left <= right) {\\n            if(dir == 0) {\\n                for(int c = left; c <= right; c++) {\\n                    matrix[top][c] = num++;\\n                }\\n                dir++;\\n                top++;\\n            } else if (dir == 1) {\\n                for(int r = top; r <= bot; r++) {\\n                    matrix[r][right] = num++;\\n                }\\n                dir++;\\n                right--;\\n            } else if (dir == 2) {\\n                for(int c = right; c >= left; c--) {\\n                    matrix[bot][c] = num++;\\n                }\\n                dir++;\\n                bot--;\\n            } else if (dir == 3) {\\n                for(int r = bot; r >= top; r--){\\n                    matrix[r][left] = num++;\\n                }\\n                dir = 0;\\n                left++;\\n            }\\n        }      \\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        \\n        int top = 0;\\n        int bot = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int dir = 0; \\n        int num = 1;\\n        \\n        while(top <= bot && left <= right) {\\n            if(dir == 0) {\\n                for(int c = left; c <= right; c++) {\\n                    matrix[top][c] = num++;\\n                }\\n                dir++;\\n                top++;\\n            } else if (dir == 1) {\\n                for(int r = top; r <= bot; r++) {\\n                    matrix[r][right] = num++;\\n                }\\n                dir++;\\n                right--;\\n            } else if (dir == 2) {\\n                for(int c = right; c >= left; c--) {\\n                    matrix[bot][c] = num++;\\n                }\\n                dir++;\\n                bot--;\\n            } else if (dir == 3) {\\n                for(int r = bot; r >= top; r--){\\n                    matrix[r][left] = num++;\\n                }\\n                dir = 0;\\n                left++;\\n            }\\n        }      \\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912550,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        let count = n / 2\\n        var num = 1\\n        \\n        for i in 0..<count {\\n            var index = 0\\n            for j in i..<(n - i - 1) {\\n                \\n                let i1 = i\\n                let j1 = j\\n                matrix[i1][j1] =  num + j - i\\n                \\n                let i2 = j\\n                let j2 = n - i - 1\\n                matrix[i2][j2] =  num + j + (n - i * 2 - 1) * 1 - i\\n                \\n                let i3 = n - i - 1\\n                let j3 = n - j - 1\\n                matrix[i3][j3] =  num + j + (n - i * 2 - 1) * 2 - i\\n                \\n                let i4 = n - j - 1\\n                let j4 = i\\n                matrix[i4][j4] =  num + j + (n - i * 2 - 1) * 3 - i\\n                index += 4\\n            }\\n            num += index\\n        }\\n        \\n        if n % 2 == 1 { matrix[(n - 1) / 2][(n - 1) / 2] = n * n }\\n        return matrix\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        let count = n / 2\\n        var num = 1\\n        \\n        for i in 0..<count {\\n            var index = 0\\n            for j in i..<(n - i - 1) {\\n                \\n                let i1 = i\\n                let j1 = j\\n                matrix[i1][j1] =  num + j - i\\n                \\n                let i2 = j\\n                let j2 = n - i - 1\\n                matrix[i2][j2] =  num + j + (n - i * 2 - 1) * 1 - i\\n                \\n                let i3 = n - i - 1\\n                let j3 = n - j - 1\\n                matrix[i3][j3] =  num + j + (n - i * 2 - 1) * 2 - i\\n                \\n                let i4 = n - j - 1\\n                let j4 = i\\n                matrix[i4][j4] =  num + j + (n - i * 2 - 1) * 3 - i\\n                index += 4\\n            }\\n            num += index\\n        }\\n        \\n        if n % 2 == 1 { matrix[(n - 1) / 2][(n - 1) / 2] = n * n }\\n        return matrix\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705624,
                "title": "java-dfs-recursive",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        var m = new int[n][n];\\n        dfs(m, 0, 0, false, 1);\\n        return m;\\n    }\\n    private void dfs(int[][] m, int row, int col, boolean goup,int count) {\\n        if (row < 0 || col < 0 || col >= m[0].length || row >= m.length || m[row][col] != 0) return;\\n        m[row][col] = count;\\n        count++;\\n        if (goup) dfs(m, row-1, col, true, count);\\n        dfs(m, row, col+1, false, count);\\n        dfs(m, row + 1, col, false, count);\\n        dfs(m, row, col-1, false, count);\\n        dfs(m, row-1, col, true, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        var m = new int[n][n];\\n        dfs(m, 0, 0, false, 1);\\n        return m;\\n    }\\n    private void dfs(int[][] m, int row, int col, boolean goup,int count) {\\n        if (row < 0 || col < 0 || col >= m[0].length || row >= m.length || m[row][col] != 0) return;\\n        m[row][col] = count;\\n        count++;\\n        if (goup) dfs(m, row-1, col, true, count);\\n        dfs(m, row, col+1, false, count);\\n        dfs(m, row + 1, col, false, count);\\n        dfs(m, row, col-1, false, count);\\n        dfs(m, row-1, col, true, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507200,
                "title": "single-loop-java-solution-easy-to-understand-0-ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int x = 1,cnt = 0;\\n        int[][] ans = new int[n][n];\\n        int i = 0,j = 0,k = 0;\\n        while(cnt < (n * n)){\\n            i(ans[i][j] == 0){\\n                ans[i][j] = x++;\\n                if(i == k && j < n - 1 - k) j++;\\n                else if(j == n - 1 - k && i < n - 1 - k) i++;\\n                else if(i == n - 1 - k && j <= n - 1 - k && j != k) j--;\\n                else if(i <= n - 1 - k && j == k) i--;\\n                cnt++;\\n            }else{ \\n                k++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int x = 1,cnt = 0;\\n        int[][] ans = new int[n][n];\\n        int i = 0,j = 0,k = 0;\\n        while(cnt < (n * n)){\\n            i(ans[i][j] == 0){\\n                ans[i][j] = x++;\\n                if(i == k && j < n - 1 - k) j++;\\n                else if(j == n - 1 - k && i < n - 1 - k) i++;\\n                else if(i == n - 1 - k && j <= n - 1 - k && j != k) j--;\\n                else if(i <= n - 1 - k && j == k) i--;\\n                cnt++;\\n            }else{ \\n                k++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941021,
                "title": "javascript-neat-3-methods-elegant-math-no-if",
                "content": "## 1. Elegant (optimized 2nd approach)\\n\\n```js\\nconst generateMatrix = (n) => {\\n  const M = [...Array(n)].map(() => Array(n).fill(0));\\n  let x = 0, y = 0, dx = 1, dy = 0;\\n  for (let i = 1, nn = n**2; i <= nn; ++i) {\\n    M[y][x] = i;\\n    if (!M[y + dy] || M[y + dy][x + dx] !== 0)\\n      [dx, dy] = [-dy, dx];\\n    x += dx;\\n    y += dy;\\n  }\\n  return M;\\n};\\n```\\n\\n## 2. Math power\\n\\n```js\\nconst generateMatrix = (n) => {\\n  const {max, abs, floor} = Math;\\n  const num = (x, y) => {\\n    x += x - n + 1;\\n    y += y - n + 1;\\n    const m = max(abs(x), abs(y));\\n    let p = floor((x + y) / 2);\\n    if (x < y) p = 2 * m - p;\\n    return n * n - m * m - m + p;\\n  }\\n    \\n  const M = [];\\n  for (let y = 0; y < n; ++y) {\\n    M[y] = [];\\n    for (let x = 0; x < n; ++x)\\n      M[y][x] = num(x, y);\\n  }\\n  return M;\\n};\\n```\\n\\n## 3. Without IF\\n\\nThere are the steps in each direction in the spiral for n = 5.\\n`[0, 5, 4, 4, 3, 3, 2, 2, 1, 1]` and for any n `[0, n,  n - 1, n - 1,  ..., 3, 3, 2, 2, 1, 1]`\\nUpdate signs of directions.\\n`[0, 5, 4, -4, -3, 3, 2, -2, -1, 1]`\\n\\n```js\\nconst generateMatrix = (n) => {    \\n  const M = [...Array(n)].map(() => Array(n));\\n  let v = 0, x = -1, y = 0;\\n  for (let i = 0, m, s, dx, dy; i < 2*n; ++i) {\\n    m = i && (2*n - i + 1) / 2|0;\\n    s = (-1)**((i - 1)/2|0);\\n    dx = s * (i % 2);\\n    dy = s * ((i + 1) % 2);\\n    for (let j = 0; j < m; ++j) {\\n      x += dx;\\n      y += dy;\\n      M[y][x] = ++v;\\n    }\\n  }\\n  return M;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst generateMatrix = (n) => {\\n  const M = [...Array(n)].map(() => Array(n).fill(0));\\n  let x = 0, y = 0, dx = 1, dy = 0;\\n  for (let i = 1, nn = n**2; i <= nn; ++i) {\\n    M[y][x] = i;\\n    if (!M[y + dy] || M[y + dy][x + dx] !== 0)\\n      [dx, dy] = [-dy, dx];\\n    x += dx;\\n    y += dy;\\n  }\\n  return M;\\n};\\n```\n```js\\nconst generateMatrix = (n) => {\\n  const {max, abs, floor} = Math;\\n  const num = (x, y) => {\\n    x += x - n + 1;\\n    y += y - n + 1;\\n    const m = max(abs(x), abs(y));\\n    let p = floor((x + y) / 2);\\n    if (x < y) p = 2 * m - p;\\n    return n * n - m * m - m + p;\\n  }\\n    \\n  const M = [];\\n  for (let y = 0; y < n; ++y) {\\n    M[y] = [];\\n    for (let x = 0; x < n; ++x)\\n      M[y][x] = num(x, y);\\n  }\\n  return M;\\n};\\n```\n```js\\nconst generateMatrix = (n) => {    \\n  const M = [...Array(n)].map(() => Array(n));\\n  let v = 0, x = -1, y = 0;\\n  for (let i = 0, m, s, dx, dy; i < 2*n; ++i) {\\n    m = i && (2*n - i + 1) / 2|0;\\n    s = (-1)**((i - 1)/2|0);\\n    dx = s * (i % 2);\\n    dy = s * ((i + 1) % 2);\\n    for (let j = 0; j < m; ++j) {\\n      x += dx;\\n      y += dy;\\n      M[y][x] = ++v;\\n    }\\n  }\\n  return M;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963337,
                "title": "c-100-simple-walk-the-spiral-solution",
                "content": "My C++ walk the spiral solution going clockwise from outside to inside\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // create n * n vector of vectors we will populate and return at the end\\n        vector<vector<int>> result(n, vector<int>(n));\\n        \\n        // calculate how many levels deep the spiral is and keep count of walking the spiral\\n        int level = ceil(n / 2), count = 1;\\n        \\n        // start from outside level moving inside\\n        for (int l = 0; l <= level; ++l) {\\n            // populate top row from left to right\\n            for (int a = l; a < n - l; ++a) result[l][a] = count++;\\n            \\n            // populate right column from top to bottom\\n            for (int b = l + 1; b < n - l; ++b) result[b][n - l - 1] = count++;\\n            \\n            // populate bottom row from right to left\\n            for (int c = l + 1; c < n - l; ++c) result[n - l - 1][n - c - 1] = count++;\\n            \\n            // populate left column from bottom to top\\n            for (int d = l + 1; d < n - l - 1; ++d) result[n - d - 1][l] = count++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // create n * n vector of vectors we will populate and return at the end\\n        vector<vector<int>> result(n, vector<int>(n));\\n        \\n        // calculate how many levels deep the spiral is and keep count of walking the spiral\\n        int level = ceil(n / 2), count = 1;\\n        \\n        // start from outside level moving inside\\n        for (int l = 0; l <= level; ++l) {\\n            // populate top row from left to right\\n            for (int a = l; a < n - l; ++a) result[l][a] = count++;\\n            \\n            // populate right column from top to bottom\\n            for (int b = l + 1; b < n - l; ++b) result[b][n - l - 1] = count++;\\n            \\n            // populate bottom row from right to left\\n            for (int c = l + 1; c < n - l; ++c) result[n - l - 1][n - c - 1] = count++;\\n            \\n            // populate left column from bottom to top\\n            for (int d = l + 1; d < n - l - 1; ++d) result[n - d - 1][l] = count++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22473,
                "title": "share-my-simple-solution-with-graphical-explanation-java",
                "content": "If n is odd, only the first direction will cover it (top left -> right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1).\\n\\n    /**\\n    \\t * -> -> ->\\n    \\t * ^      |\\n    \\t * |      |\\n    \\t * <- <-- V\\n    \\t * \\n    \\t * # # # #\\n    \\t * %     $\\n    \\t * %     $\\n    \\t * & & & $\\n    \\t *     \\n    \\t */\\n        public static int[][] generateMatrix(int n) {\\n        \\tint[][] res = new int[n][n];\\n        \\t\\n        \\tint num = 1;\\n        \\tint level = (int) Math.ceil(n / 2.);\\n        \\t\\n        \\tfor(int i = 0; i < level; i++) {\\n        \\t\\t\\n        \\t\\t// top left -> right, shown as #\\n        \\t\\tfor(int j = i; j < n - i; j++)\\n        \\t\\t\\tres[i][j] = num++;\\n        \\t\\t\\n        \\t\\t// top right + 1 -> bot, shown as $\\n        \\t\\tfor(int j = i + 1; j < n - i; j++)\\n        \\t\\t\\tres[j][n - i - 1] = num++;\\n        \\t\\t\\n        \\t\\t// bot right - 1 -> left, shown as &\\n        \\t\\tfor(int j = n - i - 2; j >= i; j--)\\n        \\t\\t\\tres[n - i - 1][j] = num++;\\n        \\t\\t\\n        \\t\\t// bot left -1 -> top + 1, shown as %\\n        \\t\\tfor(int j = n - i - 2; j > i; j--)\\n        \\t\\t\\tres[j][i] = num++;\\n        \\t}\\n        \\treturn res;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "If n is odd, only the first direction will cover it (top left -> right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1).\\n\\n    /**\\n    \\t * -> -> ->\\n    \\t * ^      |\\n    \\t * |      |\\n    \\t * <- <-- V\\n    \\t * \\n    \\t * # # # #\\n    \\t * %     $\\n    \\t * %     $\\n    \\t * & & & $\\n    \\t *     \\n    \\t */\\n        public static int[][] generateMatrix(int n) {\\n        \\tint[][] res = new int[n][n];\\n        \\t\\n        \\tint num = 1;\\n        \\tint level = (int) Math.ceil(n / 2.);\\n        \\t\\n        \\tfor(int i = 0; i < level; i++) {\\n        \\t\\t\\n        \\t\\t// top left -> right, shown as #\\n        \\t\\tfor(int j = i; j < n - i; j++)\\n        \\t\\t\\tres[i][j] = num++;\\n        \\t\\t\\n        \\t\\t// top right + 1 -> bot, shown as $\\n        \\t\\tfor(int j = i + 1; j < n - i; j++)\\n        \\t\\t\\tres[j][n - i - 1] = num++;\\n        \\t\\t\\n        \\t\\t// bot right - 1 -> left, shown as &\\n        \\t\\tfor(int j = n - i - 2; j >= i; j--)\\n        \\t\\t\\tres[n - i - 1][j] = num++;\\n        \\t\\t\\n        \\t\\t// bot left -1 -> top + 1, shown as %\\n        \\t\\tfor(int j = n - i - 2; j > i; j--)\\n        \\t\\t\\tres[j][i] = num++;\\n        \\t}\\n        \\treturn res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3507105,
                "title": "simple-java-solution-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStarting from the top left corner and moving clockwise. It traverse by filling the top row, right column, bottom row, and left column of the matrix in sequence until the entire matrix is filled.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a 2D array of size n x n with all elements set to 0.\\n- Use four variables l, t, b, and r to keep track of the boundaries of the matrix.\\n- Use a while loop that continues until either t becomes greater than b or l becomes greater than r, indicating that the entire matrix has been filled.\\n- Use four nested if statements, each of which generates a segment of the spiral by iterating through the appropriate row or column and assigning values to the matrix elements.\\n- After each segment is generated, update the corresponding boundary variables to exclude the row or column that has been filled.\\n- Return the resulting matrix.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] a = new int[n][n];\\n        int l=0,t=0,b=n-1,r=n-1,v=1;\\n        while(t<=b||l<=r){\\n         if(t<=b){\\n             for(int i=l;i<=r;i++)\\n                a[t][i]=v++;\\n             t++;\\n         }\\n         if(l<=r){\\n             for(int i=t;i<=b;i++)\\n                 a[i][r]=v++;\\n             r--;\\n         }\\n         if(t<=b){\\n             for(int i=r;i>=l;i--)\\n             a[b][i]=v++;\\n             b--;\\n         }\\n         if(t<=b){\\n             for(int i=b;i>=t;i--)\\n             a[i][l]=v++;\\n         }\\n         l++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] a = new int[n][n];\\n        int l=0,t=0,b=n-1,r=n-1,v=1;\\n        while(t<=b||l<=r){\\n         if(t<=b){\\n             for(int i=l;i<=r;i++)\\n                a[t][i]=v++;\\n             t++;\\n         }\\n         if(l<=r){\\n             for(int i=t;i<=b;i++)\\n                 a[i][r]=v++;\\n             r--;\\n         }\\n         if(t<=b){\\n             for(int i=r;i>=l;i--)\\n             a[b][i]=v++;\\n             b--;\\n         }\\n         if(t<=b){\\n             for(int i=b;i>=t;i--)\\n             a[i][l]=v++;\\n         }\\n         l++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506353,
                "title": "c-beats-100-solution-t-c-o-n-n-fully-explained-step-by-step",
                "content": "\\n# Approach\\n1.Here we have a sqare matrix of size n*n;\\n2.declare variables like starting top=0, right= n-1, left=0, bottom= n-1 and a =1.\\n3.declare count=0 and check it at every moment that it is less than and equal to end.\\nfirst we will print first row, by moving from left to right. and increase top by 1, so that we can print next row in second iteration and insert value in vector and increase by 1.\\nThen, we will print last column, by moving from top to bottom and decrease right by 1 so that we can to next inner col and insert value in vector and increase by 1.\\nthen we will print last row, by moving from right to left. and decrease bottom by 1, so that we can move to next inner row in next iteration and insert value in vector and increase by 1.\\nthen we will print first col, by moving from bottom to top, and increase left by 1, so that we can move to next col in next iteration and insert value in vector and increase by 1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>res(n,vector<int>(n));\\n        int top=0;int left=0;\\n        int right=n-1;int bottom=n-1;\\n        int a=1;\\n        while(top<=bottom && left<=right){\\n            for(int i=left;i<=right;i++){//top\\n                \\n                res[top][i]=a;\\n                a++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){//right\\n                res[i][right]=a;\\n                a++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){//bottom in reverse\\n                res[bottom][i]=a;\\n                a++;\\n            }\\n            bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){//left in reverse\\n                res[i][left]=a;\\n                a++;\\n            }\\n            left++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>res(n,vector<int>(n));\\n        int top=0;int left=0;\\n        int right=n-1;int bottom=n-1;\\n        int a=1;\\n        while(top<=bottom && left<=right){\\n            for(int i=left;i<=right;i++){//top\\n                \\n                res[top][i]=a;\\n                a++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){//right\\n                res[i][right]=a;\\n                a++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){//bottom in reverse\\n                res[bottom][i]=a;\\n                a++;\\n            }\\n            bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){//left in reverse\\n                res[i][left]=a;\\n                a++;\\n            }\\n            left++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202560,
                "title": "spiral-matrix-i-ii-iii-iv-solutions",
                "content": "# Explaination\\n- This is a very simple and easy to understand solution. I have traversed RIGHT and incremented TOP, then traverse DOWN and decrement RIGHT, then I traverse LEFT and decrement BOTTOM, and finally I have traversed UP and increment LEFT.\\n\\n- The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. \\nAny comments greatly appreciated.\\n\\n# Complexity\\n- Time Complexity: O(m*n)\\n- Space Complexity: O(1)\\n\\n# Spiral Matrix I\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Spiral Matrix II\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Spiral Matrix III\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Sprial Matrix IV\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309475,
                "title": "easy-java-solution-beats-100-online-java-submissions",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n       int[][] ans=new int[n][n];\\n       \\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        int counter=0;\\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && counter<=n*n){\\n            \\n            for(int i=columnBegin;i<=columnEnd;i++){\\n                counter++;\\n                ans[rowBegin][i]=counter;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                counter++;\\n                ans[i][columnEnd]=counter;\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin;i--){\\n                counter++;\\n                ans[rowEnd][i]=counter;\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                counter++;    \\n                ans[i][columnBegin]=counter;\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n       int[][] ans=new int[n][n];\\n       \\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        int counter=0;\\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && counter<=n*n){\\n            \\n            for(int i=columnBegin;i<=columnEnd;i++){\\n                counter++;\\n                ans[rowBegin][i]=counter;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                counter++;\\n                ans[i][columnEnd]=counter;\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin;i--){\\n                counter++;\\n                ans[rowEnd][i]=counter;\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                counter++;    \\n                ans[i][columnBegin]=counter;\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941152,
                "title": "c-two-pointer-approach",
                "content": "```\\nAlgorithm\\n---------\\n* Step1: Initialize beg = 0 and end  = n - 1\\n* Step2: Repeat Step3 to Step7 while beg < end\\n* Step3: Fill current first row(beg) from left-right\\n* Step4: Fill current last column(end) from top-bottom\\n* Step5: Fill current last row(end) from right-left\\n* Step6: Fill current first column(beg) from bottom-top\\n* Step7: Increment beg and decrement end\\n* Step8: Go to Step2\\n* Step9: Fill the cell[beg][end] if beg == end\\n* Step10: Return matrix\\n\\nComplexities\\n------------\\n* Time: O(n*n)\\n* Space: O(1)\\n\\nNote: Since, the matrix is square, we can traverse it spirally by using just 2 pointers.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        \\n        int beg = 0, end = n - 1, temp = -1, ptr = 1;\\n        while(beg < end) {\\n            // fill left to right\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[beg][temp++] = ptr++;\\n            }\\n            \\n            // fill top to bottom\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[temp++][end] = ptr++;\\n            }\\n            \\n            //fill right to left\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[end][temp--] = ptr++;\\n            }\\n            \\n            //fill bottom to top\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[temp--][beg] = ptr++;\\n            }\\n            beg++;\\n            end--;\\n        }\\n        \\n        // for odd n\\n        if(beg == end) matrix[beg][end] = ptr;\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAlgorithm\\n---------\\n* Step1: Initialize beg = 0 and end  = n - 1\\n* Step2: Repeat Step3 to Step7 while beg < end\\n* Step3: Fill current first row(beg) from left-right\\n* Step4: Fill current last column(end) from top-bottom\\n* Step5: Fill current last row(end) from right-left\\n* Step6: Fill current first column(beg) from bottom-top\\n* Step7: Increment beg and decrement end\\n* Step8: Go to Step2\\n* Step9: Fill the cell[beg][end] if beg == end\\n* Step10: Return matrix\\n\\nComplexities\\n------------\\n* Time: O(n*n)\\n* Space: O(1)\\n\\nNote: Since, the matrix is square, we can traverse it spirally by using just 2 pointers.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        \\n        int beg = 0, end = n - 1, temp = -1, ptr = 1;\\n        while(beg < end) {\\n            // fill left to right\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[beg][temp++] = ptr++;\\n            }\\n            \\n            // fill top to bottom\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[temp++][end] = ptr++;\\n            }\\n            \\n            //fill right to left\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[end][temp--] = ptr++;\\n            }\\n            \\n            //fill bottom to top\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[temp--][beg] = ptr++;\\n            }\\n            beg++;\\n            end--;\\n        }\\n        \\n        // for odd n\\n        if(beg == end) matrix[beg][end] = ptr;\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791511,
                "title": "python-simple-logic",
                "content": "We can move in 4 directions:\\nIf direction == 0: Move from left to right in top row\\nIf direction == 1: Move from top to bottom in right column\\nIf direction == 2: Move from right to left in bottom row\\nIf direction == 3: Move from bottom to top in left column\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        if n == 1:\\n            return [[1]]\\n        \\n        ans = [[0]* n for _ in range(n)]\\n        \\n        left, right = 0, n-1\\n        top, bottom = 0, n-1\\n        \\n        k = 1\\n        direction = 0\\n        \\n        while left <= right and top <= bottom:\\n            # from left to right in top row\\n            if direction == 0:\\n                for j in range(left, right+1):\\n                    ans[top][j] = k\\n                    k += 1\\n                top += 1\\n                direction = 1\\n            elif direction == 1:\\n                # from top to bottom in right column\\n                for i in range(top, bottom+1):\\n                    ans[i][right] = k\\n                    k += 1\\n                right -= 1\\n                direction = 2\\n            elif direction == 2:\\n                # from right to left in bottom row\\n                for j in range(right, left-1, -1):\\n                    ans[bottom][j] = k\\n                    k += 1\\n                bottom -= 1\\n                direction = 3\\n            else:\\n                # bottom to top in left column\\n                for i in range(bottom, top-1, -1):\\n                    ans[i][left] = k\\n                    k += 1\\n                left += 1\\n                direction = 0\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "We can move in 4 directions:\\nIf direction == 0: Move from left to right in top row\\nIf direction == 1: Move from top to bottom in right column\\nIf direction == 2: Move from right to left in bottom row\\nIf direction == 3: Move from bottom to top in left column\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        if n == 1:\\n            return [[1]]\\n        \\n        ans = [[0]* n for _ in range(n)]\\n        \\n        left, right = 0, n-1\\n        top, bottom = 0, n-1\\n        \\n        k = 1\\n        direction = 0\\n        \\n        while left <= right and top <= bottom:\\n            # from left to right in top row\\n            if direction == 0:\\n                for j in range(left, right+1):\\n                    ans[top][j] = k\\n                    k += 1\\n                top += 1\\n                direction = 1\\n            elif direction == 1:\\n                # from top to bottom in right column\\n                for i in range(top, bottom+1):\\n                    ans[i][right] = k\\n                    k += 1\\n                right -= 1\\n                direction = 2\\n            elif direction == 2:\\n                # from right to left in bottom row\\n                for j in range(right, left-1, -1):\\n                    ans[bottom][j] = k\\n                    k += 1\\n                bottom -= 1\\n                direction = 3\\n            else:\\n                # bottom to top in left column\\n                for i in range(bottom, top-1, -1):\\n                    ans[i][left] = k\\n                    k += 1\\n                left += 1\\n                direction = 0\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 22381,
                "title": "7-line-python-solution-step-pattern-is-n-n-1-n-1-n-2-n-2-2-2-1-1",
                "content": "If `n` is 5, `step` list will be [5, 4, 4, 3, 3, 2, 2, 1, 1], it means move forward 5 steps, turn right, move forward 4 steps, turn right, move forward 4 steps, turn right and so on. `x` axis is from left to right, `y` axis is from top to bottom, we start from point `(-1, 0)`.\\n\\n    def generateMatrix(self, n):\\n        mat, x, y, dx, dy, number = [[0] * n for i in xrange(n)], -1, 0, 1, 0, 0\\n        for step in [i / 2 for i in xrange(2 * n, 1, -1)]:\\n            for j in xrange(step):\\n                x, y, number = x + dx, y + dy, number + 1\\n                mat[y][x] = number\\n            dx, dy = -dy, dx # turn right\\n        return mat",
                "solutionTags": [
                    "Python"
                ],
                "code": "If `n` is 5, `step` list will be [5, 4, 4, 3, 3, 2, 2, 1, 1], it means move forward 5 steps, turn right, move forward 4 steps, turn right, move forward 4 steps, turn right and so on. `x` axis is from left to right, `y` axis is from top to bottom, we start from point `(-1, 0)`.\\n\\n    def generateMatrix(self, n):\\n        mat, x, y, dx, dy, number = [[0] * n for i in xrange(n)], -1, 0, 1, 0, 0\\n        for step in [i / 2 for i in xrange(2 * n, 1, -1)]:\\n            for j in xrange(step):\\n                x, y, number = x + dx, y + dy, number + 1\\n                mat[y][x] = number\\n            dx, dy = -dy, dx # turn right\\n        return mat",
                "codeTag": "Python3"
            },
            {
                "id": 3516518,
                "title": "easy-java-solution-with-proper-explanation-beats-100-in-tc",
                "content": "![Screenshot 2023-05-12 at 18.46.26.png](https://assets.leetcode.com/users/images/bb2248b9-f6b1-48ee-92ec-27c3e3612f5b_1683902818.4458783.png)\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code initializes an n x n matrix with all elements set to zero. It then uses four variables t, b, l, and r to keep track of the boundaries of the current spiral. It starts filling the matrix by traversing from left to right along the top boundary, then from top to bottom along the right boundary, then from right to left along the bottom boundary, and finally from bottom to top along the left boundary. It repeats this process until all elements have been filled in the matrix. Finally, it returns the filled matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        int[][] arr = new int[n][n];\\n        int b = n, r = n;\\n        int t = 0, l = 0, size = b*r,s=1;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                arr[t][i]=s++;\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                arr[i][r-1] = s++;\\n            }\\n            r--;\\n\\n            for (int i = r-1; i >= l; i--) {\\n                arr[b-1][i] = s++;\\n            }\\n            b--;\\n\\n            for (int i = b-1; i >= t; i--) {\\n                arr[i][l]=s++;\\n            }\\n            l++;\\n\\n\\n        }\\n        return arr;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        int[][] arr = new int[n][n];\\n        int b = n, r = n;\\n        int t = 0, l = 0, size = b*r,s=1;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                arr[t][i]=s++;\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                arr[i][r-1] = s++;\\n            }\\n            r--;\\n\\n            for (int i = r-1; i >= l; i--) {\\n                arr[b-1][i] = s++;\\n            }\\n            b--;\\n\\n            for (int i = b-1; i >= t; i--) {\\n                arr[i][l]=s++;\\n            }\\n            l++;\\n\\n\\n        }\\n        return arr;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509960,
                "title": "java-spiral-matrix-2",
                "content": "\\n```\\nclass Solution {\\n    public static void spiralOrder(int[][] matrix) {\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        int ch = 1;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] == 0) {\\n                    matrix[x][y] = ch++;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n\\n    public static int[][] generateMatrix(int n) {\\n        int matrix[][] = new int[n][n];\\n        spiralOrder(matrix);\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void spiralOrder(int[][] matrix) {\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        int ch = 1;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] == 0) {\\n                    matrix[x][y] = ch++;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n\\n    public static int[][] generateMatrix(int n) {\\n        int matrix[][] = new int[n][n];\\n        spiralOrder(matrix);\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506563,
                "title": "simple-clean-beats-100",
                "content": "# Intuition\\nSimple brute force\\n\\n# Approach\\nWe use left , right , top , bottom pointers to represent the configuration of the matrix.\\nSTEPS of traversal:\\n\\n1. Traverse from left to right , then update top=top+1, AS topmost row is filled.\\n\\n2. Traverse from top to bottom, then update right=right-1, AS rightmost column is filled.\\n\\n3. Traverse from right to left, then update bottom= bottom-1 , AS \\nbottomMost row is filled.\\n\\n 4. Traverse from bottom to top, then update left=left+1, \\n  AS leftmost column is filled.\\n\\n# Complexity\\n- Time complexity:\\n  O(N*N) for traversing the matrix.\\n\\n- Space complexity:\\n  O(N*N) for storing the matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int num=1,left=0,right=n-1,top=0,bottom=n-1;\\n        vector<vector<int>>matrix(n,vector<int>(n));\\n\\n        while(left<=right && top<=bottom){\\n            for(int i=left; i<=right; i++){\\n                matrix[top][i]=num++;\\n            }\\n            top++;\\n\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=num++;\\n            }\\n            right--;\\n\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=num++;\\n            }\\n            bottom--;\\n\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=num++;\\n            }\\n            left++;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int num=1,left=0,right=n-1,top=0,bottom=n-1;\\n        vector<vector<int>>matrix(n,vector<int>(n));\\n\\n        while(left<=right && top<=bottom){\\n            for(int i=left; i<=right; i++){\\n                matrix[top][i]=num++;\\n            }\\n            top++;\\n\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=num++;\\n            }\\n            right--;\\n\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=num++;\\n            }\\n            bottom--;\\n\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=num++;\\n            }\\n            left++;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506487,
                "title": "99-6-javascript-easy-to-understand",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    let save = Array.from(Array(n),()=>new Array(n).fill(0))\\n    let count =1;\\n    let left =0;\\n    let right =n-1;\\n    let bottom = n-1;\\n    let top = 0;\\n    let dir = 0;\\n\\n    while(count <= n*n){\\n        if(dir == 0){\\n            for(let i =left; i<=right; i++){\\n                save[top][i] = count;\\n                count++\\n            }\\n            top++\\n            dir++\\n        }\\n        if(dir == 1){\\n            for(let i =top; i<=bottom; i++){\\n                save[i][right] = count;\\n                count++\\n            }\\n            right--\\n            dir++        \\n        }\\n        if(dir == 2){\\n            for(let i =right; i>=left; i--){\\n                save[bottom][i] = count;\\n                count++\\n            }\\n            bottom--\\n            dir++        \\n        }\\n        if(dir == 3){\\n            for(let i =bottom; i>=top; i--){\\n                save[i][left] = count;\\n                count++\\n            }\\n            left++\\n            dir++        \\n        }\\n        dir = 0;\\n    }\\n\\n    return save;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    let save = Array.from(Array(n),()=>new Array(n).fill(0))\\n    let count =1;\\n    let left =0;\\n    let right =n-1;\\n    let bottom = n-1;\\n    let top = 0;\\n    let dir = 0;\\n\\n    while(count <= n*n){\\n        if(dir == 0){\\n            for(let i =left; i<=right; i++){\\n                save[top][i] = count;\\n                count++\\n            }\\n            top++\\n            dir++\\n        }\\n        if(dir == 1){\\n            for(let i =top; i<=bottom; i++){\\n                save[i][right] = count;\\n                count++\\n            }\\n            right--\\n            dir++        \\n        }\\n        if(dir == 2){\\n            for(let i =right; i>=left; i--){\\n                save[bottom][i] = count;\\n                count++\\n            }\\n            bottom--\\n            dir++        \\n        }\\n        if(dir == 3){\\n            for(let i =bottom; i>=top; i--){\\n                save[i][left] = count;\\n                count++\\n            }\\n            left++\\n            dir++        \\n        }\\n        dir = 0;\\n    }\\n\\n    return save;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1942901,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int x=1;\\n        while(x<=n*n){\\n            for(int i=left;i<=right;i++)\\n                res[top][i]=x++;\\n            top++;\\n            for(int i=top;i<=bottom;i++)\\n                res[i][right]=x++;\\n            right--;\\n            for(int i=right;i>=left;i--)\\n                res[bottom][i]=x++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n                res[i][left]=x++;\\n            left++;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int x=1;\\n        while(x<=n*n){\\n            for(int i=left;i<=right;i++)\\n                res[top][i]=x++;\\n            top++;\\n            for(int i=top;i<=bottom;i++)\\n                res[i][right]=x++;\\n            right--;\\n            for(int i=right;i>=left;i--)\\n                res[bottom][i]=x++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n                res[i][left]=x++;\\n            left++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1855638,
                "title": "simple-c-solution-with-explanation-commented-faster-than-100-00-of-c-online-submissions",
                "content": "Algorithm:\\n\\n* Enter value in starting row (horizonal, left to right)\\n* Enter value in ending column (vertical, top to bottom)\\n* Enter value in ending row (horizonal, right to left)\\n* Enter value in starting column (vertical, bottom to top)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,1));\\n        //index intialisation\\n        int strow=0, stcol=0;\\n        int endrow=n-1,endcol=n-1;\\n        //counters\\n        int cnt=n*n;\\n        int a=1;\\n        \\n        while(a<=cnt){\\n            \\n            //enter value in starting row\\n            for(int i=stcol;i<=endcol&&a<=cnt;i++){\\n                ans[strow][i]=a;\\n                a++;\\n            }\\n            strow++;\\n            \\n            //enter value in ending col\\n            for(int i=strow;i<=endrow&&a<=cnt;i++){\\n                ans[i][endcol]=a;\\n                a++;\\n            }\\n            endcol--;\\n            \\n            //enter value in ending row\\n            for(int i=endcol;i>=stcol&&a<=cnt;i--){\\n                ans[endrow][i]=a;\\n                a++;\\n            }\\n            endrow--;\\n            \\n            //enter value in starting col\\n            for(int i=endrow;i>=strow&&a<=cnt;i--){\\n                ans[i][stcol]=a;\\n                a++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Upvote ++ (if it helps)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,1));\\n        //index intialisation\\n        int strow=0, stcol=0;\\n        int endrow=n-1,endcol=n-1;\\n        //counters\\n        int cnt=n*n;\\n        int a=1;\\n        \\n        while(a<=cnt){\\n            \\n            //enter value in starting row\\n            for(int i=stcol;i<=endcol&&a<=cnt;i++){\\n                ans[strow][i]=a;\\n                a++;\\n            }\\n            strow++;\\n            \\n            //enter value in ending col\\n            for(int i=strow;i<=endrow&&a<=cnt;i++){\\n                ans[i][endcol]=a;\\n                a++;\\n            }\\n            endcol--;\\n            \\n            //enter value in ending row\\n            for(int i=endcol;i>=stcol&&a<=cnt;i--){\\n                ans[endrow][i]=a;\\n                a++;\\n            }\\n            endrow--;\\n            \\n            //enter value in starting col\\n            for(int i=endrow;i>=strow&&a<=cnt;i--){\\n                ans[i][stcol]=a;\\n                a++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999515,
                "title": "python-simple-and-easy-solution",
                "content": "The approach is inspired by [ \"Stefan Pochmann\"](https://leetcode.com/StefanPochmann/)\\n\\nfirst we will push an element in the array\\nthen, rotate the array.\\n\\n(We will start from the 9 upto 1)\\ne.g. for n = 3\\n\\n|9|\\nrotate and push new element\\n|8|\\n|9|\\n\\nrotate and push new elements\\n|6  7|\\n|9  8|\\n\\nrotate and push new elements\\n|4  5|\\n|9  6|\\n|8  7|\\n\\nrotate and push new elements\\n\\n|1  2  3|\\n|8  9  4|\\n|7  6  5|\\n\\n\\n\\n\\n```\\ndef generateMatrix(n):\\n#n = 3 for example\\n    result = []\\n    current = n*n -1  # =  8, for n = 3  \\n    #current will hold the value for inserting\\n    result.append([current + 1]) # first case, Handling first element explicitly result = [[9]]\\n    while current > 1:\\n        result = list(zip(*result[::-1])) # will rotate the array\\n        temp = len(result[0])\\n        # temp will hold the length of the first element of the result i.e. len([9]) i.e. 1\\n        # from temp we would know how many elements we have to push\\n        \\n        result.insert(0,list(range(current-temp+1,current+1)))\\n        #inserting the values on the top of the array\\n        \\n        current = current -temp\\n    return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef generateMatrix(n):\\n#n = 3 for example\\n    result = []\\n    current = n*n -1  # =  8, for n = 3  \\n    #current will hold the value for inserting\\n    result.append([current + 1]) # first case, Handling first element explicitly result = [[9]]\\n    while current > 1:\\n        result = list(zip(*result[::-1])) # will rotate the array\\n        temp = len(result[0])\\n        # temp will hold the length of the first element of the result i.e. len([9]) i.e. 1\\n        # from temp we would know how many elements we have to push\\n        \\n        result.insert(0,list(range(current-temp+1,current+1)))\\n        #inserting the values on the top of the array\\n        \\n        current = current -temp\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22337,
                "title": "simplest-c-solution-easy-and-clear-have-a-look",
                "content": "comments will be highly appreciated . \\n\\n    vector<vector<int>> generateMatrix(int n) {\\n            // 2d vector initialization  vector<vector<int>> myvec(rowsize,vector<int>(colsize,0));\\n            vector<vector<int>> res(n,vector<int>(n,0));\\n            if(!n) return res;\\n            \\n            int l=0,r=n-1,t=0,b=n-1,limit=n*n+1;  // l=left column , r=right column , t=top row, b=bottom row \\n            int count=1;\\n            \\n            while(count<limit){         // loop until count == n*n \\n                for(int i=l;i<=r;i++) res[t][i]=count++; // process top row\\n                t++;\\n                for(int i=t;i<=b;i++) res[i][r]=count++; // process right column\\n                r--;\\n                if(count==limit) break;         // termination condition to avoid overwritting          \\n                for(int i=r; i>=l;i--) res[b][i]=count++; // process bottom row\\n                b--;\\n                for(int i=b;i>=t;i--) res[i][l]=count++;  //process left column\\n                l++;\\n            }\\n            \\n           return res;\\n        }",
                "solutionTags": [],
                "code": "comments will be highly appreciated . \\n\\n    vector<vector<int>> generateMatrix(int n) {\\n            // 2d vector initialization  vector<vector<int>> myvec(rowsize,vector<int>(colsize,0));\\n            vector<vector<int>> res(n,vector<int>(n,0));\\n            if(!n) return res;\\n            \\n            int l=0,r=n-1,t=0,b=n-1,limit=n*n+1;  // l=left column , r=right column , t=top row, b=bottom row \\n            int count=1;\\n            \\n            while(count<limit){         // loop until count == n*n \\n                for(int i=l;i<=r;i++) res[t][i]=count++; // process top row\\n                t++;\\n                for(int i=t;i<=b;i++) res[i][r]=count++; // process right column\\n                r--;\\n                if(count==limit) break;         // termination condition to avoid overwritting          \\n                for(int i=r; i>=l;i--) res[b][i]=count++; // process bottom row\\n                b--;\\n                for(int i=b;i>=t;i--) res[i][l]=count++;  //process left column\\n                l++;\\n            }\\n            \\n           return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3510009,
                "title": "c-spiral-arrangement-of-the-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int i, j, o, k, num;\\n        vector<vector<int>> vec(n, vector<int>(n));\\n        for (i = j = o = 0 , num = 1; num <= (n * n) && i < n - o; o++, i++, j++) {\\n            cout << vec[i][j] << endl;\\n            while (j < n - o) {\\n                if (num > n*n) break;\\n                vec[i][j++] = num++;\\n            }\\n            j--;\\n            for (k = i + 1; k < n - o; k++) {\\n                if (num > n*n) break;\\n                vec[k][j] = num++;\\n            }\\n            k--;\\n            while (j > o) {\\n                if (num > n*n) break;\\n                vec[k][--j] = num++;\\n            }\\n            while (k > i + 1) {\\n                if (num > n*n) break;\\n                vec[--k][o] = num++;\\n            }\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int i, j, o, k, num;\\n        vector<vector<int>> vec(n, vector<int>(n));\\n        for (i = j = o = 0 , num = 1; num <= (n * n) && i < n - o; o++, i++, j++) {\\n            cout << vec[i][j] << endl;\\n            while (j < n - o) {\\n                if (num > n*n) break;\\n                vec[i][j++] = num++;\\n            }\\n            j--;\\n            for (k = i + 1; k < n - o; k++) {\\n                if (num > n*n) break;\\n                vec[k][j] = num++;\\n            }\\n            k--;\\n            while (j > o) {\\n                if (num > n*n) break;\\n                vec[k][--j] = num++;\\n            }\\n            while (k > i + 1) {\\n                if (num > n*n) break;\\n                vec[--k][o] = num++;\\n            }\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3508950,
                "title": "best-and-easy-approach-for-solving-competitive-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsoc=starting of column\\nsor=starting of row\\neor=end of column\\neoc=end of coloumn\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>finaldata(n,vector<int>(n,0));\\n        int soc=0,sor=0,eor=n-1,eoc=n-1,count=1;\\n        while(soc<=eoc && sor<=eor)\\n        {\\n            for(int x=soc;x<=eoc;x++)\\n            {\\n                finaldata[sor][x]=count;\\n                count++;\\n            }\\n            sor++;\\n            for(int x=sor;x<=eor;x++)\\n            {\\n                finaldata[x][eoc]=count;\\n                count++;\\n            }\\n            eoc--;\\n            for(int x=eoc;x>=soc;x--)\\n            {\\n                finaldata[eor][x]=count;\\n                count++;\\n            }\\n            eor--;\\n            for(int x=eor;x>=sor;x--)\\n            {\\n                finaldata[x][soc]=count;\\n                count++;\\n            }\\n            soc++;\\n        }\\n        return finaldata;\\n    }\\n};\\nIF YOU LOVE YOUR MOTHER UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>finaldata(n,vector<int>(n,0));\\n        int soc=0,sor=0,eor=n-1,eoc=n-1,count=1;\\n        while(soc<=eoc && sor<=eor)\\n        {\\n            for(int x=soc;x<=eoc;x++)\\n            {\\n                finaldata[sor][x]=count;\\n                count++;\\n            }\\n            sor++;\\n            for(int x=sor;x<=eor;x++)\\n            {\\n                finaldata[x][eoc]=count;\\n                count++;\\n            }\\n            eoc--;\\n            for(int x=eoc;x>=soc;x--)\\n            {\\n                finaldata[eor][x]=count;\\n                count++;\\n            }\\n            eor--;\\n            for(int x=eor;x>=sor;x--)\\n            {\\n                finaldata[x][soc]=count;\\n                count++;\\n            }\\n            soc++;\\n        }\\n        return finaldata;\\n    }\\n};\\nIF YOU LOVE YOUR MOTHER UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507369,
                "title": "java-simulation-beats-100-15-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[][] generateMatrix(int n) {\\n    int x = 0, y = -1, cnt = 1;\\n    var xMoves = new int[] {n};\\n    var yMoves = new int[] {n+1};\\n    var mat = new int[n][n];\\n\\n    for (var d = 0; cnt <= n*n; d = (d+1) % 4) {\\n      var moves = d % 2 == 0 ? yMoves : xMoves;\\n      moves[0]--;\\n\\n      for (var i = 0; i < moves[0]; i++) {\\n        switch(d) {\\n          case 0 : y++; break;\\n          case 1 : x++; break;\\n          case 2 : y--; break;\\n          case 3 : x--; break;\\n        }\\n        mat[x][y] = cnt++;\\n      }\\n    }\\n    return mat;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public int[][] generateMatrix(int n) {\\n    int x = 0, y = -1, cnt = 1;\\n    var xMoves = new int[] {n};\\n    var yMoves = new int[] {n+1};\\n    var mat = new int[n][n];\\n\\n    for (var d = 0; cnt <= n*n; d = (d+1) % 4) {\\n      var moves = d % 2 == 0 ? yMoves : xMoves;\\n      moves[0]--;\\n\\n      for (var i = 0; i < moves[0]; i++) {\\n        switch(d) {\\n          case 0 : y++; break;\\n          case 1 : x++; break;\\n          case 2 : y--; break;\\n          case 3 : x--; break;\\n        }\\n        mat[x][y] = cnt++;\\n      }\\n    }\\n    return mat;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507016,
                "title": "easy-java-code-beats-100",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] ans = new int[n][n];\\n        //right -> bottom -> left -> top\\n        int top = 0, left = 0;\\n        int bottom = n-1, right = n-1;\\n        int k = 1;\\n        while(top<=bottom && left<=right){\\n            //right\\n            for(int i=left;i<=right;i++){\\n                ans[top][i] = k++ ;\\n            }\\n            top++;\\n            //bottom\\n            for(int i=top;i<=bottom;i++){\\n                ans[i][right] = k++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                //left\\n                for(int i=right;i>=left;i--){\\n                    ans[bottom][i] = k++;\\n                  }\\n                 bottom--;\\n            }\\n            if(left<=right){\\n                //top\\n                for(int i=bottom;i>=top;i--){\\n                    ans[i][left] = k++;\\n                }  \\n                left++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] ans = new int[n][n];\\n        //right -> bottom -> left -> top\\n        int top = 0, left = 0;\\n        int bottom = n-1, right = n-1;\\n        int k = 1;\\n        while(top<=bottom && left<=right){\\n            //right\\n            for(int i=left;i<=right;i++){\\n                ans[top][i] = k++ ;\\n            }\\n            top++;\\n            //bottom\\n            for(int i=top;i<=bottom;i++){\\n                ans[i][right] = k++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                //left\\n                for(int i=right;i>=left;i--){\\n                    ans[bottom][i] = k++;\\n                  }\\n                 bottom--;\\n            }\\n            if(left<=right){\\n                //top\\n                for(int i=bottom;i>=top;i--){\\n                    ans[i][left] = k++;\\n                }  \\n                left++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506521,
                "title": "simple-spiral-traversing-c-98-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter initializing a new 2-d Array, simply traverse the array from the outer spiral towards inner spiral and place the incrementing numbers\\n\\n![Screenshot 2023-05-10 062834.png](https://assets.leetcode.com/users/images/0f78400f-bde1-46d9-912d-955e0b0787a5_1683680327.0288699.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) - as we need to place (n^2) items in the array of size (n*n), given n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra memory other than the resulting 2-d array\\n\\n## Please upvote if you like the simplicity of the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) {\\n        int[][] result = Initialize(n);\\n        int num = 1;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            for (int x = i; x <= j; x++)\\n            {\\n                result[i][x] = num++;\\n            }\\n            \\n            for (int x = i + 1; x <= j; x++)\\n            {\\n                result[x][j] = num++;\\n            }\\n            \\n            for (int x = j - 1; x >= i; x--)\\n            {\\n                result[j][x] = num++;\\n            }\\n            \\n            for (int x = j - 1; x > i; x--)\\n            {\\n                result[x][i] = num++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int[][] Initialize(int n)\\n    {\\n        int[][] result = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = new int[n];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the simplicity of the approach",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) {\\n        int[][] result = Initialize(n);\\n        int num = 1;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            for (int x = i; x <= j; x++)\\n            {\\n                result[i][x] = num++;\\n            }\\n            \\n            for (int x = i + 1; x <= j; x++)\\n            {\\n                result[x][j] = num++;\\n            }\\n            \\n            for (int x = j - 1; x >= i; x--)\\n            {\\n                result[j][x] = num++;\\n            }\\n            \\n            for (int x = j - 1; x > i; x--)\\n            {\\n                result[x][i] = num++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int[][] Initialize(int n)\\n    {\\n        int[][] result = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = new int[n];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941775,
                "title": "javascript-easy-to-understand-intuition-explained",
                "content": "**Intuition** -> This problem is similar to [Spiral matrix I](https://leetcode.com/problems/spiral-matrix/) in which we take 4 pointers and move them as per the condition, in this problem the pointer part in same only thing that has been changed is how many times the outer loop will run and how efficiently we can manage , below is the code hope it helps.\\n```\\nvar generateMatrix = function(n) {\\n    let c1=0;\\n    let c2=n-1;\\n    let r1=0;\\n    let r2=n-1;\\n    \\n    let arr=Array.from(Array(n),()=>Array(n));\\n    let i=1;\\n    while(i<=n*n){\\n        \\n        for(let c=c1;c<=c2;c++){\\n            arr[r1][c]=i;\\n            i++;\\n        }\\n        r1++;\\n        for(let r=r1;r<=r2;r++){\\n            arr[r][c2]=i;\\n            i++;\\n        }\\n        c2--;\\n        for(let c=c2;c>=c1;c--){\\n            arr[r2][c]=i;\\n            i++;\\n        }\\n        r2--;\\n        for(let r=r2;r>=r1;r--){\\n            arr[r][c1]=i;\\n            i++;\\n        }\\n        c1++;        \\n    }\\n    return arr;\\n};\\n```\\n\\n***Please upvote if you like the solution \\uD83D\\uDE80***",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar generateMatrix = function(n) {\\n    let c1=0;\\n    let c2=n-1;\\n    let r1=0;\\n    let r2=n-1;\\n    \\n    let arr=Array.from(Array(n),()=>Array(n));\\n    let i=1;\\n    while(i<=n*n){\\n        \\n        for(let c=c1;c<=c2;c++){\\n            arr[r1][c]=i;\\n            i++;\\n        }\\n        r1++;\\n        for(let r=r1;r<=r2;r++){\\n            arr[r][c2]=i;\\n            i++;\\n        }\\n        c2--;\\n        for(let c=c2;c>=c1;c--){\\n            arr[r2][c]=i;\\n            i++;\\n        }\\n        r2--;\\n        for(let r=r2;r>=r1;r--){\\n            arr[r][c1]=i;\\n            i++;\\n        }\\n        c1++;        \\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941159,
                "title": "java-simple-reuse-lc-54",
                "content": "**Idea:** \\n* This question is near identical to [LC 54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/3502622/Java-or-Simple-or-Explained) and the solution can be reused. \\n* Fill the matrix in this order: First Row \\u279D Last Column \\u279D Last Row \\u279D First Column\\n* Repeat till a cross-over happends between rows or columns\\n>**T/S:** O(n\\xB2)/O(1)\\n```\\npublic int[][] generateMatrix(int n) {\\n\\tvar matrix = new int[n][n];\\n\\tvar firstRow = 0;\\n\\tvar firstCol = 0;\\n\\tvar lastRow = n - 1;\\n\\tvar lastCol = n - 1;\\n\\tvar x = 1;\\n\\n\\twhile (firstRow <= lastRow && firstCol <= lastCol) {\\n\\t\\t// first row\\n\\t\\tfor (var j = firstCol; j <= lastCol; j++)\\n\\t\\t\\tmatrix[firstRow][j] = x++;\\n\\t\\tfirstRow++;\\n\\n\\t\\t// last col\\n\\t\\tfor (var i = firstRow; i <= lastRow; i++)\\n\\t\\t\\tmatrix[i][lastCol] = x++;\\n\\t\\tlastCol--;\\n\\n\\t\\tif (firstRow > lastRow || firstCol > lastCol)\\n\\t\\t\\tbreak;\\n\\n\\t\\t// last row\\n\\t\\tfor (var j = lastCol; j >= firstCol; j--)\\n\\t\\t\\tmatrix[lastRow][j] = x++;\\n\\t\\tlastRow--;\\n\\n\\t\\t// first col\\n\\t\\tfor (var i = lastRow; i >= firstRow; i--)\\n\\t\\t\\tmatrix[i][firstCol] = x++;\\n\\t\\tfirstCol++;\\n\\t}\\n\\n\\treturn matrix;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n\\tvar matrix = new int[n][n];\\n\\tvar firstRow = 0;\\n\\tvar firstCol = 0;\\n\\tvar lastRow = n - 1;\\n\\tvar lastCol = n - 1;\\n\\tvar x = 1;\\n\\n\\twhile (firstRow <= lastRow && firstCol <= lastCol) {\\n\\t\\t// first row\\n\\t\\tfor (var j = firstCol; j <= lastCol; j++)\\n\\t\\t\\tmatrix[firstRow][j] = x++;\\n\\t\\tfirstRow++;\\n\\n\\t\\t// last col\\n\\t\\tfor (var i = firstRow; i <= lastRow; i++)\\n\\t\\t\\tmatrix[i][lastCol] = x++;\\n\\t\\tlastCol--;\\n\\n\\t\\tif (firstRow > lastRow || firstCol > lastCol)\\n\\t\\t\\tbreak;\\n\\n\\t\\t// last row\\n\\t\\tfor (var j = lastCol; j >= firstCol; j--)\\n\\t\\t\\tmatrix[lastRow][j] = x++;\\n\\t\\tlastRow--;\\n\\n\\t\\t// first col\\n\\t\\tfor (var i = lastRow; i >= firstRow; i--)\\n\\t\\t\\tmatrix[i][firstCol] = x++;\\n\\t\\tfirstCol++;\\n\\t}\\n\\n\\treturn matrix;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941009,
                "title": "golang-simple-solution-with-rotation",
                "content": "We basically need to walk through the matrix, changing direction if we either a) got out of bounds, or b) got previously filled cell.\\n\\n```go\\nfunc generateMatrix(n int) [][]int {\\n    res := make([][]int, n)\\n    for i := 0; i < n; i++ { res[i] = make([]int, n) }\\n    \\n    dirs := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    \\n    i, j, d := 0, 0, 0 \\n    for k := 1; k <= n*n; k++ {\\n        res[i][j] = k\\n        \\n        di, dj := dirs[d%4][0], dirs[d%4][1]\\n        if i+di < 0 || i+di >= n || j+dj < 0 || j+dj >= n || res[i+di][j+dj] != 0 {\\n            d++\\n            di, dj = dirs[d%4][0], dirs[d%4][1]\\n        }\\n        \\n        i, j = i+di, j+dj\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc generateMatrix(n int) [][]int {\\n    res := make([][]int, n)\\n    for i := 0; i < n; i++ { res[i] = make([]int, n) }\\n    \\n    dirs := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    \\n    i, j, d := 0, 0, 0 \\n    for k := 1; k <= n*n; k++ {\\n        res[i][j] = k\\n        \\n        di, dj := dirs[d%4][0], dirs[d%4][1]\\n        if i+di < 0 || i+di >= n || j+dj < 0 || j+dj >= n || res[i+di][j+dj] != 0 {\\n            d++\\n            di, dj = dirs[d%4][0], dirs[d%4][1]\\n        }\\n        \\n        i, j = i+di, j+dj\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963937,
                "title": "spiral-matrix-ii-python-o-n2-simple-offset",
                "content": "The following solution keeps track of an x-y position (location in the resulting array) and an offset (used to move spiral toward the center).\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```\\n\\nThe above solution runs in *`O(n2)`* time. \\nThe above solution takes *`O(n2)`* space.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963514,
                "title": "c-simulation-self-explained-without-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int begX = 0, endX = n - 1;\\n        int begY = 0, endY = n - 1;\\n        int counter = 0;\\n        while(true){\\n            for(int j = begX; j <= endX; j++) ans[begY][j] = ++counter;\\n            if(++begY>endY) break;\\n            for(int j = begY; j <= endY; j++) ans[j][endX] = ++counter;\\n            if(begX>--endX) break;\\n            for(int j = endX; j >= begX; j--) ans[endY][j] = ++counter;\\n            if(begY>--endY) break;\\n            for(int j = endY; j >= begY; j--) ans[j][begX] = ++counter;\\n            if(++begX>endY) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int begX = 0, endX = n - 1;\\n        int begY = 0, endY = n - 1;\\n        int counter = 0;\\n        while(true){\\n            for(int j = begX; j <= endX; j++) ans[begY][j] = ++counter;\\n            if(++begY>endY) break;\\n            for(int j = begY; j <= endY; j++) ans[j][endX] = ++counter;\\n            if(begX>--endX) break;\\n            for(int j = endX; j >= begX; j--) ans[endY][j] = ++counter;\\n            if(begY>--endY) break;\\n            for(int j = endY; j >= begY; j--) ans[j][begX] = ++counter;\\n            if(++begX>endY) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552710,
                "title": "c-minimalizm",
                "content": "Track the direction (left, down, right, and up). When your next position is out of bouds, or there is already a number, we change the direction.\\n\\n```cpp\\nint ds[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto i = 0, j = 0, k = 1, d = 0; k <= n * n; i += ds[d][0], j += ds[d][1]) {\\n        res[i][j] = k++;\\n        auto ni = i + ds[d][0], nj = j + ds[d][1];\\n        if (ni < 0 || ni == n || nj < 0 || nj == n || res[ni][nj] != 0)\\n            d = (++d) % 4;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint ds[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto i = 0, j = 0, k = 1, d = 0; k <= n * n; i += ds[d][0], j += ds[d][1]) {\\n        res[i][j] = k++;\\n        auto ni = i + ds[d][0], nj = j + ds[d][1];\\n        if (ni < 0 || ni == n || nj < 0 || nj == n || res[ni][nj] != 0)\\n            d = (++d) % 4;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 408699,
                "title": "clean-javascript-solution",
                "content": "Reference from a similar question https://leetcode.com/problems/spiral-matrix/discuss/20573/A-concise-C++-implementation-based-on-Directions\\n\\n```\\n// When traversing the matrix in the spiral order, at any time we follow one out of the following four directions:\\n// RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n// 0  1  2  3  4  5\\n//    6  7  8  9 10\\n//   11 12 13 14 15\\n//\\n// Imagine a cursor starts off at (0, -1), i.e. the position at \\'0\\', then we can achieve the spiral order by doing\\n// the following:\\n// 1. Go right 5 times\\n// 2. Go down 2 times\\n// 3. Go left 4 times\\n// 4. Go up 1 times.\\n// 5. Go right 3 times\\n// 6. Go down 0 times -> quit\\n\\nconst generateMatrix = (n) => {\\n  const matrix = [...Array(n)].map(() => Array(n).fill(null));\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up\\n  const steps = [n, n - 1];\\n\\n  let num = 1;\\n  let dir = 0;\\n  let x = 0;\\n  let y = -1;\\n\\n  while (steps[dir % 2] > 0) {\\n    for (let i = 0; i < steps[dir % 2]; i++) {\\n      x += dirs[dir][0];\\n      y += dirs[dir][1];\\n      matrix[x][y] = num++;\\n    }\\n\\n    steps[dir % 2]--;\\n    dir = (dir + 1) % 4;\\n  }\\n  return matrix;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// When traversing the matrix in the spiral order, at any time we follow one out of the following four directions:\\n// RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n// 0  1  2  3  4  5\\n//    6  7  8  9 10\\n//   11 12 13 14 15\\n//\\n// Imagine a cursor starts off at (0, -1), i.e. the position at \\'0\\', then we can achieve the spiral order by doing\\n// the following:\\n// 1. Go right 5 times\\n// 2. Go down 2 times\\n// 3. Go left 4 times\\n// 4. Go up 1 times.\\n// 5. Go right 3 times\\n// 6. Go down 0 times -> quit\\n\\nconst generateMatrix = (n) => {\\n  const matrix = [...Array(n)].map(() => Array(n).fill(null));\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up\\n  const steps = [n, n - 1];\\n\\n  let num = 1;\\n  let dir = 0;\\n  let x = 0;\\n  let y = -1;\\n\\n  while (steps[dir % 2] > 0) {\\n    for (let i = 0; i < steps[dir % 2]; i++) {\\n      x += dirs[dir][0];\\n      y += dirs[dir][1];\\n      matrix[x][y] = num++;\\n    }\\n\\n    steps[dir % 2]--;\\n    dir = (dir + 1) % 4;\\n  }\\n  return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123723,
                "title": "beat-100-java-code",
                "content": "Hi all, this code divides the whole construction into n/2 loops. In each loop, it finishes one spiral. If n is an odd number, add an extra number in the center before return.\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n==1)\\n            return new int [][] {{1}};\\n        int[][] result=new int[n][n];\\n        int col=0, row=0, min=0, max=n-1, i=1, loop=0;\\n        while(loop<n/2) {\\n            result[row][col]=i++;\\n            if (row==min && col!=max) \\n                col++;\\n            else if(col==max && row!=max)\\n                row++;\\n            else if(row==max && col!=min) \\n                col--;\\n            else if(col==min && row!=min+1)\\n                row--;\\n            else {\\n                min++;\\n                max--;\\n                col=min;\\n                row=min;\\n                loop++;\\n            }\\n        }\\n        if (n%2==1) \\n            result[n/2][n/2]=i;\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n==1)\\n            return new int [][] {{1}};\\n        int[][] result=new int[n][n];\\n        int col=0, row=0, min=0, max=n-1, i=1, loop=0;\\n        while(loop<n/2) {\\n            result[row][col]=i++;\\n            if (row==min && col!=max) \\n                col++;\\n            else if(col==max && row!=max)\\n                row++;\\n            else if(row==max && col!=min) \\n                col--;\\n            else if(col==min && row!=min+1)\\n                row--;\\n            else {\\n                min++;\\n                max--;\\n                col=min;\\n                row=min;\\n                loop++;\\n            }\\n        }\\n        if (n%2==1) \\n            result[n/2][n/2]=i;\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22488,
                "title": "a-better-solution-than-switching-directions",
                "content": "Rotate the Matrix is more easier :)\\n\\n\\tpublic class Solution {\\n\\t\\tint[][] step = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\t\\tint cnt = 1;\\n\\t\\tvoid vortex(int[][] res, int len, int wid, int x, int y, int sg){\\n\\t\\t\\tif(len == 0) return;\\n\\t\\t\\tfor(int i = 0; i < len; ++i){\\n\\t\\t\\t\\tx += step[sg][0];\\n\\t\\t\\t\\ty += step[sg][1];\\n\\t\\t\\t\\tres[x][y] = cnt++;\\n\\t\\t\\t}\\n\\t\\t\\tsg = (sg+1)%4;\\n\\t\\t\\tvortex(res,--wid,len, x, y, sg);\\n\\t\\t}\\n\\t    public int[][] generateMatrix(int n) {\\n\\t        int[][] res = new int[n][n];\\n\\t        vortex(res,n,n,0,-1,0);\\n\\t        return res;\\n\\t    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tint[][] step = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 4084193,
                "title": "best-o-n-2-solution",
                "content": "# Approach\\nTraversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat (n, vector<int>(n));\\n        int num = 1;\\n        int r1 = 0, r2 = n - 1, c1 = n - 1, c2 = 0;\\n        while (num <= n * n) {\\n            for (int i = r1; i <= r2; i++) {\\n                mat[r1][i] = num;\\n                num++;\\n            }\\n            r1++;\\n            for (int i = c2 + 1; i <= c1; i++) {\\n                mat[i][c1] = num;\\n                num++;\\n            }\\n            c1--;\\n            for (int i = r2 - 1; i >= r1 - 1; i--) {\\n                mat[r2][i] = num;\\n                num++;\\n            }\\n            r2--;\\n            for (int i = c1; i >= c2 + 1; i--) {\\n                mat[i][c2] = num;\\n                num++;\\n            }\\n            c2++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat (n, vector<int>(n));\\n        int num = 1;\\n        int r1 = 0, r2 = n - 1, c1 = n - 1, c2 = 0;\\n        while (num <= n * n) {\\n            for (int i = r1; i <= r2; i++) {\\n                mat[r1][i] = num;\\n                num++;\\n            }\\n            r1++;\\n            for (int i = c2 + 1; i <= c1; i++) {\\n                mat[i][c1] = num;\\n                num++;\\n            }\\n            c1--;\\n            for (int i = r2 - 1; i >= r1 - 1; i--) {\\n                mat[r2][i] = num;\\n                num++;\\n            }\\n            r2--;\\n            for (int i = c1; i >= c2 + 1; i--) {\\n                mat[i][c2] = num;\\n                num++;\\n            }\\n            c2++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652362,
                "title": "beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse through matrix hit right when you hit a visited node or go out of limits. break when count goes to n^2 +1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintain n*n matrix. change direction when you hit a visited node or go out of limits. increment count after every insertion \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N2)\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> visited(n, vector<int>(n, 0)); int c = 1; \\n        vector<vector<int>> res(n, vector<int>(n, 0));  int x = 0; int y = 0;   char d = \\'r\\'; \\n        while( c != n*n+1){\\n            if(d == \\'r\\'){\\n                res[x][y] = c;  visited[x][y] = 1; y++; c++; \\n                if(y>=n||visited[x][y] == 1) {y--; x++; d = \\'d\\'; continue;  }\\n            }\\n            else if(d == \\'d\\'){\\n                res[x][y] = c; visited[x][y] = 1; x++; c++; \\n                if(x>=n || visited[x][y] == 1) {x--; y--; d = \\'l\\'; continue; }\\n            }\\n            else if(d == \\'l\\'){\\n                res[x][y] = c; visited[x][y] = 1; y--; c++;\\n                if(y<0 || visited[x][y] == 1) { y++; x--; d = \\'u\\'; continue; }\\n            }\\n            else if(d == \\'u\\'){\\n                res[x][y] = c; visited[x][y] = 1; x--; c++;\\n                if(x<0 || visited[x][y] == 1) {x++; y++; d = \\'r\\'; continue; }\\n            }\\n        }\\n\\n        // cout << x << y << d ; \\n\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> visited(n, vector<int>(n, 0)); int c = 1; \\n        vector<vector<int>> res(n, vector<int>(n, 0));  int x = 0; int y = 0;   char d = \\'r\\'; \\n        while( c != n*n+1){\\n            if(d == \\'r\\'){\\n                res[x][y] = c;  visited[x][y] = 1; y++; c++; \\n                if(y>=n||visited[x][y] == 1) {y--; x++; d = \\'d\\'; continue;  }\\n            }\\n            else if(d == \\'d\\'){\\n                res[x][y] = c; visited[x][y] = 1; x++; c++; \\n                if(x>=n || visited[x][y] == 1) {x--; y--; d = \\'l\\'; continue; }\\n            }\\n            else if(d == \\'l\\'){\\n                res[x][y] = c; visited[x][y] = 1; y--; c++;\\n                if(y<0 || visited[x][y] == 1) { y++; x--; d = \\'u\\'; continue; }\\n            }\\n            else if(d == \\'u\\'){\\n                res[x][y] = c; visited[x][y] = 1; x--; c++;\\n                if(x<0 || visited[x][y] == 1) {x++; y++; d = \\'r\\'; continue; }\\n            }\\n        }\\n\\n        // cout << x << y << d ; \\n\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3508409,
                "title": "c-beats-100-easy-like-if-it-helps-you-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMatrix Simulation type question.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#Define a N*N vector initiated with value 0. And then move forward in the matrix in the directions of top->bottom, right->left, left->right, bottom->top. \\n\\n#The loop runs till we reach number limit of n^2. \\n\\n#Looking for openions for optimizing my solution.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n         vector<vector<int>> grid(n, vector<int> (n,0));\\n         int dir=1;\\n         int num=1;\\n         int top=0,bottom=n-1,right=n-1,left=0;\\n         while(num<=pow(n,2))\\n         {\\n             if(dir==1)\\n             {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    grid[top][i]=num;\\n                    num++;\\n                }\\n                top++;\\n                dir=2;\\n             }\\n\\n             else if(dir==2)\\n             {\\n                 for(int i=top;i<=bottom;i++)\\n                 {\\n                     grid[i][right]=num;\\n                     num++;\\n                 }\\n                 right--;\\n                 dir=3;\\n             }\\n             else if(dir==3)\\n             {\\n                 for(int i=right;i>=left;i--)\\n                 {\\n                    grid[bottom][i]=num;\\n                    num++;\\n                 }\\n                 bottom--;\\n                 dir=4;\\n             }\\n\\n             else if(dir==4)\\n             {\\n                 for(int i=bottom;i>=top;i--)\\n                 {\\n                     grid[i][left]=num;\\n                     num++;\\n                 }\\n                 left++;\\n                 dir=1;\\n             }\\n         }\\n          return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n         vector<vector<int>> grid(n, vector<int> (n,0));\\n         int dir=1;\\n         int num=1;\\n         int top=0,bottom=n-1,right=n-1,left=0;\\n         while(num<=pow(n,2))\\n         {\\n             if(dir==1)\\n             {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    grid[top][i]=num;\\n                    num++;\\n                }\\n                top++;\\n                dir=2;\\n             }\\n\\n             else if(dir==2)\\n             {\\n                 for(int i=top;i<=bottom;i++)\\n                 {\\n                     grid[i][right]=num;\\n                     num++;\\n                 }\\n                 right--;\\n                 dir=3;\\n             }\\n             else if(dir==3)\\n             {\\n                 for(int i=right;i>=left;i--)\\n                 {\\n                    grid[bottom][i]=num;\\n                    num++;\\n                 }\\n                 bottom--;\\n                 dir=4;\\n             }\\n\\n             else if(dir==4)\\n             {\\n                 for(int i=bottom;i>=top;i--)\\n                 {\\n                     grid[i][left]=num;\\n                     num++;\\n                 }\\n                 left++;\\n                 dir=1;\\n             }\\n         }\\n          return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507313,
                "title": "c-easy-to-understand-matrix",
                "content": "sr : starting of row\\ner : end of row\\nsc : starting of row\\nec : end of columns\\n\\n{first traverse first row increment starting row by one\\nsecond traversal for insert last columns decrement last columns by 1\\nthird time insert last row decrement last row by one\\nfourth time insert first row increment 1st column by row}\\nrepeat these all four steps untill sr <= er && sc <= ec.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int sr = 0, sc = 0, er = n-1,ec = n-1,x=1,i;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v[sr][i] = x++;\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v[i][ec] = x++;\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v[er][i] = x++;\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v[i][sc] = x++;\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int sr = 0, sc = 0, er = n-1,ec = n-1,x=1,i;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v[sr][i] = x++;\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v[i][ec] = x++;\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v[er][i] = x++;\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v[i][sc] = x++;\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506683,
                "title": "c-best-solution-o-n-n-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have total n*n element for making n*n matrix in spiral order.\\nSo we can follow this **4 step**\\n\\n***Step-1*** : printing the starting row\\n***Step-2*** : printing the ending column\\n***Step-3*** : printing the ending row\\n***Step-4*** : printing the starting column\\n\\n# Dry Run\\nlet n=3\\nSo we have total 3*3 = 9 elements\\ninitial our matrix is : \\n>0 0 0\\n0 0 0\\n0 0 0\\n\\n**step-1:** *starting row*\\n>1 2 3\\n0 0 0\\n0 0 0\\n\\n**step-2:** *ending column*\\n>1 2 3\\n0 0 4\\n0 0 5\\n\\n**step-3:** *ending row*\\n>1 2 3\\n0 0 4\\n7 6 5\\n\\n**step-4:** *starting column*\\n>1 2 3\\n8 0 4\\n7 6 5\\n\\n**HERE 4 STEP IS COMPLETED BUT THE MATRIX IS NOT FILLED BY N*N ELEMENTS SO WE HAVE TO REPET THIS 4 STAPES AGAIN WHILE THERE IS LESS THEN N*N ELEMENTS**\\n\\n**step-1:** *starting row*\\n>1 2 3\\n8 9 4\\n7 6 5\\nThis is our answer\\n\\n# Complexity\\n- Time complexity: $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int srow = 0, erow = n-1, scol = 0, ecol = n-1, element = 1, total = n*n;\\n        while(element <= total)    {\\n            // step-1 : starting row\\n            for(int i=scol; i<=ecol && element<=total; i++)   {\\n                ans[srow][i] = element++;\\n            }\\n            srow++;\\n\\n            // step-2 : ending column\\n            for(int i=srow; i<=erow && element<=total; i++)   {\\n                ans[i][ecol] = element++;\\n            }\\n            ecol--;\\n\\n            // step-3 : ending row\\n            for(int i=ecol; i>=scol && element<=total; i--)   {\\n                ans[erow][i] = element++;\\n            }\\n            erow--;\\n\\n            // step-4 : starting column\\n            for(int i=erow; i>=srow && element<=total; i--)   {\\n                ans[i][scol] = element++;\\n            }\\n            scol++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int srow = 0, erow = n-1, scol = 0, ecol = n-1, element = 1, total = n*n;\\n        while(element <= total)    {\\n            // step-1 : starting row\\n            for(int i=scol; i<=ecol && element<=total; i++)   {\\n                ans[srow][i] = element++;\\n            }\\n            srow++;\\n\\n            // step-2 : ending column\\n            for(int i=srow; i<=erow && element<=total; i++)   {\\n                ans[i][ecol] = element++;\\n            }\\n            ecol--;\\n\\n            // step-3 : ending row\\n            for(int i=ecol; i>=scol && element<=total; i--)   {\\n                ans[erow][i] = element++;\\n            }\\n            erow--;\\n\\n            // step-4 : starting column\\n            for(int i=erow; i>=srow && element<=total; i--)   {\\n                ans[i][scol] = element++;\\n            }\\n            scol++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089593,
                "title": "python-beginner-friendly-similar-to-spiral-matrix-1",
                "content": "Please upvote if you like the post\\n\\n```\\n   class Solution:\\n       def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        matrix_size = n * n\\n        up = left = value = 0\\n        right = n - 1\\n        down = n - 1\\n        \\n        while value != matrix_size:\\n            \\n            for col in range(left, right + 1):\\n                value += 1\\n                matrix[up][col] = value\\n            \\n            for row in range(up + 1, down + 1):\\n                value += 1\\n                matrix[row][right] = value\\n                \\n            if up != down:\\n                for col in range(right - 1, left - 1, -1):\\n                    value += 1\\n                    matrix[down][col] = value\\n            \\n            if left != right:\\n                for row in range(down - 1, up, -1):\\n                    value += 1\\n                    matrix[row][left] = value\\n        \\n            left += 1\\n            right -= 1\\n            up += 1\\n            down -= 1\\n\\n        return matrix\\n             \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n   class Solution:\\n       def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        matrix_size = n * n\\n        up = left = value = 0\\n        right = n - 1\\n        down = n - 1\\n        \\n        while value != matrix_size:\\n            \\n            for col in range(left, right + 1):\\n                value += 1\\n                matrix[up][col] = value\\n            \\n            for row in range(up + 1, down + 1):\\n                value += 1\\n                matrix[row][right] = value\\n                \\n            if up != down:\\n                for col in range(right - 1, left - 1, -1):\\n                    value += 1\\n                    matrix[down][col] = value\\n            \\n            if left != right:\\n                for row in range(down - 1, up, -1):\\n                    value += 1\\n                    matrix[row][left] = value\\n        \\n            left += 1\\n            right -= 1\\n            up += 1\\n            down -= 1\\n\\n        return matrix\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942288,
                "title": "python-optimized-spiral-traversal-in-a-few-lines-explained",
                "content": "We fill the matrix following a spiral pattern, changing direction when going outside of the matrix or when encountering a non-zero value.\\nUsing `next`on an `itertools.cycle` is far easier to read than using modulos IMO.\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        directions = cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        row, col = 0, 0\\n        x, y = next(directions)\\n        for i in range(1, n ** 2 + 1):\\n            matrix[row][col] = i\\n            if not (0 <= row + x < n and 0 <= col + y < n and matrix[row + x][col + y] == 0):\\n                x, y = next(directions)\\n            row += x\\n            col += y  \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        directions = cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        row, col = 0, 0\\n        x, y = next(directions)\\n        for i in range(1, n ** 2 + 1):\\n            matrix[row][col] = i\\n            if not (0 <= row + x < n and 0 <= col + y < n and matrix[row + x][col + y] == 0):\\n                x, y = next(directions)\\n            row += x\\n            col += y  \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941795,
                "title": "c-100-simple-solution-o-n-2",
                "content": "```\\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }\\n    \\n    int top = 0;\\n    int bot = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    \\n    int j = 1;\\n    while (j <= n * n) {\\n        for (int i = left; i <= right; i++, j++)\\n            res[top][i] = j;\\n        top++;\\n\\n        for (int i = top; i <= bot; i++, j++)\\n            res[i][right] = j;\\n        right--;\\n\\n        for (int i = right; i >= left; i--, j++)\\n            res[bot][i] = j;\\n        bot--;\\n\\n        for (int i = bot; i >= top; i--, j++)\\n            res[i][left] = j;\\n        left++;\\n    }\\n\\n    return res;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }\\n    \\n    int top = 0;\\n    int bot = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    \\n    int j = 1;\\n    while (j <= n * n) {\\n        for (int i = left; i <= right; i++, j++)\\n            res[top][i] = j;\\n        top++;\\n\\n        for (int i = top; i <= bot; i++, j++)\\n            res[i][right] = j;\\n        right--;\\n\\n        for (int i = right; i >= left; i--, j++)\\n            res[bot][i] = j;\\n        bot--;\\n\\n        for (int i = bot; i >= top; i--, j++)\\n            res[i][left] = j;\\n        left++;\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941360,
                "title": "easy-c-solution-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // Defining the boundaries of the matrix.\\n        int top = 0, bottom = n-1, right = n-1, left = 0;\\n        // Defining the direction in which the array is to be traversed.\\n        int dir = 1, val = 1;\\n        vector<vector<int>> matirx (n, vector<int>(n, 0));\\n        while( top <= bottom && left <= right){\\n            // moving left->right\\n            if(dir == 1){\\n                for(int i=left; i <= right; i++){\\n                    matirx[top][i]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole first\\n            // row, move down to the next row.\\n            dir = 2;\\n            top++;\\n            // moving top->bottom\\n            if(dir == 2){\\n                for(int i=top; i <= bottom; i++){\\n                    matirx[i][right]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole last\\n            // column, move left to the previous column.\\n            dir = 3;\\n            right--;\\n            // moving right->left\\n            if(dir == 3){\\n                for(int i=right; i >= left; i--){\\n                    matirx[bottom][i] = val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole last\\n            // row, move up to the previous row.\\n            dir = 4;\\n            bottom--;\\n            // moving bottom->up\\n            if(dir == 4){\\n                for(int i=bottom; i>= top; i--){\\n                    matirx[i][left]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole first\\n            // col, move right to the next column.\\n            dir = 1;\\n            left ++;\\n            \\n        }\\n        \\n        return matirx;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // Defining the boundaries of the matrix.\\n        int top = 0, bottom = n-1, right = n-1, left = 0;\\n        // Defining the direction in which the array is to be traversed.\\n        int dir = 1, val = 1;\\n        vector<vector<int>> matirx (n, vector<int>(n, 0));\\n        while( top <= bottom && left <= right){\\n            // moving left->right\\n            if(dir == 1){\\n                for(int i=left; i <= right; i++){\\n                    matirx[top][i]=val;\\n                    val++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1941154,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(1), because space taken for outputing the result doesn\\'t count as space complexity***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        int k = 1;\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = n - 1;\\n        \\n        while(left <= right && top <= bottom)\\n        {\\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right; i++)\\n                {\\n                    mat[top][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom; i++)\\n                {\\n                    mat[i][right] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left; i--)\\n                {\\n                    mat[bottom][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top; i--)\\n                {\\n                    mat[i][left] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        int k = 1;\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = n - 1;\\n        \\n        while(left <= right && top <= bottom)\\n        {\\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right; i++)\\n                {\\n                    mat[top][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom; i++)\\n                {\\n                    mat[i][right] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left; i--)\\n                {\\n                    mat[bottom][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top; i--)\\n                {\\n                    mat[i][left] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767351,
                "title": "python-solution",
                "content": "Need to be careful for the corner element traversal. \\n```\\nclass Solution(object):\\n    def generateMatrix(self, n):\\n        top, bottom, left, right = 0, n-1, 0, n-1\\n        num = 1 \\n        if not n:\\n            return \\n        matrix = [[0]*n for _ in xrange(n)]\\n        while left <= right and top <= bottom:\\n            for i in xrange(left, right+1):\\n                matrix[top][i] = num\\n                num += 1\\n            top += 1 \\n            \\n            for i in xrange(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1 \\n            right -= 1 \\n            \\n            for i in xrange(right, left-1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1 \\n            \\n            for i in xrange(bottom, top-1, -1):\\n                matrix[i][left] = num\\n                num += 1 \\n            left += 1\\n            \\n        return matrix",
                "solutionTags": [
                    "Python"
                ],
                "code": "Need to be careful for the corner element traversal. \\n```\\nclass Solution(object):\\n    def generateMatrix(self, n):\\n        top, bottom, left, right = 0, n-1, 0, n-1\\n        num = 1 \\n        if not n:\\n            return \\n        matrix = [[0]*n for _ in xrange(n)]\\n        while left <= right and top <= bottom:\\n            for i in xrange(left, right+1):\\n                matrix[top][i] = num\\n                num += 1\\n            top += 1 \\n            \\n            for i in xrange(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1 \\n            right -= 1 \\n            \\n            for i in xrange(right, left-1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1 \\n            \\n            for i in xrange(bottom, top-1, -1):\\n                matrix[i][left] = num\\n                num += 1 \\n            left += 1\\n            \\n        return matrix",
                "codeTag": "Java"
            },
            {
                "id": 1500943,
                "title": "c-100-each-and-every-steps-explained-easy-efficient",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int val=1,r=0,c=0,m=n,i;\\n       \\n \\n    /*  r - starting row index\\n        m - ending row index\\n        c - starting column index\\n        n - ending column index\\n        i - iterator\\n    */\\n \\n    while (r < m && c < n) {\\n        /* Assigning value to first row from\\n               the remaining rows */\\n        for (i = c; i < n; ++i) {\\n            a[r][i] = val++;\\n        }\\n        r++;\\n \\n        /* Assigning value to last column\\n         from the remaining columns */\\n        for (i = r; i < m; ++i) {\\n            a[i][n - 1] = val++;\\n        }\\n        n--;\\n \\n        /* Assigning value to last row from\\n                the remaining rows */\\n        if (r < m) {\\n            for (i = n - 1; i >= c; --i) {\\n                a[m - 1][i] = val++;\\n            }\\n            m--;\\n        }\\n \\n        /* Assigning value to first column from\\n                   the remaining columns */\\n        if (c < n) {\\n            for (i = m - 1; i >= r; --i) {\\n                a[i][c] = val++;\\n            }\\n            c++;\\n        }\\n    }\\n        return a;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int val=1,r=0,c=0,m=n,i;\\n       \\n \\n    /*  r - starting row index\\n        m - ending row index\\n        c - starting column index\\n        n - ending column index\\n        i - iterator\\n    */\\n \\n    while (r < m && c < n) {\\n        /* Assigning value to first row from\\n               the remaining rows */\\n        for (i = c; i < n; ++i) {\\n            a[r][i] = val++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 969392,
                "title": "faster-than-100-00-beginner-friendly-easy-understanding",
                "content": "```\\n//Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int cnt=0;\\n        int rs=0,re=n-1;\\n        int cs=0,ce=n-1;\\n        int j=1;\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        while(rs <= re && cs <= ce){\\n            for(int i=cs;i<=ce;i++){\\n                res[rs][i]=j++;\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++){\\n                res[i][ce]=j++;\\n            }\\n            ce--;\\n             if (rs <= re)\\n            for(int i=ce;i>=cs;i--){\\n                res[re][i]=j++;\\n            }\\n            re--;\\n            if (cs <= ce)\\n            for(int i=re;i>=rs;i--){\\n                res[i][cs]=j++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int cnt=0;\\n        int rs=0,re=n-1;\\n        int cs=0,ce=n-1;\\n        int j=1;\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        while(rs <= re && cs <= ce){\\n            for(int i=cs;i<=ce;i++){\\n                res[rs][i]=j++;\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++){\\n                res[i][ce]=j++;\\n            }\\n            ce--;\\n             if (rs <= re)\\n            for(int i=ce;i>=cs;i--){\\n                res[re][i]=j++;\\n            }\\n            re--;\\n            if (cs <= ce)\\n            for(int i=re;i>=rs;i--){\\n                res[i][cs]=j++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964177,
                "title": "c-0ms-solution-easy-to-understand",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>v(n,vector<int>(n));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n-i;j++){   //left to right\\n                v[i][j]=++count;\\n            }\\n            for(int k=i+1;k<n-i-1;k++){   //top to bottom\\n                v[k][n-i-1]=++count;\\n            }\\n            for(int l=n-1-i;l>i;l--){            // right to left\\n                v[n-i-1][l]=++count;\\n            }\\n            for(int m=n-1-i;m>i;m--){      //bottom to top\\n                v[m][i]=++count;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>v(n,vector<int>(n));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n-i;j++){   //left to right\\n                v[i][j]=++count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963097,
                "title": "python",
                "content": "We do as told and construct the matrix via traversing the spiral.\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n):\\n        ans = [[0]*n for _ in range(n)]\\n        x = y = j = 0\\n        dirs = [(0,1),(1,0),(0,-1),(-1,0)]\\n        for i in range(1,n**2+1):\\n            ans[x][y] = i\\n            dx, dy = dirs[j]\\n            if 0<=x+dx<=n-1 and 0<=y+dy<=n-1 and ans[x+dx][y+dy]==0:\\n                x, y = x+dx, y+dy\\n            else:\\n                j = (j+1)%4\\n                dx, dy = dirs[j]\\n                x, y = x+dx, y+dy   \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n):\\n        ans = [[0]*n for _ in range(n)]\\n        x = y = j = 0\\n        dirs = [(0,1),(1,0),(0,-1),(-1,0)]\\n        for i in range(1,n**2+1):\\n            ans[x][y] = i\\n            dx, dy = dirs[j]\\n            if 0<=x+dx<=n-1 and 0<=y+dy<=n-1 and ans[x+dx][y+dy]==0:\\n                x, y = x+dx, y+dy\\n            else:\\n                j = (j+1)%4\\n                dx, dy = dirs[j]\\n                x, y = x+dx, y+dy   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394596,
                "title": "javascript-solution-beats-60",
                "content": "Here is my solution to solve this problem in JS.\\n\\n```\\n\\n/*         startColumn         endColumn\\n  startRow  1           2           3\\n            4           5           6\\n  endRow    7           8           9\\n */\\nconst spiral = n => {\\n    const results = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        results.push([]);\\n    }\\n\\n    let startRow = 0,\\n        endRow = n - 1,\\n        startColumn = 0,\\n        endColumn = n - 1,\\n        count = 1;\\n\\n    while (startRow <= endRow && startColumn <= endColumn) {\\n        //Top Row\\n        for (let i = startColumn; i <= endColumn; i++) {\\n            results[startRow][i] = count;\\n            count++;\\n        }\\n        startRow++;\\n\\n        //Right Column\\n        for (let i = startRow; i <= endRow; i++) {\\n            results[i][endColumn] = count;\\n            count++;\\n        }\\n        endColumn--;\\n\\n        //bottom row\\n        for (let i = endColumn; i >= startColumn; i--) {\\n            results[endRow][i] = count;\\n            count++;\\n        }\\n        endRow--;\\n\\n        //Left Column\\n        for (let i = endRow; i >= startRow; i--) {\\n            results[i][startColumn] = count;\\n            count++;\\n        }\\n        startColumn++;\\n    }\\n    return results;\\n};\\n\\nconsole.log(spiral(3));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/*         startColumn         endColumn\\n  startRow  1           2           3\\n            4           5           6\\n  endRow    7           8           9\\n */\\nconst spiral = n => {\\n    const results = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        results.push([]);\\n    }\\n\\n    let startRow = 0,\\n        endRow = n - 1,\\n        startColumn = 0,\\n        endColumn = n - 1,\\n        count = 1;\\n\\n    while (startRow <= endRow && startColumn <= endColumn) {\\n        //Top Row\\n        for (let i = startColumn; i <= endColumn; i++) {\\n            results[startRow][i] = count;\\n            count++;\\n        }\\n        startRow++;\\n\\n        //Right Column\\n        for (let i = startRow; i <= endRow; i++) {\\n            results[i][endColumn] = count;\\n            count++;\\n        }\\n        endColumn--;\\n\\n        //bottom row\\n        for (let i = endColumn; i >= startColumn; i--) {\\n            results[endRow][i] = count;\\n            count++;\\n        }\\n        endRow--;\\n\\n        //Left Column\\n        for (let i = endRow; i >= startRow; i--) {\\n            results[i][startColumn] = count;\\n            count++;\\n        }\\n        startColumn++;\\n    }\\n    return results;\\n};\\n\\nconsole.log(spiral(3));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384461,
                "title": "c-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        if(!n)\\n            return {};\\n        int rowStart = 0, rowEnd = n - 1, colStart = 0, colEnd = n - 1;\\n        int count = 1;\\n        vector<vector<int>> result(n, vector<int>(n));\\n        while(count <= n * n)\\n        {\\n            for(int i = colStart; i <= colEnd && count <= n * n; result[rowStart][i++] = count++);\\n            for(int i = ++rowStart; i <= rowEnd && count <=  n * n; result[i++][colEnd] = count++);\\n            for(int i = --colEnd; i >= colStart && count <=  n * n; result[rowEnd][i--] = count++);\\n            for(int i = --rowEnd; i >= rowStart && count <= n * n; result[i--][colStart] = count++);\\n            ++colStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        if(!n)\\n            return {};\\n        int rowStart = 0, rowEnd = n - 1, colStart = 0, colEnd = n - 1;\\n        int count = 1;\\n        vector<vector<int>> result(n, vector<int>(n));\\n        while(count <= n * n)\\n        {\\n            for(int i = colStart; i <= colEnd && count <= n * n; result[rowStart][i++] = count++);\\n            for(int i = ++rowStart; i <= rowEnd && count <=  n * n; result[i++][colEnd] = count++);\\n            for(int i = --colEnd; i >= colStart && count <=  n * n; result[rowEnd][i--] = count++);\\n            for(int i = --rowEnd; i >= rowStart && count <= n * n; result[i--][colStart] = count++);\\n            ++colStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309573,
                "title": "swift-beating-all-linear-solution-kewl-lewpz-hacker-rank-scared-money",
                "content": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        \\n        var m = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\\n        \\n        var l = 0, r = n - 1, t = 0, b = n - 1, x = 0, y = 0, val = 1\\n        \\n        while t <= b {\\n            \\n            x = l; y = t\\n            while x <= r { m[t][x] = val; val += 1; x += 1 }\\n            \\n            t += 1; y = t\\n            while y <= b { m[y][r] = val; val += 1; y += 1 }\\n            \\n            r -= 1; x = r\\n            while x >= l { m[b][x] = val; val += 1; x -= 1 }\\n            \\n            b -= 1; y = b\\n            while y >= t { m[y][l] = val; val += 1; y -= 1 }\\n            \\n            l += 1\\n        }\\n        \\n        return m\\n    }\\n}\\n```\\n\\nBig big big big big big big big man.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        \\n        var m = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\\n        \\n        var l = 0, r = n - 1, t = 0, b = n - 1, x = 0, y = 0, val = 1\\n        \\n        while t <= b {\\n            \\n            x = l; y = t\\n            while x <= r { m[t][x] = val; val += 1; x += 1 }\\n            \\n            t += 1; y = t\\n            while y <= b { m[y][r] = val; val += 1; y += 1 }\\n            \\n            r -= 1; x = r\\n            while x >= l { m[b][x] = val; val += 1; x -= 1 }\\n            \\n            b -= 1; y = b\\n            while y >= t { m[y][l] = val; val += 1; y -= 1 }\\n            \\n            l += 1\\n        }\\n        \\n        return m\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238780,
                "title": "ruby-solution",
                "content": "the solution learns from the discuss, here is the code:\\n\\n```ruby\\n\\ndef generate_matrix(n)\\n  arr = Array.new(n){ Array.new(n) }\\n  \\n  i, j, di, dj = 0, 0, 0, 1\\n  (0...n*n).each do |k|\\n    arr[i][j] = k + 1  \\n    \\n    di, dj = dj, -di if arr[(i+di)%n][(j+dj)%n]\\n    \\n    i += di\\n    j += dj\\n  end\\n  \\n  arr\\nend\\n",
                "solutionTags": [],
                "code": "the solution learns from the discuss, here is the code:\\n\\n```ruby\\n\\ndef generate_matrix(n)\\n  arr = Array.new(n){ Array.new(n) }\\n  \\n  i, j, di, dj = 0, 0, 0, 1\\n  (0...n*n).each do |k|\\n    arr[i][j] = k + 1  \\n    \\n    di, dj = dj, -di if arr[(i+di)%n][(j+dj)%n]\\n    \\n    i += di\\n    j += dj\\n  end\\n  \\n  arr\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 22392,
                "title": "c-template-for-spiral-matrix-spiral-matrix-ii",
                "content": "Spiral Matrix II code:\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> generateMatrix(int n) {\\n            vector<vector<int>> result(n, vector<int>(n, 0));\\n            int l=0, r=n-1, u=0, d=n-1;\\n            int k=1;\\n            while(true){\\n                for(int i=l; i<=r; i++)  result[u][i]=k++;\\n                if(++u>d) break;\\n                \\n                for(int i=u; i<=d; i++)  result[i][r]=k++;\\n                if(r--<l) break;\\n                \\n                for(int i=r; i>=l; i--)  result[d][i]=k++;\\n                if(--d<u) break;\\n                \\n                for(int i=d; i>=u; i--)  result[i][l]=k++;\\n                if(++l>r) break;\\n            }\\n            return result;\\n        }\\n    };\\n\\nSpiral Matrix Code:\\n\\n    class Solution {\\n    public:\\n        vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n            if(matrix.empty())  return {};\\n            int m=matrix.size(), n=matrix[0].size();\\n            vector<int> spiral(m*n);\\n            int u=0, d=m-1, l=0, r=n-1, k=0;\\n            while(true){\\n                /** up **/\\n                for(int col=l; col<=r; col++)  spiral[k++]=matrix[u][col];\\n                if(++u>d) break;\\n                /** right **/\\n                for(int row=u; row<=d; row++)  spiral[k++]=matrix[row][r];\\n                if(--r<l) break;\\n                /** down **/\\n                for(int col=r; col>=l; col--)  spiral[k++]=matrix[d][col];\\n                if(--d<u) break;\\n                /** left **/\\n                for(int row=d; row>=u; row--)  spiral[k++]=matrix[row][l];\\n                if(++l>r) break;\\n            }\\n            return spiral;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> generateMatrix(int n) {\\n            vector<vector<int>> result(n, vector<int>(n, 0));\\n            int l=0, r=n-1, u=0, d=n-1;\\n            int k=1;\\n            while(true){\\n                for(int i=l; i<=r; i++)  result[u][i]=k++;\\n                if(++u>d) break;\\n                \\n                for(int i=u; i<=d; i++)  result[i][r]=k++;\\n                if(r--<l) break;\\n                \\n                for(int i=r; i>=l; i--)  result[d][i]=k++;\\n                if(--d<u) break;\\n                \\n                for(int i=d; i>=u; i--)  result[i][l]=k++;\\n                if(++l>r) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3510253,
                "title": "algorithmic-approach-in-python-beginner-friendly",
                "content": "# Algorithmic Approach\\n* This problem makes more sense when you have solved the Spiral Matrix.\\n* This problem is to **generate a square matrix** **fil**led with **ele**ments from **`1 to n^2 in spiral order`**. \\n* The approach used in the code is to **kee**p **tra**ck of the `current top, bottom, left and right boundaries of the matrix`. \\n* The **alg**orithm **sta**rts from the `top left corner` and **moves** **tow**ards the `right boundary` while **fil**ling the **top row**. \\n* Once it **rea**ches the `right boundary`, it **moves down** **tow**ards the `bottom boundary` while **fil**ling the **rightmost column**.\\n*  Once it **rea**ches the `bottom boundary`, it **moves towards** the `left boundary` while **fil**ling the `bottom row`. \\n* Once it **rea**ches the `left boundary`, it **moves up tow**ards the `top boundary` while **fil**ling the `leftmost column`. \\n* After completing `one full cycle`, it `updates the top, bottom, left and right boundaries` and **rep**eats the **pro**cess **unt**il **all ele**ments have been **fil**led.\\n\\n![Image showing the initial values for top, bottom, left, and right](https://assets.leetcode.com/users/images/0cdc3ae1-62eb-4b85-86eb-50b0a72c3a94_1683755756.0455143.png)\\n\\n\\n# Time and Space Complexity: $O(n^2)$\\n\\n# Code\\n``` Python []\\n\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        # Initialize the top, bottom, right and left boundaries of the matrix\\n        top = 0\\n        bottom = n - 1\\n        right = n - 1\\n        left = 0\\n\\n        # Initialize a counter to keep track of the numbers to fill in the matrix\\n        count = 1\\n\\n        # Initialize an empty matrix of size n by n filled with zeros\\n        res = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        # Loop until the row and column boundaries cross each other\\n        while top <= bottom and left <= right:\\n            \\n            # Left to right with top as constant\\n            for i in range(left, right + 1):\\n                res[top][i] = count\\n                count += 1\\n            # Move the top boundary down by one\\n            top += 1\\n\\n            # Top to bottom with right as constant\\n            for i in range(top, bottom + 1):\\n                res[i][right] = count\\n                count += 1\\n            # Move the right boundary left by one\\n            right -= 1\\n\\n            # Check if the top boundary is still below the bottom boundary\\n            # Right to left with bottom as constant\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    res[bottom][i] = count\\n                    count += 1\\n                # Move the bottom boundary up by one\\n                bottom -= 1\\n\\n            # Check if the left boundary is still below the right boundary\\n            # Bottom to top with left as constant\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    res[i][left] = count\\n                    count += 1\\n                # Move the left boundary right by one\\n                left += 1\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "``` Python []\\n\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        # Initialize the top, bottom, right and left boundaries of the matrix\\n        top = 0\\n        bottom = n - 1\\n        right = n - 1\\n        left = 0\\n\\n        # Initialize a counter to keep track of the numbers to fill in the matrix\\n        count = 1\\n\\n        # Initialize an empty matrix of size n by n filled with zeros\\n        res = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        # Loop until the row and column boundaries cross each other\\n        while top <= bottom and left <= right:\\n            \\n            # Left to right with top as constant\\n            for i in range(left, right + 1):\\n                res[top][i] = count\\n                count += 1\\n            # Move the top boundary down by one\\n            top += 1\\n\\n            # Top to bottom with right as constant\\n            for i in range(top, bottom + 1):\\n                res[i][right] = count\\n                count += 1\\n            # Move the right boundary left by one\\n            right -= 1\\n\\n            # Check if the top boundary is still below the bottom boundary\\n            # Right to left with bottom as constant\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    res[bottom][i] = count\\n                    count += 1\\n                # Move the bottom boundary up by one\\n                bottom -= 1\\n\\n            # Check if the left boundary is still below the right boundary\\n            # Bottom to top with left as constant\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    res[i][left] = count\\n                    count += 1\\n                # Move the left boundary right by one\\n                left += 1\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509833,
                "title": "easy-java-solution-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int num[][] = new int[n][n];\\n        int count = 1;\\n        int top = 0,left = 0,bottom = n -1,right = n - 1;\\n        while(top <= bottom && left <= right){\\n            for(int i = left ; i <= right ; i++){\\n                num[top][i] = count++;\\n            }\\n            top++;\\n            for(int i = top ; i <= bottom; i++){\\n                num[i][right] = count++;\\n            }\\n            right--;\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    num[bottom][i] = count++;\\n                }\\n                bottom--;\\n            }\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    num[i][left] = count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int num[][] = new int[n][n];\\n        int count = 1;\\n        int top = 0,left = 0,bottom = n -1,right = n - 1;\\n        while(top <= bottom && left <= right){\\n            for(int i = left ; i <= right ; i++){\\n                num[top][i] = count++;\\n            }\\n            top++;\\n            for(int i = top ; i <= bottom; i++){\\n                num[i][right] = count++;\\n            }\\n            right--;\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    num[bottom][i] = count++;\\n                }\\n                bottom--;\\n            }\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    num[i][left] = count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508134,
                "title": "kotlin-2d-array-easy-solution-with-great-explanation",
                "content": "# Intuition\\nI solved this task yesterday lol, i just need to advance it :)\\n\\n# Approach\\nSo, we need to initialize `n * n` matrix/grid with zeroes on each position(which is our result, we need to edit this matrix/grid)\\n\\nNext we need to declare `direction` variable, which is equal to `\\'R\\'`, because start direction is `\"Right\"`.\\n\\nAfter that we can declare our borders on each side:\\n`borderLeft`, `borderUp` and etc.\\nNotice, that `borderUp` is equal to 1, because on start we already fill first line, so we need to move border.\\n\\nI used to `matrix[i][j]`, so i created iterables `i` which is a **Column**, and `j` which is a **Row**!\\n\\nNow we can start to travel in Matrix from `0` to `n * n` because we need to fill each cell from `1` to `n * n`, so in each step we are going to `matrix[i][j] = k + 1`(we could start from `1` to `n * n + 1`, because `until` works like: `1 <= until < (n * n + 1)`).\\n\\nI hope you understand =)\\nLet\\'s continue!\\n\\nIn Kotlin we have `when` statement, it\\'s equals to `switch`, but in my opinion much better :)\\nWe could do `when (direction) { /* TODO */ }`, but if we needed to write some `if` statements in `when` -> we can\\'t use mentioned before expression.\\n\\nWe\\'ll use `when` statement to check `direction` each time we go to somewhere. And so, if `direction == \\'R\\'`, we are going to move to the right with `j`(like `matrix[i][j++]`). And each time we are checking if we contact the `border` with `j`, if we contacted -> we are switching our direction according to statement to `\\'D\\'` and decrease possible `border`.\\n\\nNow we need to do the same with all directions. After `for` just return our edited matrix :)\\n\\n**If u liked my explanation please vote for this solution, its important to me!**\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```kotlin []\\nclass Solution {\\n    fun generateMatrix(n: Int): Array<IntArray> {\\n        var matrix = Array(n) { IntArray(n) }\\n        var direction = \\'R\\'\\n        var borderLeft = 0\\n        var borderRight = n - 1\\n        var borderUp = 1\\n        var borderDown = n - 1\\n        var i = 0\\n        var j = 0\\n        for (k in 0 until n * n) {\\n            matrix[i][j] = k + 1\\n            when {\\n                direction == \\'R\\' -> {\\n                    j++\\n                    if (j == borderRight) {\\n                        direction = \\'D\\'\\n                        borderRight--\\n                    }\\n                }\\n                direction == \\'D\\' -> {\\n                    i++\\n                    if (i == borderDown) {\\n                        direction = \\'L\\'\\n                        borderDown--\\n                    }\\n                }\\n                direction == \\'L\\' -> {\\n                    j--\\n                    if (j == borderLeft) {\\n                        direction = \\'U\\'\\n                        borderLeft++\\n                    }\\n                }\\n                direction == \\'U\\' -> {\\n                    i--\\n                    if (i == borderUp) {\\n                        direction = \\'R\\'\\n                        borderUp++\\n                    }\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Matrix"
                ],
                "code": "```kotlin []\\nclass Solution {\\n    fun generateMatrix(n: Int): Array<IntArray> {\\n        var matrix = Array(n) { IntArray(n) }\\n        var direction = \\'R\\'\\n        var borderLeft = 0\\n        var borderRight = n - 1\\n        var borderUp = 1\\n        var borderDown = n - 1\\n        var i = 0\\n        var j = 0\\n        for (k in 0 until n * n) {\\n            matrix[i][j] = k + 1\\n            when {\\n                direction == \\'R\\' -> {\\n                    j++\\n                    if (j == borderRight) {\\n                        direction = \\'D\\'\\n                        borderRight--\\n                    }\\n                }\\n                direction == \\'D\\' -> {\\n                    i++\\n                    if (i == borderDown) {\\n                        direction = \\'L\\'\\n                        borderDown--\\n                    }\\n                }\\n                direction == \\'L\\' -> {\\n                    j--\\n                    if (j == borderLeft) {\\n                        direction = \\'U\\'\\n                        borderLeft++\\n                    }\\n                }\\n                direction == \\'U\\' -> {\\n                    i--\\n                    if (i == borderUp) {\\n                        direction = \\'R\\'\\n                        borderUp++\\n                    }\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507852,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to create a 2-dimensional matrix of size n x n such that the elements are filled in spiral form.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Follow the code below to understand the solution.**\\n\\n      **If this solution helped you, give it an up-vote to help others** \\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n\\n        int [][] arr = new int[n][n];\\n\\n        int i = 0;      //starting row index\\n        int j = 0;      //starting col index\\n\\n        int k = n;    //ending row index\\n        int l = n;    //ending col index\\n\\n        int count = 0;\\n\\n        boolean flag = true;\\n\\n        while(flag) {\\n\\n            flag = false;\\n\\n\\n            //--------------LEFT --->> RIGHT------------//\\n            while(j < l)\\n            {\\n              arr[i][j] = ++count;\\n              j++;\\n                flag = true;\\n            }\\n            j--;\\n            i++;\\n\\n\\n            //-------------TOP --->> BOTTOM-------------//\\n\\n            while (i < k) {\\n                arr[i][j] = ++count;\\n                i++;\\n                flag = true;\\n            }\\n            j--;\\n            i--;\\n            k--;\\n\\n            //-----------RIGHT --->> LEFT---------//\\n            while (j >= n - l) {\\n                arr[i][j] = ++count;\\n                j--;\\n                flag = true;\\n            }\\n            j++;\\n            l--;\\n            i--;\\n\\n            //----------BOTTOM --->> TOP-------------//\\n            while (i >= n - k) {\\n                arr[i][j] = ++count;\\n                i--;\\n                flag = true;\\n            }\\n            i++;\\n            j++;\\n        }\\n\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n\\n        int [][] arr = new int[n][n];\\n\\n        int i = 0;      //starting row index\\n        int j = 0;      //starting col index\\n\\n        int k = n;    //ending row index\\n        int l = n;    //ending col index\\n\\n        int count = 0;\\n\\n        boolean flag = true;\\n\\n        while(flag) {\\n\\n            flag = false;\\n\\n\\n            //--------------LEFT --->> RIGHT------------//\\n            while(j < l)\\n            {\\n              arr[i][j] = ++count;\\n              j++;\\n                flag = true;\\n            }\\n            j--;\\n            i++;\\n\\n\\n            //-------------TOP --->> BOTTOM-------------//\\n\\n            while (i < k) {\\n                arr[i][j] = ++count;\\n                i++;\\n                flag = true;\\n            }\\n            j--;\\n            i--;\\n            k--;\\n\\n            //-----------RIGHT --->> LEFT---------//\\n            while (j >= n - l) {\\n                arr[i][j] = ++count;\\n                j--;\\n                flag = true;\\n            }\\n            j++;\\n            l--;\\n            i--;\\n\\n            //----------BOTTOM --->> TOP-------------//\\n            while (i >= n - k) {\\n                arr[i][j] = ++count;\\n                i--;\\n                flag = true;\\n            }\\n            i++;\\n            j++;\\n        }\\n\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507748,
                "title": "o-1-space-easy-c-beats-100-explanation-beginner-friendly",
                "content": "# Explanation\\nThe given code is used to generate a matrix of size n by n, where n is a positive integer. The generated matrix follows a specific pattern: starting from the top-left corner, the elements of the matrix are filled in a clockwise spiral order until the center is reached.\\n\\nHere\\'s the intuition behind the code:\\n\\n1) Initialize the 2D vector v of size n by n with all elements set to 0. This vector will store the generated matrix.\\n\\n2) Initialize variables left, right, top, and bottom to keep track of the boundaries of the current spiral.\\n\\n3) Initialize a variable val to keep track of the value to be filled in the matrix. It starts from 1 and increments as we fill in the elements.\\n\\n4) While the element at the center of the matrix is not filled (i.e., v[n/2][n/2] == 0), continue the spiral filling process.\\n\\n5) Fill the top row of the current spiral from left to right with values from val and increment val.\\n\\n6) Increment top to exclude the filled top row from future iterations.\\n\\n7) Fill the right column of the current spiral from top to bottom with values from val and increment val.\\n\\n8) Decrement right to exclude the filled right column from future iterations.\\n\\n9) Fill the bottom row of the current spiral from right to left with values from val and increment val.\\n\\n10) Decrement bottom to exclude the filled bottom row from future iterations.\\n\\n11) Fill the left column of the current spiral from bottom to top with values from val and increment val.\\n\\n12) Increment left to exclude the filled left column from future iterations.\\n\\n13) Repeat steps 5 to 12 until the center element of the matrix is filled.\\n\\nFinally, return the generated matrix v.\\n\\nThe code utilizes the four variables left, right, top, and bottom to keep track of the current boundaries of the spiral. By incrementing or decrementing these boundaries, the code ensures that the next spiral is filled correctly.\\n\\nThe val variable is used to keep track of the value to be filled in the matrix. It starts from 1 and increments after each element is filled.\\n\\nBy following this spiral pattern and updating the boundaries accordingly, the code generates the desired matrix.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1), this is because we are not using any extra space other than what is asked in the question to return as the final answer.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE if you like the solution. Glad to help. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n, vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int val=1;\\n        while(v[n/2][n/2]==0){\\n            for(int i=left;i<=right;i++) v[top][i]=val++;\\n            top++;\\n            for(int i=top;i<=bottom;i++) v[i][right]=val++;\\n            right--;\\n            for(int i=right;i>=left;i--) v[bottom][i]=val++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--) v[i][left]=val++;\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n, vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int val=1;\\n        while(v[n/2][n/2]==0){\\n            for(int i=left;i<=right;i++) v[top][i]=val++;\\n            top++;\\n            for(int i=top;i<=bottom;i++) v[i][right]=val++;\\n            right--;\\n            for(int i=right;i>=left;i--) v[bottom][i]=val++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--) v[i][left]=val++;\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507281,
                "title": "easiest-and-fast-c-soln-beats-100",
                "content": "**Please upvote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int leftrow = 0,rightrow = n-1,leftcol = 0,rightcol = n-1;\\n        int count = 1,total = n*n;\\n        vector<vector<int>> ans(n,vector<int>(n));\\n\\n        while(count<=total)\\n        {\\n            for(int i=leftcol; i<=rightcol; i++)\\n            {\\n                ans[leftrow][i] = count;\\n                count++;\\n            }\\n            leftrow++;\\n\\n            if(count > total)\\n                break;\\n            for(int i=leftrow; i<=rightrow; i++)\\n            {\\n                ans[i][rightcol] = count;\\n                count++;\\n            }\\n            rightcol--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightcol; i>=leftcol; i--)\\n            {\\n                ans[rightrow][i] = count;\\n                count++;\\n            }\\n            rightrow--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightrow; i>=leftrow; i--)\\n            {\\n                ans[i][leftcol] = count;\\n                count++;\\n            }\\n            leftcol++;\\n            if(count > total)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int leftrow = 0,rightrow = n-1,leftcol = 0,rightcol = n-1;\\n        int count = 1,total = n*n;\\n        vector<vector<int>> ans(n,vector<int>(n));\\n\\n        while(count<=total)\\n        {\\n            for(int i=leftcol; i<=rightcol; i++)\\n            {\\n                ans[leftrow][i] = count;\\n                count++;\\n            }\\n            leftrow++;\\n\\n            if(count > total)\\n                break;\\n            for(int i=leftrow; i<=rightrow; i++)\\n            {\\n                ans[i][rightcol] = count;\\n                count++;\\n            }\\n            rightcol--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightcol; i>=leftcol; i--)\\n            {\\n                ans[rightrow][i] = count;\\n                count++;\\n            }\\n            rightrow--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightrow; i>=leftrow; i--)\\n            {\\n                ans[i][leftcol] = count;\\n                count++;\\n            }\\n            leftcol++;\\n            if(count > total)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507022,
                "title": "c-beats-100-only-few-changes-in-spiral-matrix-1",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- $$O(n*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- $$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n\\n        int top = 0;\\n        int left = 0;\\n        int bottom = n - 1;\\n        int right = n - 1;\\n        int k = 1;\\n\\n        while(top <= bottom && left <= right) {\\n            // Traversing right\\n            for(int i = left; i <= right; i++) {\\n                matrix[top][i] = k;\\n                k++;\\n            }\\n            top++;\\n            // Traversing down\\n            for(int i = top; i <= bottom; i++) {\\n                matrix[i][right] = k;\\n                k++;\\n            }\\n            right--;\\n            // Traversing left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = k;\\n                    k++;\\n                }\\n                bottom--;\\n            }\\n            // Traversing up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = k;\\n                    k++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n\\n        int top = 0;\\n        int left = 0;\\n        int bottom = n - 1;\\n        int right = n - 1;\\n        int k = 1;\\n\\n        while(top <= bottom && left <= right) {\\n            // Traversing right\\n            for(int i = left; i <= right; i++) {\\n                matrix[top][i] = k;\\n                k++;\\n            }\\n            top++;\\n            // Traversing down\\n            for(int i = top; i <= bottom; i++) {\\n                matrix[i][right] = k;\\n                k++;\\n            }\\n            right--;\\n            // Traversing left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = k;\\n                    k++;\\n                }\\n                bottom--;\\n            }\\n            // Traversing up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = k;\\n                    k++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506965,
                "title": "100-faster-c-solution-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to generate a square matrix of size n with elements from 1 to n^2 in spiral order. To generate the matrix in spiral order, we can start by filling in the top row from left to right, then the right column from top to bottom, then the bottom row from right to left, and finally the left column from bottom to top. We can repeat this process until all the elements of the matrix have been filled in.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Create an n x n matrix with all elements initialized to 0.\\n2.Initialize variables startingRow, endingRow, startingCol, and endingCol to keep track of the current boundaries of the matrix.\\n3.Initialize k to 1, which represents the current element to be filled in the matrix.\\n4.Use a while loop to iterate over the matrix until all elements have been filled.\\n5.Within the while loop, use four for loops to fill in the elements of the matrix in spiral order:\\n6.The first loop fills in the top row of the matrix from left to right.\\n7.The second loop fills in the right column of the matrix from top to bottom.\\n8.The third loop fills in the bottom row of the matrix from right to left.\\n9.The fourth loop fills in the left column of the matrix from bottom to top.\\n10.After each loop, update the boundaries of the matrix by incrementing or decrementing the appropriate variables.\\n11.Increment k after each element is filled in the matrix.\\n12.Return the resulting matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n^2) because the while loop iterates over all n^2 elements of the matrix, and each element is filled in exactly once.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n^2) because we create an n x n matrix to store the resulting elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506689,
                "title": "simple-bfs-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> generateMatrix(int n)\\n{\\n    int rr[] = {0, 1, 0, -1};\\n    int cc[] = {1, 0, -1, 0};\\n\\n    vector<vector<int>> visited(n, vector<int>(n, 0));\\n    vector<vector<int>> ans(n, vector<int>(n, 0));\\n    visited[0][0] = 1;\\n    ans[0][0] = 1;\\n\\n    int index = 0;\\n    int count = 1;\\n\\n    int row = 0;\\n    int col = 0;\\n\\n    while (count < n * n)\\n    {\\n        int r = row + rr[index];\\n        int c = col + cc[index];\\n\\n        if (r < n and c < n and r >= 0 and c >= 0 and !visited[r][c])\\n        {\\n            count++;\\n            ans[r][c] = count;\\n            visited[r][c] = 1;\\n            row = r;\\n            col = c;\\n        }\\n        else\\n        {\\n            index = (index + 1) % 4;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> generateMatrix(int n)\\n{\\n    int rr[] = {0, 1, 0, -1};\\n    int cc[] = {1, 0, -1, 0};\\n\\n    vector<vector<int>> visited(n, vector<int>(n, 0));\\n    vector<vector<int>> ans(n, vector<int>(n, 0));\\n    visited[0][0] = 1;\\n    ans[0][0] = 1;\\n\\n    int index = 0;\\n    int count = 1;\\n\\n    int row = 0;\\n    int col = 0;\\n\\n    while (count < n * n)\\n    {\\n        int r = row + rr[index];\\n        int c = col + cc[index];\\n\\n        if (r < n and c < n and r >= 0 and c >= 0 and !visited[r][c])\\n        {\\n            count++;\\n            ans[r][c] = count;\\n            visited[r][c] = 1;\\n            row = r;\\n            col = c;\\n        }\\n        else\\n        {\\n            index = (index + 1) % 4;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506597,
                "title": "beats-100-java-c-python-fast-and-elegant",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\nDon\\'t forget to upvote if you find the content below helpful. \\uD83D\\uDE43\\n\\n## Problem\\nThe problem is to generate a square matrix filled with elements from 1 to n\\xB2 in a spiral order.\\n\\n## Similarity to Previous Problem\\nThis solution is very similar to [my solution of Spiral Matrix problem](https://leetcode.com/problems/spiral-matrix/solutions/3503165/beats-100-java-c-python-elegant-solution-explained/), where we traverse a 2D matrix in a spiral order. The key difference is that in the current problem, we are generating the matrix, while in the previous one we are traversing it.\\n\\n## Approach\\nWe initialize a 2D matrix of size $$n \\\\times n$$. We keep track of the current cell that we are in using `(r, c)`, and the direction in which we are moving using `(dr, dc)`. \\n\\nInitially, we start from the cell `(0,0)` and move towards the right. For each cell, we assign a number starting from `1`. If the next cell in the current direction is out of bounds or already assigned, we turn `90` degrees to the right.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity is $$O(n\\xB2)$$, where $$n$$ is the input number. This is because we have to fill up $$n\\xB2$$ cells in the matrix.\\n\\n- Space Complexity: The space complexity is also $$O(n\\xB2)$$, as we need to allocate a 2D array of size $$n \\\\times n$$ to store the resulting matrix.\\n\\n## Code\\n```java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; current++) {\\n            matrix[r][c] = current;\\n            if (r + dr >= matrix.length || r + dr < 0\\n                    || c + dc >= matrix[0].length || c + dc < 0\\n                    || matrix[r + dr][c + dc] != 0\\n            ) {\\n                int temp = dc;\\n                dc = -dr;\\n                dr = temp;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; ++current) {\\n            matrix[r][c] = current;\\n            if (r + dr >= n || r + dr < 0 || c + dc >= n || c + dc < 0 || matrix[r + dr][c + dc] != 0) {\\n                swap(dr, dc);\\n                dr = -dr;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\\n``` python3 []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0]*n for _ in range(n)]\\n        r, c, dr, dc = 0, 0, 0, 1\\n        for current in range(1, n*n + 1):\\n            matrix[r][c] = current\\n            if not (0 <= r + dr < n and 0 <= c + dc < n and matrix[r + dr][c + dc] == 0):\\n                dr, dc = dc, -dr\\n            r += dr\\n            c += dc\\n        return matrix\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; current++) {\\n            matrix[r][c] = current;\\n            if (r + dr >= matrix.length || r + dr < 0\\n                    || c + dc >= matrix[0].length || c + dc < 0\\n                    || matrix[r + dr][c + dc] != 0\\n            ) {\\n                int temp = dc;\\n                dc = -dr;\\n                dr = temp;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; ++current) {\\n            matrix[r][c] = current;\\n            if (r + dr >= n || r + dr < 0 || c + dc >= n || c + dc < 0 || matrix[r + dr][c + dc] != 0) {\\n                swap(dr, dc);\\n                dr = -dr;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\n``` python3 []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0]*n for _ in range(n)]\\n        r, c, dr, dc = 0, 0, 0, 1\\n        for current in range(1, n*n + 1):\\n            matrix[r][c] = current\\n            if not (0 <= r + dr < n and 0 <= c + dc < n and matrix[r + dr][c + dc] == 0):\\n                dr, dc = dc, -dr\\n            r += dr\\n            c += dc\\n        return matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464037,
                "title": "java-solution-for-spiral-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code generates a 2D matrix of size n x n with numbers from 1 to n*n in spiral order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a loop to iterate over all the elements in the matrix and keeps track of the current position (x, y) in the matrix. It also keeps track of the current step in the spiral using the variable step.\\n\\nThe code then iterates through the four sides of the matrix in a spiral order, filling in the numbers as it goes along. The while loops are used to fill in each side of the matrix.\\n\\nOnce all the numbers have been filled in, the resulting 2D matrix is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) since it needs to fill in each of the n^2 elements in the matrix\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) since it needs to create a 2D matrix of size n x n to store the result.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214880,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176492,
                "title": "59-spiral-matrix-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a 2D list matrix with size n x n filled with zeros.\\n2. Create a list direction that contains the possible direction of movement.\\n3. Initialize the variables curr_dir to keep track of the current direction, x and y for the current position.\\n4. Use a for loop to fill the matrix with elements from 1 to n * n.\\n5. On each iteration, calculate the next position next_x and next_y by adding the current position with the corresponding direction.\\n6. If the next position is within the bounds of the matrix and the value at the next position is 0, update the current position to the next position.\\n7. If the next position is not valid, change the direction by using curr_dir = (curr_dir + 1) % 4.\\n8. Repeat steps 5-7 until all elements from 1 to n * n are filled in the matrix.\\n9. Return the filled matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curr_dir = 0\\n        x, y = 0, 0\\n        for num in range(1, n * n + 1):\\n            matrix[x][y] = num\\n            next_x, next_y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n            if 0 <= next_x < n and 0 <= next_y < n and matrix[next_x][next_y] == 0:\\n                x, y = next_x, next_y\\n            else:\\n                curr_dir = (curr_dir + 1) % 4\\n                x, y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n        return matrix\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curr_dir = 0\\n        x, y = 0, 0\\n        for num in range(1, n * n + 1):\\n            matrix[x][y] = num\\n            next_x, next_y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n            if 0 <= next_x < n and 0 <= next_y < n and matrix[next_x][next_y] == 0:\\n                x, y = next_x, next_y\\n            else:\\n                curr_dir = (curr_dir + 1) % 4\\n                x, y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n        return matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117990,
                "title": "c-python3-solution-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> M(n, vector<int>(n));\\n        int val = 1;\\n        for(int i = 0; i < (n + 1) / 2; i++) {\\n            for(int j = i; j < n - i; j++) M[i][j] = val++;\\n            for(int j = i + 1; j < n - i; j++) M[j][n - i - 1] = val++;\\n            for(int j = n - i - 2; j >= i; j--) M[n - i - 1][j] = val++;\\n            for(int j = n - i - 2; j > i; j--) M[j][i] = val++;\\n        }\\n        return M;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def generateMatrix(self, n):\\n        M = [[0] * n for _ in range(n)]\\n        val = 0\\n        for i in range((n + 1) // 2):\\n            for j in range(i, n - i): M[i][j] = (val := val + 1)\\n            for j in range(i + 1, n - i): M[j][n - i - 1] = (val := val + 1)\\n            for j in range(n - i - 2, i - 1, -1): M[n - i - 1][j] = (val := val + 1)\\n            for j in range(n - i - 2, i, -1): M[j][i] = (val := val + 1)\\n        return M\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> M(n, vector<int>(n));\\n        int val = 1;\\n        for(int i = 0; i < (n + 1) / 2; i++) {\\n            for(int j = i; j < n - i; j++) M[i][j] = val++;\\n            for(int j = i + 1; j < n - i; j++) M[j][n - i - 1] = val++;\\n            for(int j = n - i - 2; j >= i; j--) M[n - i - 1][j] = val++;\\n            for(int j = n - i - 2; j > i; j--) M[j][i] = val++;\\n        }\\n        return M;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def generateMatrix(self, n):\\n        M = [[0] * n for _ in range(n)]\\n        val = 0\\n        for i in range((n + 1) // 2):\\n            for j in range(i, n - i): M[i][j] = (val := val + 1)\\n            for j in range(i + 1, n - i): M[j][n - i - 1] = (val := val + 1)\\n            for j in range(n - i - 2, i - 1, -1): M[n - i - 1][j] = (val := val + 1)\\n            for j in range(n - i - 2, i, -1): M[j][i] = (val := val + 1)\\n        return M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072223,
                "title": "0-ms-beats-100-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] arr = new int[n][n];\\n        int counter = 1 , up = 0 , left = 0 , right = n-1 , \\n            down = n-1 ;\\n        while(counter <= n*n){\\n            for(int i = left ; i<= right ; i++){\\n                arr[up][i] = counter++;\\n            }\\n            up++;\\n            for(int i = up ; i<=down  ; i++){\\n                arr[i][right] = counter++;\\n            }\\n            right--;\\n            for(int i = right ; i>= left ; i--){\\n                arr[down][i] = counter++;\\n            }\\n            down--;\\n            for(int i = down ; i>= up ; i--){\\n                arr[i][left] = counter++;\\n            }\\n            left++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] arr = new int[n][n];\\n        int counter = 1 , up = 0 , left = 0 , right = n-1 , \\n            down = n-1 ;\\n        while(counter <= n*n){\\n            for(int i = left ; i<= right ; i++){\\n                arr[up][i] = counter++;\\n            }\\n            up++;\\n            for(int i = up ; i<=down  ; i++){\\n                arr[i][right] = counter++;\\n            }\\n            right--;\\n            for(int i = right ; i>= left ; i--){\\n                arr[down][i] = counter++;\\n            }\\n            down--;\\n            for(int i = down ; i>= up ; i--){\\n                arr[i][left] = counter++;\\n            }\\n            left++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679788,
                "title": "java-easy-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n      int[][] result = new int[n][n];\\n        int k = 0;\\n        int rowStart = 0, rowEnd = n;\\n        int colStart = 0, colEnd = n;\\n        while (k < n * n) {\\n\\n            // right\\n            for(int i = rowStart; k < n * n && i < colEnd; i ++) {\\n                result[rowStart][i] = ++ k;\\n            }\\n            rowStart ++;\\n\\n            // down\\n            for(int i = rowStart; k < n * n && i < rowEnd; i ++) {\\n                result[i][colEnd - 1] = ++ k;\\n            }\\n            colEnd --;\\n\\n            // left\\n            for(int i = colEnd - 1; k < n * n && i >= colStart; i --) {\\n                result[rowEnd - 1][i] = ++ k;\\n            }\\n            rowEnd --;\\n\\n            // up\\n            for(int i = rowEnd - 1; k < n * n && i >= rowStart; i --) {\\n                result[i][colStart] = ++ k;\\n            }\\n            colStart ++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n      int[][] result = new int[n][n];\\n        int k = 0;\\n        int rowStart = 0, rowEnd = n;\\n        int colStart = 0, colEnd = n;\\n        while (k < n * n) {\\n\\n            // right\\n            for(int i = rowStart; k < n * n && i < colEnd; i ++) {\\n                result[rowStart][i] = ++ k;\\n            }\\n            rowStart ++;\\n\\n            // down\\n            for(int i = rowStart; k < n * n && i < rowEnd; i ++) {\\n                result[i][colEnd - 1] = ++ k;\\n            }\\n            colEnd --;\\n\\n            // left\\n            for(int i = colEnd - 1; k < n * n && i >= colStart; i --) {\\n                result[rowEnd - 1][i] = ++ k;\\n            }\\n            rowEnd --;\\n\\n            // up\\n            for(int i = rowEnd - 1; k < n * n && i >= rowStart; i --) {\\n                result[i][colStart] = ++ k;\\n            }\\n            colStart ++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664720,
                "title": "0ms-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int k = 1,rs = 0,cs = 0,ce = n-1,re = n-1,i;\\n        while(rs<=re && cs <= ce){\\n            for(i = cs; i<= ce; i++){\\n                ans[rs][i] = k++;\\n            }\\n            rs++;\\n            for(i = rs; i<= re; i++){\\n                ans[i][ce] = k++;\\n            }\\n            ce--;\\n            for(i = ce; i>= cs; i--){\\n                ans[re][i] = k++;\\n            }\\n            re--;\\n            for(i = re; i>=rs; i--){\\n                ans[i][cs] = k++;\\n            }\\n            cs++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int k = 1,rs = 0,cs = 0,ce = n-1,re = n-1,i;\\n        while(rs<=re && cs <= ce){\\n            for(i = cs; i<= ce; i++){\\n                ans[rs][i] = k++;\\n            }\\n            rs++;\\n            for(i = rs; i<= re; i++){\\n                ans[i][ce] = k++;\\n            }\\n            ce--;\\n            for(i = ce; i>= cs; i--){\\n                ans[re][i] = k++;\\n            }\\n            re--;\\n            for(i = re; i>=rs; i--){\\n                ans[i][cs] = k++;\\n            }\\n            cs++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162072,
                "title": "fastest-explained-easy-simple-clean-code-0ms",
                "content": "**Total number of iteration** through the matrix to get all the elements in spiral order is : **\"K= (n*2)-1 \"**\\nwhere **n : number of rows** (or *number of colums* as the matrix is **n *x* n**)\\n\\nThis formula can be understood by taking example of 3x3 *(5 iterations)*, 4x4 *(7 iterations)* , 5x5 *(9 iterations)* .... matrix (just to get the idea).\\nWe are basically iterating in the four directions through the matrix.\\ni.e. \\n*1)left to right in a particular row (i.e. iterating through columns in a particular row)\\n2)up to bottom in the particular column (i.e. iterating through rows in a particular column)\\n3)right to left in the particular row (i.e. iterating through columns in a particular row)\\n4)bottom to up in the particular column (i.e. iterating through rows in a particular column)*\\n\\n```\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int c=0,r=1,k=(n*2)-1;\\n        while (c<k){\\n            for (int j = c; j < n; ++j) {\\n                matrix[c][j]=r;\\n                ++r;\\n            }\\n            for (int i = c +1; i <n; ++i) {\\n                matrix[i][n-1]=r;\\n                ++r;\\n            }\\n            for (int j = n-2; j >= c; --j) {\\n                matrix[n-1][j]=r;\\n                ++r;\\n            }\\n            for (int i = n-2; i > c; --i) {\\n                matrix[i][c]=r;\\n                ++r;\\n            }\\n            --n;\\n            ++c;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int c=0,r=1,k=(n*2)-1;\\n        while (c<k){\\n            for (int j = c; j < n; ++j) {\\n                matrix[c][j]=r;\\n                ++r;\\n            }\\n            for (int i = c +1; i <n; ++i) {\\n                matrix[i][n-1]=r;\\n                ++r;\\n            }\\n            for (int j = n-2; j >= c; --j) {\\n                matrix[n-1][j]=r;\\n                ++r;\\n            }\\n            for (int i = n-2; i > c; --i) {\\n                matrix[i][c]=r;\\n                ++r;\\n            }\\n            --n;\\n            ++c;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033042,
                "title": "c-simple-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k = 0;                   //number of steps\\n        vector<vector<int>> res;     //to store the matrix\\n        \\n        //maybe you can find some better way to initialize the matrix array, but I decided to fill it with zeros))\\n        for(int i = 0; i < n; i++){\\n            vector<int> v;\\n            for(int j = 0; j < n; j++){\\n                v.push_back(0);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        //these variables will be used as pointers\\n        int r = n - 1;      //right bound \\n        int l = 0;          //left bound\\n        int u = 0;          //up bound\\n        int d = n - 1;      //down bound\\n        int i = 0;          //vertical position\\n        int j = 0;          //horizontal position\\n        \\n        while(k++ < n * n){       //we should make n*n steps to fill all the matrix\\n            res[i][j] = k;\\n            \\n            if(i == u && j < r) {    //move right\\n                j++;\\n                if(j == r) u++;      //if the bound is reached, shift the bound\\n            }\\n            else if(i < d && j == r) {       //move down\\n                i++;\\n                if(i == d) r--;\\n            }\\n            else if(i == d && j > l) {     //move left\\n                j--;\\n                if(j == l) d--;\\n            }\\n            else if(i > u && j == l) {     //move right\\n                i--;\\n                if(i == u) l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k = 0;                   //number of steps\\n        vector<vector<int>> res;     //to store the matrix\\n        \\n        //maybe you can find some better way to initialize the matrix array, but I decided to fill it with zeros))\\n        for(int i = 0; i < n; i++){\\n            vector<int> v;\\n            for(int j = 0; j < n; j++){\\n                v.push_back(0);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        //these variables will be used as pointers\\n        int r = n - 1;      //right bound \\n        int l = 0;          //left bound\\n        int u = 0;          //up bound\\n        int d = n - 1;      //down bound\\n        int i = 0;          //vertical position\\n        int j = 0;          //horizontal position\\n        \\n        while(k++ < n * n){       //we should make n*n steps to fill all the matrix\\n            res[i][j] = k;\\n            \\n            if(i == u && j < r) {    //move right\\n                j++;\\n                if(j == r) u++;      //if the bound is reached, shift the bound\\n            }\\n            else if(i < d && j == r) {       //move down\\n                i++;\\n                if(i == d) r--;\\n            }\\n            else if(i == d && j > l) {     //move left\\n                j--;\\n                if(j == l) d--;\\n            }\\n            else if(i > u && j == l) {     //move right\\n                i--;\\n                if(i == u) l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943878,
                "title": "simple-solution-with-only-one-for-loop",
                "content": "```\\n\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] matrix = new int[n][];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = Enumerable.Repeat(0, n).ToArray();\\n        }\\n        \\n        int[] directionX = new int[] { 0, 1, 0, -1 };\\n        int[] directionY = new int[] { 1, 0, -1, 0 };\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n        \\n        for (int i = 1; i <= n * n; i++)\\n        {\\n            matrix[x][y] = i;\\n            \\n            //do not need this on the last step\\n            if (i != n * n)\\n            {\\n                x += directionX[direction];\\n                y += directionY[direction];\\n\\n                //if we are out of bounds or on the already visited cell then change the direction\\n                if (x < 0 || y < 0 || x > n-1 || y > n-1 || matrix[x][y] != 0)\\n                {\\n                    x -= directionX[direction];\\n                    y -= directionY[direction];\\n\\n                    direction = (direction + 1) % 4;\\n\\n                    x += directionX[direction];\\n                    y += directionY[direction];\\n                }\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] matrix = new int[n][];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = Enumerable.Repeat(0, n).ToArray();\\n        }\\n        \\n        int[] directionX = new int[] { 0, 1, 0, -1 };\\n        int[] directionY = new int[] { 1, 0, -1, 0 };\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n        \\n        for (int i = 1; i <= n * n; i++)\\n        {\\n            matrix[x][y] = i;\\n            \\n            //do not need this on the last step\\n            if (i != n * n)\\n            {\\n                x += directionX[direction];\\n                y += directionY[direction];\\n\\n                //if we are out of bounds or on the already visited cell then change the direction\\n                if (x < 0 || y < 0 || x > n-1 || y > n-1 || matrix[x][y] != 0)\\n                {\\n                    x -= directionX[direction];\\n                    y -= directionY[direction];\\n\\n                    direction = (direction + 1) % 4;\\n\\n                    x += directionX[direction];\\n                    y += directionY[direction];\\n                }\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942034,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n]; \\n        \\n        int ele = 1; // the element to store in the matrix\\n        \\n        int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}}; //direction in which we traverse the matrix\\n        \\n        int flag = 0; // will take the values 0,1,2,3 to change direction according to increment values in dir array\\n        \\n        int row = 0, col = 0; //current row and column\\n        \\n        int rowinc = dir[flag % 4][0], colinc = dir[flag % 4][1]; //row increment, column increment\\n        \\n        while(ele <= Math.pow(n,2)){\\n            matrix[row][col] = ele;\\n            \\n            if(row + rowinc >= n || row + rowinc < 0 || col + colinc >= n || col + colinc < 0 || matrix[row + rowinc][col + colinc] != 0){\\n                //change direction\\n                \\n                flag++;\\n                rowinc = dir[flag % 4][0];\\n                colinc = dir[flag % 4][1];\\n            }\\n            \\n            ele++;\\n            row += rowinc;\\n            col += colinc;\\n        }\\n        \\n        return matrix;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n]; \\n        \\n        int ele = 1; // the element to store in the matrix\\n        \\n        int[][] dir = new int[][]{{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1942019,
                "title": "java-0ms-100-faster-simple-logic",
                "content": "```class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int result[][]=new int[n][n];\\n        if(n==1){\\n            result[0][0]=1;\\n            return result;\\n        }\\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int colBegin=0;\\n        int colEnd=n-1;\\n        int k=1;\\n        \\n        while(colBegin<=colEnd && rowBegin<=rowEnd){\\n            for(int i=colBegin;i<=colEnd;i++){\\n                result[rowBegin][i]=k++;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                result[i][colEnd]=k++;\\n            }\\n            colEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=colEnd;i>=colBegin;i--){\\n                    result[rowEnd][i]=k++;\\n                }\\n            }\\n            rowEnd--;\\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                    result[i][colBegin]=k++;\\n                }\\n            }\\n            colBegin++;\\n            \\n        }\\n            \\n        \\n        \\n        return result;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int result[][]=new int[n][n];\\n        if(n==1){\\n            result[0][0]=1;\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1941759,
                "title": "python-3-intuitive-6-lines-solution",
                "content": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:       \\n        A, S, D, X, Y =[[0]*n for _ in range(n)], 0, [[1,0],[0,1],[-1,0],[0,-1]], 0, 0\\n\\t\\t# - A:  Answer\\n\\t\\t# - S:  Status. 0: right, 1: up, 2: left, 3: down\\n\\t\\t# - D:  Direction list\\n\\t\\t# - X,Y: location\\n        valid = lambda x,y: 0<=x<n and 0<=y<n and A[y][x] == 0\\n        for i  in range(1,n*n+1):\\n            A[Y][X], S = i, (S + (not valid(X+D[S][0],Y+D[S][1]))*1) % 4\\n            X,Y = X+D[S][0], Y+D[S][1]\\n        return A\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:       \\n        A, S, D, X, Y =[[0]*n for _ in range(n)], 0, [[1,0],[0,1],[-1,0],[0,-1]], 0, 0\\n\\t\\t# - A:  Answer\\n\\t\\t# - S:  Status. 0: right, 1: up, 2: left, 3: down\\n\\t\\t# - D:  Direction list\\n\\t\\t# - X,Y: location\\n        valid = lambda x,y: 0<=x<n and 0<=y<n and A[y][x] == 0\\n        for i  in range(1,n*n+1):\\n            A[Y][X], S = i, (S + (not valid(X+D[S][0],Y+D[S][1]))*1) % 4\\n            X,Y = X+D[S][0], Y+D[S][1]\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941530,
                "title": "c-0ms-100-faster-easy-and-simple",
                "content": "Here, we just have to understand the trend of matrix.\\nLike how we are filling the matrix.\\nfirst we are doing first column to last column,\\nthen first row +1 to last row then again last column to  first column and same with last row to first row...this way we can approach this question.\\n\\nyou will have more understanding after viewing the code.\\n\\nhope you like it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        if(n==0)\\n        {\\n            return v;\\n        }\\n        int firstRow=0;\\n        int firstColumn=0;\\n        int lastRow=n-1;\\n        int lastColumn=n-1;\\n        int i=1;\\n        int num=n*n;\\n       \\n        while(firstRow<=lastRow && firstColumn<=lastColumn)\\n        {\\n            for(int j=firstColumn;j<=lastColumn;j++)\\n            { \\n                v[firstRow][j]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=firstRow+1;j<=lastRow;j++)\\n            {\\n                v[j][lastColumn]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=lastColumn-1;j>=firstColumn;j--)\\n            { \\n                v[lastRow][j]=i;\\n                i++;  \\n            }\\n            if(i>num)break;   \\n            for(int j=lastRow-1;j>firstRow;j--)\\n            {\\n                v[j][firstColumn]=i;\\n                i++;  \\n            }\\n            if(i>num)break;\\n            firstRow++;\\n            firstColumn++;\\n            lastRow--;\\n            lastColumn--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        if(n==0)\\n        {\\n            return v;\\n        }\\n        int firstRow=0;\\n        int firstColumn=0;\\n        int lastRow=n-1;\\n        int lastColumn=n-1;\\n        int i=1;\\n        int num=n*n;\\n       \\n        while(firstRow<=lastRow && firstColumn<=lastColumn)\\n        {\\n            for(int j=firstColumn;j<=lastColumn;j++)\\n            { \\n                v[firstRow][j]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=firstRow+1;j<=lastRow;j++)\\n            {\\n                v[j][lastColumn]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=lastColumn-1;j>=firstColumn;j--)\\n            { \\n                v[lastRow][j]=i;\\n                i++;  \\n            }\\n            if(i>num)break;   \\n            for(int j=lastRow-1;j>firstRow;j--)\\n            {\\n                v[j][firstColumn]=i;\\n                i++;  \\n            }\\n            if(i>num)break;\\n            firstRow++;\\n            firstColumn++;\\n            lastRow--;\\n            lastColumn--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941518,
                "title": "c-easy-to-understand-with-comments",
                "content": "```\\npublic class Solution \\n{\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        for (int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        (int top, int bottom, int left, int right) = (0, n - 1, 0, n - 1);\\n        \\n        int val = 1;\\n        while (true) \\n        {\\n            //left to right, colms are changing\\n            for (int i = left; i <= right; i++)\\n                mat[top][i] = val++;\\n            \\n            top++; //row covered, bring it down\\n           \\n            if (top > bottom)\\n                break;\\n            \\n            //top to bottom, rows are changing\\n            for (int i = top; i <= bottom; i++)\\n                mat[i][right] = val++;\\n\\n            right--; //colm covered, shrink the column window\\n            \\n            if (left > right)\\n                break;\\n            \\n            //right to left, colms are changing\\n            for (int i = right; i >= left; i--)\\n                mat[bottom][i] = val++;\\n            \\n            bottom--; //row covered, shrink the row window\\n            \\n            //bottom to top, rows are changing\\n            for (int i = bottom; i >= top; i--)\\n                mat[i][left] = val++;\\n            \\n            left++; //col covered, shrink the colm window\\n            \\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        for (int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        (int top, int bottom, int left, int right) = (0, n - 1, 0, n - 1);\\n        \\n        int val = 1;\\n        while (true) \\n        {\\n            //left to right, colms are changing\\n            for (int i = left; i <= right; i++)\\n                mat[top][i] = val++;\\n            \\n            top++; //row covered, bring it down\\n           \\n            if (top > bottom)\\n                break;\\n            \\n            //top to bottom, rows are changing\\n            for (int i = top; i <= bottom; i++)\\n                mat[i][right] = val++;\\n\\n            right--; //colm covered, shrink the column window\\n            \\n            if (left > right)\\n                break;\\n            \\n            //right to left, colms are changing\\n            for (int i = right; i >= left; i--)\\n                mat[bottom][i] = val++;\\n            \\n            bottom--; //row covered, shrink the row window\\n            \\n            //bottom to top, rows are changing\\n            for (int i = bottom; i >= top; i--)\\n                mat[i][left] = val++;\\n            \\n            left++; //col covered, shrink the colm window\\n            \\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877702,
                "title": "python-easy-simulation-solution",
                "content": "### **Spiral Matrix II**\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:    \\n        r, c = 0, 0\\n        dr, dc = 0, 1\\n        res = [[0] * n for _ in range(n)]\\n        \\n        for i in range(1, n*n + 1):\\n            res[r][c] = i   \\n            \\n            # at most one right turn\\n            tmpR, tmpC = r + dr, c + dc\\n            if (\\n                tmpR < 0 or tmpR >= n or\\n                tmpC < 0 or tmpC >= n or \\n                res[tmpR][tmpC] != 0\\n            ):\\n                dr, dc = dc, -dr # 90 degree clockwise\\n            \\n            r, c = r + dr, c + dc\\n         \\n        return res\\n```\\nMy Solutions of Related Problems:\\n* 54. Spiral Matrix: [Python, easy simulation solution]( https://leetcode.com/problems/spiral-matrix/discuss/1875750/python-lazy-simulation)\\n* 885. Spiral Matrix III: [Python, easy simulation solution with explanation.](https://leetcode.com/problems/spiral-matrix-iii/discuss/1877691/python-easy-solution-with-explanation)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:    \\n        r, c = 0, 0\\n        dr, dc = 0, 1\\n        res = [[0] * n for _ in range(n)]\\n        \\n        for i in range(1, n*n + 1):\\n            res[r][c] = i   \\n            \\n            # at most one right turn\\n            tmpR, tmpC = r + dr, c + dc\\n            if (\\n                tmpR < 0 or tmpR >= n or\\n                tmpC < 0 or tmpC >= n or \\n                res[tmpR][tmpC] != 0\\n            ):\\n                dr, dc = dc, -dr # 90 degree clockwise\\n            \\n            r, c = r + dr, c + dc\\n         \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862754,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0;\\n        int bottom=n-1;\\n        int left=0;\\n        int right=n-1;\\n        int count=1;\\n        int matrix[][]=new int[n][n];\\n        while(left<=right){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=count++;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=count++;\\n            }\\n            right--;\\n            \\n            \\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=count++;\\n            }\\n                bottom--;\\n            \\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0;\\n        int bottom=n-1;\\n        int left=0;\\n        int right=n-1;\\n        int count=1;\\n        int matrix[][]=new int[n][n];\\n        while(left<=right){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=count++;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=count++;\\n            }\\n            right--;\\n            \\n            \\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=count++;\\n            }\\n                bottom--;\\n            \\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810692,
                "title": "easy-understanding-java-solution",
                "content": "```\\nprivate int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\tprivate int direction = 0;\\n\\tpublic int[][] generateMatrix(int n) {\\n\\t\\tint[][] res = new int[n][n];\\n\\t\\tres[0][0] = 1;\\n\\t\\tint row = 0;\\n\\t\\tint col = 0;\\n\\t\\tint count = 2;\\n\\t\\twhile (count <= n * n) {\\n\\t\\t\\tif (canGo(row + dirs[direction][0], col + dirs[direction][1],res)){\\n\\t\\t\\t\\trow += dirs[direction][0];\\n\\t\\t\\t\\tcol += dirs[direction][1];\\n\\t\\t\\t\\tres[row][col] = count;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdirection++;\\n\\t\\t\\t\\tdirection = direction % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate boolean canGo(int i, int j, int[][] res) {\\n\\t\\tif (i > res.length - 1 || i < 0 || j > res[0].length - 1 || j < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(res[i][j] != 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\tprivate int direction = 0;\\n\\tpublic int[][] generateMatrix(int n) {\\n\\t\\tint[][] res = new int[n][n];\\n\\t\\tres[0][0] = 1;\\n\\t\\tint row = 0;\\n\\t\\tint col = 0;\\n\\t\\tint count = 2;\\n\\t\\twhile (count <= n * n) {\\n\\t\\t\\tif (canGo(row + dirs[direction][0], col + dirs[direction][1],res)){\\n\\t\\t\\t\\trow += dirs[direction][0];\\n\\t\\t\\t\\tcol += dirs[direction][1];\\n\\t\\t\\t\\tres[row][col] = count;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdirection++;\\n\\t\\t\\t\\tdirection = direction % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate boolean canGo(int i, int j, int[][] res) {\\n\\t\\tif (i > res.length - 1 || i < 0 || j > res[0].length - 1 || j < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(res[i][j] != 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1657189,
                "title": "c-100-faster-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int num = 1,r1 =0,r2 = n-1,c1 =0,c2 = n-1;\\n        while(r1<=r2 && c1<=c2)\\n        {\\n            //For first row\\n            for(int i = c1;i<=c2;i++)\\n            {\\n                ans[r1][i] = num++;\\n            }\\n            //For last column\\n            for(int j =r1+1;j<=r2;j++)\\n            {\\n                ans[j][c2] = num++;\\n            }\\n            //For last row\\n            if(r1 != r2)\\n            {\\n                for(int i = c2-1;i>=c1;i--)\\n                {\\n                    ans[r2][i] = num++;\\n                }\\n            }\\n            //For first column\\n            if(c1 != c2)\\n            {\\n                for(int i = r2-1;i>r1;i--)\\n                {\\n                    ans[i][c1] = num++;\\n                }\\n            }\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int num = 1,r1 =0,r2 = n-1,c1 =0,c2 = n-1;\\n        while(r1<=r2 && c1<=c2)\\n        {\\n            //For first row\\n            for(int i = c1;i<=c2;i++)\\n            {\\n                ans[r1][i] = num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1620082,
                "title": "99-faster-python-code",
                "content": "Feel free to ask any question !\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0]*n for i in range(n)]\\n        i,j = 0, 0\\n        dire = [0,1,0,-1,0]\\n        po = 0\\n        for a in range(1,n*n+1):\\n            ans[i][j] = a\\n            ni,nj = i+dire[po],j+dire[po+1]\\n            if (not 0<=ni<n) or (not 0<=nj<n) or ans[ni][nj]!=0:\\n                po+=1\\n                po%=4\\n                ni,nj = i+dire[po],j+dire[po+1]\\n            i,j = ni,nj\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0]*n for i in range(n)]\\n        i,j = 0, 0\\n        dire = [0,1,0,-1,0]\\n        po = 0\\n        for a in range(1,n*n+1):\\n            ans[i][j] = a\\n            ni,nj = i+dire[po],j+dire[po+1]\\n            if (not 0<=ni<n) or (not 0<=nj<n) or ans[ni][nj]!=0:\\n                po+=1\\n                po%=4\\n                ni,nj = i+dire[po],j+dire[po+1]\\n            i,j = ni,nj\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424885,
                "title": "0-ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int p=1;\\n        int i=0,j=0,r=n,c=n;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(i<r && j<c){\\n            for(int k=j;k<c;k++) v[i][k]=p++;\\n            i++;\\n            for(int k=i;k<r;k++) v[k][c-1]=p++;\\n            c--;\\n            if(j<c){\\n                for(int k=c-1;k>=j;k--) v[r-1][k]=p++;\\n                r--;\\n            }\\n            if(i<r){\\n                for(int k=r-1;k>=i;k--) v[k][j]=p++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int p=1;\\n        int i=0,j=0,r=n,c=n;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(i<r && j<c){\\n            for(int k=j;k<c;k++) v[i][k]=p++;\\n            i++;\\n            for(int k=i;k<r;k++) v[k][c-1]=p++;\\n            c--;\\n            if(j<c){\\n                for(int k=c-1;k>=j;k--) v[r-1][k]=p++;\\n                r--;\\n            }\\n            if(i<r){\\n                for(int k=r-1;k>=i;k--) v[k][j]=p++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137794,
                "title": "java-explained-with-images-easy-intuitive-solution",
                "content": "We just need to iterate over the outer boundaries and do it for every inner squares \\n![image](https://assets.leetcode.com/users/images/abecb707-c10a-4c21-9f1f-626793445486_1617302946.2052238.jpeg)\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        int k=0;int[][] matrix = new int[n][n];int val=1;\\n        while( k <= n/2 )\\n        {\\n            for( int j = k; j < n-k; j++)\\n               matrix[k][j] = val++;\\n        \\n            for( int  i = k+1; i < n-k-1; i++ )\\n                matrix[i][n-k-1] = val++;\\n        \\n            for( int  j = n-k-1; j > k; j-- )\\n                matrix[n-k-1][j] = val++;\\n        \\n            for( int  i = n-k-1; i > k; i-- )\\n               matrix[i][k] = val++;\\n        k++;\\n        }        \\n     return matrix;   \\n    }\\n}\\nComplexity is O(n2) as we are iterating over all the cells in the matrix.\\nPlease upvote if you like the explanation.\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        int k=0;int[][] matrix = new int[n][n];int val=1;\\n        while( k <= n/2 )\\n        {\\n            for( int j = k; j < n-k; j++)\\n               matrix[k][j] = val++;\\n        \\n            for( int  i = k+1; i < n-k-1; i++ )\\n                matrix[i][n-k-1] = val++;\\n        \\n            for( int  j = n-k-1; j > k; j-- )\\n                matrix[n-k-1][j] = val++;\\n        \\n            for( int  i = n-k-1; i > k; i-- )\\n               matrix[i][k] = val++;\\n        k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1106288,
                "title": "100-fast-simple-easy-understanding-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int left=0,right=n-1,top=0,bottom=n-1,c=1;\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n        while(1){\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=left;i<=right;i++){\\n                mat[top][i]=c;\\n                c++;\\n            }\\n            top++;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=top;i<=bottom;i++){\\n                mat[i][right]=c;\\n                c++;\\n            }\\n            right--;\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=right;i>=left;i--){\\n                mat[bottom][i]=c;\\n                c++;\\n            }\\n            bottom--;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=bottom;i>=top;i--){\\n                mat[i][left]=c;\\n                c++;\\n            }\\n            left++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int left=0,right=n-1,top=0,bottom=n-1,c=1;\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n        while(1){\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=left;i<=right;i++){\\n                mat[top][i]=c;\\n                c++;\\n            }\\n            top++;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=top;i<=bottom;i++){\\n                mat[i][right]=c;\\n                c++;\\n            }\\n            right--;\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=right;i>=left;i--){\\n                mat[bottom][i]=c;\\n                c++;\\n            }\\n            bottom--;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=bottom;i>=top;i--){\\n                mat[i][left]=c;\\n                c++;\\n            }\\n            left++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081014,
                "title": "spiral-matrix-ii-js-solution-beats-100",
                "content": "```\\nvar generateMatrix = function (n) {\\n    let dr = [0, 1, 0, -1],\\n        dc = [1, 0, -1, 0],\\n        dir = 0,\\n        board = [],\\n        row = 0,\\n        col = 0;\\n    for (let i = 0; i < n; i++) {\\n        board[i] = Array(n).fill(0)\\n    }\\n    for (i = 1; i <= n * n; i++) {\\n        board[row][col] = i\\n        let nRow = row + dr[dir % 4],\\n            nCol = col + dc[dir % 4]\\n        if (nRow >= 0 && nRow < n && nCol >= 0 && nCol < n && board[nRow] && board[nRow][nCol] == 0) {\\n            row = nRow\\n            col = nCol\\n        } else {\\n            dir++\\n            row += dr[dir % 4]\\n            col += dc[dir % 4]\\n        }\\n    }\\n    return board\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateMatrix = function (n) {\\n    let dr = [0, 1, 0, -1],\\n        dc = [1, 0, -1, 0],\\n        dir = 0,\\n        board = [],\\n        row = 0,\\n        col = 0;\\n    for (let i = 0; i < n; i++) {\\n        board[i] = Array(n).fill(0)\\n    }\\n    for (i = 1; i <= n * n; i++) {\\n        board[row][col] = i\\n        let nRow = row + dr[dir % 4],\\n            nCol = col + dc[dir % 4]\\n        if (nRow >= 0 && nRow < n && nCol >= 0 && nCol < n && board[nRow] && board[nRow][nCol] == 0) {\\n            row = nRow\\n            col = nCol\\n        } else {\\n            dir++\\n            row += dr[dir % 4]\\n            col += dc[dir % 4]\\n        }\\n    }\\n    return board\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 963724,
                "title": "c-super-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isNextValid(int x, int y, int direction_x, int direction_y, int n, vector<vector<int>> mat) {\\n        if ((x + direction_x < 0) || (x + direction_x >= n))\\n            return false;\\n        if ((y + direction_y < 0) || (y + direction_y >= n))\\n            return false;\\n        if (mat[y + direction_y][x + direction_x] != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        int direction_x = 1, direction_y = 0;\\n        int curr_x = 0, curr_y = 0;\\n        int count = 1;\\n        \\n        while (count <= pow(n, 2)) {\\n            mat[curr_y][curr_x] = count;\\n\\t\\t\\t\\n            // If next cell is out of range or filled already - change direction:\\n            if (!isNextValid(curr_x, curr_y, direction_x, direction_y, n, mat)) {\\n                swap(direction_x, direction_y);\\n                direction_x *= -1;\\n            }\\n            curr_x += direction_x;\\n            curr_y += direction_y;\\n            count++;\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isNextValid(int x, int y, int direction_x, int direction_y, int n, vector<vector<int>> mat) {\\n        if ((x + direction_x < 0) || (x + direction_x >= n))\\n            return false;\\n        if ((y + direction_y < 0) || (y + direction_y >= n))\\n            return false;\\n        if (mat[y + direction_y][x + direction_x] != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        int direction_x = 1, direction_y = 0;\\n        int curr_x = 0, curr_y = 0;\\n        int count = 1;\\n        \\n        while (count <= pow(n, 2)) {\\n            mat[curr_y][curr_x] = count;\\n\\t\\t\\t\\n            // If next cell is out of range or filled already - change direction:\\n            if (!isNextValid(curr_x, curr_y, direction_x, direction_y, n, mat)) {\\n                swap(direction_x, direction_y);\\n                direction_x *= -1;\\n            }\\n            curr_x += direction_x;\\n            curr_y += direction_y;\\n            count++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819134,
                "title": "python-easy-to-understand-fast-o-n-2-time-and-space-complexity-explained",
                "content": "Objective is to traverse matrix in spiral order and assign values in ascending order. \\n\\nSo we can use directions 0 being left to right, 1 being right to down, 2 being down to left and 3 being down to up left corner. \\n\\nTo keep track of how much data we have fiiled we will use 4 variables **sr** (starting row/rows filled), **sc**(starting column/columns filled), **er** (ending row till which rows are filled), **ec** (ending column till which column are filled)\\n\\nEach time we go from upper left to right we increment sr (starting row) count by 1 denoting that we have filled that row. \\nThen we go from right corner up to down and we decrement ec (ending column) by 1 denoting that we filled right most column. \\nThen we go from bottom right to bottom left and fill the bottom row and decrement er (ending row) count by 1 denoting we have filled that row.\\nAnd same with the left most column going from bottom to up and incrementing sc (starting column) count by 1.\\n\\nWe will use these 4 variables into our program to navigate each direction from sc to ec, sr to er, ec to sc, er to sr.\\n\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        \\n        direction = 0\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n            if direction == 0:\\n                for i in range(sc, ec+1):\\n                    matrix[sr][i] = counter\\n                    counter+=1\\n                sr+=1\\n                direction = 1\\n            elif direction==1:\\n                for i in range(sr, er+1):\\n                    matrix[i][ec] = counter\\n                    counter+=1\\n                ec-=1\\n                direction = 2\\n            elif direction==2:\\n                for i in range(ec, sc-1, -1):\\n                    matrix[er][i] = counter\\n                    counter+=1\\n                er-=1\\n                direction = 3\\n            else:\\n                for i in range(er, sr-1, -1):\\n                    matrix[i][sc] = counter\\n                    counter+=1\\n                sc+=1\\n                direction = 0\\n        \\n        return matrix\\n```\\n\\nSimplifying the code further. If you notice properly, we donot really need direction variable at all. Reason being that we have a square matrix and hence sr, sc, er, ec all would meet at the center. If the matrix was not square we would not be able to do this simplification. We can eliminate whole if else structure.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n\\n            for i in range(sc, ec+1):\\n                matrix[sr][i] = counter\\n                counter+=1\\n            sr+=1\\n\\n            for i in range(sr, er+1):\\n                matrix[i][ec] = counter\\n                counter+=1\\n            ec-=1\\n\\n            for i in range(ec, sc-1, -1):\\n                matrix[er][i] = counter\\n                counter+=1\\n            er-=1\\n\\n            for i in range(er, sr-1, -1):\\n                matrix[i][sc] = counter\\n                counter+=1\\n            sc+=1\\n        \\n        return matrix\\n```\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(N^2)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        \\n        direction = 0\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n            if direction == 0:\\n                for i in range(sc, ec+1):\\n                    matrix[sr][i] = counter\\n                    counter+=1\\n                sr+=1\\n                direction = 1\\n            elif direction==1:\\n                for i in range(sr, er+1):\\n                    matrix[i][ec] = counter\\n                    counter+=1\\n                ec-=1\\n                direction = 2\\n            elif direction==2:\\n                for i in range(ec, sc-1, -1):\\n                    matrix[er][i] = counter\\n                    counter+=1\\n                er-=1\\n                direction = 3\\n            else:\\n                for i in range(er, sr-1, -1):\\n                    matrix[i][sc] = counter\\n                    counter+=1\\n                sc+=1\\n                direction = 0\\n        \\n        return matrix\\n```\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n\\n            for i in range(sc, ec+1):\\n                matrix[sr][i] = counter\\n                counter+=1\\n            sr+=1\\n\\n            for i in range(sr, er+1):\\n                matrix[i][ec] = counter\\n                counter+=1\\n            ec-=1\\n\\n            for i in range(ec, sc-1, -1):\\n                matrix[er][i] = counter\\n                counter+=1\\n            er-=1\\n\\n            for i in range(er, sr-1, -1):\\n                matrix[i][sc] = counter\\n                counter+=1\\n            sc+=1\\n        \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732201,
                "title": "a-different-and-quick-approach-in-rust-but-explained",
                "content": "The most common approach is simulating, but actually we can write a function that maps `(n, x, y)` to `cell value`.\\n\\nFor example:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nIf we can write a function that maps `n=3, x=1, y = 2` to `6`, the problem will be easily solved.\\n\\n#### How to write it?\\n\\nWell, people may have different approaches, but mine is regarding the map as an onion which consists of several circles like this:\\n\\n```\\n[2, 2, 2, 2, 2, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 1, 0, 0, 1, 2],\\n[2, 1, 0, 0, 1, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 2, 2, 2, 2, 2]\\n```\\n\\nWith the circle numer(0-2), we calculate the base(the number current circle begins with):\\n\\n```\\n[0, 0,  0,  0,  0,  0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 0,  0,  0,  0,  0]]\\n```\\n\\nThen we calculates the offset(position of the cell locates on the circle):\\n\\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 0,  1,  2,  3,  6 ], \\n[18, 11, 0,  1,  4,  7 ], \\n[17, 10, 3,  2,  5,  8 ], \\n[16, 9,  8,  7,  6,  9 ], \\n[15, 14, 13, 12, 11, 10]\\n```\\n\\nThen we add it together:\\n\\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 20, 21, 22, 23, 6 ], \\n[18, 31, 32, 33, 24, 7 ], \\n[17, 30, 35, 34, 25, 8 ],\\n[16, 29, 28, 27, 26, 9 ],\\n[15, 14, 13, 12, 11, 10]\\n```\\n\\nThat\\'s all. Don\\'t forget to add 1. LOL. I wrote it in Rust:\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Spiral Matrix II.\\n```\\n\\n```Rust\\nfn spiral(n: usize, x: usize, y: usize) -> usize {\\n    let loop_max = (n - 1) / 2;\\n\\n    let tmp = |x| {\\n        if x <= loop_max {\\n            loop_max - x\\n        } else {\\n            x + loop_max + 1 - n\\n        }\\n    };\\n\\n    let loop_count = tmp(x).max(tmp(y));\\n\\n    let circle_len: fn(usize) -> usize = if n % 2 == 0 {\\n        |x| 8 * x + 4\\n    } else {\\n        |x| if x == 0 { 1 } else { 8 * x }\\n    };\\n\\n    let base = (loop_max - loop_count) * (circle_len(loop_max) + circle_len(loop_count + 1)) / 2;\\n\\n    let current_circle_len = circle_len(loop_count);\\n\\n    let diff = loop_max - loop_count;\\n\\n    let offset = if y == diff {\\n        x - y\\n    } else if x == n - 1 - diff {\\n        current_circle_len / 4 + (y - diff)\\n    } else if y == n - 1 - diff {\\n        3 * current_circle_len / 4 - (x - diff)\\n    } else if x == diff {\\n        current_circle_len - (y - diff)\\n    } else {\\n        unreachable!()\\n    };\\n\\n    base + offset\\n}\\n\\npub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\\n    if n == 0 {\\n        return vec![];\\n    }\\n    let n = n as usize;\\n    let mut result = vec![Vec::with_capacity(n); n];\\n    for y in 0..n {\\n        for x in 0..n {\\n            result[y].push(spiral(n, x, y) as i32 + 1);\\n        }\\n    }\\n    result\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\n[2, 2, 2, 2, 2, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 1, 0, 0, 1, 2],\\n[2, 1, 0, 0, 1, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 2, 2, 2, 2, 2]\\n```\n```\\n[0, 0,  0,  0,  0,  0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 0,  0,  0,  0,  0]]\\n```\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 0,  1,  2,  3,  6 ], \\n[18, 11, 0,  1,  4,  7 ], \\n[17, 10, 3,  2,  5,  8 ], \\n[16, 9,  8,  7,  6,  9 ], \\n[15, 14, 13, 12, 11, 10]\\n```\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 20, 21, 22, 23, 6 ], \\n[18, 31, 32, 33, 24, 7 ], \\n[17, 30, 35, 34, 25, 8 ],\\n[16, 29, 28, 27, 26, 9 ],\\n[15, 14, 13, 12, 11, 10]\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Spiral Matrix II.\\n```\n```Rust\\nfn spiral(n: usize, x: usize, y: usize) -> usize {\\n    let loop_max = (n - 1) / 2;\\n\\n    let tmp = |x| {\\n        if x <= loop_max {\\n            loop_max - x\\n        } else {\\n            x + loop_max + 1 - n\\n        }\\n    };\\n\\n    let loop_count = tmp(x).max(tmp(y));\\n\\n    let circle_len: fn(usize) -> usize = if n % 2 == 0 {\\n        |x| 8 * x + 4\\n    } else {\\n        |x| if x == 0 { 1 } else { 8 * x }\\n    };\\n\\n    let base = (loop_max - loop_count) * (circle_len(loop_max) + circle_len(loop_count + 1)) / 2;\\n\\n    let current_circle_len = circle_len(loop_count);\\n\\n    let diff = loop_max - loop_count;\\n\\n    let offset = if y == diff {\\n        x - y\\n    } else if x == n - 1 - diff {\\n        current_circle_len / 4 + (y - diff)\\n    } else if y == n - 1 - diff {\\n        3 * current_circle_len / 4 - (x - diff)\\n    } else if x == diff {\\n        current_circle_len - (y - diff)\\n    } else {\\n        unreachable!()\\n    };\\n\\n    base + offset\\n}\\n\\npub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\\n    if n == 0 {\\n        return vec![];\\n    }\\n    let n = n as usize;\\n    let mut result = vec![Vec::with_capacity(n); n];\\n    for y in 0..n {\\n        for x in 0..n {\\n            result[y].push(spiral(n, x, y) as i32 + 1);\\n        }\\n    }\\n    result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726326,
                "title": "java-simple-and-easy-to-read",
                "content": "The approach is similar to other ones but I liked how clean my solution looked and thougth I would share! :)\\n\\nTime: O(n) where n is the total number of spaces to fill in the grid\\n```\\npublic int[][] generateMatrix(int n) {\\n        // Go around until im done and while I can\\n        \\n        int total = n*n;\\n        int[][] grid = new int[n][n]; // This will initialize every element with 0\\n        \\n        int i = 1;\\n        int r = 0, c = -1;\\n        while (i <= total) {\\n            // Go right as long as I can aka the next space is 0\\n            while (c < n - 1 && grid[r][c+1] == 0) {\\n                grid[r][++c] = i++;\\n            }\\n            \\n            // Go down\\n            while (r < n - 1 && grid[r+1][c] == 0) {\\n                grid[++r][c] = i++;\\n            }\\n            \\n            // Go left\\n            while (c > 0 && grid[r][c-1] == 0) {\\n                grid[r][--c] = i++;\\n            }\\n            // Go up\\n            while (r > 0 && grid[r-1][c] == 0) {\\n                grid[--r][c] = i++;\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }",
                "solutionTags": [],
                "code": "The approach is similar to other ones but I liked how clean my solution looked and thougth I would share! :)\\n\\nTime: O(n) where n is the total number of spaces to fill in the grid\\n```\\npublic int[][] generateMatrix(int n) {\\n        // Go around until im done and while I can\\n        \\n        int total = n*n;\\n        int[][] grid = new int[n][n]; // This will initialize every element with 0\\n        \\n        int i = 1;\\n        int r = 0, c = -1;\\n        while (i <= total) {\\n            // Go right as long as I can aka the next space is 0\\n            while (c < n - 1 && grid[r][c+1] == 0) {\\n                grid[r][++c] = i++;\\n            }\\n            \\n            // Go down\\n            while (r < n - 1 && grid[r+1][c] == 0) {\\n                grid[++r][c] = i++;\\n            }\\n            \\n            // Go left\\n            while (c > 0 && grid[r][c-1] == 0) {\\n                grid[r][--c] = i++;\\n            }\\n            // Go up\\n            while (r > 0 && grid[r-1][c] == 0) {\\n                grid[--r][c] = i++;\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 547692,
                "title": "short-and-clean-dfs",
                "content": "```\\npublic class Solution \\n{\\n    private int count = 0;\\n    \\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        \\n        for(int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        DFS(mat, 0, 0, n, Direction.RIGHT);\\n        \\n        return mat;\\n    }\\n    \\n    private void DFS(int[][] mat, int r, int c, int n, Direction direction)\\n    {\\n        if(r < 0 || c < 0 || r > n - 1 || c > n - 1 || mat[r][c] > 0)\\n            return;\\n        \\n        mat[r][c] = ++count;\\n        \\n        switch(direction)\\n        {\\n            case Direction.RIGHT:\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                break;\\n            case Direction.DOWN:\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                break;\\n            case Direction.LEFT:\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                break;\\n            case Direction.UP:\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n}\\n\\npublic enum Direction\\n{\\n    RIGHT,\\n    DOWN,\\n    LEFT,\\n    UP\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private int count = 0;\\n    \\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        \\n        for(int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        DFS(mat, 0, 0, n, Direction.RIGHT);\\n        \\n        return mat;\\n    }\\n    \\n    private void DFS(int[][] mat, int r, int c, int n, Direction direction)\\n    {\\n        if(r < 0 || c < 0 || r > n - 1 || c > n - 1 || mat[r][c] > 0)\\n            return;\\n        \\n        mat[r][c] = ++count;\\n        \\n        switch(direction)\\n        {\\n            case Direction.RIGHT:\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                break;\\n            case Direction.DOWN:\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                break;\\n            case Direction.LEFT:\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                break;\\n            case Direction.UP:\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n}\\n\\npublic enum Direction\\n{\\n    RIGHT,\\n    DOWN,\\n    LEFT,\\n    UP\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508440,
                "title": "java-my-easy-solution",
                "content": "```\\npublic int[][] generateMatrix(int n) {\\n\\tint sol[][] = new int[n][n], count = 1;\\n\\tint rowMin = 0, colMin = 0, rowMax = n-1, colMax = n-1;\\n\\twhile(rowMin <= rowMax && colMin <= colMax) {\\n\\t\\tfor(int i = colMin; i <= colMax; i++) \\n\\t\\t\\tsol[rowMin][i] = count++;\\n\\t\\trowMin++;\\n\\t\\tfor(int i = rowMin; i <= rowMax; i++) \\n\\t\\t\\tsol[i][colMax] = count++;\\n\\t\\tcolMax--;\\n\\t\\tfor(int i = colMax; i >= colMin; i--)\\n\\t\\t\\tsol[rowMax][i] = count++;\\n\\t\\trowMax--;\\n\\t\\tfor(int i = rowMax; i >= rowMin; i--)\\n\\t\\t\\tsol[i][colMin] = count++;\\n\\t\\tcolMin++;\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n\\tint sol[][] = new int[n][n], count = 1;\\n\\tint rowMin = 0, colMin = 0, rowMax = n-1, colMax = n-1;\\n\\twhile(rowMin <= rowMax && colMin <= colMax) {\\n\\t\\tfor(int i = colMin; i <= colMax; i++) \\n\\t\\t\\tsol[rowMin][i] = count++;\\n\\t\\trowMin++;\\n\\t\\tfor(int i = rowMin; i <= rowMax; i++) \\n\\t\\t\\tsol[i][colMax] = count++;\\n\\t\\tcolMax--;\\n\\t\\tfor(int i = colMax; i >= colMin; i--)\\n\\t\\t\\tsol[rowMax][i] = count++;\\n\\t\\trowMax--;\\n\\t\\tfor(int i = rowMax; i >= rowMin; i--)\\n\\t\\t\\tsol[i][colMin] = count++;\\n\\t\\tcolMin++;\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477625,
                "title": "c",
                "content": "```\\npublic int[][] GenerateMatrix(int n) {\\n      \\n        int[][] result = new int[n][];\\n        for(int i = 0 ; i < result.Length; i++){\\n            result[i] = new int[n];\\n        }\\n        \\n        int count = 1;\\n        int rLowerEnd = 0, rHigherEnd = result.Length - 1;\\n        int cLowerEnd = 0, cHigherEnd = result[0].Length - 1;\\n        \\n        \\n        while (rLowerEnd <= rHigherEnd && cLowerEnd <= cHigherEnd) {\\n            for (int c = cLowerEnd; c <= cHigherEnd; c++) \\n                result[rLowerEnd][c] = count++;\\n            for (int r = rLowerEnd + 1; r <= rHigherEnd; r++) \\n                result[r][cHigherEnd] = count++;\\n            \\n            if (rLowerEnd < rHigherEnd && cLowerEnd < cHigherEnd) {\\n                for (int c = cHigherEnd - 1; c > cLowerEnd; c--) \\n                    result[rHigherEnd][c] = count++;\\n                for (int r = rHigherEnd; r > rLowerEnd; r--) \\n                    result[r][cLowerEnd] = count++;\\n            }\\n            // Move one row down \\n            rLowerEnd++;\\n            // move one row up\\n            rHigherEnd--;\\n            // move one column inside \\n            cLowerEnd++;\\n             // move one column inside \\n            cHigherEnd--;\\n        }        \\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] GenerateMatrix(int n) {\\n      \\n        int[][] result = new int[n][];\\n        for(int i = 0 ; i < result.Length; i++){\\n            result[i] = new int[n];\\n        }\\n        \\n        int count = 1;\\n        int rLowerEnd = 0, rHigherEnd = result.Length - 1;\\n        int cLowerEnd = 0, cHigherEnd = result[0].Length - 1;\\n        \\n        \\n        while (rLowerEnd <= rHigherEnd && cLowerEnd <= cHigherEnd) {\\n            for (int c = cLowerEnd; c <= cHigherEnd; c++) \\n                result[rLowerEnd][c] = count++;\\n            for (int r = rLowerEnd + 1; r <= rHigherEnd; r++) \\n                result[r][cHigherEnd] = count++;\\n            \\n            if (rLowerEnd < rHigherEnd && cLowerEnd < cHigherEnd) {\\n                for (int c = cHigherEnd - 1; c > cLowerEnd; c--) \\n                    result[rHigherEnd][c] = count++;\\n                for (int r = rHigherEnd; r > rLowerEnd; r--) \\n                    result[r][cLowerEnd] = count++;\\n            }\\n            // Move one row down \\n            rLowerEnd++;\\n            // move one row up\\n            rHigherEnd--;\\n            // move one column inside \\n            cLowerEnd++;\\n             // move one column inside \\n            cHigherEnd--;\\n        }        \\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309040,
                "title": "c-100-beat-using-smart-loops-smart-memories-super-hack-video-rental-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> aResult(n, vector<int>(n));\\n        \\n        int _U = 0, _R = n - 1, _D = n - 1, _L = 0, x = 0, y = 0, VAL = 1;\\n        \\n        while (_L <= _R) {\\n            \\n            x = _L; y = _U;\\n            \\n            //Sweep right across the top.\\n            while (x <= _R) { aResult[y][x++] = VAL++; }\\n            _U += 1; y = _U;\\n            \\n            //Sweep down the right side.\\n            while (y <= _D) { aResult[y++][_R] = VAL++; }\\n            _R -= 1; x = _R;\\n            \\n            //Swipe left across the bottom.\\n            while (x >= _L) { aResult[_D][x--] = VAL++; }\\n            _D -= 1; y = _D;\\n            \\n            //Sweep up the left side.\\n            while (y >= _U) { aResult[y--][_L] = VAL++; }\\n            _L += 1;\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nDecided to try with all the variables being named in terrible ways. I am not sure how you can clock more speed given that the result needs to be a vector of vectors.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> aResult(n, vector<int>(n));\\n        \\n        int _U = 0, _R = n - 1, _D = n - 1, _L = 0, x = 0, y = 0, VAL = 1;\\n        \\n        while (_L <= _R) {\\n            \\n            x = _L; y = _U;\\n            \\n            //Sweep right across the top.\\n            while (x <= _R) { aResult[y][x++] = VAL++; }\\n            _U += 1; y = _U;\\n            \\n            //Sweep down the right side.\\n            while (y <= _D) { aResult[y++][_R] = VAL++; }\\n            _R -= 1; x = _R;\\n            \\n            //Swipe left across the bottom.\\n            while (x >= _L) { aResult[_D][x--] = VAL++; }\\n            _D -= 1; y = _D;\\n            \\n            //Sweep up the left side.\\n            while (y >= _U) { aResult[y--][_L] = VAL++; }\\n            _L += 1;\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285553,
                "title": "java-solution-beating-100-of-java-submissions-in-both-runtime-and-memory-usage",
                "content": "```\\npublic int[][] generateMatrix(int n) {\\n    int[][] rs = new int[n][n];\\n    \\n    int r1 = 0;\\n\\tint r2 = n - 1;\\n\\tint c1 = 0;\\n\\tint c2 = n - 1;\\n\\tint num = 1;\\n\\twhile (r1 <= r2 && c1 <= c2) {\\n\\t\\tfor (int c = c1; c <= c2; c++)\\n\\t\\t\\trs[r1][c] = num++;\\n\\t\\t\\n\\t\\tfor (int r = r1 + 1; r <= r2; r++)\\n\\t\\t\\trs[r][c2] = num++;\\n\\t\\t\\n\\t\\tif (r1 < r2 && c1 < c2) {\\n\\t\\t\\tfor (int c = c2 - 1; c > c1; c--)\\n\\t\\t\\t\\trs[r2][c] = num++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int r = r2; r > r1; r--)\\n\\t\\t\\t\\trs[r][c1] = num++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tr1++;\\n\\t\\tc1++;\\n\\t\\tr2--;\\n\\t\\tc2--;\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n    int[][] rs = new int[n][n];\\n    \\n    int r1 = 0;\\n\\tint r2 = n - 1;\\n\\tint c1 = 0;\\n\\tint c2 = n - 1;\\n\\tint num = 1;\\n\\twhile (r1 <= r2 && c1 <= c2) {\\n\\t\\tfor (int c = c1; c <= c2; c++)\\n\\t\\t\\trs[r1][c] = num++;\\n\\t\\t\\n\\t\\tfor (int r = r1 + 1; r <= r2; r++)\\n\\t\\t\\trs[r][c2] = num++;\\n\\t\\t\\n\\t\\tif (r1 < r2 && c1 < c2) {\\n\\t\\t\\tfor (int c = c2 - 1; c > c1; c--)\\n\\t\\t\\t\\trs[r2][c] = num++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int r = r2; r > r1; r--)\\n\\t\\t\\t\\trs[r][c1] = num++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tr1++;\\n\\t\\tc1++;\\n\\t\\tr2--;\\n\\t\\tc2--;\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131432,
                "title": "simple-javascript-solution-beating-100",
                "content": "```\\nvar generateMatrix = function(n) {\\n    let square = Array(n).fill(0).map(el => Array(n).fill(0));\\n    let count, row, col;\\n    count = row = col = 0;\\n    while (count < n * n) {\\n        while (square[row][col] === 0) {\\n            square[row][col++] = ++count;\\n        }\\n        col--;\\n        row++;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row++][col] = ++count;\\n        }\\n        row--;\\n        col--;\\n        while (square[row][col] === 0) {\\n            square[row][col--] = ++count;\\n        }\\n        col++;\\n        row--;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row--][col] = ++count;\\n        }\\n        row++;\\n        col++;\\n    }\\n    return square;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar generateMatrix = function(n) {\\n    let square = Array(n).fill(0).map(el => Array(n).fill(0));\\n    let count, row, col;\\n    count = row = col = 0;\\n    while (count < n * n) {\\n        while (square[row][col] === 0) {\\n            square[row][col++] = ++count;\\n        }\\n        col--;\\n        row++;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row++][col] = ++count;\\n        }\\n        row--;\\n        col--;\\n        while (square[row][col] === 0) {\\n            square[row][col--] = ++count;\\n        }\\n        col++;\\n        row--;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row--][col] = ++count;\\n        }\\n        row++;\\n        col++;\\n    }\\n    return square;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22322,
                "title": "golang-3-ms",
                "content": "```\\nfunc generateMatrix(n int) [][]int {\\n        matrix := make([][]int, n)\\n        for i := range matrix {\\n            matrix[i] = make([]int, n)\\n        }\\n        \\n        if n==0 {\\n            return matrix\\n        }\\n        \\n        rowStart := 0\\n        rowEnd := n - 1\\n        colStart := 0\\n        colEnd := n - 1\\n        num := 1\\n        \\n        for rowStart <= rowEnd && colStart <= colEnd {\\n            for i := colStart; i <= colEnd; i++ {\\n                matrix[rowStart][i] = num\\n                num++\\n            }\\n            rowStart++\\n            \\n            for i := rowStart;i<=rowEnd; i++ {\\n                matrix[i][colEnd] = num\\n                num++\\n            }\\n            colEnd--\\n            for  i:= colEnd; i >= colStart; i-- {\\n                if rowStart <= rowEnd {\\n                    matrix[rowEnd][i] = num\\n                    num++\\n                }\\n            }\\n            rowEnd--\\n            for  i:= rowEnd; i >= rowStart; i-- {\\n                if colStart <= colEnd {\\n                    matrix[i][colStart] = num\\n                    num++\\n                }\\n            }\\n            colStart++\\n        }\\n        return matrix\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateMatrix(n int) [][]int {\\n        matrix := make([][]int, n)\\n        for i := range matrix {\\n            matrix[i] = make([]int, n)\\n        }\\n        \\n        if n==0 {\\n            return matrix\\n        }\\n        \\n        rowStart := 0\\n        rowEnd := n - 1\\n        colStart := 0\\n        colEnd := n - 1\\n        num := 1\\n        \\n        for rowStart <= rowEnd && colStart <= colEnd {\\n            for i := colStart; i <= colEnd; i++ {\\n                matrix[rowStart][i] = num\\n                num++\\n            }\\n            rowStart++\\n            \\n            for i := rowStart;i<=rowEnd; i++ {\\n                matrix[i][colEnd] = num\\n                num++\\n            }\\n            colEnd--\\n            for  i:= colEnd; i >= colStart; i-- {\\n                if rowStart <= rowEnd {\\n                    matrix[rowEnd][i] = num\\n                    num++\\n                }\\n            }\\n            rowEnd--\\n            for  i:= rowEnd; i >= rowStart; i-- {\\n                if colStart <= colEnd {\\n                    matrix[i][colStart] = num\\n                    num++\\n                }\\n            }\\n            colStart++\\n        }\\n        return matrix\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050368,
                "title": "spiral-matrix-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757828,
                "title": "spiral-matrix-ii-o-m-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nfunction getNeighbors(array, rowIndex, columnIndex, storage) {\\n    const neighbors = {};\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex + 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex + 1}`]\\n    ) {\\n        neighbors.right = { rowIndex: rowIndex, columnIndex: columnIndex + 1 };\\n    }\\n\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex - 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex - 1}`]\\n    ) {\\n        neighbors.left = { rowIndex: rowIndex, columnIndex: columnIndex - 1 };\\n    }\\n    if (\\n        array[rowIndex + 1] &&\\n        array[rowIndex + 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex + 1}_${columnIndex}`]\\n    ) {\\n        neighbors.down = { rowIndex: rowIndex + 1, columnIndex: columnIndex };\\n    }\\n    if (\\n        array[rowIndex - 1] &&\\n        array[rowIndex - 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex - 1}_${columnIndex}`]\\n    ) {\\n        neighbors.up = { rowIndex: rowIndex - 1, columnIndex: columnIndex };\\n    }\\n    return neighbors;\\n}\\n\\nvar generateMatrix = function(size) {\\n    const output = [];\\n    const storage = {};\\n    let count = 2;\\n    let movement = `row`;\\n    let rowIndex = 0;\\n    let columnIndex = 0;\\n    let tempSize = size * size;\\n    for (let rowIndex = 0; rowIndex < size; rowIndex++) {\\n        output[rowIndex] = [];\\n        for (let columnIndex = 0; columnIndex < size; columnIndex++) {\\n            output[rowIndex][columnIndex] = 1;\\n        }\\n    }\\n    while (tempSize--) {\\n        storage[`${rowIndex}_${columnIndex}`] = true;\\n        const neighbors = getNeighbors(output, rowIndex, columnIndex, storage);\\n        if (Object.keys(neighbors).length === 0) {\\n            break;\\n        }\\n        if (Object.keys(neighbors).length === 1) {\\n            if (neighbors.right) {\\n                rowIndex = neighbors.right.rowIndex;\\n                columnIndex = neighbors.right.columnIndex;\\n                if (!output[neighbors.right.columnIndex]) {\\n                    output[neighbors.right.columnIndex] = [];\\n                }\\n                output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.left) {\\n                rowIndex = neighbors.left.rowIndex;\\n                columnIndex = neighbors.left.columnIndex;\\n                if (!output[neighbors.left.columnIndex]) {\\n                    output[neighbors.left.columnIndex] = [];\\n                }\\n                output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.down) {\\n                rowIndex = neighbors.down.rowIndex;\\n                columnIndex = neighbors.down.columnIndex;\\n                if (!output[neighbors.down.columnIndex]) {\\n                    output[neighbors.down.columnIndex] = [];\\n                }\\n                output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                movement = `column`;\\n            } else {\\n                rowIndex = neighbors.up.rowIndex;\\n                columnIndex = neighbors.up.columnIndex;\\n                if (!output[neighbors.up.columnIndex]) {\\n                    output[neighbors.up.columnIndex] = [];\\n                }\\n                output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                movement = `column`;\\n            }\\n        } else {\\n            if (movement === `row`) {\\n                if (neighbors.right) {\\n                    rowIndex = neighbors.right.rowIndex;\\n                    columnIndex = neighbors.right.columnIndex;\\n                    if (!output[neighbors.right.columnIndex]) {\\n                        output[neighbors.right.columnIndex] = [];\\n                    }\\n                    output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.left.rowIndex;\\n                    columnIndex = neighbors.left.columnIndex;\\n                    if (!output[neighbors.left.columnIndex]) {\\n                        output[neighbors.left.columnIndex] = [];\\n                    }\\n                    output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                }\\n            } else {\\n                if (neighbors.up) {\\n                    rowIndex = neighbors.up.rowIndex;\\n                    columnIndex = neighbors.up.columnIndex;\\n                    if (!output[neighbors.up.columnIndex]) {\\n                        output[neighbors.up.columnIndex] = [];\\n                    }\\n                    output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.down.rowIndex;\\n                    columnIndex = neighbors.down.columnIndex;\\n                    if (!output[neighbors.down.columnIndex]) {\\n                        output[neighbors.down.columnIndex] = [];\\n                    }\\n                    output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                }\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction getNeighbors(array, rowIndex, columnIndex, storage) {\\n    const neighbors = {};\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex + 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex + 1}`]\\n    ) {\\n        neighbors.right = { rowIndex: rowIndex, columnIndex: columnIndex + 1 };\\n    }\\n\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex - 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex - 1}`]\\n    ) {\\n        neighbors.left = { rowIndex: rowIndex, columnIndex: columnIndex - 1 };\\n    }\\n    if (\\n        array[rowIndex + 1] &&\\n        array[rowIndex + 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex + 1}_${columnIndex}`]\\n    ) {\\n        neighbors.down = { rowIndex: rowIndex + 1, columnIndex: columnIndex };\\n    }\\n    if (\\n        array[rowIndex - 1] &&\\n        array[rowIndex - 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex - 1}_${columnIndex}`]\\n    ) {\\n        neighbors.up = { rowIndex: rowIndex - 1, columnIndex: columnIndex };\\n    }\\n    return neighbors;\\n}\\n\\nvar generateMatrix = function(size) {\\n    const output = [];\\n    const storage = {};\\n    let count = 2;\\n    let movement = `row`;\\n    let rowIndex = 0;\\n    let columnIndex = 0;\\n    let tempSize = size * size;\\n    for (let rowIndex = 0; rowIndex < size; rowIndex++) {\\n        output[rowIndex] = [];\\n        for (let columnIndex = 0; columnIndex < size; columnIndex++) {\\n            output[rowIndex][columnIndex] = 1;\\n        }\\n    }\\n    while (tempSize--) {\\n        storage[`${rowIndex}_${columnIndex}`] = true;\\n        const neighbors = getNeighbors(output, rowIndex, columnIndex, storage);\\n        if (Object.keys(neighbors).length === 0) {\\n            break;\\n        }\\n        if (Object.keys(neighbors).length === 1) {\\n            if (neighbors.right) {\\n                rowIndex = neighbors.right.rowIndex;\\n                columnIndex = neighbors.right.columnIndex;\\n                if (!output[neighbors.right.columnIndex]) {\\n                    output[neighbors.right.columnIndex] = [];\\n                }\\n                output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.left) {\\n                rowIndex = neighbors.left.rowIndex;\\n                columnIndex = neighbors.left.columnIndex;\\n                if (!output[neighbors.left.columnIndex]) {\\n                    output[neighbors.left.columnIndex] = [];\\n                }\\n                output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.down) {\\n                rowIndex = neighbors.down.rowIndex;\\n                columnIndex = neighbors.down.columnIndex;\\n                if (!output[neighbors.down.columnIndex]) {\\n                    output[neighbors.down.columnIndex] = [];\\n                }\\n                output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                movement = `column`;\\n            } else {\\n                rowIndex = neighbors.up.rowIndex;\\n                columnIndex = neighbors.up.columnIndex;\\n                if (!output[neighbors.up.columnIndex]) {\\n                    output[neighbors.up.columnIndex] = [];\\n                }\\n                output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                movement = `column`;\\n            }\\n        } else {\\n            if (movement === `row`) {\\n                if (neighbors.right) {\\n                    rowIndex = neighbors.right.rowIndex;\\n                    columnIndex = neighbors.right.columnIndex;\\n                    if (!output[neighbors.right.columnIndex]) {\\n                        output[neighbors.right.columnIndex] = [];\\n                    }\\n                    output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.left.rowIndex;\\n                    columnIndex = neighbors.left.columnIndex;\\n                    if (!output[neighbors.left.columnIndex]) {\\n                        output[neighbors.left.columnIndex] = [];\\n                    }\\n                    output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                }\\n            } else {\\n                if (neighbors.up) {\\n                    rowIndex = neighbors.up.rowIndex;\\n                    columnIndex = neighbors.up.columnIndex;\\n                    if (!output[neighbors.up.columnIndex]) {\\n                        output[neighbors.up.columnIndex] = [];\\n                    }\\n                    output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.down.rowIndex;\\n                    columnIndex = neighbors.down.columnIndex;\\n                    if (!output[neighbors.down.columnIndex]) {\\n                        output[neighbors.down.columnIndex] = [];\\n                    }\\n                    output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                }\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692221,
                "title": "easiest-c-solution-faster-than-100",
                "content": "vector<vector<int>> generateMatrix(int n) {\\n     vector<vector<int>> ans(n,vector<int>(n));\\n        int sr=0;\\n        int sc=0;\\n        int er=n-1;\\n        int ec =n-1;\\n        int c=1;\\n        while(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++ ){\\n          ans[sr][i]= c;\\n            c++;\\n        }\\n        sr++;\\n    for(int i=sr;i<=er;i++ ){\\n          ans[i][ec]= c;\\n            c++;\\n        }\\n        ec--;\\n    for(int i=ec;i>=sc;i-- ){\\n          ans[er][i]= c;\\n            c++;\\n        }\\n        er--;\\n      for(int i=er;i>=sr;i-- ){\\n          ans[i][sc]= c;\\n            c++;\\n        }\\n        sc++; \\n    }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<vector<int>> generateMatrix(int n) {\\n     vector<vector<int>> ans(n,vector<int>(n));\\n        int sr=0;\\n        int sc=0;\\n        int er=n-1;\\n        int ec =n-1;\\n        int c=1;\\n        while(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++ ){\\n          ans[sr][i]= c;\\n            c++;\\n        }\\n        sr++;\\n    for(int i=sr;i<=er;i++ ){\\n          ans[i][ec]= c;\\n            c++;\\n        }\\n        ec--;\\n    for(int i=ec;i>=sc;i-- ){\\n          ans[er][i]= c;\\n            c++;\\n        }\\n        er--;\\n      for(int i=er;i>=sr;i-- ){\\n          ans[i][sc]= c;\\n            c++;\\n        }\\n        sc++; \\n    }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3524776,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3509821,
                "title": "java-super-easy-to-understand-code-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        //create a matrix of nxn size\\n        int[][] arr  = new int[n][n];\\n        //Initialized variables \\n        int top = 0 , bottom = n-1;\\n        int left = 0 , right = n-1;\\n        //Maintain counter to add elements in matrix \\n        int cnt =1;\\n        while(left <=  right && top<=bottom){\\n            //traverse left to right\\n            for (int i = left; i <= right; i++) {\\n                arr[top][i] = cnt++;\\n            }\\n            top++;\\n            //traverse top to bottom\\n            for(int i = top; i<=bottom;i++){\\n                arr[i][right] = cnt++;\\n            }\\n            right--;\\n            //traverse right to left\\n            if(top<=bottom){\\n                for (int i = right; i >=left; i--) {\\n                    arr[bottom][i] = cnt++;\\n                }\\n            }\\n            bottom--;\\n            //traverse bottom to top\\n            if(left<=right){\\n                for (int i = bottom; i >=top ; i--) {\\n                    arr[i][left] = cnt++;\\n                }\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        //create a matrix of nxn size\\n        int[][] arr  = new int[n][n];\\n        //Initialized variables \\n        int top = 0 , bottom = n-1;\\n        int left = 0 , right = n-1;\\n        //Maintain counter to add elements in matrix \\n        int cnt =1;\\n        while(left <=  right && top<=bottom){\\n            //traverse left to right\\n            for (int i = left; i <= right; i++) {\\n                arr[top][i] = cnt++;\\n            }\\n            top++;\\n            //traverse top to bottom\\n            for(int i = top; i<=bottom;i++){\\n                arr[i][right] = cnt++;\\n            }\\n            right--;\\n            //traverse right to left\\n            if(top<=bottom){\\n                for (int i = right; i >=left; i--) {\\n                    arr[bottom][i] = cnt++;\\n                }\\n            }\\n            bottom--;\\n            //traverse bottom to top\\n            if(left<=right){\\n                for (int i = bottom; i >=top ; i--) {\\n                    arr[i][left] = cnt++;\\n                }\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509654,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n\\xB2)\\n\\n- Space complexity:\\nO(n\\xB2)\\n\\n# Code\\n```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {    \\n        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n) \\n        var top = 0, bottom = n - 1\\n        var left = 0, right = n - 1\\n        var num = 1\\n        while top <= bottom && left <= right {\\n            for i in stride(from: left, to: right + 1, by: 1) {\\n                matrix[top][i] = num\\n                num += 1\\n            }\\n            top += 1\\n            \\n            for i in stride(from: top, to: bottom + 1, by: 1) {\\n                matrix[i][right] = num\\n                num += 1\\n            }\\n            right -= 1\\n            \\n            if top <= bottom {\\n                for i in stride(from: right, to: left - 1, by: -1) {\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                }\\n            }\\n            bottom -= 1\\n            \\n            if left <= right {\\n                for i in stride(from: bottom, to: top - 1, by: -1) {\\n                    matrix[i][left] = num \\n                    num += 1\\n                }\\n            }\\n            left += 1\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {    \\n        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n) \\n        var top = 0, bottom = n - 1\\n        var left = 0, right = n - 1\\n        var num = 1\\n        while top <= bottom && left <= right {\\n            for i in stride(from: left, to: right + 1, by: 1) {\\n                matrix[top][i] = num\\n                num += 1\\n            }\\n            top += 1\\n            \\n            for i in stride(from: top, to: bottom + 1, by: 1) {\\n                matrix[i][right] = num\\n                num += 1\\n            }\\n            right -= 1\\n            \\n            if top <= bottom {\\n                for i in stride(from: right, to: left - 1, by: -1) {\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                }\\n            }\\n            bottom -= 1\\n            \\n            if left <= right {\\n                for i in stride(from: bottom, to: top - 1, by: -1) {\\n                    matrix[i][left] = num \\n                    num += 1\\n                }\\n            }\\n            left += 1\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508767,
                "title": "java-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] arr = new int[n][n];\\n        int size = 1;\\n        int rs=0, re=n-1, cs=0, ce=n-1;\\n        while(size <= n*n){\\n            for(int i=cs; i<=ce; i++){\\n                arr[rs][i] = size++;\\n            }\\n            rs++;\\n            for(int i=rs; i<=re; i++){\\n                arr[i][ce] = size++;\\n            }\\n            ce--;\\n            if(rs<=re){\\n                for(int i=ce; i>=cs; i--){\\n                    arr[re][i] = size++;\\n                }\\n                re--;\\n            }\\n            if(cs<=ce){\\n                for(int i=re; i>=rs; i--){\\n                    arr[i][cs] = size++;\\n                }\\n                cs++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] arr = new int[n][n];\\n        int size = 1;\\n        int rs=0, re=n-1, cs=0, ce=n-1;\\n        while(size <= n*n){\\n            for(int i=cs; i<=ce; i++){\\n                arr[rs][i] = size++;\\n            }\\n            rs++;\\n            for(int i=rs; i<=re; i++){\\n                arr[i][ce] = size++;\\n            }\\n            ce--;\\n            if(rs<=re){\\n                for(int i=ce; i>=cs; i--){\\n                    arr[re][i] = size++;\\n                }\\n                re--;\\n            }\\n            if(cs<=ce){\\n                for(int i=re; i>=rs; i--){\\n                    arr[i][cs] = size++;\\n                }\\n                cs++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508582,
                "title": "c-simulation-solution-with-optimized-time-complexity",
                "content": "\\n\\n# Approach\\nThe given solution uses a simulation approach, where we keep track of the boundaries of the matrix using four variables: rowBegin, rowEnd, colBegin, and colEnd. We initialize these variables to 0 and n-1, as the first row and column are the boundaries of the matrix.\\n\\nWe then use a while loop to traverse the matrix in a spiral order. In each iteration of the loop, we traverse the matrix in four directions: right, down, left, and up. We use four for loops for this purpose, each of which increments or decrements one of the boundary variables, depending on the direction of traversal.\\n\\nAs we traverse the matrix, we fill in the elements with the values from 1 to n^2 in the order specified by the problem. We use a variable num to keep track of the value to be filled in each element. We increment this variable after each element is filled.\\n\\nOnce we have filled in all the elements of the matrix, we return the matrix as the final output.\\n\\n# Complexity\\n- Time complexity:\\n O(n^2) because we need to fill all n^2 elements of the matrix\\n\\n- Space complexity:\\nO(n^2) because we need to store the entire matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int rowBegin = 0, rowEnd = n-1, colBegin = 0, colEnd = n-1;\\n        int num = 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // traverse right\\n            for (int i = colBegin; i <= colEnd; ++i) {\\n                matrix[rowBegin][i] = num++;\\n            }\\n            ++rowBegin;\\n            \\n            // traverse down\\n            for (int i = rowBegin; i <= rowEnd; ++i) {\\n                matrix[i][colEnd] = num++;\\n            }\\n            --colEnd;\\n            \\n            // traverse left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; --i) {\\n                    matrix[rowEnd][i] = num++;\\n                }\\n            }\\n            --rowEnd;\\n            \\n            // traverse up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; --i) {\\n                    matrix[i][colBegin] = num++;\\n                }\\n            }\\n            ++colBegin;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int rowBegin = 0, rowEnd = n-1, colBegin = 0, colEnd = n-1;\\n        int num = 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // traverse right\\n            for (int i = colBegin; i <= colEnd; ++i) {\\n                matrix[rowBegin][i] = num++;\\n            }\\n            ++rowBegin;\\n            \\n            // traverse down\\n            for (int i = rowBegin; i <= rowEnd; ++i) {\\n                matrix[i][colEnd] = num++;\\n            }\\n            --colEnd;\\n            \\n            // traverse left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; --i) {\\n                    matrix[rowEnd][i] = num++;\\n                }\\n            }\\n            --rowEnd;\\n            \\n            // traverse up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; --i) {\\n                    matrix[i][colBegin] = num++;\\n                }\\n            }\\n            ++colBegin;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507935,
                "title": "beats-100-c",
                "content": "![image.png](https://assets.leetcode.com/users/images/9885d1be-a40b-42c1-87b9-34306fc0e161_1683707490.7883291.png)\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int data=1;\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        while(left<=right && top<=bottom)\\n        {\\n            for(int i=left;i<=right;i++) {\\n                ans[top][i] = data++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++) {\\n                ans[i][right] = data++;\\n            }\\n            right--;\\n            if(top <= bottom) {\\n                for(int i=right;i>=left;i--) {\\n                    ans[bottom][i] = data++;\\n                }\\n                bottom--;\\n            }\\n            if(left<=right) {\\n                for(int i=bottom;i>=top;i--) {\\n                    ans[i][left] = data++;\\n                }\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int data=1;\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        while(left<=right && top<=bottom)\\n        {\\n            for(int i=left;i<=right;i++) {\\n                ans[top][i] = data++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++) {\\n                ans[i][right] = data++;\\n            }\\n            right--;\\n            if(top <= bottom) {\\n                for(int i=right;i>=left;i--) {\\n                    ans[bottom][i] = data++;\\n                }\\n                bottom--;\\n            }\\n            if(left<=right) {\\n                for(int i=bottom;i>=top;i--) {\\n                    ans[i][left] = data++;\\n                }\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507661,
                "title": "java-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        int[][] ans = new int[n][n];\\n        int count=0;\\n        if(bottom==0){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[bottom][i]=count;\\n            }\\n            return ans;\\n        }\\n        if(right==0){\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            return ans;\\n        }\\n        while(top<=bottom && left <=right){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[top][i]=count;\\n            }\\n            top++;\\n\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            right--;\\n\\n            for(int k=right;k>=left;k--){\\n                count++;\\n                ans[bottom][k]=count;\\n            }\\n            bottom--;\\n\\n            for(int a=bottom;a>=top;a--){\\n                count++;\\n                ans[a][left]=count;\\n            }\\n            left++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        int[][] ans = new int[n][n];\\n        int count=0;\\n        if(bottom==0){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[bottom][i]=count;\\n            }\\n            return ans;\\n        }\\n        if(right==0){\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            return ans;\\n        }\\n        while(top<=bottom && left <=right){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[top][i]=count;\\n            }\\n            top++;\\n\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            right--;\\n\\n            for(int k=right;k>=left;k--){\\n                count++;\\n                ans[bottom][k]=count;\\n            }\\n            bottom--;\\n\\n            for(int a=bottom;a>=top;a--){\\n                count++;\\n                ans[a][left]=count;\\n            }\\n            left++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507492,
                "title": "my-java-o-n-2-solution-beats-100-of-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple and effective solution to create a matrix of size n x n with elements 1 to n^2 in a spiral order is to initialize the matrix with all zeros and then fill in the elements in the desired order by iterating through the matrix in a spiral pattern.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by initializing a 2D matrix of size n x n with all zeros. We then define four variables: rowStart, rowEnd, colStart, and colEnd, which represent the starting and ending indices for the rows and columns that we need to fill in. We also define a variable num, which represents the current number we want to fill in the matrix.\\n\\nWe then use a while loop to iterate through the matrix in a spiral pattern. In each iteration of the loop, we fill in the elements in the current row and column that we need to fill in. We then update the corresponding rowStart, rowEnd, colStart, and colEnd variables to reflect the fact that we have filled in those rows and columns.\\n\\nWe continue this process until we have filled in all the elements in the matrix in the desired order.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\nThe time complexity of this solution is O(n^2) because it needs to fill in every cell of the n x n matrix. The while loop runs exactly n/2 times, and each iteration fills in 4 rows or columns, which takes O(n) time. Therefore, the total time complexity is O(n/2 * 4n) = O(n^2).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n\\nThe space complexity of this solution is O(n^2) because the program needs to create an n x n matrix to store the result. No additional data structures are used, and the space required for the loop variables and integer counters is negligible compared to the size of the matrix.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // Declaration\\n        int[][] matrix = new int[n][n];\\n        \\n        // Edge Case\\n        if (n == 0) {\\n            return matrix;\\n        }\\n        \\n        // Normal Case\\n        int rowStart = 0;\\n        int rowEnd = n-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        int num = 1; //change\\n        \\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            for (int i = colStart; i <= colEnd; i ++) {\\n                matrix[rowStart][i] = num ++; //change\\n            }\\n            rowStart ++;\\n            \\n            for (int i = rowStart; i <= rowEnd; i ++) {\\n                matrix[i][colEnd] = num ++; //change\\n            }\\n            colEnd --;\\n            \\n            for (int i = colEnd; i >= colStart; i --) {\\n                if (rowStart <= rowEnd)\\n                    matrix[rowEnd][i] = num ++; //change\\n            }\\n            rowEnd --;\\n            \\n            for (int i = rowEnd; i >= rowStart; i --) {\\n                if (colStart <= colEnd)\\n                    matrix[i][colStart] = num ++; //change\\n            }\\n            colStart ++;\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // Declaration\\n        int[][] matrix = new int[n][n];\\n        \\n        // Edge Case\\n        if (n == 0) {\\n            return matrix;\\n        }\\n        \\n        // Normal Case\\n        int rowStart = 0;\\n        int rowEnd = n-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        int num = 1; //change\\n        \\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            for (int i = colStart; i <= colEnd; i ++) {\\n                matrix[rowStart][i] = num ++; //change\\n            }\\n            rowStart ++;\\n            \\n            for (int i = rowStart; i <= rowEnd; i ++) {\\n                matrix[i][colEnd] = num ++; //change\\n            }\\n            colEnd --;\\n            \\n            for (int i = colEnd; i >= colStart; i --) {\\n                if (rowStart <= rowEnd)\\n                    matrix[rowEnd][i] = num ++; //change\\n            }\\n            rowEnd --;\\n            \\n            for (int i = rowEnd; i >= rowStart; i --) {\\n                if (colStart <= colEnd)\\n                    matrix[i][colStart] = num ++; //change\\n            }\\n            colStart ++;\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507353,
                "title": "0ms-easy-approach-beasts-100-step-by-step-explanation",
                "content": "# Intuition\\n\\nEasy approach to solve this question :) \\uD83D\\uDD25.\\n\\nWe mainly focus on the `top row`, `right column`, `bottom row` & `left column` after creating a blank matrix.\\nAfter every iteration we increamnt `starting row` & `starting column` and decrement `ending row` & `ending column`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- **Creating** a blank matrix of size m.\\n`int[][] ans = new int[n][n];`\\n- **Initializing** the values for smooth travelling in the matrix \\n```\\nint startingRow = 0;\\nint endingRow = n - 1;\\nint startingCol = 0;\\nint endingCol = n - 1;\\n```\\n- For **Top Row** `Left -> Right` -> as we go left to right then we increament the values then we go to next row. i.e. `startingRow++`\\n```\\nfor (int i = startingCol; i <= endingCol; i++) {\\n        ans[startingRow][i] = count;\\n        count++;\\n    }\\n    startingRow++;\\n```\\n- For **Right Column** `Top-->Bottom` --> after the top row, for every next row we go with the last index value of every column, till last second row. Then decrement the ending column index  i.e. `endingCol--`.\\n```\\nfor (int i = startingRow; i <= endingRow; i++) {\\n        ans[i][endingCol] = count;\\n        count++;\\n    }\\n    endingCol--;\\n```\\n- For **Bottom Row** `Right-->LEft` --> we go right to left then we decrement the ending column variable. i.e. `endingCol--`.\\n```\\nfor (int i = endingCol; i >= startingCol; i--) {\\n        ans[endingRow][i] = count;\\n        count++;\\n    }\\n    endingRow--;\\n```\\n- For **Left Column** `Bottom-->Top` --> after the botto row, for every above row we go with the first index value till the top second row. Then we increment the first index of every column i.e. `startingCol++` . \\n```\\nfor (int i = endingRow; i >= startingRow; i--) {\\n        ans[i][startingCol] = count;\\n        count++;   \\n    }\\n    startingCol++;\\n```\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/f9496ec6-b5f3-4fd9-83af-4a801efab4ef_1683697175.891551.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n                \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // Top row\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Right row\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            //  Bottom row \\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            //   Left column\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\nint startingRow = 0;\\nint endingRow = n - 1;\\nint startingCol = 0;\\nint endingCol = n - 1;\\n```\n```\\nfor (int i = startingCol; i <= endingCol; i++) {\\n        ans[startingRow][i] = count;\\n        count++;\\n    }\\n    startingRow++;\\n```\n```\\nfor (int i = startingRow; i <= endingRow; i++) {\\n        ans[i][endingCol] = count;\\n        count++;\\n    }\\n    endingCol--;\\n```\n```\\nfor (int i = endingCol; i >= startingCol; i--) {\\n        ans[endingRow][i] = count;\\n        count++;\\n    }\\n    endingRow--;\\n```\n```\\nfor (int i = endingRow; i >= startingRow; i--) {\\n        ans[i][startingCol] = count;\\n        count++;   \\n    }\\n    startingCol++;\\n```\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n                \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // Top row\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Right row\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            //  Bottom row \\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            //   Left column\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507277,
                "title": "solution-with-easy-understandable-logics",
                "content": "# Approach \\nCreating 2D array and storing sequence of numbers incremented by 1 starting at 1 in spiral order\\n# Institution\\n[Made by using logics from solution of this problem](https://leetcode.com/problems/spiral-matrix/solutions/3503965/beats-99-with-scomplexity/)\\n\\n\\n >BY  Seeker of Miracle\\n# Complexity\\n- Time complexity:O(n^2) \\n- Space complexity:O(n^2)\\nWhere n is length of one axis in matrix\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n    \\n    let matrix=[],count=0,x=0,y=0;\\n    const maxElements=n*n;\\n\\n    for(let i=0; i<n;i++)\\n    {\\n        matrix[i]= new Array()\\n    }\\n\\n    while(maxElements>count)\\n    {\\n        for(let i=x; maxElements>count && i<n-x;i++)\\n        {\\n            count++;\\n            matrix[y][i]=count\\n            // console.log(1, matrix[y][i])\\n        }\\n        y++;\\n\\n        for(let i=y; maxElements>count && i<n-(y-1);i++)\\n        {\\n            count++;\\n            matrix[i][(n-1) - x]=count;\\n            // console.log(2, matrix[i][(n-1) - x])\\n        }\\n        x++;\\n\\n        for(let i=(n-1)-x; maxElements>count && i>=x-1; i--)\\n        {\\n            count++;\\n            matrix[(n-1)-(y-1)][i]=count;\\n            // console.log(3, matrix[(n-1)-(y-1)][i])\\n        }\\n\\n        for(let i=(n-1)-y; maxElements>count && i>=y; i--)\\n        {\\n            count++;\\n            matrix[i][x-1]=count\\n            // console.log(4, matrix[i][x-1])\\n        }\\n    }\\n    return matrix;\\n};\\n```\\n*I am happy if you leave your comments below as advise in order to improve my code*",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n    \\n    let matrix=[],count=0,x=0,y=0;\\n    const maxElements=n*n;\\n\\n    for(let i=0; i<n;i++)\\n    {\\n        matrix[i]= new Array()\\n    }\\n\\n    while(maxElements>count)\\n    {\\n        for(let i=x; maxElements>count && i<n-x;i++)\\n        {\\n            count++;\\n            matrix[y][i]=count\\n            // console.log(1, matrix[y][i])\\n        }\\n        y++;\\n\\n        for(let i=y; maxElements>count && i<n-(y-1);i++)\\n        {\\n            count++;\\n            matrix[i][(n-1) - x]=count;\\n            // console.log(2, matrix[i][(n-1) - x])\\n        }\\n        x++;\\n\\n        for(let i=(n-1)-x; maxElements>count && i>=x-1; i--)\\n        {\\n            count++;\\n            matrix[(n-1)-(y-1)][i]=count;\\n            // console.log(3, matrix[(n-1)-(y-1)][i])\\n        }\\n\\n        for(let i=(n-1)-y; maxElements>count && i>=y; i--)\\n        {\\n            count++;\\n            matrix[i][x-1]=count\\n            // console.log(4, matrix[i][x-1])\\n        }\\n    }\\n    return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3507180,
                "title": "beginner-friendly-solution-in-cpp-beats-100-in-time-and-90-in-space",
                "content": "\\n# Complexity\\n- Time complexity: $$(N * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$(N * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> generateMatrix(int n)\\n    {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        int row = 0, col = 0, number = 1, c = 0;\\n        while (c < (n + 1) / 2) // Filling the matrix in squares, starting from the outermost and then going inwards\\n        {\\n            row = sqr_count, col = sqr_count;\\n            for (; col < n - sqr_count - 1; col++) // Going from first element of the square to the second last in that row\\n                ans[row][col] = number++;\\n            for (; row < n - sqr_count - 1; row++) // Going from the last row element(first in the column) to the second last in that column\\n                ans[row][col] = number++;\\n            for (; col > sqr_count; col--) // From the last element in the last column(last row element) to the second element in the bottom row\\n                ans[row][col] = number++;\\n            for (; row > sqr_count; row--) // From the last element in the last row,(last column element) to the second element in the first column\\n                ans[row][col] = number++;\\n            sqr_count++;\\n        }\\n        if (n & 1)  // If the order of matrix is odd set the maximum in the center\\n            ans[n / 2][n / 2] = r;\\n        return ans;\\n    }\\n};\\n```\\n## Do upvote, if it helped",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> generateMatrix(int n)\\n    {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        int row = 0, col = 0, number = 1, c = 0;\\n        while (c < (n + 1) / 2) // Filling the matrix in squares, starting from the outermost and then going inwards\\n        {\\n            row = sqr_count, col = sqr_count;\\n            for (; col < n - sqr_count - 1; col++) // Going from first element of the square to the second last in that row\\n                ans[row][col] = number++;\\n            for (; row < n - sqr_count - 1; row++) // Going from the last row element(first in the column) to the second last in that column\\n                ans[row][col] = number++;\\n            for (; col > sqr_count; col--) // From the last element in the last column(last row element) to the second element in the bottom row\\n                ans[row][col] = number++;\\n            for (; row > sqr_count; row--) // From the last element in the last row,(last column element) to the second element in the first column\\n                ans[row][col] = number++;\\n            sqr_count++;\\n        }\\n        if (n & 1)  // If the order of matrix is odd set the maximum in the center\\n            ans[n / 2][n / 2] = r;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507106,
                "title": "daily-faster-than-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int top=0, down=n-1, left=0, right=n-1;\\n        int c=1;\\n        while(top<=down and left<=right){\\n            for(int i=left; i<=right; i++){\\n                ans[top][i]=c++;\\n            }\\n            top++;\\n            for(int i=top; i<=down; i++){\\n                ans[i][right]=c++;\\n            }\\n            right--;\\n            for(int i=right; i>=left; i--){\\n                ans[down][i]=c++;\\n            }\\n            down--;\\n            for(int i=down; i>=top; i--){\\n                ans[i][left]=c++;\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int top=0, down=n-1, left=0, right=n-1;\\n        int c=1;\\n        while(top<=down and left<=right){\\n            for(int i=left; i<=right; i++){\\n                ans[top][i]=c++;\\n            }\\n            top++;\\n            for(int i=top; i<=down; i++){\\n                ans[i][right]=c++;\\n            }\\n            right--;\\n            for(int i=right; i>=left; i--){\\n                ans[down][i]=c++;\\n            }\\n            down--;\\n            for(int i=down; i>=top; i--){\\n                ans[i][left]=c++;\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506922,
                "title": "python-short-and-clean-iterative-solution",
                "content": "# Approach\\n1. Reuse the `inwards_spiral` function from [Spiral Matrix I](https://leetcode.com/problems/spiral-matrix/solutions/1467615/python-short-and-clean-iterative-solution/?orderBy=most_votes) to generate indices in spiral order.\\n\\n2. Zip through indices and counter, assigning count to the corresponding index of the `matrix`.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$, ignoring the returned list.\\n\\nwhere,\\n`m * n is the dimensions of matrix.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \"\"\"Return list of (i, j) indices of a m * n matrix in spiral order\"\"\"\\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 # Center\\n                \\n                yield from ((i1, j) for j in range(j1, j2))                                     # Left to Right\\n                yield from ((i, j2) for i in range(i1, i2))                                     # Top to Bottom\\n                yield from ((i2, j) for j in range(j2, j1, -1)) if i1 != i2 else ((i2, j2),)    # Right to Left\\n                yield from ((i, j1) for i in range(i2, i1, -1)) if j1 != j2 else ((i2, j1),)    # Bottom to Top\\n        \\n        matrix = [[0] * n for _ in range(n)]\\n        for (i, j), x in zip(inwards_spiral(n, n), count(1)): matrix[i][j] = x\\n        return matrix\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \"\"\"Return list of (i, j) indices of a m * n matrix in spiral order\"\"\"\\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 # Center\\n                \\n                yield from ((i1, j) for j in range(j1, j2))                                     # Left to Right\\n                yield from ((i, j2) for i in range(i1, i2))                                     # Top to Bottom\\n                yield from ((i2, j) for j in range(j2, j1, -1)) if i1 != i2 else ((i2, j2),)    # Right to Left\\n                yield from ((i, j1) for i in range(i2, i1, -1)) if j1 != j2 else ((i2, j1),)    # Bottom to Top\\n        \\n        matrix = [[0] * n for _ in range(n)]\\n        for (i, j), x in zip(inwards_spiral(n, n), count(1)): matrix[i][j] = x\\n        return matrix\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506910,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506897,
                "title": "direct-approach-java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int arr[][] = new int[n][n];\\n\\n        int count = 1;\\n        int k = 0;\\n        int l = 0;\\n        int t = 0;\\n        for (int i = k; i < n; i++) {\\n            for(int j=l;j<n;j++){\\n                arr[t][j] = count++;\\n            }\\n            t++;\\n            for(int j=t;j<n;j++){\\n                arr[j][n-1] = count++;\\n            }\\n            t--;\\n            for(int j=n-2;j>=t;j--){\\n                arr[n-1][j] = count++;\\n            }\\n            t++;\\n            for(int j=n-2;j>=t;j--){\\n                arr[j][t-1] = count++;\\n            }\\n            n--;\\n            l++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int arr[][] = new int[n][n];\\n\\n        int count = 1;\\n        int k = 0;\\n        int l = 0;\\n        int t = 0;\\n        for (int i = k; i < n; i++) {\\n            for(int j=l;j<n;j++){\\n                arr[t][j] = count++;\\n            }\\n            t++;\\n            for(int j=t;j<n;j++){\\n                arr[j][n-1] = count++;\\n            }\\n            t--;\\n            for(int j=n-2;j>=t;j--){\\n                arr[n-1][j] = count++;\\n            }\\n            t++;\\n            for(int j=n-2;j>=t;j--){\\n                arr[j][t-1] = count++;\\n            }\\n            n--;\\n            l++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506795,
                "title": "java-solution-for-spiral-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to use four loops, each representing a direction (right, down, left, up) to fill the matrix in a spiral order. The loops move along the outer boundaries of the matrix and increment the current number to be filled.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize variables: total to store the total number of elements in the matrix, result to store the generated matrix, x and y as the current positions in the matrix, and step to keep track of the current boundary step.\\n- Use a loop that runs until i reaches the total number of elements.\\n- Within the loop, move right until reaching the end of the current row, fill the current position with the next number, and increment i.\\n- Adjust the position and repeat the process for moving down, left, and up, respectively.\\n- Update step after completing one spiral loop to move to the inner boundaries of the matrix.\\n- Repeat the steps until all elements are filled.\\n- Return the generated matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n^2), where n is the given input. It iterates over each element in the matrix exactly once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n^2) as well since the solution creates a 2D matrix of size n x n to store the generated matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506662,
                "title": "c-easy-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k=1;\\n        int top,bottom,left,right;\\n        vector<vector<int>> matrix(n, vector<int> (n));\\n        top=left=0;\\n        right=bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=k++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=k++;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=k++;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=k++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k=1;\\n        int top,bottom,left,right;\\n        vector<vector<int>> matrix(n, vector<int> (n));\\n        top=left=0;\\n        right=bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=k++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=k++;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=k++;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=k++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506430,
                "title": "daily-leetcoding-challenge-may-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3505265,
                "title": "c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, std::vector<int>(n, 0));\\n\\n        int rowTop = 0;\\n        int rowBottom = matrix.size() - 1;\\n        int columnLeft = 0;\\n        int columnRight = matrix.size() - 1;\\n\\n        int num = 1;\\n        while (true) {\\n            // right\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                matrix[rowTop][i] = num++;\\n            }\\n            rowTop++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // down\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                matrix[i][columnRight] = num++;\\n            }\\n            columnRight--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // left\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                matrix[rowBottom][i] = num++;\\n            }\\n            rowBottom--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // up\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                matrix[i][columnLeft] = num++;\\n            }\\n            columnLeft++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, std::vector<int>(n, 0));\\n\\n        int rowTop = 0;\\n        int rowBottom = matrix.size() - 1;\\n        int columnLeft = 0;\\n        int columnRight = matrix.size() - 1;\\n\\n        int num = 1;\\n        while (true) {\\n            // right\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                matrix[rowTop][i] = num++;\\n            }\\n            rowTop++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // down\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                matrix[i][columnRight] = num++;\\n            }\\n            columnRight--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // left\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                matrix[rowBottom][i] = num++;\\n            }\\n            rowBottom--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // up\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                matrix[i][columnLeft] = num++;\\n            }\\n            columnLeft++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3345184,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int x=1;\\n        int i=0,j=0;\\n        int p=n,q=n;\\n        while(i<=p&&j<=q){\\n            for(int k=j;k<q;k++) {\\n               ans[i][k]=x;\\n               x++;\\n            }\\n            i++;\\n            for(int k=i;k<p;k++){\\n                ans[k][q-1]=x;\\n                x++;\\n            }\\n            q--;\\n            for(int k=q-1;k>=j;k--){\\n                ans[p-1][k]=x;\\n                x++;\\n            }\\n            p--;\\n            for(int k=p-1;k>=i;k--){\\n                ans[k][j]=x;\\n                x++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int x=1;\\n        int i=0,j=0;\\n        int p=n,q=n;\\n        while(i<=p&&j<=q){\\n            for(int k=j;k<q;k++) {\\n               ans[i][k]=x;\\n               x++;\\n            }\\n            i++;\\n            for(int k=i;k<p;k++){\\n                ans[k][q-1]=x;\\n                x++;\\n            }\\n            q--;\\n            for(int k=q-1;k>=j;k--){\\n                ans[p-1][k]=x;\\n                x++;\\n            }\\n            p--;\\n            for(int k=p-1;k>=i;k--){\\n                ans[k][j]=x;\\n                x++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1888784,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888659,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1710044,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888670,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1717655,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1567118,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888833,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888861,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888672,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1754605,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888784,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888659,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1710044,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888670,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1717655,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1567118,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888833,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888861,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888672,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1754605,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1889104,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889078,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 2072367,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 2026817,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1993751,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1984801,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1901066,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889605,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889361,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889347,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889341,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889319,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889286,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889196,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889166,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889133,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889100,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889008,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888971,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888924,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888912,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888878,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888847,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888816,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888812,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888799,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888776,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888721,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888715,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888677,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Substring with At Most Two Distinct Characters",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566840,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1775696,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1979186,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1803117,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            }
        ]
    },
    {
        "title": "3Sum Smaller",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565372,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1571498,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1847614,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1789850,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1624445,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Logger Rate Limiter",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1573233,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1571634,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1570043,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1823927,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1693749,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1931162,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            }
        ]
    }
]