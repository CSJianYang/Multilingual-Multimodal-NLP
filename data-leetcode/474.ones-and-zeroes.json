[
    {
        "title": "Ones and Zeroes",
        "question_content": "You are given an array of binary strings strs and two integers m and n.\nReturn the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\nA set x is a subset of a set y if all elements of x are also elements of y.\n&nbsp;\nExample 1:\n\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\nOther valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n{\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n\nExample 2:\n\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\nOutput: 2\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 600\n\t1 <= strs[i].length <= 100\n\tstrs[i] consists only of digits '0' and '1'.\n\t1 <= m, n <= 100",
        "solutions": [
            {
                "id": 814077,
                "title": "dedicated-to-beginners",
                "content": "**before starting with DP one must master the art of recursion**\\nMost of the post shows you the optimal solution, briefly explains how it works, but doesn\\'t tell you how to arive at that solution, (this post are for begineers). it goes as \"give man a fish, he can eat it whole day, tell then how to catch one, he can have it whole life\"\\n\\n**step1 : understand the problem**\\nwe have been given a array of BinaryStrings and two numbers, viz no of zeros and no of ones. \\nOur task is to tell how many strings can we make by using available no of zeros and ones, such that we are able to make the maximum no of strings present in given array.\\n\\n**step 2: logic building and deriving recurence relation**\\n\\n**1st sub step : asking questions**\\n1. question that i should ask is what is the max no of strings can i make from given avaible choices.\\n( now assume you are at a particular index on the array , these are the questions that matter ) \\n2. if i use this current string then what all choices i am left with ? what is the max possible ans for those choices.\\n3. if i dont use this current string then i have other options( other indexes ) to explore , whats going to be the answer for amoung these choices.\\n4. Finally : if i know the answer for both the paths then i ould be able to decide wether i should select this current string or not.\\n\\n**2nd sub step : Ariving at recurence relation**\\n```\\nat some Ith index my options is going to be \\n1 . if i use decide to build this string then \\n\\t answerFor( next index , currAvailableZeros - currentStringZeros , currAvailableOnes - currentStringOnes )\\n2. if i dont decide to build this string ( assuming i will get better answer later, if i save available zeros and ones)\\n\\t answerFor( next index , currAvailableZeros , currAvailableOnes  )\\n\\t \\nans_for_ith = maxOf ( if i build this current string , if i dont build )\\n```\\n\\n**step 3: code recursive solution - (TLE)**\\n```\\nint sub(vector<pair<int,int>> &a, int index , int nOnes , int nZeros)\\n    {\\n        // BASE CASES\\n        // 1. if we have reched the end of our array then we dont have any options left\\n        // 2. if we have no available zeros or ones to use then also we dont have any options left\\n        int n = a.size();\\n        if(index == n or (nZeros ==0 and nOnes == 0))   return 0;\\n        \\n        if(a[index].first > nOnes or a[index].second > nZeros)  \\n            return sub(a , index+1 , nOnes , nZeros);\\n        \\n        // now at this point we have two paths to explore, we want to know that what is the answer going to be if i \\n        // use this pair \\n        // or if i leave this pair\\n        int include = 1 + sub(a , index+1, nOnes - a[index].first , nZeros - a[index].second);\\n        int exclude = sub(a , index+1 , nOnes , nZeros);\\n        \\n        // now since we know the our answers for both of our decisions then we can choose the one which yeilds the max result\\n        return max(include , exclude);     \\n    }    \\n    int findMaxForm(vector<string>& strs, int nZeros, int nOnes) \\n    {\\n        // lets make a array of pairs which is going to store no of zeros and no of ones for ith string\\n        vector<pair<int,int>> a;\\n        for(auto i : strs)\\n        {\\n            int one = 0 , zero = 0;\\n            for(auto j : i)\\n                (j == \\'1\\') ? one ++ : zero++;\\n            a.push_back({one , zero});\\n        }\\n        \\n        int ans = sub(a , 0 , nOnes , nZeros);\\n        return ans;\\n    }\\n```\\n**step4 : memoization-top-down**\\nNow we know the subProblems. lets us save them to save some computation lets maintain a DP matrix which will store the calculated values for all index and for all its possible values of m and n\\n```\\nint dp[601][101][101] = {};\\n    \\n    int sub(vector<pair<int,int>> &a, int index , int nOnes , int nZeros)\\n    {\\n        int n = a.size();\\n        if(index == n or (nZeros ==0 and nOnes == 0))   return 0;\\n        \\n        // if we already know answer for this index with current nZeros , nOnes then no need to recompute return the saved answer\\n        if(dp[index][nOnes][nZeros] != -1)\\n            return dp[index][nOnes][nZeros];\\n        \\n        // we dont have available no of zeros or ones to build this curent string, so we dont have any other option but to skip this index\\n        if(a[index].first > nOnes or a[index].second > nZeros)  \\n            return dp[index][nOnes][nZeros] = sub(a , index+1 , nOnes , nZeros);\\n        // NOTE : we are also saving corrensponding values\\n        \\n        int include = 1 + sub(a , index+1, nOnes - a[index].first , nZeros - a[index].second);\\n        int exclude = sub(a , index+1 , nOnes , nZeros);\\n        \\n        // save these values and return the answer\\n        return dp[index][nOnes][nZeros] = max(include , exclude);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int nZeros, int nOnes) \\n    {\\n        vector<pair<int,int>> a;\\n        memset(dp , -1 , sizeof(dp));\\n        \\n        for(auto i : strs)\\n        {\\n            int one = 0 , zero = 0;\\n            for(auto j : i)\\n                (j == \\'1\\') ? one ++ : zero++;\\n            a.push_back({one , zero});\\n        }\\n        \\n        int ans = sub(a , 0 , nOnes , nZeros);\\n        return ans;\\n    }\\n```\\n\\n**step 5 : bottom up DP**\\nnow you know the base cases and subproblems , so try to come up with bottom up code yourself.\\n```\\nint findMaxForm(vector<string>& strs, int zeros, int ones) \\n    {\\n        int i,j,k,l,p=strs.size();\\n        vector<vector<int>> dp(zeros+1 , vector<int>(ones+1));\\n        \\n        for(auto &s:strs)\\n        {\\n            int currOnes = count(s.begin(),s.end(),\\'1\\');\\n            int currZeros = s.size()-currOnes;\\n            \\n            for(j=ones;j>=currOnes;j--)\\n            {\\n                for(i=zeros;i>=currZeros;i--)\\n                {\\n                    dp[i][j] = max(dp[i][j],1+dp[i-currZeros][j-currOnes]);\\n                }\\n            }\\n        }\\n        return dp[zeros][ones];\\n    }\\n```\\n\\n\\nprevious tutorial on DP\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/discuss/630868/explanation-from-someone-who-took-2-hours-to-solve/\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/discuss/642422/Lets-solve-it-together-%3A-step-by-step\\n\\nhttps://leetcode.com/problems/dungeon-game/discuss/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nat some Ith index my options is going to be \\n1 . if i use decide to build this string then \\n\\t answerFor( next index , currAvailableZeros - currentStringZeros , currAvailableOnes - currentStringOnes )\\n2. if i dont decide to build this string ( assuming i will get better answer later, if i save available zeros and ones)\\n\\t answerFor( next index , currAvailableZeros , currAvailableOnes  )\\n\\t \\nans_for_ith = maxOf ( if i build this current string , if i dont build )\\n```\n```\\nint sub(vector<pair<int,int>> &a, int index , int nOnes , int nZeros)\\n    {\\n        // BASE CASES\\n        // 1. if we have reched the end of our array then we dont have any options left\\n        // 2. if we have no available zeros or ones to use then also we dont have any options left\\n        int n = a.size();\\n        if(index == n or (nZeros ==0 and nOnes == 0))   return 0;\\n        \\n        if(a[index].first > nOnes or a[index].second > nZeros)  \\n            return sub(a , index+1 , nOnes , nZeros);\\n        \\n        // now at this point we have two paths to explore, we want to know that what is the answer going to be if i \\n        // use this pair \\n        // or if i leave this pair\\n        int include = 1 + sub(a , index+1, nOnes - a[index].first , nZeros - a[index].second);\\n        int exclude = sub(a , index+1 , nOnes , nZeros);\\n        \\n        // now since we know the our answers for both of our decisions then we can choose the one which yeilds the max result\\n        return max(include , exclude);     \\n    }    \\n    int findMaxForm(vector<string>& strs, int nZeros, int nOnes) \\n    {\\n        // lets make a array of pairs which is going to store no of zeros and no of ones for ith string\\n        vector<pair<int,int>> a;\\n        for(auto i : strs)\\n        {\\n            int one = 0 , zero = 0;\\n            for(auto j : i)\\n                (j == \\'1\\') ? one ++ : zero++;\\n            a.push_back({one , zero});\\n        }\\n        \\n        int ans = sub(a , 0 , nOnes , nZeros);\\n        return ans;\\n    }\\n```\n```\\nint dp[601][101][101] = {};\\n    \\n    int sub(vector<pair<int,int>> &a, int index , int nOnes , int nZeros)\\n    {\\n        int n = a.size();\\n        if(index == n or (nZeros ==0 and nOnes == 0))   return 0;\\n        \\n        // if we already know answer for this index with current nZeros , nOnes then no need to recompute return the saved answer\\n        if(dp[index][nOnes][nZeros] != -1)\\n            return dp[index][nOnes][nZeros];\\n        \\n        // we dont have available no of zeros or ones to build this curent string, so we dont have any other option but to skip this index\\n        if(a[index].first > nOnes or a[index].second > nZeros)  \\n            return dp[index][nOnes][nZeros] = sub(a , index+1 , nOnes , nZeros);\\n        // NOTE : we are also saving corrensponding values\\n        \\n        int include = 1 + sub(a , index+1, nOnes - a[index].first , nZeros - a[index].second);\\n        int exclude = sub(a , index+1 , nOnes , nZeros);\\n        \\n        // save these values and return the answer\\n        return dp[index][nOnes][nZeros] = max(include , exclude);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int nZeros, int nOnes) \\n    {\\n        vector<pair<int,int>> a;\\n        memset(dp , -1 , sizeof(dp));\\n        \\n        for(auto i : strs)\\n        {\\n            int one = 0 , zero = 0;\\n            for(auto j : i)\\n                (j == \\'1\\') ? one ++ : zero++;\\n            a.push_back({one , zero});\\n        }\\n        \\n        int ans = sub(a , 0 , nOnes , nZeros);\\n        return ans;\\n    }\\n```\n```\\nint findMaxForm(vector<string>& strs, int zeros, int ones) \\n    {\\n        int i,j,k,l,p=strs.size();\\n        vector<vector<int>> dp(zeros+1 , vector<int>(ones+1));\\n        \\n        for(auto &s:strs)\\n        {\\n            int currOnes = count(s.begin(),s.end(),\\'1\\');\\n            int currZeros = s.size()-currOnes;\\n            \\n            for(j=ones;j>=currOnes;j--)\\n            {\\n                for(i=zeros;i>=currZeros;i--)\\n                {\\n                    dp[i][j] = max(dp[i][j],1+dp[i-currZeros][j-currOnes]);\\n                }\\n            }\\n        }\\n        return dp[zeros][ones];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95814,
                "title": "c-dp-solution-with-comments",
                "content": "```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n  vector<vector<int>> memo(m+1, vector<int>(n+1, 0));\\n  int numZeroes, numOnes;\\n\\n  for (auto &s : strs) {\\n    numZeroes = numOnes = 0;\\n    // count number of zeroes and ones in current string\\n    for (auto c : s) {\\n      if (c == '0')\\n\\tnumZeroes++;\\n      else if (c == '1')\\n\\tnumOnes++;\\n    }\\n\\n    // memo[i][j] = the max number of strings that can be formed with i 0's and j 1's\\n    // from the first few strings up to the current string s\\n    // Catch: have to go from bottom right to top left\\n    // Why? If a cell in the memo is updated(because s is selected),\\n    // we should be adding 1 to memo[i][j] from the previous iteration (when we were not considering s)\\n    // If we go from top left to bottom right, we would be using results from this iteration => overcounting\\n    for (int i = m; i >= numZeroes; i--) {\\n\\tfor (int j = n; j >= numOnes; j--) {\\n          memo[i][j] = max(memo[i][j], memo[i - numZeroes][j - numOnes] + 1);\\n\\t}\\n    }\\n  }\\n  return memo[m][n];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n  vector<vector<int>> memo(m+1, vector<int>(n+1, 0));\\n  int numZeroes, numOnes;\\n\\n  for (auto &s : strs) {\\n    numZeroes = numOnes = 0;\\n    // count number of zeroes and ones in current string\\n    for (auto c : s) {\\n      if (c == '0')\\n\\tnumZeroes++;\\n      else if (c == '1')\\n\\tnumOnes++;\\n    }\\n\\n    // memo[i][j] = the max number of strings that can be formed with i 0's and j 1's\\n    // from the first few strings up to the current string s\\n    // Catch: have to go from bottom right to top left\\n    // Why? If a cell in the memo is updated(because s is selected),\\n    // we should be adding 1 to memo[i][j] from the previous iteration (when we were not considering s)\\n    // If we go from top left to bottom right, we would be using results from this iteration => overcounting\\n    for (int i = m; i >= numZeroes; i--) {\\n\\tfor (int j = n; j >= numOnes; j--) {\\n          memo[i][j] = max(memo[i][j], memo[i - numZeroes][j - numOnes] + 1);\\n\\t}\\n    }\\n  }\\n  return memo[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138589,
                "title": "short-easy-w-explanation-o-l-m-n-dp-solution-6-lines-similar-to-knapsack",
                "content": "For each string in the set, we have the choice to include it in the subset or leave it. For `Max(strs.length) == 600`, we would have `2^600`, different ways of choosing and we have to find the way which maximizes the subset size. Obviously, this exponential Time complexity brute force approach won\\'t work. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution (Dynamic Programming)***\\n\\nThis problem looks a lot like the knapsack just that we have two constraints here `m` and `n` instead of just `W` in the knapsack problem. Here, a set of items(strings) are given and we have to choose a subset satisfying given constraints. We can apply **DP** here. We can maintain a 2d dp array, where `dp[i][j]` will maintain the optimal solution when `zeros_limit = i & ones_limit = j`.\\n\\nFor each string, some number of 0s(lets call *`zeros`*) and 1s (lets call *`ones`*) are required. Obviously, if our balance of zeros and ones is less than what is required by current string, we can\\'t choose it. But in the case where our balance of *zeros* and *ones*  is greater than the required, we have two cases -\\n* Either take the current string into our subset. The resultant count would be 1 + optimal solution that we had when our balance was `i - zeros` & `j - ones`.\\n* Or leave the current string meaning the resultant count will remain the same.\\n\\nFor each string in `strs`, we will update the dp matrix as per the above two cases.\\n\\n\\n\\n\\n```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n\\t// dp[i][j] will store Max subset size possible with zeros_limit = i, ones_limit = j\\n\\tvector<vector<int> > dp(m + 1, vector<int>(n + 1));\\n\\tfor(auto& str : strs) {\\n\\t\\t// count zeros & ones frequency in current string            \\n\\t\\tint zeros = count(begin(str), end(str), \\'0\\'), ones = size(str) - zeros; \\n\\t\\t// which positions of dp will be updated ?\\n\\t\\t// Only those having atleast `zeros` 0s(i >= zeros) and `ones` 1s(j >= ones)\\n\\t\\tfor(int i = m; i >= zeros; i--)\\n\\t\\t\\tfor(int j = n; j >= ones; j--)                    \\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], // either leave the current string\\n\\t\\t\\t\\t\\t\\t\\t   dp[i - zeros][j - ones] + 1); // or take it by adding 1 to optimal solution of remaining balance\\n\\t\\t// at this point each dp[i][j] will store optimal value for items considered till now & having constraints i and j respectively\\n\\t}\\n\\treturn dp[m][n];\\n}\\n```\\n\\n***Time Complexity :*** **`O(L*m*n)`**, where `L` is the length of `strs`\\n***Space Complexity :*** **`O(m*n)`**\\n\\n\\n----\\n----\\n\\n<br />\\n\\n\\uD83D\\uDCDD ***Some Extra Points*** \\uD83D\\uDCA1\\n\\n\\n\\n* *Why go from `i = m` and `j = n`, i.e, bottom right of our dp to the top left ?*\\n**Ans :** For every string, we are updating the values of dp where it is possible to choose the current string. Now, we could do something like - \\n\\n\\t```\\n\\t// wrong way\\n\\tfor(int i = 0; i <= m; i++)\\n\\t\\tfor(int j = 0; j <= n; j++)\\n\\t\\t\\tif(i >= zeros && j >= ones) \\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1); \\n\\t```\\n\\n\\tWhat this does is, it will update some values in the **top left of dp** and then we would be using these updated values in **updating some `dp[i][j]` in the bottom right**. But this would be wrong, since it would be like choosing the same string twice.\\n\\n\\tWe could most certainly do it from bottom left as well...it\\'s just a bit less efficient -\\n\\n\\t```\\n\\tint findMaxForm(vector<string>& strs, int m, int n) {        \\n\\t\\tvector<vector<int> > dp(m + 1, vector<int>(n + 1));\\n\\t\\tfor(auto& str : strs) {\\t\\t\\n\\t\\t\\tint zeros = count(begin(str), end(str), \\'0\\'), ones = size(str) - zeros; \\n\\t\\t\\tvector<vector<int> > dp2 = dp;\\n\\t\\t\\tfor(int i = 0; i <= m; i++)\\n\\t\\t\\t\\tfor(int j = 0; j <= n; j++)                    \\n\\t\\t\\t\\t\\tif(i - zeros >= 0 && j - ones >= 0) // use this check or directly start from i=zeros & j=ones\\n\\t\\t\\t\\t\\t\\tdp2[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1); // ensures we don\\'t count a string multiple times\\n\\t\\t\\tdp = dp2;\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n\\t}\\n\\t```\\t\\n\\t----\\n\\n* *Recursive solution ?* \\n**Ans** : Here\\'s the Top-down recursive approach -\\n\\t```\\n\\tvector<vector<vector<int> > >dp;\\n\\tint findMaxForm(vector<string>& strs, int m, int n) {        \\n\\t\\tdp.resize(size(strs), vector<vector<int> >(m + 1, vector<int>(n + 1)));\\n\\t\\treturn helper(strs, m, n, 0);\\n\\t}\\n\\tint helper(vector<string>& strs, int m, int n, int idx){\\n\\t\\t// base condition - all items covered, then stop further recusion\\n\\t\\tif(idx == size(strs)) return 0; \\n\\t\\t// if the current case is already memoised - return it\\n\\t\\tif(dp[idx][m][n]) return dp[idx][m][n];\\n\\t\\t// count freqeuncy of zeros and ones in current string\\n\\t\\tint zeros = count(begin(strs[idx]), end(strs[idx]), \\'0\\'), ones = size(strs[idx]) - zeros;\\n\\t\\tdp[idx][m][n] = helper(strs, m, n, idx + 1); // case where current string is not chosen & move to next string\\n\\t\\t// if current string can be chosen, find optimal between choosing it and leaving it\\n\\t\\tif(m - zeros >= 0 && n - ones >= 0) \\n\\t\\t\\tdp[idx][m][n] = max(dp[idx][m][n], 1 + helper(strs, m - zeros, n - ones, idx + 1));\\n\\t\\treturn dp[idx][m][n]; // finally the optimal answer will be returned\\n\\t}\\n\\t```\\n\\tThe above solution gave runtime which was about 5x slower and space usage which was around 10x more than the iterative version. Also, the above solution is a **3d dp** solution and I wasn\\'t able to form a **2d recursive solution**. If anyone is able to do it, **please comment below.**\\n\\t\\n\\t----\\n\\n* *How to know this is a DP problem?*\\n**Ans** : You wont get that it\\'s a dp problem right away. For me, I first thought it may be a greedy solution where I could sort the `strs` based on length of string and greedily choose starting from the smallest strings that satisfied the constraints. This didn\\'t work because one constraint could be smaller than other and greedily choosing smallest string may end up using all of that contraint\\'s balance at once. Tried some other ways of sorting based on m/n & using greedy approach but to no avail.\\n\\n\\tFinally decided to go back and see if there\\'s a brute force way of solving it. I could observe that for each string, we had choice to select or leave it but this gave exponential TC. After making this observation, the problem seemed kind of similar to some other dp problems like coin change or knapsack problem where we have to make choice about each item - whether to take it or leave it. But this problem had 2 constrains `m` and `n`\\n\\n\\tNow, for 1-contraint dp problem like knapsack, we would do something like -\\n\\n\\t```\\n\\tfor item in items_list:\\n\\t\\tfor w in range(0, MAX_W+1): // build optimal answers for w from [0, max_W]\\n\\t\\t\\t// take it or leave to get optimal answer\\n\\t\\t// now dp will have optimal answers for items considered till now\\n\\t```\\n\\n\\tIn this case, we would have to deal with both the constraints instead of one - \\n\\t```\\n\\tfor _string in strs:\\n\\t\\tfor i in range(0, m+1):\\n\\t\\t\\tfor j in range(0, n+1): // build optimal answers for both constraints - for each j in [0,n] & do this for each i in [o,m]\\n\\t\\t\\t\\t// again take it or leave choice will be evaluated for _string\\n\\t\\t// now dp will have optimal answers for strings considered till now\\n\\t```\\n\\n\\tNow, the solution I presented above is analogous to optimized 1d approach in knapsack. In this, the non-optimized space appraoch would be to use 3d dp where `dp[i][j][k]` would denote optimal solution for first `i` items when constraints `m` and `n` are `j` and `k` respectively. This is shown in the recursive solution given above\\n\\t\\n\\t----\\n\\nI don\\'t know if a did a good job of explaining my approach but I hope this would help others in understanding the problem and improving the approach of building up to a dp solution.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n\\t// dp[i][j] will store Max subset size possible with zeros_limit = i, ones_limit = j\\n\\tvector<vector<int> > dp(m + 1, vector<int>(n + 1));\\n\\tfor(auto& str : strs) {\\n\\t\\t// count zeros & ones frequency in current string            \\n\\t\\tint zeros = count(begin(str), end(str), \\'0\\'), ones = size(str) - zeros; \\n\\t\\t// which positions of dp will be updated ?\\n\\t\\t// Only those having atleast `zeros` 0s(i >= zeros) and `ones` 1s(j >= ones)\\n\\t\\tfor(int i = m; i >= zeros; i--)\\n\\t\\t\\tfor(int j = n; j >= ones; j--)                    \\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], // either leave the current string\\n\\t\\t\\t\\t\\t\\t\\t   dp[i - zeros][j - ones] + 1); // or take it by adding 1 to optimal solution of remaining balance\\n\\t\\t// at this point each dp[i][j] will store optimal value for items considered till now & having constraints i and j respectively\\n\\t}\\n\\treturn dp[m][n];\\n}\\n```\n```\\n\\t// wrong way\\n\\tfor(int i = 0; i <= m; i++)\\n\\t\\tfor(int j = 0; j <= n; j++)\\n\\t\\t\\tif(i >= zeros && j >= ones) \\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1); \\n\\t```\n```\\n\\tint findMaxForm(vector<string>& strs, int m, int n) {        \\n\\t\\tvector<vector<int> > dp(m + 1, vector<int>(n + 1));\\n\\t\\tfor(auto& str : strs) {\\t\\t\\n\\t\\t\\tint zeros = count(begin(str), end(str), \\'0\\'), ones = size(str) - zeros; \\n\\t\\t\\tvector<vector<int> > dp2 = dp;\\n\\t\\t\\tfor(int i = 0; i <= m; i++)\\n\\t\\t\\t\\tfor(int j = 0; j <= n; j++)                    \\n\\t\\t\\t\\t\\tif(i - zeros >= 0 && j - ones >= 0) // use this check or directly start from i=zeros & j=ones\\n\\t\\t\\t\\t\\t\\tdp2[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1); // ensures we don\\'t count a string multiple times\\n\\t\\t\\tdp = dp2;\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n\\t}\\n\\t```\n```\\n\\tvector<vector<vector<int> > >dp;\\n\\tint findMaxForm(vector<string>& strs, int m, int n) {        \\n\\t\\tdp.resize(size(strs), vector<vector<int> >(m + 1, vector<int>(n + 1)));\\n\\t\\treturn helper(strs, m, n, 0);\\n\\t}\\n\\tint helper(vector<string>& strs, int m, int n, int idx){\\n\\t\\t// base condition - all items covered, then stop further recusion\\n\\t\\tif(idx == size(strs)) return 0; \\n\\t\\t// if the current case is already memoised - return it\\n\\t\\tif(dp[idx][m][n]) return dp[idx][m][n];\\n\\t\\t// count freqeuncy of zeros and ones in current string\\n\\t\\tint zeros = count(begin(strs[idx]), end(strs[idx]), \\'0\\'), ones = size(strs[idx]) - zeros;\\n\\t\\tdp[idx][m][n] = helper(strs, m, n, idx + 1); // case where current string is not chosen & move to next string\\n\\t\\t// if current string can be chosen, find optimal between choosing it and leaving it\\n\\t\\tif(m - zeros >= 0 && n - ones >= 0) \\n\\t\\t\\tdp[idx][m][n] = max(dp[idx][m][n], 1 + helper(strs, m - zeros, n - ones, idx + 1));\\n\\t\\treturn dp[idx][m][n]; // finally the optimal answer will be returned\\n\\t}\\n\\t```\n```\\n\\tfor item in items_list:\\n\\t\\tfor w in range(0, MAX_W+1): // build optimal answers for w from [0, max_W]\\n\\t\\t\\t// take it or leave to get optimal answer\\n\\t\\t// now dp will have optimal answers for items considered till now\\n\\t```\n```\\n\\tfor _string in strs:\\n\\t\\tfor i in range(0, m+1):\\n\\t\\t\\tfor j in range(0, n+1): // build optimal answers for both constraints - for each j in [0,n] & do this for each i in [o,m]\\n\\t\\t\\t\\t// again take it or leave choice will be evaluated for _string\\n\\t\\t// now dp will have optimal answers for strings considered till now\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 95807,
                "title": "0-1-knapsack-detailed-explanation",
                "content": "This problem is a typical 0-1 knapsack problem, we need to pick several strings in provided strings to get the maximum number of strings using limited number 0 and 1. We can create a three dimensional array, in which dp[i][j][k] means the maximum number of strings we can get from the first i argument strs using limited j number of \\'0\\'s and k number of \\'1\\'s.\\n\\nFor dp[i][j][k], we can get it by fetching the current string i or discarding the current string, which would result in dp[i][j][k] = dp[i-1][j-numOfZero(strs[i])][i-numOfOnes(strs[i])] and dp[i][j][k] = dp[i-1][j][k]; We only need to treat the larger one in it as the largest number for dp[i][j][k].\\n\\ntalking is cheap:\\n\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int l = strs.length;\\n        int[][][] dp = new int[l+1][m+1][n+1];\\n        \\n        for (int i = 0; i < l+1; i++) {\\n            int[] nums = new int[]{0,0};\\n            if (i > 0) {\\n                nums = calculate(strs[i-1]);\\n            }\\n            for (int j = 0; j < m+1; j++) {\\n                for (int k = 0; k < n+1; k++) {\\n                    if (i == 0) {\\n                        dp[i][j][k] = 0;\\n                    } else if (j>=nums[0] && k>=nums[1]) {\\n                        dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-nums[0]][k-nums[1]]+1);\\n                    } else {\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[l][m][n];\\n    }\\n    \\n    private int[] calculate(String str) {\\n        int[] res = new int[2];\\n        Arrays.fill(res, 0);\\n        \\n        for (char ch : str.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                res[0]++;\\n            } else if (ch == \\'1\\') {\\n                res[1]++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\nBy the way, 0-1 knapsack we cannot decrease the time complexity, but we can decrease the space complexity from i*j*k to j*k\\n\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int l = strs.length;\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m+1; i++) {\\n            Arrays.fill(dp[i], 0);\\n        }\\n        \\n        int[] nums = new int[]{0,0};\\n        for (String str : strs) {\\n            nums = calculate(str);\\n            for (int j = m; j >= nums[0]; j--) {\\n                for (int k = n; k >= nums[1]; k--) {\\n                    if (j>=nums[0] && k>=nums[1]) {\\n                        dp[j][k] = Math.max(dp[j][k], dp[j-nums[0]][k-nums[1]]+1);\\n                    } else {\\n                        dp[j][k] = dp[j][k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    \\n    private int[] calculate(String str) {\\n        int[] res = new int[2];\\n        Arrays.fill(res, 0);\\n        \\n        for (char ch : str.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                res[0]++;\\n            } else if (ch == \\'1\\') {\\n                res[1]++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "This problem is a typical 0-1 knapsack problem, we need to pick several strings in provided strings to get the maximum number of strings using limited number 0 and 1. We can create a three dimensional array, in which dp[i][j][k] means the maximum number of strings we can get from the first i argument strs using limited j number of \\'0\\'s and k number of \\'1\\'s.\\n\\nFor dp[i][j][k], we can get it by fetching the current string i or discarding the current string, which would result in dp[i][j][k] = dp[i-1][j-numOfZero(strs[i])][i-numOfOnes(strs[i])] and dp[i][j][k] = dp[i-1][j][k]; We only need to treat the larger one in it as the largest number for dp[i][j][k].\\n\\ntalking is cheap:\\n\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int l = strs.length;\\n        int[][][] dp = new int[l+1][m+1][n+1];\\n        \\n        for (int i = 0; i < l+1; i++) {\\n            int[] nums = new int[]{0,0};\\n            if (i > 0) {\\n                nums = calculate(strs[i-1]);\\n            }\\n            for (int j = 0; j < m+1; j++) {\\n                for (int k = 0; k < n+1; k++) {\\n                    if (i == 0) {\\n                        dp[i][j][k] = 0;\\n                    } else if (j>=nums[0] && k>=nums[1]) {\\n                        dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-nums[0]][k-nums[1]]+1);\\n                    } else {\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[l][m][n];\\n    }\\n    \\n    private int[] calculate(String str) {\\n        int[] res = new int[2];\\n        Arrays.fill(res, 0);\\n        \\n        for (char ch : str.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                res[0]++;\\n            } else if (ch == \\'1\\') {\\n                res[1]++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\nBy the way, 0-1 knapsack we cannot decrease the time complexity, but we can decrease the space complexity from i*j*k to j*k\\n\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int l = strs.length;\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m+1; i++) {\\n            Arrays.fill(dp[i], 0);\\n        }\\n        \\n        int[] nums = new int[]{0,0};\\n        for (String str : strs) {\\n            nums = calculate(str);\\n            for (int j = m; j >= nums[0]; j--) {\\n                for (int k = n; k >= nums[1]; k--) {\\n                    if (j>=nums[0] && k>=nums[1]) {\\n                        dp[j][k] = Math.max(dp[j][k], dp[j-nums[0]][k-nums[1]]+1);\\n                    } else {\\n                        dp[j][k] = dp[j][k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    \\n    private int[] calculate(String str) {\\n        int[] res = new int[2];\\n        Arrays.fill(res, 0);\\n        \\n        for (char ch : str.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                res[0]++;\\n            } else if (ch == \\'1\\') {\\n                res[1]++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2065992,
                "title": "c-detailed-explanation-w-recursion-memoziation-examples-and-well-commented",
                "content": "***Brief note about Question-***\\n* We have to return the size of the largest subset of strs such that there are at most `m 0\\'s `and` n 1`\\'s in the subset.\\n```\\nLet\\'s take an example not given in the question- \\nSuppose our arr is arr[]: [\"101\", \"111\", \"000\", \"01\", \"111110100\"], \\n                  Given,   m = 5 and n = 6\\n\\t\\t\\t\\t  \\nNow, This says that we can include at most 5 zeroes and at most 6 ones in our ans,\\nSo, we say that we will choose  \"101\", \"111\", \"000\", and \"01\"\\nby choosing this, we satisy our criteria of atmost 5 zeroes and 6 ones,\\nso the answer is 4.\\n\\nOne thing is to notice here is that we have to choose atmost,\\nmeans maximum we can choose for zero is \\'m\\' and maximum we can choose for one is \\'n\\'.\\nWe have option to choose less than \\'m\\' and \\'n\\' but to maximise the count of subset.\\n```\\n____________________________\\n***Generating intiutaion:***\\n* First thing that we will see is that from the given array of strings we have to choose some of its indices,such that after choosing them we will count our ones and zeros.\\n\\n* So, this is kind of ***option type thing***, suppose we start traversing in our given vector, and stand on any ith index, then for that index we have a choice.\\n* And **what choice** is that? Choice is that we will ask a question to ourself whether to include this string in our answer or not.\\n* ***So, if we decide to choose this string in our answer then we will add count of ones and zeroes of this string in our answer and move ahead and if we decide not to include this string in our answer, then we will do nothing, we just move forward.***\\n* So, Overall we can say that we have choice for every index of array whether to include it our answer or not to include.\\n* And whenver we heard a term that here we have a choice like this, then we will say **recursion** will use here.\\n* **Why recusrion?** Recursion is because it will try out every single possibility for every string in our answer.\\n* Let see ahead with a example.\\n__________________________\\n***Again a example for better understanding:***\\n```\\nWe will take a very light example, \\nSuppose array given to us is as arr[]: [\"00\", \"1\",\"0\", \"000\", \"11\"], Given m = 3 and n = 2\\nIt says that we can choose atmost three zeroes (m = 3) and also we can choose atmost two ones(n = 2)\\n\\nSee here, we can say that we have to choose three zeroes, so what are the options or to say \\nwhat are the choices we have,\\nWe have a option in which we will say for zeroes we will choose \"000\", it complete our criteria\\nof having atmost three zeroes and give us the count of subset as 1.\\n\\nBut, since we want to maximise our answer, we will say that it is better to choose \"00\" and \"0\",\\nit also satisfies our criteria of having atmost three zeroes, but with the count of subset as 2.\\n\\nSo, we saw here we will have choice for every string in our array, whether to include this in our answer or not.\\n_______________________________________________________________________________________\\n\\n      Visuliaze something like this, arr[]:  [\"00\", \"1\",\"0\", \"000\", \"11\"]\\n\\t                                          /  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t            whether to choose this  whether to not choose this\\n\\t\\t\\t\\t\\t\\t           {Same for all other strings}\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\nAnd that is what we are going to implement.\\n```\\n__________________________________________\\n***Now What?***\\n* Now till here we understand that ok we have option for every string in our array. Now what?\\n* We will ***keep a record of count ones and zeroes***.\\n* We say when we decide to include this string in our answer, then we add count of ones and zeroes of this string in our answer and then move to anthor index.\\n* But if we decide not to choose this, so we do not do any change in our counts, because we are not choosing this.\\n* And also, on including a string in our anwer we will see whether after including this in our answer our criteria of having atmost m zeroes and n zeroes are satisfied or not.\\n* If it crosses that criteria then we will do nothing we simply move ahead.\\n* But if it not crosses then criteria, then we will apply our option that whether to choose this in our answer.\\n* See commented code for more explanation.\\n\\n* We will move further with first recursion and then memoziation.\\n___________________________ \\n***Solution - I (Recursion, TLE)-***\\n```\\nclass Solution {\\npublic:\\n    // Count one and Zero function take string as parameter and count the number of ones and zeroes present in the string and return the counts.\\n    pair<int, int> countOneAndZero(string s)\\n    {\\n        int one = 0, zero = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) // travel in the string\\n        {\\n            if(s[i] == \\'1\\')  // if == \\'1\\', then add to one\\n                one++;\\n            else            // otherwise add to zero\\n                zero++;\\n        }\\n        \\n        return {one, zero};\\n    }\\n    \\n    int solve(int i, int one, int zero, int& maxZero, int& maxOne, \\n             vector<string>& arr)\\n    {\\n        if(i >= arr.size()) // if ith index crosses the length then return 0\\n            return 0;\\n        \\n        // if any of the count, crosses the criteria of having maximum one\\n        // or zero, then return 0\\n        if(one > maxOne || zero > maxZero)\\n            return 0;\\n        \\n        /* what we discused:-\\n        for every ith index i, we have two option, whether to include it\\n         in our answer or not, if include then add the count of \\n         ones and zeros from that string */\\n        \\n        // pair p contains, the number of ones and zeroes present in the string of ith index of vector arr.\\n        pair<int, int> p = countOneAndZero(arr[i]);\\n        \\n        /* we declare three variables -\\n        1) ans1, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then to include this in our answer.\\n        2) ans2, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then not to include this in our answer.\\n        3) ansWithout, If adding the count of ones and zeroes at ith index in arr, crosses our limit, then not to include this in our answer.\\n        */\\n        \\n        int ans1 = 0, ans2 = 0, ansWithout = 0;\\n        \\n        // adding count of current index, not to cross our limit then-\\n        if(one + p.first <= maxOne && zero + p.second <= maxZero)\\n        {\\n            // ans1, including it in our answer\\n            ans1 = 1 + solve(i + 1, one + p.first, zero + p.second, \\n                           maxZero, maxOne, arr);\\n            \\n            // not including in our answer.\\n            ans2 = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        else // if crossing limit, obviously not to take\\n        {\\n            ansWithout = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        \\n        // and at last return the maximum of them\\n        return max({ans1, ans2, ansWithout});\\n        \\n        \\n    }\\n    int findMaxForm(vector<string>& arr, int m, int n) {\\n        // we redfine m and n as maxzero and maxOne respectively, for better clarification.\\n        int maxZero = m; \\n        int maxOne = n;\\n        \\n        /* parameters of solve-\\n        1) First parameter is \\'i\\', by which we move in our array of strings.\\n        2) Second parameter is the variable who keeps record of count of ones. (we name it as one)\\n        3) Third parameter is the variable who keeps record of count of zeroes. (we name it as zero)\\n        4) Fourth parameter is maxZero, the maximum zeros we are allowed to take.\\n        5) Fifth parameter is maxOne, the maximum ones we are allowed to take. \\n        6) Last Sixth parameter is the array itself.\\n        */\\n        \\n        // return solve function\\n        return solve(0, 0, 0, maxZero, maxOne, arr);\\n    }\\n};\\n```\\n__________________________________________________\\n***Solution - II (Memoziation, Accepted)-***\\n* In memoziation, we make an dp array, to store some already previous computed result.\\n* ***How many parameter are there which are changing?***\\n* We will see, first index itself and then count of ones and and zeroes.\\n* So, we will a 3 D vector for storing results that are already previous computed.\\n* See, code :)\\n```\\nclass Solution {\\npublic:\\n    // 3 D dp vector, as we dicused, We will give it maximum size,\\n    //see Constraints, 1 <= strs.length <= 600 and 1 <= m, n <= 100\\n    int dp[601][101][101]; \\n    \\n    // Count one and Zero function take string as parameter and count the number of ones and zeroes present in the string and return the counts.\\n    pair<int, int> countOneAndZero(string s)\\n    {\\n        int one = 0, zero = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) // travel in the string\\n        {\\n            if(s[i] == \\'1\\') // if == \\'1\\', then add to one\\n                one++;\\n            else            // otherwise add to zero\\n                zero++;\\n        }\\n        \\n        return {one, zero};\\n    }\\n    \\n    int solve(int i, int one, int zero, int& maxZero, int& maxOne, \\n             vector<string>& arr)\\n    {\\n        if(i >= arr.size()) // if ith index crosses the length then return 0\\n            return 0;\\n        \\n        // if any of the count, crosses the criteria of having maximum one\\n        // or zero, then return 0\\n        if(one > maxOne || zero > maxZero)\\n            return 0;\\n        \\n        // if it is already computed, then no need to do computation again,\\n\\t\\t//return from here itself\\n        if(dp[i][one][zero] != -1)\\n        {\\n            return dp[i][one][zero];\\n        }\\n        \\n        /* what we discused:-\\n        for every ith index i, we have two option, whether to include it\\n         in our answer or not, if include then add the count of \\n         ones and zeros from that string */\\n        \\n        // pair p contains, the number of ones and zeroes present in the string of ith index of vector arr.\\n        pair<int, int> p = countOneAndZero(arr[i]);\\n        \\n        /* we declare three variables -\\n        1) ans1, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then to include this in our answer.\\n        2) ans2, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then not to include this in our answer.\\n        3) ansWithout, If adding the count of ones and zeroes at ith index in arr, crosses our limit, then not to include this in our answer.\\n        */\\n        \\n        int ans1 = 0, ans2 = 0, ansWithout = 0;\\n        \\n        // adding count of current index, not to cross our limit then-\\n        if(one + p.first <= maxOne && zero + p.second <= maxZero)\\n        {\\n            // ans1, including it in our answer\\n            ans1 = 1 + solve(i + 1, one + p.first, zero + p.second, \\n                           maxZero, maxOne, arr);\\n            \\n            // not including in our answer.\\n            ans2 = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        else // if crossing limit, obviously not to take\\n        {\\n            ansWithout = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        \\n        // and at last return the maximum of them\\n        return dp[i][one][zero] = max({ans1, ans2, ansWithout});\\n        \\n        \\n    }\\n    int findMaxForm(vector<string>& arr, int m, int n) {\\n        // we redfine m and n as maxzero and maxOne respectively, for better clarification.\\n        int maxZero = m; \\n        int maxOne = n;\\n        \\n        memset(dp, -1, sizeof(dp)); // intially, putting -1 in dp\\n        \\n        /* parameters of solve-\\n        1) First parameter is \\'i\\', by which we move in our array of strings.\\n        2) Second parameter is the variable who keeps record of count of ones. (we name it as one)\\n        3) Third parameter is the variable who keeps record of count of zeroes. (we name it as zero)\\n        4) Fourth parameter is maxZero, the maximum zeros we are allowed to take.\\n        5) Fifth parameter is maxOne, the maximum ones we are allowed to take. \\n        6) Last Sixth parameter is the array itself.\\n        */\\n        \\n        // return solve function\\n        return solve(0, 0, 0, maxZero, maxOne, arr);\\n    }\\n};\\n```\\n_______________________________\\n* **Note:** I am not providing bottom up soln, because every second post is that itself.\\n* Main thing is to come up with recursive approach and then memoize it.\\n______________\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nLet\\'s take an example not given in the question- \\nSuppose our arr is arr[]: [\"101\", \"111\", \"000\", \"01\", \"111110100\"], \\n                  Given,   m = 5 and n = 6\\n\\t\\t\\t\\t  \\nNow, This says that we can include at most 5 zeroes and at most 6 ones in our ans,\\nSo, we say that we will choose  \"101\", \"111\", \"000\", and \"01\"\\nby choosing this, we satisy our criteria of atmost 5 zeroes and 6 ones,\\nso the answer is 4.\\n\\nOne thing is to notice here is that we have to choose atmost,\\nmeans maximum we can choose for zero is \\'m\\' and maximum we can choose for one is \\'n\\'.\\nWe have option to choose less than \\'m\\' and \\'n\\' but to maximise the count of subset.\\n```\n```\\nWe will take a very light example, \\nSuppose array given to us is as arr[]: [\"00\", \"1\",\"0\", \"000\", \"11\"], Given m = 3 and n = 2\\nIt says that we can choose atmost three zeroes (m = 3) and also we can choose atmost two ones(n = 2)\\n\\nSee here, we can say that we have to choose three zeroes, so what are the options or to say \\nwhat are the choices we have,\\nWe have a option in which we will say for zeroes we will choose \"000\", it complete our criteria\\nof having atmost three zeroes and give us the count of subset as 1.\\n\\nBut, since we want to maximise our answer, we will say that it is better to choose \"00\" and \"0\",\\nit also satisfies our criteria of having atmost three zeroes, but with the count of subset as 2.\\n\\nSo, we saw here we will have choice for every string in our array, whether to include this in our answer or not.\\n_______________________________________________________________________________________\\n\\n      Visuliaze something like this, arr[]:  [\"00\", \"1\",\"0\", \"000\", \"11\"]\\n\\t                                          /  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t            whether to choose this  whether to not choose this\\n\\t\\t\\t\\t\\t\\t           {Same for all other strings}\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\nAnd that is what we are going to implement.\\n```\n```\\nclass Solution {\\npublic:\\n    // Count one and Zero function take string as parameter and count the number of ones and zeroes present in the string and return the counts.\\n    pair<int, int> countOneAndZero(string s)\\n    {\\n        int one = 0, zero = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) // travel in the string\\n        {\\n            if(s[i] == \\'1\\')  // if == \\'1\\', then add to one\\n                one++;\\n            else            // otherwise add to zero\\n                zero++;\\n        }\\n        \\n        return {one, zero};\\n    }\\n    \\n    int solve(int i, int one, int zero, int& maxZero, int& maxOne, \\n             vector<string>& arr)\\n    {\\n        if(i >= arr.size()) // if ith index crosses the length then return 0\\n            return 0;\\n        \\n        // if any of the count, crosses the criteria of having maximum one\\n        // or zero, then return 0\\n        if(one > maxOne || zero > maxZero)\\n            return 0;\\n        \\n        /* what we discused:-\\n        for every ith index i, we have two option, whether to include it\\n         in our answer or not, if include then add the count of \\n         ones and zeros from that string */\\n        \\n        // pair p contains, the number of ones and zeroes present in the string of ith index of vector arr.\\n        pair<int, int> p = countOneAndZero(arr[i]);\\n        \\n        /* we declare three variables -\\n        1) ans1, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then to include this in our answer.\\n        2) ans2, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then not to include this in our answer.\\n        3) ansWithout, If adding the count of ones and zeroes at ith index in arr, crosses our limit, then not to include this in our answer.\\n        */\\n        \\n        int ans1 = 0, ans2 = 0, ansWithout = 0;\\n        \\n        // adding count of current index, not to cross our limit then-\\n        if(one + p.first <= maxOne && zero + p.second <= maxZero)\\n        {\\n            // ans1, including it in our answer\\n            ans1 = 1 + solve(i + 1, one + p.first, zero + p.second, \\n                           maxZero, maxOne, arr);\\n            \\n            // not including in our answer.\\n            ans2 = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        else // if crossing limit, obviously not to take\\n        {\\n            ansWithout = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        \\n        // and at last return the maximum of them\\n        return max({ans1, ans2, ansWithout});\\n        \\n        \\n    }\\n    int findMaxForm(vector<string>& arr, int m, int n) {\\n        // we redfine m and n as maxzero and maxOne respectively, for better clarification.\\n        int maxZero = m; \\n        int maxOne = n;\\n        \\n        /* parameters of solve-\\n        1) First parameter is \\'i\\', by which we move in our array of strings.\\n        2) Second parameter is the variable who keeps record of count of ones. (we name it as one)\\n        3) Third parameter is the variable who keeps record of count of zeroes. (we name it as zero)\\n        4) Fourth parameter is maxZero, the maximum zeros we are allowed to take.\\n        5) Fifth parameter is maxOne, the maximum ones we are allowed to take. \\n        6) Last Sixth parameter is the array itself.\\n        */\\n        \\n        // return solve function\\n        return solve(0, 0, 0, maxZero, maxOne, arr);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // 3 D dp vector, as we dicused, We will give it maximum size,\\n    //see Constraints, 1 <= strs.length <= 600 and 1 <= m, n <= 100\\n    int dp[601][101][101]; \\n    \\n    // Count one and Zero function take string as parameter and count the number of ones and zeroes present in the string and return the counts.\\n    pair<int, int> countOneAndZero(string s)\\n    {\\n        int one = 0, zero = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) // travel in the string\\n        {\\n            if(s[i] == \\'1\\') // if == \\'1\\', then add to one\\n                one++;\\n            else            // otherwise add to zero\\n                zero++;\\n        }\\n        \\n        return {one, zero};\\n    }\\n    \\n    int solve(int i, int one, int zero, int& maxZero, int& maxOne, \\n             vector<string>& arr)\\n    {\\n        if(i >= arr.size()) // if ith index crosses the length then return 0\\n            return 0;\\n        \\n        // if any of the count, crosses the criteria of having maximum one\\n        // or zero, then return 0\\n        if(one > maxOne || zero > maxZero)\\n            return 0;\\n        \\n        // if it is already computed, then no need to do computation again,\\n\\t\\t//return from here itself\\n        if(dp[i][one][zero] != -1)\\n        {\\n            return dp[i][one][zero];\\n        }\\n        \\n        /* what we discused:-\\n        for every ith index i, we have two option, whether to include it\\n         in our answer or not, if include then add the count of \\n         ones and zeros from that string */\\n        \\n        // pair p contains, the number of ones and zeroes present in the string of ith index of vector arr.\\n        pair<int, int> p = countOneAndZero(arr[i]);\\n        \\n        /* we declare three variables -\\n        1) ans1, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then to include this in our answer.\\n        2) ans2, If adding the count of ones and zeroes at ith index in arr,\\n        does not crosses our limit, then not to include this in our answer.\\n        3) ansWithout, If adding the count of ones and zeroes at ith index in arr, crosses our limit, then not to include this in our answer.\\n        */\\n        \\n        int ans1 = 0, ans2 = 0, ansWithout = 0;\\n        \\n        // adding count of current index, not to cross our limit then-\\n        if(one + p.first <= maxOne && zero + p.second <= maxZero)\\n        {\\n            // ans1, including it in our answer\\n            ans1 = 1 + solve(i + 1, one + p.first, zero + p.second, \\n                           maxZero, maxOne, arr);\\n            \\n            // not including in our answer.\\n            ans2 = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        else // if crossing limit, obviously not to take\\n        {\\n            ansWithout = solve(i + 1, one, zero, maxZero, maxOne, arr);\\n        }\\n        \\n        // and at last return the maximum of them\\n        return dp[i][one][zero] = max({ans1, ans2, ansWithout});\\n        \\n        \\n    }\\n    int findMaxForm(vector<string>& arr, int m, int n) {\\n        // we redfine m and n as maxzero and maxOne respectively, for better clarification.\\n        int maxZero = m; \\n        int maxOne = n;\\n        \\n        memset(dp, -1, sizeof(dp)); // intially, putting -1 in dp\\n        \\n        /* parameters of solve-\\n        1) First parameter is \\'i\\', by which we move in our array of strings.\\n        2) Second parameter is the variable who keeps record of count of ones. (we name it as one)\\n        3) Third parameter is the variable who keeps record of count of zeroes. (we name it as zero)\\n        4) Fourth parameter is maxZero, the maximum zeros we are allowed to take.\\n        5) Fifth parameter is maxOne, the maximum ones we are allowed to take. \\n        6) Last Sixth parameter is the array itself.\\n        */\\n        \\n        // return solve function\\n        return solve(0, 0, 0, maxZero, maxOne, arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138695,
                "title": "js-python-java-c-easy-dp-knapsack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is a variation on the **0-1 Knapsack Problem** with a wrinkle: each item has a 2-dimensional weight, but a constant value. If we were to naively attempt every single permutation of up to **600** strings, that would be **2^600** permutations.\\n\\nBut thankfully we\\'re not tasked with keeping track of each permutation, but simply the maximum number of items. This calls for the use of **dynamic programming** (**DP**) to reduce the overall complexity by instead only keeping track of the best results of the various subproblems encountered while working our way to the eventual answer.\\n\\nFor our DP array (**dp**), **dp[i][j]** will represent the largest number of items that can be added to yield **i** zeros and **j** ones. Thus, our answer will ultimately be **dp[M][N]**. We\\'ll naturally being doing a bottom-up DP approach, as we\\'ll be starting with no data and iterating through the input array (**S**), adding more data to **dp** as we go.\\n\\nSince each string in **S** will require us to iterate through the entirety of **dp** looking for data to update, we\\'ll need to do this iteration in a top-down fashion, to avoid interfering with our overall bottom-up approach, which would occur if we were to update entries that will be the basis for later updates in the same pass.\\n\\nOnce we reach the end, we return **dp[M][N]**.\\n\\n\\n---\\n\\n#### ***Implementation:***\\n\\nAs each entry in dp will be in the range **[0,200]** based on the constraints for **M** and **N**, we have the option of using an **8-bit** number storage array for the purpose.\\n\\nPython has other, faster solutions, but this is one of the easiest, and mirrors the solutions in the other languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **104ms / 39.2MB** (beats 99% / 100%).\\n```javascript\\nvar findMaxForm = function(S, M, N) {\\n    let dp = Array.from({length:M+1},() => new Uint8Array(N+1))\\n    for (let i = 0; i < S.length; i++) {\\n        let str = S[i], zeros = 0, ones = 0\\n        for (let j = 0; j < str.length; j++)\\n            str.charAt(j) === \"0\" ? zeros++ : ones++\\n        for (let j = M; j >= zeros; j--)\\n            for (let k = N; k >= ones; k--)\\n                dp[j][k] = Math.max(dp[j][k], dp[j-zeros][k-ones] + 1)\\n    }\\n    return dp[M][N]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **3228ms / 14.2MB** (beats 76% / 100%).\\n```python\\nclass Solution:\\n    def findMaxForm(self, S: List[str], M: int, N: int) -> int:\\n        dp = [[0 for _ in range(N+1)] for _ in range(M+1)]\\n        for str in S:\\n            zeros = str.count(\"0\")\\n            ones = len(str) - zeros\\n            for i in range(M, zeros - 1, -1):\\n                for j in range(N, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\\n        return dp[M][N]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **31ms / 37.9MB** (beats 98% / 97%).\\n```java\\nclass Solution {\\n    public int findMaxForm(String[] S, int M, int N) {\\n        int[][] dp = new int[M+1][N+1];\\n        for (String str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str.toCharArray())\\n                if (c == \\'0\\') zeros++;\\n                else ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **32ms / 8.5MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& S, int M, int N) {\\n        int dp[101][101]{0};\\n        for (string str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str)\\n                c == \\'0\\' ? zeros++ : ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findMaxForm = function(S, M, N) {\\n    let dp = Array.from({length:M+1},() => new Uint8Array(N+1))\\n    for (let i = 0; i < S.length; i++) {\\n        let str = S[i], zeros = 0, ones = 0\\n        for (let j = 0; j < str.length; j++)\\n            str.charAt(j) === \"0\" ? zeros++ : ones++\\n        for (let j = M; j >= zeros; j--)\\n            for (let k = N; k >= ones; k--)\\n                dp[j][k] = Math.max(dp[j][k], dp[j-zeros][k-ones] + 1)\\n    }\\n    return dp[M][N]\\n};\\n```\n```python\\nclass Solution:\\n    def findMaxForm(self, S: List[str], M: int, N: int) -> int:\\n        dp = [[0 for _ in range(N+1)] for _ in range(M+1)]\\n        for str in S:\\n            zeros = str.count(\"0\")\\n            ones = len(str) - zeros\\n            for i in range(M, zeros - 1, -1):\\n                for j in range(N, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\\n        return dp[M][N]\\n```\n```java\\nclass Solution {\\n    public int findMaxForm(String[] S, int M, int N) {\\n        int[][] dp = new int[M+1][N+1];\\n        for (String str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str.toCharArray())\\n                if (c == \\'0\\') zeros++;\\n                else ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& S, int M, int N) {\\n        int dp[101][101]{0};\\n        for (string str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str)\\n                c == \\'0\\' ? zeros++ : ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95845,
                "title": "easy-to-understand-recursive-solutions-in-java-with-explanation",
                "content": "\\nAs everyone told, this is a 0-1 Knapsack problem. In my solution, the focus is not time or memory efficiency. Instead, I would like to generate a code which is simple to understand and easy to maintain.\\n\\nSo, the main idea is, for each string, we will decide whether \\n\\n* use remaining 0s and 1s (if there are enough of them) and count that string or\\n* do not use any 0s and 1s and skip that string entirely\\n\\nHere is this solution:\\n\\n```\\npublic class Solution {\\n\\n  public int findMaxForm(String[] strs, int m, int n) {\\n    return findMaxFormStartingWith(strs, m, n, 0);\\n  }\\n\\t\\n  private int findMaxFormStartingWith(String[] strs, int m, int n, int begin) {\\n    if ((begin==strs.length) || (m+n==0)) {\\n      return 0;\\n    }\\n    int countByAddingString = 0;\\n    String current = strs[begin];\\n    int zeroes = countZeroesIn(current);\\n    int ones = current.length()-zeroes;\\n    if (m>=zeroes && n>=ones) {\\n      countByAddingString = 1 + findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1);\\n    }\\n    int countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);\\n    if (countByAddingString > countBySkippingString) {\\n      return countByAddingString;\\n    }\\n    return countBySkippingString;\\n  }\\n\\t\\n  private int countZeroesIn(String str) {\\n    int count = 0;\\n    for (int i=0; i<str.length(); i++) {\\n      if (str.charAt(i) == '0') {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\nWith this code, for each string, we count the zeroes in it by ```countZeroesIn(String str)``` and see if there are enough 0s and 1s for it. If so, we accumulate that string and proceed with the remaining strings, 0s and 1s by means of the following code:\\n\\n```countByAddingString = 1 + findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1);```\\n\\nWe also take the other route, which simply skips the string and does not use any 0s and 1s.\\n\\n```countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);```\\n\\nWhichever is bigger, is that the result. \\n\\nThe main problem with this approach is, it is too slow. Why? Beacause, it does not take advantage of previously solved subproblems. The Dynamic Programming comes in to the scene. What we will add is a simple table, which holds the previous answers and return them whenever we need them.\\n\\n```findMaxFormStartingWith(strs, m, n, begin)``` is called by 4 parameters. The string array is provided for practical purposes. It can be simply left out by declaring a private field for the class. The actual parameters are the remaining 0s (```m```), 1s (```n```) and current string index ```begin```. I preferred to create a 3D integer array to store and retrieve the results of subproblems. Each dimension represents the respective values of the parameters.\\n\\n```\\n  private int[][][] dpTable;\\n\\n  public int findMaxForm(String[] strs, int m, int n) {\\n    dpTable = new int[m+1][n+1][strs.length];\\n    return findMaxFormStartingWith(strs, m, n, 0);\\n  }\\n```\\n\\nThe arrays in Java are 0-indexed, hence ```m+1``` and ```n+1``` make the array operations easier for us. With this array in our hands, we will have two extra operations:\\n\\n* return the result if we have solved for these parameters before\\n* store the result for further access\\n\\nThese are the steps that decrease the time required to solve the problem. And these are the steps that we can use as Dynamic Programming.\\n\\nThis modification can be seen in the final version below.\\n\\n```\\n  private int findMaxFormStartingWith(String[] strs, int m, int n, int begin) {\\n    if ((begin==strs.length) || (m+n==0)) {\\n      return 0;\\n    }\\n    // return the result if we have solved for these parameters before\\n    if (dpTable[m][n][begin] > 0) {\\n      return dpTable[m][n][begin];\\n    }\\n    int countByAddingString = 0;\\n    String current = strs[begin];\\n    int zeroes = countZeroesIn(current);\\n    int ones = current.length()-zeroes;\\n    if (m>=zeroes && n>=ones) {\\n      countByAddingString = findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1)+1;\\n    }\\n    int countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);\\n    // store the result for further access\\n    if (countByAddingString > countBySkippingString) {\\n      dpTable[m][n][begin] = countByAddingString;\\n    } else {\\n      dpTable[m][n][begin] = countBySkippingString;\\n    }\\n    return dpTable[m][n][begin];\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n  public int findMaxForm(String[] strs, int m, int n) {\\n    return findMaxFormStartingWith(strs, m, n, 0);\\n  }\\n\\t\\n  private int findMaxFormStartingWith(String[] strs, int m, int n, int begin) {\\n    if ((begin==strs.length) || (m+n==0)) {\\n      return 0;\\n    }\\n    int countByAddingString = 0;\\n    String current = strs[begin];\\n    int zeroes = countZeroesIn(current);\\n    int ones = current.length()-zeroes;\\n    if (m>=zeroes && n>=ones) {\\n      countByAddingString = 1 + findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1);\\n    }\\n    int countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);\\n    if (countByAddingString > countBySkippingString) {\\n      return countByAddingString;\\n    }\\n    return countBySkippingString;\\n  }\\n\\t\\n  private int countZeroesIn(String str) {\\n    int count = 0;\\n    for (int i=0; i<str.length(); i++) {\\n      if (str.charAt(i) == '0') {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\n```countZeroesIn(String str)```\n```countByAddingString = 1 + findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1);```\n```countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);```\n```findMaxFormStartingWith(strs, m, n, begin)```\n```m```\n```n```\n```begin```\n```\\n  private int[][][] dpTable;\\n\\n  public int findMaxForm(String[] strs, int m, int n) {\\n    dpTable = new int[m+1][n+1][strs.length];\\n    return findMaxFormStartingWith(strs, m, n, 0);\\n  }\\n```\n```m+1```\n```n+1```\n```\\n  private int findMaxFormStartingWith(String[] strs, int m, int n, int begin) {\\n    if ((begin==strs.length) || (m+n==0)) {\\n      return 0;\\n    }\\n    // return the result if we have solved for these parameters before\\n    if (dpTable[m][n][begin] > 0) {\\n      return dpTable[m][n][begin];\\n    }\\n    int countByAddingString = 0;\\n    String current = strs[begin];\\n    int zeroes = countZeroesIn(current);\\n    int ones = current.length()-zeroes;\\n    if (m>=zeroes && n>=ones) {\\n      countByAddingString = findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1)+1;\\n    }\\n    int countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);\\n    // store the result for further access\\n    if (countByAddingString > countBySkippingString) {\\n      dpTable[m][n][begin] = countByAddingString;\\n    } else {\\n      dpTable[m][n][begin] = countBySkippingString;\\n    }\\n    return dpTable[m][n][begin];\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138534,
                "title": "python-short-dp-explained",
                "content": "Actually, what is asked: let as have `k` pairs `(x1, y1), ... ,(xk, yk)`. We need to answer, how many of them we can choose, so sum of all chosen `x` less than `m` and sum of all chosen `y` is less than `n`.\\nOne way to solve it is to use `dp(mm, nn, kk)`, where:\\n1. `mm` is how many zeroes we still allowed to take\\n2. `nn` is how many ones we still allowed to take\\n3. `kk` is how many pairs our of `k` we already processed\\n\\nThen what we can do is the following:\\n1. if `mm < 0` or `nn < 0`, we return `-float(\"inf\")`, because we take more zeroes or ones than allowed\\n2. if `kk = len(strs)`, it means, that we out of pairs, return `0`.\\n3. finally, we can have two options: either take the last pair or not, and we choose the maximum. \\n\\n#### Complexity\\nTime and space complexity is`O(mnk)`, where `k` is number of strings, because we have this number of states and only `2` transitions from given state.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findMaxForm(self, strs, m, n):\\n        xy = [[s.count(\"0\"), s.count(\"1\")] for s in strs]\\n\\n        @lru_cache(None)\\n        \\n        def dp(mm, nn, kk):\\n            if mm < 0 or nn < 0: return -float(\"inf\")\\n            if kk == len(strs): return 0\\n            x, y = xy[kk]\\n            return max(1 + dp(mm-x, nn-y, kk + 1), dp(mm, nn, kk + 1))\\n        \\n        return dp(m, n, 0)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def findMaxForm(self, strs, m, n):\\n        xy = [[s.count(\"0\"), s.count(\"1\")] for s in strs]\\n\\n        @lru_cache(None)\\n        \\n        def dp(mm, nn, kk):\\n            if mm < 0 or nn < 0: return -float(\"inf\")\\n            if kk == len(strs): return 0\\n            x, y = xy[kk]\\n            return max(1 + dp(mm-x, nn-y, kk + 1), dp(mm, nn, kk + 1))\\n        \\n        return dp(m, n, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065208,
                "title": "python-easy-dp-2-approaches",
                "content": "\\n1. ##### **Memoization(Top Down)**\\n\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        counter=[[s.count(\"0\"), s.count(\"1\")] for s in strs]\\n        \\n        @cache\\n        def dp(i,j,idx):\\n            if i<0 or j<0:\\n                return -math.inf\\n            \\n            if idx==len(strs):\\n                return 0\\n            \\n            return max(dp(i,j,idx+1), 1 + dp(i-counter[idx][0], j-counter[idx][1], idx+1))\\n        return dp(m,n,0)\\n```\\n\\n\\n**Time - O(l * m * n)** - where `l` is length of `strs`\\n**Space - O(l * m * n)** - memo table\\n\\n\\n----\\n\\n2. ##### **Tabulation(Bottom Up)**\\n\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:            \\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        counter=[[s.count(\"0\"), s.count(\"1\")] for s in strs]\\n        \\n        for zeroes, ones in counter:\\n            for i in range(m, zeroes-1, -1):\\n                for j in range(n, ones-1, -1):                   \\n                    dp[i][j] = max(dp[i][j], 1+dp[i-zeroes][j-ones])\\n        \\n        return dp[-1][-1]\\n```\\n\\n**Time - O(l * m * n)** - where `l` is length of `strs`\\n**Space - O(m * n)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        counter=[[s.count(\"0\"), s.count(\"1\")] for s in strs]\\n        \\n        @cache\\n        def dp(i,j,idx):\\n            if i<0 or j<0:\\n                return -math.inf\\n            \\n            if idx==len(strs):\\n                return 0\\n            \\n            return max(dp(i,j,idx+1), 1 + dp(i-counter[idx][0], j-counter[idx][1], idx+1))\\n        return dp(m,n,0)\\n```\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:            \\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        counter=[[s.count(\"0\"), s.count(\"1\")] for s in strs]\\n        \\n        for zeroes, ones in counter:\\n            for i in range(m, zeroes-1, -1):\\n                for j in range(n, ones-1, -1):                   \\n                    dp[i][j] = max(dp[i][j], 1+dp[i-zeroes][j-ones])\\n        \\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95811,
                "title": "java-iterative-dp-solution-o-mn-space",
                "content": "Time Complexity: O(kl + kmn), where k is the length of input string array and l is the average length of a string within the array.\\n\\n```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n    int[][] dp = new int[m+1][n+1];\\n    for (String s : strs) {\\n        int[] count = count(s);\\n        for (int i=m;i>=count[0];i--) \\n            for (int j=n;j>=count[1];j--) \\n                dp[i][j] = Math.max(1 + dp[i-count[0]][j-count[1]], dp[i][j]);\\n    }\\n    return dp[m][n];\\n}\\n    \\npublic int[] count(String str) {\\n    int[] res = new int[2];\\n    for (int i=0;i<str.length();i++)\\n        res[str.charAt(i) - '0']++;\\n    return res;\\n }\\n```\\nThanks @shawngao for some ways to make this solution more concise.",
                "solutionTags": [],
                "code": "```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n    int[][] dp = new int[m+1][n+1];\\n    for (String s : strs) {\\n        int[] count = count(s);\\n        for (int i=m;i>=count[0];i--) \\n            for (int j=n;j>=count[1];j--) \\n                dp[i][j] = Math.max(1 + dp[i-count[0]][j-count[1]], dp[i][j]);\\n    }\\n    return dp[m][n];\\n}\\n    \\npublic int[] count(String str) {\\n    int[] res = new int[2];\\n    for (int i=0;i<str.length();i++)\\n        res[str.charAt(i) - '0']++;\\n    return res;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 121876,
                "title": "c-dp-knapsack-approach",
                "content": "\\nSuggestion :  Do Coin Change 1 and Coin Change 2 before trying this problem to learn more about Knapsack. Their solutions are [SOLUTION1](https://leetcode.com/problems/coin-change/discuss/121814/C++-Dynamic-Programming-(Knapsack-Approach)) and [SOLUTION2](https://leetcode.com/problems/coin-change-2/discuss/121863/C++-Dynamic-Programming-Solution-(Knapsack-Approach))\\n\\n# 1) Basics of Knapsack\\nFor people finding this problem hard to understand:\\nTry and understand the basic knapsack problem and how it\\u2019s solved in two different ways. We could either build the dp table top down or bottom up. The top down approach for knapsack with O(nW) runtime and O(nW) space is listed below:\\n\\n####  `Knapsack using 2D DP Array`\\n```\\nint knapsack(int val[], int wt[], int n, int W)\\n{\\n   int dp[n+1][W+1];\\n   memset(dp, 0, sizeof dp);\\n   for (int i = 1; i <= n; i++)\\n   {\\n       for (w = 1; w <= W; w++)\\n       {\\n           dp[i][w] = dp[i-1][w];  //don\\'t include the item\\n           if (wt[i-1] <= w)\\n                 dp[i][w] = max(dp[i][w], \\n                           val[i-1] + dp[i-1][w-wt[i-1]]);  \\n       }\\n   }\\n   return dp[n][W];\\n}\\n```\\n#### `Knapsack using 2D DP Array`\\nThe same knapsack problem could be solved with O(nW) runtime and O(W) space by building the table bottom up as shown below:\\n\\n```\\nint knapsack(int val[], int wt[], int n, int W)\\n{\\n    int dp[W+1];\\n    memset(dp, 0, sizeof(dp));\\n    for(int i=0; i < n; i++) \\n        for(int j=W; j>=wt[i]; j--)\\n            dp[j] = max(dp[j] , val[i] + dp[j-wt[i]]);\\n    return dp[W];\\n}\\n```\\nReference : [@messi14](https://leetcode.com/problems/ones-and-zeroes/discuss/95814/c++-DP-solution-with-comments/100357)\\n\\n\\n# 2) Knapsack 3D DP Array Solution O(l x m x n)\\n```\\n//Make a 3D Vector\\ntypedef vector<int> v1d;\\ntypedef vector<v1d> v2d;\\ntypedef vector<v2d> v3d;\\n\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l = strs.size();\\n        v3d dp(l+1, v2d(m+1, v1d(n+1, 0))); //dp[l+1][m+1][n+1]\\n        \\n        for(int i=1;i<=l;i++)\\n        {\\n            string s = strs[i-1];\\n            int ones = count(s.begin(), s.end(), \\'1\\');\\n            int zeros = s.size()-ones;\\n            \\n            for (int j=0;j<=m;j++)\\n            {\\n                for (int k=0;k<=n;k++)\\n                {\\n                    if (j>=zeros && k>=ones)\\n                        dp[i][j][k] = max(dp[i-1][j][k], 1 + dp[i-1][j-zeros][k-ones] );\\n                    else\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                    \\n                }//k\\n            }//j\\n        }//i\\n        \\n        return dp[l][m][n];\\n    }\\n};\\n```\\nReference : [@yangluphil](https://leetcode.com/problems/ones-and-zeroes/discuss/95814/c++-DP-solution-with-comments/120779?page=1) and [@ZhuEason](https://leetcode.com/problems/ones-and-zeroes/discuss/95807/0-1-knapsack-detailed-explanation.)\\n# 3) Knapsack 2D DP Array Solution O (l x m x n) \\n\\n```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n    \\n    for (auto &s: strs) {\\n        int ones = count(s.begin(), s.end(), \\'1\\');\\n        int zeros= s.size()-ones;\\n        for (int i=m; i>=zeros; i--) \\n            for (int j=n; j>=ones; j--)\\n                dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1);\\n    }\\n    return dp[m][n];\\n}\\n```\\nReference: [@gangshen2004@yahoo.com](https://leetcode.com/problems/ones-and-zeroes/discuss/95814/c++-DP-solution-with-comments/100382)",
                "solutionTags": [],
                "code": "```\\nint knapsack(int val[], int wt[], int n, int W)\\n{\\n   int dp[n+1][W+1];\\n   memset(dp, 0, sizeof dp);\\n   for (int i = 1; i <= n; i++)\\n   {\\n       for (w = 1; w <= W; w++)\\n       {\\n           dp[i][w] = dp[i-1][w];  //don\\'t include the item\\n           if (wt[i-1] <= w)\\n                 dp[i][w] = max(dp[i][w], \\n                           val[i-1] + dp[i-1][w-wt[i-1]]);  \\n       }\\n   }\\n   return dp[n][W];\\n}\\n```\n```\\nint knapsack(int val[], int wt[], int n, int W)\\n{\\n    int dp[W+1];\\n    memset(dp, 0, sizeof(dp));\\n    for(int i=0; i < n; i++) \\n        for(int j=W; j>=wt[i]; j--)\\n            dp[j] = max(dp[j] , val[i] + dp[j-wt[i]]);\\n    return dp[W];\\n}\\n```\n```\\n//Make a 3D Vector\\ntypedef vector<int> v1d;\\ntypedef vector<v1d> v2d;\\ntypedef vector<v2d> v3d;\\n\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l = strs.size();\\n        v3d dp(l+1, v2d(m+1, v1d(n+1, 0))); //dp[l+1][m+1][n+1]\\n        \\n        for(int i=1;i<=l;i++)\\n        {\\n            string s = strs[i-1];\\n            int ones = count(s.begin(), s.end(), \\'1\\');\\n            int zeros = s.size()-ones;\\n            \\n            for (int j=0;j<=m;j++)\\n            {\\n                for (int k=0;k<=n;k++)\\n                {\\n                    if (j>=zeros && k>=ones)\\n                        dp[i][j][k] = max(dp[i-1][j][k], 1 + dp[i-1][j-zeros][k-ones] );\\n                    else\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                    \\n                }//k\\n            }//j\\n        }//i\\n        \\n        return dp[l][m][n];\\n    }\\n};\\n```\n```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n    \\n    for (auto &s: strs) {\\n        int ones = count(s.begin(), s.end(), \\'1\\');\\n        int zeros= s.size()-ones;\\n        for (int i=m; i>=zeros; i--) \\n            for (int j=n; j>=ones; j--)\\n                dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1);\\n    }\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95808,
                "title": "0-1-knapsack-in-python",
                "content": "This question is very similar to a 0-1 knapsack, the transition function is\\n```\\ndp(k, x, y) = max(dp(k-1, x-z, y-o) + 1, dp(k-1, x, y))   (z is zeroes in strs[k], o is ones in strs[k])\\n```\\ndp(k, x, y) is the maximum strs we can include when we have x zeros, y ones and only the first k strs are considered.\\n\\ndp(len(strs), M, N) is the answer we are looking for\\n\\nI first implemented a dfs + memoization, which gets MLE, so I created a bottom up style dp.\\nWith bottom up, we can use something called \"rolling array\" to optimize space complexity from O(KMN) to O(MN)\\n\\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        def count(s):\\n            return sum(1 for c in s if c == '0'), sum(1 for c in s if c == '1')\\n        \\n        for z, o in [count(s) for s in strs]:\\n            for x in range(m, -1, -1):\\n                for y in range(n, -1, -1):\\n                    if x >= z and y >= o:\\n                        dp[x][y] = max(1 + dp[x-z][y-o], dp[x][y])\\n                        \\n        return dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\ndp(k, x, y) = max(dp(k-1, x-z, y-o) + 1, dp(k-1, x, y))   (z is zeroes in strs[k], o is ones in strs[k])\\n```\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        def count(s):\\n            return sum(1 for c in s if c == '0'), sum(1 for c in s if c == '1')\\n        \\n        for z, o in [count(s) for s in strs]:\\n            for x in range(m, -1, -1):\\n                for y in range(n, -1, -1):\\n                    if x >= z and y >= o:\\n                        dp[x][y] = max(1 + dp[x-z][y-o], dp[x][y])\\n                        \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701736,
                "title": "python-dp-solution-explained-with-example",
                "content": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : DP ##\\n\\t\\t## Similar to Leetcode 416. partition equal subset sum ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. This problem can be decomposed to 0/1 Knapsack Problem, where you have n items with each having its own weight w and own profit p, \\n        #      We have a limitation on maximum weight of the items that we can carry in a bag, so what is the maximum profit that can be achieved within the weight limit of the bag.\\n\\t\\t#\\t2. m, n are the similar to limitations of the bag, strings being with items with weight w\\n\\t\\t#\\t3. Each cell in DP indicates the number of strings that can be achieved with i zeros and j ones. We iterate with all strings and fill the matrix\\n        \\n\\t\\t## TIME COMPLEXITY : O(Nx(mxn)) ##\\n\\t\\t## SPACE COMPLEXITY : O(mxn) ##\\n\\n        ## EXAMPLE [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 5 3 ##\\n        ## STACK TRACE ##\\n        # [[0, 0, 0, 0], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]]\\n        # [[0, 0, 0, 0], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 2, 2], [0, 1, 2, 2]]\\n        # [[0, 0, 0, 0], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 2, 2], [0, 1, 2, 2]]\\n        # [[0, 1, 1, 1], [0, 1, 2, 2], [0, 1, 2, 2], [0, 1, 2, 2], [0, 1, 2, 3], [0, 1, 2, 3]]\\n        # [[0, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3], [1, 2, 3, 3], [1, 2, 3, 3], [1, 2, 3, 4]]\\n        \\n        ## WATCH OUT FOR LOOPS,\\n        ## 1. We are traversing reverse to prevent sub problem overlapping, consider string \"01\" and m = 5, n = 3 and draw matrix from normal order and in reverse order, you\\'ll understand\\n        ## 2. The lower limit is number of zeros and ones, coz before that you wont find any match\\n        dp = [[ 0 ] * (n+1) for _ in range(m+1)]\\n        for s in strs:\\n            zeros, ones = s.count(\"0\"), s.count(\"1\")\\n            for i in range(m, zeros - 1, -1):\\n                for j in range(n, ones - 1, -1):\\n                    # dp[i][j] indicates it has i zeros and j ones, can this string be formed with those ?\\n                    dp[i][j] = max( 1 + dp[i - zeros][j- ones], dp[i][j] )\\n            # print(dp)\\n        return dp[-1][-1]\\n    \\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : DP ##\\n\\t\\t## Similar to Leetcode 416. partition equal subset sum ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. This problem can be decomposed to 0/1 Knapsack Problem, where you have n items with each having its own weight w and own profit p, \\n        #      We have a limitation on maximum weight of the items that we can carry in a bag, so what is the maximum profit that can be achieved within the weight limit of the bag.\\n\\t\\t#\\t2. m, n are the similar to limitations of the bag, strings being with items with weight w\\n\\t\\t#\\t3. Each cell in DP indicates the number of strings that can be achieved with i zeros and j ones. We iterate with all strings and fill the matrix\\n        \\n\\t\\t## TIME COMPLEXITY : O(Nx(mxn)) ##\\n\\t\\t## SPACE COMPLEXITY : O(mxn) ##\\n\\n        ## EXAMPLE [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 5 3 ##\\n        ## STACK TRACE ##\\n        # [[0, 0, 0, 0], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]]\\n        # [[0, 0, 0, 0], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 2, 2], [0, 1, 2, 2]]\\n        # [[0, 0, 0, 0], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 2, 2], [0, 1, 2, 2]]\\n        # [[0, 1, 1, 1], [0, 1, 2, 2], [0, 1, 2, 2], [0, 1, 2, 2], [0, 1, 2, 3], [0, 1, 2, 3]]\\n        # [[0, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3], [1, 2, 3, 3], [1, 2, 3, 3], [1, 2, 3, 4]]\\n        \\n        ## WATCH OUT FOR LOOPS,\\n        ## 1. We are traversing reverse to prevent sub problem overlapping, consider string \"01\" and m = 5, n = 3 and draw matrix from normal order and in reverse order, you\\'ll understand\\n        ## 2. The lower limit is number of zeros and ones, coz before that you wont find any match\\n        dp = [[ 0 ] * (n+1) for _ in range(m+1)]\\n        for s in strs:\\n            zeros, ones = s.count(\"0\"), s.count(\"1\")\\n            for i in range(m, zeros - 1, -1):\\n                for j in range(n, ones - 1, -1):\\n                    # dp[i][j] indicates it has i zeros and j ones, can this string be formed with those ?\\n                    dp[i][j] = max( 1 + dp[i - zeros][j- ones], dp[i][j] )\\n            # print(dp)\\n        return dp[-1][-1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138696,
                "title": "ones-and-zeros-js-python-java-c-easy-dp-knapsack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is a variation on the **0-1 Knapsack Problem** with a wrinkle: each item has a 2-dimensional weight, but a constant value. If we were to naively attempt every single permutation of up to **600** strings, that would be **2^600** permutations.\\n\\nBut thankfully we\\'re not tasked with keeping track of each permutation, but simply the maximum number of items. This calls for the use of **dynamic programming** (**DP**) to reduce the overall complexity by instead only keeping track of the best results of the various subproblems encountered while working our way to the eventual answer.\\n\\nFor our DP array (**dp**), **dp[i][j]** will represent the largest number of items that can be added to yield **i** zeros and **j** ones. Thus, our answer will ultimately be **dp[M][N]**. We\\'ll naturally being doing a bottom-up DP approach, as we\\'ll be starting with no data and iterating through the input array (**S**), adding more data to **dp** as we go.\\n\\nSince each string in **S** will require us to iterate through the entirety of **dp** looking for data to update, we\\'ll need to do this iteration in a top-down fashion, to avoid interfering with our overall bottom-up approach, which would occur if we were to update entries that will be the basis for later updates in the same pass.\\n\\nOnce we reach the end, we return **dp[M][N]**.\\n\\n\\n---\\n\\n#### ***Implementation:***\\n\\nAs each entry in dp will be in the range **[0,200]** based on the constraints for **M** and **N**, we have the option of using an **8-bit** number storage array for the purpose.\\n\\nPython has other, faster solutions, but this is one of the easiest, and mirrors the solutions in the other languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **104ms / 39.2MB** (beats 99% / 100%).\\n```javascript\\nvar findMaxForm = function(S, M, N) {\\n    let dp = Array.from({length:M+1},() => new Uint8Array(N+1))\\n    for (let i = 0; i < S.length; i++) {\\n        let str = S[i], zeros = 0, ones = 0\\n        for (let j = 0; j < str.length; j++)\\n            str.charAt(j) === \"0\" ? zeros++ : ones++\\n        for (let j = M; j >= zeros; j--)\\n            for (let k = N; k >= ones; k--)\\n                dp[j][k] = Math.max(dp[j][k], dp[j-zeros][k-ones] + 1)\\n    }\\n    return dp[M][N]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **3228ms / 14.2MB** (beats 76% / 100%).\\n```python\\nclass Solution:\\n    def findMaxForm(self, S: List[str], M: int, N: int) -> int:\\n        dp = [[0 for _ in range(N+1)] for _ in range(M+1)]\\n        for str in S:\\n            zeros = str.count(\"0\")\\n            ones = len(str) - zeros\\n            for i in range(M, zeros - 1, -1):\\n                for j in range(N, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\\n        return dp[M][N]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **31ms / 37.9MB** (beats 98% / 97%).\\n```java\\nclass Solution {\\n    public int findMaxForm(String[] S, int M, int N) {\\n        int[][] dp = new int[M+1][N+1];\\n        for (String str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str.toCharArray())\\n                if (c == \\'0\\') zeros++;\\n                else ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **32ms / 8.5MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& S, int M, int N) {\\n        int dp[101][101]{0};\\n        for (string str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str)\\n                c == \\'0\\' ? zeros++ : ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar findMaxForm = function(S, M, N) {\\n    let dp = Array.from({length:M+1},() => new Uint8Array(N+1))\\n    for (let i = 0; i < S.length; i++) {\\n        let str = S[i], zeros = 0, ones = 0\\n        for (let j = 0; j < str.length; j++)\\n            str.charAt(j) === \"0\" ? zeros++ : ones++\\n        for (let j = M; j >= zeros; j--)\\n            for (let k = N; k >= ones; k--)\\n                dp[j][k] = Math.max(dp[j][k], dp[j-zeros][k-ones] + 1)\\n    }\\n    return dp[M][N]\\n};\\n```\n```python\\nclass Solution:\\n    def findMaxForm(self, S: List[str], M: int, N: int) -> int:\\n        dp = [[0 for _ in range(N+1)] for _ in range(M+1)]\\n        for str in S:\\n            zeros = str.count(\"0\")\\n            ones = len(str) - zeros\\n            for i in range(M, zeros - 1, -1):\\n                for j in range(N, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\\n        return dp[M][N]\\n```\n```java\\nclass Solution {\\n    public int findMaxForm(String[] S, int M, int N) {\\n        int[][] dp = new int[M+1][N+1];\\n        for (String str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str.toCharArray())\\n                if (c == \\'0\\') zeros++;\\n                else ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& S, int M, int N) {\\n        int dp[101][101]{0};\\n        for (string str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str)\\n                c == \\'0\\' ? zeros++ : ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464430,
                "title": "diego-s-understandable-explanations-c",
                "content": "Hi, I\\'m trying to make easily understandable explanations for everyone. Hopefully I did a good job here.\\n*Please upvote if this post helped you, so that others can find it.*\\n\\n**The insight**\\nThe problem insight comes from recognizing that it is useful to remember how many strings you could optimally form given some budget of zeros and ones.\\n\\nWe can think of each string as requiring a certain amount of zeros and ones. If our budget of zeros and ones has the required zeros and ones for a string, we can make a choice...\\n* to form the string, spending the required zeros and ones from the budget, or\\n* not to form the string, keeping the budget the same.\\n\\nTo make this decision, we simply have to compare the two choices! We do this by comparing...\\n* when forming the string, the optimal number of strings you could form with the now reduced budget, plus the one string you formed, or\\n* when not forming the string, the optimal number of strings you could form with the same budget.\\n\\nAnd this is completely tractable! We know this because if we save the maximum number of strings we could form for all budgets, then for each budget we consider, we already have all the optimal numbers saved for comparing.\\n\\nIt turns out that this simple two-option choice is all you need to do.\\n\\n**But wait, does the order of the strings you consider matter?**\\nGreat question! Thankfully, it doesn\\'t. This is because for each string, you\\'re always considering all possible budgets when forming the strings, which are later available for reference when you\\'re considering other strings. This way, you will always get the correct answer, regardless of whether or not you first look at a string you shouldn\\'t use.\\n\\n**Wrapping up**\\nNow make that decision for all possible budgets, from the first string to the last! Also, if your budget does not allow for a string, then you should forward propagate the optimal number of strings you can form so far given that budget. This makes sense because you know that at the very least this is the best you can do with the budget.\\n\\n**A solution**\\nThis solution can be optimized in some ways for improved performance, but I leave that exercise to the reader.\\n\\n```\\n// How many zeros and ones are required by this string?\\npair<int, int> count(const string& s) {\\n    int num_zeros = 0;\\n    for (char ch : s) if (ch == \\'0\\') num_zeros++;\\n    return {num_zeros, s.size() - num_zeros};\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<vector<int>>> dp(strs.size() + 1,\\n                                   vector<vector<int>>(m + 1,\\n                                                       vector<int>(n + 1, 0)));\\n    for (size_t i = 1; i < strs.size() + 1; i++) {\\n\\t\\t// Figure out how many zeros and ones you need for this string.\\n        int zeros, ones; tie(zeros, ones) = count(strs[i - 1]);\\n\\n        for (size_t j = 0; j < m + 1; j++) {\\n            for (size_t k = 0; k < n + 1; k++) {\\n\\t\\t\\t\\t// Can I form this string with my budget?\\n                if (j >= zeros && k >= ones) {\\n\\t\\t\\t\\t\\t// Is it better to not form the string or to form it?\\n                    dp[i][j][k] = max(dp[i - 1][j][k],\\n                                      1 + dp[i - 1][j - zeros][k - ones]);\\n                } else dp[i][j][k] = dp[i - 1][j][k]; // I can\\'t form it, so remember the best I could do.\\n            }\\n        }\\n    }\\n\\n    return dp.back().back().back();\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// How many zeros and ones are required by this string?\\npair<int, int> count(const string& s) {\\n    int num_zeros = 0;\\n    for (char ch : s) if (ch == \\'0\\') num_zeros++;\\n    return {num_zeros, s.size() - num_zeros};\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<vector<int>>> dp(strs.size() + 1,\\n                                   vector<vector<int>>(m + 1,\\n                                                       vector<int>(n + 1, 0)));\\n    for (size_t i = 1; i < strs.size() + 1; i++) {\\n\\t\\t// Figure out how many zeros and ones you need for this string.\\n        int zeros, ones; tie(zeros, ones) = count(strs[i - 1]);\\n\\n        for (size_t j = 0; j < m + 1; j++) {\\n            for (size_t k = 0; k < n + 1; k++) {\\n\\t\\t\\t\\t// Can I form this string with my budget?\\n                if (j >= zeros && k >= ones) {\\n\\t\\t\\t\\t\\t// Is it better to not form the string or to form it?\\n                    dp[i][j][k] = max(dp[i - 1][j][k],\\n                                      1 + dp[i - 1][j - zeros][k - ones]);\\n                } else dp[i][j][k] = dp[i - 1][j][k]; // I can\\'t form it, so remember the best I could do.\\n            }\\n        }\\n    }\\n\\n    return dp.back().back().back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065570,
                "title": "100-0-ms-concise-code-epic-meme",
                "content": "# NOTE:- if you found anyone\\'s post helpful please upvote that post because some persons are downvoting unneccesarily, and you are the one guys that save our post from getting unvisible, upvote for remains visible for others so and other people can also get benefitted.\\n# explain\\n\\nThis code is an implementation of the 0/1 Knapsack problem, where we are given a list of strings and two integers m and n. The goal is to select a subset of strings such that the total number of 1s in the subset is at most n and the total number of 0s in the subset is at most m. The function returns the maximum number of strings that can be selected.\\n\\nThe function uses dynamic programming to solve the problem. It creates a 2D array dp of size (m+1) x (n+1) to store the maximum number of strings that can be selected for each subproblem. The subproblems are defined by the number of 0s and 1s allowed in the subset. dp[i][j] represents the maximum number of strings that can be selected using i 0s and j 1s.\\n\\nFor each string in the input list, the function calculates the number of 0s and 1s in the string using two variables zero and one. It then updates the dp array for each subproblem that can be solved using the current string. This is done using two nested loops that iterate over all possible values of i and j. For each pair (i,j), the function checks if the current string can be added to the subset. If the number of 0s in the current string is less than or equal to i and the number of 1s in the current string is less than or equal to j, then the function updates dp[i][j] to be the maximum of its current value and dp[i - zero][j - one] + 1. This means that we can either exclude the current string and use the best solution we have found so far for subproblem (i,j), or we can include the current string and use the best solution we have found so far for subproblem (i - zero, j - one) plus 1.\\n\\nAfter all strings have been processed, the function returns the value of dp[m][n]. This represents the maximum number of strings that can be selected using m 0s and n 1s.\\n\\nOverall, the time complexity of this function is O(l * mn), where l is the length of the input array. The space complexity is O(mn) to store the dp array.\\n\\n\\n```java []\\npublic static int findMaxForm(String[] strs, int m, int n) {\\n        int[][] dp = new int[m + 1][n + 1];\\n        for(String str : strs){\\n            int one = 0;\\n            int zero = 0;\\n            for(char c : str.toCharArray()){\\n                if(c == \\'1\\')\\n                    one++;\\n                else\\n                    zero++;\\n            }\\n            for(int i = m; i >= zero; i--){\\n                for(int j = n; j >= one; j--){\\n                    if(one <= j && zero <= i)\\n                        dp[i][j] = Math.max(dp[i][j],dp[i - zero][j - one] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n```c++ []\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n    for(string str : strs){\\n        int one = 0;\\n        int zero = 0;\\n        for(char c : str){\\n            if(c == \\'1\\')\\n                one++;\\n            else\\n                zero++;\\n        }\\n        for(int i = m; i >= zero; i--){\\n            for(int j = n; j >= one; j--){\\n                if(one <= j && zero <= i)\\n                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1);\\n            }\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```\\n```python []\\ndef findMaxForm(strs, m, n):\\n    dp = [[0] * (n+1) for _ in range(m+1)]\\n    for str in strs:\\n        one = 0\\n        zero = 0\\n        for c in str:\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1\\n        for i in range(m, zero-1, -1):\\n            for j in range(n, one-1, -1):\\n                if one <= j and zero <= i:\\n                    dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + 1)\\n    return dp[m][n]\\n```\\n# dry run 1\\nlet\\'s do a dry run for the given input:\\n\\nFirst, we initialize a 2D array dp[m+1][n+1] with all 0\\'s:\\n\\n     0  1\\n   -------\\n 0 |  0  0\\n 1 |  0  0\\nNext, we loop through each string in the input array and count the number of ones and zeros:\\n\\nFor the first string \"10\", we have one zero and one one.\\nFor the second string \"0\", we have one zero and zero ones.\\nFor the third string \"1\", we have zero zeros and one one.\\nNext, we iterate through the dp array for each possible combination of zeros and ones that can be used to form the current string:\\n\\nFor the first string \"10\", we start at dp[1][1] and iterate backwards through the array, checking each combination of zeros and ones. Since we have one zero and one one, we can update dp[0][0] to 1 (indicating that we can form one string using zero zeros and zero ones) and dp[1][1] to 1 (indicating that we can form one string using one zero and one one).\\nFor the second string \"0\", we start at dp[1][1] and iterate backwards through the array, checking each combination of zeros and ones. Since we have one zero and zero ones, we can update dp[1][0] to 1 (indicating that we can form one string using one zero and zero ones).\\nFor the third string \"1\", we start at dp[1][1] and iterate backwards through the array, checking each combination of zeros and ones. Since we have zero zeros and one one, we can update dp[0][1] to 1 (indicating that we can form one string using zero zeros and one one).\\nAfter iterating through all the strings and updating the dp array accordingly, we end up with the following dp array:\\n\\n     0  1\\n   -------\\n 0 |  1  1\\n 1 |  1  2\\nThe value at dp[1][1] (which represents the maximum number of strings that can be formed using one zero and one one) is 2, which is the output for this input.\\n\\n# dry run 2\\nlet\\'s do a dry run for the given input:\\n\\nFirst, we initialize a 2D array dp[m+1][n+1] with all 0\\'s:\\n\\n      0  1  2  3\\n   --------------\\n 0 |  0  0  0  0\\n 1 |  0  0  0  0\\n 2 |  0  0  0  0\\n 3 |  0  0  0  0\\n 4 |  0  0  0  0\\n 5 |  0  0  0  0\\nNext, we loop through each string in the input array and count the number of ones and zeros:\\n\\nFor the first string \"10\", we have one zero and one one.\\nFor the second string \"0001\", we have three zeros and one one.\\nFor the third string \"111001\", we have two zeros and four ones.\\nFor the fourth string \"1\", we have zero zeros and one one.\\nFor the fifth string \"0\", we have one zero and zero ones.\\nNext, we iterate through the dp array for each possible combination of zeros and ones that can be used to form the current string:\\n\\nFor the first string \"10\", we start at dp[5][3] and iterate backwards through the array, checking each combination of zeros and ones. Since we have one zero and one one, we can only update dp[1][2] to 1 (indicating that we can form one string using one zero and two ones).\\nFor the second string \"0001\", we start at dp[5][3] and iterate backwards through the array, checking each combination of zeros and ones. Since we have three zeros and one one, we can update dp[2][3] to 1 (indicating that we can form one string using two zeros and three ones).\\nFor the third string \"111001\", we start at dp[5][3] and iterate backwards through the array, checking each combination of zeros and ones. Since we have two zeros and four ones, we can update dp[2][1] to 1 (indicating that we can form one string using two zeros and one one).\\nFor the fourth string \"1\", we start at dp[5][3] and iterate backwards through the array, checking each combination of zeros and ones. Since we have zero zeros and one one, we can update dp[5][2] to 1 (indicating that we can form one string using five zeros and two ones).\\nFor the fifth string \"0\", we start at dp[5][3] and iterate backwards through the array, checking each combination of zeros and ones. Since we have one zero and zero ones, we can update dp[4][3] to 1 (indicating that we can form one string using four zeros and three ones).\\nAfter iterating through all the strings and updating the dp array accordingly, we end up with the following dp array:\\n\\n      0  1  2  3\\n   --------------\\n 0 |  0  0  0  0\\n 1 |  0  0  1  1\\n 2 |  0  1  1  1\\n 3 |  0  1  1  1\\n 4 |  0  1  1  1\\n 5 |  0  0  1  1\\nThe value at dp[5][3] (which represents the maximum number of strings that can be formed using five zeros and three ones) is 4, which is the output for this input.\\n\\n# time complexity (TC) \\nThe time complexity (TC) of this algorithm is O(l * mn), where l is the length of the input array and m and n are the given integers. The outer loop iterates over each string in the input array, while the two inner loops iterate over all possible values of i and j. Therefore, the total number of iterations of the inner loops is O(mn), and since this is done l times, the total time complexity is O(l * mn).\\n\\nThe space complexity (SC) of this algorithm is O(mn), since we are using a 2D list dp of size (m+1) x (n+1) to store the maximum number of strings that can be selected for each subproblem. Therefore, the space required is proportional to the product of m and n.\\n\\n![image](https://assets.leetcode.com/users/images/74392f99-73ed-4faf-b464-42d893a3549a_1653280016.6957881.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java []\\npublic static int findMaxForm(String[] strs, int m, int n) {\\n        int[][] dp = new int[m + 1][n + 1];\\n        for(String str : strs){\\n            int one = 0;\\n            int zero = 0;\\n            for(char c : str.toCharArray()){\\n                if(c == \\'1\\')\\n                    one++;\\n                else\\n                    zero++;\\n            }\\n            for(int i = m; i >= zero; i--){\\n                for(int j = n; j >= one; j--){\\n                    if(one <= j && zero <= i)\\n                        dp[i][j] = Math.max(dp[i][j],dp[i - zero][j - one] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\n```c++ []\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n    for(string str : strs){\\n        int one = 0;\\n        int zero = 0;\\n        for(char c : str){\\n            if(c == \\'1\\')\\n                one++;\\n            else\\n                zero++;\\n        }\\n        for(int i = m; i >= zero; i--){\\n            for(int j = n; j >= one; j--){\\n                if(one <= j && zero <= i)\\n                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1);\\n            }\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```\n```python []\\ndef findMaxForm(strs, m, n):\\n    dp = [[0] * (n+1) for _ in range(m+1)]\\n    for str in strs:\\n        one = 0\\n        zero = 0\\n        for c in str:\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1\\n        for i in range(m, zero-1, -1):\\n            for j in range(n, one-1, -1):\\n                if one <= j and zero <= i:\\n                    dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + 1)\\n    return dp[m][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2065429,
                "title": "c-short-and-easy-dp-solution",
                "content": "Typical DP problem. Comment for any doubts.\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n        \\n        for(auto& s : strs) { \\n            \\n            int zeros = count(s.begin(), s.end(), \\'0\\');\\n            int ones = s.size();\\n            \\n            for(int i = m; i >= zeros; i--) \\n                for(int j = n; j >= (ones - zeros); j--) \\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - zeros][j - ones + zeros]);\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n        \\n        for(auto& s : strs) { \\n            \\n            int zeros = count(s.begin(), s.end(), \\'0\\');\\n            int ones = s.size();\\n            \\n            for(int i = m; i >= zeros; i--) \\n                for(int j = n; j >= (ones - zeros); j--) \\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - zeros][j - ones + zeros]);\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95851,
                "title": "4-python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Ones and Zeroes** https://leetcode.com/problems/ones-and-zeroes/\\n\\n**BruteForce**\\n* The recursion tree for this problem indicates that there are three states: i, m, and n. i refers to the start index for strs and m, n are the number of zeroes and ones allowed. The tree will perform a DFS like traversal for every possible start index i and record the number of strings that could be formed. The solution would be the maximum between all the initial start states.\\n* The helper method takes m, n, and i as the parameters for this problem. Note we do not have any explicit checks like m ==0 and n==0 for a solution. m could be 0 and n could be non zero and subsequent items might just have 1s. Once we pick a candidate, we just check if we have sufficient zeroes and ones to accomodate it. If yes, we include it and make the next call.\\n```\\nclass Solution(object):\\n    def helper(self, strs, m, n, i):\\n        max_so_far = 0\\n        for idx in range(i, len(strs)):\\n            zeroes, ones = strs[idx].count('0'), strs[idx].count('1') \\n            if m >= zeroes and n >= ones:\\n                max_so_far = max(max_so_far, self.helper(strs, m-zeroes, n-ones, idx+1)+1)\\n        return max_so_far\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cache = {}\\n        return self.helper(strs, m, n, 0)\\n```\\n\\n**Memoization: O(MNL). TLE error**\\n* Find the maximum strings which can be created using m zeroes and n ones starting from index i in strs and store the results in a three dimensional table. The answer to the problem is then table[m,n,0]\\n* The code is exactly like the brute force approach with an addition of a table.\\n* This gives a TLE.\\n```\\nclass Solution(object):\\n    def helper(self, strs, m, n, i, table):\\n        if m in table and n in table[m] and i in table[m][n]:\\n            return table[m][n][i]\\n        table.setdefault(m, {}).setdefault(n, {})[i] = 0\\n        for idx in range(i, len(strs)):\\n            zeroes, ones = strs[idx].count('0'), strs[idx].count('1') \\n            if m >= zeroes and n >= ones:\\n                table[m][n][i] = max(table[m][n][i], self.helper(strs, m-zeroes, n-ones, idx+1, table)+1)\\n        return table[m][n][i]\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return self.helper(strs, m, n, 0, {})\\n```\\n\\n**Dynamic Programming: Time and Space O(MNL). MLE error**\\n* Find the maximum strings which can be created using m zeroes and n ones using indices 0 to i in strs (strs[0:i+1]) and store the results in a three dimensional table. The answer to the problem is then table[m,n,i]\\n* For simplicity, we will parameterize i as the number of strings being used in strs so that we dont need to deal with negative indices.\\n* Iterate from index 1 to len(strs). For a given index, we test all possible pairs of m and n. \\n* If for a pair we find we have sufficient zeroes and ones to use str[i], we update table[i,j,k] as the max of table[i-1,j, k], 1+table[i-1,j-zeroes,k-ones]. This means that we are trying to find the maximum by either including it or not including it. For the case of inclusion, we need to find the maximum string we can until index i-1 with j-zeroes and k-ones.\\n* If for a pair we find we do not have sufficient zeroes and ones, we update table[i,j,k] as table[i-1,j,k].\\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        table = {k:[[0]*(n+1) for _ in range(m+1)] for k in range(len(strs)+1)}\\n        for i in range(1, len(strs)+1):\\n            zeroes, ones = strs[i-1].count('0'), strs[i-1].count('1')\\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    if j >= zeroes and k >= ones:\\n                        table[i][j][k] = max(table[i-1][j][k], 1+table[i-1][j-zeroes][k-ones])\\n                    else:\\n                        table[i][j][k] = table[i-1][j][k]\\n        return table[len(strs)][m][n]\\n```\\n\\n**Dynamic Programming: Time O(MNL) and Space O(MN). Accepted Solution*\\n \\n*  Do we really need a three dimensional table? Process index i only requires the table for index i-1.\\n*  We can therefore use a prev and current table and achieve space complexity of O(MN).\\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        prev, curr = [[0]*(n+1) for _ in range(m+1)], [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(1, len(strs)+1):\\n            zeroes, ones = strs[i-1].count('0'), strs[i-1].count('1')\\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    curr[j][k] = 0\\n                    if j >= zeroes and k >= ones:\\n                        curr[j][k] = max(prev[j][k], 1+prev[j-zeroes][k-ones])\\n                    else:\\n                        curr[j][k] = prev[j][k]\\n            prev, curr = curr, prev\\n        return prev[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, strs, m, n, i):\\n        max_so_far = 0\\n        for idx in range(i, len(strs)):\\n            zeroes, ones = strs[idx].count('0'), strs[idx].count('1') \\n            if m >= zeroes and n >= ones:\\n                max_so_far = max(max_so_far, self.helper(strs, m-zeroes, n-ones, idx+1)+1)\\n        return max_so_far\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cache = {}\\n        return self.helper(strs, m, n, 0)\\n```\n```\\nclass Solution(object):\\n    def helper(self, strs, m, n, i, table):\\n        if m in table and n in table[m] and i in table[m][n]:\\n            return table[m][n][i]\\n        table.setdefault(m, {}).setdefault(n, {})[i] = 0\\n        for idx in range(i, len(strs)):\\n            zeroes, ones = strs[idx].count('0'), strs[idx].count('1') \\n            if m >= zeroes and n >= ones:\\n                table[m][n][i] = max(table[m][n][i], self.helper(strs, m-zeroes, n-ones, idx+1, table)+1)\\n        return table[m][n][i]\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return self.helper(strs, m, n, 0, {})\\n```\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        table = {k:[[0]*(n+1) for _ in range(m+1)] for k in range(len(strs)+1)}\\n        for i in range(1, len(strs)+1):\\n            zeroes, ones = strs[i-1].count('0'), strs[i-1].count('1')\\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    if j >= zeroes and k >= ones:\\n                        table[i][j][k] = max(table[i-1][j][k], 1+table[i-1][j-zeroes][k-ones])\\n                    else:\\n                        table[i][j][k] = table[i-1][j][k]\\n        return table[len(strs)][m][n]\\n```\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        prev, curr = [[0]*(n+1) for _ in range(m+1)], [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(1, len(strs)+1):\\n            zeroes, ones = strs[i-1].count('0'), strs[i-1].count('1')\\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    curr[j][k] = 0\\n                    if j >= zeroes and k >= ones:\\n                        curr[j][k] = max(prev[j][k], 1+prev[j-zeroes][k-ones])\\n                    else:\\n                        curr[j][k] = prev[j][k]\\n            prev, curr = curr, prev\\n        return prev[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123247,
                "title": "recursion-memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n       return solve(0,m,n,strs.size(),strs);\\n    }\\n    int solve(int start,int m,int n,int size,vector<string>&strs){\\n        if(start>=size || m<0 || n<0)\\n            return 0;\\n        if(m==0 && n==0)\\n            return 0;\\n        if(dp[start][m][n]!=-1)\\n            return dp[start][m][n];\\n        \\n        int i=start;\\n        int zeroes=count(strs[i].begin(),strs[i].end(),\\'0\\');\\n        int ones=strs[i].size()-zeroes;\\n        if(m>=zeroes && n>=ones)\\n            return dp[start][m][n]=max(1+solve(i+1,m-zeroes,n-ones,size,strs),solve(i+1,m,n,size,strs));\\n        else\\n            return dp[start][m][n]=solve(i+1,m,n,size,strs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n       return solve(0,m,n,strs.size(),strs);\\n    }\\n    int solve(int start,int m,int n,int size,vector<string>&strs){\\n        if(start>=size || m<0 || n<0)\\n            return 0;\\n        if(m==0 && n==0)\\n            return 0;\\n        if(dp[start][m][n]!=-1)\\n            return dp[start][m][n];\\n        \\n        int i=start;\\n        int zeroes=count(strs[i].begin(),strs[i].end(),\\'0\\');\\n        int ones=strs[i].size()-zeroes;\\n        if(m>=zeroes && n>=ones)\\n            return dp[start][m][n]=max(1+solve(i+1,m-zeroes,n-ones,size,strs),solve(i+1,m,n,size,strs));\\n        else\\n            return dp[start][m][n]=solve(i+1,m,n,size,strs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138621,
                "title": "c-super-simple-dynamic-programming-explained-solution",
                "content": "**Brief explanation:**\\nWe have a table size n*m, initialized by 0s.\\nIn each cell dp[i][j] we will save the size of the largest subset of strs such that there are at most j 1\\'s and i 0\\'s in the subset.\\nIn the end, dp[n][m] will have the desired result.\\nWe loop through the list of strings.\\nIn each iteration, we have two options: Either we add the current string to our result, or we don\\'t.\\nIf we don\\'t use it, the value in dp[i][j] stays as it was before.\\nIf we do want to use it, we put in dp[i][j]: dp[i - ones][j - zeros], because we can\\'t use more than j 1\\'s and i 0\\'s, so we reduce the amount of 1\\'s and 0\\'s in the current string and check the value in the [i - ones][j - zeros] cell, and then add one because we are using another string.\\nWe want the maximum between those two options.\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 0));\\n        int ones, zeros;\\n        for (auto str : strs) {\\n            ones = count(str.begin(), str.end(), \\'1\\');\\n            zeros = count(str.begin(), str.end(), \\'0\\');\\n            for (int i = n; i >= ones; i--) {\\n                for (int j = m; j >= zeros; j--) {\\n                    \\n                    // In each cell, we check the max between using the current string or not.\\n                    // dp[i][j] is the previous value in the cell - not using the current str.\\n                    // dp[i - ones][j - zeros] is the value if we want to use the current string.\\n                    // we add one because we are using another string.\\n                    \\n                    dp[i][j] = max(dp[i][j], dp[i - ones][j - zeros] + 1);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 0));\\n        int ones, zeros;\\n        for (auto str : strs) {\\n            ones = count(str.begin(), str.end(), \\'1\\');\\n            zeros = count(str.begin(), str.end(), \\'0\\');\\n            for (int i = n; i >= ones; i--) {\\n                for (int j = m; j >= zeros; j--) {\\n                    \\n                    // In each cell, we check the max between using the current string or not.\\n                    // dp[i][j] is the previous value in the cell - not using the current str.\\n                    // dp[i - ones][j - zeros] is the value if we want to use the current string.\\n                    // we add one because we are using another string.\\n                    \\n                    dp[i][j] = max(dp[i][j], dp[i - ones][j - zeros] + 1);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177368,
                "title": "python-clear-explanation-from-recursion-to-dp",
                "content": "**Recursion (Did not submit)**\\nThe idea is like the coin change problem. Once we encounter ```strs[i]```, we calculate ```m1```, the number of 0\\'s, and ```n1```, the number of 1\\'s. If ```m1```  is less than ```m``` and ```n1``` is less than ```n```, it means we have two options with that string: to use it or to skip it. If we use it, we reduce ```m``` by ```m1``` and `n` by `n1`, add the counter by one, and go to the next string. If we skip it, we just go to the next string. \\n\\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def findMax(strs, i, m, n):\\n            counter = 0\\n            if i <= len(strs)-1:                \\n                if m > 0 or n > 0:\\n                    # use it or skip it\\n                    m1 = strs[i].count(\\'0\\')\\n                    n1 = strs[i].count(\\'1\\')\\n                    use = 0\\n                    \\n                    # skip it\\n                    skip = findMax(strs, i+1, m, n)\\n                    \\n                    # use it\\n                    if m1 <= m and n1 <= n:\\n                        use = findMax(strs, i+1, m-m1, n-n1) + 1\\n                    \\n                    # update counter\\n                    counter = max(use, skip)\\n                                \\n            return counter\\n            \\n        counter = findMax(strs, 0, m, n)\\n        return counter\\n```\\n\\n**Memoization (Memory Limit Exceeded 63/63)**\\nThis is just like the recursive solution. I only add the `self.memo` dictionary to store pre-computed solutions. \\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.memo = {}\\n        def findMax(strs, i, m, n):\\n            if i <= len(strs)-1:\\n                if (i, m, n) in self.memo:\\n                    return self.memo[(i,m,n)]\\n                \\n                if m > 0 or n > 0:\\n                    # use it or skip it\\n                    m1 = strs[i].count(\\'0\\')\\n                    n1 = strs[i].count(\\'1\\')\\n                    use = 0\\n                    \\n                    # skip it\\n                    skip = findMax(strs, i+1, m, n)\\n                    \\n                    # use it\\n                    if m1 <= m and n1 <= n:\\n                        use = findMax(strs, i+1, m-m1, n-n1) + 1\\n                    \\n                    # update counter\\n                    counter = max(use, skip)\\n                    self.memo[(i,m,n)] = counter\\n                    \\n                    return self.memo[(i,m,n)]\\n            \\n            return 0\\n            \\n        counter = findMax(strs, 0, m, n)\\n        return counter\\n```\\n\\nThe knapsack solutions are inspired by [this post](https://leetcode.com/problems/ones-and-zeroes/discuss/95807/0-1-knapsack-detailed-explanation.). I take no credit for it.\\n\\n**Knapsack O(length * m * n) time, O(length * m * n) space [Accepted]**\\nWe allocate a list of size `length x m x n` to store all possibilities of subproblems with `m1` and `n1` up to `m` and `n`. The idea is the same as the recursive solution: if a string can be included in a solution, we have two options: use it or skip it.\\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(strs)\\n        dp = [[[0 for i in range(n+1)] for j in range(m+1)] for k in range(length+1)]\\n                    \\n        for i in range(1, length+1):\\n            s = strs[i-1]\\n            m1 = s.count(\\'0\\')\\n            n1 = s.count(\\'1\\')\\n            \\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    # this string can be used, so choose to use or skip\\n                    if j >= m1 and k >= n1:\\n                        dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-m1][k-n1]+1)\\n                    \\n                    # definitely cannot use this string\\n                    else:\\n                        dp[i][j][k] = dp[i-1][j][k]\\n        \\n        return dp[-1][-1][-1]\\n```\\n\\n**Knapsack O(length * m * n) time, O(mn) space [Accepted]**\\nThe difference between this version and the previous version is that we traverse the second and third loop backward from `m` to `m1` and `n` to `n1`. I also change how I calculate `m1` and `n1` because the `count()` method takes O(length(string)) time. \\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(strs)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        \\n        for s in strs:\\n            m1, n1 = 0, 0\\n            for ch in s:\\n                if ch == \\'0\\':\\n                    m1 += 1\\n                else:\\n                    n1 += 1\\n            \\n            for j in range(m, m1-1, -1):\\n                for k in range(n, n1-1, -1):\\n                    # can be used, so choose to use or skip\\n                    if j >= m1 and k >= n1:\\n                        dp[j][k] = max(dp[j][k], dp[j-m1][k-n1]+1)\\n        \\n        return dp[-1][-1] \\n```\\nAny suggestion for improvization is greatly welcome. Thanks.",
                "solutionTags": [],
                "code": "```strs[i]```\n```m1```\n```n1```\n```m1```\n```m```\n```n1```\n```n```\n```m```\n```m1```\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def findMax(strs, i, m, n):\\n            counter = 0\\n            if i <= len(strs)-1:                \\n                if m > 0 or n > 0:\\n                    # use it or skip it\\n                    m1 = strs[i].count(\\'0\\')\\n                    n1 = strs[i].count(\\'1\\')\\n                    use = 0\\n                    \\n                    # skip it\\n                    skip = findMax(strs, i+1, m, n)\\n                    \\n                    # use it\\n                    if m1 <= m and n1 <= n:\\n                        use = findMax(strs, i+1, m-m1, n-n1) + 1\\n                    \\n                    # update counter\\n                    counter = max(use, skip)\\n                                \\n            return counter\\n            \\n        counter = findMax(strs, 0, m, n)\\n        return counter\\n```\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.memo = {}\\n        def findMax(strs, i, m, n):\\n            if i <= len(strs)-1:\\n                if (i, m, n) in self.memo:\\n                    return self.memo[(i,m,n)]\\n                \\n                if m > 0 or n > 0:\\n                    # use it or skip it\\n                    m1 = strs[i].count(\\'0\\')\\n                    n1 = strs[i].count(\\'1\\')\\n                    use = 0\\n                    \\n                    # skip it\\n                    skip = findMax(strs, i+1, m, n)\\n                    \\n                    # use it\\n                    if m1 <= m and n1 <= n:\\n                        use = findMax(strs, i+1, m-m1, n-n1) + 1\\n                    \\n                    # update counter\\n                    counter = max(use, skip)\\n                    self.memo[(i,m,n)] = counter\\n                    \\n                    return self.memo[(i,m,n)]\\n            \\n            return 0\\n            \\n        counter = findMax(strs, 0, m, n)\\n        return counter\\n```\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(strs)\\n        dp = [[[0 for i in range(n+1)] for j in range(m+1)] for k in range(length+1)]\\n                    \\n        for i in range(1, length+1):\\n            s = strs[i-1]\\n            m1 = s.count(\\'0\\')\\n            n1 = s.count(\\'1\\')\\n            \\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    # this string can be used, so choose to use or skip\\n                    if j >= m1 and k >= n1:\\n                        dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-m1][k-n1]+1)\\n                    \\n                    # definitely cannot use this string\\n                    else:\\n                        dp[i][j][k] = dp[i-1][j][k]\\n        \\n        return dp[-1][-1][-1]\\n```\n```\\ndef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(strs)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        \\n        for s in strs:\\n            m1, n1 = 0, 0\\n            for ch in s:\\n                if ch == \\'0\\':\\n                    m1 += 1\\n                else:\\n                    n1 += 1\\n            \\n            for j in range(m, m1-1, -1):\\n                for k in range(n, n1-1, -1):\\n                    # can be used, so choose to use or skip\\n                    if j >= m1 and k >= n1:\\n                        dp[j][k] = max(dp[j][k], dp[j-m1][k-n1]+1)\\n        \\n        return dp[-1][-1] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95860,
                "title": "java-dp-solution-with-explanation",
                "content": "The idea is to build up the solution for 0..m zeros and 0..n ones, from only knowing 1 string, 2 strings, ..., up to n strings.\\n\\nFor example, for array = {\"10\", \"0\", \"1\"}, m = 1, n = 1.\\n\\n* for first string \"10\":\\n  * zero = 0, one = 0\\n  * zero = 1, one = 0\\n  * zero = 0, one = 1\\n  * zero = 1, one = 1, can form \"10\" [+1]\\n* continue on the second string \"0\", with previous knowledge of string \"10\":\\n  * zero = 0, one = 0\\n  * zero = 1, one = 0, can form \"0\" [+1]\\n  * zero = 0, one = 1\\n  * zero = 1, one = 1, can form \"0\" [+1] **or** 1 string (\"10\"), known from previous string\\n* continue on the last string \"1\", with previous knowledge of strings \"10\" and \"0\":\\n  * zero = 0, one = 0\\n  * zero = 1, one = 0, can't form \"1\", but we know it can form 1 string (\"0\") from previous set of strings\\n  * zero = 0, one = 1, can form \"1\" (+1)\\n  * zero = 1, one = 1, (can form \"1\" **and** 1 more string (\"0\") with zero = 1, one = 0, known from previous set of strings) or (1 string (\"10\"),  known from previous set of strings)\\n\\nHence, at the end, we know that with zero = 1, one = 1, with string \"10\", \"0\", and \"1\", the maximum number of strings we can form is 2.\\n\\n```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n    int[][] max = new int[m + 1][n + 1];\\n    for (int i = 0; i < strs.length; i++) {\\n        String str = strs[i];\\n        \\n        int neededZero = 0;\\n        int neededOne = 0;\\n        for (int j = 0; j < str.length(); j++) {\\n            if (str.charAt(j) == '0') {\\n                neededZero++;\\n            } else {\\n                neededOne++;\\n            }\\n        }\\n        \\n        int[][] newMax = new int[m + 1][n + 1];\\n        \\n        for (int zero = 0; zero <= m; zero++) {\\n            for (int one = 0; one <= n; one++) {\\n                if (zero >= neededZero && one >= neededOne) {\\n                    int zeroLeft = zero - neededZero;\\n                    int oneLeft = one - neededOne;\\n                    newMax[zero][one] = Math.max(1 + max[zeroLeft][oneLeft], max[zero][one]);\\n                } else {\\n                    newMax[zero][one] = max[zero][one];\\n                }\\n            }\\n        }\\n        \\n        max = newMax;\\n    }\\n    return max[m][n];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n    int[][] max = new int[m + 1][n + 1];\\n    for (int i = 0; i < strs.length; i++) {\\n        String str = strs[i];\\n        \\n        int neededZero = 0;\\n        int neededOne = 0;\\n        for (int j = 0; j < str.length(); j++) {\\n            if (str.charAt(j) == '0') {\\n                neededZero++;\\n            } else {\\n                neededOne++;\\n            }\\n        }\\n        \\n        int[][] newMax = new int[m + 1][n + 1];\\n        \\n        for (int zero = 0; zero <= m; zero++) {\\n            for (int one = 0; one <= n; one++) {\\n                if (zero >= neededZero && one >= neededOne) {\\n                    int zeroLeft = zero - neededZero;\\n                    int oneLeft = one - neededOne;\\n                    newMax[zero][one] = Math.max(1 + max[zeroLeft][oneLeft], max[zero][one]);\\n                } else {\\n                    newMax[zero][one] = max[zero][one];\\n                }\\n            }\\n        }\\n        \\n        max = newMax;\\n    }\\n    return max[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068639,
                "title": "intuition-for-dimension-reduction-3d-2d-and-bottom-right-to-top-left-filling-of-dp-table",
                "content": "Assume that we use a 3-dimensional array to keep track of our results.\\n```dp[i][j][k]``` represents the maximum length of subset you can get for at most j 0\\'s and k 1\\'s using the first i elements in the array strs.\\n\\nLet ```l``` be the length of the ```strs``` array, ```cz[i]``` represent the number of 0\\'s in the ith entry in strs and ```co[i]``` represent the number of 1\\'s in the ith entry in strs.\\n\\nIn this case, you can fill your dp table from top-left to bottom-right and the expression would look as such:\\n```\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = 0 ; j <= m ; j++) {\\n                for(int k = 0 ; k <= n ; k++) {\\n                    if(cz[i] <= j && co[i] <= k)\\n                    dp[i][j][k] = max(dp[i-1][j][k], 1+dp[i-1][j-cz[i]][k-co[i]]);\\n                    else dp[i][j][k] = dp[i-1][j][k];\\n                }\\n            }\\n        }\\n```\\nIf you look at the relation: \\n```\\ndp[i][j][k] = max(dp[i-1][j][k], 1+dp[i-1][j-cz[i]][k-co[i]]);\\n``` \\n, you can observe that for every ith dimension, we only look at results from the i-1 dimension. This is an opportunity for **dimension reduction**. Since our outermost loop is i, we can be sure that if we just use dp[j][k] instead of dp[i][j][k], the results available to us before we update the results in the ith iteration will be the results of the i-1th iteration. Another **important observation** is that in order to compute the result of j and k(for particular i), we always look at results lesser than equal to j (``` j-cz[i] ```), and lesser than equal to k (```k-co[i])```) and never greater or to the right of these.\\n\\nGreat, so we can just change the expression in our code and be done with it, right?\\n```\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = 0 ; j <= m ; j++) {\\n                for(int k = 0 ; k <= n ; k++) {\\n                    if(cz[i-1] <= j && co[i-1] <= k)\\n                    dp[j][k] = max(dp[j][k], 1+dp[j-cz[i]][k-co[i]]);\\n                }\\n            }\\n        }\\n```\\nWrong! This wouldn\\'t work and the reason is the order in which we fill up our table. We know that to compute the result of the ith iteration properly for all j and k, we need to have available to us the results of the i-1th iteration for indices <= j and <= k. If we fill up the table from top-left (0,0) to bottom-right(m,n), we will end up rewriting certain entries which might actually be needed for later computations.\\n\\nFor example, we might need the value of ```dp[i-1][1][1]``` to calculate ```dp[i][2][2]```, but in the above code, we will end up replacing ```dp[i-1][1][1]``` with ```dp[i][1][1]``` since we are not explicitly mentioning the ith dimension. This, in turn, will lead to the wrong computation of ```dp[i][2][2]```. To make sure that we do not change the required values from the previous i iteration, we fill the table from (m,n) to (0,0). This works because we know that we only need dimensions <=j and <=k from the i-th iteration to compute j and k in the ith iteration.\\n\\nFor example, if we replace ```dp[i-1][2][2]``` with ```dp[i][2][2]```, and then move to calculating ```dp[i][1][1]```, we can be sure that we will never need ```dp[i-1][2][2]``` for computing ```dp[i][1][1]```.\\n\\nTherefore, the final expression can be:\\n```\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = m ; j >= 0 ; j--) {\\n                for(int k = n ; k >= 0 ; k--) {\\n                    if(cz[i] <= j && co[i] <= k)\\n                    dp[j][k] = max(dp[j][k], 1+dp[j-cz[i]][k-co[i]]);\\n                }\\n            }\\n        }\\n```\\n\\nThe final code can be as such:\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l = strs.size();\\n        vector<int> cz(l+1, 0);\\n        vector<int> co(l+1, 0);\\n        int ind = 1;\\n        for(auto it: strs) {\\n            int count0 = 0;\\n            int count1 = 0;\\n            for(auto c: it) {\\n                if(c==\\'0\\') {\\n                    count0++;\\n                } else \\n                    count1++;\\n            }\\n            cz[ind] = count0;\\n            co[ind] = count1;\\n            ind++;\\n        }\\n\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = m ; j >= 0 ; j--) {\\n                for(int k = n ; k >= 0 ; k--) {\\n                    if(cz[i] <= j && co[i] <= k)\\n                    dp[j][k] = max(dp[j][k], 1+dp[j-cz[i]][k-co[i]]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nHope this helps :)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j][k]```\n```l```\n```strs```\n```cz[i]```\n```co[i]```\n```\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = 0 ; j <= m ; j++) {\\n                for(int k = 0 ; k <= n ; k++) {\\n                    if(cz[i] <= j && co[i] <= k)\\n                    dp[i][j][k] = max(dp[i-1][j][k], 1+dp[i-1][j-cz[i]][k-co[i]]);\\n                    else dp[i][j][k] = dp[i-1][j][k];\\n                }\\n            }\\n        }\\n```\n```\\ndp[i][j][k] = max(dp[i-1][j][k], 1+dp[i-1][j-cz[i]][k-co[i]]);\\n```\n``` j-cz[i] ```\n```k-co[i])```\n```\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = 0 ; j <= m ; j++) {\\n                for(int k = 0 ; k <= n ; k++) {\\n                    if(cz[i-1] <= j && co[i-1] <= k)\\n                    dp[j][k] = max(dp[j][k], 1+dp[j-cz[i]][k-co[i]]);\\n                }\\n            }\\n        }\\n```\n```dp[i-1][1][1]```\n```dp[i][2][2]```\n```dp[i-1][1][1]```\n```dp[i][1][1]```\n```dp[i][2][2]```\n```dp[i-1][2][2]```\n```dp[i][2][2]```\n```dp[i][1][1]```\n```dp[i-1][2][2]```\n```dp[i][1][1]```\n```\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = m ; j >= 0 ; j--) {\\n                for(int k = n ; k >= 0 ; k--) {\\n                    if(cz[i] <= j && co[i] <= k)\\n                    dp[j][k] = max(dp[j][k], 1+dp[j-cz[i]][k-co[i]]);\\n                }\\n            }\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l = strs.size();\\n        vector<int> cz(l+1, 0);\\n        vector<int> co(l+1, 0);\\n        int ind = 1;\\n        for(auto it: strs) {\\n            int count0 = 0;\\n            int count1 = 0;\\n            for(auto c: it) {\\n                if(c==\\'0\\') {\\n                    count0++;\\n                } else \\n                    count1++;\\n            }\\n            cz[ind] = count0;\\n            co[ind] = count1;\\n            ind++;\\n        }\\n\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int i = 1 ; i <= l ; i++) {\\n            for(int j = m ; j >= 0 ; j--) {\\n                for(int k = n ; k >= 0 ; k--) {\\n                    if(cz[i] <= j && co[i] <= k)\\n                    dp[j][k] = max(dp[j][k], 1+dp[j-cz[i]][k-co[i]]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066147,
                "title": "simple-c-code-dp-3-methods-tabulation-memoization",
                "content": "Method-1 : Memoization\\n\\nTime Complexity : O(m```*```n```*```sizeof(strs))\\nSpace Complexity : O(m```*```n```*```sizeof(strs))\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int fun(int i, int m, int n, vector<pair<int, int>>& v){\\n        if(i<0) return 0;\\n        if(dp[i][m][n]!=-1) return dp[i][m][n];\\n        if(m>=v[i].first && n>=v[i].second) return dp[i][m][n] = max(1+fun(i-1, m-v[i].first, n-v[i].second, v), fun(i-1, m, n, v));\\n        return dp[i][m][n] = fun(i-1, m, n, v);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        dp.resize(strs.size()+2, vector<vector<int>>(m+2, vector<int>(n+2, -1)));\\n        vector<pair<int, int>> v;\\n        for(string x : strs){\\n            int cnt = count(x.begin(), x.end(), \\'0\\');\\n            v.push_back({cnt, x.size()-cnt});\\n        }\\n        return fun(strs.size()-1, m, n, v);\\n    }\\n};\\n```\\n\\nMethod-2 : Tabulation\\n\\nTime Complexity : O(m```*```n```*```sizeof(strs))\\nSpace Complexity : O(m```*```n```*```sizeof(strs))\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pair<int, int>> v;\\n        for(string x : strs){\\n            int cnt = count(x.begin(), x.end(), \\'0\\');\\n            v.push_back({cnt, x.size()-cnt});\\n        }\\n        vector<vector<vector<int>>> dp(strs.size()+2, vector<vector<int>>(m+2, vector<int>(n+2, 0)));\\n        for(int i=0;i<=v.size();i++){\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    if(i==0) dp[i][j][k] = 0;\\n                    else if(j>=v[i-1].first && k>=v[i-1].second) dp[i][j][k] = max(dp[i-1][j][k], 1+dp[i-1][j-v[i-1].first][k-v[i-1].second]);\\n                    else dp[i][j][k] = dp[i-1][j][k];\\n                }\\n            }\\n        }\\n        return dp[v.size()][m][n];\\n    }\\n};\\n```\\n\\nMethod-3 (Most Efficient Approach)\\n\\nTime Complexity : O(m```*```n```*```sizeof(strs))\\nSpace Complexity : O(m```*```n))\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m+2, vector<int>(n+2, 0));\\n        vector<pair<int, int>> v;\\n        for(string x : strs){\\n            int cnt = count(x.begin(), x.end(), \\'0\\');\\n            v.push_back({cnt, x.size()-cnt});\\n        }\\n        for(auto pr : v){\\n            for(int i=m;i>=0;i--){\\n                for(int j=n;j>=0;j--){\\n                    if(i>=pr.first && j>=pr.second){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i-pr.first][j-pr.second]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```*```\n```*```\n```*```\n```*```\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int fun(int i, int m, int n, vector<pair<int, int>>& v){\\n        if(i<0) return 0;\\n        if(dp[i][m][n]!=-1) return dp[i][m][n];\\n        if(m>=v[i].first && n>=v[i].second) return dp[i][m][n] = max(1+fun(i-1, m-v[i].first, n-v[i].second, v), fun(i-1, m, n, v));\\n        return dp[i][m][n] = fun(i-1, m, n, v);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        dp.resize(strs.size()+2, vector<vector<int>>(m+2, vector<int>(n+2, -1)));\\n        vector<pair<int, int>> v;\\n        for(string x : strs){\\n            int cnt = count(x.begin(), x.end(), \\'0\\');\\n            v.push_back({cnt, x.size()-cnt});\\n        }\\n        return fun(strs.size()-1, m, n, v);\\n    }\\n};\\n```\n```*```\n```*```\n```*```\n```*```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pair<int, int>> v;\\n        for(string x : strs){\\n            int cnt = count(x.begin(), x.end(), \\'0\\');\\n            v.push_back({cnt, x.size()-cnt});\\n        }\\n        vector<vector<vector<int>>> dp(strs.size()+2, vector<vector<int>>(m+2, vector<int>(n+2, 0)));\\n        for(int i=0;i<=v.size();i++){\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    if(i==0) dp[i][j][k] = 0;\\n                    else if(j>=v[i-1].first && k>=v[i-1].second) dp[i][j][k] = max(dp[i-1][j][k], 1+dp[i-1][j-v[i-1].first][k-v[i-1].second]);\\n                    else dp[i][j][k] = dp[i-1][j][k];\\n                }\\n            }\\n        }\\n        return dp[v.size()][m][n];\\n    }\\n};\\n```\n```*```\n```*```\n```*```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m+2, vector<int>(n+2, 0));\\n        vector<pair<int, int>> v;\\n        for(string x : strs){\\n            int cnt = count(x.begin(), x.end(), \\'0\\');\\n            v.push_back({cnt, x.size()-cnt});\\n        }\\n        for(auto pr : v){\\n            for(int i=m;i>=0;i--){\\n                for(int j=n;j>=0;j--){\\n                    if(i>=pr.first && j>=pr.second){\\n                        dp[i][j] = max(dp[i][j], 1+dp[i-pr.first][j-pr.second]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819076,
                "title": "c-dp-solution-from-recursion-to-memoization-to-bottom-up-to-knapsack",
                "content": "**Let\\'s Understand the question**\\nwe are given a vector of binary strings and and 2 variables m and n representing the max. no. of one\\'s and zero\\'s we can have in our subset\\n\\nwe need to form a subset which contains atmost m 0\\'s and n 1\\'s of largest size\\n\\n**by largest size we mean the no. of strings added together not the length of the subset formed**\\n\\n**brute Force**  gives TLE\\n\\nfor every string we have 2 options either to pick them or not(just like any subsequence problem)\\nbut here we will do that under a condition that the count of 1\\'s and 0\\'s in the subset should be within n and m respectively\\n\\n```\\n//RECURSION  TC-O(2^R)  SC-O(N)\\n    int recursive(int r,int m,int n,vector<string>& strs)\\n    {\\n        int zero=0,one=0;\\n        for(int i=0;i<strs[r].size();i++)  //counting 1\\'s and 0\\'s for each string\\n        {\\n            if(strs[r][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        if(r==0)\\n        {\\n            if(m-zero>=0 && n-one>=0)  return 1;\\n            return 0;\\n        }\\n        \\n        \\n        int notPick = recursive(r-1,m,n,strs);\\n        int pick = INT_MIN;\\n        \\n        if(m-zero>=0 && n-one>=0)\\n            pick = recursive(r-1,m-zero,n-one,strs) + 1;\\n        return max(pick,notPick);\\n    }\\n```\\n\\nwe  can definitely optimize it using memoization\\n\\nsince we have 3 changing parameters, we will have a 3D dp array\\n\\n\\n```\\n//MEMOIZATION  TC-O(R*M*N)  SC-O(R*M*N) + O(N)\\n    \\n    int memoize(int r,int m,int n,vector<string>& strs,vector<vector<vector<int>>> &dp)\\n    {\\n        int zero=0,one=0;\\n        for(int i=0;i<strs[r].size();i++)  //counting 1\\'s and 0\\'s\\n        {\\n            if(strs[r][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        if(r==0)\\n        {\\n            if(m-zero>=0 && n-one>=0)  return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[r][m][n]!=-1)\\n            return dp[r][m][n];\\n        \\n        int notPick = memoize(r-1,m,n,strs,dp);\\n        int pick = INT_MIN;\\n        if(m-zero>=0 && n-one>=0)\\n            pick = memoize(r-1,m-zero,n-one,strs,dp) + 1;\\n        return dp[r][m][n] = max(pick,notPick);\\n    }\\n```\\n\\n\\n**BOTTOM UP APPROACH**\\n\\nwe can avoid the extra stack space used for recursion by using BOTTOM-UP approach\\n\\nwe always start from the base case in BOTTOM-UP\\n\\nfor index 0 the dp array will contain the value 1 for all the combinations of m and n for the condition  **(m-zero>=0 && n-one>=0)**\\n\\n```\\n//TABULATION  TC--O(R*M*N)   SC--O(R*M*N)\\n    \\n    int tabulate(int M,int N,vector<string>& strs)\\n    {\\n        int size = strs.size();\\n        vector<vector<vector<int>>> dp(size,vector<vector<int>>(M+1,vector<int>(N+1,0)));\\n        \\n        int zero=0,one=0;\\n        \\n        for(int i=0;i<strs[0].size();i++) //count of 0 and 1 for first index\\n        {\\n            if(strs[0][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        //base case\\n        for(int i=zero;i<=M;i++)\\n        {\\n            for(int j=one;j<=N;j++)\\n                dp[0][i][j]=1;\\n        }\\n        \\n        \\n        for(int r=1;r<size;r++)\\n        {\\n            zero=0,one=0; //counting 0 and 1 for string\\n            for(int i=0;i<strs[r].size();i++)\\n            {\\n                if(strs[r][i]==\\'0\\') zero++;\\n                else one++;\\n            }\\n            \\n            for(int m=0;m<=M;m++)  //loop for zero balance\\n            {\\n                for(int n=0;n<=N;n++)  //loop for one balance\\n                {\\n                    int notPick = dp[r-1][m][n];\\n                    int pick = INT_MIN;\\n                    if(m-zero>=0 && n-one>=0)\\n                        pick = dp[r-1][m-zero][n-one] + 1;\\n                    dp[r][m][n] = max(pick,notPick);\\n                }\\n            }\\n        }\\n        return dp[size-1][M][N];\\n    }\\n```\\n\\n\\nwe can further optimize the space to O(M*N) by simple observation\\n\\nwe can see that we are always using the values of the previous row, so instead of carrying the values of all the row ,we can only have 2 rows to maintain the values of the current and previous row\\nand pass the value of curr row to previous row after each iteration\\n\\n```\\n//SPACE OPTIMIZATION  TC-O(R*M*N)  SC-O(M*N)\\n    \\n    int spaceOptimized(int M,int N,vector<string>& strs)\\n    {\\n        int size = strs.size();\\n        vector<vector<int>> dp(M+1,vector<int>(N+1,0));\\n        \\n        int zero=0,one=0;\\n        for(int i=0;i<strs[0].size();i++) //count of 0 and 1 for first index\\n        {\\n            if(strs[0][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        //base case\\n        for(int i=zero;i<=M;i++)\\n        {\\n            for(int j=one;j<=N;j++)\\n                dp[i][j]=1;\\n        }\\n        \\n        \\n        for(int r=1;r<size;r++)\\n        {\\n            \\n            vector<vector<int>> temp(M+1,vector<int>(N+1,0));\\n            zero=0,one=0; //counting 0 and 1 for string\\n            for(int i=0;i<strs[r].size();i++)\\n            {\\n                if(strs[r][i]==\\'0\\') zero++;\\n                else one++;\\n            }\\n            \\n            for(int m=0;m<=M;m++)  //loop for zero balance\\n            {\\n                for(int n=0;n<=N;n++)  //loop for one balance\\n                {\\n                    int notPick = dp[m][n];\\n                    int pick = INT_MIN;\\n                    if(m-zero>=0 && n-one>=0)\\n                        pick = dp[m-zero][n-one] + 1;\\n                    temp[m][n] = max(pick,notPick);\\n                }\\n            }\\n            dp=temp;  //passing the curr row to dp\\n        }\\n        return dp[M][N];   \\n    }\\n```\\n\\n\\n**KNAPSACK**\\n\\nafter further observations we can also see that instead of using 2 rows we can simply can 1 vector to perform the task as the question falls under KNAPSACK category\\n\\n```\\n//KNAPSACK  TC--O(R*M*N)  SC-O(M*N)\\n    \\n    int knapsack(int M,int N,vector<string>& strs)\\n    {\\n        int size = strs.size();\\n        vector<vector<int>> dp(M+1,vector<int>(N+1,0));\\n        \\n        int zero=0,one=0;\\n        \\n        for(int i=0;i<strs[0].size();i++) //count of 0 and 1 for first index\\n        {\\n            if(strs[0][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        //base case\\n        for(int i=zero;i<=M;i++)\\n        {\\n            for(int j=one;j<=N;j++)\\n                dp[i][j]=1;\\n        }\\n        \\n        \\n        for(int r=1;r<size;r++)\\n        {\\n            zero=0,one=0; //counting 0 and 1 for string\\n            for(int i=0;i<strs[r].size();i++)\\n            {\\n                if(strs[r][i]==\\'0\\') zero++;\\n                else one++;\\n            }\\n            \\n            for(int m=M;m>=0;m--)  //loop for zero balance\\n            {\\n                for(int n=N;n>=0;n--)  //loop for one balance\\n                {\\n                    int notPick = dp[m][n];\\n                    int pick = INT_MIN;\\n                    if(m-zero>=0 && n-one>=0)\\n                        pick = dp[m-zero][n-one] + 1;\\n                    dp[m][n] = max(pick,notPick);\\n                }\\n            }\\n        }\\n        return dp[M][N];   \\n    }\\n```\\n\\n**PLEASE DO GIVE A REVIEW AND SUGGEST ME FOR FURTHER CODE OPTIMIZATION**\\n**AND PLEASE UPVOTE**\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n//RECURSION  TC-O(2^R)  SC-O(N)\\n    int recursive(int r,int m,int n,vector<string>& strs)\\n    {\\n        int zero=0,one=0;\\n        for(int i=0;i<strs[r].size();i++)  //counting 1\\'s and 0\\'s for each string\\n        {\\n            if(strs[r][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        if(r==0)\\n        {\\n            if(m-zero>=0 && n-one>=0)  return 1;\\n            return 0;\\n        }\\n        \\n        \\n        int notPick = recursive(r-1,m,n,strs);\\n        int pick = INT_MIN;\\n        \\n        if(m-zero>=0 && n-one>=0)\\n            pick = recursive(r-1,m-zero,n-one,strs) + 1;\\n        return max(pick,notPick);\\n    }\\n```\n```\\n//MEMOIZATION  TC-O(R*M*N)  SC-O(R*M*N) + O(N)\\n    \\n    int memoize(int r,int m,int n,vector<string>& strs,vector<vector<vector<int>>> &dp)\\n    {\\n        int zero=0,one=0;\\n        for(int i=0;i<strs[r].size();i++)  //counting 1\\'s and 0\\'s\\n        {\\n            if(strs[r][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        if(r==0)\\n        {\\n            if(m-zero>=0 && n-one>=0)  return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[r][m][n]!=-1)\\n            return dp[r][m][n];\\n        \\n        int notPick = memoize(r-1,m,n,strs,dp);\\n        int pick = INT_MIN;\\n        if(m-zero>=0 && n-one>=0)\\n            pick = memoize(r-1,m-zero,n-one,strs,dp) + 1;\\n        return dp[r][m][n] = max(pick,notPick);\\n    }\\n```\n```\\n//TABULATION  TC--O(R*M*N)   SC--O(R*M*N)\\n    \\n    int tabulate(int M,int N,vector<string>& strs)\\n    {\\n        int size = strs.size();\\n        vector<vector<vector<int>>> dp(size,vector<vector<int>>(M+1,vector<int>(N+1,0)));\\n        \\n        int zero=0,one=0;\\n        \\n        for(int i=0;i<strs[0].size();i++) //count of 0 and 1 for first index\\n        {\\n            if(strs[0][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        //base case\\n        for(int i=zero;i<=M;i++)\\n        {\\n            for(int j=one;j<=N;j++)\\n                dp[0][i][j]=1;\\n        }\\n        \\n        \\n        for(int r=1;r<size;r++)\\n        {\\n            zero=0,one=0; //counting 0 and 1 for string\\n            for(int i=0;i<strs[r].size();i++)\\n            {\\n                if(strs[r][i]==\\'0\\') zero++;\\n                else one++;\\n            }\\n            \\n            for(int m=0;m<=M;m++)  //loop for zero balance\\n            {\\n                for(int n=0;n<=N;n++)  //loop for one balance\\n                {\\n                    int notPick = dp[r-1][m][n];\\n                    int pick = INT_MIN;\\n                    if(m-zero>=0 && n-one>=0)\\n                        pick = dp[r-1][m-zero][n-one] + 1;\\n                    dp[r][m][n] = max(pick,notPick);\\n                }\\n            }\\n        }\\n        return dp[size-1][M][N];\\n    }\\n```\n```\\n//SPACE OPTIMIZATION  TC-O(R*M*N)  SC-O(M*N)\\n    \\n    int spaceOptimized(int M,int N,vector<string>& strs)\\n    {\\n        int size = strs.size();\\n        vector<vector<int>> dp(M+1,vector<int>(N+1,0));\\n        \\n        int zero=0,one=0;\\n        for(int i=0;i<strs[0].size();i++) //count of 0 and 1 for first index\\n        {\\n            if(strs[0][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        //base case\\n        for(int i=zero;i<=M;i++)\\n        {\\n            for(int j=one;j<=N;j++)\\n                dp[i][j]=1;\\n        }\\n        \\n        \\n        for(int r=1;r<size;r++)\\n        {\\n            \\n            vector<vector<int>> temp(M+1,vector<int>(N+1,0));\\n            zero=0,one=0; //counting 0 and 1 for string\\n            for(int i=0;i<strs[r].size();i++)\\n            {\\n                if(strs[r][i]==\\'0\\') zero++;\\n                else one++;\\n            }\\n            \\n            for(int m=0;m<=M;m++)  //loop for zero balance\\n            {\\n                for(int n=0;n<=N;n++)  //loop for one balance\\n                {\\n                    int notPick = dp[m][n];\\n                    int pick = INT_MIN;\\n                    if(m-zero>=0 && n-one>=0)\\n                        pick = dp[m-zero][n-one] + 1;\\n                    temp[m][n] = max(pick,notPick);\\n                }\\n            }\\n            dp=temp;  //passing the curr row to dp\\n        }\\n        return dp[M][N];   \\n    }\\n```\n```\\n//KNAPSACK  TC--O(R*M*N)  SC-O(M*N)\\n    \\n    int knapsack(int M,int N,vector<string>& strs)\\n    {\\n        int size = strs.size();\\n        vector<vector<int>> dp(M+1,vector<int>(N+1,0));\\n        \\n        int zero=0,one=0;\\n        \\n        for(int i=0;i<strs[0].size();i++) //count of 0 and 1 for first index\\n        {\\n            if(strs[0][i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        //base case\\n        for(int i=zero;i<=M;i++)\\n        {\\n            for(int j=one;j<=N;j++)\\n                dp[i][j]=1;\\n        }\\n        \\n        \\n        for(int r=1;r<size;r++)\\n        {\\n            zero=0,one=0; //counting 0 and 1 for string\\n            for(int i=0;i<strs[r].size();i++)\\n            {\\n                if(strs[r][i]==\\'0\\') zero++;\\n                else one++;\\n            }\\n            \\n            for(int m=M;m>=0;m--)  //loop for zero balance\\n            {\\n                for(int n=N;n>=0;n--)  //loop for one balance\\n                {\\n                    int notPick = dp[m][n];\\n                    int pick = INT_MIN;\\n                    if(m-zero>=0 && n-one>=0)\\n                        pick = dp[m-zero][n-one] + 1;\\n                    dp[m][n] = max(pick,notPick);\\n                }\\n            }\\n        }\\n        return dp[M][N];   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138544,
                "title": "help-why-is-10-invalid-in-the-sample-test-from-description",
                "content": "The sample test shows - \\n```\\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n```\\n\\n\"10\" fits the criteria of *zeroCount = 1, oneCount = 1*. \\nThen why is the correct answer 2 and not 3? Am i missing anything here?",
                "solutionTags": [],
                "code": "```\\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065495,
                "title": "recursive-simple-solution-like-0-1-knapsack",
                "content": "class Solution {\\npublic:\\n\\n    vector<string> v;//dummy vector\\n    int t[601][101][101];//memoization array\\n    \\n    int rec(int k,int m,int n){\\n        if(k<=0||(m<=0&&n<=0))return 0;//Base Condition.\\n        if(t[k][m][n]) return t[k][m][n];\\n        string s=v[k-1];\\n        int cnt0=0,cnt1=0;//count of 0s and 1s in string.\\n        for(auto i:s){\\n            if(i==\\'0\\')cnt0++;\\n            else cnt1++;\\n        }\\n        if(cnt0>m||cnt1>n) return t[k][m][n]=rec(k-1,m,n);//recursion call if one or both the parameters are small.\\n        return t[k][m][n]=max(rec(k-1,m,n),1+rec(k-1,m-cnt0,n-cnt1));//recursion call for finding maximum count.\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        v=strs;\\n        return rec(v.size(),m,n);\\n    }\\n    //Please Upvote if u like the solution\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> v;//dummy vector\\n    int t[601][101][101];//memoization array\\n    \\n    int rec(int k,int m,int n){\\n        if(k<=0||(m<=0&&n<=0))return 0;//Base Condition.\\n        if(t[k][m][n]) return t[k][m][n];\\n        string s=v[k-1];\\n        int cnt0=0,cnt1=0;//count of 0s and 1s in string.\\n        for(auto i:s){\\n            if(i==\\'0\\')cnt0++;\\n            else cnt1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1139036,
                "title": "python-top-down-dp-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1:  Top Down DP**\\n- Let `dp(i, m, n)` is the largest subset of `strs[i:]` such that there are at most `m` 0\\'s and `n` 1\\'s in the subset.\\n```python\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        cnt = [[s.count(\\'0\\'), s.count(\\'1\\')] for s in strs]\\n        \\n        @lru_cache(None)\\n        def dp(i, m, n):\\n            if i == len(strs):\\n                return 0\\n            \\n            ans = dp(i+1, m, n) # Skip strs[i]\\n            if m >= cnt[i][0] and n >= cnt[i][1]:\\n                ans = max(ans, dp(i+1, m-cnt[i][0], n-cnt[i][1]) + 1)  # Pick strs[i]\\n            return ans\\n        \\n        return dp(0, m, n)\\n```\\nComplexity:\\n- Time: `O(L * M * N)`, where `L <= 600` is length of `strs`, `M, N <= 100`\\n- Space: `O(L * M * N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        cnt = [[s.count(\\'0\\'), s.count(\\'1\\')] for s in strs]\\n        \\n        @lru_cache(None)\\n        def dp(i, m, n):\\n            if i == len(strs):\\n                return 0\\n            \\n            ans = dp(i+1, m, n) # Skip strs[i]\\n            if m >= cnt[i][0] and n >= cnt[i][1]:\\n                ans = max(ans, dp(i+1, m-cnt[i][0], n-cnt[i][1]) + 1)  # Pick strs[i]\\n            return ans\\n        \\n        return dp(0, m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824896,
                "title": "java-memoization-easy-to-understand",
                "content": "For every position in the string array we have two possible option either to take the string and update our remaining zeros and ones or to skip it and go to the next position . We traverse both the ways and check which one gives the maximum number .\\n```\\nclass Solution {\\n\\n    Map<String,Integer> map;\\n    public int findMaxForm(String[] strs, int m, int n) {\\n\\t\\n        if(strs.length == 0 || strs == null)return 0;\\n        map = new HashMap();\\n\\t\\t\\n        return max(strs,m,n,0);\\n    }\\n    \\n    public int max(String[] strs, int m ,int n,int index){\\n\\t// If we are done with the our remaining zeros and ones return 0 as we cant get any furtherr strings.\\n        if(m == 0 && n == 0){\\n            return 0;\\n        }\\n        if(index >= strs.length)return 0;\\n\\t\\t\\n        String key = m+\"->\"+n+\"->\"+index;\\n\\t\\t\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n\\t\\t\\n        int totalCount = 0;\\n\\t\\t//For the current index count the required number of zeros and ones .\\n\\t\\t\\n        String curr = strs[index];\\n        int ones = 0,zeros = 0;\\n\\t\\t\\n        for(char c:curr.toCharArray()){\\n            if(c == \\'0\\')zeros++;\\n            else{\\n                ones++;\\n            }\\n          }\\n        int takenStringCount = 0;\\n\\t\\t\\n\\t\\t// if we have the  required number of zeros and ones  we take the current string and update the \\n\\t\\t// remaining zeros and ones and go to the next index;\\n\\t\\t\\n        if(ones <= n && zeros <= m){\\n                takenStringCount = 1 + max(strs,m-zeros,n-ones,index+1);\\n        }\\n\\t\\t// For every position we also the option to skip the current string ;\\n\\t\\t\\n        int skippedStringNumber = max(strs,m,n,index+1);\\n\\t\\t// We take the max of both the possible ways to get the maximum string which we can make .\\n\\t\\t\\n        totalCount = Math.max(skippedStringNumber,takenStringCount);\\n\\t\\t\\n        map.put(key,totalCount);\\n        return totalCount;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    Map<String,Integer> map;\\n    public int findMaxForm(String[] strs, int m, int n) {\\n\\t\\n        if(strs.length == 0 || strs == null)return 0;\\n        map = new HashMap();\\n\\t\\t\\n        return max(strs,m,n,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 755576,
                "title": "java-dp-knapsack",
                "content": "```\\n    public int findMaxForm(String[] ss, int m, int n) {\\n        int l = ss.length, dp[][] = new int[m + 1][n + 1];\\n        for (String s : ss) {\\n            int one = 0, zero = 0;\\n            for (char c : s.toCharArray()) {\\n                if (c == \\'1\\') one++;\\n                else zero++;\\n            }\\n            for (int i = m; i >= zero; i--) {\\n                for (int j = n; j >= one; j--) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findMaxForm(String[] ss, int m, int n) {\\n        int l = ss.length, dp[][] = new int[m + 1][n + 1];\\n        for (String s : ss) {\\n            int one = 0, zero = 0;\\n            for (char c : s.toCharArray()) {\\n                if (c == \\'1\\') one++;\\n                else zero++;\\n            }\\n            for (int i = m; i >= zero; i--) {\\n                for (int j = n; j >= one; j--) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 445762,
                "title": "python-simple-dp-solution-with-explanation",
                "content": "Define `dp(m, n)` as the maximum number of strings that we can form with given `m` 0s and `n` 1s.\\nWe\\'ll get the recursion below:\\n`dp(m + m_i, n + n_i) = max(dp(m, n) + 1, dp(m + m_i, n + n_i))`\\nPlease note that `m_i` and `n_i` are 0s and 1s of the i-th string in `strs` respectively.\\n\\n```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\t    # Preprocessing to count 0s and 1s in strings.\\n        strs = [(s.count(\\'0\\'), s.count(\\'1\\')) for s in strs]\\n\\t\\t\\n        dp = defaultdict(int)\\n\\t\\t# we cannot form any string without 0 and 1.\\n        dp[0, 0] = 0\\n        for a0, a1 in strs:\\n            for (b0, b1), count in list(dp.items()):\\n                if a0 + b0 <= m and a1 + b1 <= n:\\n                    key = (a0 + b0, a1 + b1)\\n                    dp[key] = max(count + 1, dp[key])\\n        return max(dp.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\t    # Preprocessing to count 0s and 1s in strings.\\n        strs = [(s.count(\\'0\\'), s.count(\\'1\\')) for s in strs]\\n\\t\\t\\n        dp = defaultdict(int)\\n\\t\\t# we cannot form any string without 0 and 1.\\n        dp[0, 0] = 0\\n        for a0, a1 in strs:\\n            for (b0, b1), count in list(dp.items()):\\n                if a0 + b0 <= m and a1 + b1 <= n:\\n                    key = (a0 + b0, a1 + b1)\\n                    dp[key] = max(count + 1, dp[key])\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139815,
                "title": "java-simple-and-easy-to-understand-dp-solution-s-n-2-clean-code-with-comments",
                "content": "****\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] dp = new int[m + 1][n + 1];\\n        \\n        for(String str : strs){\\n            //count of onees and zeors for this string\\n            int[]count = getCount(str);\\n            \\n            for(int zeroes = m; zeroes >= count[0]; zeroes--){\\n                for(int ones = n; ones >= count[1]; ones--){\\n                    \\n                    //update the current subset length,\\n                    //find the maximum subsets length, when consider current element or when we donn\\'t consider\\n                    dp[zeroes][ones] = Math.max(dp[zeroes][ones], 1 + dp[zeroes - count[0]][ones - count[1]]);\\n                }  \\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    \\n\\n    \\n    private int[] getCount(String str){\\n        int[] count = new int[2];\\n        \\n        //count zeroes and ones of current string\\n        for(char c : str.toCharArray()){\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] dp = new int[m + 1][n + 1];\\n        \\n        for(String str : strs){\\n            //count of onees and zeors for this string\\n            int[]count = getCount(str);\\n            \\n            for(int zeroes = m; zeroes >= count[0]; zeroes--){\\n                for(int ones = n; ones >= count[1]; ones--){\\n                    \\n                    //update the current subset length,\\n                    //find the maximum subsets length, when consider current element or when we donn\\'t consider\\n                    dp[zeroes][ones] = Math.max(dp[zeroes][ones], 1 + dp[zeroes - count[0]][ones - count[1]]);\\n                }  \\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    \\n\\n    \\n    private int[] getCount(String str){\\n        int[] count = new int[2];\\n        \\n        //count zeroes and ones of current string\\n        for(char c : str.toCharArray()){\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054913,
                "title": "easy-to-understand-faster-simple-memoization-python-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        weights = []\\n        for st in strs:\\n            counter = Counter(st)\\n            weights.append((counter.get(\"0\", 0), counter.get(\"1\", 0)))\\n        self.visited = {}\\n        return self.recursiveWithMemo(strs, weights, len(strs) - 1, (m, n))\\n    \\n    # Brute Force Recursive Solution\\n    def recursiveWithoutMemo(self, strs, weights, index, wt):\\n        if wt == (0, 0) or index < 0: return 0\\n        else:\\n            curr = weights[index]\\n            if curr[0] <= wt[0] and curr[1] <= wt[1]:\\n                return max(\\n                    1 + self.recursiveWithoutMemo(strs, weights, index - 1, (wt[0] - curr[0], wt[1] - curr[1])),\\n                    self.recursiveWithoutMemo(strs, weights, index - 1, wt)\\n                )\\n            else:\\n                return self.recursiveWithoutMemo(strs, weights, index - 1, wt)\\n    # Top Down Approach DP        \\n    def recursiveWithMemo(self, strs, weights, index, wt):\\n        if wt == (0, 0) or index < 0: return 0\\n        if (index, wt) in self.visited: return self.visited[(index, wt)]\\n        else:\\n            curr = weights[index]\\n            if curr[0] <= wt[0] and curr[1] <= wt[1]:\\n                self.visited[(index, wt)] = max(\\n                    1 + self.recursiveWithMemo(strs, weights, index - 1, (wt[0] - curr[0], wt[1] - curr[1])),\\n                    self.recursiveWithMemo(strs, weights, index - 1, wt)\\n                )\\n            else:\\n                self.visited[(index, wt)] = self.recursiveWithMemo(strs, weights, index - 1, wt)\\n            return self.visited[(index, wt)]\\n                \\n                \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        weights = []\\n        for st in strs:\\n            counter = Counter(st)\\n            weights.append((counter.get(\"0\", 0), counter.get(\"1\", 0)))\\n        self.visited = {}\\n        return self.recursiveWithMemo(strs, weights, len(strs) - 1, (m, n))\\n    \\n    # Brute Force Recursive Solution\\n    def recursiveWithoutMemo(self, strs, weights, index, wt):\\n        if wt == (0, 0) or index < 0: return 0\\n        else:\\n            curr = weights[index]\\n            if curr[0] <= wt[0] and curr[1] <= wt[1]:\\n                return max(\\n                    1 + self.recursiveWithoutMemo(strs, weights, index - 1, (wt[0] - curr[0], wt[1] - curr[1])),\\n                    self.recursiveWithoutMemo(strs, weights, index - 1, wt)\\n                )\\n            else:\\n                return self.recursiveWithoutMemo(strs, weights, index - 1, wt)\\n    # Top Down Approach DP        \\n    def recursiveWithMemo(self, strs, weights, index, wt):\\n        if wt == (0, 0) or index < 0: return 0\\n        if (index, wt) in self.visited: return self.visited[(index, wt)]\\n        else:\\n            curr = weights[index]\\n            if curr[0] <= wt[0] and curr[1] <= wt[1]:\\n                self.visited[(index, wt)] = max(\\n                    1 + self.recursiveWithMemo(strs, weights, index - 1, (wt[0] - curr[0], wt[1] - curr[1])),\\n                    self.recursiveWithMemo(strs, weights, index - 1, wt)\\n                )\\n            else:\\n                self.visited[(index, wt)] = self.recursiveWithMemo(strs, weights, index - 1, wt)\\n            return self.visited[(index, wt)]\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 744393,
                "title": "rust-dynamic-programming",
                "content": "```Rust\\nimpl Solution {\\n    pub fn find_max_form(strs: Vec<String>, m: i32, n: i32) -> i32 {\\n        let mut dp = vec![vec![0; n as usize + 1]; m as usize + 1];\\n\\n        for s in strs {\\n            let zeros = s.chars().filter(|&c| c == \\'0\\').count();\\n            let ones = s.chars().filter(|&c| c == \\'1\\').count();\\n            for i in (zeros..=(m as usize)).rev() {\\n                for j in (ones..=(n as usize)).rev() {\\n                    dp[i][j] = dp[i][j].max(1 + dp[i - zeros][j - ones]);\\n                }\\n            }\\n        }\\n\\n        dp[m as usize][n as usize]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn find_max_form(strs: Vec<String>, m: i32, n: i32) -> i32 {\\n        let mut dp = vec![vec![0; n as usize + 1]; m as usize + 1];\\n\\n        for s in strs {\\n            let zeros = s.chars().filter(|&c| c == \\'0\\').count();\\n            let ones = s.chars().filter(|&c| c == \\'1\\').count();\\n            for i in (zeros..=(m as usize)).rev() {\\n                for j in (ones..=(n as usize)).rev() {\\n                    dp[i][j] = dp[i][j].max(1 + dp[i - zeros][j - ones]);\\n                }\\n            }\\n        }\\n\\n        dp[m as usize][n as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95863,
                "title": "java-memoization-and-accepted-dp-solutions-with-explanations",
                "content": "Hi there! I am sharing explanation of my solution. In the problem what matters is the number of zeros and ones in each string. Therefore the first thing we have to do, is to turn the array of string into array of pairs. The ith pair contains number of zeros  and ones in ith string. Next step is to determine how many pairs from the array we can cover by m and n;\\n``` ```The strightforward idea is backtracking. So we can just try out covering strings starting from different positions and maximize the result. Implementation of this idea is written below:\\n\\n```\\npublic class Solution {\\n    Integer memo[][][];\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs == null || strs.length == 0 || (m == 0 && n == 0)) return 0;\\n        memo = new Integer[m+1][n+1][strs.length];\\n        int [][] pairs = new int[strs.length][2];\\n        for(int i = 0;i<strs.length;i++){\\n            for(int j = 0;j<strs[i].length();j++){\\n                char ch  = strs[i].charAt(j);\\n                if(ch == '0') pairs[i][0]++;\\n                else pairs[i][1]++;\\n            }\\n        }\\n        return go(pairs, 0, m, n);\\n    }\\n    \\n    public int go(int pairs[][], int s, int m, int n){\\n        if(s >= pairs.length) return 0;\\n        if(memo[m][n][s] != null) return memo[m][n][s];\\n        int count = 0;\\n        for(int i = s;i<pairs.length;i++){\\n            int dm = m - pairs[i][0];\\n            int dn = n - pairs[i][1];\\n            if(dm >= 0 && dn >=0) {\\n                count = Math.max(count, 1+go(pairs, i+1, dm, dn));\\n            }\\n        }\\n        memo[m][n][s] = count;\\n        return count;\\n    }\\n} \\n\\n```\\nThis top to down approach solution gets TLE at 51/56 test. But I think this approach could be accepted in an interview. \\n```  ```  My second solution uses bottom-up algorithm (DP). But pursues the same thinking approach. \\n```  ```  A state of my DP (int i, int numOfZeros, int numOfOnes) describes the maximum number of strings we can construct starting from index 'i' by having numOfZeros zeros and numOfOnes ones.\\n   There are two simple transition functions from upper state to lower state. \\n* First transition is skipping the ith string and just taking the maximum value we can construct starting from i-1 th string. \\n* Second transition is constructing current string (ith string) then adding maximum number of strings that can be constructed starting from i-1 th string by the rest of ones and zeros (numOfZeros - pair[i][0] and numOfOnes-pair[i][1]). \\n\\nThe value for the current state is the maximum of values of the two transaction. Finally the answer is the value of state that describes the number of strings that can be constructed starting from the last(or the first,actually does not matter) index of the input string by m zeros and n ones. In other words just return dp[strs.length-1][m][n];\\n\\n```\\npublic class Solution {\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs == null || strs.length == 0 || (m == 0 && n == 0)) return 0;\\n        int dp [][][] = new int[strs.length][m+1][n+1];\\n        int [][] pairs = new int[strs.length][2];\\n        for(int i = 0;i<strs.length;i++){\\n            for(int j = 0;j<strs[i].length();j++){\\n                char ch  = strs[i].charAt(j);\\n                if(ch == '0') pairs[i][0]++;\\n                else pairs[i][1]++;\\n            }\\n        }\\n        for(int zeros =  pairs[0][0];zeros<=m;zeros++){\\n               for(int ones = pairs[0][1];ones<=n;ones++){\\n                   dp[0][zeros][ones] = 1;\\n               }\\n        } \\n        for(int i  = 1;i<strs.length;i++){\\n           for(int zeros =  0;zeros<=m;zeros++){\\n               for(int ones = 0;ones<=n;ones++){\\n                   dp[i][zeros][ones] = dp[i-1][zeros][ones];\\n               }\\n           }\\n           for(int zeros =  pairs[i][0];zeros<=m;zeros++){\\n               for(int ones = pairs[i][1];ones<=n;ones++){\\n                   dp[i][zeros][ones] = Math.max(dp[i-1][zeros][ones], 1+dp[i-1][zeros-pairs[i][0]][ones-pairs[i][1]]);\\n               }\\n           }\\n        }\\n        return dp[strs.length-1][m][n];\\n    }\\n    \\n   \\n}\\n\\n```\\nTime and space complexity of the solution is ```O(n*m*pairs.length)```",
                "solutionTags": [],
                "code": "``` ```\n```\\npublic class Solution {\\n    Integer memo[][][];\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs == null || strs.length == 0 || (m == 0 && n == 0)) return 0;\\n        memo = new Integer[m+1][n+1][strs.length];\\n        int [][] pairs = new int[strs.length][2];\\n        for(int i = 0;i<strs.length;i++){\\n            for(int j = 0;j<strs[i].length();j++){\\n                char ch  = strs[i].charAt(j);\\n                if(ch == '0') pairs[i][0]++;\\n                else pairs[i][1]++;\\n            }\\n        }\\n        return go(pairs, 0, m, n);\\n    }\\n    \\n    public int go(int pairs[][], int s, int m, int n){\\n        if(s >= pairs.length) return 0;\\n        if(memo[m][n][s] != null) return memo[m][n][s];\\n        int count = 0;\\n        for(int i = s;i<pairs.length;i++){\\n            int dm = m - pairs[i][0];\\n            int dn = n - pairs[i][1];\\n            if(dm >= 0 && dn >=0) {\\n                count = Math.max(count, 1+go(pairs, i+1, dm, dn));\\n            }\\n        }\\n        memo[m][n][s] = count;\\n        return count;\\n    }\\n} \\n\\n```\n```  ```\n```  ```\n```\\npublic class Solution {\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs == null || strs.length == 0 || (m == 0 && n == 0)) return 0;\\n        int dp [][][] = new int[strs.length][m+1][n+1];\\n        int [][] pairs = new int[strs.length][2];\\n        for(int i = 0;i<strs.length;i++){\\n            for(int j = 0;j<strs[i].length();j++){\\n                char ch  = strs[i].charAt(j);\\n                if(ch == '0') pairs[i][0]++;\\n                else pairs[i][1]++;\\n            }\\n        }\\n        for(int zeros =  pairs[0][0];zeros<=m;zeros++){\\n               for(int ones = pairs[0][1];ones<=n;ones++){\\n                   dp[0][zeros][ones] = 1;\\n               }\\n        } \\n        for(int i  = 1;i<strs.length;i++){\\n           for(int zeros =  0;zeros<=m;zeros++){\\n               for(int ones = 0;ones<=n;ones++){\\n                   dp[i][zeros][ones] = dp[i-1][zeros][ones];\\n               }\\n           }\\n           for(int zeros =  pairs[i][0];zeros<=m;zeros++){\\n               for(int ones = pairs[i][1];ones<=n;ones++){\\n                   dp[i][zeros][ones] = Math.max(dp[i-1][zeros][ones], 1+dp[i-1][zeros-pairs[i][0]][ones-pairs[i][1]]);\\n               }\\n           }\\n        }\\n        return dp[strs.length-1][m][n];\\n    }\\n    \\n   \\n}\\n\\n```\n```O(n*m*pairs.length)```",
                "codeTag": "Java"
            },
            {
                "id": 2065874,
                "title": "java-recursive-solution-dynamic-programming-memoization",
                "content": "**Recursive Solution : **\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        return calcFindMaxForm(strs, m, n, 0);\\n    }\\n    \\n    private int calcFindMaxForm(String[] strs, int m, int n, int i) {\\n\\t\\tif (i > strs.length - 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m == 0 && n == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint zerosCount = calcCount(strs[i], \\'0\\');\\n\\t\\tint onesCount = strs[i].length() - zerosCount;\\n\\n\\t\\tif (zerosCount <= m && onesCount <= n)\\n\\t\\t\\treturn Math.max(1 + calcFindMaxForm(strs, m - zerosCount, n - onesCount, i + 1),\\n\\t\\t\\t\\t\\tcalcFindMaxForm(strs, m, n, i + 1));\\n\\t\\telse\\n\\t\\t\\treturn calcFindMaxForm(strs, m, n, i + 1);\\n\\t}\\n\\n\\tprivate int calcCount(String str, char ch) {\\n\\t\\tint count = 0;\\n\\t\\tfor (char tempCh : str.toCharArray()) {\\n\\t\\t\\tif (tempCh == ch)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```\\n\\n**Dynamic Programming Solution : **\\n\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][][] dp = new int[m + 1][n + 1][strs.length + 1];\\n        return calcFindMaxForm(strs, m, n, 0, dp);\\n    }\\n    \\n    private int calcFindMaxForm(String[] strs, int m, int n, int i, int[][][] dp) {\\n\\t\\tif (i > strs.length - 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m == 0 && n == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (dp[m][n][i] != 0)\\n\\t\\t\\treturn dp[m][n][i];\\n\\n\\t\\tint zerosCount = calcCount(strs[i], \\'0\\');\\n\\t\\tint onesCount = strs[i].length() - zerosCount;\\n\\n\\t\\tif (zerosCount <= m && onesCount <= n)\\n\\t\\t\\treturn dp[m][n][i] = Math.max(1 + calcFindMaxForm(strs, m - zerosCount, n - onesCount, i + 1, dp),\\n\\t\\t\\t\\t\\tcalcFindMaxForm(strs, m, n, i + 1, dp));\\n\\t\\telse\\n\\t\\t\\treturn dp[m][n][i] = calcFindMaxForm(strs, m, n, i + 1, dp);\\n\\t}\\n\\n\\tprivate int calcCount(String str, char ch) {\\n\\t\\tint count = 0;\\n\\t\\tfor (char tempCh : str.toCharArray()) {\\n\\t\\t\\tif (tempCh == ch)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        return calcFindMaxForm(strs, m, n, 0);\\n    }\\n    \\n    private int calcFindMaxForm(String[] strs, int m, int n, int i) {\\n\\t\\tif (i > strs.length - 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m == 0 && n == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint zerosCount = calcCount(strs[i], \\'0\\');\\n\\t\\tint onesCount = strs[i].length() - zerosCount;\\n\\n\\t\\tif (zerosCount <= m && onesCount <= n)\\n\\t\\t\\treturn Math.max(1 + calcFindMaxForm(strs, m - zerosCount, n - onesCount, i + 1),\\n\\t\\t\\t\\t\\tcalcFindMaxForm(strs, m, n, i + 1));\\n\\t\\telse\\n\\t\\t\\treturn calcFindMaxForm(strs, m, n, i + 1);\\n\\t}\\n\\n\\tprivate int calcCount(String str, char ch) {\\n\\t\\tint count = 0;\\n\\t\\tfor (char tempCh : str.toCharArray()) {\\n\\t\\t\\tif (tempCh == ch)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][][] dp = new int[m + 1][n + 1][strs.length + 1];\\n        return calcFindMaxForm(strs, m, n, 0, dp);\\n    }\\n    \\n    private int calcFindMaxForm(String[] strs, int m, int n, int i, int[][][] dp) {\\n\\t\\tif (i > strs.length - 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (m == 0 && n == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (dp[m][n][i] != 0)\\n\\t\\t\\treturn dp[m][n][i];\\n\\n\\t\\tint zerosCount = calcCount(strs[i], \\'0\\');\\n\\t\\tint onesCount = strs[i].length() - zerosCount;\\n\\n\\t\\tif (zerosCount <= m && onesCount <= n)\\n\\t\\t\\treturn dp[m][n][i] = Math.max(1 + calcFindMaxForm(strs, m - zerosCount, n - onesCount, i + 1, dp),\\n\\t\\t\\t\\t\\tcalcFindMaxForm(strs, m, n, i + 1, dp));\\n\\t\\telse\\n\\t\\t\\treturn dp[m][n][i] = calcFindMaxForm(strs, m, n, i + 1, dp);\\n\\t}\\n\\n\\tprivate int calcCount(String str, char ch) {\\n\\t\\tint count = 0;\\n\\t\\tfor (char tempCh : str.toCharArray()) {\\n\\t\\t\\tif (tempCh == ch)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465535,
                "title": "c-2d-memory-beats-100-dp-matrix-solution-with-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/ones-and-zeroes/\\n*/\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n    \\n        // each entry: no. of strings that can be formed with m and n\\n        vector<vector<int> > dp(m+1, vector<int>(n+1, 0));\\n        \\n        /*\\n            This is a knapsack problem with \\'m\\' and \\'n\\' that can be considered weights.\\n            So just like the classical problem can be solved with 1D array, for m and n\\n            we use 2D matrix.\\n            \\n            For each entry: check if current string can be formed \\n                            + no. of strings that can be formed with remaining n and m\\n                            \\n            For doing this if we start from top and go towards bottom(smallest value of n and m to largest), \\n            then we end up counting reduntant things. Eg: m = 10, n = 10 will also capture the string that\\n            m = 1, n = 1 can. So if the current string is such that it can be captured by last m and n values and\\n            the current m and n can also cover it, then when we do dp[i - zeros][j - ones], it will give us 1 for the same \\n            thing again.\\n            So we iterate through the strings, and for the current string we start filling m X n matrix from bottom right\\n            to top left. So since upper values can be filled only when the lower values are filled so this time when\\n            1 +  dp[i - zeros][j - ones] is done, dp[i - zeros][j - ones] will only account for the values till the \\n            string before the current string.\\n            for ith string, dp[i][j] has info about the ith string and dp[i-1][j-1] has info till i-1th string, \\n            so adding it won\\'t create any redundancy.\\n        */\\n        \\n        for(const string& str: strs) {\\n            // calculate the no. of ones and zeros required\\n            int zeros = count(str.begin(), str.end(), \\'0\\');\\n            int ones = str.size() - zeros;\\n            \\n            for(int i = m; i >= 0; i--) {\\n                for(int j = n; j >= 0; j--) {\\n                    // current can be considered iff we have required no. of ones and zeros\\n                    int including_current = (zeros <= i && ones <= j) ? 1 + dp[i - zeros][j - ones] : 0;\\n                    dp[i][j] = max(dp[i][j], including_current);\\n                }\\n            }    \\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nreference: https://leetcode.com/problems/ones-and-zeroes/discuss/95814/c++-DP-solution-with-comments",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/ones-and-zeroes/\\n*/\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n    \\n        // each entry: no. of strings that can be formed with m and n\\n        vector<vector<int> > dp(m+1, vector<int>(n+1, 0));\\n        \\n        /*\\n            This is a knapsack problem with \\'m\\' and \\'n\\' that can be considered weights.\\n            So just like the classical problem can be solved with 1D array, for m and n\\n            we use 2D matrix.\\n            \\n            For each entry: check if current string can be formed \\n                            + no. of strings that can be formed with remaining n and m\\n                            \\n            For doing this if we start from top and go towards bottom(smallest value of n and m to largest), \\n            then we end up counting reduntant things. Eg: m = 10, n = 10 will also capture the string that\\n            m = 1, n = 1 can. So if the current string is such that it can be captured by last m and n values and\\n            the current m and n can also cover it, then when we do dp[i - zeros][j - ones], it will give us 1 for the same \\n            thing again.\\n            So we iterate through the strings, and for the current string we start filling m X n matrix from bottom right\\n            to top left. So since upper values can be filled only when the lower values are filled so this time when\\n            1 +  dp[i - zeros][j - ones] is done, dp[i - zeros][j - ones] will only account for the values till the \\n            string before the current string.\\n            for ith string, dp[i][j] has info about the ith string and dp[i-1][j-1] has info till i-1th string, \\n            so adding it won\\'t create any redundancy.\\n        */\\n        \\n        for(const string& str: strs) {\\n            // calculate the no. of ones and zeros required\\n            int zeros = count(str.begin(), str.end(), \\'0\\');\\n            int ones = str.size() - zeros;\\n            \\n            for(int i = m; i >= 0; i--) {\\n                for(int j = n; j >= 0; j--) {\\n                    // current can be considered iff we have required no. of ones and zeros\\n                    int including_current = (zeros <= i && ones <= j) ? 1 + dp[i - zeros][j - ones] : 0;\\n                    dp[i][j] = max(dp[i][j], including_current);\\n                }\\n            }    \\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177639,
                "title": "java-dp-solution-2-solutions-with-explanation",
                "content": "The first solution is O(l * m * n) space.  The second solution is an optimization on space since we only use the previous string's values O(m * n) space. Both are O(l * m * n) time.\n\nFirst we count the number of ones and zeros in each string and store them (in my case I stored them in ms and ns).  ms stores the number of 0s for each string i, and ns stores the number of 1s for each string i.\n\nWe have 3 variables that make the current state unique: The remaining m, the remaining n, and the number of strings left.\nWe let our dp array represent the maximum number of representations with mm 0s nn 1s and i strings.  The answer will be in the dp[m][n][str.length] entry since this represents m 0s n 1s and all strings.  \n\nGoing through each string, we know that if we have enough 0s and 1s left, we can choose the option of using 1 more representation.  Otherwise, we don't use any and take the previous string's value.  \n\nAssuming our current entry is dp[mm][nn][i+1] This means we choose either dp[mm][nn][i] (we don't add a representation and use the previous strings value) or we use dp[mm-ms[i]][nn-ns[i]][i]+1 using up ms[i] 0s and ns[i] 1s and add 1 representation.  We want the maximum of these two choices at every 0<=mm<=m and 0<=nn<=n.\n\n\n```\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int [] ms = new int[strs.length];\n        int [] ns = new int[strs.length];\n        for(int i =0; i<strs.length;++i){\n            String s = strs[i];\n            for(int j=0; j<s.length();++j){\n                char c = s.charAt(j);\n                if(c=='0')++ms[i];\n                else ++ns[i];\n            }\n        }\n        int [][][] dp = new int[m+1][n+1][strs.length+1];\n        int max = 0;\n        for(int i=0; i<ms.length;++i){\n            for(int mm = 0; mm<=m;++mm){\n                for(int nn= 0; nn<=n;++nn){\n                    if(mm>=ms[i]&& nn>=ns[i]){\n                        dp[mm][nn][i+1]=Math.max(dp[mm][nn][i],dp[mm-ms[i]][nn-ns[i]][i]+1);\n                    }\n                    else{ \n                        dp[mm][nn][i+1]=dp[mm][nn][i];\n                    }\n                }\n            }\n        }\n        return dp[m][n][strs.length];\n    }\n}\n```\nTo optimize the space, we can create the dp array in the opposite order (since we want the previous string of the current array), you can also just use a temporary previous array, but this way is cleaner.  (Note that I can't use just one 2d array and go in the same order as the first solution because it will overwrite values from the array then the mm-ms[i] and nn-ns[i] will be using values created during this iteration of i instead of the previous iteration). O(m*n) space\n```\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int [] ms = new int[strs.length];\n        int [] ns = new int[strs.length];\n        for(int i =0; i<strs.length;++i){\n            String s = strs[i];\n            for(int j=0; j<s.length();++j){\n                char c = s.charAt(j);\n                if(c=='0')++ms[i];\n                else ++ns[i];\n            }\n        }\n        int [][] dp = new int[m+1][n+1];\n        int max = 0;\n        for(int i=0; i<ms.length;++i){\n            for(int mm = m; mm>=ms[i];--mm){\n                for(int nn=n; nn>=ns[i];--nn){\n                    dp[mm][nn]=Math.max(dp[mm][nn],dp[mm-ms[i]][nn-ns[i]]+1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int [] ms = new int[strs.length];\n        int [] ns = new int[strs.length];\n        for(int i =0; i<strs.length;++i){\n            String s = strs[i];\n            for(int j=0; j<s.length();++j){\n                char c = s.charAt(j);\n                if(c=='0')++ms[i];\n                else ++ns[i];\n            }\n        }\n        int [][][] dp = new int[m+1][n+1][strs.length+1];\n        int max = 0;\n        for(int i=0; i<ms.length;++i){\n            for(int mm = 0; mm<=m;++mm){\n                for(int nn= 0; nn<=n;++nn){\n                    if(mm>=ms[i]&& nn>=ns[i]){\n                        dp[mm][nn][i+1]=Math.max(dp[mm][nn][i],dp[mm-ms[i]][nn-ns[i]][i]+1);\n                    }\n                    else{ \n                        dp[mm][nn][i+1]=dp[mm][nn][i];\n                    }\n                }\n            }\n        }\n        return dp[m][n][strs.length];\n    }\n}\n```\n```\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int [] ms = new int[strs.length];\n        int [] ns = new int[strs.length];\n        for(int i =0; i<strs.length;++i){\n            String s = strs[i];\n            for(int j=0; j<s.length();++j){\n                char c = s.charAt(j);\n                if(c=='0')++ms[i];\n                else ++ns[i];\n            }\n        }\n        int [][] dp = new int[m+1][n+1];\n        int max = 0;\n        for(int i=0; i<ms.length;++i){\n            for(int mm = m; mm>=ms[i];--mm){\n                for(int nn=n; nn>=ns[i];--nn){\n                    dp[mm][nn]=Math.max(dp[mm][nn],dp[mm-ms[i]][nn-ns[i]]+1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646476,
                "title": "c-recursion-memoization-01-knapsack",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/ce3e069b-34ad-4f24-9b8d-34ec91c4c7af_1664634275.2664628.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,vector<string>& str,int m,int n,int s){\\n\\t\\t\\t\\tif(i==s) return 0;\\n\\t\\t\\t\\tint a=0,b=0;\\n\\t\\t\\t\\tfor(int j=0;j<str[i].size();j++){\\n\\t\\t\\t\\t\\tif(str[i][j]==\\'1\\') a++;\\n\\t\\t\\t\\t\\telse b++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint pick=0;\\n\\t\\t\\t\\tif(m>=b && n>=a) pick=1+f(i+1,str,m-b,n-a,s);\\n\\t\\t\\t\\tint notpick=f(i+1,str,m,n,s);\\n\\t\\t\\t\\treturn max(pick,notpick);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint findMaxForm(vector<string>& str, int m, int n) {\\n\\t\\t\\t\\tint s=str.size();\\n\\t\\t\\t\\treturn f(0,str,m,n,s);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method -2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/bc1565e7-8145-492f-b9bf-371bd4755b6d_1664634574.6241844.png)\\n\\n**T->O(s x m x n) && S->O(s x m x n) + O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<string>& str,int m,int n,int s,vector<vector<vector<int>>>& dp){\\n\\t\\t\\tif(i==s) return 0;\\n\\t\\t\\tif(dp[i][m][n]!=-1) return dp[i][m][n];\\n\\t\\t\\tint a=0,b=0;\\n\\t\\t\\tfor(int j=0;j<str[i].size();j++){\\n\\t\\t\\t\\tif(str[i][j]==\\'1\\') a++;\\n\\t\\t\\t\\telse b++;\\n\\t\\t\\t}\\n\\t\\t\\tint pick=0;\\n\\t\\t\\tif(m>=b && n>=a) pick=1+f(i+1,str,m-b,n-a,s,dp);\\n\\t\\t\\tint notpick=f(i+1,str,m,n,s,dp);\\n\\t\\t\\treturn dp[i][m][n]=max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint findMaxForm(vector<string>& str, int m, int n) {\\n\\t\\t\\tint s=str.size();   \\n\\t\\t\\tvector<vector<vector<int>>> dp(s,vector<vector<int>>(m+1,vector<int>(n+1,-1))); \\n\\t\\t\\treturn f(0,str,m,n,s,dp);\\n\\t\\t}\\n\\t};\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,vector<string>& str,int m,int n,int s){\\n\\t\\t\\t\\tif(i==s) return 0;\\n\\t\\t\\t\\tint a=0,b=0;\\n\\t\\t\\t\\tfor(int j=0;j<str[i].size();j++){\\n\\t\\t\\t\\t\\tif(str[i][j]==\\'1\\') a++;\\n\\t\\t\\t\\t\\telse b++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2543626,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * L * L), Where N is size of array and L is the max. size of string***\\n\\n* ***Space Complexity :- O(N * L * L)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a 3D dp\\n    \\n    int dp[605][105][105];\\n    \\n    int helper(vector<pair<int, int>>& arr, int i, int n, int zeros, int ones)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[i][zeros][ones] != -1)\\n            return dp[i][zeros][ones];\\n        \\n        // we have two options either include the curr string or exclude\\n        \\n        // inclusion part\\n        \\n        int include = 0; \\n        \\n        if(zeros - arr[i].first >= 0 && ones - arr[i].second >= 0)\\n        {\\n            include = 1 + helper(arr, i + 1, n, zeros - arr[i].first, ones - arr[i].second);\\n        }\\n        \\n        // exclusion part\\n        \\n        int exclude = helper(arr, i + 1, n, zeros, ones);\\n        \\n        // store the res and return it\\n        \\n        return dp[i][zeros][ones] = max(include, exclude);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int zeros, int ones) {\\n        \\n        int n = strs.size();\\n        \\n        // find the count of zero and one in every string and store in array\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count_0 = 0;\\n            \\n            int count_1 = 0;\\n            \\n            for(int j = 0; j < strs[i].size(); j++)\\n            {\\n                if(strs[i][j] == \\'0\\')\\n                {\\n                    count_0++;\\n                }\\n                else\\n                {\\n                    count_1++;\\n                }\\n            }\\n            \\n            arr[i] = {count_0, count_1};\\n        }\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(arr, 0, n, zeros, ones);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a 3D dp\\n    \\n    int dp[605][105][105];\\n    \\n    int helper(vector<pair<int, int>>& arr, int i, int n, int zeros, int ones)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[i][zeros][ones] != -1)\\n            return dp[i][zeros][ones];\\n        \\n        // we have two options either include the curr string or exclude\\n        \\n        // inclusion part\\n        \\n        int include = 0; \\n        \\n        if(zeros - arr[i].first >= 0 && ones - arr[i].second >= 0)\\n        {\\n            include = 1 + helper(arr, i + 1, n, zeros - arr[i].first, ones - arr[i].second);\\n        }\\n        \\n        // exclusion part\\n        \\n        int exclude = helper(arr, i + 1, n, zeros, ones);\\n        \\n        // store the res and return it\\n        \\n        return dp[i][zeros][ones] = max(include, exclude);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int zeros, int ones) {\\n        \\n        int n = strs.size();\\n        \\n        // find the count of zero and one in every string and store in array\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count_0 = 0;\\n            \\n            int count_1 = 0;\\n            \\n            for(int j = 0; j < strs[i].size(); j++)\\n            {\\n                if(strs[i][j] == \\'0\\')\\n                {\\n                    count_0++;\\n                }\\n                else\\n                {\\n                    count_1++;\\n                }\\n            }\\n            \\n            arr[i] = {count_0, count_1};\\n        }\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(arr, 0, n, zeros, ones);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067137,
                "title": "python-easy-dp",
                "content": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        \\n        dp = [[0 for i in range(m+1)] for i in range(n+1)]\\n        \\n        for s in strs:\\n            ones = s.count(\"1\")\\n            zeros = s.count(\"0\")\\n            \\n            for i in range(n,ones-1,-1):\\n                for j in range(m,zeros-1,-1):\\n                    dp[i][j] = max(dp[i][j],dp[i-ones][j-zeros]+1)\\n                    \\n        return dp[n][m]\\n```\\n\\n**Please upvote if you find it useful**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        \\n        dp = [[0 for i in range(m+1)] for i in range(n+1)]\\n        \\n        for s in strs:\\n            ones = s.count(\"1\")\\n            zeros = s.count(\"0\")\\n            \\n            for i in range(n,ones-1,-1):\\n                for j in range(m,zeros-1,-1):\\n                    dp[i][j] = max(dp[i][j],dp[i-ones][j-zeros]+1)\\n                    \\n        return dp[n][m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065419,
                "title": "java-easy-approach-dp-pyrogramming",
                "content": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] arr = new int[m+1][n+1];\\n        \\n        for(String str : strs){\\n            int c0 = 0;\\n            int c1 = 0;\\n            \\n            for(char c : str.toCharArray()){\\n                if(c == \\'0\\') c0++;\\n                else c1++;\\n            }\\n            \\n            for(int i=m;i>=c0;i--){\\n                for(int j=n;j>=c1;j--){\\n                    arr[i][j] = Math.max(arr[i][j],arr[i-c0][j-c1] + 1);\\n                }\\n            }\\n        }\\n        return arr[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] arr = new int[m+1][n+1];\\n        \\n        for(String str : strs){\\n            int c0 = 0;\\n            int c1 = 0;\\n            \\n            for(char c : str.toCharArray()){\\n                if(c == \\'0\\') c0++;\\n                else c1++;\\n            }\\n            \\n            for(int i=m;i>=c0;i--){\\n                for(int j=n;j>=c1;j--){\\n                    arr[i][j] = Math.max(arr[i][j],arr[i-c0][j-c1] + 1);\\n                }\\n            }\\n        }\\n        return arr[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065309,
                "title": "c-dp-explaination-o-m-n-space",
                "content": "**Explaination:**\\nClassic 0-1 knapsack variation:\\nAt any index **i** we have 2 choice either to include the current string or not.\\nlet **dp [i][j][k]** denote maximum size subset till **i** having atmost **j** zeroes and **k** ones\\n1. If we don\\'t include i, we assume our optimal answer comes from i-1 \\n2. If we include means i,  we have a new subproblem of maxsize subset till **i-1** having atmost j- zeroes(str) abd k-ones(str)\\nFrom the above two observations we have the dp formula as\\n**let z= zeroes in ith string and o as ones in ith string\\nlet optimalAns1 = dp[i-1][j][k] ---- from statement 1\\n\\toptimal Ans2 = dp[i-1][j-z][k-o]\\n\\tdp[i][j][k] = max(optimal1,optimal2)**\\n**Time: O(l*m*n)     -> l is number of strings\\nSpace:O(l*m*n)**\\n\\n**Optimisation**:\\nAt any index i we only need previous state of **i i.e i-1**. So we can use a dp with size 2 instead of length. Since consecutive i\\'s always have opposite parity (if one is odd other is even), we can take %2 to get current and prev state\\n**Space: O(m*n)**\\n\\nUse one based indexing for edge case in 0th index as we have to access i-1.\\n**Hope it helps. DO upvote :)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int> > > dp;\\n    int findMaxForm(vector<string>& str, int m, int n) {\\n        int l=str.size();\\n        vector<pair<int,int> > cnt(l);\\n       auto getCount = [&](string s){\\n            int cnt=0;;\\n            for(auto c:s) cnt += c-\\'0\\';\\n            return make_pair(s.length()-cnt,cnt);\\n        };\\n        \\n        for(int i=0;i<l;i++) cnt[i]=getCount(str[i]);\\n        \\n        dp.resize(2);\\n        for(auto &y:dp){\\n            y.resize(m+1);\\n            for(auto &x:y) x.resize(n+1);\\n        }\\n        \\n        for(int i=1;i<=l;i++){\\n            int z = cnt[i-1].first , o= cnt[i-1].second;\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    //if not include\\n                    dp[i%2][j][k] = dp[(i-1+2)%2][j][k];\\n                    //if included\\n                    if(j-z>=0 and k-o >=0){\\n                        dp[i%2][j][k] = max(dp[i%2][j][k] , 1 + dp[(i-1+2)%2][j-z][k-o]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[l%2][m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int> > > dp;\\n    int findMaxForm(vector<string>& str, int m, int n) {\\n        int l=str.size();\\n        vector<pair<int,int> > cnt(l);\\n       auto getCount = [&](string s){\\n            int cnt=0;;\\n            for(auto c:s) cnt += c-\\'0\\';\\n            return make_pair(s.length()-cnt,cnt);\\n        };\\n        \\n        for(int i=0;i<l;i++) cnt[i]=getCount(str[i]);\\n        \\n        dp.resize(2);\\n        for(auto &y:dp){\\n            y.resize(m+1);\\n            for(auto &x:y) x.resize(n+1);\\n        }\\n        \\n        for(int i=1;i<=l;i++){\\n            int z = cnt[i-1].first , o= cnt[i-1].second;\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    //if not include\\n                    dp[i%2][j][k] = dp[(i-1+2)%2][j][k];\\n                    //if included\\n                    if(j-z>=0 and k-o >=0){\\n                        dp[i%2][j][k] = max(dp[i%2][j][k] , 1 + dp[(i-1+2)%2][j-z][k-o]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[l%2][m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706217,
                "title": "c-dp-solution-0-1-knapsack-problem",
                "content": "**INTUTION:-**\\nThis is a typical 0-1 knapsack problem ... only difference here is that we have to consider 2 wieghts.number of zeroes and number of ones . So what we do is simply traverse through the vector of string and see number of ones and number of zeroes in that string. Now we simply have 2 choices .. either to accept that string or not. In we follow both cases and see which result gives us max result.\\n\\nLets see how to code above intution:-\\n\\n```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n        int dp[strs.size() + 1][m + 1][n + 1];\\n        memset(dp,0,sizeof dp);\\n        for(int i = 0;i < strs.size() + 1;i++){\\n            int o  = 0;\\n            int z = 0;\\n            if(i > 0){\\n               for(int x = 0;x < strs[i-1].size();x++){\\n                if(strs[i-1][x] == \\'1\\'){\\n                    o++;\\n                }\\n                else{\\n                    z++;\\n                }\\n              }\\n            }\\n           \\n            for(int j = 0;j <= m;j++){\\n                for(int k = 0; k <= n;k++){\\n                    if(i == 0){\\n                        dp[i][j][k] = 0;\\n                    }\\n                    else if(j >= z && k >= o){\\n                        dp[i][j][k] = max(dp[i - 1][j][k],1 + dp[i-1][j- z][k-o]);\\n                    }\\n                    else{\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[strs.size()][m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n        int dp[strs.size() + 1][m + 1][n + 1];\\n        memset(dp,0,sizeof dp);\\n        for(int i = 0;i < strs.size() + 1;i++){\\n            int o  = 0;\\n            int z = 0;\\n            if(i > 0){\\n               for(int x = 0;x < strs[i-1].size();x++){\\n                if(strs[i-1][x] == \\'1\\'){\\n                    o++;\\n                }\\n                else{\\n                    z++;\\n                }\\n              }\\n            }\\n           \\n            for(int j = 0;j <= m;j++){\\n                for(int k = 0; k <= n;k++){\\n                    if(i == 0){\\n                        dp[i][j][k] = 0;\\n                    }\\n                    else if(j >= z && k >= o){\\n                        dp[i][j][k] = max(dp[i - 1][j][k],1 + dp[i-1][j- z][k-o]);\\n                    }\\n                    else{\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[strs.size()][m][n];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138502,
                "title": "ones-and-zeroes-simple-dp-solution-easy-to-understand-explained",
                "content": "The main idea is \\n-> first for every string, we count number of `\\'0\\'s (cnt0) and \\'1\\'s(cnt1)`.\\n-> we also need to check whether our current string is included to get maximum length or if it is excluded, here  we use the DP approach to  solve this, the intiution is very much similar to `0-1 kanpsack problem` .  Here we need to pick maximum number of strings having given number of 0s and 1s  instead of maximum value for a given weight.\\n->finally we return `dp[m][n]` i.e, maximum length with `m` 0s and `n` 1s.\\n\\n**Do upvote** if you find it helpful!! \\n```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        for(string s:strs){\\n            int cnt0=0,cnt1=0;\\n            for(char c:s){\\n                if(c==\\'0\\') cnt0++;\\n                if(c==\\'1\\') cnt1++;\\n            }\\n            for(int i=m;i>=cnt0;i--)\\n                for(int j=n;j>=cnt1;j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-cnt0][j-cnt1]+1);\\n        }\\n        return dp[m][n];\\n    }\\n```\\n**Is there any efficient way to solve this?? thoughts??**",
                "solutionTags": [],
                "code": "```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        for(string s:strs){\\n            int cnt0=0,cnt1=0;\\n            for(char c:s){\\n                if(c==\\'0\\') cnt0++;\\n                if(c==\\'1\\') cnt1++;\\n            }\\n            for(int i=m;i>=cnt0;i--)\\n                for(int j=n;j>=cnt1;j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-cnt0][j-cnt1]+1);\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970739,
                "title": "c-memoization-with-dp-3d-dp",
                "content": "\\n\\n```\\nint memo(vector <vector <vector<int>>>& dp, int start, int m, int n, int size, vector<string>& strs){\\n\\n        if(start>= size || m<0 || n<0)return 0;\\n        if(m ==0 && n == 0 )return 0 ; \\n        if(dp[start][m][n]!= -1 )return dp[start][m][n];\\n        int res = 0 ;\\n        int i = start; \\n        int ones = count(strs[i].begin(), strs[i].end(), \\'1\\'); \\n        int zeros = strs[i].size() -ones;\\n        if(m-zeros>=0 && n-ones >=0) res = max(1+memo(dp,i+1,m-zeros, n-ones,size, strs),memo(dp,i+1,m, n,size, strs));\\n        else res = memo(dp,i+1,m, n,size, strs); \\n  \\n        return dp[start][m][n] = res; \\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size()+1, vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return memo(dp, 0, m,n, strs.size(), strs); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint memo(vector <vector <vector<int>>>& dp, int start, int m, int n, int size, vector<string>& strs){\\n\\n        if(start>= size || m<0 || n<0)return 0;\\n        if(m ==0 && n == 0 )return 0 ; \\n        if(dp[start][m][n]!= -1 )return dp[start][m][n];\\n        int res = 0 ;\\n        int i = start; \\n        int ones = count(strs[i].begin(), strs[i].end(), \\'1\\'); \\n        int zeros = strs[i].size() -ones;\\n        if(m-zeros>=0 && n-ones >=0) res = max(1+memo(dp,i+1,m-zeros, n-ones,size, strs),memo(dp,i+1,m, n,size, strs));\\n        else res = memo(dp,i+1,m, n,size, strs); \\n  \\n        return dp[start][m][n] = res; \\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size()+1, vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return memo(dp, 0, m,n, strs.size(), strs); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329520,
                "title": "c-dynamic-programming-based-on-3d-0-1-knapsack-a-beginner-s-explanation",
                "content": "I\\'m not adept at Dynamic Programming. I\\'m at the point where top down recursion is becoming more intuitive but certainly not 2D or 2D dynamic programming. I usually struggle with the question of what do I memoize -- so if I can\\'t do that how can I do DP. \\n\\nWatched a video on the knapsack problem and many more DP problems linked here: https://www.youtube.com/watch?v=xCbYmUPvc2Q&t=696s&frags=pl%2Cwn(Fantastic Explanation!). And I suddenly levelled up on my understanding and applied it to this problem. Benefits for you as the audience, you get a full tour of how I came up with a working solution as a beginner. So my hope is the explanation will be crystal clear and gap-free!\\n\\n```\\nclass Solution {\\nprivate:\\n    int countNum(string s, int num){\\n        int count = 0;\\n        for (char &c : s){\\n            if (c - \\'0\\' == num){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    vector<int> possibleCounts;\\n    void findMaxForm(vector<string> strs, int m, int n, int count, int idx) {\\n        if (m>=0 && n>=0){\\n            possibleCounts.push_back(count);\\n        } else {\\n            return;\\n        }\\n        for (int i = idx; i<strs.size(); i++){ \\n            findMaxForm(strs, m - countNum(strs[i], 0), n- countNum(strs[i], 1), count + 1, i+1);\\n        }\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        /*\\n            10 max = 1\\n            10 0001 max = 2\\n            10 001 11001 invalid\\n            10 001 11001 1 invalid\\n            10 001 11001 0 invalid\\n            10 11001 \\n            10 11001 1 \\n            10 11001 1 0 \\n            \\n            recursion\\n        */\\n        // Recursion Solution Time: N! + NlogN ... way too slow ...duh!\\n        /*\\n        findMaxForm(strs, m, n, 0, 0);\\n        sort(possibleCounts.begin(), possibleCounts.end(), std::greater<int>{});\\n        return possibleCounts[0];\\n        */\\n        \\n        /*\\n        Dynamic Programming: Similar to knapsack problem but 3 dimensional\\n        The strs are the row headers\\n        n and m are column headers \\n               m=0 1 2 3 4 5 || n=0 1 2 3 \\n        10\\n        0001\\n        11001\\n        1\\n        0\\n        >> think of the row headers as all permutations of m and n \\n            >> [m,n] = 00, 01, 02, 03, 10, 11, 12, 13, 20, 21, 22, 23 etc. \\n        \\n        each cell represents the maximum form using strs with a max m and n in the row headers\\n            >> for row 0 you can only use strs[0]\\n            >> for row 1 you can use strs[0] and strs[1]\\n            >> for row 2 you can use strs[0], strs[1], and strs[2] \\n            >> and so on\\n        So this couples the rows to the previous row. \\n            >> for each new row we are populating, we choose to either (1) NOT use the strs[row] or \\n                (2) Use strs[row] \\n                >> (1) If we do not use strs[row] then we just retrieve dp[row -1][colM][colN]\\n                >> (2) If we use strs[row] then we dp[row][colM][colN] = dp[row-1][colM-countM][colN-countN] + 1\\n                    >> countM and countN are the counts of 0\\'s and 1\\'s for strs[row] respectively\\n                    >> Hence we have to check if colM-countM >=0 and colN-countN >= 0 otherwise\\n                        dp[row][colM][colN] = case(1) because we it means you do not have enough available 0\\'s or 1\\'s \\n                        to use. \\n                        >> AND keep in mind you have to meet both conditions of having enoughs 0\\'s and 1\\'s\\n                            i.e. neither can be negative\\n                >> just max (1) and (2) to get the maxForm\\n            >> Since we need row-1 at each iteration then we need an unnamed dummy row. It cannot be \"\" because this would\\n            be 1 in all cases. But we can call it an empty string, \"\", and just treat it as 0. \\n                 m=0 1 2 3 4 5 || n=0 1 2 3 \\n        unnamed    0 0 0 0 0 0      0 0 0 0\\n        10\\n        0001\\n        11001\\n        1\\n        0    \\n        \\n     \\n        */\\n        vector<vector<vector<int>>> dp(strs.size() + 1, vector<vector<int>> (m+1, vector<int>(n+1)));\\n        int countM, countN; \\n        for(int row = 0; row<strs.size() + 1; row++){\\n            if (row >= 1){\\n                countM = countNum(strs[row-1], 0);\\n                countN = countNum(strs[row-1], 1);\\n            }\\n            for(int colM = 0; colM<=m; colM++){\\n                for (int colN = 0; colN<=n; colN++){\\n                    if (row == 0){\\n                        dp[row][colM][colN] = 0;\\n                        continue;\\n                    } \\n                    if (colM - countM >= 0 && colN - countN >= 0){\\n                        dp[row][colM][colN] = max(dp[row-1][colM][colN], 1 + dp[row-1][colM-countM][colN-countN]);\\n                    } else{\\n                        dp[row][colM][colN] = dp[row-1][colM][colN];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[strs.size()][m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countNum(string s, int num){\\n        int count = 0;\\n        for (char &c : s){\\n            if (c - \\'0\\' == num){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    vector<int> possibleCounts;\\n    void findMaxForm(vector<string> strs, int m, int n, int count, int idx) {\\n        if (m>=0 && n>=0){\\n            possibleCounts.push_back(count);\\n        } else {\\n            return;\\n        }\\n        for (int i = idx; i<strs.size(); i++){ \\n            findMaxForm(strs, m - countNum(strs[i], 0), n- countNum(strs[i], 1), count + 1, i+1);\\n        }\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        /*\\n            10 max = 1\\n            10 0001 max = 2\\n            10 001 11001 invalid\\n            10 001 11001 1 invalid\\n            10 001 11001 0 invalid\\n            10 11001 \\n            10 11001 1 \\n            10 11001 1 0 \\n            \\n            recursion\\n        */\\n        // Recursion Solution Time: N! + NlogN ... way too slow ...duh!\\n        /*\\n        findMaxForm(strs, m, n, 0, 0);\\n        sort(possibleCounts.begin(), possibleCounts.end(), std::greater<int>{});\\n        return possibleCounts[0];\\n        */\\n        \\n        /*\\n        Dynamic Programming: Similar to knapsack problem but 3 dimensional\\n        The strs are the row headers\\n        n and m are column headers \\n               m=0 1 2 3 4 5 || n=0 1 2 3 \\n        10\\n        0001\\n        11001\\n        1\\n        0\\n        >> think of the row headers as all permutations of m and n \\n            >> [m,n] = 00, 01, 02, 03, 10, 11, 12, 13, 20, 21, 22, 23 etc. \\n        \\n        each cell represents the maximum form using strs with a max m and n in the row headers\\n            >> for row 0 you can only use strs[0]\\n            >> for row 1 you can use strs[0] and strs[1]\\n            >> for row 2 you can use strs[0], strs[1], and strs[2] \\n            >> and so on\\n        So this couples the rows to the previous row. \\n            >> for each new row we are populating, we choose to either (1) NOT use the strs[row] or \\n                (2) Use strs[row] \\n                >> (1) If we do not use strs[row] then we just retrieve dp[row -1][colM][colN]\\n                >> (2) If we use strs[row] then we dp[row][colM][colN] = dp[row-1][colM-countM][colN-countN] + 1\\n                    >> countM and countN are the counts of 0\\'s and 1\\'s for strs[row] respectively\\n                    >> Hence we have to check if colM-countM >=0 and colN-countN >= 0 otherwise\\n                        dp[row][colM][colN] = case(1) because we it means you do not have enough available 0\\'s or 1\\'s \\n                        to use. \\n                        >> AND keep in mind you have to meet both conditions of having enoughs 0\\'s and 1\\'s\\n                            i.e. neither can be negative\\n                >> just max (1) and (2) to get the maxForm\\n            >> Since we need row-1 at each iteration then we need an unnamed dummy row. It cannot be \"\" because this would\\n            be 1 in all cases. But we can call it an empty string, \"\", and just treat it as 0. \\n                 m=0 1 2 3 4 5 || n=0 1 2 3 \\n        unnamed    0 0 0 0 0 0      0 0 0 0\\n        10\\n        0001\\n        11001\\n        1\\n        0    \\n        \\n     \\n        */\\n        vector<vector<vector<int>>> dp(strs.size() + 1, vector<vector<int>> (m+1, vector<int>(n+1)));\\n        int countM, countN; \\n        for(int row = 0; row<strs.size() + 1; row++){\\n            if (row >= 1){\\n                countM = countNum(strs[row-1], 0);\\n                countN = countNum(strs[row-1], 1);\\n            }\\n            for(int colM = 0; colM<=m; colM++){\\n                for (int colN = 0; colN<=n; colN++){\\n                    if (row == 0){\\n                        dp[row][colM][colN] = 0;\\n                        continue;\\n                    } \\n                    if (colM - countM >= 0 && colN - countN >= 0){\\n                        dp[row][colM][colN] = max(dp[row-1][colM][colN], 1 + dp[row-1][colM-countM][colN-countN]);\\n                    } else{\\n                        dp[row][colM][colN] = dp[row-1][colM][colN];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[strs.size()][m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281156,
                "title": "474-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a 2D array, dp, with m+1 rows and n+1 columns, filled with 0\\'s. The purpose of this array is to keep track of the maximum subset size for each combination of zeros and ones that can be formed with the current set of strings.\\n\\n2. Iterate through each string in strs.\\n\\n3. For the current string, count the number of 0\\'s and 1\\'s it contains, and store these values in zero_count and one_count, respectively.\\n\\n4. Starting from the last row and last column of dp, iterate through each possible (i, j) combination such that i is greater than or equal to zero_count and j is greater than or equal to one_count. This is because we can only form a subset using a string if there are enough zeros and ones available to do so.\\n\\n5. For each (i, j) combination, update the value of dp[i][j] to be the maximum value of dp[i][j] and dp[i-zero_count][j-one_count] + 1. The first term represents the maximum subset size that can be formed without using the current string, while the second term represents the maximum subset size that can be formed by using the current string. By adding 1 to the latter, we include the current string in the subset.\\n\\n6. After iterating through all the strings in strs, return dp[m][n], which represents the maximum subset size that can be formed using at most m zeros and n ones.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        # Initialize dp with 0\\'s\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        # Iterate through each string in strs\\n        for s in strs:\\n            zero_count = s.count(\\'0\\')\\n            one_count = s.count(\\'1\\')\\n            \\n            # Update dp for each possible (i, j)\\n            for i in range(m, zero_count-1, -1):\\n                for j in range(n, one_count-1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i-zero_count][j-one_count] + 1)\\n        \\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        # Initialize dp with 0\\'s\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        # Iterate through each string in strs\\n        for s in strs:\\n            zero_count = s.count(\\'0\\')\\n            one_count = s.count(\\'1\\')\\n            \\n            # Update dp for each possible (i, j)\\n            for i in range(m, zero_count-1, -1):\\n                for j in range(n, one_count-1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i-zero_count][j-one_count] + 1)\\n        \\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065917,
                "title": "c-2-methods-tabulation-recursion",
                "content": "#Method 1: Recursion + Memoization (top-down dp)\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int fun(int i,int m, int n, vector<string> &s){\\n\\t   // base case\\n        if(i >= s.size() || n<0 || m<0 ){\\n            return 0;\\n        }\\n\\t\\t// simply return the value if previously calculated\\n        if(dp[i][m][n] != -1)return dp[i][m][n];\\n        int c0 = count(s[i].begin(),s[i].end(),\\'0\\');\\n        int c1 = count(s[i].begin(),s[i].end(),\\'1\\');\\n\\t\\t// if we can take this string , then ans_till_here = max(take it , avoid it)\\n        if(m-c0 >= 0 && n-c1 >= 0 )\\n        return dp[i][m][n] = max(fun(i+1,m-c0,n-c1,s)+1, fun(i+1,m,n,s));\\n\\t\\t//otherwise avoid it\\n        else return dp[i][m][n] = fun(i+1,m,n,s);\\n    }\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int sz = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,m,n,s);\\n    }\\n};\\n```\\n\\n#Method 2: Tabulation(bottom-up dp)\\n```\\nclass Solution {\\npublic:\\n \\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int sz = s.size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int cnt[sz+1][2];\\n        for(int i=0;i<sz;i++){\\n            int c0 = count(s[i].begin(), s[i].end(),\\'0\\');\\n            int c1 = count(s[i].begin(), s[i].end(),\\'1\\');\\n            cnt[i+1][0]= c0;\\n            cnt[i+1][1]=c1;\\n        }\\n        for(int i=1;i <= sz;i++){\\n            for(int j=m;j>=0;j--){\\n                for(int k=n;k>=0;k--){\\n                    \\n                    if((j-cnt[i][0]) >=0 && (k-cnt[i][1]) >= 0){\\n                        dp[j][k] = max(dp[j][k], dp[j-cnt[i][0]][k-cnt[i][1]]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int fun(int i,int m, int n, vector<string> &s){\\n\\t   // base case\\n        if(i >= s.size() || n<0 || m<0 ){\\n            return 0;\\n        }\\n\\t\\t// simply return the value if previously calculated\\n        if(dp[i][m][n] != -1)return dp[i][m][n];\\n        int c0 = count(s[i].begin(),s[i].end(),\\'0\\');\\n        int c1 = count(s[i].begin(),s[i].end(),\\'1\\');\\n\\t\\t// if we can take this string , then ans_till_here = max(take it , avoid it)\\n        if(m-c0 >= 0 && n-c1 >= 0 )\\n        return dp[i][m][n] = max(fun(i+1,m-c0,n-c1,s)+1, fun(i+1,m,n,s));\\n\\t\\t//otherwise avoid it\\n        else return dp[i][m][n] = fun(i+1,m,n,s);\\n    }\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int sz = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,m,n,s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n \\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int sz = s.size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int cnt[sz+1][2];\\n        for(int i=0;i<sz;i++){\\n            int c0 = count(s[i].begin(), s[i].end(),\\'0\\');\\n            int c1 = count(s[i].begin(), s[i].end(),\\'1\\');\\n            cnt[i+1][0]= c0;\\n            cnt[i+1][1]=c1;\\n        }\\n        for(int i=1;i <= sz;i++){\\n            for(int j=m;j>=0;j--){\\n                for(int k=n;k>=0;k--){\\n                    \\n                    if((j-cnt[i][0]) >=0 && (k-cnt[i][1]) >= 0){\\n                        dp[j][k] = max(dp[j][k], dp[j-cnt[i][0]][k-cnt[i][1]]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065155,
                "title": "java-solution",
                "content": "```\\n// Ones and Zeros\\n// Leetcode problem https://leetcode.com/problems/ones-and-zeroes/\\n\\nclass Solution {\\n    public int findMaxForm(String[] S, int M, int N) {\\n        int[][] dp = new int[M+1][N+1];\\n        for (String str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str.toCharArray())\\n                if (c == \\'0\\') zeros++;\\n                else ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Ones and Zeros\\n// Leetcode problem https://leetcode.com/problems/ones-and-zeroes/\\n\\nclass Solution {\\n    public int findMaxForm(String[] S, int M, int N) {\\n        int[][] dp = new int[M+1][N+1];\\n        for (String str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str.toCharArray())\\n                if (c == \\'0\\') zeros++;\\n                else ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371836,
                "title": "java-recursion-memoization-bu-buse-4-solutions",
                "content": "\\n\\n\\t// Recursion\\n\\t// O(2^len) O(len)\\n\\tpublic int findMaxFormRec(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\treturn findMaxFormRecHelper(strs, m, n, 0, len, map);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(2^len) O(len)\\n\\tpublic int findMaxFormRecHelper(String[] strs, int m, int n, int idx, int len, int[][] map) {\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn Integer.MIN_VALUE;\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint yes = findMaxFormRecHelper(strs, m - map[idx][0], n - map[idx][1], idx + 1, len, map);\\n\\t\\tint no = findMaxFormRecHelper(strs, m, n, idx + 1, len, map);\\n\\n\\t\\tif (yes != Integer.MIN_VALUE)\\n\\t\\t\\tyes += 1;\\n\\n\\t\\treturn Math.max(yes, no);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(m*n*len) O(m*n*len)\\n\\tpublic int findMaxFormMemo(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2];\\n\\t\\tInteger[][][] memo = new Integer[m + 1][n + 1][len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\treturn findMaxFormMemoHelper(strs, m, n, 0, len, map, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(m*n*len) O(m*n*len)\\n\\tpublic int findMaxFormMemoHelper(String[] strs, int m, int n, int idx, int len, int[][] map, Integer[][][] memo) {\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn Integer.MIN_VALUE;\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[m][n][idx] != null)\\n\\t\\t\\treturn memo[m][n][idx];\\n\\n\\t\\tint yes = findMaxFormMemoHelper(strs, m - map[idx][0], n - map[idx][1], idx + 1, len, map, memo);\\n\\t\\tint no = findMaxFormMemoHelper(strs, m, n, idx + 1, len, map, memo);\\n\\n\\t\\tif (yes != Integer.MIN_VALUE)\\n\\t\\t\\tyes += 1;\\n\\n\\t\\tint ans = Math.max(yes, no);\\n\\t\\tmemo[m][n][idx] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(m*n*len) O(m*n*len)\\n\\tpublic int findMaxFormBU(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2];\\n\\t\\tint[][][] dp = new int[m + 1][n + 1][len + 1];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = m; j >= 0; j--) {\\n\\t\\t\\t\\tfor (int k = n; k >= 0; k--) {\\n\\t\\t\\t\\t\\tint yes = (j - map[i][0] < 0 || k - map[i][1] < 0) ? Integer.MIN_VALUE\\n\\t\\t\\t\\t\\t\\t\\t: dp[j - map[i][0]][k - map[i][1]][i + 1];\\n\\t\\t\\t\\t\\tint no = dp[j][k][i + 1];\\n\\t\\t\\t\\t\\tif (yes != Integer.MIN_VALUE)\\n\\t\\t\\t\\t\\t\\tyes += 1;\\n\\t\\t\\t\\t\\tdp[j][k][i] = Math.max(yes, no);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[m][n][0];\\n\\t}\\n\\n\\t// Bottom Up Space Efficient\\n\\t// O(m*n*len) O(m*n)\\n\\tpublic int findMaxFormBUSE(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2], dp = new int[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint cnt1 = map[i][0], cnt2 = map[i][1];\\n\\t\\t\\tfor (int j = m; j >= cnt1; j--) {\\n\\t\\t\\t\\tfor (int k = n; k >= cnt2; k--) {\\n\\t\\t\\t\\t\\tint yes = dp[j - map[i][0]][k - map[i][1]] + 1;\\n\\t\\t\\t\\t\\tint no = dp[j][k];\\n\\t\\t\\t\\t\\tdp[j][k] = (yes > no) ? yes : no;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[m][n];\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// Recursion\\n\\t// O(2^len) O(len)\\n\\tpublic int findMaxFormRec(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\treturn findMaxFormRecHelper(strs, m, n, 0, len, map);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(2^len) O(len)\\n\\tpublic int findMaxFormRecHelper(String[] strs, int m, int n, int idx, int len, int[][] map) {\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn Integer.MIN_VALUE;\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint yes = findMaxFormRecHelper(strs, m - map[idx][0], n - map[idx][1], idx + 1, len, map);\\n\\t\\tint no = findMaxFormRecHelper(strs, m, n, idx + 1, len, map);\\n\\n\\t\\tif (yes != Integer.MIN_VALUE)\\n\\t\\t\\tyes += 1;\\n\\n\\t\\treturn Math.max(yes, no);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(m*n*len) O(m*n*len)\\n\\tpublic int findMaxFormMemo(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2];\\n\\t\\tInteger[][][] memo = new Integer[m + 1][n + 1][len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\treturn findMaxFormMemoHelper(strs, m, n, 0, len, map, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(m*n*len) O(m*n*len)\\n\\tpublic int findMaxFormMemoHelper(String[] strs, int m, int n, int idx, int len, int[][] map, Integer[][][] memo) {\\n\\n\\t\\tif (m < 0 || n < 0)\\n\\t\\t\\treturn Integer.MIN_VALUE;\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[m][n][idx] != null)\\n\\t\\t\\treturn memo[m][n][idx];\\n\\n\\t\\tint yes = findMaxFormMemoHelper(strs, m - map[idx][0], n - map[idx][1], idx + 1, len, map, memo);\\n\\t\\tint no = findMaxFormMemoHelper(strs, m, n, idx + 1, len, map, memo);\\n\\n\\t\\tif (yes != Integer.MIN_VALUE)\\n\\t\\t\\tyes += 1;\\n\\n\\t\\tint ans = Math.max(yes, no);\\n\\t\\tmemo[m][n][idx] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(m*n*len) O(m*n*len)\\n\\tpublic int findMaxFormBU(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2];\\n\\t\\tint[][][] dp = new int[m + 1][n + 1][len + 1];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = m; j >= 0; j--) {\\n\\t\\t\\t\\tfor (int k = n; k >= 0; k--) {\\n\\t\\t\\t\\t\\tint yes = (j - map[i][0] < 0 || k - map[i][1] < 0) ? Integer.MIN_VALUE\\n\\t\\t\\t\\t\\t\\t\\t: dp[j - map[i][0]][k - map[i][1]][i + 1];\\n\\t\\t\\t\\t\\tint no = dp[j][k][i + 1];\\n\\t\\t\\t\\t\\tif (yes != Integer.MIN_VALUE)\\n\\t\\t\\t\\t\\t\\tyes += 1;\\n\\t\\t\\t\\t\\tdp[j][k][i] = Math.max(yes, no);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[m][n][0];\\n\\t}\\n\\n\\t// Bottom Up Space Efficient\\n\\t// O(m*n*len) O(m*n)\\n\\tpublic int findMaxFormBUSE(String[] strs, int m, int n) {\\n\\n\\t\\tint len = strs.length;\\n\\t\\tint[][] map = new int[len][2], dp = new int[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tString binary = strs[i];\\n\\t\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t\\tfor (char ch : binary.toCharArray()) {\\n\\t\\t\\t\\tif (ch == \\'0\\')\\n\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t}\\n\\t\\t\\tmap[i][0] = count1;\\n\\t\\t\\tmap[i][1] = count2;\\n\\t\\t}\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint cnt1 = map[i][0], cnt2 = map[i][1];\\n\\t\\t\\tfor (int j = m; j >= cnt1; j--) {\\n\\t\\t\\t\\tfor (int k = n; k >= cnt2; k--) {\\n\\t\\t\\t\\t\\tint yes = dp[j - map[i][0]][k - map[i][1]] + 1;\\n\\t\\t\\t\\t\\tint no = dp[j][k];\\n\\t\\t\\t\\t\\tdp[j][k] = (yes > no) ? yes : no;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[m][n];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1138851,
                "title": "java-solution-beats-99-with-comments-for-explanation",
                "content": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // keeps track max size of the subset that could be stored for each max[i][j] where\\n        // i is the number of zeroes\\n        // j is the number of ones\\n        int[][] max = new int[m+1][n+1];\\n        for(String str : strs){\\n            int neededZeroes = 0;\\n            int neededOnes = 0;\\n            \\n            for(int i = 0; i < str.length(); i++){\\n                if(str.charAt(i) == \\'0\\') neededZeroes++;\\n                else neededOnes++;\\n            }\\n            \\n            for(int zero = m; zero >= 0; zero--){\\n                for(int one = n; one >= 0; one--){\\n                    // if we could take the current string then reassess the max\\n                    if(zero >= neededZeroes && one >= neededOnes){\\n                        // compare the size of subsets if we don\\'t take it vs we take it\\n                        max[zero][one] = Math.max(max[zero][one], 1 + max[zero-neededZeroes][one-neededOnes]);\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return max[m][n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // keeps track max size of the subset that could be stored for each max[i][j] where\\n        // i is the number of zeroes\\n        // j is the number of ones\\n        int[][] max = new int[m+1][n+1];\\n        for(String str : strs){\\n            int neededZeroes = 0;\\n            int neededOnes = 0;\\n            \\n            for(int i = 0; i < str.length(); i++){\\n                if(str.charAt(i) == \\'0\\') neededZeroes++;\\n                else neededOnes++;\\n            }\\n            \\n            for(int zero = m; zero >= 0; zero--){\\n                for(int one = n; one >= 0; one--){\\n                    // if we could take the current string then reassess the max\\n                    if(zero >= neededZeroes && one >= neededOnes){\\n                        // compare the size of subsets if we don\\'t take it vs we take it\\n                        max[zero][one] = Math.max(max[zero][one], 1 + max[zero-neededZeroes][one-neededOnes]);\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return max[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228831,
                "title": "python-dp",
                "content": "\\tdef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # m: 0 n: 1\\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for str in strs:\\n            zeros = 0\\n            ones = 0\\n            for char in str:\\n                if char == \"0\":\\n                    zeros += 1\\n                elif char == \"1\":\\n                    ones += 1\\n            for i in range(m, zeros - 1, -1):\\n                for j in range(n, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\\n            \\n        return dp[m][n]",
                "solutionTags": [],
                "code": "\\tdef findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # m: 0 n: 1\\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for str in strs:\\n            zeros = 0\\n            ones = 0\\n            for char in str:\\n                if char == \"0\":\\n                    zeros += 1\\n                elif char == \"1\":\\n                    ones += 1\\n            for i in range(m, zeros - 1, -1):\\n                for j in range(n, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\\n            \\n        return dp[m][n]",
                "codeTag": "Python3"
            },
            {
                "id": 3668890,
                "title": "memoization-tabulation-space-optimization-3d-dp-to-2d-dp",
                "content": "# Intuition\\nThere Are three Changing Transistions \\n1) index\\n2) No of zeros\\n3) No of Ones\\nHence We Have to use 3d dp  .\\nBut space can be optimized because at every index we need the the curr row and (previous row or next row depends on intiution).\\n\\n**Memoization :**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(SIZE * M * N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(SIZE * M * N+SIZE)\\n//recursive stack space is added\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recurse(vector<string>& strs,int i,int m,int n,vector<vector<vector<int>>>&dp,int size,vector<int>&ones,vector<int>&zeros)\\n    {\\n        if(i==size ) return 0;\\n        if(dp[i][m][n]!=-1) return dp[i][m][n];\\n        int nt=recurse(strs,i+1,m,n,dp,size,ones,zeros);\\n        int t=0;\\n        if(m>=zeros[i] && n>=ones[i])\\n        {\\n            t=1+recurse(strs,i+1,m-zeros[i],n-ones[i],dp,size,ones,zeros);\\n        }\\n        return dp[i][m][n]=max(t,nt);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int size=strs.size();\\n        vector<int>ones(size,0),zeros(size,0);\\n        string s;\\n        for(int i=0;i<size;i++)\\n        { \\n           s=strs[i];\\n           for(char c:s)\\n           {\\n               if(c==\\'0\\') zeros[i]++;\\n               else ones[i]++;\\n           }   \\n        //   cout<<zeros[i]<<\" \"<<ones[i]<<endl;\\n        }\\n        vector<vector<vector<int>>>dp(size,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n      return recurse(strs,0,m,n,dp,size,ones,zeros);\\n    }\\n};\\n```\\n**TABULATION :**\\n# Complexity\\n- Time complexity:\\nO(SIZE * M * N)\\n\\n- Space complexity:\\nO(SIZE * M * N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int size=strs.size();\\n        string s;\\n        int ones=0,zeros=0;\\n        vector<vector<vector<int>>>dp(size+1,vector<vector<int>>(m+1,vector<int>(n+1,0)));\\n   for(int i=size-1;i>=0;i--)\\n   {\\n           s=strs[i];\\n           zeros=0,ones=0;\\n           for(char c:s)\\n           {\\n               if(c==\\'0\\') zeros++;\\n               else ones++;\\n           }   \\n       for(int j=m;j>=0;j--)\\n       {\\n           for(int k=n;k>=0;k--)\\n           {\\n                int nt=dp[i+1][j][k];\\n        int t=0;\\n        if(j>=zeros && k>=ones)\\n        {\\n            t=1+dp[i+1][j-zeros][k-ones];\\n        }\\n        dp[i][j][k]=max(t,nt);\\n\\n           }\\n       }\\n                \\n   }\\n   return dp[0][m][n];\\n    }\\n};\\n```\\n**SPACE OPTIMIZED 3D DP TO 2D DP**\\n\\n# Complexity\\n- Time complexity:\\nO(SIZE * M * N)\\n\\n- Space complexity:\\nO(M * N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int findMaxForm(vector<string>& strs, int m1, int n1) {\\n        int size=strs.size();\\n        string s;\\n\\n       int zeros=0,ones=0;\\n     vector<vector<int>>ahead(m1+1,vector<int>(n1+1,0)),cur(m1+1,vector<int>(n1+1,0));\\n        for(int i=size-1;i>=0;i--)\\n        {\\n           s=strs[i];\\n           zeros=0,ones=0;\\n           for(char c:s)\\n           {\\n               if(c==\\'0\\') zeros++;\\n               else ones++;\\n           }   \\n            for(int m=m1;m>=0;m--)\\n            {\\n                for(int n=n1;n>=0;n--)\\n                {\\n                     int nt=ahead[m][n];\\n        int t=0;\\n        if(m>=zeros && n>=ones)\\n        {\\n            t=1+ahead[m-zeros][n-ones];\\n        }\\n         cur[m][n]=max(t,nt);\\n                }\\n            }\\n            ahead=cur;\\n        }\\n      return ahead[m1][n1];\\n  \\n    }\\n};\\n```\\n**PLEASE UPVOTE IF YOU LIKE MY SOLUTION**\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recurse(vector<string>& strs,int i,int m,int n,vector<vector<vector<int>>>&dp,int size,vector<int>&ones,vector<int>&zeros)\\n    {\\n        if(i==size ) return 0;\\n        if(dp[i][m][n]!=-1) return dp[i][m][n];\\n        int nt=recurse(strs,i+1,m,n,dp,size,ones,zeros);\\n        int t=0;\\n        if(m>=zeros[i] && n>=ones[i])\\n        {\\n            t=1+recurse(strs,i+1,m-zeros[i],n-ones[i],dp,size,ones,zeros);\\n        }\\n        return dp[i][m][n]=max(t,nt);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int size=strs.size();\\n        vector<int>ones(size,0),zeros(size,0);\\n        string s;\\n        for(int i=0;i<size;i++)\\n        { \\n           s=strs[i];\\n           for(char c:s)\\n           {\\n               if(c==\\'0\\') zeros[i]++;\\n               else ones[i]++;\\n           }   \\n        //   cout<<zeros[i]<<\" \"<<ones[i]<<endl;\\n        }\\n        vector<vector<vector<int>>>dp(size,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n      return recurse(strs,0,m,n,dp,size,ones,zeros);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int size=strs.size();\\n        string s;\\n        int ones=0,zeros=0;\\n        vector<vector<vector<int>>>dp(size+1,vector<vector<int>>(m+1,vector<int>(n+1,0)));\\n   for(int i=size-1;i>=0;i--)\\n   {\\n           s=strs[i];\\n           zeros=0,ones=0;\\n           for(char c:s)\\n           {\\n               if(c==\\'0\\') zeros++;\\n               else ones++;\\n           }   \\n       for(int j=m;j>=0;j--)\\n       {\\n           for(int k=n;k>=0;k--)\\n           {\\n                int nt=dp[i+1][j][k];\\n        int t=0;\\n        if(j>=zeros && k>=ones)\\n        {\\n            t=1+dp[i+1][j-zeros][k-ones];\\n        }\\n        dp[i][j][k]=max(t,nt);\\n\\n           }\\n       }\\n                \\n   }\\n   return dp[0][m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int findMaxForm(vector<string>& strs, int m1, int n1) {\\n        int size=strs.size();\\n        string s;\\n\\n       int zeros=0,ones=0;\\n     vector<vector<int>>ahead(m1+1,vector<int>(n1+1,0)),cur(m1+1,vector<int>(n1+1,0));\\n        for(int i=size-1;i>=0;i--)\\n        {\\n           s=strs[i];\\n           zeros=0,ones=0;\\n           for(char c:s)\\n           {\\n               if(c==\\'0\\') zeros++;\\n               else ones++;\\n           }   \\n            for(int m=m1;m>=0;m--)\\n            {\\n                for(int n=n1;n>=0;n--)\\n                {\\n                     int nt=ahead[m][n];\\n        int t=0;\\n        if(m>=zeros && n>=ones)\\n        {\\n            t=1+ahead[m-zeros][n-ones];\\n        }\\n         cur[m][n]=max(t,nt);\\n                }\\n            }\\n            ahead=cur;\\n        }\\n      return ahead[m1][n1];\\n  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3619769,
                "title": "beginner-friendly-c-recursion-memoisation-approach-with-diagrams",
                "content": "\\n# Identification of Problem\\nLet\\'s start by figuring out what\\'s given to us and how we can use it.\\nWe\\'re provided with an vector of strings as input and two integers m and n which denotes maximum number of 0\\'s and 1\\'s the subset of string can have!\\n\\n1. We have a choice whether to include a string or not in the subset.\\n2. We have been asked about finding largest subset i.e. optimal condition\\n\\nSo, we have a choice and we\\'ve to give optimal condition in output. Generally, these problems of choice and optimal condition is solved using... \\n\\nYES! you\\'ve guess it **Dynamic Programming!**\\n\\n# Identification of parent problem statement\\nThis is the most important part of dynamic programming whether if we\\'re able to identify the parent problem set.\\n\\nHere, we\\'ve given a vector of stings as input\\n\\n```\\nstrs= [\"10\", \"00001\", \"1110001\", \"1\", \"0\"]\\nm=5, n=3\\n```\\nWe have an condition that it should have at most m-> 0\\'s and n-> 1\\'s.\\n\\nLet\\'s draw the choice diagram for a better understanding of the problem.\\n\\n![photo_2023-06-10_02-16-32.jpg](https://assets.leetcode.com/users/images/e012fdf9-ed13-46cb-a0ef-335bb0774954_1686343610.8904438.jpeg)\\n\\nIn short, we can say\\n\\n![photo_2023-06-10_02-18-28.jpg](https://assets.leetcode.com/users/images/9faa95cf-7d84-4b5e-83d2-f0356ad28fbd_1686343718.8429286.jpeg)\\n\\n> If number of 0\\'s in string is **greater than m** or **number of zeroes greater than n** we can\\'t include the string as it\\'s not satisfying the condition.\\nIf **number of 0\\'s in string is less than or equal to m** or **number of zeroes less than equal to n**, we have to choice to include the string in the solution or not.\\n\\n**From this we can identify this problem is similar to 0/1 Knapsack!**\\nWhy? Let\\'s again see it through choice diagram of 0/1 knapsack.\\n\\n![photo_2023-06-10_02-24-26.jpg](https://assets.leetcode.com/users/images/165e9a8b-cab8-4db3-9251-8074c9aea7f5_1686344107.1137526.jpeg)\\n\\n**But, there is only one array given in this problem statement in knapsack problems there are two arrays one weight and other profit!**\\nWhen the problem has same choice diagram as knapsack but there is only one array given consider it as weight array and do the changes.\\n\\n# Code for general 0/1 Knapsack:\\n```\\nint knapSack(int W, int wt[], int val[], int n) \\n    { \\n       if(n==0 || W==0) return 0;\\n       \\n       if(wt[n-1]<=W)\\n        return max(knapSack( W,wt,val,n-1 ) , val[ n-1 ] + knapSack( W-wt[n-1],wt,val,n-1 ) );\\n        \\n       return knapSack( W,wt,val,n-1 );\\n    }\\n```\\n\\n# Modified Knapsack code for this solution:\\n```\\n1. Calculate number of zeroes and ones in the string.\\n2. Think of base condition here if the index equals the size of the \\n   given vector or when value of m and n both equals zero we return 0.\\n3. Modify the knapsack code!\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int noZeros(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'0\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int noOnes(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'1\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int helper(vector<string> & strs, int m, int n, int ind){\\n         // Base Condition\\n        if(ind ==strs.size() || (m==0 && n==0)) return 0;\\n\\n        // Calcualte number of ones and zeros in the string\\n        int zeros=noZeros(strs[ind]);\\n        int ones=noOnes(strs[ind]);\\n\\n        int choose= 0;\\n        if( zeros <= m && ones <= n ){\\n            return max( helper( strs, m, n, ind+1), 1 + helper( strs, m-zeros, n-ones, ind+1));\\n        }\\n        return helper( strs, m, n, ind+1);\\n    }\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return helper(strs, m, n, 0);\\n    }\\n};\\n\\n```\\n\\n# Code for memoisation\\n\\nAfter writing the recursive code memoisation isn\\'t a big task!\\n```\\n1. Make a global 3-D array with m, n and index as it\\'s dimentions.\\n2. Set every element of the array as -1 using memset function.\\n3. Check if stored the value is not equal to -1 and return the value as we\\'ve already calculated it.\\n4. Store the values in the 3-D array. \\n5. Return the last element of the 3-D array.\\n```\\n```\\nclass Solution {\\npublic:\\n    int noZeros(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'0\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int noOnes(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'1\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int t[102][102][602];\\n\\n    int helper(vector<string> & strs, int m, int n, int ind){\\n         // Base Condition\\n        if(ind ==strs.size() || (m==0 && n==0)) return 0;\\n\\n        // Calcualte number of ones and zeros in the string\\n        int zeros=noZeros(strs[ind]);\\n        int ones=noOnes(strs[ind]);\\n\\n        int choose= 0;\\n        if( t[m][n][ind] != -1 ){\\n            return t[m][n][ind];\\n        }\\n\\n        if( zeros <= m && ones <= n ){\\n            t[m][n][ind] = max( helper( strs, m, n, ind+1), 1 + helper( strs, m-zeros, n-ones, ind+1));\\n        }\\n        else if( zeros > m || ones > n)\\n            t[m][n][ind] = helper( strs, m, n, ind+1 );\\n\\n        return t[m][n][ind];\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(t,-1, sizeof(t));\\n        return helper(strs, m, n, 0);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nstrs= [\"10\", \"00001\", \"1110001\", \"1\", \"0\"]\\nm=5, n=3\\n```\n```\\nint knapSack(int W, int wt[], int val[], int n) \\n    { \\n       if(n==0 || W==0) return 0;\\n       \\n       if(wt[n-1]<=W)\\n        return max(knapSack( W,wt,val,n-1 ) , val[ n-1 ] + knapSack( W-wt[n-1],wt,val,n-1 ) );\\n        \\n       return knapSack( W,wt,val,n-1 );\\n    }\\n```\n```\\n1. Calculate number of zeroes and ones in the string.\\n2. Think of base condition here if the index equals the size of the \\n   given vector or when value of m and n both equals zero we return 0.\\n3. Modify the knapsack code!\\n```\n```\\nclass Solution {\\npublic:\\n    int noZeros(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'0\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int noOnes(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'1\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int helper(vector<string> & strs, int m, int n, int ind){\\n         // Base Condition\\n        if(ind ==strs.size() || (m==0 && n==0)) return 0;\\n\\n        // Calcualte number of ones and zeros in the string\\n        int zeros=noZeros(strs[ind]);\\n        int ones=noOnes(strs[ind]);\\n\\n        int choose= 0;\\n        if( zeros <= m && ones <= n ){\\n            return max( helper( strs, m, n, ind+1), 1 + helper( strs, m-zeros, n-ones, ind+1));\\n        }\\n        return helper( strs, m, n, ind+1);\\n    }\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return helper(strs, m, n, 0);\\n    }\\n};\\n\\n```\n```\\n1. Make a global 3-D array with m, n and index as it\\'s dimentions.\\n2. Set every element of the array as -1 using memset function.\\n3. Check if stored the value is not equal to -1 and return the value as we\\'ve already calculated it.\\n4. Store the values in the 3-D array. \\n5. Return the last element of the 3-D array.\\n```\n```\\nclass Solution {\\npublic:\\n    int noZeros(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'0\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int noOnes(string s){\\n        int count =0;\\n        for(char ch: s){\\n            if(ch== \\'1\\' )count++;\\n        }\\n        return count;\\n    }\\n\\n    int t[102][102][602];\\n\\n    int helper(vector<string> & strs, int m, int n, int ind){\\n         // Base Condition\\n        if(ind ==strs.size() || (m==0 && n==0)) return 0;\\n\\n        // Calcualte number of ones and zeros in the string\\n        int zeros=noZeros(strs[ind]);\\n        int ones=noOnes(strs[ind]);\\n\\n        int choose= 0;\\n        if( t[m][n][ind] != -1 ){\\n            return t[m][n][ind];\\n        }\\n\\n        if( zeros <= m && ones <= n ){\\n            t[m][n][ind] = max( helper( strs, m, n, ind+1), 1 + helper( strs, m-zeros, n-ones, ind+1));\\n        }\\n        else if( zeros > m || ones > n)\\n            t[m][n][ind] = helper( strs, m, n, ind+1 );\\n\\n        return t[m][n][ind];\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(t,-1, sizeof(t));\\n        return helper(strs, m, n, 0);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180702,
                "title": "easy-c-dp-2-solutions",
                "content": "#### **Top Down DP**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    \\n    int helper(vector<string>&str, int m, int n, int pos){\\n        if(pos == str.size()) return 0;\\n        if(dp[pos][m][n] != -1) return dp[pos][m][n];\\n        int ones = count(str[pos].begin(), str[pos].end(), \\'1\\');\\n        int zeros = str[pos].size()-ones;\\n        if(ones<=n and zeros<=m)\\n            return dp[pos][m][n] = max(helper(str,m-zeros, n-ones,pos+1)+1, helper(str,m,n,pos+1));\\n        return dp[pos][m][n] = helper(str,m,n,pos+1);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        dp.resize(strs.size(), vector<vector<int>>(m+1, vector<int>(n+1, -1)));\\n        return helper(strs,m,n,0);\\n    }\\n};\\n```\\n\\n#### **Bottom Up DP**\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size()+1, vector<vector<int>> (m+1, vector<int>(n+1,0)));\\n        for(int i=1; i<=strs.size(); ++i){\\n            int zeros = count(strs[i-1].begin(), strs[i-1].end(),\\'0\\');\\n            int ones = strs[i-1].size()-zeros;\\n            for(int j=0; j<=m; ++j)\\n                for(int k=0; k<=n; ++k){\\n                    if(zeros<=j and ones<=k)\\n                        dp[i][j][k] = max(dp[i-1][j-zeros][k-ones]+1, dp[i-1][j][k]);\\n                    else\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                }\\n        }\\n        return dp[strs.size()][m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    \\n    int helper(vector<string>&str, int m, int n, int pos){\\n        if(pos == str.size()) return 0;\\n        if(dp[pos][m][n] != -1) return dp[pos][m][n];\\n        int ones = count(str[pos].begin(), str[pos].end(), \\'1\\');\\n        int zeros = str[pos].size()-ones;\\n        if(ones<=n and zeros<=m)\\n            return dp[pos][m][n] = max(helper(str,m-zeros, n-ones,pos+1)+1, helper(str,m,n,pos+1));\\n        return dp[pos][m][n] = helper(str,m,n,pos+1);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        dp.resize(strs.size(), vector<vector<int>>(m+1, vector<int>(n+1, -1)));\\n        return helper(strs,m,n,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size()+1, vector<vector<int>> (m+1, vector<int>(n+1,0)));\\n        for(int i=1; i<=strs.size(); ++i){\\n            int zeros = count(strs[i-1].begin(), strs[i-1].end(),\\'0\\');\\n            int ones = strs[i-1].size()-zeros;\\n            for(int j=0; j<=m; ++j)\\n                for(int k=0; k<=n; ++k){\\n                    if(zeros<=j and ones<=k)\\n                        dp[i][j][k] = max(dp[i-1][j-zeros][k-ones]+1, dp[i-1][j][k]);\\n                    else\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                }\\n        }\\n        return dp[strs.size()][m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065354,
                "title": "python-o-ssl-space-o-ssl-sl-time-using-array-100",
                "content": "I know my solution could be not so clean at first, and the code is really loooong. \\nIf you want the \"rigth\" solution, probably it is better see a dp solution. \\nMy (crazy?) idea was:\\n* create a list of pair with the number of 0\\'s and 1\\'s in every string\\n* order the list based on the number of 0\\'s\\n\\t* loop on the ordered list and collect all the set that have at most m 0\\'s and n 1\\'s \\n\\t* update the max set length\\n* order the list based on the number of 1\\'s\\n\\t* loop on the ordered list and collect all the set that have at most m 0\\'s and n 1\\'s \\n\\t* update the max set length\\n\\nI cannot use m and n, so lets say Ssl = lenght of the strs array, total number of strings\\nand Sl = length of the single string\\nWe have O(Ssl * Sl) time for create the list of pairs and  O(Ssl * log(Ssl)) every time we have to order it, but with the problem constraints Ssl * Sl > Ssl * log(Ssl) so the time complexity is **O(Ssl * Sl)**.\\nWe need extra space to save the list of pairs so a space complexity of **O(Ssl)**\\n\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        ans = 0\\n        strDigitsCount = []\\n        for s in strs:\\n            cur0 = 0\\n            cur1 = 0\\n            for c in s:\\n                if c==\\'0\\':\\n                    cur0 += 1\\n                if c==\\'1\\':\\n                    cur1 += 1\\n            strDigitsCount.append([cur0, cur1])\\n        strDigitsCount = sorted(strDigitsCount, key=lambda x: x[0])    \\n        for i  in range(len(strs)):\\n            cur0 = m\\n            cur1 = n\\n            curSetLength = 0\\n            for j in range(i, len(strs)):\\n                if cur0 >= strDigitsCount[j][0] and cur1 >= strDigitsCount[j][1]:\\n                    curSetLength += 1\\n                    cur0 -= strDigitsCount[j][0]\\n                    cur1 -= strDigitsCount[j][1]\\n                    \\n            ans = max(ans, curSetLength)\\n        strDigitsCount = sorted(strDigitsCount, key=lambda x: x[1])  \\n        for i  in range(len(strs)):\\n            cur0 = m\\n            cur1 = n\\n            curSetLength = 0\\n            for j in range(i, len(strs)):\\n                if cur0 >= strDigitsCount[j][0] and cur1 >= strDigitsCount[j][1]:\\n                    curSetLength += 1\\n                    cur0 -= strDigitsCount[j][0]\\n                    cur1 -= strDigitsCount[j][1]\\n\\n            ans = max(ans, curSetLength)\\n        return ans\\n```\\nI am happy also with the result after the submit: \\n![image](https://assets.leetcode.com/users/images/df319f07-03d3-40de-899e-eee5d8e7935a_1653273770.510769.jpeg)\\n\\nIf I did some mistakes, please feel free to correct me :)",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        ans = 0\\n        strDigitsCount = []\\n        for s in strs:\\n            cur0 = 0\\n            cur1 = 0\\n            for c in s:\\n                if c==\\'0\\':\\n                    cur0 += 1\\n                if c==\\'1\\':\\n                    cur1 += 1\\n            strDigitsCount.append([cur0, cur1])\\n        strDigitsCount = sorted(strDigitsCount, key=lambda x: x[0])    \\n        for i  in range(len(strs)):\\n            cur0 = m\\n            cur1 = n\\n            curSetLength = 0\\n            for j in range(i, len(strs)):\\n                if cur0 >= strDigitsCount[j][0] and cur1 >= strDigitsCount[j][1]:\\n                    curSetLength += 1\\n                    cur0 -= strDigitsCount[j][0]\\n                    cur1 -= strDigitsCount[j][1]\\n                    \\n            ans = max(ans, curSetLength)\\n        strDigitsCount = sorted(strDigitsCount, key=lambda x: x[1])  \\n        for i  in range(len(strs)):\\n            cur0 = m\\n            cur1 = n\\n            curSetLength = 0\\n            for j in range(i, len(strs)):\\n                if cur0 >= strDigitsCount[j][0] and cur1 >= strDigitsCount[j][1]:\\n                    curSetLength += 1\\n                    cur0 -= strDigitsCount[j][0]\\n                    cur1 -= strDigitsCount[j][1]\\n\\n            ans = max(ans, curSetLength)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568406,
                "title": "recursion-memo-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n//     RECURSIVE\\n    int solve(vector<string>& strs, int m, int n,int i){\\n        if(i==strs.size() || m<0 || n<0) return 0;\\n        if(m==0 && n==0) return 0;\\n        int zeros = count(strs[i].begin(),strs[i].end(),\\'0\\');\\n        int ones = strs[i].length()-zeros;\\n        if(zeros<=m && ones<=n) return max(solve(strs,m,n,i+1) , solve(strs,m-zeros,n-ones,i+1)+1);\\n        else return solve(strs,m,n,i+1);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return solve(strs,m,n,0);      \\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n//     MEMO\\n    int solve(vector<string>& strs, int m, int n,int i,vector<vector< vector<int>>>& memo){\\n        if(i==strs.size() || m<0 || n<0) return 0;\\n        if(m==0 && n==0) return 0;\\n        if(memo[i][m][n]!=-1) return memo[i][m][n];\\n        int zeros = count(strs[i].begin(),strs[i].end(),\\'0\\');\\n        int ones = strs[i].length()-zeros;\\n        if(zeros<=m && ones<=n) return memo[i][m][n] = max(solve(strs,m,n,i+1,memo) , solve(strs,m-zeros,n-ones,i+1,memo)+1);\\n        else return memo[i][m][n] = solve(strs,m,n,i+1,memo);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\nvector<vector< vector<int> > > memo(strs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return solve(strs,m,n,0,memo);      \\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n//     DP\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for (auto &s: strs) {\\n            int ones = count(s.begin(), s.end(), \\'1\\');\\n            int zeros= s.size()-ones;\\n            for (int i=m; i>=zeros; i--) \\n                for (int j=n; j>=ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1); //reject or accept whichever is max\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     RECURSIVE\\n    int solve(vector<string>& strs, int m, int n,int i){\\n        if(i==strs.size() || m<0 || n<0) return 0;\\n        if(m==0 && n==0) return 0;\\n        int zeros = count(strs[i].begin(),strs[i].end(),\\'0\\');\\n        int ones = strs[i].length()-zeros;\\n        if(zeros<=m && ones<=n) return max(solve(strs,m,n,i+1) , solve(strs,m-zeros,n-ones,i+1)+1);\\n        else return solve(strs,m,n,i+1);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return solve(strs,m,n,0);      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//     MEMO\\n    int solve(vector<string>& strs, int m, int n,int i,vector<vector< vector<int>>>& memo){\\n        if(i==strs.size() || m<0 || n<0) return 0;\\n        if(m==0 && n==0) return 0;\\n        if(memo[i][m][n]!=-1) return memo[i][m][n];\\n        int zeros = count(strs[i].begin(),strs[i].end(),\\'0\\');\\n        int ones = strs[i].length()-zeros;\\n        if(zeros<=m && ones<=n) return memo[i][m][n] = max(solve(strs,m,n,i+1,memo) , solve(strs,m-zeros,n-ones,i+1,memo)+1);\\n        else return memo[i][m][n] = solve(strs,m,n,i+1,memo);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\nvector<vector< vector<int> > > memo(strs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return solve(strs,m,n,0,memo);      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//     DP\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for (auto &s: strs) {\\n            int ones = count(s.begin(), s.end(), \\'1\\');\\n            int zeros= s.size()-ones;\\n            for (int i=m; i>=zeros; i--) \\n                for (int j=n; j>=ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1); //reject or accept whichever is max\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391327,
                "title": "python-top-down-recursive-with-memo-explained-and-visualized",
                "content": "**[1] Top-down recursive with memoization**\\n\\t*| Runtime: 3638 ms, faster than 43.21% of Python3 |*\\n\\n- Classical 01 knapsack - optimize (maximize) value (lenght of substring) within capacity constrain\\n\\n**Time:** O(l*m*n)\\n**Space:** Size of memo dict = O(m*n*l)\\n\\n\\n- At every node we consider both excludsion and inclusion, build your binary solution tree\\n- As you can see in the space tree, we actually do not care about the length of the path\\n\\t- as in we don\\'t just simply count the edges from root to leaf)\\n\\t- but rather, the number of times we have included a new node \\n\\t- **The max number of successful inclusions (along a path)** is what we need to return\\n\\nSee the two illustarted examples below for better understanding:\\n- **Example 1:** `[\"10\",\"0001\",\"111001\",\"1\",\"0\"] 5, 3`\\n![image](https://assets.leetcode.com/users/images/4800089f-fbb8-44ad-89c4-319866c66b19_1628429755.4255652.jpeg)\\n\\n- **Example 2:** `[\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4, 3`\\n![image](https://assets.leetcode.com/users/images/9b98f27d-8eb3-4781-89b1-7bc55fd86222_1628429772.9346228.jpeg)\\n\\n**Code:**\\n```\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\t# -- helper\\n\\tdef recurse(curM, curN, i):\\n\\t\\tif i > len(strs)-1: # end of path\\n\\t\\t\\treturn 0\\n\\n\\t\\tif curM < 0 or curN < 0:\\n\\t\\t\\treturn 0\\n\\n\\t\\tif curM > m or curN > n: # indv nodes greater than capacity limit\\n\\t\\t\\treturn 0\\n\\n\\t\\tif (curM, curN, i) in memo:\\n\\t\\t\\treturn memo[(curM, curN, i)]\\n\\n\\t\\texclude = recurse(curM, curN, i+1)\\n\\t\\t# ----- NOTE [1]\\n\\t\\tif curM-edgeCost[i][0] >= 0 and curN-edgeCost[i][1] >= 0:\\n\\t\\t\\tinclude = 1 + recurse(curM-edgeCost[i][0], curN-edgeCost[i][1], i+1)\\n\\t\\telse:\\n\\t\\t\\tinclude = 0\\n\\n\\t\\tresult = max(include, exclude)\\n\\n\\t\\tmemo[(curM, curN, i)] = result\\n\\t\\treturn result\\n\\n\\t# -- main\\n\\t# peprocess each str to its equivalent freq tuple of 0,1\\n\\tedgeCost = []\\n\\tfor s in strs:\\n\\t\\tzeros, ones = 0, 0\\n\\t\\tfor ch in s:\\n\\t\\t\\tif ch == \"0\":\\n\\t\\t\\t\\tzeros += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tones += 1\\n\\t\\tedgeCost.append([zeros, ones])\\n\\n\\tmemo = {}\\n\\treturn recurse(m, n, 0) # m, n, i\\n```\\n\\n**NOTE [1]**\\n- We should be incrementing the size of the subset (aka path from root to leaf) **only** when the child node (aka. (curM-edgeCost[i][0], curM-edgeCost[i][1], i+1) ) is valid (aka neither curM, or curN should be less than zero)\\n\\n- Initially I did the mistake of passing the next node to the recursive function wihtout checking\\nits validitiy and would delay the check when the child node becomes my current node. The validity check:\\n\\n\\t```\\n\\tif curM > m or curN > n: # indv nodes greater than capacity limit\\n\\t\\treturn 0\\n\\t```\\n\\n- However checking the validity of the node after passing the node to the recursive function is too late becaue the result has already been incremented and even if I capture the invalid node later, the path size would have been incremented already and hence not be accurate\\n\\t```\\n\\tmax(\\n\\t\\t1 + recurse(curM-strsFreq[i][0], curN-strsFreq[i][1], i+1),\\n\\t\\trecurse(curM, curN, i+1)\\n\\t\\t)\\n\\t```\\n\\n- Since we are adding 1 (incrementing) at the same line where we call the recursive finction on the next layer, we should make sure the node is valid first before passing it to the recursive function",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\t# -- helper\\n\\tdef recurse(curM, curN, i):\\n\\t\\tif i > len(strs)-1: # end of path\\n\\t\\t\\treturn 0\\n\\n\\t\\tif curM < 0 or curN < 0:\\n\\t\\t\\treturn 0\\n\\n\\t\\tif curM > m or curN > n: # indv nodes greater than capacity limit\\n\\t\\t\\treturn 0\\n\\n\\t\\tif (curM, curN, i) in memo:\\n\\t\\t\\treturn memo[(curM, curN, i)]\\n\\n\\t\\texclude = recurse(curM, curN, i+1)\\n\\t\\t# ----- NOTE [1]\\n\\t\\tif curM-edgeCost[i][0] >= 0 and curN-edgeCost[i][1] >= 0:\\n\\t\\t\\tinclude = 1 + recurse(curM-edgeCost[i][0], curN-edgeCost[i][1], i+1)\\n\\t\\telse:\\n\\t\\t\\tinclude = 0\\n\\n\\t\\tresult = max(include, exclude)\\n\\n\\t\\tmemo[(curM, curN, i)] = result\\n\\t\\treturn result\\n\\n\\t# -- main\\n\\t# peprocess each str to its equivalent freq tuple of 0,1\\n\\tedgeCost = []\\n\\tfor s in strs:\\n\\t\\tzeros, ones = 0, 0\\n\\t\\tfor ch in s:\\n\\t\\t\\tif ch == \"0\":\\n\\t\\t\\t\\tzeros += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tones += 1\\n\\t\\tedgeCost.append([zeros, ones])\\n\\n\\tmemo = {}\\n\\treturn recurse(m, n, 0) # m, n, i\\n```\n```\\n\\tif curM > m or curN > n: # indv nodes greater than capacity limit\\n\\t\\treturn 0\\n\\t```\n```\\n\\tmax(\\n\\t\\t1 + recurse(curM-strsFreq[i][0], curN-strsFreq[i][1], i+1),\\n\\t\\trecurse(curM, curN, i+1)\\n\\t\\t)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1325213,
                "title": "c-easy-to-understand-commented-solution-with-dp-and-recursion-approach",
                "content": "Hi,\\nThis is simple dp and recursion. Only tricky part is that for every string we nned to store that ```ith``` string has ```v[i].first 0\\'s and v[i].second 1\\'s``` and use similar to maximum subset sum less than target (m and n).\\n**If this helps please do UPVOTE or if you have any query or doubt COMMENT it down.**\\n```\\nclass Solution {\\npublic:\\n// initialize dp\\n    int dp[601][101][101];\\n    int solve(vector<pair<int,int>>& v,int ind,int m,int n){\\n        \\n        if(ind == v.size()) return 0;\\n        if(dp[ind][m][n]!=-1) return dp[ind][m][n];\\n\\t\\t\\n\\t\\t// if dont choose current indexed string\\n        int res = solve(v,ind+1,m,n);\\n        \\n\\t\\t// if we choose current indexed string\\n        if(m>=v[ind].first and n>=v[ind].second)\\n            res=max(res,1+solve(v,ind+1,m-v[ind].first,n-v[ind].second));\\n        return dp[ind][m][n] = res;\\n    }\\n    \\n    int findMaxForm(vector<string>& str, int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        int k=str.size();\\n        vector<pair<int,int>> v(k,{0,0});\\n        for(int i=0;i<k;i++){\\n            for(int j=0;j<str[i].size();j++){\\n                if(str[i][j]==\\'0\\') v[i].first++;\\n                else v[i].second++;\\n            }\\n        }\\n        \\n        return solve(v,0,m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```ith```\n```v[i].first 0\\'s and v[i].second 1\\'s```\n```\\nclass Solution {\\npublic:\\n// initialize dp\\n    int dp[601][101][101];\\n    int solve(vector<pair<int,int>>& v,int ind,int m,int n){\\n        \\n        if(ind == v.size()) return 0;\\n        if(dp[ind][m][n]!=-1) return dp[ind][m][n];\\n\\t\\t\\n\\t\\t// if dont choose current indexed string\\n        int res = solve(v,ind+1,m,n);\\n        \\n\\t\\t// if we choose current indexed string\\n        if(m>=v[ind].first and n>=v[ind].second)\\n            res=max(res,1+solve(v,ind+1,m-v[ind].first,n-v[ind].second));\\n        return dp[ind][m][n] = res;\\n    }\\n    \\n    int findMaxForm(vector<string>& str, int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        int k=str.size();\\n        vector<pair<int,int>> v(k,{0,0});\\n        for(int i=0;i<k;i++){\\n            for(int j=0;j<str[i].size();j++){\\n                if(str[i][j]==\\'0\\') v[i].first++;\\n                else v[i].second++;\\n            }\\n        }\\n        \\n        return solve(v,0,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175250,
                "title": "python-o-s-m-n-by-dp-w-comment",
                "content": "Python by DP\\n\\n---\\n\\n**Implementation** by DP in Python\\n\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        \\n        # dynamic programming table for subset making up to m zeros and n ones\\n        dp = [ [0 for _ in range(m+1)] for _ in range(n+1)]\\n        \\n        # scan each string\\n        for string in strs:\\n            \\n            # total zeros and ones of current string\\n            zeros = string.count(\\'0\\')\\n            ones = len(string) - zeros\\n            \\n            # check for each subcase\\n            for N in range( n, ones-1, -1):\\n                for M in range( m, zeros-1, -1):\\n                    \\n                    # maximize subset size from growing on smaller cases with string\\n                    dp[N][M] = max( 1 + dp[N-ones][M-zeros], dp[N][M])\\n                    \\n        \\n        return dp[n][m]\\n```\\n\\n---\\n\\n**Implementation** by Top-down DP with memo in Python\\n\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\n        len_table = [ [string.count(\\'0\\'), string.count(\\'1\\') ] for string in strs]\\n        \\n\\t\\t# use python native cache as memoization for DP\\n        @cache\\n        def dp(i, M, N):\\n            \\n            if i < 0:\\n                # Chose nothing from empty set\\n                return 0\\n            \\n            if i == 0:\\n                # Base case\\n                return int( (len_table[0][0] <= M) and (len_table[0][1] <= N) )\\n            \\n\\n            ## General cases:        \\n    \\n            # Case 1: i-th string is selected\\n            take_str_i = 0\\n            zeros_count, ones_count = len_table[i][0], len_table[i][1]\\n            \\n            if M >= zeros_count and N >= ones_count:\\n                take_str_i = 1 + dp(i-1, M-zeros_count, N-ones_count)\\n            \\n            # Case 2: i-th string is not selected\\n            not_to_take_str_i = 0 + dp(i-1, M, N)\\n            \\n            return max( take_str_i, not_to_take_str_i )\\n            \\n        # -------------------------------------------------------\\n        return dp( len(strs)-1, M=m, N=n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        \\n        # dynamic programming table for subset making up to m zeros and n ones\\n        dp = [ [0 for _ in range(m+1)] for _ in range(n+1)]\\n        \\n        # scan each string\\n        for string in strs:\\n            \\n            # total zeros and ones of current string\\n            zeros = string.count(\\'0\\')\\n            ones = len(string) - zeros\\n            \\n            # check for each subcase\\n            for N in range( n, ones-1, -1):\\n                for M in range( m, zeros-1, -1):\\n                    \\n                    # maximize subset size from growing on smaller cases with string\\n                    dp[N][M] = max( 1 + dp[N-ones][M-zeros], dp[N][M])\\n                    \\n        \\n        return dp[n][m]\\n```\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\n        len_table = [ [string.count(\\'0\\'), string.count(\\'1\\') ] for string in strs]\\n        \\n\\t\\t# use python native cache as memoization for DP\\n        @cache\\n        def dp(i, M, N):\\n            \\n            if i < 0:\\n                # Chose nothing from empty set\\n                return 0\\n            \\n            if i == 0:\\n                # Base case\\n                return int( (len_table[0][0] <= M) and (len_table[0][1] <= N) )\\n            \\n\\n            ## General cases:        \\n    \\n            # Case 1: i-th string is selected\\n            take_str_i = 0\\n            zeros_count, ones_count = len_table[i][0], len_table[i][1]\\n            \\n            if M >= zeros_count and N >= ones_count:\\n                take_str_i = 1 + dp(i-1, M-zeros_count, N-ones_count)\\n            \\n            # Case 2: i-th string is not selected\\n            not_to_take_str_i = 0 + dp(i-1, M, N)\\n            \\n            return max( take_str_i, not_to_take_str_i )\\n            \\n        # -------------------------------------------------------\\n        return dp( len(strs)-1, M=m, N=n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139575,
                "title": "c-dp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n){\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(auto &s:strs){\\n            int zeroes=0,ones=0;\\n            for(auto ch:s){\\n                if(ch==\\'0\\')zeroes++;\\n                else if(ch==\\'1\\')ones++;\\n            }\\n            for(int i=m;i>=zeroes;i--){\\n                for(int j=n; j>=ones;j--) dp[i][j]=max(dp[i][j],dp[i-zeroes][j-ones]+1);\\n            }\\n        }\\n  return dp[m][n];\\n}\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n){\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(auto &s:strs){\\n            int zeroes=0,ones=0;\\n            for(auto ch:s){\\n                if(ch==\\'0\\')zeroes++;\\n                else if(ch==\\'1\\')ones++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1139222,
                "title": "python-memoization",
                "content": "# Idea\\nFirst let\\'s count the zeros and ones in all of the strings. Then for each string, we can either use it if we have enough ones and zeros, or we can\\'t if our balance doesn\\'t allow it. Each scenario produces a subproblem which can itself be further deconstructed. We use `lru_cache` for memoization.\\n# Complexity\\nTime / Memory: O(len(strs) * m * n)\\n```\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\tcounts = []\\n\\tfor s in strs:\\n\\t\\tc = Counter(s)\\n\\t\\tcounts.append((c[\\'0\\'], c[\\'1\\']))\\n\\n\\t@lru_cache(None)\\n\\tdef findmax(i, l, o):\\n\\t\\tif l == 0 == o or i >= len(counts): return 0\\n\\t\\texcl = findmax(i+1, l, o)\\n\\t\\tzeros, ones = counts[i]\\n\\t\\tif l >= zeros and o >= ones:\\n\\t\\t    incl = 1 + findmax(i+1, l-zeros, o-ones)\\n\\t\\t\\treturn max(excl, incl)\\n\\t\\treturn excl\\n\\n\\treturn findmax(0, m, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n\\tcounts = []\\n\\tfor s in strs:\\n\\t\\tc = Counter(s)\\n\\t\\tcounts.append((c[\\'0\\'], c[\\'1\\']))\\n\\n\\t@lru_cache(None)\\n\\tdef findmax(i, l, o):\\n\\t\\tif l == 0 == o or i >= len(counts): return 0\\n\\t\\texcl = findmax(i+1, l, o)\\n\\t\\tzeros, ones = counts[i]\\n\\t\\tif l >= zeros and o >= ones:\\n\\t\\t    incl = 1 + findmax(i+1, l-zeros, o-ones)\\n\\t\\t\\treturn max(excl, incl)\\n\\t\\treturn excl\\n\\n\\treturn findmax(0, m, n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1138627,
                "title": "94-74-efficient-clean-dp-soln",
                "content": "```\\npublic class Solution {\\n    public int FindMaxForm(string[] strs, int maxZeros, int maxOnes) {\\n        int[,] dp = new int[maxZeros+1,maxOnes+1];\\n        int zeros,ones;\\n        for(int i=0;i<strs.Length;i++)\\n        {\\n            zeros = 0;\\n            for(int j=0;j<strs[i].Length;j++)\\n                if(strs[i][j]==\\'0\\')\\n                    zeros++;\\n            ones = strs[i].Length-zeros;\\n            \\n            for(int j=maxZeros;j>=zeros;j--)\\n                for(int k=maxOnes;k>=ones;k--)\\n                    dp[j,k]=Math.Max(dp[j,k],1+dp[j-zeros,k-ones]);\\n        }\\n        return dp[maxZeros,maxOnes];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindMaxForm(string[] strs, int maxZeros, int maxOnes) {\\n        int[,] dp = new int[maxZeros+1,maxOnes+1];\\n        int zeros,ones;\\n        for(int i=0;i<strs.Length;i++)\\n        {\\n            zeros = 0;\\n            for(int j=0;j<strs[i].Length;j++)\\n                if(strs[i][j]==\\'0\\')\\n                    zeros++;\\n            ones = strs[i].Length-zeros;\\n            \\n            for(int j=maxZeros;j>=zeros;j--)\\n                for(int k=maxOnes;k>=ones;k--)\\n                    dp[j,k]=Math.Max(dp[j,k],1+dp[j-zeros,k-ones]);\\n        }\\n        return dp[maxZeros,maxOnes];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609509,
                "title": "python-a-summary-of-3-recursive-and-2-dp-solutions",
                "content": "```PY\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# 1) DFS without memorization\\n        self.rst = 0\\n        strs = sorted(strs, key=len)\\n        def dfs(start, m, n, cur):\\n            self.rst = max(self.rst, cur)\\n            if start == len(strs) or len(strs[start]) > m + n:\\n                return\\n            \\n            for i in range(start, len(strs)):\\n                zeros, ones = strs[i].count(\\'0\\'), strs[i].count(\\'1\\')\\n                if m - zeros >= 0 and n - ones >= 0:\\n                    dfs(i + 1, m - zeros, n - ones, cur + 1)\\n                    \\n        dfs(0, m, n, 0)\\n        return self.rst\\n\\t\\t\\n\\t\\t# 2) DFS + memorization, subset is implemented by for loops\\n        strs = sorted(strs, key=len)\\n        mem = [[[0] * (n + 1) for _ in xrange(m + 1)] for _ in xrange(len(strs) + 1)]\\n        def dfs(start, m, n):\\n            if start == len(strs) or len(strs[start]) > m + n:\\n                return 0\\n            if mem[start][m][n] != 0:\\n                return mem[start][m][n]\\n            \\n            rst = 0\\n            for i in xrange(start, len(strs)):\\n                zeros, ones = strs[i].count(\\'0\\'), strs[i].count(\\'1\\')\\n                if m - zeros >= 0 and n - ones >= 0:\\n                    # rst = max(rst, dfs(i + 1, m - zeros, n - ones) + 1)\\n                    rst = max(rst, dfs(i + 1, m - zeros, n - ones) + 1)\\n            mem[start][m][n] = rst\\n            return mem[start][m][n]\\n            \\n        return dfs(0, m, n)\\n\\t\\t\\n\\t\\t# 3) DFS + memorization, subset is implemented by taken/not taken each position\\n        mem = [[[0] * (n + 1) for _ in xrange(m + 1)] for _ in xrange(len(strs) + 1)]\\n        def dfs(start, m, n):\\n            if start == len(strs):\\n                return 0\\n            if mem[start][m][n] != 0:\\n                return mem[start][m][n]\\n            \\n            taken, not_taken = 0, 0\\n            zeros, ones = strs[start].count(\\'0\\'), strs[start].count(\\'1\\')\\n            if m - zeros >= 0 and n - ones >= 0:\\n                taken = dfs(start + 1, m - zeros, n - ones) + 1\\n            not_taken = dfs(start + 1, m, n)\\n            mem[start][m][n] = max(taken, not_taken)\\n            return mem[start][m][n]\\n        return dfs(0, m, n)\\n\\t\\t\\n\\t\\t# 4) 3d-DP: dp[i][j][k]: former i strings with j and k zeros and ones used, how many can be constructed\\n        dp = [[[0] * (n + 1) for _ in xrange(m + 1)] for _ in xrange(len(strs) + 1)]\\n        for i in range(1, len(strs) + 1):   # former i strings\\n            zeros, ones = strs[i - 1].count(\\'0\\'), strs[i - 1].count(\\'1\\')\\n            for j in range(m + 1):          # zeros\\n                for k in range(n + 1):      # ones\\n                    if j - zeros >= 0 and k - ones >= 0:\\n                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)\\n                    else:\\n                        dp[i][j][k] = dp[i - 1][j][k]\\n        return dp[len(strs)][m][n]\\n\\t\\t\\n        # 5) 3d-DP optimized to 2D space: dp[j][k]: i dimension is optimized to be used in-place\\n        # Notice the j and k should be changed to update FROM LARGER TO SMALLER\\n        dp = [[0] * (n + 1) for _ in xrange(m + 1)]\\n        for i in xrange(len(strs)):                    # index i string\\n            zeros, ones = strs[i].count(\\'0\\'), strs[i].count(\\'1\\')\\n            for j in xrange(m, zeros - 1, -1):         # zeros\\n                for k in xrange(n, ones - 1, -1):      # ones\\n                    dp[j][k] = max(dp[j][k], dp[j - zeros][k - ones] + 1)\\n        return dp[m][n]\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```PY\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# 1) DFS without memorization\\n        self.rst = 0\\n        strs = sorted(strs, key=len)\\n        def dfs(start, m, n, cur):\\n            self.rst = max(self.rst, cur)\\n            if start == len(strs) or len(strs[start]) > m + n:\\n                return\\n            \\n            for i in range(start, len(strs)):\\n                zeros, ones = strs[i].count(\\'0\\'), strs[i].count(\\'1\\')\\n                if m - zeros >= 0 and n - ones >= 0:\\n                    dfs(i + 1, m - zeros, n - ones, cur + 1)\\n                    \\n        dfs(0, m, n, 0)\\n        return self.rst\\n\\t\\t\\n\\t\\t# 2) DFS + memorization, subset is implemented by for loops\\n        strs = sorted(strs, key=len)\\n        mem = [[[0] * (n + 1) for _ in xrange(m + 1)] for _ in xrange(len(strs) + 1)]\\n        def dfs(start, m, n):\\n            if start == len(strs) or len(strs[start]) > m + n:\\n                return 0\\n            if mem[start][m][n] != 0:\\n                return mem[start][m][n]\\n            \\n            rst = 0\\n            for i in xrange(start, len(strs)):\\n                zeros, ones = strs[i].count(\\'0\\'), strs[i].count(\\'1\\')\\n                if m - zeros >= 0 and n - ones >= 0:\\n                    # rst = max(rst, dfs(i + 1, m - zeros, n - ones) + 1)\\n                    rst = max(rst, dfs(i + 1, m - zeros, n - ones) + 1)\\n            mem[start][m][n] = rst\\n            return mem[start][m][n]\\n            \\n        return dfs(0, m, n)\\n\\t\\t\\n\\t\\t# 3) DFS + memorization, subset is implemented by taken/not taken each position\\n        mem = [[[0] * (n + 1) for _ in xrange(m + 1)] for _ in xrange(len(strs) + 1)]\\n        def dfs(start, m, n):\\n            if start == len(strs):\\n                return 0\\n            if mem[start][m][n] != 0:\\n                return mem[start][m][n]\\n            \\n            taken, not_taken = 0, 0\\n            zeros, ones = strs[start].count(\\'0\\'), strs[start].count(\\'1\\')\\n            if m - zeros >= 0 and n - ones >= 0:\\n                taken = dfs(start + 1, m - zeros, n - ones) + 1\\n            not_taken = dfs(start + 1, m, n)\\n            mem[start][m][n] = max(taken, not_taken)\\n            return mem[start][m][n]\\n        return dfs(0, m, n)\\n\\t\\t\\n\\t\\t# 4) 3d-DP: dp[i][j][k]: former i strings with j and k zeros and ones used, how many can be constructed\\n        dp = [[[0] * (n + 1) for _ in xrange(m + 1)] for _ in xrange(len(strs) + 1)]\\n        for i in range(1, len(strs) + 1):   # former i strings\\n            zeros, ones = strs[i - 1].count(\\'0\\'), strs[i - 1].count(\\'1\\')\\n            for j in range(m + 1):          # zeros\\n                for k in range(n + 1):      # ones\\n                    if j - zeros >= 0 and k - ones >= 0:\\n                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)\\n                    else:\\n                        dp[i][j][k] = dp[i - 1][j][k]\\n        return dp[len(strs)][m][n]\\n\\t\\t\\n        # 5) 3d-DP optimized to 2D space: dp[j][k]: i dimension is optimized to be used in-place\\n        # Notice the j and k should be changed to update FROM LARGER TO SMALLER\\n        dp = [[0] * (n + 1) for _ in xrange(m + 1)]\\n        for i in xrange(len(strs)):                    # index i string\\n            zeros, ones = strs[i].count(\\'0\\'), strs[i].count(\\'1\\')\\n            for j in xrange(m, zeros - 1, -1):         # zeros\\n                for k in xrange(n, ones - 1, -1):      # ones\\n                    dp[j][k] = max(dp[j][k], dp[j - zeros][k - ones] + 1)\\n        return dp[m][n]\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 364115,
                "title": "java-knapsack",
                "content": "1. Knapsack says - to choose or not\\n2. Keep the DP algo in mind - we have to go back \\'i-m1\\' and \\'j-n1\\' for checking\\n3. Update dp matrix with max of dp[i][j] and 1+dp[i-m1][j-n1] where m1 and n1 are the counts for 1 and 0 - in a sense m1 and n1 denote the VALUES wrt knapsack\\n\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n    \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for(String s:strs){\\n            int m1 = count(s,0);\\n            int n1 = count(s,1);\\n            for(int i=m;i>=m1;i--){\\n                for(int j=n;j>=n1;j--){\\n                    dp[i][j] = Math.max(dp[i][j],1+dp[i-m1][j-n1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    \\n    }\\n    \\n    public int count(String s, int a){\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)-\\'0\\' == a){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n    \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for(String s:strs){\\n            int m1 = count(s,0);\\n            int n1 = count(s,1);\\n            for(int i=m;i>=m1;i--){\\n                for(int j=n;j>=n1;j--){\\n                    dp[i][j] = Math.max(dp[i][j],1+dp[i-m1][j-n1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    \\n    }\\n    \\n    public int count(String s, int a){\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)-\\'0\\' == a){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95840,
                "title": "evolve-from-brute-force-to-dp",
                "content": "1. O(2^k), try all the combinations.\\n```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        vector<pair<int,int>> ct(sz);\\n        for(int i=0;i<sz;i++) {\\n            int sn = strs[i].size(), z=0;\\n            for(char c:strs[i]) if(c=='0') z++;\\n            ct[i]=pair<int,int>(z,sn-z);\\n        }\\n        return dfs(0,m,n,ct);\\n    }\\n    int dfs(int p, int m, int n, vector<pair<int,int>>& ct) {\\n        if(m<0 || n<0) return -1;\\n        if(p==ct.size()) return 0; \\n        return max(dfs(p+1,m,n,ct), 1+dfs(p+1,m-ct[p].first,n-ct[p].second,ct));\\n    }\\n```\\n2. O(kmn) memoization and dp O(kmn) space\\n```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        vector<pair<int,int>> ct(sz);\\n        for(int i=0;i<sz;i++) {\\n            int sn = strs[i].size(), z=0;\\n            for(char c:strs[i]) if(c=='0') z++;\\n            ct[i]=pair<int,int>(z,sn-z);\\n        }\\n        vector<vector<vector<int>>> mem(sz,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return dfs(0,m,n,ct,mem);\\n    }\\n    int dfs(int p, int m, int n, vector<pair<int,int>>& ct,vector<vector<vector<int>>>& mem) {\\n        if(m<0 || n<0) return -1;\\n        if(p==ct.size()) return 0;\\n        if(mem[p][m][n]>-1) return mem[p][m][n];\\n        return mem[p][m][n]=max(dfs(p+1,m,n,ct,mem), 1+dfs(p+1,m-ct[p].first,n-ct[p].second,ct,mem));\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        vector<vector<vector<int>>> mem(sz+1,vector<vector<int>>(m+1,vector<int>(n+1)));\\n        for(int i=sz-1;i>=0;i--) { \\n            int z=count(strs[i].begin(),strs[i].end(),'0');\\n            for(int j=0;j<=m;j++) \\n                for(int k=0;k<=n;k++)\\n                    mem[i][j][k] = j>=z&& k>= strs[i].size()-z ? \\n                        max(mem[i+1][j][k], 1+mem[i+1][j-z][k-strs[i].size()+z]) : mem[i+1][j][k];\\n        }\\n        return mem[0][m][n];\\n    }\\n```\\n3. O(mn) space dp. In the above dp solution, the current state i only depends on state i+1, this means we only need to cache two states of i. In fact, we only need to cache 1 state of i by updating from m, n to 0. Because the we need the m-zero, n-one state value from the previous state. The great idea is from [@yangluphil](https://discuss.leetcode.com/topic/71438/c-dp-solution-with-comments).\\n```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> mem(m+1,vector<int>(n+1));\\n        for(string &s:strs) { \\n            int z=count(s.begin(),s.end(),'0');\\n            for(int i=m;i>=z;i--) \\n                for(int j=n;j>=(int)s.size()-z;j--) \\n                    mem[i][j] = max(mem[i][j], 1+mem[i-z][j-s.size()+z]);\\n        }\\n        return mem[m][n];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        vector<pair<int,int>> ct(sz);\\n        for(int i=0;i<sz;i++) {\\n            int sn = strs[i].size(), z=0;\\n            for(char c:strs[i]) if(c=='0') z++;\\n            ct[i]=pair<int,int>(z,sn-z);\\n        }\\n        return dfs(0,m,n,ct);\\n    }\\n    int dfs(int p, int m, int n, vector<pair<int,int>>& ct) {\\n        if(m<0 || n<0) return -1;\\n        if(p==ct.size()) return 0; \\n        return max(dfs(p+1,m,n,ct), 1+dfs(p+1,m-ct[p].first,n-ct[p].second,ct));\\n    }\\n```\n```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        vector<pair<int,int>> ct(sz);\\n        for(int i=0;i<sz;i++) {\\n            int sn = strs[i].size(), z=0;\\n            for(char c:strs[i]) if(c=='0') z++;\\n            ct[i]=pair<int,int>(z,sn-z);\\n        }\\n        vector<vector<vector<int>>> mem(sz,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return dfs(0,m,n,ct,mem);\\n    }\\n    int dfs(int p, int m, int n, vector<pair<int,int>>& ct,vector<vector<vector<int>>>& mem) {\\n        if(m<0 || n<0) return -1;\\n        if(p==ct.size()) return 0;\\n        if(mem[p][m][n]>-1) return mem[p][m][n];\\n        return mem[p][m][n]=max(dfs(p+1,m,n,ct,mem), 1+dfs(p+1,m-ct[p].first,n-ct[p].second,ct,mem));\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        vector<vector<vector<int>>> mem(sz+1,vector<vector<int>>(m+1,vector<int>(n+1)));\\n        for(int i=sz-1;i>=0;i--) { \\n            int z=count(strs[i].begin(),strs[i].end(),'0');\\n            for(int j=0;j<=m;j++) \\n                for(int k=0;k<=n;k++)\\n                    mem[i][j][k] = j>=z&& k>= strs[i].size()-z ? \\n                        max(mem[i+1][j][k], 1+mem[i+1][j-z][k-strs[i].size()+z]) : mem[i+1][j][k];\\n        }\\n        return mem[0][m][n];\\n    }\\n```\n```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> mem(m+1,vector<int>(n+1));\\n        for(string &s:strs) { \\n            int z=count(s.begin(),s.end(),'0');\\n            for(int i=m;i>=z;i--) \\n                for(int j=n;j>=(int)s.size()-z;j--) \\n                    mem[i][j] = max(mem[i][j], 1+mem[i-z][j-s.size()+z]);\\n        }\\n        return mem[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95842,
                "title": "accepted-greedy-algorithm",
                "content": "[UPDATE]:\\nThis is not a working solution as pointed out by @andhddn below. \\n\\nI have a greedy algorithm that is accepted. Can't prove the correctness though. Main idea is to use the shortest string first. We sort all the string based on the number of 1s it has once, and then based on the 0s second time. Each time we try to consume as much string as possible. Result is the bigger of the 2 iterations. \\n\\nAny counter example/ proof of correctness is appreciated\\n\\n```\\npublic class Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int result = 0;\\n        if(strs.length == 0) return 0;\\n        PriorityQueue<Element> oneQueue = new PriorityQueue<Element>(new oneComparator());\\n        PriorityQueue<Element> zeroQueue = new PriorityQueue<Element>(new zeroComparator());\\n        \\n        for(String s : strs){\\n            int ones = 0;\\n            int zeros = 0;\\n            for(char c : s.toCharArray()){\\n                if(c == '0') {\\n                    zeros++;\\n                }else{\\n                    ones++;\\n                }\\n            }\\n            Element e = new Element(ones, zeros);\\n            oneQueue.offer(e);\\n            zeroQueue.offer(e);\\n        }\\n        int numZero = m;\\n        int numOne = n;\\n        /*sort the string based on # of 0 each string has and try to consume as many string as possible*/\\n        while(!zeroQueue.isEmpty()){\\n            if(numZero >= zeroQueue.peek().zero && numOne >= zeroQueue.peek().one){\\n                result++;\\n                numZero -= zeroQueue.peek().zero;\\n                numOne -= zeroQueue.peek().one;\\n            }\\n\\n            zeroQueue.poll();\\n        }\\n        int secondResult = 0;\\n        numZero = m;\\n        numOne = n;\\n        /*sort the string based on # of 1 each string has and try to consume as many string as possible*/\\n        while(!oneQueue.isEmpty()){\\n            if(numOne >= oneQueue.peek().one && numZero >= oneQueue.peek().zero){\\n                secondResult++;\\n                numZero -= oneQueue.peek().zero;\\n                numOne -= oneQueue.peek().one;\\n            }\\n\\n            oneQueue.poll();\\n            \\n        }        \\n        return Math.max(result, secondResult);\\n        \\n    }\\n    \\n    class oneComparator implements Comparator<Element>{\\n        public int compare(Element e1, Element e2){\\n            if(e1.one == e2.one) return e1.zero - e2.zero;\\n            return e1.one - e2.one;\\n        }\\n    }\\n    \\n    class zeroComparator implements Comparator<Element>{\\n        public int compare(Element e1, Element e2){\\n            if(e1.zero == e2.zero) return e1.one - e2.one;\\n            return e1.zero - e2.zero;\\n        }\\n    }\\n    \\n    class Element{\\n        public int one;\\n        public int zero;\\n\\n        public Element(int one, int zero){\\n            this.one = one;\\n            this.zero = zero;\\n        }\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int result = 0;\\n        if(strs.length == 0) return 0;\\n        PriorityQueue<Element> oneQueue = new PriorityQueue<Element>(new oneComparator());\\n        PriorityQueue<Element> zeroQueue = new PriorityQueue<Element>(new zeroComparator());\\n        \\n        for(String s : strs){\\n            int ones = 0;\\n            int zeros = 0;\\n            for(char c : s.toCharArray()){\\n                if(c == '0') {\\n                    zeros++;\\n                }else{\\n                    ones++;\\n                }\\n            }\\n            Element e = new Element(ones, zeros);\\n            oneQueue.offer(e);\\n            zeroQueue.offer(e);\\n        }\\n        int numZero = m;\\n        int numOne = n;\\n        /*sort the string based on # of 0 each string has and try to consume as many string as possible*/\\n        while(!zeroQueue.isEmpty()){\\n            if(numZero >= zeroQueue.peek().zero && numOne >= zeroQueue.peek().one){\\n                result++;\\n                numZero -= zeroQueue.peek().zero;\\n                numOne -= zeroQueue.peek().one;\\n            }\\n\\n            zeroQueue.poll();\\n        }\\n        int secondResult = 0;\\n        numZero = m;\\n        numOne = n;\\n        /*sort the string based on # of 1 each string has and try to consume as many string as possible*/\\n        while(!oneQueue.isEmpty()){\\n            if(numOne >= oneQueue.peek().one && numZero >= oneQueue.peek().zero){\\n                secondResult++;\\n                numZero -= oneQueue.peek().zero;\\n                numOne -= oneQueue.peek().one;\\n            }\\n\\n            oneQueue.poll();\\n            \\n        }        \\n        return Math.max(result, secondResult);\\n        \\n    }\\n    \\n    class oneComparator implements Comparator<Element>{\\n        public int compare(Element e1, Element e2){\\n            if(e1.one == e2.one) return e1.zero - e2.zero;\\n            return e1.one - e2.one;\\n        }\\n    }\\n    \\n    class zeroComparator implements Comparator<Element>{\\n        public int compare(Element e1, Element e2){\\n            if(e1.zero == e2.zero) return e1.one - e2.one;\\n            return e1.zero - e2.zero;\\n        }\\n    }\\n    \\n    class Element{\\n        public int one;\\n        public int zero;\\n\\n        public Element(int one, int zero){\\n            this.one = one;\\n            this.zero = zero;\\n        }\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3724291,
                "title": "recursion-memoization-dp-tabulation-dp-optimization-easy-c",
                "content": "# 1. Naive Recursive approach (TLE)\\n- Time complexity: O(2^i)\\n   // i is size of the strs\\n- Space complexity: Stack Space = O(i)\\n```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int solve(int i, vector<string>& strs, int m, int n){\\n        if(i==0){\\n            return 0;\\n        }\\n        int o=ones(strs[i-1]);\\n        int z=strs[i-1].size()-o;\\n\\n        if(o<=n && z<=m){\\n            return max(solve(i-1, strs, m-z, n-o)+1, solve(i-1, strs, m, n));\\n        }\\n        else return solve(i-1, strs, m, n);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return solve(strs.size(), strs, m, n);\\n    }\\n};\\n\\n```\\n# 2. Memoization(DP)\\n- Time complexity: O(i * m * n) \\n- Space complexity: O(i * m * n) +Stack Space\\n\\n```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int solve(int i, vector<string>& strs, int m, int n, vector<vector<vector<int>>>&dp){\\n        if(i==0){\\n            return 0;\\n        }\\n        if(dp[i][m][n]!=-1) return dp[i][m][n];\\n        int o=ones(strs[i-1]);\\n        int z=strs[i-1].size()-o;\\n\\n        if(o<=n && z<=m){\\n            return dp[i][m][n]= max(solve(i-1, strs, m-z, n-o, dp)+1, solve(i-1, strs, m, n, dp));\\n        }\\n        else return dp[i][m][n]=solve(i-1, strs, m, n, dp);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n       \\n        vector<vector<vector<int>>>dp(strs.size()+1, vector<vector<int>>(m+1, vector<int>(n+1, -1)));\\n        return solve(strs.size(), strs, m, n, dp);\\n    }\\n};\\n\\n```\\n\\n# 3. Tabulation(DP)\\n- Time complexity: O(i * m * n) \\n- Space complexity: O(i * m * n) \\n\\n```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>>dp(strs.size()+1, vector<vector<int>>(m+1, vector<int>(n+1, 0)));\\n        int q=strs.size();\\n        for(int i=1;i<=q;i++){\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    int o=ones(strs[i-1]);\\n                    int z=strs[i-1].size()-o;\\n                    if(z<=j && o<=k){\\n                        dp[i][j][k]=max(1+dp[i-1][j-z][k-o], dp[i-1][j][k]);\\n                    }\\n                    else dp[i][j][k]=dp[i-1][j][k];\\n                }\\n            }\\n        }\\n        return dp[q][m][n];\\n    }\\n};\\n```\\n\\n# 4. Optimized Space (BEST Approach)\\n- Time complexity: O(i * m * n) \\n- Space complexity: O(m * n)\\n\\n```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>>curr(m+1, vector<int>(n+1, 0)), prev(m+1, vector<int>(n+1, 0));\\n        int q=strs.size();\\n        for(int i=1;i<=q;i++){\\n            int o=ones(strs[i-1]);\\n            int z=strs[i-1].size()-o;\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    if(z<=j && o<=k){\\n                        curr[j][k]=max(1+prev[j-z][k-o], prev[j][k]);\\n                    }\\n                    else curr[j][k]=prev[j][k];\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return curr[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int solve(int i, vector<string>& strs, int m, int n){\\n        if(i==0){\\n            return 0;\\n        }\\n        int o=ones(strs[i-1]);\\n        int z=strs[i-1].size()-o;\\n\\n        if(o<=n && z<=m){\\n            return max(solve(i-1, strs, m-z, n-o)+1, solve(i-1, strs, m, n));\\n        }\\n        else return solve(i-1, strs, m, n);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return solve(strs.size(), strs, m, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int solve(int i, vector<string>& strs, int m, int n, vector<vector<vector<int>>>&dp){\\n        if(i==0){\\n            return 0;\\n        }\\n        if(dp[i][m][n]!=-1) return dp[i][m][n];\\n        int o=ones(strs[i-1]);\\n        int z=strs[i-1].size()-o;\\n\\n        if(o<=n && z<=m){\\n            return dp[i][m][n]= max(solve(i-1, strs, m-z, n-o, dp)+1, solve(i-1, strs, m, n, dp));\\n        }\\n        else return dp[i][m][n]=solve(i-1, strs, m, n, dp);\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n       \\n        vector<vector<vector<int>>>dp(strs.size()+1, vector<vector<int>>(m+1, vector<int>(n+1, -1)));\\n        return solve(strs.size(), strs, m, n, dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>>dp(strs.size()+1, vector<vector<int>>(m+1, vector<int>(n+1, 0)));\\n        int q=strs.size();\\n        for(int i=1;i<=q;i++){\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    int o=ones(strs[i-1]);\\n                    int z=strs[i-1].size()-o;\\n                    if(z<=j && o<=k){\\n                        dp[i][j][k]=max(1+dp[i-1][j-z][k-o], dp[i-1][j][k]);\\n                    }\\n                    else dp[i][j][k]=dp[i-1][j][k];\\n                }\\n            }\\n        }\\n        return dp[q][m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ones(string s){\\n        int count=0;\\n        int r=s.size();\\n        for(int j=0;j<r;j++){\\n            if(s[j]==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>>curr(m+1, vector<int>(n+1, 0)), prev(m+1, vector<int>(n+1, 0));\\n        int q=strs.size();\\n        for(int i=1;i<=q;i++){\\n            int o=ones(strs[i-1]);\\n            int z=strs[i-1].size()-o;\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    if(z<=j && o<=k){\\n                        curr[j][k]=max(1+prev[j-z][k-o], prev[j][k]);\\n                    }\\n                    else curr[j][k]=prev[j][k];\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return curr[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903738,
                "title": "c-memoization-3d-dp-simple-solution-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int backtrack(int ind,vector<string>&nums,int zero,int one,vector<vector<vector<int>>>&dp)\\n    {\\n        if(ind==nums.size()) return 0;\\n        if(dp[ind][zero][one]!=-1) return dp[ind][zero][one];\\n        int nonpick=backtrack(ind+1,nums,zero,one,dp);\\n        int pick=0;\\n        int z=0; int o=0;\\n        for(int i=0;i<nums[ind].length();i++)\\n        {\\n            if(nums[ind][i]==\\'1\\') o++;\\n            else z++;\\n        }\\n        if(zero>=z and one>=o)\\n            pick=1+backtrack(ind+1,nums,zero-z,one-o,dp);\\n        return dp[ind][zero][one]=max(pick,nonpick);\\n    }\\n    int findMaxForm(vector<string>& nums, int zero, int one) {\\n        int n = nums.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(zero+1,vector<int>(one+1,-1)));\\n        return backtrack(0,nums,zero,one,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int backtrack(int ind,vector<string>&nums,int zero,int one,vector<vector<vector<int>>>&dp)\\n    {\\n        if(ind==nums.size()) return 0;\\n        if(dp[ind][zero][one]!=-1) return dp[ind][zero][one];\\n        int nonpick=backtrack(ind+1,nums,zero,one,dp);\\n        int pick=0;\\n        int z=0; int o=0;\\n        for(int i=0;i<nums[ind].length();i++)\\n        {\\n            if(nums[ind][i]==\\'1\\') o++;\\n            else z++;\\n        }\\n        if(zero>=z and one>=o)\\n            pick=1+backtrack(ind+1,nums,zero-z,one-o,dp);\\n        return dp[ind][zero][one]=max(pick,nonpick);\\n    }\\n    int findMaxForm(vector<string>& nums, int zero, int one) {\\n        int n = nums.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(zero+1,vector<int>(one+1,-1)));\\n        return backtrack(0,nums,zero,one,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838022,
                "title": "python3-solution-knapsack-dp",
                "content": "# Complexity\\n- Time complexity: $$O(n * m * s.length)$$\\n- Space complexity: $$O(n * m)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def findMaxForm(self, S, M, N):\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for s in S:\\n            x, y = s.count(\\'1\\'), s.count(\\'0\\')\\n            for i in range(N - x, -1, -1):\\n                for j in range(M - y, -1, -1):\\n                    dp[i + x][j + y] = max(dp[i + x][j + y], dp[i][j] + 1)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution:\\n    def findMaxForm(self, S, M, N):\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for s in S:\\n            x, y = s.count(\\'1\\'), s.count(\\'0\\')\\n            for i in range(N - x, -1, -1):\\n                for j in range(M - y, -1, -1):\\n                    dp[i + x][j + y] = max(dp[i + x][j + y], dp[i][j] + 1)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421325,
                "title": "c-aditya-verma-solution-0-1-knapsack-based-easy-to-understand",
                "content": "<-- if u like this solution please upvote.\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n// create a 3d array  whose value change in the  function  index, m, n\\n    int t[601][101][101];\\n\\t\\n\\t// Recursion \\n    int solve(vector<string> &s, int m, int n, int index){\\n        int size= s.size();\\n\\t\\t// i.e index is reaches  to the end of the string   or either no. of 0\\'s  || 1\\'s value <0\\n        if(index>=size || m<0 || n<0) return 0;\\n        \\n\\t\\t// if both m , n ==0  \\n        if( m==0 && n==0)return 0;\\n\\t\\t\\n\\t\\t// if we already calculate the smaller problem so we will return form here  we don\\'t need to go further \\n        if(t[index][m][n]!=-1)return t[index][m][n];\\n\\t\\t\\n        int i= index;\\n\\t\\t// counting the No if Zeros in the string \\n        int zeros= count(s[i].begin(), s[i].end(),\\'0\\');\\n\\t\\t\\n\\t\\t// counting the No of ones in string  we simply   s[i].size()-zero  beacuse the string contains only  0\\'s and 1\\'s\\n        int ones= s[i].size()-zeros;\\n\\t\\t\\n        if(m-zeros >=0 && n-ones>=0){\\n\\t // here we  have two choice \\n\\t // either we consider this string \\n\\t //              or \\n\\t // either we  skip this \\n            return t[index][m][n]= max(1+solve(s,m-zeros,n-ones, i+1) , solve( s,m,n,i+1));\\n        }\\n\\t\\t\\n            return t[index][m][n]= solve( s,m,n,i+1);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n    memset(t,-1, sizeof(t));\\n        return solve(strs, m,n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// create a 3d array  whose value change in the  function  index, m, n\\n    int t[601][101][101];\\n\\t\\n\\t// Recursion \\n    int solve(vector<string> &s, int m, int n, int index){\\n        int size= s.size();\\n\\t\\t// i.e index is reaches  to the end of the string   or either no. of 0\\'s  || 1\\'s value <0\\n        if(index>=size || m<0 || n<0) return 0;\\n        \\n\\t\\t// if both m , n ==0  \\n        if( m==0 && n==0)return 0;\\n\\t\\t\\n\\t\\t// if we already calculate the smaller problem so we will return form here  we don\\'t need to go further \\n        if(t[index][m][n]!=-1)return t[index][m][n];\\n\\t\\t\\n        int i= index;\\n\\t\\t// counting the No if Zeros in the string \\n        int zeros= count(s[i].begin(), s[i].end(),\\'0\\');\\n\\t\\t\\n\\t\\t// counting the No of ones in string  we simply   s[i].size()-zero  beacuse the string contains only  0\\'s and 1\\'s\\n        int ones= s[i].size()-zeros;\\n\\t\\t\\n        if(m-zeros >=0 && n-ones>=0){\\n\\t // here we  have two choice \\n\\t // either we consider this string \\n\\t //              or \\n\\t // either we  skip this \\n            return t[index][m][n]= max(1+solve(s,m-zeros,n-ones, i+1) , solve( s,m,n,i+1));\\n        }\\n\\t\\t\\n            return t[index][m][n]= solve( s,m,n,i+1);\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n    memset(t,-1, sizeof(t));\\n        return solve(strs, m,n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288704,
                "title": "please-help-recursive-top-down-solution",
                "content": "From the Discussion section I have understood that, We need to find the minimum difference between two groups, the original array has divided into. For this we need to find the maximum weight of items closer to TotalWeightofItems/2. \\n\\nI used the following backtracking approach along with memoization:\\n\\n```\\n    typedef pair<int,int> pii;       \\n    \\n    vector<vector<vector<int>>>dp;\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l=strs.size();\\n        dp.resize(l+1,vector<vector<int>>(m+1,vector<int>(n+1,-2)));\\n                \\n        vector<pii>freq;        \\n        for(auto it:strs){\\n            int zeros=findzeros(it);\\n            int ones=it.length()-zeros;\\n            freq.push_back({zeros,ones});\\n        }        \\n        return backtrack(freq,0,m,n);\\n    }\\n    \\n    int backtrack(vector<pii>&freq,int start,int m,int n){\\n                \\n        if(m<0 || n<0) return -1;\\n                \\n        if(dp[start][m][n]!=-2)\\n            return dp[start][m][n];\\n        \\n        int ans=-1;\\n        for(int i=start;i<freq.size();i++){            \\n            int val=backtrack(freq,i+1,m-freq[i].first,n-freq[i].second); \\n            ans=max(ans,val);\\n        }\\n        \\n        ans++;\\n        dp[start][m][n]=ans;\\n        return ans;\\n    }\\n\\t\\n\\tint findzeros(string &str){\\n        int count=0;            \\n        \\n        for(auto it:str)\\n            if(it==\\'0\\')\\n                count++;\\n        \\n        return count;\\n    }\\n```\\n\\nThe above solution gave me a TLE, but the below approach of choosing or not gave me an AC\\n\\n```\\nclass Solution {\\npublic:\\ntypedef pair<int,int> pii;    \\nvector<vector<vector<int>>>dp;\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pii>freq;\\n        \\n        for(auto it:strs)\\n        {\\n            int zeros=findzeros(it);\\n            int ones=it.size()-zeros;\\n            freq.push_back({zeros,ones});\\n        }\\n        \\n        dp.resize(strs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,-2)));\\n        return backtrack(freq,0,m,n);\\n    }\\n    \\n    int backtrack(vector<pii>&freq,int start,int m,int n){\\n        \\n        if(m<0 || n<0) return -1;\\n        if(start==freq.size()) return 0;\\n        \\n        if(dp[start][m][n]!=-2)\\n            return dp[start][m][n];\\n        \\n        //take the pile if it\\'s valid\\n        int ans=0;\\n        ans=max(ans,1+backtrack(freq,start+1,m-freq[start].first,n-freq[start].second));\\n        \\n        //don\\'t take the current pile\\n        ans=max(ans,backtrack(freq,start+1,m,n));\\n        \\n        dp[start][m][n]=ans;\\n        return ans;\\n    }\\n    \\n    int findzeros(string &str){\\n        int count=0;\\n        \\n        for(auto &it:str)\\n            if(it==\\'0\\')\\n                count++;\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n\\nI am very habituated to the approach of 1 moving the pointer start to rest of the possibilities like a typical backing problem like subset,permutations instead of making a choice to take or not. Both the recursive tree explore the same number of nodes and I have memozied the overlapping cases. But as you could see one is giving TLE while other is not. The same thing happened to me for 2 other questions as well. I don\\'t understand why it gives TLE since I assume for both trees the time complexity is same. \\n\\nIt would be really helpful if someone points out the mistake with approach. (Both the codes work fine for testcases i.e you need not worry about the answer but just look at the way I have used 2 different recusrion trees in 2 approaches.)\\n\\nThank you!!",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    typedef pair<int,int> pii;       \\n    \\n    vector<vector<vector<int>>>dp;\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l=strs.size();\\n        dp.resize(l+1,vector<vector<int>>(m+1,vector<int>(n+1,-2)));\\n                \\n        vector<pii>freq;        \\n        for(auto it:strs){\\n            int zeros=findzeros(it);\\n            int ones=it.length()-zeros;\\n            freq.push_back({zeros,ones});\\n        }        \\n        return backtrack(freq,0,m,n);\\n    }\\n    \\n    int backtrack(vector<pii>&freq,int start,int m,int n){\\n                \\n        if(m<0 || n<0) return -1;\\n                \\n        if(dp[start][m][n]!=-2)\\n            return dp[start][m][n];\\n        \\n        int ans=-1;\\n        for(int i=start;i<freq.size();i++){            \\n            int val=backtrack(freq,i+1,m-freq[i].first,n-freq[i].second); \\n            ans=max(ans,val);\\n        }\\n        \\n        ans++;\\n        dp[start][m][n]=ans;\\n        return ans;\\n    }\\n\\t\\n\\tint findzeros(string &str){\\n        int count=0;            \\n        \\n        for(auto it:str)\\n            if(it==\\'0\\')\\n                count++;\\n        \\n        return count;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\ntypedef pair<int,int> pii;    \\nvector<vector<vector<int>>>dp;\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pii>freq;\\n        \\n        for(auto it:strs)\\n        {\\n            int zeros=findzeros(it);\\n            int ones=it.size()-zeros;\\n            freq.push_back({zeros,ones});\\n        }\\n        \\n        dp.resize(strs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,-2)));\\n        return backtrack(freq,0,m,n);\\n    }\\n    \\n    int backtrack(vector<pii>&freq,int start,int m,int n){\\n        \\n        if(m<0 || n<0) return -1;\\n        if(start==freq.size()) return 0;\\n        \\n        if(dp[start][m][n]!=-2)\\n            return dp[start][m][n];\\n        \\n        //take the pile if it\\'s valid\\n        int ans=0;\\n        ans=max(ans,1+backtrack(freq,start+1,m-freq[start].first,n-freq[start].second));\\n        \\n        //don\\'t take the current pile\\n        ans=max(ans,backtrack(freq,start+1,m,n));\\n        \\n        dp[start][m][n]=ans;\\n        return ans;\\n    }\\n    \\n    int findzeros(string &str){\\n        int count=0;\\n        \\n        for(auto &it:str)\\n            if(it==\\'0\\')\\n                count++;\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067603,
                "title": "recursive-equation-explanation-why-greedy-won-t-work-top-down-transformation",
                "content": "**Disclaimer : This post is for beginners who are new into problem solving and are looking for detailed explainations, so it is written that way. Cheers.**\\n\\nIf we see this problem at first we might consider that this can be solved by greedy, Frankly I tried solving it that way. Because it was passing most of the test cases that i tried. Even after submission it passed 63 testcases out of 71. But sadly \\uD83E\\uDD72\\uD83E\\uDD72 \\uD83E\\uDD72\\uD83E\\uDD72  this approach does not work. So if you are like me who explore different option & is trying to go in this path and need some counter example, this post is for you or you can directly skips to approach 1 where i have explained building blockes of actual solution.\\n\\n\\nApproach that I was thinking is as under.\\n\\nlike if we have m zeros and n ones, then the maximum size of subset could be m+n in best case. If input string have m string of length 1 with zero as value and n string of length 1 and 1 as value.\\n\\nSo it make sense to sort the input array by length and elements with same length can be sorted by difference of ones and zeros. Now we pick elements from left to right if they can be added.\\n\\nCode \\n\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int zeros, int ones) {\\n      List<String> inputStrings = new LinkedList<>(Arrays.asList(strs));\\n      \\n      Collections.sort(inputStrings,(m,n)->{\\n          \\n          if(m.length()<n.length())\\n              return -1;\\n          else if(m.length()>n.length())\\n              return 1;\\n          else {\\n              int oneM=0,oneN=0;\\n              oneM = countOne(m);\\n              oneN = countOne(n);\\n              \\n            int zeroM = Math.abs(m.length()-oneM);\\n            int zeroN = Math.abs(n.length()-oneN);\\n          \\n              int differenceM = Math.abs(oneM-zeroM);\\n              int differenceN = Math.abs(oneN-zeroN);\\n              \\n          if(differenceM<differenceN)\\n              return -1;\\n          else if(differenceM>differenceN)\\n              return 1;\\n          else\\n              return 0;\\n          }\\n          \\n      });  \\n        \\n      int count=0;\\n     System.out.println(inputStrings);\\n        \\n      for(int i=0;i<inputStrings.size();i++) {\\n          int countofone  = countOne(inputStrings.get(i));\\n          int countofzero = inputStrings.get(i).length()-countofone;\\n          if((zeros-countofzero)>=0 && (ones-countofone)>=0){\\n             count++;\\n             zeros= zeros-countofzero;\\n             ones = ones-countofone;\\n          } \\n      }  \\n      \\n        \\n      return count;  \\n    }\\n    \\n    public int countOne(String input){\\n        int count=0;\\n        for(int i=0;i<input.length();i++) {\\n                  if(input.charAt(i)==\\'1\\'){\\n                      count++;\\n                  }\\n              }\\n        return count;\\n    }\\n}\\n```\\n\\nThis approach does not work on following input:\\n\\n[\"111\",\"1000\",\"1000\",\"1000\"]\\n9\\n3\\n\\nSo greedy does not work, thats bad. Now lets think of some other apporach.\\n\\n\\n**Approach 1 :**\\n\\nLet\\'s forget all fancy approach and work with the basics, how to solve this problem by backtracking?\\n\\nfor every index of input array strs we have 2 choice either we can take it or we can ignore it, that we break the problem into **independently solvable  Subproblems**  \\n\\nWhat will the recursive equation? Rough method will look something like this.\\n\\nsolve(strs,i,m,n) {\\nint count1 = countone(strs[i]);\\nint count0 = strs[i].length-count1;\\nint output = 0;\\nif(we can include this in the output array) {\\noutput = solve(strs,i+1,m-count0,n-count1)+1;\\n}\\n//lets not include it in the output\\n\\noutput = Math.max(output,solve(strs,i+1,m,n));\\nreturn output;\\n}\\n\\nyeah we have some working logic. Please find exact code for the same as under\\n\\n\\n```\\nclass Solution {\\n    \\n    public int findMaxForm(String[] strs, int zeros, int ones) {\\n     \\n        return findMax(strs,zeros,ones,0);\\n    }\\n    \\n    public int findMax(String[] strs,\\n                       int zeros,\\n                       int ones,\\n                       int i) {\\n        if(i>=strs.length)\\n            return 0;\\n    \\n            int count1 = countOne(strs[i]);\\n            int count0 = strs[i].length()-count1;   \\n            int output = 0;\\n            if(ones>=count1 && zeros>=count0) {\\n                output = findMax(strs,zeros-count0,ones-count1,i+1)+1;\\n            }\\n            \\n            output = Math.max(output,findMax(strs,zeros,ones,i+1));\\n            return output;       \\n        \\n    }\\n    \\n    public int countOne(String input){\\n        int count=0;\\n        for(int i=0;i<input.length();i++) {\\n                  if(input.charAt(i)==\\'1\\'){\\n                      count++;\\n                  }\\n              }\\n        return count;\\n    }\\n}\\n```\\n\\nSadly \\xA0\\uD83E\\uDD72\\uD83E\\uDD72 \\uD83E\\uDD72\\uD83E\\uDD72  this is still slow, even though it is correct and we are on the right path. Why not store the result of each computation as each string contains only zero and ones? \\n\\n**Approach 2 :**\\n\\n```\\nclass Solution {\\n    \\n    public int findMaxForm(String[] strs, int zeros, int ones) {\\n     \\n\\n        Integer cache[][][] = new Integer[strs.length][zeros+1][ones+1];\\n        return findMax(strs,zeros,ones,0,cache);\\n    }\\n    \\n    public int findMax(String[] strs,\\n                       int zeros,\\n                       int ones,\\n                       int i,\\n                       Integer cache[][][]) {\\n        if(i>=strs.length)\\n            return 0;\\n        \\n        Integer value = cache[i][zeros][ones];\\n        if(value!=null)\\n            return value;\\n        else {\\n            int count1 = countOne(strs[i]);\\n            int count0 = strs[i].length()-count1;   \\n            int output = 0;\\n            if(ones>=count1 && zeros>=count0) {\\n                output = findMax(strs,zeros-count0,ones-count1,i+1,cache)+1;\\n            }\\n            \\n            output = Math.max(output,findMax(strs,zeros,ones,i+1,cache));\\n            \\n            \\n            cache[i][zeros][ones] = output;\\n            return output;\\n        }        \\n        \\n    }\\n    \\n    public int countOne(String input){\\n        int count=0;\\n        for(int i=0;i<input.length();i++) {\\n                  if(input.charAt(i)==\\'1\\'){\\n                      count++;\\n                  }\\n              }\\n        return count;\\n    }\\n}\\n```\\n\\n\\nWe have introduced a cache that simply stores result of each computation in a dp array. And yes it pass all the test cases. So we have a working code. Converting this top down approach to bottem up is easy. We just need to move from m=0,n=0 to m=given m and n=given n.\\n\\nHope this helps.\\uD83E\\uDD13\\uD83E\\uDD13\\uD83E\\uDD13\\uD83E\\uDD13\\uD83E\\uDD13\\uD83E\\uDD13\\uD83E\\uDD13. Please upvote if it helps. Will update it with bottem up implementation in a while.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int zeros, int ones) {\\n      List<String> inputStrings = new LinkedList<>(Arrays.asList(strs));\\n      \\n      Collections.sort(inputStrings,(m,n)->{\\n          \\n          if(m.length()<n.length())\\n              return -1;\\n          else if(m.length()>n.length())\\n              return 1;\\n          else {\\n              int oneM=0,oneN=0;\\n              oneM = countOne(m);\\n              oneN = countOne(n);\\n              \\n            int zeroM = Math.abs(m.length()-oneM);\\n            int zeroN = Math.abs(n.length()-oneN);\\n          \\n              int differenceM = Math.abs(oneM-zeroM);\\n              int differenceN = Math.abs(oneN-zeroN);\\n              \\n          if(differenceM<differenceN)\\n              return -1;\\n          else if(differenceM>differenceN)\\n              return 1;\\n          else\\n              return 0;\\n          }\\n          \\n      });  \\n        \\n      int count=0;\\n     System.out.println(inputStrings);\\n        \\n      for(int i=0;i<inputStrings.size();i++) {\\n          int countofone  = countOne(inputStrings.get(i));\\n          int countofzero = inputStrings.get(i).length()-countofone;\\n          if((zeros-countofzero)>=0 && (ones-countofone)>=0){\\n             count++;\\n             zeros= zeros-countofzero;\\n             ones = ones-countofone;\\n          } \\n      }  \\n      \\n        \\n      return count;  \\n    }\\n    \\n    public int countOne(String input){\\n        int count=0;\\n        for(int i=0;i<input.length();i++) {\\n                  if(input.charAt(i)==\\'1\\'){\\n                      count++;\\n                  }\\n              }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int findMaxForm(String[] strs, int zeros, int ones) {\\n     \\n        return findMax(strs,zeros,ones,0);\\n    }\\n    \\n    public int findMax(String[] strs,\\n                       int zeros,\\n                       int ones,\\n                       int i) {\\n        if(i>=strs.length)\\n            return 0;\\n    \\n            int count1 = countOne(strs[i]);\\n            int count0 = strs[i].length()-count1;   \\n            int output = 0;\\n            if(ones>=count1 && zeros>=count0) {\\n                output = findMax(strs,zeros-count0,ones-count1,i+1)+1;\\n            }\\n            \\n            output = Math.max(output,findMax(strs,zeros,ones,i+1));\\n            return output;       \\n        \\n    }\\n    \\n    public int countOne(String input){\\n        int count=0;\\n        for(int i=0;i<input.length();i++) {\\n                  if(input.charAt(i)==\\'1\\'){\\n                      count++;\\n                  }\\n              }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int findMaxForm(String[] strs, int zeros, int ones) {\\n     \\n\\n        Integer cache[][][] = new Integer[strs.length][zeros+1][ones+1];\\n        return findMax(strs,zeros,ones,0,cache);\\n    }\\n    \\n    public int findMax(String[] strs,\\n                       int zeros,\\n                       int ones,\\n                       int i,\\n                       Integer cache[][][]) {\\n        if(i>=strs.length)\\n            return 0;\\n        \\n        Integer value = cache[i][zeros][ones];\\n        if(value!=null)\\n            return value;\\n        else {\\n            int count1 = countOne(strs[i]);\\n            int count0 = strs[i].length()-count1;   \\n            int output = 0;\\n            if(ones>=count1 && zeros>=count0) {\\n                output = findMax(strs,zeros-count0,ones-count1,i+1,cache)+1;\\n            }\\n            \\n            output = Math.max(output,findMax(strs,zeros,ones,i+1,cache));\\n            \\n            \\n            cache[i][zeros][ones] = output;\\n            return output;\\n        }        \\n        \\n    }\\n    \\n    public int countOne(String input){\\n        int count=0;\\n        for(int i=0;i<input.length();i++) {\\n                  if(input.charAt(i)==\\'1\\'){\\n                      count++;\\n                  }\\n              }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067563,
                "title": "python-backtracking-memoization-dp",
                "content": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        def count_digits(string: str) -> Tuple[int, int]:\\n\\t\\t\\t\"\"\" Count zeroes and ones in string\\n\\t\\t\\t\\n\\t\\t\\tArgs:\\n\\t\\t\\t\\tstring: the input string\\n\\t\\t\\tReturns:\\n\\t\\t\\t\\tint: count of zeroes in input string\\n\\t\\t\\t\\tint: count of ones in input string\\n\\t\\t\\t\"\"\"\\n            m = 0\\n            for c in string:\\n                if c == \"0\":\\n                    m += 1\\n            return m, len(string) - m\\n        \\n        def backtracking(m, n, idx = 0, dp = {}):\\n\\t\\t\\t# we processed all count for input list of strings\\n            if idx == len(counts):\\n                return 0\\n            \\n\\t\\t\\t# the combination m, n, idx has been processed previously\\n            if (m, n, idx) in dp:\\n                return dp[(m, n, idx)]\\n            \\n\\t\\t\\t# try to find the max form without the string at index idx\\n            max_result = backtracking(m, n, idx + 1) \\n            \\n            # try to find the max form with the string at index idx\\n            count_zeroes, count_ones = counts[idx]\\n            if m - count_zeroes >= 0 and n - count_ones >= 0:\\n                result = backtracking(m - count_zeroes, n - count_ones, idx + 1) + 1 \\n                max_result = max(max_result, result)\\n\\n\\t\\t\\t# memoize the combination m, n, idx to avoid processing it again\\n            dp[(m, n, idx)] = max_result\\n\\t\\t\\t\\n            return max_result\\n        \\n        counts = [count_digits(s) for s in strs]\\n        return backtracking(m, n)\\n```\\n\\nor using the Python `@cache` decorator:\\n\\n```\\n\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        def count_digits(string: str) -> Tuple[int, int]:\\n            m = 0\\n            for c in string:\\n                if c == \"0\":\\n                    m += 1\\n            return m, len(string) - m\\n        \\n        @cache\\n\\t\\tdef backtracking(m, n, idx = 0):\\n            if idx == len(counts):\\n                return 0\\n            \\n            max_result = backtracking(m, n, idx + 1) \\n            \\n            count_zeroes, count_ones = counts[idx]\\n            if m - count_zeroes >= 0 and n - count_ones >= 0:\\n                result = backtracking(m - count_zeroes, n - count_ones, idx + 1) + 1 \\n                max_result = max(max_result, result)\\n\\n            return max_result\\n        \\n        \\n        counts = [count_digits(s) for s in strs]\\n        return backtracking(m, n)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        def count_digits(string: str) -> Tuple[int, int]:\\n\\t\\t\\t\"\"\" Count zeroes and ones in string\\n\\t\\t\\t\\n\\t\\t\\tArgs:\\n\\t\\t\\t\\tstring: the input string\\n\\t\\t\\tReturns:\\n\\t\\t\\t\\tint: count of zeroes in input string\\n\\t\\t\\t\\tint: count of ones in input string\\n\\t\\t\\t\"\"\"\\n            m = 0\\n            for c in string:\\n                if c == \"0\":\\n                    m += 1\\n            return m, len(string) - m\\n        \\n        def backtracking(m, n, idx = 0, dp = {}):\\n\\t\\t\\t# we processed all count for input list of strings\\n            if idx == len(counts):\\n                return 0\\n            \\n\\t\\t\\t# the combination m, n, idx has been processed previously\\n            if (m, n, idx) in dp:\\n                return dp[(m, n, idx)]\\n            \\n\\t\\t\\t# try to find the max form without the string at index idx\\n            max_result = backtracking(m, n, idx + 1) \\n            \\n            # try to find the max form with the string at index idx\\n            count_zeroes, count_ones = counts[idx]\\n            if m - count_zeroes >= 0 and n - count_ones >= 0:\\n                result = backtracking(m - count_zeroes, n - count_ones, idx + 1) + 1 \\n                max_result = max(max_result, result)\\n\\n\\t\\t\\t# memoize the combination m, n, idx to avoid processing it again\\n            dp[(m, n, idx)] = max_result\\n\\t\\t\\t\\n            return max_result\\n        \\n        counts = [count_digits(s) for s in strs]\\n        return backtracking(m, n)\\n```\n```\\n\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        def count_digits(string: str) -> Tuple[int, int]:\\n            m = 0\\n            for c in string:\\n                if c == \"0\":\\n                    m += 1\\n            return m, len(string) - m\\n        \\n        @cache\\n\\t\\tdef backtracking(m, n, idx = 0):\\n            if idx == len(counts):\\n                return 0\\n            \\n            max_result = backtracking(m, n, idx + 1) \\n            \\n            count_zeroes, count_ones = counts[idx]\\n            if m - count_zeroes >= 0 and n - count_ones >= 0:\\n                result = backtracking(m - count_zeroes, n - count_ones, idx + 1) + 1 \\n                max_result = max(max_result, result)\\n\\n            return max_result\\n        \\n        \\n        counts = [count_digits(s) for s in strs]\\n        return backtracking(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066370,
                "title": "c-dp-iteration-knapsack-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    \\n    //function for count 0s and 1s \\n    vector<int> count(string s)\\n    {\\n        \\n        vector<int> cnt(2);\\n        for(auto it: s)\\n        {\\n            it==\\'0\\' ? cnt[0]++ : cnt[1]++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) \\n    {\\n        //define 2D vector of zeros+1 rows and ones+1 columns\\n        vector<vector<int>> dp(m+1, (vector<int> (n+1, 0)));\\n        \\n        //iterate over strs and get string s\\n        for(string s:strs)\\n        {\\n            //count 0s an 1s in string s\\n            vector<int> cnt = count(s);\\n            \\n            //zero -> m-count[0]  ---- 0\\n            //one -> n-count[1] ---- 0\\n            for(int zero=m; zero>=cnt[0]; zero--)\\n            {\\n                for(int one=n; one>=cnt[1]; one--)\\n                {\\n                    dp[zero][one] = max(1+dp[zero-cnt[0]][one-cnt[1]], dp[zero][one]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    //function for count 0s and 1s \\n    vector<int> count(string s)\\n    {\\n        \\n        vector<int> cnt(2);\\n        for(auto it: s)\\n        {\\n            it==\\'0\\' ? cnt[0]++ : cnt[1]++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) \\n    {\\n        //define 2D vector of zeros+1 rows and ones+1 columns\\n        vector<vector<int>> dp(m+1, (vector<int> (n+1, 0)));\\n        \\n        //iterate over strs and get string s\\n        for(string s:strs)\\n        {\\n            //count 0s an 1s in string s\\n            vector<int> cnt = count(s);\\n            \\n            //zero -> m-count[0]  ---- 0\\n            //one -> n-count[1] ---- 0\\n            for(int zero=m; zero>=cnt[0]; zero--)\\n            {\\n                for(int one=n; one>=cnt[1]; one--)\\n                {\\n                    dp[zero][one] = max(1+dp[zero-cnt[0]][one-cnt[1]], dp[zero][one]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065803,
                "title": "c-easy-94-faster",
                "content": "class Solution {\\npublic:\\n\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int l=s.size();\\n        int dp[m+3][n+3];\\n         memset(dp,0,sizeof(dp));\\n        for(int k=0;k<l;k++)\\n        {\\n            int cntz=0,cnto=0; // counting zero and one in each string\\n            for(auto c:s[k])\\n            {\\n                (c==\\'0\\')?cntz++:cnto++;\\n            }\\n            for(int i=m;i>=0;i--)\\n            {\\n                for(int j=n;j>=0;j--)\\n                {\\n                  if(i>=cntz && j>=cnto)\\n                  dp[i][j]=max(dp[i][j],dp[i-cntz][j-cnto]+1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int l=s.size();\\n        int dp[m+3][n+3];\\n         memset(dp,0,sizeof(dp));\\n        for(int k=0;k<l;k++)\\n        {\\n            int cntz=0,cnto=0; // counting zero and one in each string\\n            for(auto c:s[k])\\n            {\\n                (c==\\'0\\')?cntz++:cnto++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1951294,
                "title": "dynamic-programming-tabulation-bottom-up-approach-with-diagrams-explanation",
                "content": "Inspired from another solution but made it more readable (hopefully) and understandable with my diagrams\\n\\n```\\nvar findMaxForm = function(strs, m, n) {\\n    // convert strs to m & n counts per string\\n    strs = strs.map((str) => {\\n        const counts = [0, 0];\\n        \\n        for (let i = 0; i < str.length; i++) {\\n            const character = str[i];\\n            \\n            counts[character] += 1;\\n        }\\n        \\n        return counts;\\n    })\\n    \\n    // setup dp matrix (m+1 x n+1)\\n    const dp = [];\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp.push([]);\\n        \\n        for (let j = 0; j <= n; j++) {\\n            dp[i].push(0);\\n        }\\n    }\\n    \\n\\t// using example: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\n    // iterate through dp: strs.length x m x n\\n    // this loops over m count and n count of each string\\n    for (let i = 0; i < strs.length; i++) {\\n        const [mCount, nCount] = strs[i];\\n        \\n        // each time we iterate the above, we find the max \"take\" from the bottom right corner of matrix\\n        // when we move on to the next string (m & n counts), we update based on previous iteration\\'s values\\n        for (let row = m; row >= mCount; row--) {\\n            for (let column = n; column >= nCount; column--) {\\n                // max \"take\" is its current value or current dp m & n counts decrementing the current string\\'s m & n count\\n                /*  Example: \\n                        row represents m, and column represents n\\n                        Iteration right after processing max take of index 0\\'s \\'10\\' string\\n                        \\n                        [ 0, 0, 0, 0 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ]\\n\\n                        During iteration of index 1\\'s string \\'0001\\' has 3 zeros(m\\'s) and 1 ones(n\\'s)\\n                        From X (row 5, column 3, value 1), we decrement 3 m\\'s and 1 n\\'s; which ends up at Y (row 2, column 2, value 1)\\n\\n                        [ 0, 0, 0, 0 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, Y, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, X ]\\n                        \\n                        Since we update its value based on max of (current value X = 1) or (Y position\\'s value + 1 = 2)\\n                        We update X to 2\\n\\n                        [ 0, 0, 0, 0 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 2 ]\\n                */\\n                dp[row][column] = Math.max(dp[row][column], dp[row - mCount][column - nCount] + 1);\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar findMaxForm = function(strs, m, n) {\\n    // convert strs to m & n counts per string\\n    strs = strs.map((str) => {\\n        const counts = [0, 0];\\n        \\n        for (let i = 0; i < str.length; i++) {\\n            const character = str[i];\\n            \\n            counts[character] += 1;\\n        }\\n        \\n        return counts;\\n    })\\n    \\n    // setup dp matrix (m+1 x n+1)\\n    const dp = [];\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp.push([]);\\n        \\n        for (let j = 0; j <= n; j++) {\\n            dp[i].push(0);\\n        }\\n    }\\n    \\n\\t// using example: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\n    // iterate through dp: strs.length x m x n\\n    // this loops over m count and n count of each string\\n    for (let i = 0; i < strs.length; i++) {\\n        const [mCount, nCount] = strs[i];\\n        \\n        // each time we iterate the above, we find the max \"take\" from the bottom right corner of matrix\\n        // when we move on to the next string (m & n counts), we update based on previous iteration\\'s values\\n        for (let row = m; row >= mCount; row--) {\\n            for (let column = n; column >= nCount; column--) {\\n                // max \"take\" is its current value or current dp m & n counts decrementing the current string\\'s m & n count\\n                /*  Example: \\n                        row represents m, and column represents n\\n                        Iteration right after processing max take of index 0\\'s \\'10\\' string\\n                        \\n                        [ 0, 0, 0, 0 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ]\\n\\n                        During iteration of index 1\\'s string \\'0001\\' has 3 zeros(m\\'s) and 1 ones(n\\'s)\\n                        From X (row 5, column 3, value 1), we decrement 3 m\\'s and 1 n\\'s; which ends up at Y (row 2, column 2, value 1)\\n\\n                        [ 0, 0, 0, 0 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, Y, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, X ]\\n                        \\n                        Since we update its value based on max of (current value X = 1) or (Y position\\'s value + 1 = 2)\\n                        We update X to 2\\n\\n                        [ 0, 0, 0, 0 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 1 ],\\n                        [ 0, 1, 1, 2 ]\\n                */\\n                dp[row][column] = Math.max(dp[row][column], dp[row - mCount][column - nCount] + 1);\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909505,
                "title": "easiy-3d-dp-approach-recursion-memoization-optimized",
                "content": "```\\n1. ** Recursion **\\n\\nint dp[601][101][101];\\n    \\n    int fun(vector<string>& s, int m, int n , int l , int i)\\n    {\\n        if(i>=l || m<0 || n<0)return  0;\\n        if(m==0 && n==0)return 0;\\n        \\n        int c0=0 , c1=0;\\n        for(int j=0;j<s[i].length();j++)\\n        {\\n            if(s[i][j] ==\\'0\\')c0++;\\n            else c1++;\\n        }\\n        \\n       if(m>=c0 && n>=c1) return max(1+ fun(s,m-c0,n-c1,l,i+1,) , fun(s,m,n,l,i+1));\\n        return fun(s,m,n,l,i+1);\\n        \\n    }\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int l = s.size();\\n        \\n      memset(dp , -1 , sizeof(dp));\\n        return fun(s, m,n,l,0 );\\n    }\\n\\t```\\n\\t\\n\\t\\n\\t\\n2.\\t**Memoization**\\n\\t\\n\\t```\\n\\t int dp[601][101][101];\\n    \\n    int fun(vector<string>& s, int m, int n , int l , int i, string x )\\n    {\\n        if(i>=l || m<0 || n<0)return dp[i][m][n] = 0;\\n        if(m==0 && n==0)return dp[i][m][n]=0;\\n        \\n        if(dp[i][m][n]!=-1)return dp[i][m][n]; \\n        \\n        int c=0 , k=0;\\n        for(int j=0;j<s[i].length();j++)\\n        {\\n            if(s[i][j] ==\\'0\\')c++;\\n            else k++;\\n        }\\n        \\n       if(m-c>=0 && n>=k) return dp[i][m][n] = max(1+ fun(s,m-c,n-k,l,i+1, x+s[i]) , fun(s,m,n,l,i+1, x));\\n        return dp[i][m][n] = fun(s,m,n,l,i+1,x);\\n        \\n    }\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int l = s.size();\\n        \\n      memset(dp , -1 , sizeof(dp));\\n        return fun(s, m,n,l,0 , \"\");\\n\\t\\t```\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n3. \\t\\t**Optimized**  - Passing the count of 1s and 0s instead of given array\\n    \\n\\t\\n\\t```\\n\\tint dp[601][101][101];\\n    \\n    int fun(vector<pair<int , int> >& s, int m, int n , int l , int i)\\n    {\\n        if( i==l || (m==0 && n==0) )return dp[i][m][n] = 0;\\n        \\n         if(dp[i][m][n]!=-1)return dp[i][m][n]; \\n        \\n        int c0=s[i].first , c1=s[i].second;\\n        \\n        if(m >= c0 && n >= c1) {  return dp[i][m][n] = max(fun(s , m , n , l , i+1) , 1 + fun(s , m-c0 , n-c1 , l , i+1 )) ;}\\n         return dp[i][m][n] = fun(s , m , n , l , i+1) ;\\n        \\n        \\n    }\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int l = s.size();\\n\\t\\t\\n        vector<pair<int , int> > cntZO(l) ;\\n        int i=0;\\n        for(auto x : s)\\n        { \\n            \\n            int one = count(x.begin() , x.end() , \\'1\\' ) ;\\n            int zero = x.length() - one;\\n            cntZO[i] = {zero , one} ;\\n            i++;\\n        }\\n        memset(dp , -1 , sizeof(dp));\\n        \\n        return fun(cntZO, m,n,l,0 );\\n\\t",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n1. ** Recursion **\\n\\nint dp[601][101][101];\\n    \\n    int fun(vector<string>& s, int m, int n , int l , int i)\\n    {\\n        if(i>=l || m<0 || n<0)return  0;\\n        if(m==0 && n==0)return 0;\\n        \\n        int c0=0 , c1=0;\\n        for(int j=0;j<s[i].length();j++)\\n        {\\n            if(s[i][j] ==\\'0\\')c0++;\\n            else c1++;\\n        }\\n        \\n       if(m>=c0 && n>=c1) return max(1+ fun(s,m-c0,n-c1,l,i+1,) , fun(s,m,n,l,i+1));\\n        return fun(s,m,n,l,i+1);\\n        \\n    }\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int l = s.size();\\n        \\n      memset(dp , -1 , sizeof(dp));\\n        return fun(s, m,n,l,0 );\\n    }\\n\\t```\n```\\n\\t int dp[601][101][101];\\n    \\n    int fun(vector<string>& s, int m, int n , int l , int i, string x )\\n    {\\n        if(i>=l || m<0 || n<0)return dp[i][m][n] = 0;\\n        if(m==0 && n==0)return dp[i][m][n]=0;\\n        \\n        if(dp[i][m][n]!=-1)return dp[i][m][n]; \\n        \\n        int c=0 , k=0;\\n        for(int j=0;j<s[i].length();j++)\\n        {\\n            if(s[i][j] ==\\'0\\')c++;\\n            else k++;\\n        }\\n        \\n       if(m-c>=0 && n>=k) return dp[i][m][n] = max(1+ fun(s,m-c,n-k,l,i+1, x+s[i]) , fun(s,m,n,l,i+1, x));\\n        return dp[i][m][n] = fun(s,m,n,l,i+1,x);\\n        \\n    }\\n    int findMaxForm(vector<string>& s, int m, int n) {\\n        int l = s.size();\\n        \\n      memset(dp , -1 , sizeof(dp));\\n        return fun(s, m,n,l,0 , \"\");\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1798636,
                "title": "cpp-dp-recursion-memoization-tabulation-understand-quickly",
                "content": "#### Ones and Zeros - DP\\nThis is one another classical problem from DP. If you are wondering how to figure out if its a DP problem, its simple. \\n- Most of the questions like these - which requires picking random elements are often DP problems. (This is not sub-array prob, so no sliding window, or anything)\\n- Try sorting, and if you **cannot** apply greedy - this might be a DP prob.\\n\\n##### Code Explained\\n\\nFor recursion, just write the basic recursive code that comes in your mind.\\n\\n**1. Recursion (TLE)** \\u274C \\n```\\npair<int, int> countZerosOnes(string& s) {\\n    int zeros = 0;\\n    for (char ch : s)\\n        if (ch == \\'0\\') zeros++;\\n    return {zeros, s.size() - zeros};\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n, int pos = 0) {\\n    if (pos == strs.size())\\n        return 0;\\n\\n\\t// p.first is count(0s) and p.second is count(1s)\\n    pair<int, int> p = countZerosOnes(strs[pos]);\\n\\n    if (p.first <= m && p.second <= n) {\\n        return max(1 + findMaxForm(strs, m - p.first, n - p.second, pos + 1),\\n                   findMaxForm(strs, m, n, pos + 1));\\n    }\\n\\n    return findMaxForm(strs, m, n, pos + 1);\\n}\\n```\\n\\nFollowing the method of recursion which gets TLE, we can proceed to memoize it by using three varying elemts in each recursive calls - **M, N, and strs.size()**.\\n\\nSo the answer will end up in ->  dp [strs.size()][M][N]\\n\\n**2. Memoization** \\u2705\\n```cpp\\npair<int, int> countZerosOnes(string& s) {\\n    int zeros = 0;\\n    for (char ch : s)\\n        if (ch == \\'0\\') zeros++;\\n    return {zeros, s.size() - zeros};\\n}\\n\\nvector<vector<vector<int>>> dp;\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    dp.resize(strs.size() + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, -1)));\\n    return helper(strs, m, n);\\n}\\n\\nint helper(vector<string>& strs, int m, int n, int pos = 0) {\\n    if (pos == strs.size())\\n        return 0;\\n\\n    if (dp[pos][m][n] != -1) return dp[pos][m][n];\\n    pair<int, int> p = countZerosOnes(strs[pos]);\\n\\n    if (p.first <= m && p.second <= n) {\\n        return dp[pos][m][n] =\\n                   max(1 + helper(strs, m - p.first, n - p.second, pos + 1),\\n                       helper(strs, m, n, pos + 1));\\n    }\\n\\n    return dp[pos][m][n] = helper(strs, m, n, pos + 1);\\n}\\n```\\n\\nIn tabulation, **dp[i][j]** - represents the maximum subset count of -  **i zeros**  and **j ones** that is present following each strings in array - **strs[i]**.\\n\\n**3. Tabulation  - Bottom Up Approach** \\u2705\\n```cpp\\npair<int, int> countZerosOnes(string& s) {\\n    int zeros = 0;\\n    for (char ch : s)\\n        if (ch == \\'0\\') zeros++;\\n    return {zeros, s.size() - zeros};\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<int>> dp;\\n    dp.resize(m + 1, vector<int>(n + 1));\\n\\n    for (string& s : strs) {\\n        pair<int, int> p = countZerosOnes(s);\\n        for (int i = m; i >= 0; i--) {  // for m limit\\n            for (int j = n; j >= 0; j--) { // for n limit\\n\\t\\t\\t\\t// just like above memoizn code, check if lesser num to subtract and proceed loop\\n                if (p.first <= i && p.second <= j) \\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - p.first][j - p.second]);\\n            }\\n        }\\n    }\\n\\n    return dp[m][n];\\n}\\n```\\n\\nLearn dp and peace out.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npair<int, int> countZerosOnes(string& s) {\\n    int zeros = 0;\\n    for (char ch : s)\\n        if (ch == \\'0\\') zeros++;\\n    return {zeros, s.size() - zeros};\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n, int pos = 0) {\\n    if (pos == strs.size())\\n        return 0;\\n\\n\\t// p.first is count(0s) and p.second is count(1s)\\n    pair<int, int> p = countZerosOnes(strs[pos]);\\n\\n    if (p.first <= m && p.second <= n) {\\n        return max(1 + findMaxForm(strs, m - p.first, n - p.second, pos + 1),\\n                   findMaxForm(strs, m, n, pos + 1));\\n    }\\n\\n    return findMaxForm(strs, m, n, pos + 1);\\n}\\n```\n```cpp\\npair<int, int> countZerosOnes(string& s) {\\n    int zeros = 0;\\n    for (char ch : s)\\n        if (ch == \\'0\\') zeros++;\\n    return {zeros, s.size() - zeros};\\n}\\n\\nvector<vector<vector<int>>> dp;\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    dp.resize(strs.size() + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, -1)));\\n    return helper(strs, m, n);\\n}\\n\\nint helper(vector<string>& strs, int m, int n, int pos = 0) {\\n    if (pos == strs.size())\\n        return 0;\\n\\n    if (dp[pos][m][n] != -1) return dp[pos][m][n];\\n    pair<int, int> p = countZerosOnes(strs[pos]);\\n\\n    if (p.first <= m && p.second <= n) {\\n        return dp[pos][m][n] =\\n                   max(1 + helper(strs, m - p.first, n - p.second, pos + 1),\\n                       helper(strs, m, n, pos + 1));\\n    }\\n\\n    return dp[pos][m][n] = helper(strs, m, n, pos + 1);\\n}\\n```\n```cpp\\npair<int, int> countZerosOnes(string& s) {\\n    int zeros = 0;\\n    for (char ch : s)\\n        if (ch == \\'0\\') zeros++;\\n    return {zeros, s.size() - zeros};\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    vector<vector<int>> dp;\\n    dp.resize(m + 1, vector<int>(n + 1));\\n\\n    for (string& s : strs) {\\n        pair<int, int> p = countZerosOnes(s);\\n        for (int i = m; i >= 0; i--) {  // for m limit\\n            for (int j = n; j >= 0; j--) { // for n limit\\n\\t\\t\\t\\t// just like above memoizn code, check if lesser num to subtract and proceed loop\\n                if (p.first <= i && p.second <= j) \\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - p.first][j - p.second]);\\n            }\\n        }\\n    }\\n\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1267875,
                "title": "java-dynamic-programming-with-explanation",
                "content": "## Approach\\nThis problem is similar to knapsack problem, the main difference being that instead of one bag, we have two bags of size n and m. The initial appraoch is the brute force approach, you pick the current string or skip it in the array. Then you find the answer for the rest of the array using recursion. The base case would be an empty array, where the answer is trivial, that is, 0.\\n\\nThe psuedo-code would look something like this:\\n1. If the array size is zero, the solution is trivial, that is 0.\\n2. Else check if the current string can be included in the solution (based on remaining m and n).\\n\\ta. If it cannot be included, return the solution for the rest of the array.\\n\\tb. Else return the maximum between including and skipping over the current string.\\n\\t\\n## Implementations\\n**S = size of input strs array**\\n**N = input n**\\n**M = input m**\\n**K = average string size**\\n\\n## 1. Recursion\\n**Time complexity: O(K * 2^S)** \\n**Space complexity: O(S)**\\n\\n```java\\nclass Solution {\\n    \\n    String[] strs;\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        this.strs = strs;\\n        \\n        // call helper function\\n        return recurse(strs.length, m, n);\\n    }\\n    \\n    private int recurse(int size, int m, int n) {\\n        // base case\\n        if (size == 0)\\n            return 0;\\n        \\n        // 1. skip current element\\n        int skip = recurse(size - 1, m, n);\\n        \\n        // update m, n with the last element\\n        for (char bit: strs[size - 1].toCharArray()) {\\n            if (bit == \\'0\\')\\n                m--;\\n            else\\n                n--;\\n        }\\n        \\n        // 2. choose current element if possible\\n        int choose = 0;\\n        if (m >= 0 && n >= 0)\\n            choose = 1 + recurse(size - 1, m, n);\\n        \\n        // return the optimal answer\\n        return Math.max(skip, choose);\\n    }\\n}\\n```\\n\\n## 2. Top-down DP\\n**Time complexity: O(K * S)**\\n**Space complexity: O(S * N * M)**\\n\\n```java\\nclass Solution {\\n    \\n    String[] strs;\\n    int[][][] memo;\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        this.strs = strs;\\n        \\n        // initialize dp table\\n        memo = new int[strs.length + 1][m + 1][n + 1];\\n        for (int i = 0; i < strs.length + 1; i++) {\\n            for (int j = 0; j < m + 1; j++) {\\n                Arrays.fill(memo[i][j], i == 0 ? 0 : -1);\\n            }\\n        }\\n        \\n        // call helper function\\n        return recurse(strs.length, m, n);\\n    }\\n    \\n    private int recurse(int size, int m, int n) {\\n        // base case and dp table check\\n        if (memo[size][m][n] != -1)\\n            return memo[size][m][n];\\n        \\n        // 1. skip current element\\n        int skip = recurse(size - 1, m, n);\\n        \\n        // update m, n with the last element\\n        int newM = m, newN = n;\\n        for (char bit: strs[size - 1].toCharArray()) {\\n            if (bit == \\'0\\')\\n                newM--;\\n            else\\n                newN--;\\n        }\\n        \\n        // 2. choose current element if possible\\n        int choose = 0;\\n        if (newM >= 0 && newN >= 0)\\n            choose = 1 + recurse(size - 1, newM, newN);\\n        \\n        // return the optimal answer\\n        memo[size][m][n] = Math.max(skip, choose);\\n        return memo[size][m][n];\\n    }\\n}\\n```\\n\\n## 3. Bottom-up DP\\n**Time complexity: O(K * S)** \\n**Space complexity: O(S * N * M)**\\n\\n```java\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // initialize dp table\\n        int[][][] table = new int[strs.length + 1][m + 1][n + 1];\\n        \\n        for (int i = 0; i < strs.length + 1; i++) {\\n            for (int j = 0; j < m + 1; j++) {\\n                for (int k = 0; k < n + 1; k++) {\\n                    // base case\\n                    if (i == 0) {\\n                        table[i][j][k] = 0;\\n                        continue;\\n                    }\\n                    \\n                    // 1. skip current element\\n                    table[i][j][k] = table[i - 1][j][k];\\n\\n                    // count zeros and ones left after the current element\\n                    int zeros = j, ones = k;\\n                    for (char bit: strs[i - 1].toCharArray()) {\\n                        if (bit == \\'0\\')\\n                            zeros--;\\n                        else\\n                            ones--;\\n                    }\\n\\n                    // 2. select current element if possible\\n                    if (zeros >= 0 && ones >= 0)\\n                        table[i][j][k] = Math.max(table[i][j][k], 1 + table[i - 1][zeros][ones]);\\n                }\\n            }\\n        }\\n        \\n        return table[strs.length][m][n];\\n    }\\n}\\n```\\n\\n## 4. Bottom-up DP with space optimization\\n**Time complexity: O(K * S)** \\n**Space complexity: O(N * M)**\\n\\n```java\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // initialize dp table\\n        int[][] curTable = new int[m + 1][n + 1];\\n        \\n        for (int i = 0; i < strs.length + 1; i++) {\\n            int[][] prevTable = curTable;\\n            curTable = new int[m + 1][n + 1];\\n            \\n            for (int j = 0; j < m + 1; j++) {\\n                for (int k = 0; k < n + 1; k++) {\\n                    // base case\\n                    if (i == 0) {\\n                        curTable[j][k] = 0;\\n                        continue;\\n                    }\\n                    \\n                    // 1. skip current element\\n                    curTable[j][k] = prevTable[j][k];\\n\\n                    // count zeros and ones left after the current element\\n                    int zeros = j, ones = k;\\n                    for (char bit: strs[i - 1].toCharArray()) {\\n                        if (bit == \\'0\\')\\n                            zeros--;\\n                        else\\n                            ones--;\\n                    }\\n\\n                    // 2. select current element if possible\\n                    if (zeros >= 0 && ones >= 0)\\n                        curTable[j][k] = Math.max(curTable[j][k], 1 + prevTable[zeros][ones]);\\n                }\\n            }\\n        }\\n        \\n        return curTable[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    String[] strs;\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        this.strs = strs;\\n        \\n        // call helper function\\n        return recurse(strs.length, m, n);\\n    }\\n    \\n    private int recurse(int size, int m, int n) {\\n        // base case\\n        if (size == 0)\\n            return 0;\\n        \\n        // 1. skip current element\\n        int skip = recurse(size - 1, m, n);\\n        \\n        // update m, n with the last element\\n        for (char bit: strs[size - 1].toCharArray()) {\\n            if (bit == \\'0\\')\\n                m--;\\n            else\\n                n--;\\n        }\\n        \\n        // 2. choose current element if possible\\n        int choose = 0;\\n        if (m >= 0 && n >= 0)\\n            choose = 1 + recurse(size - 1, m, n);\\n        \\n        // return the optimal answer\\n        return Math.max(skip, choose);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    String[] strs;\\n    int[][][] memo;\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        this.strs = strs;\\n        \\n        // initialize dp table\\n        memo = new int[strs.length + 1][m + 1][n + 1];\\n        for (int i = 0; i < strs.length + 1; i++) {\\n            for (int j = 0; j < m + 1; j++) {\\n                Arrays.fill(memo[i][j], i == 0 ? 0 : -1);\\n            }\\n        }\\n        \\n        // call helper function\\n        return recurse(strs.length, m, n);\\n    }\\n    \\n    private int recurse(int size, int m, int n) {\\n        // base case and dp table check\\n        if (memo[size][m][n] != -1)\\n            return memo[size][m][n];\\n        \\n        // 1. skip current element\\n        int skip = recurse(size - 1, m, n);\\n        \\n        // update m, n with the last element\\n        int newM = m, newN = n;\\n        for (char bit: strs[size - 1].toCharArray()) {\\n            if (bit == \\'0\\')\\n                newM--;\\n            else\\n                newN--;\\n        }\\n        \\n        // 2. choose current element if possible\\n        int choose = 0;\\n        if (newM >= 0 && newN >= 0)\\n            choose = 1 + recurse(size - 1, newM, newN);\\n        \\n        // return the optimal answer\\n        memo[size][m][n] = Math.max(skip, choose);\\n        return memo[size][m][n];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // initialize dp table\\n        int[][][] table = new int[strs.length + 1][m + 1][n + 1];\\n        \\n        for (int i = 0; i < strs.length + 1; i++) {\\n            for (int j = 0; j < m + 1; j++) {\\n                for (int k = 0; k < n + 1; k++) {\\n                    // base case\\n                    if (i == 0) {\\n                        table[i][j][k] = 0;\\n                        continue;\\n                    }\\n                    \\n                    // 1. skip current element\\n                    table[i][j][k] = table[i - 1][j][k];\\n\\n                    // count zeros and ones left after the current element\\n                    int zeros = j, ones = k;\\n                    for (char bit: strs[i - 1].toCharArray()) {\\n                        if (bit == \\'0\\')\\n                            zeros--;\\n                        else\\n                            ones--;\\n                    }\\n\\n                    // 2. select current element if possible\\n                    if (zeros >= 0 && ones >= 0)\\n                        table[i][j][k] = Math.max(table[i][j][k], 1 + table[i - 1][zeros][ones]);\\n                }\\n            }\\n        }\\n        \\n        return table[strs.length][m][n];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // initialize dp table\\n        int[][] curTable = new int[m + 1][n + 1];\\n        \\n        for (int i = 0; i < strs.length + 1; i++) {\\n            int[][] prevTable = curTable;\\n            curTable = new int[m + 1][n + 1];\\n            \\n            for (int j = 0; j < m + 1; j++) {\\n                for (int k = 0; k < n + 1; k++) {\\n                    // base case\\n                    if (i == 0) {\\n                        curTable[j][k] = 0;\\n                        continue;\\n                    }\\n                    \\n                    // 1. skip current element\\n                    curTable[j][k] = prevTable[j][k];\\n\\n                    // count zeros and ones left after the current element\\n                    int zeros = j, ones = k;\\n                    for (char bit: strs[i - 1].toCharArray()) {\\n                        if (bit == \\'0\\')\\n                            zeros--;\\n                        else\\n                            ones--;\\n                    }\\n\\n                    // 2. select current element if possible\\n                    if (zeros >= 0 && ones >= 0)\\n                        curTable[j][k] = Math.max(curTable[j][k], 1 + prevTable[zeros][ones]);\\n                }\\n            }\\n        }\\n        \\n        return curTable[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214176,
                "title": "c-solution-with-simple-intuition-and-explanation-bottom-up-dp-knapsack",
                "content": "```\\n/*\\nIntuition: Similar to knapsack with one additional parameter\\ndp[i][j][k] denotes the max length for i ones, j zeros, if we consider first k \\nelements of the array\\ncurrMax denotes dp[i][j][index_of_currElement]\\nWe just have two options:\\n1. Take the curr element in subset :\\nmax(currMax, dp[i - ones_in_currElement][j - zeros_in_currElement][index _of_currElement- 1] + 1)\\n2. Don\\'t take\\ndp[i][j][index - 1]\\n*/\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size(), j = 0;\\n        vector<pair<int, int>> zeros(len); //stores number of zeros and ones in each array element\\n        for(string str : strs) {\\n            int i = 0;\\n            for(char c : str) {\\n                if(c == \\'1\\')\\n                    i++;\\n            }\\n            zeros[j] = {i, str.size() - i};\\n            j++;\\n        };\\n        int dp[n + 1][m + 1][len + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 0; i <= n; i++) {\\n            for(int j = 0; j <= m; j++) {\\n                for(int index = 1; index <= len; index++) {\\n                    if(i - zeros[index - 1].first >= 0 && j - zeros[index - 1].second >= 0) {\\n                        dp[i][j][index] = max(dp[i][j][index], dp[i - zeros[index - 1].first][j - zeros[index - 1].second][index - 1] + 1);\\n                    }\\n                    dp[i][j][index] = max(dp[i][j][index], dp[i][j][index - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m][len];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nIntuition: Similar to knapsack with one additional parameter\\ndp[i][j][k] denotes the max length for i ones, j zeros, if we consider first k \\nelements of the array\\ncurrMax denotes dp[i][j][index_of_currElement]\\nWe just have two options:\\n1. Take the curr element in subset :\\nmax(currMax, dp[i - ones_in_currElement][j - zeros_in_currElement][index _of_currElement- 1] + 1)\\n2. Don\\'t take\\ndp[i][j][index - 1]\\n*/\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size(), j = 0;\\n        vector<pair<int, int>> zeros(len); //stores number of zeros and ones in each array element\\n        for(string str : strs) {\\n            int i = 0;\\n            for(char c : str) {\\n                if(c == \\'1\\')\\n                    i++;\\n            }\\n            zeros[j] = {i, str.size() - i};\\n            j++;\\n        };\\n        int dp[n + 1][m + 1][len + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 0; i <= n; i++) {\\n            for(int j = 0; j <= m; j++) {\\n                for(int index = 1; index <= len; index++) {\\n                    if(i - zeros[index - 1].first >= 0 && j - zeros[index - 1].second >= 0) {\\n                        dp[i][j][index] = max(dp[i][j][index], dp[i - zeros[index - 1].first][j - zeros[index - 1].second][index - 1] + 1);\\n                    }\\n                    dp[i][j][index] = max(dp[i][j][index], dp[i][j][index - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m][len];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208970,
                "title": "knapsack-step-by-step-explanation-with-example-and-iteration",
                "content": "Here since we have to consider size,no of 0\\'s and 1\\'s hence we will take 3d dp.\\ndp table  for example 2 :-Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 will be---->>\\n\\n dp[1][0][0]=0;dp[1][0][1]=0;dp[1][1][0]=0;dp[1][1][1]=1;\\n dp[2][0][0]=0;dp[2][0][1]=0;dp[2][1][0]=1;dp[2][1][1]=1;\\n  dp[3][0][0]=0;dp[3][0][1]=1;dp[3][1][0]=1;dp[3][1][1]=2;\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz=strs.size();\\n        int dp[sz+1][m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int res=0;\\n        for(int i=1;i<=sz;i++){\\n            int cnt1=count(strs[i-1].begin(),strs[i-1].end(),\\'1\\');  //count no of 1\\'s in each substring\\n            int cnt0=strs[i-1].size()-cnt1;                           //count no of 0\\'s in each substring\\n                                                                        \\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=dp[i-1][j][k];\\n                    if(j>=cnt0&&k>=cnt1){                    //when substring have more or equal no of cnt1 and cnt0 \\n                        dp[i][j][k]=max(dp[i][j][k],1+dp[i-1][j-cnt0][k-cnt1]); //Either we will take individual dp or we will take previous one and then size will be incremented by 1\\n                        \\n                    }\\n                    res=max(res,dp[i][j][k]);                //take maximum count of substring\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz=strs.size();\\n        int dp[sz+1][m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int res=0;\\n        for(int i=1;i<=sz;i++){\\n            int cnt1=count(strs[i-1].begin(),strs[i-1].end(),\\'1\\');  //count no of 1\\'s in each substring\\n            int cnt0=strs[i-1].size()-cnt1;                           //count no of 0\\'s in each substring\\n                                                                        \\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=dp[i-1][j][k];\\n                    if(j>=cnt0&&k>=cnt1){                    //when substring have more or equal no of cnt1 and cnt0 \\n                        dp[i][j][k]=max(dp[i][j][k],1+dp[i-1][j-cnt0][k-cnt1]); //Either we will take individual dp or we will take previous one and then size will be incremented by 1\\n                        \\n                    }\\n                    res=max(res,dp[i][j][k]);                //take maximum count of substring\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139561,
                "title": "java-simple-and-easy-to-understand-solution-using-dp-memoization-clean-code-with-comments",
                "content": "****\\n\\n\\n```\\nclass Solution {\\n    int[][][] cache;\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] counts = new int[strs.length][2];\\n        for(int i = 0; i < strs.length; i++){\\n            //store the counts of zeroes\\n            counts[i] = getCount(strs[i]);\\n        }\\n        \\n        cache = new int[strs.length][m + 1][n + 1];\\n        \\n        return getMaxLengthSubset(0, counts, m, n);\\n    }\\n    \\n    private int getMaxLengthSubset(int index, int[][] counts, int zeroes, int ones){\\n        if(index == counts.length){\\n            return 0;\\n        }\\n        \\n        //retrive from cache\\n        if(cache[index][zeroes][ones] != 0) return cache[index][zeroes][ones];\\n        \\n        \\n        //Aproach \\n        //here we using the backtracking \\n        //1. consider     :  add current binary string in subset,\\n        //2. not consider :  just ignore this current string, move to another \\n        \\n        \\n        //this time consider, current binary string count\\n        int considered = 0;\\n        int remainingZeroes = zeroes - counts[index][0];\\n        int remainingOnes   = ones - counts[index][1];\\n        \\n        if(remainingZeroes >= 0 && remainingOnes >= 0){\\n            //call getMaxLengthSubset, pass the remaining Zeroes and ones\\n            considered = 1 + getMaxLengthSubset(index + 1, counts, remainingZeroes, remainingOnes);\\n        }\\n        \\n        //ignore this string\\n        //call getMaxLengthSubset, pass actual Zeroes and Ones\\n        int notConsidered = getMaxLengthSubset(index + 1, counts, zeroes, ones);\\n        \\n        //find max number subset store in the cache\\n        cache[index][zeroes][ones] = Math.max(considered, notConsidered);\\n        \\n        return cache[index][zeroes][ones];\\n    }\\n    \\n    private int[] getCount(String str){\\n        int[] count = new int[2];\\n        \\n        //count zeroes and ones of current string\\n        for(char c : str.toCharArray()){\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][][] cache;\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] counts = new int[strs.length][2];\\n        for(int i = 0; i < strs.length; i++){\\n            //store the counts of zeroes\\n            counts[i] = getCount(strs[i]);\\n        }\\n        \\n        cache = new int[strs.length][m + 1][n + 1];\\n        \\n        return getMaxLengthSubset(0, counts, m, n);\\n    }\\n    \\n    private int getMaxLengthSubset(int index, int[][] counts, int zeroes, int ones){\\n        if(index == counts.length){\\n            return 0;\\n        }\\n        \\n        //retrive from cache\\n        if(cache[index][zeroes][ones] != 0) return cache[index][zeroes][ones];\\n        \\n        \\n        //Aproach \\n        //here we using the backtracking \\n        //1. consider     :  add current binary string in subset,\\n        //2. not consider :  just ignore this current string, move to another \\n        \\n        \\n        //this time consider, current binary string count\\n        int considered = 0;\\n        int remainingZeroes = zeroes - counts[index][0];\\n        int remainingOnes   = ones - counts[index][1];\\n        \\n        if(remainingZeroes >= 0 && remainingOnes >= 0){\\n            //call getMaxLengthSubset, pass the remaining Zeroes and ones\\n            considered = 1 + getMaxLengthSubset(index + 1, counts, remainingZeroes, remainingOnes);\\n        }\\n        \\n        //ignore this string\\n        //call getMaxLengthSubset, pass actual Zeroes and Ones\\n        int notConsidered = getMaxLengthSubset(index + 1, counts, zeroes, ones);\\n        \\n        //find max number subset store in the cache\\n        cache[index][zeroes][ones] = Math.max(considered, notConsidered);\\n        \\n        return cache[index][zeroes][ones];\\n    }\\n    \\n    private int[] getCount(String str){\\n        int[] count = new int[2];\\n        \\n        //count zeroes and ones of current string\\n        for(char c : str.toCharArray()){\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138678,
                "title": "dp-top-down-approach-c-with-explanation",
                "content": "The problem has small constraints for number of strings and the string sizes themselves. So a simple 3D array can be used.\\nThe problem has some confusing terminology regarding largest subset. Basically they expect **the most number of strings in strs** which are used to form the target string having at most m zeros and n ones. \\n\\nInitially I tried a greedy approach but that didn\\'t pass the test cases. So then I looked at the problem from an inclusion exclusion perspective and wrote the recursive code. Then after the recursion code passed I added memoization. For me it really helps to first solve the problem and then add memoziation. \\n\\nBasically at each string we have a choice to make, either it belongs to the set or it doesn\\'t. If the string contains more 0s or 1s than we have remaining ignore it. Otherwise we can choose to add it.\\n\\nAt the end we need to choose the maximum between ignoring the string or adding it to the result set. \\n\\nHere dp[i][j][k] will return the largest subset size from string at index i where we have j zeros and k ones remaining.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int recurse(vector<string>& strs, int m, int n, int index){\\n        if(index == strs.size()) return 0;\\n        if(m == 0 && n == 0) return 0;\\n        if(dp[index][m][n] != -1) return dp[index][m][n];\\n        string s = strs[index];\\n        int count_zero = 0;\\n        int count_one = 0;\\n        for(char c: s)\\n            if(c == \\'0\\') count_zero++;\\n            else count_one++; \\n        int chose = 0;\\n        if(count_zero<=m && count_one<=n){\\n            chose = 1+recurse(strs,m-count_zero,n-count_one,index+1);\\n        }\\n        return dp[index][m][n] = max(chose,recurse(strs,m,n,index+1));\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        for(int i=0;i<=600;i++)\\n            for(int j=0;j<=100;j++)\\n                for(int k=0;k<=100;k++)\\n                    dp[i][j][k] = -1;\\n        int index = 0;\\n        return recurse(strs,m,n,index);\\n    }\\n};\\n```\\n\\nFeel free to ask questions if something isn\\'t clear. Trying to improve on my editorial  skills.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int recurse(vector<string>& strs, int m, int n, int index){\\n        if(index == strs.size()) return 0;\\n        if(m == 0 && n == 0) return 0;\\n        if(dp[index][m][n] != -1) return dp[index][m][n];\\n        string s = strs[index];\\n        int count_zero = 0;\\n        int count_one = 0;\\n        for(char c: s)\\n            if(c == \\'0\\') count_zero++;\\n            else count_one++; \\n        int chose = 0;\\n        if(count_zero<=m && count_one<=n){\\n            chose = 1+recurse(strs,m-count_zero,n-count_one,index+1);\\n        }\\n        return dp[index][m][n] = max(chose,recurse(strs,m,n,index+1));\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        for(int i=0;i<=600;i++)\\n            for(int j=0;j<=100;j++)\\n                for(int k=0;k<=100;k++)\\n                    dp[i][j][k] = -1;\\n        int index = 0;\\n        return recurse(strs,m,n,index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138553,
                "title": "ones-and-zeroes-easy-3-d-knapsack-c-dp",
                "content": "This question can be solved like a 0/1 knapsack. \\nIn classic 0/1 knapsack we use 2-D matrix for DP, here we use a 3-D matrix.\\nIf you understand classic 0/1 knapsack, this question would be a cakewalk.\\nNOTE : Here I used DP matrix of 3 dimension for simplicity, but same can also be solved a using a DP matrix of 2 dimension.\\n\\n**Steps -**\\n\\n1) Make a n*2 matrix comp which stores number of zeros and ones in a string .\\n```\\nfor(int i=0;i<strs.size();i++)\\n{\\n\\tfor(int j=0;j<strs[i].size();j++)\\n\\t{\\n\\t\\tif(strs[i][j]==\\'0\\')\\n\\t\\t\\tcomp[i][0]++;    \\n\\t}\\n\\tcomp[i][1]=strs[i].size()-comp[i][0];\\n}\\n```\\n\\n\\n2) Now create 3 nested for loops for strs.size(), m, n respectively and fill DP as shown below.\\n\\n\\n```\\nfor(int i=0;i<=strs.size()++)\\n{\\n\\tfor(int j=0 ; j<=m;j++)\\n\\t{\\n\\t\\tfor(int k=0;k<=n;k++)\\n\\t\\t\\tif(i==0)\\n\\t\\t\\t\\tdp[i][j][k]=0;\\n\\t\\t\\telse if(j>=comp[i-1][0] && k>=comp[i-1][1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i][j][k]=max(dp[i-1][j][k],1+dp[i-1][j-comp[i-1][0]][k-comp[i-1][1]]);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][j][k]=dp[i-1][j][k];\\n\\t}   \\n}\\n```\\n3) return dp[strs.size()][m][n];\\n\\n\\nUpvote if it helped a bit : )\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor(int i=0;i<strs.size();i++)\\n{\\n\\tfor(int j=0;j<strs[i].size();j++)\\n\\t{\\n\\t\\tif(strs[i][j]==\\'0\\')\\n\\t\\t\\tcomp[i][0]++;    \\n\\t}\\n\\tcomp[i][1]=strs[i].size()-comp[i][0];\\n}\\n```\n```\\nfor(int i=0;i<=strs.size()++)\\n{\\n\\tfor(int j=0 ; j<=m;j++)\\n\\t{\\n\\t\\tfor(int k=0;k<=n;k++)\\n\\t\\t\\tif(i==0)\\n\\t\\t\\t\\tdp[i][j][k]=0;\\n\\t\\t\\telse if(j>=comp[i-1][0] && k>=comp[i-1][1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i][j][k]=max(dp[i-1][j][k],1+dp[i-1][j-comp[i-1][0]][k-comp[i-1][1]]);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][j][k]=dp[i-1][j][k];\\n\\t}   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057202,
                "title": "java-memoization-knapsack-very-easy-and-intuitive",
                "content": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        \\n        return dp(strs,m,n,0,new HashMap<>());\\n    }\\n    \\n    private int dp(String[] strs, int m, int n,int i,Map<String,Integer> map){\\n        \\n        if(m==0 && n ==0 || i >= strs.length) // base condition\\n            return 0;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        String key = sb.append(m).append(\\',\\').append(n).append(\\',\\').append(i).toString(); // key generation for memoization, store in a map\\n        // System.out.println(key);\\n        \\n        if(map.containsKey(key))\\n            return map.get(key);\\n        \\n        int z = 0,o=0,res;\\n        for(char a : strs[i].toCharArray()) // counting 0\\'s and 1\\'s in the str at index i\\n            if(a == \\'0\\') z++;\\n            else o++;\\n        \\n        \\n        \\n        if(z>m || o>n)\\n            res =  dp(strs,m,n,i+1,map); // skip the current string at index i, if it crosses the limit of m or n\\n        else \\n            res =  Math.max(dp(strs,m,n,i+1,map),1 + dp(strs,m-z,n-o,i+1,map)); // typical knapsack condition Max(without,with)\\n        map.put(key,res); // memoization\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        \\n        return dp(strs,m,n,0,new HashMap<>());\\n    }\\n    \\n    private int dp(String[] strs, int m, int n,int i,Map<String,Integer> map){\\n        \\n        if(m==0 && n ==0 || i >= strs.length) // base condition\\n            return 0;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        String key = sb.append(m).append(\\',\\').append(n).append(\\',\\').append(i).toString(); // key generation for memoization, store in a map\\n        // System.out.println(key);\\n        \\n        if(map.containsKey(key))\\n            return map.get(key);\\n        \\n        int z = 0,o=0,res;\\n        for(char a : strs[i].toCharArray()) // counting 0\\'s and 1\\'s in the str at index i\\n            if(a == \\'0\\') z++;\\n            else o++;\\n        \\n        \\n        \\n        if(z>m || o>n)\\n            res =  dp(strs,m,n,i+1,map); // skip the current string at index i, if it crosses the limit of m or n\\n        else \\n            res =  Math.max(dp(strs,m,n,i+1,map),1 + dp(strs,m-z,n-o,i+1,map)); // typical knapsack condition Max(without,with)\\n        map.put(key,res); // memoization\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025400,
                "title": "top-down-vs-bottom-up-easy-to-understand-dhruv-vavliya",
                "content": "```\\n# Written by : Dhruv vavliya\\n\\nstrs = [\"001\", \"110\",\"0000\",\"0000\"]\\nm = 9\\nn = 2\\n\\ndef go(strs,index,m,n,dp):\\n    if m<0 or n<0:\\n        return float(\\'-inf\\')\\n    if index == len(strs):\\n        return 0\\n    if dp[index][m][n]!=-1:\\n        return dp[index][m][n]\\n\\n    zero = strs[index].count(\\'0\\')\\n    one = strs[index].count(\\'1\\')\\n    if zero <= m and one <= n:\\n        dp[index][m][n] = max( 1 + go(strs,index+1,m-zero,n-one,dp),\\n                               go(strs,index+1,m,n,dp))\\n    else:\\n        dp[index][m][n] = go(strs,index+1,m,n,dp)\\n\\n    return dp[index][m][n]\\n\\n\\ndef one_zero(strs,m,n):\\n    dp  = [ [ [-1]*(n+1) for _ in range(m+1) ]  for _ in range(len(strs))]\\n    return go(strs,0,m,n,dp),dp\\n\\nprint(one_zero(strs,m,n))\\n\\n\\n# bottom-up DP\\ndef ones_zeroes(strs,m,n):\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for s in strs:\\n        zero = s.count(\\'0\\')\\n        one = s.count(\\'1\\')\\n\\n        for i in range(m,-1,-1):\\n            for j in range(n,-1,-1):\\n                if zero <= i and one <= j:\\n                    dp[i][j] = max( dp[i][j] ,1 + dp[i-zero][j-one])\\n                # else:\\n                #     dp[i][j] = dp[i][j]    # but don\\'t care take or not\\n\\n    return dp[-1][-1]\\n\\n# print(ones_zeroes(strs,m,n))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n# Written by : Dhruv vavliya\\n\\nstrs = [\"001\", \"110\",\"0000\",\"0000\"]\\nm = 9\\nn = 2\\n\\ndef go(strs,index,m,n,dp):\\n    if m<0 or n<0:\\n        return float(\\'-inf\\')\\n    if index == len(strs):\\n        return 0\\n    if dp[index][m][n]!=-1:\\n        return dp[index][m][n]\\n\\n    zero = strs[index].count(\\'0\\')\\n    one = strs[index].count(\\'1\\')\\n    if zero <= m and one <= n:\\n        dp[index][m][n] = max( 1 + go(strs,index+1,m-zero,n-one,dp),\\n                               go(strs,index+1,m,n,dp))\\n    else:\\n        dp[index][m][n] = go(strs,index+1,m,n,dp)\\n\\n    return dp[index][m][n]\\n\\n\\ndef one_zero(strs,m,n):\\n    dp  = [ [ [-1]*(n+1) for _ in range(m+1) ]  for _ in range(len(strs))]\\n    return go(strs,0,m,n,dp),dp\\n\\nprint(one_zero(strs,m,n))\\n\\n\\n# bottom-up DP\\ndef ones_zeroes(strs,m,n):\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for s in strs:\\n        zero = s.count(\\'0\\')\\n        one = s.count(\\'1\\')\\n\\n        for i in range(m,-1,-1):\\n            for j in range(n,-1,-1):\\n                if zero <= i and one <= j:\\n                    dp[i][j] = max( dp[i][j] ,1 + dp[i-zero][j-one])\\n                # else:\\n                #     dp[i][j] = dp[i][j]    # but don\\'t care take or not\\n\\n    return dp[-1][-1]\\n\\n# print(ones_zeroes(strs,m,n))\\n\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 946025,
                "title": "c-easy-to-understand-01-knapsack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<int> zeros(strs.size(), 0), ones(strs.size(), 0);\\n        \\n        for (int i = 0; i < strs.size(); i++) {\\n            string s = strs[i]; int count = 0;\\n            \\n            for (const auto& c : s) {\\n                if (c == \\'1\\') count++;\\n            }\\n            \\n            ones[i] = count; zeros[i] = s.size() - count;\\n        }\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)); \\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < strs.size(); i++) {\\n            for (int x = m; x >= zeros[i]; x--) {\\n                for (int y = n; y >= ones[i]; y--) {\\n                    dp[x][y] = max(dp[x][y], dp[x - zeros[i]][y - ones[i]] + 1);\\n                }\\n            }\\n        }\\n            \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<int> zeros(strs.size(), 0), ones(strs.size(), 0);\\n        \\n        for (int i = 0; i < strs.size(); i++) {\\n            string s = strs[i]; int count = 0;\\n            \\n            for (const auto& c : s) {\\n                if (c == \\'1\\') count++;\\n            }\\n            \\n            ones[i] = count; zeros[i] = s.size() - count;\\n        }\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)); \\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < strs.size(); i++) {\\n            for (int x = m; x >= zeros[i]; x--) {\\n                for (int y = n; y >= ones[i]; y--) {\\n                    dp[x][y] = max(dp[x][y], dp[x - zeros[i]][y - ones[i]] + 1);\\n                }\\n            }\\n        }\\n            \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915778,
                "title": "c-dp-0-1-knapsack-solution",
                "content": "Runtime: 240 ms, faster than 66.64% of C++ online submissions for Ones and Zeroes.\\nMemory Usage: 10.1 MB, less than 11.06% of C++ online submissions for Ones and Zeroes.\\n\\n```\\nGenerate Count vector from strs strings containing zero and one count <zero,one>.\\nNow this becomes a DP problem to find largest possible subset for target <m,n> => <zero,one>\\nwhich can be solved using 0-1 knapsack solution approach.\\n\\nDP vector M * N, DP[i][j] tracks the largest possible subset for <i,j> => <zero,one> (DP state)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        int size = strs.size();\\n        \\n        // track zero and one count of strs[i] string\\n        vector<pair<int,int>>freqCount(size);\\n        \\n        // populate zero and one count of strings in strs\\n        for(int i=0;i<size;i++)\\n        {\\n            int oc = count(strs[i].begin(),strs[i].end(),\\'1\\');\\n            \\n            freqCount[i] = {strs[i].length()-oc,oc};\\n        }\\n        \\n        // M*N dp vector where dp[i][j] track max largest subset possible for m = i and n = j \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n          \\n        // loop through the strings of strs (consider each string once) \\n        for(int k=0;k<size;k++)\\n        {\\n            int zc = freqCount[k].first;\\n            int oc = freqCount[k].second;\\n            \\n            // generate result from target <m,n> to <zc,oc>\\n            for(int i=m;i>=zc;i--)\\n            {\\n                for(int j=n;j>=oc;j--)\\n                {\\n                    // ignore <0,0> state\\n                    if(i==0 && j==0) continue;\\n                    \\n                    // get largest subset possible for dp[i][j]\\n                    dp[i][j] = max(dp[i][j],dp[i-zc][j-oc]+1);\\n                }\\n            }\\n        }\\n        \\n        // largest subset possible for target <m,n> => <zero,one>\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nGenerate Count vector from strs strings containing zero and one count <zero,one>.\\nNow this becomes a DP problem to find largest possible subset for target <m,n> => <zero,one>\\nwhich can be solved using 0-1 knapsack solution approach.\\n\\nDP vector M * N, DP[i][j] tracks the largest possible subset for <i,j> => <zero,one> (DP state)\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        int size = strs.size();\\n        \\n        // track zero and one count of strs[i] string\\n        vector<pair<int,int>>freqCount(size);\\n        \\n        // populate zero and one count of strings in strs\\n        for(int i=0;i<size;i++)\\n        {\\n            int oc = count(strs[i].begin(),strs[i].end(),\\'1\\');\\n            \\n            freqCount[i] = {strs[i].length()-oc,oc};\\n        }\\n        \\n        // M*N dp vector where dp[i][j] track max largest subset possible for m = i and n = j \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n          \\n        // loop through the strings of strs (consider each string once) \\n        for(int k=0;k<size;k++)\\n        {\\n            int zc = freqCount[k].first;\\n            int oc = freqCount[k].second;\\n            \\n            // generate result from target <m,n> to <zc,oc>\\n            for(int i=m;i>=zc;i--)\\n            {\\n                for(int j=n;j>=oc;j--)\\n                {\\n                    // ignore <0,0> state\\n                    if(i==0 && j==0) continue;\\n                    \\n                    // get largest subset possible for dp[i][j]\\n                    dp[i][j] = max(dp[i][j],dp[i-zc][j-oc]+1);\\n                }\\n            }\\n        }\\n        \\n        // largest subset possible for target <m,n> => <zero,one>\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882629,
                "title": "easy-c-memo-with-comments-knapsack-0-1",
                "content": "consider it as knapsack where profit is 1 rs for all the string and wieght is no of zero and one in that string and m,n in capacity\\n```\\nclass Solution {\\npublic:\\n    int dp[601][101][101]; \\n\\t// i is index,l is length\\n    int helper(int i,int m,int n,int l,vector<string>& strs){\\n        if(m==0 && n==0) // no more one and zero available\\n            return dp[i][m][n]= 0;\\n        if(i==l)  // end of vector\\n            return  dp[i][m][n]= 0;\\n        if( dp[i][m][n]!=-1){\\n            return  dp[i][m][n];\\n        }\\n        int nz =0, no = 0; //nz -number  of zero , no -number of one\\n        \\n    // count number of zeroes and ones in current string\\n    for (auto c : strs[i]) {\\n      if (c == \\'0\\')\\n\\tnz++;\\n      else if (c == \\'1\\')\\n\\tno++;\\n    }\\n        \\n       int a=-2;\\n        int b=-2;\\n      if(n>=no && m>=nz){ //we have required capacity of one and zeron to take this string \\n         a= helper(i+1,m-nz,n-no,l,strs)+1;// profit is 1\\n      }   \\n     b=helper(i+1,m,n,l,strs); //we do not include this string\\n        \\n        return  dp[i][m][n]=max(a,b);\\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n       return helper(0,m,n,strs.size(),strs);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[601][101][101]; \\n\\t// i is index,l is length\\n    int helper(int i,int m,int n,int l,vector<string>& strs){\\n        if(m==0 && n==0) // no more one and zero available\\n            return dp[i][m][n]= 0;\\n        if(i==l)  // end of vector\\n            return  dp[i][m][n]= 0;\\n        if( dp[i][m][n]!=-1){\\n            return  dp[i][m][n];\\n        }\\n        int nz =0, no = 0; //nz -number  of zero , no -number of one\\n        \\n    // count number of zeroes and ones in current string\\n    for (auto c : strs[i]) {\\n      if (c == \\'0\\')\\n\\tnz++;\\n      else if (c == \\'1\\')\\n\\tno++;\\n    }\\n        \\n       int a=-2;\\n        int b=-2;\\n      if(n>=no && m>=nz){ //we have required capacity of one and zeron to take this string \\n         a= helper(i+1,m-nz,n-no,l,strs)+1;// profit is 1\\n      }   \\n     b=helper(i+1,m,n,l,strs); //we do not include this string\\n        \\n        return  dp[i][m][n]=max(a,b);\\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n       return helper(0,m,n,strs.size(),strs);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837125,
                "title": "python-memoization-3-steps",
                "content": "```python\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        \\n        # 1. Optimization: If a string is length 1, always use it.\\n        count = 0\\n        strings = []\\n        for i in range(len(strs)):\\n            if (len(strs[i]) == 1):\\n                if (strs[i] == \\'0\\') and m:\\n                    m -= 1\\n                    count += 1\\n                    continue\\n                elif (strs[i] == \\'1\\') and n:\\n                    n -= 1\\n                    count += 1\\n                    continue\\n            strings.append(strs[i])\\n            \\n        # 2. Optimization: Keep a hashtable of string_id -> number of ones in the string\\n        ones = {}\\n        zeros = {}\\n        for i in range(len(strings)):\\n            ones[i] = strings[i].count(\\'1\\')\\n            zeros[i] = len(strings[i]) - ones[i]\\n        \\n        # 3. Memoization\\n        # 3.1 If we have used more 0 or 1 than allowed, return -1 to account for the string we should not have added.\\n        # 3.2 If i == len(strings), then we have considered every string, return 0 because there are no more strings for us to try adding.\\n        # 3.3 Try including and not including the string, return the option that yields the best result.\\n        @functools.lru_cache(None)\\n        def helper(i, m, n):\\n            if (m < 0) or (n < 0): return -1                                      # 3.1\\n            if i == len(strings): return 0                                        # 3.2\\n            return max(helper(i+1, m, n), 1 + helper(i+1, m-zeros[i], n-ones[i])) # 3.3\\n        \\n        return count + helper(0, m, n)\\n```\\n<img src=\"https://assets.leetcode.com/users/images/50ff6b7c-966e-40db-977f-a4476e88821e_1599607362.8844101.png\" width=\"50%\">\\n",
                "solutionTags": [],
                "code": "```python\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        \\n        # 1. Optimization: If a string is length 1, always use it.\\n        count = 0\\n        strings = []\\n        for i in range(len(strs)):\\n            if (len(strs[i]) == 1):\\n                if (strs[i] == \\'0\\') and m:\\n                    m -= 1\\n                    count += 1\\n                    continue\\n                elif (strs[i] == \\'1\\') and n:\\n                    n -= 1\\n                    count += 1\\n                    continue\\n            strings.append(strs[i])\\n            \\n        # 2. Optimization: Keep a hashtable of string_id -> number of ones in the string\\n        ones = {}\\n        zeros = {}\\n        for i in range(len(strings)):\\n            ones[i] = strings[i].count(\\'1\\')\\n            zeros[i] = len(strings[i]) - ones[i]\\n        \\n        # 3. Memoization\\n        # 3.1 If we have used more 0 or 1 than allowed, return -1 to account for the string we should not have added.\\n        # 3.2 If i == len(strings), then we have considered every string, return 0 because there are no more strings for us to try adding.\\n        # 3.3 Try including and not including the string, return the option that yields the best result.\\n        @functools.lru_cache(None)\\n        def helper(i, m, n):\\n            if (m < 0) or (n < 0): return -1                                      # 3.1\\n            if i == len(strings): return 0                                        # 3.2\\n            return max(helper(i+1, m, n), 1 + helper(i+1, m-zeros[i], n-ones[i])) # 3.3\\n        \\n        return count + helper(0, m, n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 791288,
                "title": "top-down-dp-recursion-memoization",
                "content": "Idea is similar to 0-1 Knapsack problem i.e. whether you take the ith string or not and recursively calculate for remaining index and remaining number of zeros and ones.\\n```\\nclass Solution {\\n    vector<pair<int,int> > preComp;\\n    int dp[601][102][102];\\npublic:\\n    int solve(int idx, int m, int n, int& sz)\\n    {\\n        // Base Cases\\n        if (m == 0 and n == 0)\\n            return 0;\\n        // End of array reached\\n        if (idx == sz)\\n            return 0;\\n        // Check if you already computed the given states\\n        if (dp[idx][m][n] != -1)\\n            return dp[idx][m][n];\\n        // If ith string has more number of zeros or ones than remaining zeros or ones\\n        if (preComp[idx].first > m or preComp[idx].second > n)\\n            return dp[idx][m][n] = solve(idx+1, m, n, sz);\\n        // else \\n        // ans = max( if you take ith string  , add one to answer and call for remaining indexes , zeros and ones,\\n        //           otherwise simply call for remaining indexes , zeros and ones)\\n        return dp[idx][m][n] = max(1+solve(idx+1, m-preComp[idx].first, n-preComp[idx].second, sz), solve(idx+1, m, n, sz));\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        preComp.clear();\\n        \\n        int sz = (int)strs.size();\\n        // Precimpute number of zeros and ones in each string \\n        // this would help in the case of string with larger length \\n        for(int i = 0 ; i < sz ; i++)\\n        {\\n            int countZero = 0 , countOne = 0;\\n            for(int j = 0 ; j < (int)strs[i].length(); j++)\\n                (strs[i][j] == \\'0\\') ? countZero++ : countOne++ ;\\n            preComp.push_back({countZero,countOne});\\n        }\\n        // Resetting DP states to -1\\n        memset(dp,-1,sizeof dp);\\n        \\n        return solve(0, m, n, sz);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<pair<int,int> > preComp;\\n    int dp[601][102][102];\\npublic:\\n    int solve(int idx, int m, int n, int& sz)\\n    {\\n        // Base Cases\\n        if (m == 0 and n == 0)\\n            return 0;\\n        // End of array reached\\n        if (idx == sz)\\n            return 0;\\n        // Check if you already computed the given states\\n        if (dp[idx][m][n] != -1)\\n            return dp[idx][m][n];\\n        // If ith string has more number of zeros or ones than remaining zeros or ones\\n        if (preComp[idx].first > m or preComp[idx].second > n)\\n            return dp[idx][m][n] = solve(idx+1, m, n, sz);\\n        // else \\n        // ans = max( if you take ith string  , add one to answer and call for remaining indexes , zeros and ones,\\n        //           otherwise simply call for remaining indexes , zeros and ones)\\n        return dp[idx][m][n] = max(1+solve(idx+1, m-preComp[idx].first, n-preComp[idx].second, sz), solve(idx+1, m, n, sz));\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        preComp.clear();\\n        \\n        int sz = (int)strs.size();\\n        // Precimpute number of zeros and ones in each string \\n        // this would help in the case of string with larger length \\n        for(int i = 0 ; i < sz ; i++)\\n        {\\n            int countZero = 0 , countOne = 0;\\n            for(int j = 0 ; j < (int)strs[i].length(); j++)\\n                (strs[i][j] == \\'0\\') ? countZero++ : countOne++ ;\\n            preComp.push_back({countZero,countOne});\\n        }\\n        // Resetting DP states to -1\\n        memset(dp,-1,sizeof dp);\\n        \\n        return solve(0, m, n, sz);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683378,
                "title": "simple-memoization-with-explanation",
                "content": "This is a problem of 0/1 knapsack.. but problem is in 3 dimension\\n```\\nclass Solution {\\npublic:\\n    int t[603][103][103];  // we will take a global 3d array to store the result   based on constraint.\\n    int memo(pair<int,int> p[],int size,int m,int n)\\n    {\\n        if(size==0)  // base condtion if size of string array (means no string remaining or exits) then we will return 0;\\n            return 0;\\n        if(m==0 && n==0)  // if( given value of  zeros(m) and ones(n) is zero (empty) then will return 0;\\n            return 0;\\n        if(t[size][m][n]!=-1)  // this is for memoization as check if  we already call(solve) the recursion function at t[size][m][n] (means value is not equal to -1) then return from here . we doing because in memoization concept we avoid the exxcess call of function if this function is already called before.\\t\\t\\n            return t[size][m][n];\\n        t[size][m][n]=0;// here we setting to zero so this will tell that we called this function and solve no need to call again(above line)\\n\\t\\t// below are based on logic daigram\\n        if(m-p[size-1].first>=0 && n-p[size-1].second>=0)// if m(left zero) and n((left one)are greater than current value of zero and ones\\n        {\\n            return t[size][m][n]=max(1+memo(p,size-1,m-p[size-1].first,n-p[size-1].second),memo(p,size-1,m,n));\\n        }\\n        else if( p[size-1].second==0 && m-p[size-1].first>=0) // if m is greater than current value of zero and  p[size-1[.second(currnetString_one) is 0\\n        {\\n            return t[size][m][n]=max(1+memo(p,size-1,m-p[size-1].first,n),memo(p,size-1,m,n));\\n        }\\n        else if(p[size-1].first==0 && n-p[size-1].second>=0)// if n is greater than current value of one and  p[size-1].first(currnetString_zero) is 0\\n        {\\n            return t[size][m][n]=max(1+memo(p,size-1,m,n-p[size-1].second),memo(p,size-1,m,n));\\n        }\\n        else\\n        {\\n            return t[size][m][n]=memo(p,size-1,m,n);\\n        }\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n    int size= strs.size();\\n        pair<int,int> p[size];\\n        for(int i=0;i<size;i++)\\n            p[i]=countofzero_one(strs[i]);\\n        \\n        memset(t,-1,sizeof(t)); // by this we set all the values in global 3d array to -1. (for memoziation cache) tell to call recusrion or not based on -1 value\\n        return memo(p,size,m,n);    \\n    }\\n\\t\\t// pair<int,int> countofzero_one(string s)  // this will provide the count of 1\\'s and 2\\'s in a given string and will return in the form of pair\\n    pair<int,int> countofzero_one(string s)\\n    {\\n        int zero=0,one=0;\\n        for(auto i:s)\\n        {\\n            if(i==\\'0\\')\\n                zero++;\\n            else \\n                one++;\\n        }\\n        return make_pair(zero,one);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[603][103][103];  // we will take a global 3d array to store the result   based on constraint.\\n    int memo(pair<int,int> p[],int size,int m,int n)\\n    {\\n        if(size==0)  // base condtion if size of string array (means no string remaining or exits) then we will return 0;\\n            return 0;\\n        if(m==0 && n==0)  // if( given value of  zeros(m) and ones(n) is zero (empty) then will return 0;\\n            return 0;\\n        if(t[size][m][n]!=-1)  // this is for memoization as check if  we already call(solve) the recursion function at t[size][m][n] (means value is not equal to -1) then return from here . we doing because in memoization concept we avoid the exxcess call of function if this function is already called before.\\t\\t\\n            return t[size][m][n];\\n        t[size][m][n]=0;// here we setting to zero so this will tell that we called this function and solve no need to call again(above line)\\n\\t\\t// below are based on logic daigram\\n        if(m-p[size-1].first>=0 && n-p[size-1].second>=0)// if m(left zero) and n((left one)are greater than current value of zero and ones\\n        {\\n            return t[size][m][n]=max(1+memo(p,size-1,m-p[size-1].first,n-p[size-1].second),memo(p,size-1,m,n));\\n        }\\n        else if( p[size-1].second==0 && m-p[size-1].first>=0) // if m is greater than current value of zero and  p[size-1[.second(currnetString_one) is 0\\n        {\\n            return t[size][m][n]=max(1+memo(p,size-1,m-p[size-1].first,n),memo(p,size-1,m,n));\\n        }\\n        else if(p[size-1].first==0 && n-p[size-1].second>=0)// if n is greater than current value of one and  p[size-1].first(currnetString_zero) is 0\\n        {\\n            return t[size][m][n]=max(1+memo(p,size-1,m,n-p[size-1].second),memo(p,size-1,m,n));\\n        }\\n        else\\n        {\\n            return t[size][m][n]=memo(p,size-1,m,n);\\n        }\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n    int size= strs.size();\\n        pair<int,int> p[size];\\n        for(int i=0;i<size;i++)\\n            p[i]=countofzero_one(strs[i]);\\n        \\n        memset(t,-1,sizeof(t)); // by this we set all the values in global 3d array to -1. (for memoziation cache) tell to call recusrion or not based on -1 value\\n        return memo(p,size,m,n);    \\n    }\\n\\t\\t// pair<int,int> countofzero_one(string s)  // this will provide the count of 1\\'s and 2\\'s in a given string and will return in the form of pair\\n    pair<int,int> countofzero_one(string s)\\n    {\\n        int zero=0,one=0;\\n        for(auto i:s)\\n        {\\n            if(i==\\'0\\')\\n                zero++;\\n            else \\n                one++;\\n        }\\n        return make_pair(zero,one);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461382,
                "title": "c-dynamic-programming-easy-implementation-with-comments-o-m-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> v( m+1 , vector<int>( n+1 , 0 ) );\\n        int l = strs.size();\\n        int i , j , k , z , o ;\\n        for( int  i = 0 ; i < l ; i++ ){ // include ith string and update the vector v[m][n]\\n        \\t\\n        \\to = count( strs[i].begin() , strs[i].end() , \\'1\\' );\\n        \\tz = strs[i].size() - o;\\n\\n        \\tfor( j = m ; j >= z ; j-- ){ // j should be greater than z( no of zeroes )\\n        \\t\\tfor( k = n ; k >= o ; k-- ){  // k should be greater than o ( no of ones )\\n        \\t\\t\\t\\n        \\t\\t\\tv[j][k] = max( v[j][k] , 1+v[ j - z ][ k - o ] ); \\n        \\t\\t\\n        \\t\\t}// for k \\n        \\t}// for j \\n        }\\n        return v[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> v( m+1 , vector<int>( n+1 , 0 ) );\\n        int l = strs.size();\\n        int i , j , k , z , o ;\\n        for( int  i = 0 ; i < l ; i++ ){ // include ith string and update the vector v[m][n]\\n        \\t\\n        \\to = count( strs[i].begin() , strs[i].end() , \\'1\\' );\\n        \\tz = strs[i].size() - o;\\n\\n        \\tfor( j = m ; j >= z ; j-- ){ // j should be greater than z( no of zeroes )\\n        \\t\\tfor( k = n ; k >= o ; k-- ){  // k should be greater than o ( no of ones )\\n        \\t\\t\\t\\n        \\t\\t\\tv[j][k] = max( v[j][k] , 1+v[ j - z ][ k - o ] ); \\n        \\t\\t\\n        \\t\\t}// for k \\n        \\t}// for j \\n        }\\n        return v[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351913,
                "title": "easy-java-solution-using-knapsack",
                "content": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs==null || m<0 || n<0) return 0;\\n        int[][] dp=new int[m+1][n+1];\\n        for(String str:strs){\\n            int ones=(int)str.chars().filter(num -> num==\\'1\\').count();\\n            int zeroes=str.length()-ones;\\n            for(int i=m;i>=zeroes;i--){\\n                for(int j=n;j>=ones;j--){\\n                    dp[i][j]=Math.max(dp[i][j],dp[i-zeroes][j-ones]+1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs==null || m<0 || n<0) return 0;\\n        int[][] dp=new int[m+1][n+1];\\n        for(String str:strs){\\n            int ones=(int)str.chars().filter(num -> num==\\'1\\').count();\\n            int zeroes=str.length()-ones;\\n            for(int i=m;i>=zeroes;i--){\\n                for(int j=n;j>=ones;j--){\\n                    dp[i][j]=Math.max(dp[i][j],dp[i-zeroes][j-ones]+1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95832,
                "title": "c-clean-and-short-dp-o-kmn-time-o-mn-space",
                "content": "Where K is the size of the string array, and m n are number of zeros and ones.\\n```\\nstruct Solution {\\n    int findMaxForm(vector<string>& strs, int zeros, int ones) {\\n        vector<vector<int>> dp(zeros + 1, vector<int>(ones + 1));\\n        for (int i = 0; i < strs.size(); ++i)\\n        {\\n            int cur_z = 0, cur_o = 0;\\n            for (auto n : strs[i])\\n                n == '0' ? cur_z ++ : cur_o ++;\\n            for (int z = zeros; z >= cur_z; -- z)\\n                for(int o = ones; o >= cur_o; -- o)\\n            \\t    dp[z][o] = max(dp[z - cur_z][o - cur_o] + 1, dp[z][o]);\\n        }\\n        return dp[zeros][ones];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Solution {\\n    int findMaxForm(vector<string>& strs, int zeros, int ones) {\\n        vector<vector<int>> dp(zeros + 1, vector<int>(ones + 1));\\n        for (int i = 0; i < strs.size(); ++i)\\n        {\\n            int cur_z = 0, cur_o = 0;\\n            for (auto n : strs[i])\\n                n == '0' ? cur_z ++ : cur_o ++;\\n            for (int z = zeros; z >= cur_z; -- z)\\n                for(int o = ones; o >= cur_o; -- o)\\n            \\t    dp[z][o] = max(dp[z - cur_z][o - cur_o] + 1, dp[z][o]);\\n        }\\n        return dp[zeros][ones];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95854,
                "title": "please-increase-the-time-limit-for-this-problem",
                "content": "Below is the top down python DP approach I came up with. It passes 57/60 test cases, and then gets TLE. I believe this approach is sufficient for an interview, and as such it should work for the OJ as well. Can the admin please at least *slightly* increase the time limit?\\nI did not make any 3d array cause I thought that would be very annoying to code, so I just used a hashmap \\n\\n```class Solution(object):\\n    def can_make(self, m, n, string):\\n        return m >= string[0] and n >= string[1]\\n    \\n    def calc_max_strings(self, m, n, i, memo, strs):\\n        if i == 0:\\n            if self.can_make(m, n, strs[0]):\\n                return 1\\n            return 0\\n        \\n        if (m,n,i) in memo:\\n            return memo[(m,n,i)]\\n            \\n        #choose to exclude i\\n        memo[(m,n,i)] = self.calc_max_strings(m, n, i-1, memo, strs)\\n        if self.can_make(m, n, strs[i]):\\n            create_i_max_strs = 1+self.calc_max_strings(m-strs[i][0], n-strs[i][1], i-1, memo, strs)\\n            memo[(m,n,i)] = max(memo[(m,n,i)], create_i_max_strs)\\n            \\n        return memo[(m,n,i)]\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        max_strings_memo = {}\\n        counted_strs = [None] * len(strs)\\n        for i in xrange(len(strs)):\\n            zero_cnt = 0\\n            one_cnt = 0\\n            for j in xrange(len(strs[i])):\\n                if strs[i][j] == \"0\":\\n                    zero_cnt += 1\\n                else:\\n                    one_cnt += 1\\n                    \\n            counted_strs[i] = [zero_cnt, one_cnt]\\n        \\n        return self.calc_max_strings(m, n, len(strs) - 1, max_strings_memo, counted_strs)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def can_make(self, m, n, string):\\n        return m >= string[0] and n >= string[1]\\n    \\n    def calc_max_strings(self, m, n, i, memo, strs):\\n        if i == 0:\\n            if self.can_make(m, n, strs[0]):\\n                return 1\\n            return 0\\n        \\n        if (m,n,i) in memo:\\n            return memo[(m,n,i)]\\n            \\n        #choose to exclude i\\n        memo[(m,n,i)] = self.calc_max_strings(m, n, i-1, memo, strs)\\n        if self.can_make(m, n, strs[i]):\\n            create_i_max_strs = 1+self.calc_max_strings(m-strs[i][0], n-strs[i][1], i-1, memo, strs)\\n            memo[(m,n,i)] = max(memo[(m,n,i)], create_i_max_strs)\\n            \\n        return memo[(m,n,i)]\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        max_strings_memo = {}",
                "codeTag": "Java"
            },
            {
                "id": 95871,
                "title": "c-bfs-with-unordered-map-29ms",
                "content": "If we use DP, there would be too many invalid searches.\\nInstead, if we iterate through partially built results with an unordered_map, we don't have to waste time on invalid searches.\\n\\n*60 / 60 test cases passed*\\n*Status: Accepted*\\n*Runtime: 29 ms*\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        uint max = 0;\\n        unordered_map<short, uint> cand, pool, tmp; // Put {zeros, ones} into one short\\n        pool.reserve(m * n);\\n        tmp.reserve(m * n);\\n        for (auto& s : strs) { // Combine similar candidates since only the counts of 0/1 matter\\n            short zero = 0, one = 0;\\n            for (auto& c : s) {\\n                if (c == '0') zero++;\\n                else one++;\\n            }\\n            if (zero <= m && one <= n) cand[zero << 8 | one]++;\\n        }\\n        pool.emplace(m << 8 | n, 0);\\n        for (auto& c : cand) { // BFS, try to add each candidate into already built results\\n            short zero = c.first >> 8, one = c.first & 0xFF;\\n            tmp = pool;\\n            for (auto& p : pool) {\\n                short zero_left = p.first >> 8, one_left = p.first & 0xFF;\\n                for (uint i = 1, ii = c.second; i <= ii; i++) { // Each candidate represents several similar strings\\n                    if ((zero_left -= zero) >= 0 && (one_left -= one) >= 0) {\\n                        auto it = tmp.find(zero_left << 8 | one_left);\\n                        if (it == tmp.end()) tmp[zero_left << 8 | one_left] = p.second + i;\\n                        else if (p.second + i > it->second) it->second = p.second + i;\\n                    } else break;\\n                }\\n            }\\n            pool.clear();\\n            pool.swap(tmp);\\n        }\\n        for (auto& p : pool) {\\n            if (p.second > max) max = p.second;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        uint max = 0;\\n        unordered_map<short, uint> cand, pool, tmp; // Put {zeros, ones} into one short\\n        pool.reserve(m * n);\\n        tmp.reserve(m * n);\\n        for (auto& s : strs) { // Combine similar candidates since only the counts of 0/1 matter\\n            short zero = 0, one = 0;\\n            for (auto& c : s) {\\n                if (c == '0') zero++;\\n                else one++;\\n            }\\n            if (zero <= m && one <= n) cand[zero << 8 | one]++;\\n        }\\n        pool.emplace(m << 8 | n, 0);\\n        for (auto& c : cand) { // BFS, try to add each candidate into already built results\\n            short zero = c.first >> 8, one = c.first & 0xFF;\\n            tmp = pool;\\n            for (auto& p : pool) {\\n                short zero_left = p.first >> 8, one_left = p.first & 0xFF;\\n                for (uint i = 1, ii = c.second; i <= ii; i++) { // Each candidate represents several similar strings\\n                    if ((zero_left -= zero) >= 0 && (one_left -= one) >= 0) {\\n                        auto it = tmp.find(zero_left << 8 | one_left);\\n                        if (it == tmp.end()) tmp[zero_left << 8 | one_left] = p.second + i;\\n                        else if (p.second + i > it->second) it->second = p.second + i;\\n                    } else break;\\n                }\\n            }\\n            pool.clear();\\n            pool.swap(tmp);\\n        }\\n        for (auto& p : pool) {\\n            if (p.second > max) max = p.second;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924490,
                "title": "accepted-greedy-solution-with-counterexample",
                "content": "# Overview\\nGreedily take strings based on some sorted order. 4 orders were examined: sorting by (# of 0\\'s, # of 1\\'s), sorting by (# of 1\\'s, # of 0\\'s), sorting (combined length, # of 0\\'s, # of 1\\'s), (combined length, # of 1\\'s, # of 0\\'s).\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        d = []\\n        for s in strs:\\n            cnts = [0,0]\\n            for char in s:\\n                if char == \\'0\\': \\n                    cnts[0] +=1\\n                else:\\n                    cnts[1] += 1\\n            if cnts[0] <= m and cnts[1] <= n:\\n                d.append(cnts)\\n        sorted_d3 = sorted(d, key=lambda x:(x[0]+x[1], x[0], x[1]))\\n        m_left, n_left = m, n\\n        ans3 = 0\\n        while sorted_d3:\\n            subset = sorted_d3.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans3 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        sorted_d4 = sorted(d, key=lambda x:(x[0]+x[1], x[1], x[0]))\\n        m_left, n_left = m, n\\n        ans4 = 0\\n        while sorted_d4:\\n            subset = sorted_d4.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans4 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        m_left, n_left = m, n\\n        sorted_d1 = sorted(d, key=lambda x:(x[0], x[1]))\\n        ans1 = 0\\n        while sorted_d1:\\n            subset = sorted_d1.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans1 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        m_left, n_left =  m, n\\n        sorted_d2 = sorted(d, key=lambda x:(x[1], x[0]))\\n        ans2 = 0\\n        while sorted_d2:\\n            subset = sorted_d2.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans2 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        return max(ans1, ans2, ans3, ans4)\\n```\\n\\nPasses all current test cases, but fails on this test:\\n[\"0000\", \"1110\", \"1100\", \"1100\"]\\nm = 4, n = 4",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        d = []\\n        for s in strs:\\n            cnts = [0,0]\\n            for char in s:\\n                if char == \\'0\\': \\n                    cnts[0] +=1\\n                else:\\n                    cnts[1] += 1\\n            if cnts[0] <= m and cnts[1] <= n:\\n                d.append(cnts)\\n        sorted_d3 = sorted(d, key=lambda x:(x[0]+x[1], x[0], x[1]))\\n        m_left, n_left = m, n\\n        ans3 = 0\\n        while sorted_d3:\\n            subset = sorted_d3.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans3 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        sorted_d4 = sorted(d, key=lambda x:(x[0]+x[1], x[1], x[0]))\\n        m_left, n_left = m, n\\n        ans4 = 0\\n        while sorted_d4:\\n            subset = sorted_d4.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans4 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        m_left, n_left = m, n\\n        sorted_d1 = sorted(d, key=lambda x:(x[0], x[1]))\\n        ans1 = 0\\n        while sorted_d1:\\n            subset = sorted_d1.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans1 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        m_left, n_left =  m, n\\n        sorted_d2 = sorted(d, key=lambda x:(x[1], x[0]))\\n        ans2 = 0\\n        while sorted_d2:\\n            subset = sorted_d2.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans2 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        return max(ans1, ans2, ans3, ans4)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805157,
                "title": "c-memoization-tabulation",
                "content": "# Memoization\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> memo(strs.size(), vector<vector<int>>(m + 1, vector<int>(n + 1, -1)));\\n        return dp(strs, m, n, 0, memo); \\n    }\\n\\nprivate:\\n    int dp(vector<string>& strs, int m, int n, int i, vector<vector<vector<int>>>& memo) {\\n        if (m == 0 && n == 0) return 0;\\n        if (i == strs.size()) return 0;\\n        if (memo[i][m][n] != -1) return memo[i][m][n];\\n\\n        int ones = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n        int zeros = strs[i].size() - ones;\\n        int take = 0;\\n        if (m >= zeros && n >= ones)\\n            take = 1 + dp(strs, m - zeros, n - ones, i + 1, memo);\\n        int dontTake = dp(strs, m, n, i + 1, memo);\\n\\n        return memo[i][m][n] = max(take, dontTake);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int N = strs.size();\\n        vector<vector<vector<int>>> dp(N + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, 0)));\\n\\n        for (int i = N-1; i >= 0; i--) {\\n            int ones = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n            int zeros = strs[i].size() - ones;\\n            for (int j = 0; j <= m; j++) {\\n                for (int k = 0; k <= n; k++) {\\n                    int take = 0;\\n                    if (j >= zeros && k >= ones)\\n                        take = 1 + dp[i + 1][j - zeros][k - ones];\\n                    int dontTake = dp[i + 1][j][k];\\n                    dp[i][j][k] = max(take, dontTake);\\n                }\\n            }\\n        }\\n\\n        return dp[0][m][n];\\n    }\\n};\\n```\\n\\n# Optimized Tabulation\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int N = strs.size();\\n        vector<vector<int>> curr(m + 1, vector<int>(n + 1, 0));\\n        vector<vector<int>> next(m + 1, vector<int>(n + 1, 0));\\n\\n\\n        for (int i = N-1; i >= 0; i--) {\\n            int ones = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n            int zeros = strs[i].size() - ones;\\n            for (int j = zeros; j <= m; j++) {\\n                for (int k = ones; k <= n; k++) {\\n                    int take = 1 + next[j - zeros][k - ones];\\n                    int dontTake = next[j][k];\\n                    curr[j][k] = max(take, dontTake);\\n                }\\n            }\\n            next = curr;\\n        }\\n\\n        return next[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> memo(strs.size(), vector<vector<int>>(m + 1, vector<int>(n + 1, -1)));\\n        return dp(strs, m, n, 0, memo); \\n    }\\n\\nprivate:\\n    int dp(vector<string>& strs, int m, int n, int i, vector<vector<vector<int>>>& memo) {\\n        if (m == 0 && n == 0) return 0;\\n        if (i == strs.size()) return 0;\\n        if (memo[i][m][n] != -1) return memo[i][m][n];\\n\\n        int ones = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n        int zeros = strs[i].size() - ones;\\n        int take = 0;\\n        if (m >= zeros && n >= ones)\\n            take = 1 + dp(strs, m - zeros, n - ones, i + 1, memo);\\n        int dontTake = dp(strs, m, n, i + 1, memo);\\n\\n        return memo[i][m][n] = max(take, dontTake);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int N = strs.size();\\n        vector<vector<vector<int>>> dp(N + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, 0)));\\n\\n        for (int i = N-1; i >= 0; i--) {\\n            int ones = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n            int zeros = strs[i].size() - ones;\\n            for (int j = 0; j <= m; j++) {\\n                for (int k = 0; k <= n; k++) {\\n                    int take = 0;\\n                    if (j >= zeros && k >= ones)\\n                        take = 1 + dp[i + 1][j - zeros][k - ones];\\n                    int dontTake = dp[i + 1][j][k];\\n                    dp[i][j][k] = max(take, dontTake);\\n                }\\n            }\\n        }\\n\\n        return dp[0][m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int N = strs.size();\\n        vector<vector<int>> curr(m + 1, vector<int>(n + 1, 0));\\n        vector<vector<int>> next(m + 1, vector<int>(n + 1, 0));\\n\\n\\n        for (int i = N-1; i >= 0; i--) {\\n            int ones = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n            int zeros = strs[i].size() - ones;\\n            for (int j = zeros; j <= m; j++) {\\n                for (int k = ones; k <= n; k++) {\\n                    int take = 1 + next[j - zeros][k - ones];\\n                    int dontTake = next[j][k];\\n                    curr[j][k] = max(take, dontTake);\\n                }\\n            }\\n            next = curr;\\n        }\\n\\n        return next[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793246,
                "title": "java-easy-solution-using-dp",
                "content": "# Intuition\\nThe problem can be solved using dynamic programming. We need to find the size of the largest subset of binary strings that satisfy the given condition (at most m 0\\'s and n 1\\'s in the subset).\\n\\n# Approach\\nThe approach utilizes dynamic programming to find the solution. We start by creating a HashMap that stores the count of zeros and ones for each binary string. Then, we define a recursive function function, which takes the current index, remaining zeros, remaining ones, and the HashMap as parameters and returns the maximum size of the subset that can be formed.\\n\\nThe recursive function function explores two choices at each step: either take the current binary string (if it can be accommodated within the remaining zeros and ones) or skip the current binary string. We use memoization to avoid redundant calculations and store the results in a 3D DP array.\\n\\n# Complexity\\n- ***Time complexity:*** O(size * m * n), where \\'size\\' is the number of binary strings, and \\'m\\' and \\'n\\' are the maximum allowed zeros and ones, respectively.\\n\\n- ***Space complexity:*** O(size * m * n) because we are using a 3D DP array to store the results of subproblems.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Pair{\\n    int zero;\\n    int ones;\\n    Pair(int zero,int ones){\\n        this.zero = zero;\\n        this.ones = ones;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        HashMap<String,Pair> map = new HashMap<>();\\n        updateMap(strs,map);\\n        int size = strs.length;\\n        int[][][] dp = new int[size][m+1][n+1];\\n        for(int[][] matrix:dp) for(int[] rows:matrix) Arrays.fill(rows,-1);\\n        return function(strs,0,m,n,map,size,dp);\\n    }\\n\\n    public void updateMap(String[] strs,HashMap<String,Pair> map){\\n\\n        for(String s:strs){\\n            int zero = 0;\\n            int one = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\') zero++;\\n                else one++;\\n            }\\n            map.put(s,new Pair(zero,one));\\n        }\\n\\n    }\\n\\n    public int function(String[] strs,int ind,int zeroes,int ones,HashMap<String,Pair> map,int size,int[][][] dp){\\n\\n        if(zeroes==0 && ones==0 || ind==size) return 0;\\n\\n        if(dp[ind][zeroes][ones]!=-1) return dp[ind][zeroes][ones];\\n\\n        int curr_zeroes = 0;\\n        int curr_ones = 0;\\n\\n        int take = Integer.MIN_VALUE;\\n        String s = strs[ind];\\n\\n        if(map.get(s).zero<=zeroes && map.get(s).ones<=ones){\\n            take = 1 + function(strs,ind+1,zeroes-map.get(s).zero,ones-map.get(s).ones,map,size,dp);\\n        }\\n\\n        int not_take = function(strs,ind+1,zeroes,ones,map,size,dp);\\n\\n        return dp[ind][zeroes][ones]= Math.max(take,not_take);\\n    }\\n\\n}\\n```\\n\\n\\n![plz upvote.jpeg](https://assets.leetcode.com/users/images/ba26c884-865b-4cd7-bf03-eabb8bda0ff7_1689868817.485213.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Pair{\\n    int zero;\\n    int ones;\\n    Pair(int zero,int ones){\\n        this.zero = zero;\\n        this.ones = ones;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        HashMap<String,Pair> map = new HashMap<>();\\n        updateMap(strs,map);\\n        int size = strs.length;\\n        int[][][] dp = new int[size][m+1][n+1];\\n        for(int[][] matrix:dp) for(int[] rows:matrix) Arrays.fill(rows,-1);\\n        return function(strs,0,m,n,map,size,dp);\\n    }\\n\\n    public void updateMap(String[] strs,HashMap<String,Pair> map){\\n\\n        for(String s:strs){\\n            int zero = 0;\\n            int one = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\') zero++;\\n                else one++;\\n            }\\n            map.put(s,new Pair(zero,one));\\n        }\\n\\n    }\\n\\n    public int function(String[] strs,int ind,int zeroes,int ones,HashMap<String,Pair> map,int size,int[][][] dp){\\n\\n        if(zeroes==0 && ones==0 || ind==size) return 0;\\n\\n        if(dp[ind][zeroes][ones]!=-1) return dp[ind][zeroes][ones];\\n\\n        int curr_zeroes = 0;\\n        int curr_ones = 0;\\n\\n        int take = Integer.MIN_VALUE;\\n        String s = strs[ind];\\n\\n        if(map.get(s).zero<=zeroes && map.get(s).ones<=ones){\\n            take = 1 + function(strs,ind+1,zeroes-map.get(s).zero,ones-map.get(s).ones,map,size,dp);\\n        }\\n\\n        int not_take = function(strs,ind+1,zeroes,ones,map,size,dp);\\n\\n        return dp[ind][zeroes][ones]= Math.max(take,not_take);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588487,
                "title": "c-recursive-memoization-solution-with-detailed-explanation-of-time-and-space-complexity",
                "content": "#### *Recursive Solution :-* \\n**Time Complexity :-**  O(2^(m+n)),  where m is the maximum count of 0s that can be used and n is the maximum count of 1s that can be used. This is because for each string in the vector strs, the code has two choices: either pick the string or not pick it.\\n\\n**Space Complexity :-**   O(2^(m+n)), because at each recursive call, a new stack frame is created to store the function parameters and local variables. As the number of recursive calls grows exponentially with the input size, the space required also grows exponentially\\n```\\nclass Solution {\\n    private:\\n    int countz(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'0\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int counto(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'1\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int fun(int ind,vector<string>& strs,int m,int n)\\n    {\\n        if(ind >= strs.size() )\\n            return 0;\\n       \\n        int cnt0 = countz(strs[ind]);\\n        int cnt1 = counto(strs[ind]);\\n        int pick= INT_MIN;\\n        if(m>=cnt0 && n>=cnt1)\\n             pick = 1+fun(ind+1,strs,m-cnt0,n-cnt1);\\n        int nonpick = 0 + fun(ind+1,strs,m,n);\\n        return max(pick,nonpick);\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) \\n    {\\n        return fun(0,strs,m,n);\\n    }\\n};\\n```\\n\\n**Memoization Solution :-**\\n**See the Changing parameters in the Recursive solution**.\\nIt is ind,m,n. So therefore we create 3d Dp\\n\\n**Time Complexity :-**  O(L * M * N), where L is the size of the strs vector, M is the maximum count of 0s that can be used (value of m), and N is the maximum count of 1s that can be used (value of n). This is because the code uses memoization (dynamic programming) to store and reuse computed results, avoiding redundant calculations\\n\\n**Space Complexity :-** O(L * M * N) for 3d dp\\n```\\nclass Solution {\\n    private:\\n    int countz(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'0\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int counto(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'1\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int fun(int ind,vector<string>& strs,int m,int n,vector<vector<vector<int>>>&dp)\\n    {\\n        if(ind >= strs.size() )\\n            return 0;\\n        // if(m==0 || n==0)\\n        //     return 1;\\n        if(dp[ind][m][n] != -1)\\n            return dp[ind][m][n];\\n        int cnt0 = countz(strs[ind]);\\n        int cnt1 = counto(strs[ind]);\\n        int pick= INT_MIN;\\n        if(m>=cnt0 && n>=cnt1)\\n             pick = 1+fun(ind+1,strs,m-cnt0,n-cnt1,dp);\\n        int nonpick = 0 + fun(ind+1,strs,m,n,dp);\\n        return dp[ind][m][n] = max(pick,nonpick);\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) \\n    {\\n        vector<vector<vector<int>>>dp(strs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return fun(0,strs,m,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int countz(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'0\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int counto(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'1\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int fun(int ind,vector<string>& strs,int m,int n)\\n    {\\n        if(ind >= strs.size() )\\n            return 0;\\n       \\n        int cnt0 = countz(strs[ind]);\\n        int cnt1 = counto(strs[ind]);\\n        int pick= INT_MIN;\\n        if(m>=cnt0 && n>=cnt1)\\n             pick = 1+fun(ind+1,strs,m-cnt0,n-cnt1);\\n        int nonpick = 0 + fun(ind+1,strs,m,n);\\n        return max(pick,nonpick);\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) \\n    {\\n        return fun(0,strs,m,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private:\\n    int countz(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'0\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int counto(string &str)\\n    {\\n        int cnt = 0;\\n        for(auto &it : str)\\n        {\\n            if(it == \\'1\\')\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    int fun(int ind,vector<string>& strs,int m,int n,vector<vector<vector<int>>>&dp)\\n    {\\n        if(ind >= strs.size() )\\n            return 0;\\n        // if(m==0 || n==0)\\n        //     return 1;\\n        if(dp[ind][m][n] != -1)\\n            return dp[ind][m][n];\\n        int cnt0 = countz(strs[ind]);\\n        int cnt1 = counto(strs[ind]);\\n        int pick= INT_MIN;\\n        if(m>=cnt0 && n>=cnt1)\\n             pick = 1+fun(ind+1,strs,m-cnt0,n-cnt1,dp);\\n        int nonpick = 0 + fun(ind+1,strs,m,n,dp);\\n        return dp[ind][m][n] = max(pick,nonpick);\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) \\n    {\\n        vector<vector<vector<int>>>dp(strs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,-1)));\\n        return fun(0,strs,m,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340656,
                "title": "memoization-tabulation-dp-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int s, int m, int n, vector<string> &strs, vector<vector<vector<int>>> &dp) {\\n        if(i == s) return 0;\\n        if(dp[i][m][n] != -1) return dp[i][m][n];\\n\\n        int notpick = dfs(i + 1, s, m, n, strs, dp);\\n        int cnt0 = 0, cnt1 = 0, pick = 0;\\n        for(char c : strs[i]) {\\n            c == \\'0\\' ? cnt0++ : cnt1++;\\n        }\\n        if(m >= cnt0 && n >= cnt1) {\\n            pick = 1 + dfs(i + 1, s, m - cnt0, n - cnt1, strs, dp);\\n        }\\n        return dp[i][m][n] = max(pick, notpick);\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s = strs.size();\\n        vector<vector<vector<int>>> dp(s, vector<vector<int>>(m + 1, vector<int>(n + 1, -1)));\\n        return dfs(0, s, m, n, strs, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s = strs.size();\\n        vector<vector<vector<int>>> dp(s + 1, vector<vector<int>>(m + 1, vector<int>(n + 1)));\\n\\n        for(int i=s-1; i>=0; i--) {\\n            for(int j=0; j<=m; j++) {\\n                for(int k=0; k<=n; k++) {\\n                    int notpick = dp[i + 1][j][k];\\n                    int cnt0 = 0, cnt1 = 0, pick = 0;\\n                    for(char c : strs[i]) {\\n                        c == \\'0\\' ? cnt0++ : cnt1++;\\n                    }\\n                    if(j >= cnt0 && k >= cnt1) {\\n                        pick = 1 + dp[i + 1][j - cnt0][k - cnt1];\\n                    }\\n                    dp[i][j][k] = max(pick, notpick);\\n                }\\n            }\\n        }\\n        return dp[0][m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int s, int m, int n, vector<string> &strs, vector<vector<vector<int>>> &dp) {\\n        if(i == s) return 0;\\n        if(dp[i][m][n] != -1) return dp[i][m][n];\\n\\n        int notpick = dfs(i + 1, s, m, n, strs, dp);\\n        int cnt0 = 0, cnt1 = 0, pick = 0;\\n        for(char c : strs[i]) {\\n            c == \\'0\\' ? cnt0++ : cnt1++;\\n        }\\n        if(m >= cnt0 && n >= cnt1) {\\n            pick = 1 + dfs(i + 1, s, m - cnt0, n - cnt1, strs, dp);\\n        }\\n        return dp[i][m][n] = max(pick, notpick);\\n    }\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s = strs.size();\\n        vector<vector<vector<int>>> dp(s, vector<vector<int>>(m + 1, vector<int>(n + 1, -1)));\\n        return dfs(0, s, m, n, strs, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s = strs.size();\\n        vector<vector<vector<int>>> dp(s + 1, vector<vector<int>>(m + 1, vector<int>(n + 1)));\\n\\n        for(int i=s-1; i>=0; i--) {\\n            for(int j=0; j<=m; j++) {\\n                for(int k=0; k<=n; k++) {\\n                    int notpick = dp[i + 1][j][k];\\n                    int cnt0 = 0, cnt1 = 0, pick = 0;\\n                    for(char c : strs[i]) {\\n                        c == \\'0\\' ? cnt0++ : cnt1++;\\n                    }\\n                    if(j >= cnt0 && k >= cnt1) {\\n                        pick = 1 + dp[i + 1][j - cnt0][k - cnt1];\\n                    }\\n                    dp[i][j][k] = max(pick, notpick);\\n                }\\n            }\\n        }\\n        return dp[0][m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316032,
                "title": "from-memoization-tabulation-and-optimized-soltution-java-with-explanation",
                "content": "Note : dp[i][m][n] indicates the largest subset you can form with m zeros and n ones till current index.\\n\\n```\\nclass Solution {\\n    static int[][][] dp;\\n//as they are three changing parameters we use 3D dp\\n\\n    public int dfs(int i,int m,int n,String[] strs)\\n    { \\n        if(i == 0)\\n        { //when we are at index 0 the largest subset with m zeros and n ones will be the count of ones and zeros in that string\\n            int zeros = 0,ones = 0;\\n            for(char c : strs[0].toCharArray())\\n            {\\n               if(c == \\'0\\') zeros++;\\n               else ones++;\\n            }\\n              //zeros and ones are valid return 1,else return 0\\n             if(zeros <= m && ones <= n)\\n             return 1;\\n\\n             return 0;\\n        }\\n        //already cached return the respective value\\n        if(dp[i][m][n] != -1) return dp[i][m][n];\\n       \\n       //two choices either include the current string or not\\n        int notTake = dfs(i - 1,m,n,strs);\\n        int take = 0;\\n\\n         int zeros = 0,ones = 0;\\n            for(char c : strs[i].toCharArray())\\n            {\\n               if(c == \\'0\\') zeros++;\\n               else ones++;\\n            }\\n         \\n     //we can only include the current string if the zeros and ones are valid\\n         if(zeros <= m && ones <= n)\\n         {\\n             take = 1 + dfs(i -1,m - zeros,n - ones,strs);\\n         }\\n        //take max of both including and not including\\n         dp[i][m][n] = Math.max(take,notTake);\\n\\n         return dp[i][m][n];\\n    }\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        \\n          dp = new int[strs.length][m + 1][n + 1];\\n          //initially fill all cells with -1\\n\\n\\n          for(int[][] arr : dp)\\n            for(int[] row : arr)\\n              Arrays.fill(row,-1);\\n\\n          return dfs(strs.length - 1,m,n,strs);  \\n    }\\n}\\n```\\n\\nTabulation\\n\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int M, int N) {\\n        \\n        int[][][] dp = new int[strs.length][M + 1][N + 1];\\n     \\n      \\n\\n      for(int m = 0;m <= M;m++)\\n      {\\n          for(int n = 0;n <= N;n++)\\n          {   \\n              String s = strs[0];\\n              int zeros = 0,ones = 0;\\n             for(int i = 0;i < s.length();i++)\\n             {\\n                 if(s.charAt(i) == \\'0\\') zeros++;\\n                 else ones++;\\n             } \\n             if(zeros <= m && ones <= n)\\n               dp[0][m][n] = 1;\\n          }\\n      }\\n        for(int i = 1;i <strs.length;i++)\\n        {\\n            String s = strs[i];\\n\\n            int zeros = 0,ones = 0;\\n\\n            for(char c : s.toCharArray())\\n             {\\n                 if(c == \\'0\\') zeros++;\\n                 else ones++;\\n             }\\n          \\n            for(int m = 0;m <= M;m++)\\n            {\\n                for(int n = 0;n <= N;n++)\\n                {\\n                    int notTake = dp[i - 1][m][n];\\n                    int take = 0;\\n                    if(zeros <= m && ones <= n)\\n                    {\\n                        take = 1 + dp[i - 1][m - zeros][n -ones];\\n                    }\\n                    dp[i][m][n] = Math.max(take,notTake);\\n                }\\n            } \\n\\n        }\\n            return dp[strs.length - 1][M][N]; \\n\\n    }\\n}\\n\\n```\\ntime complexity : O(m * n * s)\\nspace complexity :O(m * n * s)\\n\\nOptimized solution:we can decrease the space complexity to O(m x n)\\nby doing buttom up dp and calculationg zeros and ones such that we do not overwrite the original values and only look at a subproblem;\\ntime complexity : O(m * n * s)\\nspace complexity :O(m * n)\\n\\n```\\n\\nclass Solution {\\n    public int findMaxForm(String[] strs, int M, int N) {\\n        \\n        int[][] dp = new int[M + 1][N + 1];\\n\\n        for(String str : strs)\\n        {\\n            int zeros = 0,ones = 0;\\n            for(char c : str.toCharArray())\\n            {\\n                if(c == \\'0\\') zeros++;\\n                else ones++;\\n            }\\n            for(int m = M;m >= zeros;m--)\\n            {\\n                for(int n = N;n >= ones;n--)\\n                {\\n                    dp[m][n] = Math.max(dp[m][n],1 + dp[m - zeros][n - ones]);\\n                }\\n            }\\n        }\\n\\n        return dp[M][N];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[][][] dp;\\n//as they are three changing parameters we use 3D dp\\n\\n    public int dfs(int i,int m,int n,String[] strs)\\n    { \\n        if(i == 0)\\n        { //when we are at index 0 the largest subset with m zeros and n ones will be the count of ones and zeros in that string\\n            int zeros = 0,ones = 0;\\n            for(char c : strs[0].toCharArray())\\n            {\\n               if(c == \\'0\\') zeros++;\\n               else ones++;\\n            }\\n              //zeros and ones are valid return 1,else return 0\\n             if(zeros <= m && ones <= n)\\n             return 1;\\n\\n             return 0;\\n        }\\n        //already cached return the respective value\\n        if(dp[i][m][n] != -1) return dp[i][m][n];\\n       \\n       //two choices either include the current string or not\\n        int notTake = dfs(i - 1,m,n,strs);\\n        int take = 0;\\n\\n         int zeros = 0,ones = 0;\\n            for(char c : strs[i].toCharArray())\\n            {\\n               if(c == \\'0\\') zeros++;\\n               else ones++;\\n            }\\n         \\n     //we can only include the current string if the zeros and ones are valid\\n         if(zeros <= m && ones <= n)\\n         {\\n             take = 1 + dfs(i -1,m - zeros,n - ones,strs);\\n         }\\n        //take max of both including and not including\\n         dp[i][m][n] = Math.max(take,notTake);\\n\\n         return dp[i][m][n];\\n    }\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        \\n          dp = new int[strs.length][m + 1][n + 1];\\n          //initially fill all cells with -1\\n\\n\\n          for(int[][] arr : dp)\\n            for(int[] row : arr)\\n              Arrays.fill(row,-1);\\n\\n          return dfs(strs.length - 1,m,n,strs);  \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int M, int N) {\\n        \\n        int[][][] dp = new int[strs.length][M + 1][N + 1];\\n     \\n      \\n\\n      for(int m = 0;m <= M;m++)\\n      {\\n          for(int n = 0;n <= N;n++)\\n          {   \\n              String s = strs[0];\\n              int zeros = 0,ones = 0;\\n             for(int i = 0;i < s.length();i++)\\n             {\\n                 if(s.charAt(i) == \\'0\\') zeros++;\\n                 else ones++;\\n             } \\n             if(zeros <= m && ones <= n)\\n               dp[0][m][n] = 1;\\n          }\\n      }\\n        for(int i = 1;i <strs.length;i++)\\n        {\\n            String s = strs[i];\\n\\n            int zeros = 0,ones = 0;\\n\\n            for(char c : s.toCharArray())\\n             {\\n                 if(c == \\'0\\') zeros++;\\n                 else ones++;\\n             }\\n          \\n            for(int m = 0;m <= M;m++)\\n            {\\n                for(int n = 0;n <= N;n++)\\n                {\\n                    int notTake = dp[i - 1][m][n];\\n                    int take = 0;\\n                    if(zeros <= m && ones <= n)\\n                    {\\n                        take = 1 + dp[i - 1][m - zeros][n -ones];\\n                    }\\n                    dp[i][m][n] = Math.max(take,notTake);\\n                }\\n            } \\n\\n        }\\n            return dp[strs.length - 1][M][N]; \\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315555,
                "title": "java-dynamic-programming-memoization-easy-simple",
                "content": "\\n# Complexity\\n- Time complexity:O(k x m x n)\\n    - K is the length of string array\\n    - m and n are the maximum number of 0\\'s and 1\\'s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k x m x n) + O(n){Recursive Stack Space}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int helper(int ind,int m,int n,String []strs,int dp[][][]){\\n        if(ind==0){\\n            int zCnt=0,oCnt=0;\\n            for(int i=0;i<strs[0].length();i++){\\n                zCnt+=(strs[0].charAt(i)==\\'0\\')?1:0;\\n                oCnt+=(strs[0].charAt(i)==\\'1\\')?1:0;\\n            }\\n            return (zCnt<=m && oCnt<=n)?1:0;\\n        }\\n        if(dp[ind][m][n]!=-1)   return dp[ind][m][n];\\n        int dont_pick=helper(ind-1,m,n,strs,dp);\\n        int pick=0;\\n        String str=strs[ind];\\n        int zCnt=0,oCnt=0;\\n        for(int i=0;i<str.length();i++){\\n            zCnt+=(str.charAt(i)==\\'0\\')?1:0;\\n            oCnt+=(str.charAt(i)==\\'1\\')?1:0;\\n        }\\n        if(zCnt<=m && oCnt<=n){\\n            pick=1+helper(ind-1,m-zCnt,n-oCnt,strs,dp);\\n        }\\n        return dp[ind][m][n]=Math.max(pick,dont_pick);\\n    }   \\n     public int findMaxForm(String[] strs, int m, int n) {\\n        int dp[][][]=new int[strs.length][m+1][n+1];\\n        for(int arr[][]:dp){\\n            for(int arr1[]:arr){\\n                Arrays.fill(arr1,-1);\\n            }\\n        }\\n        return helper(strs.length-1,m,n,strs,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public static int helper(int ind,int m,int n,String []strs,int dp[][][]){\\n        if(ind==0){\\n            int zCnt=0,oCnt=0;\\n            for(int i=0;i<strs[0].length();i++){\\n                zCnt+=(strs[0].charAt(i)==\\'0\\')?1:0;\\n                oCnt+=(strs[0].charAt(i)==\\'1\\')?1:0;\\n            }\\n            return (zCnt<=m && oCnt<=n)?1:0;\\n        }\\n        if(dp[ind][m][n]!=-1)   return dp[ind][m][n];\\n        int dont_pick=helper(ind-1,m,n,strs,dp);\\n        int pick=0;\\n        String str=strs[ind];\\n        int zCnt=0,oCnt=0;\\n        for(int i=0;i<str.length();i++){\\n            zCnt+=(str.charAt(i)==\\'0\\')?1:0;\\n            oCnt+=(str.charAt(i)==\\'1\\')?1:0;\\n        }\\n        if(zCnt<=m && oCnt<=n){\\n            pick=1+helper(ind-1,m-zCnt,n-oCnt,strs,dp);\\n        }\\n        return dp[ind][m][n]=Math.max(pick,dont_pick);\\n    }   \\n     public int findMaxForm(String[] strs, int m, int n) {\\n        int dp[][][]=new int[strs.length][m+1][n+1];\\n        for(int arr[][]:dp){\\n            for(int arr1[]:arr){\\n                Arrays.fill(arr1,-1);\\n            }\\n        }\\n        return helper(strs.length-1,m,n,strs,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508204,
                "title": "python-easy-recursion-dp",
                "content": "```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        #dp dict to store the computations\\n        dp={}\\n        \\n        \\n        def A(curm,curn,ind):\\n            \\n            if (curm,curn,ind) in dp:\\n                return dp[(curm,curn,ind)]\\n            #if it is less than the capacity return -1\\n            if curm<0 or curn<0:\\n                return -1\\n            #if the ind reached end of the array\\n            if ind==len(strs):\\n                return 0\\n            \\n            ans1,ans2=0,0\\n            \\n            #skip \\n            ans1=A(curm,curn,ind+1)\\n            \\n            #include \\n            ans2=1+A(curm-(strs[ind].count(\\'0\\')),curn-(strs[ind].count(\\'1\\')),ind+1)\\n            \\n            #store the value\\n            dp[(curm,curn,ind)]=max(ans1,ans2)\\n\\t\\t\\t\\n            #return the value\\n            return max(ans1,ans2)\\n        \\n        return A(m,n,0)\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        #dp dict to store the computations\\n        dp={}\\n        \\n        \\n        def A(curm,curn,ind):\\n            \\n            if (curm,curn,ind) in dp:\\n                return dp[(curm,curn,ind)]\\n            #if it is less than the capacity return -1\\n            if curm<0 or curn<0:\\n                return -1\\n            #if the ind reached end of the array\\n            if ind==len(strs):\\n                return 0\\n            \\n            ans1,ans2=0,0\\n            \\n            #skip \\n            ans1=A(curm,curn,ind+1)\\n            \\n            #include \\n            ans2=1+A(curm-(strs[ind].count(\\'0\\')),curn-(strs[ind].count(\\'1\\')),ind+1)\\n            \\n            #store the value\\n            dp[(curm,curn,ind)]=max(ans1,ans2)\\n\\t\\t\\t\\n            #return the value\\n            return max(ans1,ans2)\\n        \\n        return A(m,n,0)\\n            \\n            \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2404599,
                "title": "simple-c-dp-solution-knapsack-variation",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[601][101][101];\\n    \\n    int f(vector<pair<int,int>> &v,int i,int m,int n){\\n        \\n        if(i==v.size() or (m==0 and n==0)) return 0;\\n        \\n        int &ans=dp[i][m][n];\\n        \\n        if(ans!=-1) return ans;\\n        \\n        if(v[i].first<=m and v[i].second<=n) \\n            ans=1+f(v,i+1,m-v[i].first,n-v[i].second);\\n        ans=max(ans,f(v,i+1,m,n));\\n        return ans;\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<pair<int,int>> v;\\n        for(auto &str:strs){\\n            pair<int,int> x;\\n            for(auto i:str){\\n                x.first+=i==\\'0\\';\\n                x.second+=i==\\'1\\';\\n            }\\n            v.push_back(x);\\n        }\\n        \\n        return f(v,0,m,n);\\n        \\n    }\\n};\\n```\\n\\nTime Complexity : **0(l * m * n)**\\nSpace Complexity : **0(l * m * n + l + h)** h->auxillary stack space\\n [ l --> length of the string array ]\\n \\nHope this helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[601][101][101];\\n    \\n    int f(vector<pair<int,int>> &v,int i,int m,int n){\\n        \\n        if(i==v.size() or (m==0 and n==0)) return 0;\\n        \\n        int &ans=dp[i][m][n];\\n        \\n        if(ans!=-1) return ans;\\n        \\n        if(v[i].first<=m and v[i].second<=n) \\n            ans=1+f(v,i+1,m-v[i].first,n-v[i].second);\\n        ans=max(ans,f(v,i+1,m,n));\\n        return ans;\\n    }\\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<pair<int,int>> v;\\n        for(auto &str:strs){\\n            pair<int,int> x;\\n            for(auto i:str){\\n                x.first+=i==\\'0\\';\\n                x.second+=i==\\'1\\';\\n            }\\n            v.push_back(x);\\n        }\\n        \\n        return f(v,0,m,n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240387,
                "title": "c-dp-solution-recursive-memoization-tabulation",
                "content": "Recursion is the heart of dynamic programming. Without solving recursively and directly jumping to tabulation, I don\\'t think is the right approach. We understand the main concept by doing it recursively first, memoizing it and then converting it into tabulation form. In this solution I will follow all the steps mentioned.\\nThis question is a variation of knapsack.\\nWe have two options for each string:-\\n\\nEither add it.\\nOr Leave it.\\n\\nFor adding the string is the subset, we have check if the number of \\'0\\'s and \\'1\\'s in the current string are less than or equal to the maximum amount of \\'0\\'s and \\'1\\'s remaining to be added in the subset.\\n\\nWe have to find a way in which the length of the subset can be maximized.\\n\\n**Recursion (TLE)**\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> zo(string &s){\\n        int z = 0;\\n        int o = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\') z++;\\n            else o++;\\n        }\\n        return {z,o};\\n    }\\n    int solve(vector<string>&strs, int m, int n, int idx){\\n        if(idx == strs.size()) return 0;\\n        if(m <= 0 && n <= 0) return 0;\\n        auto p = zo(strs[idx]);\\n        int len = solve(strs, m, n, idx+1);\\n        if(p.first <= m && p.second <=n){\\n            len = max(len, 1 + solve(strs, m-p.first, n-p.second, idx+1));\\n        }\\n        return  len;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        return solve(strs, m, n, 0);\\n    }\\n};\\n```\\n\\n**Memoization** \\n```\\nclass Solution {\\npublic:\\n    int dp[601][101][101]; \\n    pair<int,int> zo(string &s){\\n        int z = 0;\\n        int o = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\') z++;\\n            else o++;\\n        }\\n        return {z,o};\\n    }\\n    int solve(vector<string>&strs, int m, int n, int idx){\\n        if(idx == strs.size()) return 0;\\n        if(m <= 0 && n <= 0) return 0;\\n        auto p = zo(strs[idx]);\\n        if(dp[idx][m][n] != -1) return dp[idx][m][n];\\n        int len = solve(strs, m, n, idx+1);\\n        if(p.first <= m && p.second <=n){\\n            len = max(len, 1 + solve(strs, m-p.first, n-p.second, idx+1));\\n        }\\n        return dp[idx][m][n] = len;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(strs, m, n, 0);\\n    }\\n};\\n```\\n\\n**Tabulation** \\n```\\nclass Solution {\\npublic:\\n    pair<int,int> zo(string &s){\\n        int z = 0;\\n        int o = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\') z++;\\n            else o++;\\n        }\\n        return {z,o};\\n    }\\n    bool isValid(int i, int j, int m, int n){\\n        if(i>=0 && i<=m && j>=0 && j<=n) return true;\\n        return false;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        vector<vector<vector<int>>> dp(len+1, vector<vector<int>>(m+1, vector<int>(n+1,0)));\\n        for(int i=1; i<len+1; i++){\\n            auto p = zo(strs[i-1]);\\n            for(int j=0; j<m+1; j++){\\n                for(int k=0; k<n+1; k++){\\n                    if(isValid(j-p.first, k-p.second, m, n) && p.first <= j && p.second <= k){\\n                        dp[i][j][k] = max(dp[i-1][j][k], 1 + dp[i-1][j-p.first][k-p.second]);\\n                    }\\n                    else{\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[len][m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> zo(string &s){\\n        int z = 0;\\n        int o = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\') z++;\\n            else o++;\\n        }\\n        return {z,o};\\n    }\\n    int solve(vector<string>&strs, int m, int n, int idx){\\n        if(idx == strs.size()) return 0;\\n        if(m <= 0 && n <= 0) return 0;\\n        auto p = zo(strs[idx]);\\n        int len = solve(strs, m, n, idx+1);\\n        if(p.first <= m && p.second <=n){\\n            len = max(len, 1 + solve(strs, m-p.first, n-p.second, idx+1));\\n        }\\n        return  len;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        return solve(strs, m, n, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[601][101][101]; \\n    pair<int,int> zo(string &s){\\n        int z = 0;\\n        int o = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\') z++;\\n            else o++;\\n        }\\n        return {z,o};\\n    }\\n    int solve(vector<string>&strs, int m, int n, int idx){\\n        if(idx == strs.size()) return 0;\\n        if(m <= 0 && n <= 0) return 0;\\n        auto p = zo(strs[idx]);\\n        if(dp[idx][m][n] != -1) return dp[idx][m][n];\\n        int len = solve(strs, m, n, idx+1);\\n        if(p.first <= m && p.second <=n){\\n            len = max(len, 1 + solve(strs, m-p.first, n-p.second, idx+1));\\n        }\\n        return dp[idx][m][n] = len;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(strs, m, n, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    pair<int,int> zo(string &s){\\n        int z = 0;\\n        int o = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\') z++;\\n            else o++;\\n        }\\n        return {z,o};\\n    }\\n    bool isValid(int i, int j, int m, int n){\\n        if(i>=0 && i<=m && j>=0 && j<=n) return true;\\n        return false;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        vector<vector<vector<int>>> dp(len+1, vector<vector<int>>(m+1, vector<int>(n+1,0)));\\n        for(int i=1; i<len+1; i++){\\n            auto p = zo(strs[i-1]);\\n            for(int j=0; j<m+1; j++){\\n                for(int k=0; k<n+1; k++){\\n                    if(isValid(j-p.first, k-p.second, m, n) && p.first <= j && p.second <= k){\\n                        dp[i][j][k] = max(dp[i-1][j][k], 1 + dp[i-1][j-p.first][k-p.second]);\\n                    }\\n                    else{\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[len][m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155283,
                "title": "c-short-easy-w-explanation-for-noobies-like-me-knapsack-pick-notpick-memoization",
                "content": "\\n  ```\\nint solve(int i,vector<string>& s1,int m,int n,int t[601][101][101]){\\n        int size=s1.size();\\n        if(i>=size) return 0;//if i crosses the vector, return 0\\n        if(t[i][m][n]!=-1) return t[i][m][n]; \\n        \\n        int m_count=0,n_count=0;//for a particular i,this gives the count of O\\'s and 1\\'s int s1[i]\\n        string temp=s1[i];\\n        for(int j=0;j<temp.size();j++){\\n                if(temp[j]==\\'0\\') m_count++;\\n            else n_count++;\\n            }\\n        \\n        int pick=0;\\n        int notpick=solve(i+1,s1,m,n,t);//here a particular s1[i] is not picked\\n        if(m-m_count>=0 && n-n_count>=0) pick=1+solve(i+1,s1,m-m_count,n-n_count,t);\\n\\t\\t//first we are checking the conditions, and then picking this particular s1[i]\\n        \\n         return t[i][m][n]= max(notpick,pick);//returning the max of pick and notpick\\n}\\n\\nint findMaxForm(vector<string>& s1, int m, int n) {\\n\\tint t[601][101][101];//memoization stuff\\n\\tmemset(t,-1,sizeof(t));\\n\\t int size=s1.size();\\n\\treturn solve(0,s1,m,n,t);//passing the starting index,m and n\\n\\t}\\n\\n``",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\n  ```\\nint solve(int i,vector<string>& s1,int m,int n,int t[601][101][101]){\\n        int size=s1.size();\\n        if(i>=size) return 0;//if i crosses the vector, return 0\\n        if(t[i][m][n]!=-1) return t[i][m][n]; \\n        \\n        int m_count=0,n_count=0;//for a particular i,this gives the count of O\\'s and 1\\'s int s1[i]\\n        string temp=s1[i];\\n        for(int j=0;j<temp.size();j++){\\n                if(temp[j]==\\'0\\') m_count++;\\n            else n_count++;\\n            }\\n        \\n        int pick=0;\\n        int notpick=solve(i+1,s1,m,n,t);//here a particular s1[i] is not picked\\n        if(m-m_count>=0 && n-n_count>=0) pick=1+solve(i+1,s1,m-m_count,n-n_count,t);\\n\\t\\t//first we are checking the conditions, and then picking this particular s1[i]\\n        \\n         return t[i][m][n]= max(notpick,pick);//returning the max of pick and notpick\\n}\\n\\nint findMaxForm(vector<string>& s1, int m, int n) {\\n\\tint t[601][101][101];//memoization stuff\\n\\tmemset(t,-1,sizeof(t));\\n\\t int size=s1.size();\\n\\treturn solve(0,s1,m,n,t);//passing the starting index,m and n\\n\\t}\\n\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 2099981,
                "title": "c-3d-dp-optimized-to-2d-dp",
                "content": "**Intuition**\\nThe first intuitive solution that comes to mind after seeing this problem is to use a greedy approach and simply put as many strings in a subset. It can be seen, however, that this solution isn\\'t optimal.\\n\\nSince the greedy solution isn\\'t optimal, it is wise to consider if a dynamic programming solutions exists to the problem. After reconsidering the problem with a \"dynamic programming point-of-view\", it can be seen that the problem is actually very similar to the standard dyanmic programming problem Knapsack.\\n\\nInitially, I first thought to represent this problem with a 3-dimensional dynamic programming table. \\n\\nThe table I initially thought of followed this form:\\nLet dp[i][j][k] denote the maximum size subset from the first i strings in the strs array that contains at most j zeroes and k ones. \\n\\nSince this problem is very similar to Knapsack, the transitions for initializing the dynamic programming table described above proved to be very similar:\\n\\nIf we are trying to initialize dp[i][j][k] and if the current string has z zeroes and o ones and if the current subproblem in the table can have at least z zeroes (that is if j >= z) and at least o ones (that is if k >= o), then we can initialize dp[i][j][k] by taking the most optimal answer when we had less than one string (dp[i - 1][j - z][k - o]) and adding one to the result (dp[i - 1][j - z][k - o] + 1) or we can be equal to max(dp[z][j][k]) for all z < i if we can\\'t include the current string in the subset. In the case where we can add the string to the current subset, we take the max of the two transitions described above. In the case where we can\\'t add the string to the subset, we take the latter transition (the one with z).\\n\\n**Therefore, our transitions for the 3D DP look like this:**\\n\\n*Let\\'s assume the i-th string (strs[i]) has z zeroes and o ones.*\\n```\\nif j >= z and k >= o \\n\\t\\tthen dp[i][j][k] = max(dp[i - 1][j - z][k - o] + 1, max(dp[z][j][k]) for all z < i)\\nelse \\n\\t\\tdp[i][j][k] = max(dp[z][j][k]) for all z < i\\n```\\n\\n**The code for the 3D DP looks like this:**\\n```\\nint zeroFreq(string &a) {\\n\\tint zeroes = 0;\\n\\tfor (char c : a) {\\n\\t\\tzeroes += c == \\'0\\';\\n\\t}\\n\\treturn zeroes;\\n}\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n\\t// let dp[i][j][k] denote max subset size from the first i strings \\n\\twith at most j 0\\'s and k 1\\'s\\n\\tvector<vector<vector<int>>> dp(strs.size(), \\n\\t\\t\\t\\t\\t\\t\\t\\t   vector<vector<int>>(m + 1, vector<int>(n + 1, 0)));\\n\\tvector<vector<int>> preMax(m + 1, vector<int>(n + 1, 0));\\n\\tint zeroes = zeroFreq(strs[0]);\\n\\tint ones = strs[0].length() - zeroes;\\n\\tfor (int j = 0; j <= m; j++) {\\n\\t\\tfor (int k = 0; k <= n; k++) {\\n\\t\\t\\tdp[0][j][k] = \\n\\t\\t\\t\\tj >= zeroes && k >= ones ? 1 : 0;\\n\\t\\t\\tpreMax[j][k] = max(preMax[j][k], dp[0][j][k]);\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 1; i < strs.size(); i++) {\\n\\t\\tzeroes = zeroFreq(strs[i]);\\n\\t\\tones = strs[i].length() - zeroes;\\n\\t\\tfor (int j = 0; j <= m; j++) {\\n\\t\\t\\tfor (int k = 0; k <= n; k++) {\\n\\t\\t\\t\\tint diffZeroes = j - zeroes;\\n\\t\\t\\t\\tint diffOnes = k - ones;\\n\\t\\t\\t\\tif (diffZeroes >= 0 && diffOnes >= 0) {\\n\\t\\t\\t\\t\\tdp[i][j][k] = dp[i - 1][diffZeroes][diffOnes] + 1;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tdp[i][j][k] = max(dp[i][j][k], preMax[j][k]);\\n\\t\\t\\t\\tpreMax[j][k] = max(preMax[j][k], dp[i][j][k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[strs.size() - 1][m][n];\\n}\\n```\\n*Note: The above code is optimized using a prefix max.*\\n\\n\\nAfter looking at this code, it can be seen that three dimensions aren\\'t needed to solve this problem if we slide the results of the previous table forward always. This is equivalent to just taking a max over the current value in the table with the new value.\\n\\n**The optimized code with the 2D DP table looks like this:**\\n  ```\\n  int zeroFreq(string &a) {\\n\\tint zeroes = 0;\\n\\tfor (char c : a) {\\n\\t\\tzeroes += c == \\'0\\';\\n\\t}\\n\\treturn zeroes;\\n}\\n  int findMaxForm(vector<string>& strs, int m, int n) {\\n\\t  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)), tempdp(m + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int i = 0; i < strs.size(); i++) {\\n\\t\\t\\tint zeroes = zeroFreq(strs[i]);\\n\\t\\t\\tint ones = strs[i].length() - zeroes;\\n\\t\\t\\tfor (int j = 0; j <= m; j++) {\\n\\t\\t\\t\\tfor (int k = 0; k <= n; k++) {\\n\\t\\t\\t\\t\\tint diffZeroes = j - zeroes;\\n\\t\\t\\t\\t\\tint diffOnes = k - ones;\\n\\t\\t\\t\\t\\tif (diffZeroes >= 0 && diffOnes >= 0) {\\n\\t\\t\\t\\t\\t\\ttempdp[j][k] = max(dp[j][k], \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[diffZeroes][diffOnes] + 1);\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp = tempdp;\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n}\\n```\\n*Note: Since this is the bottom-up solution, we have to use a temporary dp table so we don\\'t use updated values in our transitions for a specific value of i. We set the actual dp table equal to the temporary after.*",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nif j >= z and k >= o \\n\\t\\tthen dp[i][j][k] = max(dp[i - 1][j - z][k - o] + 1, max(dp[z][j][k]) for all z < i)\\nelse \\n\\t\\tdp[i][j][k] = max(dp[z][j][k]) for all z < i\\n```\n```\\nint zeroFreq(string &a) {\\n\\tint zeroes = 0;\\n\\tfor (char c : a) {\\n\\t\\tzeroes += c == \\'0\\';\\n\\t}\\n\\treturn zeroes;\\n}\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n\\t// let dp[i][j][k] denote max subset size from the first i strings \\n\\twith at most j 0\\'s and k 1\\'s\\n\\tvector<vector<vector<int>>> dp(strs.size(), \\n\\t\\t\\t\\t\\t\\t\\t\\t   vector<vector<int>>(m + 1, vector<int>(n + 1, 0)));\\n\\tvector<vector<int>> preMax(m + 1, vector<int>(n + 1, 0));\\n\\tint zeroes = zeroFreq(strs[0]);\\n\\tint ones = strs[0].length() - zeroes;\\n\\tfor (int j = 0; j <= m; j++) {\\n\\t\\tfor (int k = 0; k <= n; k++) {\\n\\t\\t\\tdp[0][j][k] = \\n\\t\\t\\t\\tj >= zeroes && k >= ones ? 1 : 0;\\n\\t\\t\\tpreMax[j][k] = max(preMax[j][k], dp[0][j][k]);\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 1; i < strs.size(); i++) {\\n\\t\\tzeroes = zeroFreq(strs[i]);\\n\\t\\tones = strs[i].length() - zeroes;\\n\\t\\tfor (int j = 0; j <= m; j++) {\\n\\t\\t\\tfor (int k = 0; k <= n; k++) {\\n\\t\\t\\t\\tint diffZeroes = j - zeroes;\\n\\t\\t\\t\\tint diffOnes = k - ones;\\n\\t\\t\\t\\tif (diffZeroes >= 0 && diffOnes >= 0) {\\n\\t\\t\\t\\t\\tdp[i][j][k] = dp[i - 1][diffZeroes][diffOnes] + 1;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tdp[i][j][k] = max(dp[i][j][k], preMax[j][k]);\\n\\t\\t\\t\\tpreMax[j][k] = max(preMax[j][k], dp[i][j][k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[strs.size() - 1][m][n];\\n}\\n```\n```\\n  int zeroFreq(string &a) {\\n\\tint zeroes = 0;\\n\\tfor (char c : a) {\\n\\t\\tzeroes += c == \\'0\\';\\n\\t}\\n\\treturn zeroes;\\n}\\n  int findMaxForm(vector<string>& strs, int m, int n) {\\n\\t  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)), tempdp(m + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int i = 0; i < strs.size(); i++) {\\n\\t\\t\\tint zeroes = zeroFreq(strs[i]);\\n\\t\\t\\tint ones = strs[i].length() - zeroes;\\n\\t\\t\\tfor (int j = 0; j <= m; j++) {\\n\\t\\t\\t\\tfor (int k = 0; k <= n; k++) {\\n\\t\\t\\t\\t\\tint diffZeroes = j - zeroes;\\n\\t\\t\\t\\t\\tint diffOnes = k - ones;\\n\\t\\t\\t\\t\\tif (diffZeroes >= 0 && diffOnes >= 0) {\\n\\t\\t\\t\\t\\t\\ttempdp[j][k] = max(dp[j][k], \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[diffZeroes][diffOnes] + 1);\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp = tempdp;\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067559,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findMaxForm(String[] s, int m, int n) {\\n        int a[][]=new int[m+1][n+1];\\n        for(String p:s)\\n        {\\n            int c[]=count(p);\\n            for(int i=m;i>=c[0];i--)\\n            {\\n                for(int j=n;j>=c[1];j--)\\n                {\\n                    a[i][j]=Math.max(a[i-c[0]][j-c[1]]+1,a[i][j]);\\n                }\\n            }\\n        }\\n        return a[m][n];\\n    }\\n    static int[] count(String s)\\n    {\\n        int a[]=new int[2];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'0\\']++;\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int findMaxForm(String[] s, int m, int n) {\\n        int a[][]=new int[m+1][n+1];\\n        for(String p:s)\\n        {\\n            int c[]=count(p);\\n            for(int i=m;i>=c[0];i--)\\n            {\\n                for(int j=n;j>=c[1];j--)\\n                {\\n                    a[i][j]=Math.max(a[i-c[0]][j-c[1]]+1,a[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2067168,
                "title": "easy-java-dp-solution",
                "content": "I think this is quite similar to the [Coin Change](https://leetcode.com/problems/coin-change/) problem, by considering the strings as coins and the quantity of 1s and 0s as the money to make change of, and each coin can only be used once.\\n\\n```\\npublic class Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if (strs == null || strs.length < 1) return 0;\\n        int[][] dp = new int[m+1][n+1];\\n        int[][] nums = new int[strs.length][2];\\n        for (int i = 0; i < strs.length; ++i) {\\n            for (int j = 0; j < strs[i].length(); ++j) {\\n                ++nums[i][strs[i].charAt(j)-\\'0\\'];\\n            }\\n        }\\n        for (int[] num : nums) {\\n            for (int i = m; i >= num[0]; --i) {\\n                for (int j = n; j >= num[1]; --j) {\\n                    dp[i][j] = Math.max(dp[i][j], 1 + dp[i-num[0]][j-num[1]]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```\\n\\n**Please upvote if it helps!!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if (strs == null || strs.length < 1) return 0;\\n        int[][] dp = new int[m+1][n+1];\\n        int[][] nums = new int[strs.length][2];\\n        for (int i = 0; i < strs.length; ++i) {\\n            for (int j = 0; j < strs[i].length(); ++j) {\\n                ++nums[i][strs[i].charAt(j)-\\'0\\'];\\n            }\\n        }\\n        for (int[] num : nums) {\\n            for (int i = m; i >= num[0]; --i) {\\n                for (int j = n; j >= num[1]; --j) {\\n                    dp[i][j] = Math.max(dp[i][j], 1 + dp[i-num[0]][j-num[1]]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067006,
                "title": "c-dp-with-detailed-comments",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int dp[101][101][601]; // m,n,idx\\n    int helper(vector<string>& strs, int m, int n, int idx)\\n    {\\n        /* Helper takes, strs arr, m (max 0s), n (max 1s) and idx (current string).\\n        *  For each strs[idx] we either consider it or not.\\n        *  When we consider the str[idx] string, we\\'ll also update m and n.\\n        *  At the end, we\\'ll return max(considered, not_considered).\\n        */\\n        \\n        if (idx >= strs.size()) { // Reached end of strs arr.\\n            return 0;\\n        }\\n        // If result is already calculated\\n        // then return it, no need to go further.\\n        if (dp[m][n][idx] != -1) \\n            return dp[m][n][idx];\\n\\n        // res1 holds the max number of elems if strs[idx]\\n        // is NOT considered for final set.\\n        int res1 = helper(strs, m, n, idx+1);\\n        \\n        // res2 holds the max number of elems if strs[idx]\\n        // is considered for final set.\\n        // (Don\\'t forget to update m and n.)\\n        int count[2] = {0,0};\\n        for (int i = 0; i < strs[idx].length(); i++){\\n            if (strs[idx][i] == \\'0\\') count[0]++;\\n            else count[1]++;\\n        }\\n        int res2 = 0;\\n        if (!(m - count[0] < 0 || n - count[1] < 0)){\\n            res2 = 1 + helper(strs, m - count[0] , n - count[1], idx+1);\\n        }\\n        \\n        // Store result for current m, n and idx in dp\\n        // and return it.\\n        dp[m][n][idx] = max(res2, res1);\\n        return dp[m][n][idx];\\n        \\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(strs, m, n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int dp[101][101][601]; // m,n,idx\\n    int helper(vector<string>& strs, int m, int n, int idx)\\n    {\\n        /* Helper takes, strs arr, m (max 0s), n (max 1s) and idx (current string).\\n        *  For each strs[idx] we either consider it or not.\\n        *  When we consider the str[idx] string, we\\'ll also update m and n.\\n        *  At the end, we\\'ll return max(considered, not_considered).\\n        */\\n        \\n        if (idx >= strs.size()) { // Reached end of strs arr.\\n            return 0;\\n        }\\n        // If result is already calculated\\n        // then return it, no need to go further.\\n        if (dp[m][n][idx] != -1) \\n            return dp[m][n][idx];\\n\\n        // res1 holds the max number of elems if strs[idx]\\n        // is NOT considered for final set.\\n        int res1 = helper(strs, m, n, idx+1);\\n        \\n        // res2 holds the max number of elems if strs[idx]\\n        // is considered for final set.\\n        // (Don\\'t forget to update m and n.)\\n        int count[2] = {0,0};\\n        for (int i = 0; i < strs[idx].length(); i++){\\n            if (strs[idx][i] == \\'0\\') count[0]++;\\n            else count[1]++;\\n        }\\n        int res2 = 0;\\n        if (!(m - count[0] < 0 || n - count[1] < 0)){\\n            res2 = 1 + helper(strs, m - count[0] , n - count[1], idx+1);\\n        }\\n        \\n        // Store result for current m, n and idx in dp\\n        // and return it.\\n        dp[m][n][idx] = max(res2, res1);\\n        return dp[m][n][idx];\\n        \\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(strs, m, n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066414,
                "title": "c-solution-using-two-approaches-greedy-dp",
                "content": "# **Greedy Solution**\\n**Time Complexity: O(X * L + X log X)**, **Space Complexity: O(X)**, where X is number of strings and L is the length of the longest string\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        \\n        vector<pair<int, int>> fa(sz);\\n        for(int i = 0; i < sz; ++i) {\\n            int cnt_0 = count(strs[i].begin(), strs[i].end(), \\'0\\'), cnt_1 = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n            fa[i] = {cnt_0, cnt_1};\\n        }\\n        \\n\\t\\t// comparator to sort on the basis of zeroes\\n        auto cmp_0 = [](pair<int, int> &a, pair<int, int> &b){\\n            if(a.first == b.first) return a.second < b.second;\\n            return a.first < b.first;\\n        };\\n        \\n\\t\\t// comparator to sort on the basis of ones\\n        auto cmp_1 = [](pair<int, int> &a, pair<int, int> &b){\\n            if(a.second == b.second) return a.first < b.first;\\n            return a.second < b.second;\\n        };\\n        \\n\\t\\t// comparator to sort on the basis of zeroes and ones count\\n        auto cmp_01 = [](pair<int, int> &a, pair<int, int> &b){\\n            if(a.first + a.second == b.first + b.second) return a.first < b.first;\\n            return a.first + a.second < b.first + b.second;\\n        };\\n        \\n        auto get_ans = [&m, &n, &sz, &fa](){\\n            int ans = 0;\\n            int total_m = 0, total_n = 0;\\n            for(int i = 0; i < sz; ++i) {\\n                auto &[cnt_0, cnt_1] = fa[i];\\n                if(total_m + cnt_0 <= m && total_n + cnt_1 <= n) {\\n                    ++ans;\\n                    total_m += cnt_0;\\n                    total_n += cnt_1;\\n                }\\n            }\\n            \\n            return ans;\\n        };\\n        \\n        sort(fa.begin(), fa.end(), cmp_0);\\n        int a1 = get_ans();\\n        \\n        sort(fa.begin(), fa.end(), cmp_1);\\n        int a2 = get_ans();\\n        \\n        sort(fa.begin(), fa.end(), cmp_01);\\n        int a3 = get_ans();\\n        \\n\\t\\t// max of all possible answers\\n        return max({a1, a2, a3});\\n    }\\n};\\n```\\n\\n# **DP Solution**\\n**Time Complexity: O(L * M * N)**, **Space Complexity: O(M * N)**\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n        \\n        for(auto &str: strs) {\\n            int cnt_0 = count(str.begin(), str.end(), \\'0\\'), cnt_1 = count(str.begin(), str.end(), \\'1\\');\\n            \\n            //  going from bottom-left as we don\\'t want the future interation in this string to use the updated values (which have been updated in the current iteration)\\n            for(int i = m; i >= cnt_0; --i) {\\n                for(int j = n; j >= cnt_1; --j) {\\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - cnt_0][j - cnt_1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int sz = strs.size();\\n        \\n        vector<pair<int, int>> fa(sz);\\n        for(int i = 0; i < sz; ++i) {\\n            int cnt_0 = count(strs[i].begin(), strs[i].end(), \\'0\\'), cnt_1 = count(strs[i].begin(), strs[i].end(), \\'1\\');\\n            fa[i] = {cnt_0, cnt_1};\\n        }\\n        \\n\\t\\t// comparator to sort on the basis of zeroes\\n        auto cmp_0 = [](pair<int, int> &a, pair<int, int> &b){\\n            if(a.first == b.first) return a.second < b.second;\\n            return a.first < b.first;\\n        };\\n        \\n\\t\\t// comparator to sort on the basis of ones\\n        auto cmp_1 = [](pair<int, int> &a, pair<int, int> &b){\\n            if(a.second == b.second) return a.first < b.first;\\n            return a.second < b.second;\\n        };\\n        \\n\\t\\t// comparator to sort on the basis of zeroes and ones count\\n        auto cmp_01 = [](pair<int, int> &a, pair<int, int> &b){\\n            if(a.first + a.second == b.first + b.second) return a.first < b.first;\\n            return a.first + a.second < b.first + b.second;\\n        };\\n        \\n        auto get_ans = [&m, &n, &sz, &fa](){\\n            int ans = 0;\\n            int total_m = 0, total_n = 0;\\n            for(int i = 0; i < sz; ++i) {\\n                auto &[cnt_0, cnt_1] = fa[i];\\n                if(total_m + cnt_0 <= m && total_n + cnt_1 <= n) {\\n                    ++ans;\\n                    total_m += cnt_0;\\n                    total_n += cnt_1;\\n                }\\n            }\\n            \\n            return ans;\\n        };\\n        \\n        sort(fa.begin(), fa.end(), cmp_0);\\n        int a1 = get_ans();\\n        \\n        sort(fa.begin(), fa.end(), cmp_1);\\n        int a2 = get_ans();\\n        \\n        sort(fa.begin(), fa.end(), cmp_01);\\n        int a3 = get_ans();\\n        \\n\\t\\t// max of all possible answers\\n        return max({a1, a2, a3});\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n        \\n        for(auto &str: strs) {\\n            int cnt_0 = count(str.begin(), str.end(), \\'0\\'), cnt_1 = count(str.begin(), str.end(), \\'1\\');\\n            \\n            //  going from bottom-left as we don\\'t want the future interation in this string to use the updated values (which have been updated in the current iteration)\\n            for(int i = m; i >= cnt_0; --i) {\\n                for(int j = n; j >= cnt_1; --j) {\\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - cnt_0][j - cnt_1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066140,
                "title": "java-simple-solution-recursion-memoization-dp",
                "content": "Recursive Code - TLE\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        return helper(strs, m, n, 0);\\n    }\\n    \\n    public int helper(String[] strs, int m, int n, int idx) {\\n        if(m < 0 || n < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        if(idx == strs.length) {\\n            if(m >= 0 && n >= 0) {\\n                return 0;\\n            } \\n            return Integer.MIN_VALUE;\\n        }\\n        int ones = 0, zeroes = 0;\\n        for(char ch: strs[idx].toCharArray()) {\\n            if(ch == \\'0\\') {\\n                zeroes++;\\n            } else {\\n                ones++;\\n            }\\n        }\\n        int inc = helper(strs, m - zeroes, n - ones, idx + 1) + 1;\\n        int exc = helper(strs, m, n, idx + 1);\\n        \\n        return Math.max(inc, exc);\\n    }\\n}\\n```\\nMemoization using 3D DP\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][][] dp = new int[m + 1][n + 1][strs.length];\\n        return helper(strs, m, n, 0, dp);\\n    }\\n    \\n    public int helper(String[] strs, int m, int n, int idx, int[][][] dp) {\\n        if(m < 0 || n < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        if(idx == strs.length) {\\n            if(m >= 0 && n >= 0) {\\n                return 0;\\n            } \\n            return Integer.MIN_VALUE;\\n        }\\n        if(dp[m][n][idx] > 0) {\\n            return dp[m][n][idx];\\n        }\\n        int ones = 0, zeroes = 0;\\n        for(char ch: strs[idx].toCharArray()) {\\n            if(ch == \\'0\\') {\\n                zeroes++;\\n            } else {\\n                ones++;\\n            }\\n        }\\n        int inc = helper(strs, m - zeroes, n - ones, idx + 1, dp) + 1;\\n        int exc = helper(strs, m, n, idx + 1, dp);\\n        \\n        dp[m][n][idx] = Math.max(inc, exc);\\n        return dp[m][n][idx];\\n    }\\n}\\n```\\nTabulation using 2D DP\\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] dp = new int[m + 1][n + 1];\\n        for(int k = 0; k < strs.length; k++){\\n            int zero = 0, one = 0;\\n            for(char ch : strs[k].toCharArray()){\\n                if(ch == \\'0\\'){\\n                    zero++;\\n                }else{\\n                    one++;\\n                }\\n            }\\n            for(int i = m; i>= zero; i--){\\n                for(int j = n; j >= one; j--){\\n                    dp[i][j] = Math.max(dp[i - zero][j - one] + 1, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        return helper(strs, m, n, 0);\\n    }\\n    \\n    public int helper(String[] strs, int m, int n, int idx) {\\n        if(m < 0 || n < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        if(idx == strs.length) {\\n            if(m >= 0 && n >= 0) {\\n                return 0;\\n            } \\n            return Integer.MIN_VALUE;\\n        }\\n        int ones = 0, zeroes = 0;\\n        for(char ch: strs[idx].toCharArray()) {\\n            if(ch == \\'0\\') {\\n                zeroes++;\\n            } else {\\n                ones++;\\n            }\\n        }\\n        int inc = helper(strs, m - zeroes, n - ones, idx + 1) + 1;\\n        int exc = helper(strs, m, n, idx + 1);\\n        \\n        return Math.max(inc, exc);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][][] dp = new int[m + 1][n + 1][strs.length];\\n        return helper(strs, m, n, 0, dp);\\n    }\\n    \\n    public int helper(String[] strs, int m, int n, int idx, int[][][] dp) {\\n        if(m < 0 || n < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        if(idx == strs.length) {\\n            if(m >= 0 && n >= 0) {\\n                return 0;\\n            } \\n            return Integer.MIN_VALUE;\\n        }\\n        if(dp[m][n][idx] > 0) {\\n            return dp[m][n][idx];\\n        }\\n        int ones = 0, zeroes = 0;\\n        for(char ch: strs[idx].toCharArray()) {\\n            if(ch == \\'0\\') {\\n                zeroes++;\\n            } else {\\n                ones++;\\n            }\\n        }\\n        int inc = helper(strs, m - zeroes, n - ones, idx + 1, dp) + 1;\\n        int exc = helper(strs, m, n, idx + 1, dp);\\n        \\n        dp[m][n][idx] = Math.max(inc, exc);\\n        return dp[m][n][idx];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][] dp = new int[m + 1][n + 1];\\n        for(int k = 0; k < strs.length; k++){\\n            int zero = 0, one = 0;\\n            for(char ch : strs[k].toCharArray()){\\n                if(ch == \\'0\\'){\\n                    zero++;\\n                }else{\\n                    one++;\\n                }\\n            }\\n            for(int i = m; i>= zero; i--){\\n                for(int j = n; j >= one; j--){\\n                    dp[i][j] = Math.max(dp[i - zero][j - one] + 1, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066129,
                "title": "0ms-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** C++ ***\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& S, int M, int N) {\\n        int dp[101][101]{0};\\n        for (string str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str)\\n                c == \\'0\\' ? zeros++ : ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& S, int M, int N) {\\n        int dp[101][101]{0};\\n        for (string str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str)\\n                c == \\'0\\' ? zeros++ : ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }\\n        return dp[M][N];\\n    }\\n};\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066013,
                "title": "dp-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t int dp[601][101][101];\\n\\t\\tint help(vector<pair<int,int>>&nums,int m, int n, int i){\\n\\t\\t\\tif(i==size(nums) or m<0 or n<0) return 0;\\n\\t\\t\\t if(dp[i][m][n]!=-1) return dp[i][m][n];\\n\\t\\t\\tauto [one,zero] = nums[i];\\n\\t\\t\\tif(zero<=m and one<=n) return dp[i][m][n] = max(1+help(nums,m-zero,n-one,i+1),help(nums,m,n,i+1));\\n\\t\\t\\telse return dp[i][m][n] = help(nums,m,n,i+1);\\n\\t\\t}\\n\\t\\tint findMaxForm(vector<string>& strs, int m, int n) {\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(auto str:strs){\\n\\t\\t\\t\\tint one = 0,zero = 0;\\n\\t\\t\\t\\tfor(auto num:str) num==\\'1\\'?one++:zero++;\\n\\t\\t\\t\\tv.push_back({one,zero});\\n\\t\\t\\t}\\n\\t\\t\\t memset(dp,-1,sizeof dp);\\n\\t\\t\\treturn help(v,m,n,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t int dp[601][101][101];\\n\\t\\tint help(vector<pair<int,int>>&nums,int m, int n, int i){\\n\\t\\t\\tif(i==size(nums) or m<0 or n<0) return 0;\\n\\t\\t\\t if(dp[i][m][n]!=-1) return dp[i][m][n];\\n\\t\\t\\tauto [one,zero] = nums[i];\\n\\t\\t\\tif(zero<=m and one<=n) return dp[i][m][n] = max(1+help(nums,m-zero,n-one,i+1),help(nums,m,n,i+1));\\n\\t\\t\\telse return dp[i][m][n] = help(nums,m,n,i+1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2065576,
                "title": "rust-dp",
                "content": "Convert each string in `strs` into a tuple counting zeroes and ones in it. Then it turns out to be a knapsack problem which can be easily solved with dynamic programming.\\n```\\nimpl Solution {\\n    pub fn find_max_form(strs: Vec<String>, m: i32, n: i32) -> i32 {\\n        let (m, n) = (m as usize, n as usize);\\n        let mut max_size = vec![vec![0; n + 1]; m + 1];\\n        \\n        strs.iter()\\n            .map(|s| s.chars()\\n                .fold((0, 0), |(mut x, mut y), ch| {\\n                    if ch == \\'0\\' {\\n                        x += 1;\\n                    } else {\\n                        y += 1;\\n                    }\\n                    (x, y)\\n                    })\\n                )\\n            .for_each(|(x, y)|\\n                // iterate reversely to avoid changing max_size for the same (x, y)\\n                for i in (x..=m).rev() {\\n                    for j in (y..=n).rev() {\\n                        max_size[i][j] = max_size[i][j].max(max_size[i - x][j - y] + 1);\\n                    }\\n                });\\n        \\n        max_size[m][n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_max_form(strs: Vec<String>, m: i32, n: i32) -> i32 {\\n        let (m, n) = (m as usize, n as usize);\\n        let mut max_size = vec![vec![0; n + 1]; m + 1];\\n        \\n        strs.iter()\\n            .map(|s| s.chars()\\n                .fold((0, 0), |(mut x, mut y), ch| {\\n                    if ch == \\'0\\' {\\n                        x += 1;\\n                    } else {\\n                        y += 1;\\n                    }\\n                    (x, y)\\n                    })\\n                )\\n            .for_each(|(x, y)|\\n                // iterate reversely to avoid changing max_size for the same (x, y)\\n                for i in (x..=m).rev() {\\n                    for j in (y..=n).rev() {\\n                        max_size[i][j] = max_size[i][j].max(max_size[i - x][j - y] + 1);\\n                    }\\n                });\\n        \\n        max_size[m][n]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065363,
                "title": "java-memoization-simple",
                "content": "**Idea:** This is a simple binary decision tree problem where we need to decide for each string whether to include it in the subset or not\\n\\n**Method 1:** Brute force recursion\\n>**T/S:** O((2^t) w)/O(w), where t = number of possible subsets, w = size(strs)\\n```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n\\treturn findMaxForm(strs, m, n, 0, getNumToOnes(strs));\\n}\\n\\n// Count number of ones in each string\\nprivate Map<String, Integer> getNumToOnes(String[] strs) {\\n\\tvar numToOnes = new HashMap<String, Integer>();\\n\\t\\n\\tfor (var str : strs) {\\n\\t\\tif (numToOnes.containsKey(str))\\n\\t\\t\\tcontinue;\\n\\t\\tvar ones = 0;\\n\\t\\tfor (var i = 0; i < str.length(); i++)\\n\\t\\t\\tif (str.charAt(i) == \\'1\\')\\n\\t\\t\\t\\tones++;\\n\\t\\tnumToOnes.put(str, ones);\\n\\t}\\n\\treturn numToOnes;\\n}\\n\\nprivate int findMaxForm(String[] strs, int m, int n, int i, Map<String, Integer> numToOnes) {\\n\\t// end of recursion tree\\n\\tif (i == strs.length || m == 0 && n == 0)\\n\\t\\treturn 0;\\n\\tvar ones = numToOnes.get(strs[i]);\\n\\tvar zeroes = strs[i].length() - ones;\\n\\n\\t// include this string\\n\\tvar include = 0;\\n\\tif (m >= zeroes && n >= ones)\\n\\t\\tinclude = 1 + findMaxForm(strs, m - zeroes, n - ones, i + 1, numToOnes);\\n\\t\\n\\t// exclude this string\\n\\tvar exclude = findMaxForm(strs, m, n, i + 1, numToOnes);\\n\\t// find the maximum subset\\n\\treturn Math.max(include, exclude);\\n}\\n```\\n\\n**Method 2:** Inject memoization in method 1\\n>**T/S:** O(tmn)/O(tmn)\\n```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n\\treturn findMaxForm(strs, m, n, 0, getNumToOnes(strs), new HashMap<>());\\n}\\n\\nprivate int findMaxForm(String[] strs, int m, int n, int i, Map<String, Integer> numToOnes, Map<String, Integer> memo) {\\n\\tif (i == strs.length || m == 0 && n == 0)\\n\\t\\treturn 0;\\n\\n\\tvar key = m + \" \" + n + \" \" + i;\\n\\tif (memo.containsKey(key))\\n\\t\\treturn memo.get(key);\\n\\n\\tvar ones = numToOnes.get(strs[i]);\\n\\tvar zeroes = strs[i].length() - ones;\\n\\tvar include = 0;\\n\\tif (m >= zeroes && n >= ones)\\n\\t\\tinclude = 1 + findMaxForm(strs, m - zeroes, n - ones, i + 1, numToOnes, memo);\\n\\n\\tvar exclude = findMaxForm(strs, m, n, i + 1, numToOnes, memo);\\n\\tvar max = Math.max(include, exclude);\\n\\treturn memo.compute(key, (k, v) -> max);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n\\treturn findMaxForm(strs, m, n, 0, getNumToOnes(strs));\\n}\\n\\n// Count number of ones in each string\\nprivate Map<String, Integer> getNumToOnes(String[] strs) {\\n\\tvar numToOnes = new HashMap<String, Integer>();\\n\\t\\n\\tfor (var str : strs) {\\n\\t\\tif (numToOnes.containsKey(str))\\n\\t\\t\\tcontinue;\\n\\t\\tvar ones = 0;\\n\\t\\tfor (var i = 0; i < str.length(); i++)\\n\\t\\t\\tif (str.charAt(i) == \\'1\\')\\n\\t\\t\\t\\tones++;\\n\\t\\tnumToOnes.put(str, ones);\\n\\t}\\n\\treturn numToOnes;\\n}\\n\\nprivate int findMaxForm(String[] strs, int m, int n, int i, Map<String, Integer> numToOnes) {\\n\\t// end of recursion tree\\n\\tif (i == strs.length || m == 0 && n == 0)\\n\\t\\treturn 0;\\n\\tvar ones = numToOnes.get(strs[i]);\\n\\tvar zeroes = strs[i].length() - ones;\\n\\n\\t// include this string\\n\\tvar include = 0;\\n\\tif (m >= zeroes && n >= ones)\\n\\t\\tinclude = 1 + findMaxForm(strs, m - zeroes, n - ones, i + 1, numToOnes);\\n\\t\\n\\t// exclude this string\\n\\tvar exclude = findMaxForm(strs, m, n, i + 1, numToOnes);\\n\\t// find the maximum subset\\n\\treturn Math.max(include, exclude);\\n}\\n```\n```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n\\treturn findMaxForm(strs, m, n, 0, getNumToOnes(strs), new HashMap<>());\\n}\\n\\nprivate int findMaxForm(String[] strs, int m, int n, int i, Map<String, Integer> numToOnes, Map<String, Integer> memo) {\\n\\tif (i == strs.length || m == 0 && n == 0)\\n\\t\\treturn 0;\\n\\n\\tvar key = m + \" \" + n + \" \" + i;\\n\\tif (memo.containsKey(key))\\n\\t\\treturn memo.get(key);\\n\\n\\tvar ones = numToOnes.get(strs[i]);\\n\\tvar zeroes = strs[i].length() - ones;\\n\\tvar include = 0;\\n\\tif (m >= zeroes && n >= ones)\\n\\t\\tinclude = 1 + findMaxForm(strs, m - zeroes, n - ones, i + 1, numToOnes, memo);\\n\\n\\tvar exclude = findMaxForm(strs, m, n, i + 1, numToOnes, memo);\\n\\tvar max = Math.max(include, exclude);\\n\\treturn memo.compute(key, (k, v) -> max);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1968569,
                "title": "iterative-dp-100-time-and-100-memory",
                "content": "Here we remove the first dimension which represents we are considering first \"i\" strings.\\nThis is because dp[i][...][...] only depends on dp[i-1][...][...]\\nAnd we should iterate through m,n quotas in reverse_order, as this make sure we still update the value using value from last round. \\n\\nTo convince yourself, you can also use size of 2 in first dimensions.\\ndp[2][m][n]\\nUse dp[0][...][...] to store results from last round. Write results from current round in dp[1][...][...]\\n\\n```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int dp[101][101]{};\\n        for(int i = 0; i < strs.size(); i++){\\n            int cnt_0 = count(strs[i]), cnt_1 = strs[i].size() - cnt_0;\\n            for(int m_quota = m; m_quota >= 0; m_quota--)\\n                for(int n_quota = n; n_quota >= 0; n_quota--)\\n                    if(cnt_0 <= m_quota and cnt_1 <= n_quota)\\n                        dp[m_quota][n_quota] = max(dp[m_quota][n_quota], dp[m_quota-cnt_0][n_quota-cnt_1] + 1);\\n        }\\n        return dp[m][n];\\n    }\\n    \\n    int count(string &s){\\n        int cnt_0{0};\\n        for(char c: s)\\n            cnt_0+= (c == \\'0\\');\\n        return\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int dp[101][101]{};\\n        for(int i = 0; i < strs.size(); i++){\\n            int cnt_0 = count(strs[i]), cnt_1 = strs[i].size() - cnt_0;\\n            for(int m_quota = m; m_quota >= 0; m_quota--)\\n                for(int n_quota = n; n_quota >= 0; n_quota--)\\n                    if(cnt_0 <= m_quota and cnt_1 <= n_quota)\\n                        dp[m_quota][n_quota] = max(dp[m_quota][n_quota], dp[m_quota-cnt_0][n_quota-cnt_1] + 1);\\n        }\\n        return dp[m][n];\\n    }\\n    \\n    int count(string &s){\\n        int cnt_0{0};\\n        for(char c: s)\\n            cnt_0+= (c == \\'0\\');\\n        return\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1853738,
                "title": "java-knapsack-3d-dp",
                "content": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // DP - 0/1 knapsack, because we have 2x limitations m and n, so it needs 3-dimentional DP memo\\n        int size = strs.length;\\n        int[][][] memo = new int[size + 1][m + 1][n + 1];\\n        int[] strs0 = new int[size];\\n        int[] strs1 = new int[size];\\n\\t// calculate the number of 0\\u2019s and 1\\u2019s for each string\\n        for(int i = 0; i < size; i++) {\\n            char[] chs = strs[i].toCharArray();\\n            int sum0 = 0, sum1 = 0;\\n            for (char ch:chs) {\\n                if (ch == \\'0\\')\\n                    sum0 ++;\\n                else if (ch == \\'1\\')\\n                    sum1 ++;\\n            }\\n            strs0[i] = sum0;\\n            strs1[i] = sum1;\\n        }\\n        \\n        // populate the 3D memo\\n        for (int i = 1; i <= size; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                for (int k = 0; k <= n; k++) {\\n                    \\n                    if (j - strs0[i - 1] < 0 || k - strs1[i - 1] < 0) \\n                        memo[i][j][k] = memo[i - 1][j][k];\\n                    else\\n                        memo[i][j][k] = Math.max(memo[i - 1][j][k], 1 + memo[i - 1][j - strs0[i - 1]][k - strs1[i - 1]]);\\n                }\\n            }\\n        }\\n        \\n        return memo[size][m][n];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        // DP - 0/1 knapsack, because we have 2x limitations m and n, so it needs 3-dimentional DP memo\\n        int size = strs.length;\\n        int[][][] memo = new int[size + 1][m + 1][n + 1];\\n        int[] strs0 = new int[size];\\n        int[] strs1 = new int[size];\\n\\t// calculate the number of 0\\u2019s and 1\\u2019s for each string\\n        for(int i = 0; i < size; i++) {\\n            char[] chs = strs[i].toCharArray();\\n            int sum0 = 0, sum1 = 0;\\n            for (char ch:chs) {\\n                if (ch == \\'0\\')\\n                    sum0 ++;\\n                else if (ch == \\'1\\')\\n                    sum1 ++;\\n            }\\n            strs0[i] = sum0;\\n            strs1[i] = sum1;\\n        }\\n        \\n        // populate the 3D memo\\n        for (int i = 1; i <= size; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                for (int k = 0; k <= n; k++) {\\n                    \\n                    if (j - strs0[i - 1] < 0 || k - strs1[i - 1] < 0) \\n                        memo[i][j][k] = memo[i - 1][j][k];\\n                    else\\n                        memo[i][j][k] = Math.max(memo[i - 1][j][k], 1 + memo[i - 1][j - strs0[i - 1]][k - strs1[i - 1]]);\\n                }\\n            }\\n        }\\n        \\n        return memo[size][m][n];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847518,
                "title": "python-3-recursive-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        strs = [collections.Counter(s) for s in strs]\\n        dp = {}\\n        \\n        def helper(i, m, n):\\n            if i == len(strs):\\n                return 0\\n            \\n            x = (i, m, n)\\n            if x in dp:\\n                return dp[x]\\n            \\n            count0, count1 = strs[i][\\'0\\'], strs[i][\\'1\\']\\n            dp[x] = helper(i + 1, m, n)\\n            if m - count0 >= 0 and n - count1 >= 0:\\n                dp[x] = max(dp[x], helper(i + 1, m - count0, n - count1) + 1)\\n                \\n            return dp[x]\\n        \\n        return helper(0, m, n)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        strs = [collections.Counter(s) for s in strs]\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 1827996,
                "title": "python-0-1-knapsack-solution",
                "content": "Python implementation based on this awesome post:\\nhttps://leetcode.com/discuss/study-guide/1200320/Thief-with-a-knapsack-a-series-of-crimes.\\n\\n```\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        #rows = zeros\\n        #columns = unos\\n        for s in strs:\\n            z = s.count(\\'0\\')\\n            o = len(s)-z\\n            for i in range(m, z-1, -1):\\n                for j in range(n, o-1 , -1):\\n                    dp[i][j] = max(dp[i][j], 1 + dp[i-z][j-o])\\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        #rows = zeros\\n        #columns = unos\\n        for s in strs:\\n            z = s.count(\\'0\\')\\n            o = len(s)-z\\n            for i in range(m, z-1, -1):\\n                for j in range(n, o-1 , -1):\\n                    dp[i][j] = max(dp[i][j], 1 + dp[i-z][j-o])\\n        return dp[m][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1791187,
                "title": "c-knapsack-code-recursion-memoization-3d-dp",
                "content": "**0-1 Knapsack application. Pick and Not pick each element of the vector.**\\n```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int knapsack(vector<string>& v, int l, int m, int n){\\n        if(l==0){\\n            return 0;\\n        }\\n        \\n        if(dp[l][m][n]!=-1){\\n            return dp[l][m][n];\\n        }\\n        \\n        int size=v[l-1].size();\\n        int zeroes=0,ones=0;\\n        for(int i=0;i<size;i++){\\n            if(v[l-1][i]==\\'0\\'){\\n                zeroes++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        \\n        if(m>=zeroes and n>=ones){\\n            return dp[l][m][n]=max(1+knapsack(v,l-1,m-zeroes,n-ones),knapsack(v,l-1,m,n));\\n        }else{\\n            return dp[l][m][n]=knapsack(v,l-1,m,n);\\n        }\\n        \\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l=strs.size();\\n        memset(dp,-1,sizeof(dp));\\n        return knapsack(strs, l, m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[601][101][101];\\n    int knapsack(vector<string>& v, int l, int m, int n){\\n        if(l==0){\\n            return 0;\\n        }\\n        \\n        if(dp[l][m][n]!=-1){\\n            return dp[l][m][n];\\n        }\\n        \\n        int size=v[l-1].size();\\n        int zeroes=0,ones=0;\\n        for(int i=0;i<size;i++){\\n            if(v[l-1][i]==\\'0\\'){\\n                zeroes++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        \\n        if(m>=zeroes and n>=ones){\\n            return dp[l][m][n]=max(1+knapsack(v,l-1,m-zeroes,n-ones),knapsack(v,l-1,m,n));\\n        }else{\\n            return dp[l][m][n]=knapsack(v,l-1,m,n);\\n        }\\n        \\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int l=strs.size();\\n        memset(dp,-1,sizeof(dp));\\n        return knapsack(strs, l, m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766710,
                "title": "c-memoization-0-1-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        dp.resize(m+2, vector<vector<int>>(n+2, vector<int>(strs.size()+2, -1)));\\n        return helper(strs, 0, m, n);\\n    }\\n    \\n    int helper(vector<string>& strs, int index, int m , int n){\\n        if(index == strs.size()) return 0;\\n        if(m<=0 && n<=0) return 0;\\n        \\n\\t\\tif(dp[m][n][index] != -1) return dp[m][n][index];\\n        auto zeroesAndOnes = countZeroesAndOnes(strs[index]);\\n        int zeroes = zeroesAndOnes.first, ones = zeroesAndOnes.second;\\n        \\n        if(zeroes <= m && ones <= n){\\n            //Choice to select this string or skip it\\n            dp[m][n][index] = max(1 + helper(strs, index + 1, m-zeroes, n-ones), helper(strs, index + 1, m, n));\\n            return dp[m][n][index];\\n        }\\n\\t\\t\\n\\t\\t//No choice: Skip this string\\n        else return dp[m][n][index] = helper(strs, index+1, m, n);\\n    }\\n    \\n    pair<int, int> countZeroesAndOnes(string& str){\\n        int zeroes = 0, ones = 0;\\n        for(auto& c:str){\\n            if(c==\\'0\\') zeroes+=1;\\n            else ones += 1;\\n        }\\n        return {zeroes, ones};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        dp.resize(m+2, vector<vector<int>>(n+2, vector<int>(strs.size()+2, -1)));\\n        return helper(strs, 0, m, n);\\n    }\\n    \\n    int helper(vector<string>& strs, int index, int m , int n){\\n        if(index == strs.size()) return 0;\\n        if(m<=0 && n<=0) return 0;\\n        \\n\\t\\tif(dp[m][n][index] != -1) return dp[m][n][index];\\n        auto zeroesAndOnes = countZeroesAndOnes(strs[index]);\\n        int zeroes = zeroesAndOnes.first, ones = zeroesAndOnes.second;\\n        \\n        if(zeroes <= m && ones <= n){\\n            //Choice to select this string or skip it\\n            dp[m][n][index] = max(1 + helper(strs, index + 1, m-zeroes, n-ones), helper(strs, index + 1, m, n));\\n            return dp[m][n][index];\\n        }\\n\\t\\t\\n\\t\\t//No choice: Skip this string\\n        else return dp[m][n][index] = helper(strs, index+1, m, n);\\n    }\\n    \\n    pair<int, int> countZeroesAndOnes(string& str){\\n        int zeroes = 0, ones = 0;\\n        for(auto& c:str){\\n            if(c==\\'0\\') zeroes+=1;\\n            else ones += 1;\\n        }\\n        return {zeroes, ones};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668237,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n    \\n    for (auto &x: strs) {\\n        \\n        int ones = count(x.begin(), x.end(), \\'1\\');\\n        \\n        int zeros= x.size()-ones;\\n        \\n        for (int i=m; i>=zeros; i--) \\n        {\\n            \\n            for (int j=n; j>=ones; j--)\\n            {\\n                \\n                dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1);\\n                \\n            }\\n    }\\n        \\n    }\\n    return dp[m][n];\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n    \\n    for (auto &x: strs) {\\n        \\n        int ones = count(x.begin(), x.end(), \\'1\\');\\n        \\n        int zeros= x.size()-ones;\\n        \\n        for (int i=m; i>=zeros; i--) \\n        {\\n            \\n            for (int j=n; j>=ones; j--)\\n            {\\n                \\n                dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1630124,
                "title": "c-recursive-memoized-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int subMax(vector<string>& strs, int i, int m, int n){\\n        \\n        if(m<0 || n<0 ) return -1e9;\\n        if(m==0 && n== 0) return 0;\\n        \\n        if(i== strs.size()) return 0;\\n        \\n        if(dp[i][m][n] != -1) return dp[i][m][n];\\n        \\n        int count1=0, count0=0;\\n        \\n        for(auto c: strs[i]){\\n            if(c == \\'1\\') count1++;\\n            else count0++;\\n        }\\n        \\n        return dp[i][m][n] = max(1+ subMax(strs, i+1, m-count0, n-count1), subMax(strs,i+1, m,n));\\n        \\n    }\\n    \\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s = strs.size();\\n        dp.resize(s, vector<vector<int>>(m+1, vector<int>(n+1,-1)));\\n        \\n        return max(subMax(strs,0,m,n),0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int subMax(vector<string>& strs, int i, int m, int n){\\n        \\n        if(m<0 || n<0 ) return -1e9;\\n        if(m==0 && n== 0) return 0;\\n        \\n        if(i== strs.size()) return 0;\\n        \\n        if(dp[i][m][n] != -1) return dp[i][m][n];\\n        \\n        int count1=0, count0=0;\\n        \\n        for(auto c: strs[i]){\\n            if(c == \\'1\\') count1++;\\n            else count0++;\\n        }\\n        \\n        return dp[i][m][n] = max(1+ subMax(strs, i+1, m-count0, n-count1), subMax(strs,i+1, m,n));\\n        \\n    }\\n    \\n    \\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s = strs.size();\\n        dp.resize(s, vector<vector<int>>(m+1, vector<int>(n+1,-1)));\\n        \\n        return max(subMax(strs,0,m,n),0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457610,
                "title": "c-using-dp-bottom-up",
                "content": "Here is my solution.\\n```\\nvector<int> getCounts(string str) {\\n    vector<int> counts(2);\\n    int count = 0;\\n\\n    for (char c : str) {\\n        if (c == \\'0\\') count++;\\n    }\\n\\n    counts[0] = count;\\n    counts[1] = str.length() - count;\\n    return counts;\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    int s = strs.size();\\n    int cache[s+1][m+1][n+1];\\n\\n    memset(cache, 0, sizeof(cache));\\n\\n    for (int i = s-1; i >= 0; --i) {\\n        vector<int> counts = getCounts(strs[i]);\\n\\n        for (int j = 0; j <= m; ++j) {\\n            for (int k = 0; k <= n; ++k) {\\n                if (counts[0] > j || counts[1] > k) {\\n                    cache[i][j][k] = cache[i+1][j][k];\\n                } else {\\n                    cache[i][j][k] = max(1 + cache[i+1][j-counts[0]][k-counts[1]], cache[i+1][j][k]);\\n                }\\n            }\\n        }\\n    }\\n\\n    return cache[0][m][n];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> getCounts(string str) {\\n    vector<int> counts(2);\\n    int count = 0;\\n\\n    for (char c : str) {\\n        if (c == \\'0\\') count++;\\n    }\\n\\n    counts[0] = count;\\n    counts[1] = str.length() - count;\\n    return counts;\\n}\\n\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n    int s = strs.size();\\n    int cache[s+1][m+1][n+1];\\n\\n    memset(cache, 0, sizeof(cache));\\n\\n    for (int i = s-1; i >= 0; --i) {\\n        vector<int> counts = getCounts(strs[i]);\\n\\n        for (int j = 0; j <= m; ++j) {\\n            for (int k = 0; k <= n; ++k) {\\n                if (counts[0] > j || counts[1] > k) {\\n                    cache[i][j][k] = cache[i+1][j][k];\\n                } else {\\n                    cache[i][j][k] = max(1 + cache[i+1][j-counts[0]][k-counts[1]], cache[i+1][j][k]);\\n                }\\n            }\\n        }\\n    }\\n\\n    return cache[0][m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1412138,
                "title": "c-dp-memoization-easy-for-beginners",
                "content": "```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n        int k = strs.size() -1;\\n        vector<vector<vector<int>>> dp(strs.size()+1,vector<vector<int>> (m+1,vector<int>(n+1,-1)));\\n        return knapsack(strs, m, n, k, dp);\\n    }\\n    \\n    int knapsack(vector<string>& strs, int m, int n, int k, vector<vector<vector<int>>>& dp){\\n        if(dp[k+1][m][n] != -1)\\n            return dp[k+1][m][n];\\n        \\n        int result, temp1, temp2;\\n        if (k == -1 or (m == 0  and n == 0))\\n            result = 0;\\n        else if(zeroes(strs[k]) > m  or ones(strs[k]) > n)\\n            result = knapsack(strs, m, n, k-1, dp);\\n        else{\\n            temp1 = knapsack(strs, m, n, k-1, dp);\\n            temp2 = 1 + knapsack(strs, m - zeroes(strs[k]), n - ones(strs[k]), k-1, dp);\\n            result = max(temp1, temp2);\\n        }\\n        dp[k+1][m][n] = result;\\n        return result;   \\n    }\\n    \\n    int zeroes(string& s){\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i]==\\'0\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    int ones(string& s){\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i]==\\'1\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n        int k = strs.size() -1;\\n        vector<vector<vector<int>>> dp(strs.size()+1,vector<vector<int>> (m+1,vector<int>(n+1,-1)));\\n        return knapsack(strs, m, n, k, dp);\\n    }\\n    \\n    int knapsack(vector<string>& strs, int m, int n, int k, vector<vector<vector<int>>>& dp){\\n        if(dp[k+1][m][n] != -1)\\n            return dp[k+1][m][n];\\n        \\n        int result, temp1, temp2;\\n        if (k == -1 or (m == 0  and n == 0))\\n            result = 0;\\n        else if(zeroes(strs[k]) > m  or ones(strs[k]) > n)\\n            result = knapsack(strs, m, n, k-1, dp);\\n        else{\\n            temp1 = knapsack(strs, m, n, k-1, dp);\\n            temp2 = 1 + knapsack(strs, m - zeroes(strs[k]), n - ones(strs[k]), k-1, dp);\\n            result = max(temp1, temp2);\\n        }\\n        dp[k+1][m][n] = result;\\n        return result;   \\n    }\\n    \\n    int zeroes(string& s){\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i]==\\'0\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    int ones(string& s){\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i]==\\'1\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1318989,
                "title": "c-0-1-knapsack-space-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        \\n        auto find = [](string s)\\n        {\\n            pair<int, int> p;\\n            for (auto i : s)\\n            {\\n                if (i == \\'0\\')\\n                    p.first++;\\n                else\\n                    p.second++;\\n            }\\n            return p;\\n        };\\n\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n        for (auto s : strs)\\n        {\\n            pair<int, int> p = find(s);\\n            for (int i = m; i >= p.first; i--)\\n            {\\n                for (int j = n; j >= p.second; j--)\\n                {\\n                    dp[i][j] = max(dp[i][j], dp[i - p.first][j - p.second] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        \\n        auto find = [](string s)\\n        {\\n            pair<int, int> p;\\n            for (auto i : s)\\n            {\\n                if (i == \\'0\\')\\n                    p.first++;\\n                else\\n                    p.second++;\\n            }\\n            return p;\\n        };\\n\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n        for (auto s : strs)\\n        {\\n            pair<int, int> p = find(s);\\n            for (int i = m; i >= p.first; i--)\\n            {\\n                for (int j = n; j >= p.second; j--)\\n                {\\n                    dp[i][j] = max(dp[i][j], dp[i - p.first][j - p.second] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298328,
                "title": "if-you-know-0-1-knapsack-top-down-you-will-surely-get-it",
                "content": "Here, we are give m and n as the capacity of the knapsack. Therefore, we have 2 consecutive loops for m and n (So, don\\'t get confused by seeing an extra loop).\\nAnd, the third loop is for the size of the array.\\nAlso, for every element we need to find the count of zero (as z) and count of one (as o).\\nNow, just compare the code with standard problem of 0_1 Knapsack (Top-Down) and try to relate the conditions of this code with the standard problem.\\nI am sure you will be able to relate the code and the logic behind its working. Also, I\\'ll be giving the code of 0_1 Knapsack at the end of the post.\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s=strs.size();\\n        int t[m+1][n+1][s+1];\\n        for(int i=0; i<=m; i++){\\n            for(int j=0; j<=n; j++){\\n                for(int k=0; k<=s; k++){\\n                    if((i==0 && j==0) || k==0){\\n                        t[i][j][k]=0;\\n                        continue;\\n                    }\\n                    string x=strs[k-1];\\n                    int z=0,o=0;\\n                    z=count(x.begin(),x.end(),\\'0\\');\\n                    o=x.size()-z;\\n                    if(o<=j && z<=i)\\n                        t[i][j][k]=max(1+t[i-z][j-o][k-1] , t[i][j][k-1]);\\n                    else\\n                        t[i][j][k]=t[i][j][k-1];\\n                }\\n            }\\n        }\\n        return t[m][n][s];\\n    }\\n};\\n```\\n\\n0_1 Knapsack : (Capacity of the Knapsack = c)\\n```\\nvoid knapsack(int c, vector<int> &a){\\n\\tint n=a.size();\\n    int t[c+1][n+1];\\n    for(int i=0; i<=c; i++){\\n        for(int j=0; j<=n; j++){\\n            if(i==0 || j==0){\\n                t[i][j]=0;\\n                continue;\\n            }\\n            if(a[j-1]<=i)   //if value of the element is less than the capacity <=> we have two choices : (1)Accept (2)Ignore\\n                t[i][j] = max(1+t[i-a[j-1]][j-1]] , t[i][j-1]);    //if element accepted <=> capacity to be reduced by the value of that element and move to the next element else capacity remains same and move to the next element\\n            else\\n                t[i][j]=t[i][j-1];   //value of the element is more than the capacity <=> ignore the element and move to the next element also, capacity remains unchanged\\n        }\\n    }\\n    cout<<\"\\\\nMax. number of elements to be chosen from the Knapsack = \"<<t[c][n];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int s=strs.size();\\n        int t[m+1][n+1][s+1];\\n        for(int i=0; i<=m; i++){\\n            for(int j=0; j<=n; j++){\\n                for(int k=0; k<=s; k++){\\n                    if((i==0 && j==0) || k==0){\\n                        t[i][j][k]=0;\\n                        continue;\\n                    }\\n                    string x=strs[k-1];\\n                    int z=0,o=0;\\n                    z=count(x.begin(),x.end(),\\'0\\');\\n                    o=x.size()-z;\\n                    if(o<=j && z<=i)\\n                        t[i][j][k]=max(1+t[i-z][j-o][k-1] , t[i][j][k-1]);\\n                    else\\n                        t[i][j][k]=t[i][j][k-1];\\n                }\\n            }\\n        }\\n        return t[m][n][s];\\n    }\\n};\\n```\n```\\nvoid knapsack(int c, vector<int> &a){\\n\\tint n=a.size();\\n    int t[c+1][n+1];\\n    for(int i=0; i<=c; i++){\\n        for(int j=0; j<=n; j++){\\n            if(i==0 || j==0){\\n                t[i][j]=0;\\n                continue;\\n            }\\n            if(a[j-1]<=i)   //if value of the element is less than the capacity <=> we have two choices : (1)Accept (2)Ignore\\n                t[i][j] = max(1+t[i-a[j-1]][j-1]] , t[i][j-1]);    //if element accepted <=> capacity to be reduced by the value of that element and move to the next element else capacity remains same and move to the next element\\n            else\\n                t[i][j]=t[i][j-1];   //value of the element is more than the capacity <=> ignore the element and move to the next element also, capacity remains unchanged\\n        }\\n    }\\n    cout<<\"\\\\nMax. number of elements to be chosen from the Knapsack = \"<<t[c][n];\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1142063,
                "title": "ones-and-zeroes-in-c-best-easy-explanation",
                "content": "class Solution {\\npublic:\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        //creating a 2d vector of nxm\\n        vector<vector<int> > subresults(n+1, vector<int>(m+1, 0));\\n        int n_ones,n_zeroes;\\n        \\n        //taking one str element one by one\\n        for (auto str : strs)\\n        {\\n            \\n            //counting number of zeroes and ones in each string element\\n            n_ones = count(str.begin(),str.end(),\\'1\\');\\n            n_zeroes = count(str.begin(),str.end(),\\'0\\');\\n            \\n            //we get a decision whether to choose the string or leave it\\n            //we use max function to take a decision\\n            //when we dont want to use the string - we take subresults[i][j] i.e previous value\\n            //when we want to use the string - we take subresults[i-n_ones][j-n_zeroes] and add 1 to mark used.\\n            for(int i = n; i >= n_ones; i--)\\n            {\\n                for(int j = m; j >= n_zeroes; j--)\\n                {\\n                    subresults[i][j] = max( subresults[i][j] , subresults[i - n_ones][j - n_zeroes] + 1);\\n                }\\n            }\\n        }\\n        return subresults[n][m];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        //creating a 2d vector of nxm\\n        vector<vector<int> > subresults(n+1, vector<int>(m+1, 0));\\n        int n_ones,n_zeroes;\\n        \\n        //taking one str element one by one\\n        for (auto str : strs)\\n        {\\n            \\n            //counting number of zeroes and ones in each string element\\n            n_ones = count(str.begin(),str.end(),\\'1\\');\\n            n_zeroes = count(str.begin(),str.end(),\\'0\\');\\n            \\n            //we get a decision whether to choose the string or leave it\\n            //we use max function to take a decision\\n            //when we dont want to use the string - we take subresults[i][j] i.e previous value\\n            //when we want to use the string - we take subresults[i-n_ones][j-n_zeroes] and add 1 to mark used.\\n            for(int i = n; i >= n_ones; i--)\\n            {\\n                for(int j = m; j >= n_zeroes; j--)\\n                {\\n                    subresults[i][j] = max( subresults[i][j] , subresults[i - n_ones][j - n_zeroes] + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1139615,
                "title": "python-solution-with-explanation",
                "content": "First look at the problem ,it was like we can not use brute force as it will surely give TLE verdict.\\nso doing more otlook, i found thta sorting arrays on the basis of number of zeos and ones can do the required tasks i.e. greedy approach.\\nbut it failed in most of the test cases \\nfor example,{\\'10\\',\"00\",\"0001\",\"0\",\"1\"}  m=5,n=2\\nsorting the above array on the basis on number of zeros we get,\\n{\"1\",\"0\",\"10\",\"00\",\"0001\"}\\nso for the count of n we get utilized in the index 2 only and zeros condition doesn\\'t got fullfilled.\\nso this approach was not working.\\nafter that we have to think of like a recursive solution only. And from there gotthe approach for the problem using DP algorithm.\\n\\n\\nThe code is:-\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        # m zeros\\n        # n ones\\n        dp = [[0 for j in range(m+1)] for i in range(n+1)]\\n        for s in strs:\\n            ones = s.count(\\'1\\')\\n            zeros = s.count(\\'0\\')\\n            for i in range(n,ones-1,-1):\\n                for j in range(m,zeros-1,-1):\\n                    dp[i][j] = max(dp[i][j],dp[i-ones][j-zeros]+1)\\n        return dp[n][m]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        # m zeros\\n        # n ones\\n        dp = [[0 for j in range(m+1)] for i in range(n+1)]\\n        for s in strs:\\n            ones = s.count(\\'1\\')\\n            zeros = s.count(\\'0\\')\\n            for i in range(n,ones-1,-1):\\n                for j in range(m,zeros-1,-1):\\n                    dp[i][j] = max(dp[i][j],dp[i-ones][j-zeros]+1)\\n        return dp[n][m]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139580,
                "title": "c-recursive-memonization-bottomup-solutions-with-explanations",
                "content": "```\\n  Recursive :TLE\\n  Memonization: TLE\\n    /*\\n     * TopDown Approach or Recursive Solution\\n     *\\n     * There will be s subproblems for each problem i.e.., for each string in the input\\n     * stringarray, 2 subproblems are to include and not include. Include only when the\\n     * no of zeros and ones are less than m and n respectively. Recursive loop exists\\n     * only when all the strings are checkd\\n     * Eg: [\"10\",\"0\",\"1\"] m = 1, n = 1\\n     *                             (0...2)\\n     *                               |\\n     *                       -------------------\\n     *                      |                   |\\n     *                 (\"10\", [\"0\",\"1\")     (\"0\", \"1\")\\n     *                                          |\\n     *                                     -----------------\\n     *                                    |                 |\\n     *                                  (\"0\", \"1\")        (\"1\")\\n     *\\n     * From above it is seen that first substring \"10\" has 1 zero and 1 one which is\\n     * needed so will include in result and procced further, If we exlude it then it\\n     * loop for all remaining strings.\\n     *\\n     *    CountZerosOnes(numOnes, numZeros)\\n     *    if (m >= numZeros && n >= numOnes) {\\n     *       include = 1 + findMaxForm(strs, idx+1, m-numZeros, n-numOnes);\\n     *    }\\n     *    exclude = findMaxForm(strs, idx+1, m, n);\\n     *\\n     *    res = max(include, exclude);\\n     *\\n     * Base cases:\\n     *  . If we are done with all string inthe input ie.., idx >= strs.size(), then there\\n     *    no elements to check return 0 \\n     *  . If m or n < 0, then we exceeded the limit return 0\\n     *\\n     */\\n    int findMaxForm(vector<string>& strs, int idx, int m, int n) {\\n        if (idx >= strs.size() || m < 0 || n < 0) {\\n            // If all strings are checked or there is no required no of zeros or ones\\n            return 0;\\n        }\\n\\n        // Count num of zeros or ones in string at idx \\n        int numZeros = 0;\\n        int numOnes = 0;\\n\\n        for (char ch : strs[idx]) {\\n            ch == \\'0\\' ? numZeros++ : numOnes++;\\n        }\\n\\n        // Check if this string can be included in the output\\n        int included = 0;\\n        if (m >= numZeros && n >= numOnes) {\\n            // Zeros and Ones are in the required limit in this string\\n            // Include this and procced further\\n            included = 1 + findMaxForm(strs, idx + 1, m - numZeros, n - numOnes);\\n        }\\n\\n        // Exclude the string at idx and procced to find the num count\\n        int excluded = findMaxForm(strs, idx + 1, m, n);\\n\\n        return std::max(included, excluded);\\n    }\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return  findMaxForm(strs, 0, m, n);\\n    }\\n    /*\\n     * Top Down with Memonization\\n     *\\n     * As there are many duplicate subproblems problems, results can intermediately stored\\n     * in dp array.\\n     * Conditions are similar to Recursive Solution\\n    */\\n    unordered_map<string, int> dp;\\n\\n    int findMaxForm(vector<string>& strs, int idx, int m, int n) {\\n        if (idx >= strs.size() || m < 0 || n < 0) {\\n            // If all strings are checked or there is no required no of zeros or ones\\n            return 0;\\n        }\\n\\n       \\t// key in the map is a idx, m, n seperated by \\'_\\'\\n        string key = to_string(idx) + \"_\" +  to_string(m) + \"_\" + to_string(n);\\n\\n        // Check if this subproblem is already solved.\\n        if (dp.count(key) == 1) {\\n            // Subproblem is already solved return the solution\\n            return dp[key];\\n        }\\n        \\n        // Count num of zeros or ones in string at idx \\n        int numZeros = 0;\\n        int numOnes = 0;\\n\\n        for (char ch : strs[idx]) {\\n            ch == \\'0\\' ? numZeros++ : numOnes++;\\n        }\\n\\n        // Check if this string can be included in the output\\n        int included = 0;\\n        if (m >= numZeros && n >= numOnes) {\\n            // Zeros and Ones are in the required limit in this string\\n            // Include this and procced further\\n            included = 1 + findMaxForm(strs, idx + 1, m - numZeros, n - numOnes);\\n        }\\n\\n        // Exclude the string at idx and procced to find the num count\\n        int excluded = findMaxForm(strs, idx + 1, m, n);\\n\\n        return dp[key] = std::max(included, excluded);\\n    }\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return  findMaxForm(strs, 0, m, n);\\n    }\\t\\n\\t\\n\\t    /*\\n     * findMaxForm BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for\\n     * the main problem can ba attained if we have solutions of suproblems, Dynamic Programming\\n     * can be applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the\\n     * top solution i.e.., solution of the problem\\n     *\\n     * The Dp table is of lenght m+1 , n+1 where m is max numof 1\\'s and n is max num 0\\'s +1 is to\\n     * have the case of m = 0, n = 0 and dp[i][j] holds the size of subset holding most of 0\\'s, 1\\'s\\n     *\\n     *    find numzeros, numones for strs 0... size()\\n     *    dp[i][j] = std::max (dp[i][j], dp[i- numzeros][j-numones]+1)\\n     */\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        // Dp array to hold the size of subset strings that are having most 0s and 1s at index i, j\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n\\n        // Loop for all strings\\n        for (string str : strs) {\\n            // Count numOnes, zeros in string\\n            int numZeros = 0;\\n            int numOnes = 0;\\n\\n            for (char ch : str) {\\n                ch == \\'0\\' ? numZeros++ : numOnes++;\\n            }\\n\\n            for (int zeros = m; zeros >= numZeros; zeros--) {\\n                for (int ones = n; ones >= numOnes; ones--) {\\n                    dp[zeros][ones] = max(dp[zeros][ones], dp[zeros - numZeros][ones - numOnes] + 1);\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  Recursive :TLE\\n  Memonization: TLE\\n    /*\\n     * TopDown Approach or Recursive Solution\\n     *\\n     * There will be s subproblems for each problem i.e.., for each string in the input\\n     * stringarray, 2 subproblems are to include and not include. Include only when the\\n     * no of zeros and ones are less than m and n respectively. Recursive loop exists\\n     * only when all the strings are checkd\\n     * Eg: [\"10\",\"0\",\"1\"] m = 1, n = 1\\n     *                             (0...2)\\n     *                               |\\n     *                       -------------------\\n     *                      |                   |\\n     *                 (\"10\", [\"0\",\"1\")     (\"0\", \"1\")\\n     *                                          |\\n     *                                     -----------------\\n     *                                    |                 |\\n     *                                  (\"0\", \"1\")        (\"1\")\\n     *\\n     * From above it is seen that first substring \"10\" has 1 zero and 1 one which is\\n     * needed so will include in result and procced further, If we exlude it then it\\n     * loop for all remaining strings.\\n     *\\n     *    CountZerosOnes(numOnes, numZeros)\\n     *    if (m >= numZeros && n >= numOnes) {\\n     *       include = 1 + findMaxForm(strs, idx+1, m-numZeros, n-numOnes);\\n     *    }\\n     *    exclude = findMaxForm(strs, idx+1, m, n);\\n     *\\n     *    res = max(include, exclude);\\n     *\\n     * Base cases:\\n     *  . If we are done with all string inthe input ie.., idx >= strs.size(), then there\\n     *    no elements to check return 0 \\n     *  . If m or n < 0, then we exceeded the limit return 0\\n     *\\n     */\\n    int findMaxForm(vector<string>& strs, int idx, int m, int n) {\\n        if (idx >= strs.size() || m < 0 || n < 0) {\\n            // If all strings are checked or there is no required no of zeros or ones\\n            return 0;\\n        }\\n\\n        // Count num of zeros or ones in string at idx \\n        int numZeros = 0;\\n        int numOnes = 0;\\n\\n        for (char ch : strs[idx]) {\\n            ch == \\'0\\' ? numZeros++ : numOnes++;\\n        }\\n\\n        // Check if this string can be included in the output\\n        int included = 0;\\n        if (m >= numZeros && n >= numOnes) {\\n            // Zeros and Ones are in the required limit in this string\\n            // Include this and procced further\\n            included = 1 + findMaxForm(strs, idx + 1, m - numZeros, n - numOnes);\\n        }\\n\\n        // Exclude the string at idx and procced to find the num count\\n        int excluded = findMaxForm(strs, idx + 1, m, n);\\n\\n        return std::max(included, excluded);\\n    }\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return  findMaxForm(strs, 0, m, n);\\n    }\\n    /*\\n     * Top Down with Memonization\\n     *\\n     * As there are many duplicate subproblems problems, results can intermediately stored\\n     * in dp array.\\n     * Conditions are similar to Recursive Solution\\n    */\\n    unordered_map<string, int> dp;\\n\\n    int findMaxForm(vector<string>& strs, int idx, int m, int n) {\\n        if (idx >= strs.size() || m < 0 || n < 0) {\\n            // If all strings are checked or there is no required no of zeros or ones\\n            return 0;\\n        }\\n\\n       \\t// key in the map is a idx, m, n seperated by \\'_\\'\\n        string key = to_string(idx) + \"_\" +  to_string(m) + \"_\" + to_string(n);\\n\\n        // Check if this subproblem is already solved.\\n        if (dp.count(key) == 1) {\\n            // Subproblem is already solved return the solution\\n            return dp[key];\\n        }\\n        \\n        // Count num of zeros or ones in string at idx \\n        int numZeros = 0;\\n        int numOnes = 0;\\n\\n        for (char ch : strs[idx]) {\\n            ch == \\'0\\' ? numZeros++ : numOnes++;\\n        }\\n\\n        // Check if this string can be included in the output\\n        int included = 0;\\n        if (m >= numZeros && n >= numOnes) {\\n            // Zeros and Ones are in the required limit in this string\\n            // Include this and procced further\\n            included = 1 + findMaxForm(strs, idx + 1, m - numZeros, n - numOnes);\\n        }\\n\\n        // Exclude the string at idx and procced to find the num count\\n        int excluded = findMaxForm(strs, idx + 1, m, n);\\n\\n        return dp[key] = std::max(included, excluded);\\n    }\\n\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        return  findMaxForm(strs, 0, m, n);\\n    }\\t\\n\\t\\n\\t    /*\\n     * findMaxForm BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for\\n     * the main problem can ba attained if we have solutions of suproblems, Dynamic Programming\\n     * can be applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the\\n     * top solution i.e.., solution of the problem\\n     *\\n     * The Dp table is of lenght m+1 , n+1 where m is max numof 1\\'s and n is max num 0\\'s +1 is to\\n     * have the case of m = 0, n = 0 and dp[i][j] holds the size of subset holding most of 0\\'s, 1\\'s\\n     *\\n     *    find numzeros, numones for strs 0... size()\\n     *    dp[i][j] = std::max (dp[i][j], dp[i- numzeros][j-numones]+1)\\n     */\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        // Dp array to hold the size of subset strings that are having most 0s and 1s at index i, j\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n\\n        // Loop for all strings\\n        for (string str : strs) {\\n            // Count numOnes, zeros in string\\n            int numZeros = 0;\\n            int numOnes = 0;\\n\\n            for (char ch : str) {\\n                ch == \\'0\\' ? numZeros++ : numOnes++;\\n            }\\n\\n            for (int zeros = m; zeros >= numZeros; zeros--) {\\n                for (int ones = n; ones >= numOnes; ones--) {\\n                    dp[zeros][ones] = max(dp[zeros][ones], dp[zeros - numZeros][ones - numOnes] + 1);\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139090,
                "title": "swift-dp-readable-solution",
                "content": "##### dp[i][j] = maximum number of subsets I can take while having *i zeroes* and *j ones*\\n```swift\\nfinal class Solution {\\n    // O(m*n*w) time | O(m*n) space\\n    func findMaxForm(_ strs: [String], _ m: Int, _ n: Int) -> Int {\\n        var dp = Array(\\n            repeating: Array(repeating: 0, count: n+1),\\n            count: m+1\\n        )\\n        \\n        for word in strs {\\n            let ones = word.filter { $0 == \"1\" }.count\\n            let zeroes = word.filter { $0 == \"0\" }.count\\n            \\n            for i in stride(from: m, through: zeroes, by: -1) {\\n                for j in stride(from: n, through: ones, by: -1){\\n                    dp[i][j] = max(dp[i][j], dp[i-zeroes][j-ones]+1)\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nfinal class Solution {\\n    // O(m*n*w) time | O(m*n) space\\n    func findMaxForm(_ strs: [String], _ m: Int, _ n: Int) -> Int {\\n        var dp = Array(\\n            repeating: Array(repeating: 0, count: n+1),\\n            count: m+1\\n        )\\n        \\n        for word in strs {\\n            let ones = word.filter { $0 == \"1\" }.count\\n            let zeroes = word.filter { $0 == \"0\" }.count\\n            \\n            for i in stride(from: m, through: zeroes, by: -1) {\\n                for j in stride(from: n, through: ones, by: -1){\\n                    dp[i][j] = max(dp[i][j], dp[i-zeroes][j-ones]+1)\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138999,
                "title": "my-java-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int [][] dp = new int [m + 1][n + 1];\\n        int ones = 0;\\n        int zeroes = 0;\\n        // count the number of zeros and ones\\n        for (String s : strs) {\\n            ones = countOnes(s);\\n            zeroes = countZeroes(s);\\n            for (int i=m; i>=zeroes; i--) {\\n                for (int j=n; j>=ones; j--) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroes][j - ones] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    \\n    public int countOnes(String s) {\\n        int count = 0;\\n            for (char ch : s.toCharArray()) {\\n                if (ch == \\'1\\')\\n                    count += 1;\\n        }\\n        return count;\\n    } \\n    \\n    public int countZeroes(String s) {\\n            int count = 0;\\n            for (char ch : s.toCharArray()) {\\n                if (ch == \\'0\\')\\n                    count += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int [][] dp = new int [m + 1][n + 1];\\n        int ones = 0;\\n        int zeroes = 0;\\n        // count the number of zeros and ones\\n        for (String s : strs) {\\n            ones = countOnes(s);\\n            zeroes = countZeroes(s);\\n            for (int i=m; i>=zeroes; i--) {\\n                for (int j=n; j>=ones; j--) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroes][j - ones] + 1);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    \\n    public int countOnes(String s) {\\n        int count = 0;\\n            for (char ch : s.toCharArray()) {\\n                if (ch == \\'1\\')\\n                    count += 1;\\n        }\\n        return count;\\n    } \\n    \\n    public int countZeroes(String s) {\\n            int count = 0;\\n            for (char ch : s.toCharArray()) {\\n                if (ch == \\'0\\')\\n                    count += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138771,
                "title": "java-recursion-memoization-idea-0-1-knapsack",
                "content": "```\\nclass Solution {\\n    public int dp [][][];\\n    public int findMaxForm (String[] strs, int m, int n) {\\n        dp = new int [m+1][n+1][strs.length+1];\\n        for (int matrix [][] : dp) {\\n            for (int row [] : matrix)\\n                Arrays.fill (row, -1);\\n        }\\n        return Solve (strs, m, n, 0);\\n    }\\n    \\n    public int Solve (String str [], int m, int n, int index) {\\n        if (str.length == 0 || (m + n) == 0 || m < 0 || n < 0 || index == str.length)\\n            return 0;\\n        if (dp [m][n][index] != -1)\\n            return dp [m][n][index];\\n        String curr = str [index];\\n        int zeros = getZerosCount (curr);\\n        int ones = curr.length () - zeros;\\n        if (m - zeros >= 0 && n - ones >= 0)\\n            dp [m][n][index] = Math.max (1 + Solve (str, m - zeros, n - ones, index + 1), Solve (str, m, n, index + 1));\\n        else\\n            dp [m][n][index] = Solve (str, m, n, index + 1);\\n        return dp [m][n][index];\\n        \\n    }\\n    \\n    public int getZerosCount (String curr) {\\n        int count = 0;\\n        for (int i = 0; i < curr.length (); i++) {\\n            if (curr.charAt (i) == \\'0\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int dp [][][];\\n    public int findMaxForm (String[] strs, int m, int n) {\\n        dp = new int [m+1][n+1][strs.length+1];\\n        for (int matrix [][] : dp) {\\n            for (int row [] : matrix)\\n                Arrays.fill (row, -1);\\n        }\\n        return Solve (strs, m, n, 0);\\n    }\\n    \\n    public int Solve (String str [], int m, int n, int index) {\\n        if (str.length == 0 || (m + n) == 0 || m < 0 || n < 0 || index == str.length)\\n            return 0;\\n        if (dp [m][n][index] != -1)\\n            return dp [m][n][index];\\n        String curr = str [index];\\n        int zeros = getZerosCount (curr);\\n        int ones = curr.length () - zeros;\\n        if (m - zeros >= 0 && n - ones >= 0)\\n            dp [m][n][index] = Math.max (1 + Solve (str, m - zeros, n - ones, index + 1), Solve (str, m, n, index + 1));\\n        else\\n            dp [m][n][index] = Solve (str, m, n, index + 1);\\n        return dp [m][n][index];\\n        \\n    }\\n    \\n    public int getZerosCount (String curr) {\\n        int count = 0;\\n        for (int i = 0; i < curr.length (); i++) {\\n            if (curr.charAt (i) == \\'0\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138744,
                "title": "golang-dp-solution-with-explanation",
                "content": "Define dp[i][j] = n \\n\\ti : number of zeros \\n\\tj : number of ones\\n\\tn : max number of subset with i zeros and j ones\\n\\t\\nIterate the strs and for each string there are 2 options\\n\\toption 1: don\\'t include it in the subset, in this case there is no impact on DP[i][j] \\n\\toption 2: include it in the subset, DP[i][j] = DP[i - number of zeros in string][j - number of ones in string]\\nbased on the 2 options, DP formula is :\\n```\\ndp[i][j] = max(dp[i][j], dp[i - list[k][0]][j - list[k][1]] + 1)\\n```\\ndp[0][0] = 0\\n\\n```\\nfunc findMaxForm(strs []string, m int, n int) int {\\n    list := make([][2]int, len(strs))\\n    for i := 0; i < len(strs); i++ {\\n        l := len(strs[i])\\n        list[i][0] = strings.Count(strs[i], \"0\")\\n        list[i][1] = l - list[i][0]\\n    }\\n    dp := make([][]int, m + 1) \\n    for i := 0; i <= m; i++ {\\n        dp[i] = make([]int, n + 1)\\n    }\\n    dp[0][0] = 0\\n    \\n    for k := 0; k < len(list); k++ {\\n        for i := m; i >= 0; i-- {\\n            for j := n; j >= 0; j-- {\\n                if i >= list[k][0] && j >= list[k][1] {\\n                    dp[i][j] = max(dp[i][j], dp[i - list[k][0]][j - list[k][1]] + 1)\\n                } else {\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    return dp[m][n]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = max(dp[i][j], dp[i - list[k][0]][j - list[k][1]] + 1)\\n```\n```\\nfunc findMaxForm(strs []string, m int, n int) int {\\n    list := make([][2]int, len(strs))\\n    for i := 0; i < len(strs); i++ {\\n        l := len(strs[i])\\n        list[i][0] = strings.Count(strs[i], \"0\")\\n        list[i][1] = l - list[i][0]\\n    }\\n    dp := make([][]int, m + 1) \\n    for i := 0; i <= m; i++ {\\n        dp[i] = make([]int, n + 1)\\n    }\\n    dp[0][0] = 0\\n    \\n    for k := 0; k < len(list); k++ {\\n        for i := m; i >= 0; i-- {\\n            for j := n; j >= 0; j-- {\\n                if i >= list[k][0] && j >= list[k][1] {\\n                    dp[i][j] = max(dp[i][j], dp[i - list[k][0]][j - list[k][1]] + 1)\\n                } else {\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    return dp[m][n]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138623,
                "title": "ones-and-zeroes-dp-knapsack-variation-simple-solution-c-easy-to-understand",
                "content": "### **Note: I am assuming that you are already familiar with 0-1 Knapsack problem and dynamic programming approach to solve it.**\\n* As in knapsack problem we are given weights and values of n items, and we are given a knapsack of weight W.\\n* We need to tell maximum possible value that we obtain by choosing (0 or more) items such that their total weight <=W (i.e can be held by the knapsack).\\n\\nNow if we think that for given strings the  **Weight of the string is equivalent to (number of zeros , number of ones) in it** and **value of each string is 1** we can model this problem directly 0-1 Knapsack.\\n\\n\\n### CODE:\\n```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        int i,N=strs.size();\\n        vector<int>z(N,0);//To store zeroes in ith string\\n        vector<int>o(N,0);//To store ones in ith string\\n        for(i=0;i<N;i++)\\n        {\\n            for(auto c:strs[i])\\n            {\\n                if(c==\\'0\\')z[i]++;\\n                else o[i]++;\\n            }\\n        }\\n      \\n\\t   //dp[i][j][k]--> maximum subset size that can be achieved when at most i zeroes  and at most j ones are allowed\\n        int dp[m+1][n+1][N];\\n        int j,k;\\n        for(i=0;i<=m;i++)\\n        for(j=0;j<=n;j++)\\n        for(k=0;k<N;k++)\\n        dp[i][j][k]=0;\\n        \\n        for(i=0;i<=m;i++)\\n        {\\n            for(j=0;j<=n;j++)\\n            {\\n                for(k=0;k<N;k++)\\n                {\\n                    if(z[k]<=i&&o[k]<=j)\\n                    {\\n                        if(k)dp[i][j][k]=max(dp[i][j][k-1],dp[i-z[k]][j-o[k]][k-1]+1);\\n                        else dp[i][j][k]=1;\\n                    }\\n                    else\\n                    {\\n                        if(k)dp[i][j][k]=dp[i][j][k-1];\\n                        else dp[i][j][k]=0;\\n                    }\\n                }\\n            }\\n           \\n        }\\n        return dp[m][n][N-1];    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        \\n        int i,N=strs.size();\\n        vector<int>z(N,0);//To store zeroes in ith string\\n        vector<int>o(N,0);//To store ones in ith string\\n        for(i=0;i<N;i++)\\n        {\\n            for(auto c:strs[i])\\n            {\\n                if(c==\\'0\\')z[i]++;\\n                else o[i]++;\\n            }\\n        }\\n      \\n\\t   //dp[i][j][k]--> maximum subset size that can be achieved when at most i zeroes  and at most j ones are allowed\\n        int dp[m+1][n+1][N];\\n        int j,k;\\n        for(i=0;i<=m;i++)\\n        for(j=0;j<=n;j++)\\n        for(k=0;k<N;k++)\\n        dp[i][j][k]=0;\\n        \\n        for(i=0;i<=m;i++)\\n        {\\n            for(j=0;j<=n;j++)\\n            {\\n                for(k=0;k<N;k++)\\n                {\\n                    if(z[k]<=i&&o[k]<=j)\\n                    {\\n                        if(k)dp[i][j][k]=max(dp[i][j][k-1],dp[i-z[k]][j-o[k]][k-1]+1);\\n                        else dp[i][j][k]=1;\\n                    }\\n                    else\\n                    {\\n                        if(k)dp[i][j][k]=dp[i][j][k-1];\\n                        else dp[i][j][k]=0;\\n                    }\\n                }\\n            }\\n           \\n        }\\n        return dp[m][n][N-1];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137565,
                "title": "python-one-small-trick-for-optimizing-knapsack-dp-40ms-100",
                "content": "There\\'s two main optimizations you can make here with Knapsack DP: first, use top-down recursion to avoid computing the entire len(strs) * m * n size table; only compute those for counts of zeroes and ones that are actually possible. \\n\\nBut the main thing here, based on an idea I saw in another post for sorting our (zero, one) pairs, is to modify our DP equation. If you haven\\'t heard of the [Nearest Smaller Values](https://en.wikipedia.org/wiki/All_nearest_smaller_values) problem, which pops up often in Leetcode, check it out! We have a way to calculate the next smallest value to the right (or left) of any position in a list, in linear time. \\n\\nThe idea here is simple. Rather than finding all combinations using the first i strings, then the first i+1 strings... etc, we can use a lookahead table. If in an optimal solution we reject string i, which has (j zeroes, k ones), then we should also reject any future strings that have j+w zeroes, k+y ones. By sorting the strings by zero count, then using the Nearest smallest values on their one count, we can find the next feasible candidate for every position i given that we reject string i. \\n\\nWe don\\'t even need memoization for the DP. The trick works for any similar multidimensional Knapsack-like problem.\\n\\n```python\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n    num_strs = len(strs)\\n    count_zero_one = []\\n\\n    for my_string in strs:\\n        zeroes, ones = 0, 0\\n        for letter in my_string:\\n            if letter == \\'0\\':\\n                zeroes += 1\\n            else:\\n                ones += 1\\n        count_zero_one.append((zeroes, ones))\\n\\n    count_zero_one.sort()\\n    # Lookahead table: If we\\'re not using (j, k),\\n    # then don\\'t use (j,k+1), (j, k+2)... or any (j+w, k+y), w,y >=0\\n    # But maybe use (j+w, k-y) for v >= 1, x >= 1\\n    # All nearest smallest values problem\\n    count_zero_one.append((0, -1))\\n\\n    next_candidate = list(range(num_strs))\\n    for i in range(num_strs - 1, -1, -1):\\n        my_ones = count_zero_one[i][1]\\n        j = i + 1\\n        while count_zero_one[j][1] >= my_ones:\\n            j = next_candidate[j]\\n        next_candidate[i] = j\\n    count_zero_one.pop()\\n\\n    def dp(used_zeroes, used_ones, idx):\\n        if idx >= num_strs:\\n            return 0\\n        new_zero_count = count_zero_one[idx][0] + used_zeroes\\n        # If using string at idx would take us over max zeroes, so would any higher idx\\n        if new_zero_count > m:\\n            return 0\\n        new_ones_count = count_zero_one[idx][1] + used_ones\\n        if new_ones_count > n:\\n            return dp(used_zeroes, used_ones, next_candidate[idx])\\n        return max(1 + dp(new_zero_count, new_ones_count, idx + 1),\\n                   dp(used_zeroes, used_ones, next_candidate[idx]))\\n\\n    return dp(0, 0, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n    num_strs = len(strs)\\n    count_zero_one = []\\n\\n    for my_string in strs:\\n        zeroes, ones = 0, 0\\n        for letter in my_string:\\n            if letter == \\'0\\':\\n                zeroes += 1\\n            else:\\n                ones += 1\\n        count_zero_one.append((zeroes, ones))\\n\\n    count_zero_one.sort()\\n    # Lookahead table: If we\\'re not using (j, k),\\n    # then don\\'t use (j,k+1), (j, k+2)... or any (j+w, k+y), w,y >=0\\n    # But maybe use (j+w, k-y) for v >= 1, x >= 1\\n    # All nearest smallest values problem\\n    count_zero_one.append((0, -1))\\n\\n    next_candidate = list(range(num_strs))\\n    for i in range(num_strs - 1, -1, -1):\\n        my_ones = count_zero_one[i][1]\\n        j = i + 1\\n        while count_zero_one[j][1] >= my_ones:\\n            j = next_candidate[j]\\n        next_candidate[i] = j\\n    count_zero_one.pop()\\n\\n    def dp(used_zeroes, used_ones, idx):\\n        if idx >= num_strs:\\n            return 0\\n        new_zero_count = count_zero_one[idx][0] + used_zeroes\\n        # If using string at idx would take us over max zeroes, so would any higher idx\\n        if new_zero_count > m:\\n            return 0\\n        new_ones_count = count_zero_one[idx][1] + used_ones\\n        if new_ones_count > n:\\n            return dp(used_zeroes, used_ones, next_candidate[idx])\\n        return max(1 + dp(new_zero_count, new_ones_count, idx + 1),\\n                   dp(used_zeroes, used_ones, next_candidate[idx]))\\n\\n    return dp(0, 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043200,
                "title": "c-classic-knapsack-dp-type-boiler-plate-also",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint dp[605][105][105];\\n\\tint f(int idx, vector<pair<int, int>>& arr, int m, int n) {\\n\\t\\t// base\\n\\t\\tif (idx == arr.size())\\n\\t\\t\\treturn 0;\\n\\n\\t\\t// dp check\\n\\t\\tif (dp[idx][m][n] != -1)\\n\\t\\t\\treturn dp[idx][m][n];\\n\\n\\t\\t// main\\n\\t\\tint cur0 = arr[idx].first;\\n\\t\\tint cur1 = arr[idx].second;\\n\\n\\t\\t// exclude this idx\\n\\t\\tif (m - cur0 < 0 or n - cur1 < 0)\\n\\t\\t\\treturn f(idx + 1, arr, m, n);\\n\\n\\t\\t// satisfy + include/exclude this idx\\n\\t\\tint incl = 1 + f(idx + 1, arr, m - cur0, n - cur1);\\n\\t\\tint excl = f(idx + 1, arr, m, n);\\n\\n\\t\\treturn dp[idx][m][n] = max(incl, excl);\\n\\t}\\n\\n\\tint findMaxForm(vector<string>& strs, int m, int n) {\\n\\t\\tint k = strs.size();\\n\\t\\tvector<pair<int, int>> arr(k);\\n\\n\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\tarr[i] = {count(strs[i].begin(), strs[i].end(), \\'0\\'), count(strs[i].begin(), strs[i].end(), \\'1\\')};\\n\\t\\t}\\n\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn f(0, arr, m, n);\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint dp[605][105][105];\\n\\tint f(int idx, vector<pair<int, int>>& arr, int m, int n) {\\n\\t\\t// base\\n\\t\\tif (idx == arr.size())\\n\\t\\t\\treturn 0;\\n\\n\\t\\t// dp check\\n\\t\\tif (dp[idx][m][n] != -1)\\n\\t\\t\\treturn dp[idx][m][n];\\n\\n\\t\\t// main\\n\\t\\tint cur0 = arr[idx].first;\\n\\t\\tint cur1 = arr[idx].second;\\n\\n\\t\\t// exclude this idx\\n\\t\\tif (m - cur0 < 0 or n - cur1 < 0)\\n\\t\\t\\treturn f(idx + 1, arr, m, n);\\n\\n\\t\\t// satisfy + include/exclude this idx\\n\\t\\tint incl = 1 + f(idx + 1, arr, m - cur0, n - cur1);\\n\\t\\tint excl = f(idx + 1, arr, m, n);\\n\\n\\t\\treturn dp[idx][m][n] = max(incl, excl);\\n\\t}\\n\\n\\tint findMaxForm(vector<string>& strs, int m, int n) {\\n\\t\\tint k = strs.size();\\n\\t\\tvector<pair<int, int>> arr(k);\\n\\n\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\tarr[i] = {count(strs[i].begin(), strs[i].end(), \\'0\\'), count(strs[i].begin(), strs[i].end(), \\'1\\')};\\n\\t\\t}\\n\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn f(0, arr, m, n);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021541,
                "title": "c-solution-top-down-approach-bottom-up-approach-and-memory-optimisation",
                "content": "```\\n// method-1: Top-down approach\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size(), vector<vector<int>>(m+1, vector<int>(n+1, -1)));\\n        return helper(strs, 0, m, n, dp);\\n    }\\n    \\n    int helper(vector<string>& strs, int i, int m, int n, vector<vector<vector<int>>>& dp){\\n        if(i>=strs.size()){\\n            return 0;\\n        }\\n        if(m==0 && n==0){\\n            return 0;\\n        }\\n        if(dp[i][m][n]!=-1){\\n            return dp[i][m][n];\\n        }\\n        int m1=0;\\n        int n1=0;\\n        for(char c: strs[i]){\\n            if(c==\\'0\\'){\\n                m1++;\\n            }else{\\n                n1++;\\n            }\\n        }\\n        int ans=0;\\n        if(m1<=m && n1<=n){\\n            ans = max(ans, 1+ helper(strs,i+1, m-m1, n-n1, dp));\\n        }\\n        ans = max(ans, helper(strs,i+1, m, n, dp));\\n        dp[i][m][n] = ans;\\n        return ans;\\n    }\\n};\\n// method-2: Bottom-up approach\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size()+1, vector<vector<int>>(m+1, vector<int>(n+1, 0)));\\n        for(int i=1;i<=strs.size();i++){\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    int m1=0;\\n                    int n1=0;\\n                    for(char c: strs[i-1]){\\n                        if(c==\\'0\\'){\\n                            m1++;\\n                        }else{\\n                            n1++;\\n                        }\\n                    }\\n                    if(j>=m1 && k>=n1){\\n                        dp[i][j][k] = max(dp[i][j][k], 1 + dp[i-1][j-m1][k-n1]);\\n                        dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\\n                    }else{\\n                        dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\\n                    }\\n                }\\n            }   \\n        }\\n        return dp[strs.size()][m][n];\\n    }\\n};\\n\\n// method-3: Bottom-up approach, memory optimisation\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int i=1;i<=strs.size();i++){\\n            for(int j=m;j>=0;j--){\\n                for(int k=n;k>=0;k--){\\n                    int m1=0;\\n                    int n1=0;\\n                    for(char c: strs[i-1]){\\n                        if(c==\\'0\\'){\\n                            m1++;\\n                        }else{\\n                            n1++;\\n                        }\\n                    }\\n                    if(j>=m1 && k>=n1){\\n                        dp[j][k] = max(dp[j][k], 1 + dp[j-m1][k-n1]);\\n                    }\\n                }\\n            }   \\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// method-1: Top-down approach\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size(), vector<vector<int>>(m+1, vector<int>(n+1, -1)));\\n        return helper(strs, 0, m, n, dp);\\n    }\\n    \\n    int helper(vector<string>& strs, int i, int m, int n, vector<vector<vector<int>>>& dp){\\n        if(i>=strs.size()){\\n            return 0;\\n        }\\n        if(m==0 && n==0){\\n            return 0;\\n        }\\n        if(dp[i][m][n]!=-1){\\n            return dp[i][m][n];\\n        }\\n        int m1=0;\\n        int n1=0;\\n        for(char c: strs[i]){\\n            if(c==\\'0\\'){\\n                m1++;\\n            }else{\\n                n1++;\\n            }\\n        }\\n        int ans=0;\\n        if(m1<=m && n1<=n){\\n            ans = max(ans, 1+ helper(strs,i+1, m-m1, n-n1, dp));\\n        }\\n        ans = max(ans, helper(strs,i+1, m, n, dp));\\n        dp[i][m][n] = ans;\\n        return ans;\\n    }\\n};\\n// method-2: Bottom-up approach\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<vector<int>>> dp(strs.size()+1, vector<vector<int>>(m+1, vector<int>(n+1, 0)));\\n        for(int i=1;i<=strs.size();i++){\\n            for(int j=0;j<=m;j++){\\n                for(int k=0;k<=n;k++){\\n                    int m1=0;\\n                    int n1=0;\\n                    for(char c: strs[i-1]){\\n                        if(c==\\'0\\'){\\n                            m1++;\\n                        }else{\\n                            n1++;\\n                        }\\n                    }\\n                    if(j>=m1 && k>=n1){\\n                        dp[i][j][k] = max(dp[i][j][k], 1 + dp[i-1][j-m1][k-n1]);\\n                        dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\\n                    }else{\\n                        dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\\n                    }\\n                }\\n            }   \\n        }\\n        return dp[strs.size()][m][n];\\n    }\\n};\\n\\n// method-3: Bottom-up approach, memory optimisation\\nclass Solution {\\npublic:\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int i=1;i<=strs.size();i++){\\n            for(int j=m;j>=0;j--){\\n                for(int k=n;k>=0;k--){\\n                    int m1=0;\\n                    int n1=0;\\n                    for(char c: strs[i-1]){\\n                        if(c==\\'0\\'){\\n                            m1++;\\n                        }else{\\n                            n1++;\\n                        }\\n                    }\\n                    if(j>=m1 && k>=n1){\\n                        dp[j][k] = max(dp[j][k], 1 + dp[j-m1][k-n1]);\\n                    }\\n                }\\n            }   \\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007484,
                "title": "recursion-memoization-3d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[601][101][101];\\n  \\n    int ans(int i,vector<string>& strs, int size, int m, int n){\\n       \\n        if(size==0)\\n            return t[i][m][n]=0;\\n        if(m==0 && n==0)\\n            return t[i][m][n]=0;\\n        if(t[i][m][n]!=-1)\\n            return t[i][m][n];\\n        \\n        int zeroes=0,ones=0;\\n        \\n        for(char ch : strs[i]){\\n            if(ch==\\'0\\')\\n                zeroes++;\\n            if(ch==\\'1\\')\\n                ones++;\\n        }\\n        \\n     \\n        if(zeroes<=m && ones<=n)\\n            t[i][m][n]=max(ans(i+1,strs,size-1,m-zeroes,n-ones)+1, ans(i+1,strs,size-1,m,n));\\n        else\\n           t[i][m][n]=ans(i+1,strs,size-1,m,n);\\n        return t[i][m][n];\\n            \\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int size=strs.size();\\n        memset(t,-1,sizeof(t));\\n        return ans(0,strs,size,m,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[601][101][101];\\n  \\n    int ans(int i,vector<string>& strs, int size, int m, int n){\\n       \\n        if(size==0)\\n            return t[i][m][n]=0;\\n        if(m==0 && n==0)\\n            return t[i][m][n]=0;\\n        if(t[i][m][n]!=-1)\\n            return t[i][m][n];\\n        \\n        int zeroes=0,ones=0;\\n        \\n        for(char ch : strs[i]){\\n            if(ch==\\'0\\')\\n                zeroes++;\\n            if(ch==\\'1\\')\\n                ones++;\\n        }\\n        \\n     \\n        if(zeroes<=m && ones<=n)\\n            t[i][m][n]=max(ans(i+1,strs,size-1,m-zeroes,n-ones)+1, ans(i+1,strs,size-1,m,n));\\n        else\\n           t[i][m][n]=ans(i+1,strs,size-1,m,n);\\n        return t[i][m][n];\\n            \\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int size=strs.size();\\n        memset(t,-1,sizeof(t));\\n        return ans(0,strs,size,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007203,
                "title": "c-solution-using-recursion-and-memoization-and-3d-vector",
                "content": "```\\nint check(int i,int m,int n,vector<vector<vector<int> > >& dp,int l,vector<string>& strs)\\n    {\\n        if(i>=l)\\n            return(0);\\n        if(dp[i][m][n]!=-1)\\n            return(dp[i][m][n]);\\n        int ones = count(strs[i].begin(), strs[i].end(), \\'1\\'); \\n        int zeros = strs[i].size() -ones;\\n        if(zeros<=m&&ones<=n)\\n            return(dp[i][m][n]=max(1+check(i+1,m-zeros,n-ones,dp,l,strs),check(i+1,m,n,dp,l,strs)));\\n        return(dp[i][m][n]=check(i+1,m,n,dp,l,strs));\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int i,j;\\n        vector<vector<vector<int> > > dp (strs.size()+1,vector<vector<int> >(m+1,vector <int>(n+1,-1)));\\n        return(check(0,m,n,dp,strs.size(),strs));\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nint check(int i,int m,int n,vector<vector<vector<int> > >& dp,int l,vector<string>& strs)\\n    {\\n        if(i>=l)\\n            return(0);\\n        if(dp[i][m][n]!=-1)\\n            return(dp[i][m][n]);\\n        int ones = count(strs[i].begin(), strs[i].end(), \\'1\\'); \\n        int zeros = strs[i].size() -ones;\\n        if(zeros<=m&&ones<=n)\\n            return(dp[i][m][n]=max(1+check(i+1,m-zeros,n-ones,dp,l,strs),check(i+1,m,n,dp,l,strs)));\\n        return(dp[i][m][n]=check(i+1,m,n,dp,l,strs));\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int i,j;\\n        vector<vector<vector<int> > > dp (strs.size()+1,vector<vector<int> >(m+1,vector <int>(n+1,-1)));\\n        return(check(0,m,n,dp,strs.size(),strs));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986849,
                "title": "c-solution-using-3-d-and-2-d-arrays-knapsack-technique",
                "content": "USING 3-D ARRAYS\\n```\\nclass Solution {\\npublic:\\n    int get_zero(const string& s) {\\n        int zero = 0;\\n        for(char i : s) {\\n            if(i == \\'0\\')\\n                zero++;\\n        }\\n        return zero;\\n    }\\n    int get_one(const string& s) {\\n        int one = 0;\\n        for(char i : s) {\\n            if(i == \\'1\\')\\n                one++;\\n        }\\n        return one;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        int dp[len + 1][m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i <= len; i++) {\\n            for(int j = 0; j <= m; j++) {\\n                for(int k = 0; k <= n; k++) {\\n                    int zero = get_zero(strs[i - 1]);\\n                    int one = get_one(strs[i - 1]);\\n                    if(j - zero >= 0 && k - one >= 0) {\\n                        dp[i][j][k] = max(dp[i - 1][j - zero][k - one] + 1, dp[i - 1][j][k]);\\n                    }\\n                    else\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                }\\n            }\\n        }\\n        return dp[len][m][n];\\n    }\\n};\\n```\\nUSING 2-D ARRAYS\\n\\n```\\nclass Solution {\\npublic:\\n    int get_zero(const string& s) {\\n        int zero = 0;\\n        for(char i : s) {\\n            if(i == \\'0\\')\\n                zero++;\\n        }\\n        return zero;\\n    }\\n    int get_one(const string& s) {\\n        int one = 0;\\n        for(char i : s) {\\n            if(i == \\'1\\')\\n                one++;\\n        }\\n        return one;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i <= len; i++) {\\n            for(int j = m; j >= 0; j--) {\\n                for(int k = n; k >= 0; k--) {\\n                    int zero = get_zero(strs[i - 1]);\\n                    int one = get_one(strs[i - 1]);\\n                    if(j - zero >= 0 && k - one >= 0) {\\n                        dp[j][k] = max(dp[j - zero][k - one] + 1, dp[j][k]);\\n                    }\\n                    else\\n                        dp[j][k] = dp[j][k];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int get_zero(const string& s) {\\n        int zero = 0;\\n        for(char i : s) {\\n            if(i == \\'0\\')\\n                zero++;\\n        }\\n        return zero;\\n    }\\n    int get_one(const string& s) {\\n        int one = 0;\\n        for(char i : s) {\\n            if(i == \\'1\\')\\n                one++;\\n        }\\n        return one;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        int dp[len + 1][m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i <= len; i++) {\\n            for(int j = 0; j <= m; j++) {\\n                for(int k = 0; k <= n; k++) {\\n                    int zero = get_zero(strs[i - 1]);\\n                    int one = get_one(strs[i - 1]);\\n                    if(j - zero >= 0 && k - one >= 0) {\\n                        dp[i][j][k] = max(dp[i - 1][j - zero][k - one] + 1, dp[i - 1][j][k]);\\n                    }\\n                    else\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                }\\n            }\\n        }\\n        return dp[len][m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int get_zero(const string& s) {\\n        int zero = 0;\\n        for(char i : s) {\\n            if(i == \\'0\\')\\n                zero++;\\n        }\\n        return zero;\\n    }\\n    int get_one(const string& s) {\\n        int one = 0;\\n        for(char i : s) {\\n            if(i == \\'1\\')\\n                one++;\\n        }\\n        return one;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i <= len; i++) {\\n            for(int j = m; j >= 0; j--) {\\n                for(int k = n; k >= 0; k--) {\\n                    int zero = get_zero(strs[i - 1]);\\n                    int one = get_one(strs[i - 1]);\\n                    if(j - zero >= 0 && k - one >= 0) {\\n                        dp[j][k] = max(dp[j - zero][k - one] + 1, dp[j][k]);\\n                    }\\n                    else\\n                        dp[j][k] = dp[j][k];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865836,
                "title": "go-16ms-beats-100-very-simple-with-pseudocode",
                "content": "```\\nfunc findMaxForm(strs []string, m int, n int) int {\\n    memo := make([][]int, m + 1)\\n    for i := range memo {\\n        memo[i] = make([]int, n + 1)\\n    }\\n    for _, s := range strs {\\n        z := strings.Count(s, \"0\")\\n        o := len(s) - z\\n        for i := m; i >= z; i -= 1 {\\n            for j := n; j >= o; j -= 1 {\\n                t := memo[i - z][j - o] + 1\\n                if t > memo[i][j] {\\n                    memo[i][j] = t\\n                }\\n            }\\n        }\\n    }\\n    return memo[m][n]\\n}\\n```\\n\\nPseudocode:\\n```\\nCreate m+1 by n+1 int array M for memoization.\\nFor each string S:\\n    Count zeros and ones into vars \"zeros\" and \"ones\".\\n\\tFor each integer \"i\" between \"m\" and \"zeros\" inclusive:\\n\\t\\tFor each integer \"j\" between \"n\" and \"ones\" inclusive:\\n\\t\\t\\tIf using string S along with best result from M[i - zeros][j - ones] improves the previous best score for M[i][j]:\\n\\t\\t\\t\\tThen update M[i][j] with M[i - zeros][j - ones] + 1\\nReturn highest score from M (will always be index m,n)\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nfunc findMaxForm(strs []string, m int, n int) int {\\n    memo := make([][]int, m + 1)\\n    for i := range memo {\\n        memo[i] = make([]int, n + 1)\\n    }\\n    for _, s := range strs {\\n        z := strings.Count(s, \"0\")\\n        o := len(s) - z\\n        for i := m; i >= z; i -= 1 {\\n            for j := n; j >= o; j -= 1 {\\n                t := memo[i - z][j - o] + 1\\n                if t > memo[i][j] {\\n                    memo[i][j] = t\\n                }\\n            }\\n        }\\n    }\\n    return memo[m][n]\\n}\\n```\n```\\nCreate m+1 by n+1 int array M for memoization.\\nFor each string S:\\n    Count zeros and ones into vars \"zeros\" and \"ones\".\\n\\tFor each integer \"i\" between \"m\" and \"zeros\" inclusive:\\n\\t\\tFor each integer \"j\" between \"n\" and \"ones\" inclusive:\\n\\t\\t\\tIf using string S along with best result from M[i - zeros][j - ones] improves the previous best score for M[i][j]:\\n\\t\\t\\t\\tThen update M[i][j] with M[i - zeros][j - ones] + 1\\nReturn highest score from M (will always be index m,n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786016,
                "title": "dfs-memoization-approach",
                "content": "````\\nclass Solution {\\npublic:\\n    int dp[605][101][101];\\n    int dfs(vector<string>& strs, int m, int n, int currIndex, int len){\\n        if(currIndex == len){\\n            return 0;\\n        }\\n        if(m == 0 && n == 0){\\n            return 0;\\n        }\\n        if(dp[currIndex][m][n] != -1){\\n            return dp[currIndex][m][n];\\n        }\\n        int one = 0, zero = 0;\\n        for(int i=0;i<strs[currIndex].size();i++){\\n            if(strs[currIndex][i] == \\'1\\'){\\n                one++;\\n            }\\n            else{\\n                zero++;\\n            }\\n        }\\n        int inc_curr = 0, exc_curr = 0;\\n        if(zero <= m && one <= n){\\n            inc_curr = 1 + dfs(strs, m-zero, n-one, currIndex + 1, len);\\n        }\\n        exc_curr = dfs(strs, m, n, currIndex + 1, len);\\n        dp[currIndex][m][n] = max(inc_curr, exc_curr);\\n        return dp[currIndex][m][n];\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        int len = strs.size();\\n        for(int i=0;i<605;i++){\\n            for(int j=0;j<101;j++){\\n                for(int k=0;k<101;k++){\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }\\n        return dfs(strs, m, n, 0, len);\\n    }\\n};\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[605][101][101];\\n    int dfs(vector<string>& strs, int m, int n, int currIndex, int len){\\n        if(currIndex == len){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 706909,
                "title": "clean-0-1-knapsack-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> countF(string s)\\n    {\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            count+= s[i]==\\'1\\';\\n        }\\n        return {count,(int)s.length()-count};\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pair<int,int> >count;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n            count.push_back(countF(strs[i]));\\n        }\\n        int dp[(int)strs.size()+1][m+1][n+1];\\n        memset(dp, 0, sizeof dp);\\n        for(int i=0;i<=strs.size();i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                for(int k=0;k<=n;k++)\\n                {\\n                    if(i==0)\\n                    {\\n                        dp[i][j][k]=0;\\n                        continue;\\n                    }\\n                    int count1=count[i-1].first;\\n                    int count0=count[i-1].second;\\n                    dp[i][j][k]=dp[i-1][j][k]; \\n                    if(j >= count0 && k >= count1)\\n                    {\\n                       dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-count0][k-count1]+1); \\n                    }\\n                }\\n            }\\n        }\\n        return dp[(int)strs.size()][m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> countF(string s)\\n    {\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            count+= s[i]==\\'1\\';\\n        }\\n        return {count,(int)s.length()-count};\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pair<int,int> >count;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n            count.push_back(countF(strs[i]));\\n        }\\n        int dp[(int)strs.size()+1][m+1][n+1];\\n        memset(dp, 0, sizeof dp);\\n        for(int i=0;i<=strs.size();i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                for(int k=0;k<=n;k++)\\n                {\\n                    if(i==0)\\n                    {\\n                        dp[i][j][k]=0;\\n                        continue;\\n                    }\\n                    int count1=count[i-1].first;\\n                    int count0=count[i-1].second;\\n                    dp[i][j][k]=dp[i-1][j][k]; \\n                    if(j >= count0 && k >= count1)\\n                    {\\n                       dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-count0][k-count1]+1); \\n                    }\\n                }\\n            }\\n        }\\n        return dp[(int)strs.size()][m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656987,
                "title": "why-does-dfs-with-memoization-not-work",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int>mp;\\n    int dfs(vector<pair<int,int>>&v,int m,int n,int pos){\\n        if(mp.find({pos,{m,n}})!=mp.end())return mp[{pos,{m,n}}];\\n        int x=0;\\n        for(int i=pos;i<v.size();i++){\\n            if(m-v[i].first>=0 && n-v[i].second>=0){\\n                x=max(x,dfs(v,m-v[i].first,n-v[i].second,i+1)+1);\\n            }\\n        }\\n        mp[{pos,{m,n}}]=x;\\n        return x;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<strs.size();i++){\\n            int zero=0,one=0;\\n            for(char ch:strs[i]){\\n                if(ch==\\'0\\')zero++;\\n                else one++;\\n            }\\n            v.push_back({zero,one});\\n        }\\n        return dfs(v,m,n,0);\\n    }\\n};\\n```\\n\\nThis code works for 60/69 test cases.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int>mp;\\n    int dfs(vector<pair<int,int>>&v,int m,int n,int pos){\\n        if(mp.find({pos,{m,n}})!=mp.end())return mp[{pos,{m,n}}];\\n        int x=0;\\n        for(int i=pos;i<v.size();i++){\\n            if(m-v[i].first>=0 && n-v[i].second>=0){\\n                x=max(x,dfs(v,m-v[i].first,n-v[i].second,i+1)+1);\\n            }\\n        }\\n        mp[{pos,{m,n}}]=x;\\n        return x;\\n    }\\n    int findMaxForm(vector<string>& strs, int m, int n) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<strs.size();i++){\\n            int zero=0,one=0;\\n            for(char ch:strs[i]){\\n                if(ch==\\'0\\')zero++;\\n                else one++;\\n            }\\n            v.push_back({zero,one});\\n        }\\n        return dfs(v,m,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570886,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1566223,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1569125,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1568553,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1782498,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1576796,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1573798,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1571744,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1571743,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 2025815,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1570886,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1566223,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1569125,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1568553,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1782498,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1576796,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1573798,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1571744,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 1571743,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            },
            {
                "id": 2025815,
                "content": [
                    {
                        "username": "prasad_gandhi",
                        "content": "The answer of Example 2 should be 3, how come it is 2 ?"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "The statement is so ambiguous. It just mentioned that a string which should be included in the subset should have less than or equal to m \"0\"s and n \"1\"s. But as per the output, the number of \"0\"s and \"1\" should decrease with respect to the presence of \"0\"s and \"1\"s in the previous string while iterating. It took really long for me to figure out."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset not in each element of that subset .Hope it helps"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/ones-and-zeroes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Time Limit Exceeded]\n\n  \n**Approach 2:** Better Brute Force [Time Limit Exceeded]\n\n  \n**Approach 3:** Using Recursion [Time Limit Exceeded]\n\n  \n**Approach 4:** Using Memoization [Accepted]\n\n  \n**Approach 5:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "opentolearn",
                        "content": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nLeetCode is giving answer 3 and I am thinking maximum we can get is 2 only. Can someone please explain how we get 3 ?"
                    },
                    {
                        "username": "200030041",
                        "content": "[@user5400h](/user5400h) the question is atmost m 0\\'s and atmost n 1\\'s"
                    },
                    {
                        "username": "yadav0288",
                        "content": "[@user5400h](/user5400h)  according to question at most m 0\\'s and n 1\\'s in the subset. , that\\'s why ans is 3 \\n"
                    },
                    {
                        "username": "user3574B",
                        "content": "[@user5400h](/user5400h) \\nthe output seems ok to me - [\"10\", \"1\", \"0\"] that\\'s 3 "
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly, the output of this test case is wrong. its answer will be 2 only. i.e. [111001, 0]"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "I am confused with the question:\\nExample: [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\\n\\nThe subset must conain at most 4 0\\'s and 3 1\\'s\\nso the valid set is 10, 0001, 1, 0, so is 4 but correct anser is 3\\n\\nthis is similar to the first example where:\\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\\nOutput: 4\\nExplanation: The largest subset with at most 5 0\\'s and 3 1\\'s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\\n\\nI guess this could 10 contains 1 and 0 so it is not counted as subset??\\n\\nbut the first example does count 10"
                    },
                    {
                        "username": "o60816",
                        "content": "I was stuck as well, and I finally figure it out.\nThe answer is the size of subsets not the total sum of those binary string in subsets.\ne.g.\nSo the answer of [\"10\",\"0001\",\"111001\",\"1\",\"0\"] 4 3\nis the size of [\"10\", \"0001\", \"1\"] is 3 not the total sum of 2 + 1 + 1 = 4."
                    },
                    {
                        "username": "MikeIsMike",
                        "content": "Clarification about example 2: I\\'ve realised that m and n are the numbers of 0 and 1 permitted in the whole subset, rather than in each string of the whole subset. {\"01\"} would be the subset that has at most one 0 and at most one 1. {\"01\", \"0\", \"1\"} as a subset has two 0\\'s and two 1\\'s, so the answer is 2 for example 2, rather than 3."
                    },
                    {
                        "username": "Umang3172",
                        "content": "So, I have a doubt that why example 2 return value 2 rather than 3 as there can be atmost 1 1\\'s and 1 0\\'s, so \"10\" should be included as it has 1 \"1\" and 1 \"0\". \\nExample 2: \\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\\nOutput: 2\\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\\n\\nThanks in advance."
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "The question says Total no of zeroes and one\\'s in longest subset should be less than or equal to one not in each element of that subset so if you take 10 then you cannot add anymore element .Hope it helps"
                    },
                    {
                        "username": "familytime001",
                        "content": "Original: \"form with given ***m*** 0s and ***n*** 1s.\"\"\\n\\nShould consider \"form with ***at most*** m 0s and ***at most*** n 1s\"\\n\\nFor example, in this test case, \\n[\"10\",\"1\"]\\n2\\n2\\nOnline Judge Ans = 2, by chosing \"10\", \"1\",  however, ***it does not use***  m=2 0s and n=2 1s\\n\\nPlease update."
                    },
                    {
                        "username": "JokerChris",
                        "content": "I can't understand this instance:\\n\\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\\n3\\n4\\n\\nthe expected answer is 3.\\nBut I think the answer is 2 [\"111001\",\"0\"]."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@user5400h](/user5400h)  no its not, the answer is correct...."
                    },
                    {
                        "username": "user5400h",
                        "content": "exactly. this test case output is wrong. it will be 2 as [111001, 0]"
                    },
                    {
                        "username": "franky123",
                        "content": "I can code the top down DP  solution in O(N*M* string length) time and space but worst case memory limit is 600*100*100 which makes it not feasible. Is it possible to reduce memory for top down dp approach specifically or only possible with bottom up?"
                    },
                    {
                        "username": "s3stan",
                        "content": "It takes a lot of care to understand the condition of the problem. Questions on the second example immediately seem justified. But if you carefully read the task, everything is very clear.\\nThe matter is that it is necessary to select not lines separately, and the maximum subset of rows in which the number of 0 and 1 in the sum is not greater than the given one.\\nThat is, in the second example, both n and m are equal to 1. And this means that to get the maximum subset we have to select rows \\'0\\' and \\'1\\'."
                    }
                ]
            }
        ]
    }
]