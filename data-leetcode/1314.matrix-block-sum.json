[
    {
        "title": "Valid Permutations for DI Sequence",
        "question_content": "You are given a string s of length n where s[i] is either:\n\n\t'D' means decreasing, or\n\t'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\n\tIf s[i] == 'D', then perm[i] > perm[i + 1], and\n\tIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\nExample 2:\n\nInput: s = \"D\"\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == s.length\n\t1 <= n <= 200\n\ts[i] is either 'I' or 'D'.",
        "solutions": [
            {
                "id": 168278,
                "title": "c-java-python-dp-solution-o-n-2",
                "content": "# Intuition\\n`dp[i][j]` means the number of possible permutations of first `i + 1` digits,\\nwhere the `i + 1`th digit is `j + 1`th smallest in the rest of unused digits.\\n\\n\\nOk, may not make sense ... Let\\'s see the following diagram.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1536486527.png)\\n\\nI take the example of `S = \"DID\"`.\\nIn the parenthesis, I list all possible permutations.\\n\\nThe permutation can start from `1, 2, 3, 4`.\\nSo `dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = 1`.\\n\\nWe decrese from the first digit to the second,\\nthe down arrow show the all possibile decresing pathes.\\n\\nThe same, because we increase from the second digit to the third,\\nthe up arrow show the all possibile increasing pathes.\\n\\n`dp[2][1] = 5`, mean the number of permutations\\nwhere the third digitis the second smallest of the rest.\\nWe have 413,314,214,423,324.\\nFow example 413, where 2,3 are left and 3 the second smallest of them.\\n<br>\\n\\n# Explanation\\nAs shown in the diagram,\\nfor \"I\", we calculate prefix sum of the array,\\nfor \"D\", we calculate sufixsum of the array.\\n<br>\\n\\n# Complexity\\nTime `O(N^2)`\\nSpace `O(N^2)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\\n\\n# Solution 2:\\nNow as we did for every DP, make it 1D dp.\\nTime `O(N^2)`\\nSpace `O(N)`\\n\\n**C++:**\\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<int> dp(n + 1, 1), dp2(n);\\n        for (int i = 0; i < n; dp = dp2, i++) {\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[] dp = new int[n + 1], dp2 = new int[n];;\\n        for (int j = 0; j <= n; j++) dp[j] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n            dp = Arrays.copyOf(dp2, n);\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Python2**\\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for c in S:\\n            if c == \"I\":\\n                dp = dp[:-1]\\n                for i in range(1, len(dp)):\\n                    dp[i] += dp[i - 1]\\n            else:\\n                dp = dp[1:]\\n                for i in range(len(dp) - 1)[::-1]:\\n                    dp[i] += dp[i + 1]\\n        return dp[0] % (10**9 + 7)\\n```\\n**Python3**\\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<int> dp(n + 1, 1), dp2(n);\\n        for (int i = 0; i < n; dp = dp2, i++) {\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n        }\\n        return dp[0];\\n    }\\n```\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[] dp = new int[n + 1], dp2 = new int[n];;\\n        for (int j = 0; j <= n; j++) dp[j] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n            dp = Arrays.copyOf(dp2, n);\\n        }\\n        return dp[0];\\n    }\\n```\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for c in S:\\n            if c == \"I\":\\n                dp = dp[:-1]\\n                for i in range(1, len(dp)):\\n                    dp[i] += dp[i - 1]\\n            else:\\n                dp = dp[1:]\\n                for i in range(len(dp) - 1)[::-1]:\\n                    dp[i] += dp[i + 1]\\n        return dp[0] % (10**9 + 7)\\n```\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 196939,
                "title": "easy-to-understand-solution-with-detailed-explanation",
                "content": "\\nBefore diving into the state transition function, let us first start with a simple example.\\n\\n### 1. a simple example\\n\\nIn the following discussion, for simplification, I will use both notation DI-seq and DI-rule instead of DI sequence.\\n\\nConsider a permutation 1032, which is based on a DI-seq \"DID\", how to use it to construct a new instance ending at **2** and based on DI-seq \"DID**D**\"?\\n\\n**Method**:\\nstep 1.\\nfor the original permutation `1032`, we add 1 to the digits *that are larger than or equal to* **2**.\\n```C++\\n1032->1043\\n  ^^\\n```\\n\\nstep 2.\\nthen directly append **2**  to `1043`,  i.e., 1043 -> 1043**2**\\n\\n**Remark on step 1**:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival **2**.\\n(2) More importantly, such operation on the digits **will not break the original DI-rule**. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward,  you can validate yourself.\\n\\nNow a new permutation with DI-rule \"DID**D**\" and ending at **2** has been constructed from 1032, namely 1043**2**.\\n\\n\\nWith the same spirit, using 1032(\"DID\"), we can construct instances with DI-rule \"DID**D**\": 2043**1**(ending with **1**), 2143**0**(ending with **0**).\\n(Note that the instance(based on \"DID**D**\") which ends with 3 can not be constructed.)\\n\\n\\n\\nSimilarly, from 1032(\"DID\"), we can construct instances with DI-rule \"DID**I**\": 10423(ending with **3**), 10324(ending with **4**).\\n(Note that the instance(based on \"DID**I**\") which ends with 1 or 2 can not be constructed.)\\n\\n\\n\\n### 2. state transition function\\n\\nWith the example above in mind, the transition function seems to be clear.\\n\\nGiven a string DI-seq S, let `dp[i][j]` represents the number of permutation of number `0, 1, ... , i`, satisfying DI-rule S.substr(0, i), and ending with digit `j`.\\n\\n\\n```C++\\nif(S[i-1] == \\'D\\')\\n   dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + ... + dp[i-1][i-1]\\n\\nif(S[i-1] == \\'I\\') \\n   dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]\\n```\\n\\n\\n\\n\\n### 3.  Solution\\n\\n```C++\\nlass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.size(), m = 1e9 + 7;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= i; j++)\\n                if(S[i-1] == \\'D\\')\\n                    for(int k = j; k <= i-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n                else\\n                    for(int k = 0; k <= j-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n        int res = 0;\\n        for(int i = 0; i <= n; i++)\\n            res = res%m + dp[n][i]%m;\\n        return res%m;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\n1032->1043\\n  ^^\\n```\n```C++\\nif(S[i-1] == \\'D\\')\\n   dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + ... + dp[i-1][i-1]\\n\\nif(S[i-1] == \\'I\\') \\n   dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]\\n```\n```C++\\nlass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.size(), m = 1e9 + 7;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= i; j++)\\n                if(S[i-1] == \\'D\\')\\n                    for(int k = j; k <= i-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n                else\\n                    for(int k = 0; k <= j-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n        int res = 0;\\n        for(int i = 0; i <= n; i++)\\n            res = res%m + dp[n][i]%m;\\n        return res%m;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168612,
                "title": "top-down-with-memo-bottom-up-dp-n-3-dp-n-2-dp-o-n-space",
                "content": "**Top-down with Memo:**\\n\\nDefinition: `helper(String s, Map<String, Long> map)`: Answer to `s`.\\n\\nIntuition: Insert the largest number into appropriate postion.\\n\\neg. `s=\\'IIDD\\'`, we can only insert `4` between `I` and `D`. We break the remained numbers `0, 1, 2, 3` into two groups both with the size of 2. We have `C(4, 2)` possible combinations. Then `helper(\"IIDD\") = helper(\"I\") * helper(\"D\") * C(4, 2)`.\\n\\nTricky: How to calculate `C(n, k) % M`? I referred a method using *Pascal Triangle* from [here](https://www.geeksforgeeks.org/compute-ncr-p-set-1-introduction-and-dynamic-programming-solution/). (This part makes this method ugly and lengthy, anybody has better approaches?)\\n\\nTime complexity: `O(n^4)` in my implementation, however could improve to `O(n^3)`.\\n\\nCode:\\n\\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    private int[][] nCkMemo;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        nCkMemo = new int[n + 1][n + 1];\\n        return (int)helper(S, new HashMap<>());\\n    }\\n    private long helper(String s, Map<String, Long> map) {\\n        if (s.equals(\"\")) {\\n            return 1;\\n        }\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        long result = 0;\\n        int n = s.length();\\n        if (s.charAt(0) == \\'D\\') {\\n            result += helper(s.substring(1), map);\\n            result %= M;\\n        }\\n        if (s.charAt(n - 1) == \\'I\\') {\\n            result += helper(s.substring(0, n - 1), map);\\n            result %= M;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i - 1) == \\'I\\' && s.charAt(i) == \\'D\\') {\\n                long left = helper(s.substring(0, i - 1), map);\\n                long right = helper(s.substring(i + 1), map);\\n                result += (((left * right) % M) * nCk(n, i)) % M;\\n                result %= M;\\n            }\\n        }\\n        map.put(s, result);\\n        return result;\\n    }\\n    private int nCk(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k) + nCk(n - 1, k - 1)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\\n\\n**Bottom-up DP:**\\n\\nSame idea with the Top-down. `dp[i][j]` represent the answer of `s.substring(i, j)`. Just a Bottom-up implementation:\\n\\nTime complexity: `O(n^3)`\\n\\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        int[][] nCkMemo = new int[n + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][i] = 1;\\n        }\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len;\\n                if (S.charAt(i) == \\'D\\') {\\n                    dp[i][j] += dp[i + 1][j];\\n                    dp[i][j] %= M;\\n                }\\n                for (int k = i + 1; k < j; k++) {\\n                    if (S.charAt(k - 1) == \\'I\\' && S.charAt(k) == \\'D\\') {\\n                        dp[i][j] += (((dp[i][k - 1] * dp[k + 1][j]) % M) * nCk(len, k - i, nCkMemo)) % M;\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n                if (S.charAt(j - 1) == \\'I\\') {\\n                    dp[i][j] += dp[i][j - 1];\\n                    dp[i][j] %= M;\\n                }\\n            }\\n        }\\n        return (int)dp[0][n];\\n    }\\n    private int nCk(int n, int k, int[][] nCkMemo) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k, nCkMemo) + nCk(n - 1, k - 1, nCkMemo)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\\n\\n**N^3 DP:**\\n\\nLet\\'s change the definition of `dp` matrix to make the calculation simple: let\\'s say `dp[i][j]` represents the number of permutation of number `0, 1, ... , i` which ends with `j`. Also, it represents the answer of  `s.substring(0, i)` which ends with `j`.\\nWe will have two conditions: \\n\\n1. `s.charAt(i - 1) == \\'I\\'`: In this case, `dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1])`.\\n2. `s.charAt(i - 1) == \\'D\\'`: In this case, `dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1])`.\\n\\nImagine each time when appending the `j` to the previous permutations, you have to **add 1 to each number in the previous permutation which is greater than or equals to `j`**. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation `(1, 0, 3, 2)`. We are trying to append `2`. Now the `(1, 0, 3, 2)` changes to `(1, 0, 4, 3)` then appended with a `2`. We have `(1, 0, 4, 3, 2)`. Although the values change but the order and count don\\'t change.\\n\\nTime complexity: `O(n^3)`\\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    for (int k = j; k < i; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                } else {\\n                    for (int k = 0; k < j; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 0; j <= n; j++) {\\n            result += dp[n][j];\\n            result %= M;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n **N^2 DP:**\\n \\n Notice that in the previous method, we are actually calculate the **prefix sum** and **suffix sum**  in the two conditions:\\n \\n1. `s.charAt(i - 1) == \\'I\\'`: In this case, `dp[i][j] = sum[i - 1][j - 1]`.\\n2. `s.charAt(i - 1) == \\'D\\'`: In this case, `dp[i][j] = sum[i - 1][i - 1] - sum[i - 1][j - 1]`.\\n\\nWe can define `dp[i][j]` as `sum(dp[i][0], dp[i][1], ... dp[i][j])` which is `sum[i][j]`.\\n\\nTime complexity: `O(n^2)`\\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        Arrays.fill(dp[0], 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                dp[i][j] = j == 0 ? 0 : dp[i][j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    dp[i][j] += (dp[i - 1][i - 1] - (j == 0 ? 0 : dp[i - 1][j - 1])) % M;\\n                    if (dp[i][j] < 0) {\\n                        dp[i][j] += M;\\n                    }\\n                } else {\\n                    dp[i][j] += j == 0 ? 0 : dp[i - 1][j - 1];\\n                }\\n                dp[i][j] %= M;\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\\n\\n**O(N) space:**\\n\\nPrevious solution could be optimized to `O(n)` space.\\n\\nTime complexity: `O(n^2)`. Space complexity: `O(n)`.\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i <= n; i++) {\\n            int[] temp = new int[n + 1];\\n            for (int j = 0; j <= i; j++) {\\n                temp[j] = j == 0 ? 0 : temp[j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    temp[j] += (dp[i - 1] - (j == 0 ? 0 : dp[j - 1])) % M;\\n                    if (temp[j] < 0) {\\n                        temp[j] += M;\\n                    }\\n                } else {\\n                    temp[j] += j == 0 ? 0 : dp[j - 1];\\n                }\\n                temp[j] %= M;\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    private int[][] nCkMemo;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        nCkMemo = new int[n + 1][n + 1];\\n        return (int)helper(S, new HashMap<>());\\n    }\\n    private long helper(String s, Map<String, Long> map) {\\n        if (s.equals(\"\")) {\\n            return 1;\\n        }\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        long result = 0;\\n        int n = s.length();\\n        if (s.charAt(0) == \\'D\\') {\\n            result += helper(s.substring(1), map);\\n            result %= M;\\n        }\\n        if (s.charAt(n - 1) == \\'I\\') {\\n            result += helper(s.substring(0, n - 1), map);\\n            result %= M;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i - 1) == \\'I\\' && s.charAt(i) == \\'D\\') {\\n                long left = helper(s.substring(0, i - 1), map);\\n                long right = helper(s.substring(i + 1), map);\\n                result += (((left * right) % M) * nCk(n, i)) % M;\\n                result %= M;\\n            }\\n        }\\n        map.put(s, result);\\n        return result;\\n    }\\n    private int nCk(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k) + nCk(n - 1, k - 1)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        int[][] nCkMemo = new int[n + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][i] = 1;\\n        }\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len;\\n                if (S.charAt(i) == \\'D\\') {\\n                    dp[i][j] += dp[i + 1][j];\\n                    dp[i][j] %= M;\\n                }\\n                for (int k = i + 1; k < j; k++) {\\n                    if (S.charAt(k - 1) == \\'I\\' && S.charAt(k) == \\'D\\') {\\n                        dp[i][j] += (((dp[i][k - 1] * dp[k + 1][j]) % M) * nCk(len, k - i, nCkMemo)) % M;\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n                if (S.charAt(j - 1) == \\'I\\') {\\n                    dp[i][j] += dp[i][j - 1];\\n                    dp[i][j] %= M;\\n                }\\n            }\\n        }\\n        return (int)dp[0][n];\\n    }\\n    private int nCk(int n, int k, int[][] nCkMemo) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k, nCkMemo) + nCk(n - 1, k - 1, nCkMemo)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    for (int k = j; k < i; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                } else {\\n                    for (int k = 0; k < j; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 0; j <= n; j++) {\\n            result += dp[n][j];\\n            result %= M;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        Arrays.fill(dp[0], 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                dp[i][j] = j == 0 ? 0 : dp[i][j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    dp[i][j] += (dp[i - 1][i - 1] - (j == 0 ? 0 : dp[i - 1][j - 1])) % M;\\n                    if (dp[i][j] < 0) {\\n                        dp[i][j] += M;\\n                    }\\n                } else {\\n                    dp[i][j] += j == 0 ? 0 : dp[i - 1][j - 1];\\n                }\\n                dp[i][j] %= M;\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i <= n; i++) {\\n            int[] temp = new int[n + 1];\\n            for (int j = 0; j <= i; j++) {\\n                temp[j] = j == 0 ? 0 : temp[j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    temp[j] += (dp[i - 1] - (j == 0 ? 0 : dp[j - 1])) % M;\\n                    if (temp[j] < 0) {\\n                        temp[j] += M;\\n                    }\\n                } else {\\n                    temp[j] += j == 0 ? 0 : dp[j - 1];\\n                }\\n                temp[j] %= M;\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168289,
                "title": "share-my-o-n-3-o-n-2-c-dp-solution-including-the-thoughts-of-improvement",
                "content": "Came up with the original idea during contest, so might not be the best. But it works.\\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] number of permutation whose length is i and end with j\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    // add all string with length i - 1 and last digit is greater than or equal to j\\n                    for (int k = j; k <= i; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                } else {\\n                    // increase to j\\n                    // add all string with length i - 1 and last digit is smaller than j\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= N; ++i) ans = (ans + dp[N][i]) % MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n**UPDATE 9/9/2018**:\\nThanks to `@chosun1`, I used prefix sum to save the result which reduce the complexity to O(N ^ 2). There is no need to keep a separate 2d array for prefix sum, just change the definition of dp array is fine. Here is the updated code, it is even shorter.\\n\\n`dp[i][j]` means number of permutation whose length is `i` and end with **at most** `j`.\\n\\nLet\\'s say the current position of DI sequence is `\\'D\\'`, \\nSo, `dp[i][j] = dp[i][j-1] + X`, where `X` is number of permutations whose length is `i` and end exactly with `j`. We can calculate it by adding number of permutations whose length is `i-1` and end with `{j, j+1, ..., i-1}`, because they will satisfy the condition of \"decreasing to j\". (*Wait! Wait! Why start with j not j + 1?, see the bolded explaination below.*)\\nAccording to the definition of dp array, we can get `X = dp[i-1][i-1] - dp[i-1][j-1]`.\\n\\nIf the DI sequence is `\\'I\\'`, it\\'s similiar.\\n\\n**So, why start with j, not j + 1, since the sequence is decreasing to j?**\\n`Thought Experiment`: In the sequence with length of `i-1`, the largest number in this sequence should be `i-1`. However, when we are dealing with length `i` and end with `j`, the previous sequence has already another `j` and we should also add `i` to the sequence. What we can do is, **add one to all those numbers greater than or equal to j**. This operation will make the largest number to be `i` without breaking the sequence property, also, it will free the `j` so that we can use it at the end of the sequence. By this thought experiment, we can easily get the result of `X`. For example, if the sequence is `{3,4,1,2,5}` and we want to expand it to be of length 6 and end with 3. We first make it to be `{3->4,4->5,1,2,5->6}`, and then, add 3 to the end of the sequence.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] means number of permutation whose length is i and end with at most j.\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][i-1] - dp[i-1][j-1]) % MOD) % MOD;\\n                } else {\\n                    // increase to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][j-1] - dp[i-1][0]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return (dp[N][N] + MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] number of permutation whose length is i and end with j\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    // add all string with length i - 1 and last digit is greater than or equal to j\\n                    for (int k = j; k <= i; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                } else {\\n                    // increase to j\\n                    // add all string with length i - 1 and last digit is smaller than j\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= N; ++i) ans = (ans + dp[N][i]) % MOD;\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] means number of permutation whose length is i and end with at most j.\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][i-1] - dp[i-1][j-1]) % MOD) % MOD;\\n                } else {\\n                    // increase to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][j-1] - dp[i-1][0]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return (dp[N][N] + MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715588,
                "title": "how-to-define-the-dp-states-with-clear-picture-explanation",
                "content": "When I tried to understand lee215\\'s [solution](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C++JavaPython-DP-Solution-O(N2)), I got stuck. Then I redescribe this process to better understand the whole process. Credits go to lee215.  \\nThe intuition is: given a string s, results of the number of permutations for the following strings are the same.\\n```\\n0,1,2\\n1,2,3\\n1,2,4\\n```\\n\\nBased on this observation, we can use the index of the sorted unused digits to aggregate the results.\\nI am going to improve the illustration and also state definition.\\nDefine the state of DP[i][j] as:\\n- i is the digit index.\\n- j is the **index** of current digit from sorted(current digit + remaining digits).\\n\\nThe reason we define j in this way is:\\nAll the following will have the same results based on the same string S.\\n```\\n0, 1,2\\n1,2,3\\n1,2,4\\n```\\nWe can use index to have an unified representation.\\n```\\n0, 1, 2   ->   0, 1,  2\\n1, 2, 3   ->   0, 1,  2\\n1, 2, 4   ->   0, 1,  2\\n```\\nAfter figuring out this, the transitions can be shown as below:![image](https://assets.leetcode.com/users/images/d146760c-7121-409f-be5d-a7d406029ae0_1623956092.467306.png)\\n\\n\\nMore detail can be found [Here.](https://medium.com/@jim.morris.shen/hard-dp-77774c6a4695?source=friends_link&sk=d901fef6067a08fdbb184acfdeb8cf5e)\\n\\nAfter figuring out the state transitions, then the code is pretty simple.\\nif \"D\": postfix sum\\nif \\'I\\': prefix sum\\n```\\n/*\\njimmy shen\\nTime complexity: O(n^2)\\nSpace complexity: O(n)\\n*/\\n\\nint MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.size();\\n        vector<int> dp(N+1, 1);\\n        for (int i=1;i<N+1;++i){\\n            int M = (N+1)-i;\\n            vector<int> new_dp(M, 0);\\n            if (S[i-1]==\\'D\\'){\\n                //postfix sum\\n                for (int j=dp.size()-2;j>=0;--j){\\n                    dp[j] += dp[j+1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j+1];\\n                }\\n            }\\n            else{\\n                //prefix sum\\n                for (int j=1;j<dp.size();++j){\\n                    dp[j] += dp[j-1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j];\\n                }\\n            }\\n            dp = new_dp;\\n        }\\n        int ret = 0;\\n        for (int i=0;i<dp.size();++i){\\n            ret+=dp[i];\\n            if (ret>=MOD)ret %= MOD;}\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0,1,2\\n1,2,3\\n1,2,4\\n```\n```\\n0, 1,2\\n1,2,3\\n1,2,4\\n```\n```\\n0, 1, 2   ->   0, 1,  2\\n1, 2, 3   ->   0, 1,  2\\n1, 2, 4   ->   0, 1,  2\\n```\n```\\n/*\\njimmy shen\\nTime complexity: O(n^2)\\nSpace complexity: O(n)\\n*/\\n\\nint MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.size();\\n        vector<int> dp(N+1, 1);\\n        for (int i=1;i<N+1;++i){\\n            int M = (N+1)-i;\\n            vector<int> new_dp(M, 0);\\n            if (S[i-1]==\\'D\\'){\\n                //postfix sum\\n                for (int j=dp.size()-2;j>=0;--j){\\n                    dp[j] += dp[j+1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j+1];\\n                }\\n            }\\n            else{\\n                //prefix sum\\n                for (int j=1;j<dp.size();++j){\\n                    dp[j] += dp[j-1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j];\\n                }\\n            }\\n            dp = new_dp;\\n        }\\n        int ret = 0;\\n        for (int i=0;i<dp.size();++i){\\n            ret+=dp[i];\\n            if (ret>=MOD)ret %= MOD;}\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707459,
                "title": "python-dp-approach-some-explanation",
                "content": "Most of us here are preparing for programming Interviews and those interviews have a threshold of about 45 minutes, and you have to come-up with an approach, write code, and explain. If you spend some time on the discuss section, you will realize there are some awesome solutions, which take you more than an interview-time to understand, let alone to come-up and code it. You may probably not hit the cool greedy solution, or the most optimized DP within time (though with time you will improve) but you should first practice to be able to solve the problem **within time**.\\nIt is often helpful to keep a timer of 45 minutes to solve these problems, even if you are not able to solve it you will get enough understanding to explain your approaches and why those won\\'t work out? Then move to discuss sections and try to understand a solution in 10-20 minutes. If you are able to understand in this time, you can code in the remaining time.\\n\\nSo, the following is what I came up within ~45 minutes:\\nThis problem clearly speaks for a Dynamic Programmic approach. \\nYou can imagine a state graph, \\n* last state can have any values between [0, n]\\n* if the last step was \\'D\\', the previous state can have only a higher value than what at the last state. Similarly, a lower value if step was \\'I\\'.\\n* and the combination should be unique.\\n\\nThe third point, required some book-keeping of what numbers have appeared already. And I started out with a solution to keep the mask (as a tuple) (which as you may already know, won\\'t work). After much brainstorming, I realized that it is not required to keep the details of which numbers (specifically) have appeared. It would just suffice to keep the details of the number of numbers haven\\'t appeared and how many of them are lower (or higher) than the last number.\\n\\n```python\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        N = len(S)\\n        MOD = 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, less, more):\\n            res = 0\\n            if(i < 0): return 1\\n            if(less + more == 0): return 0\\n            if(S[i] == \\'I\\'):\\n                for k in range(less):\\n                    res = (res + dp(i-1, k, less - k -1 + more)) % MOD\\n            elif(S[i] == \\'D\\'):\\n                for k in range(more):\\n                    res = (res + dp(i-1, less + k, more - k - 1)) % MOD\\n            return res\\n        \\n        return sum(dp(N-1, k, N-k) for k in range(N+1)) % MOD\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        N = len(S)\\n        MOD = 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, less, more):\\n            res = 0\\n            if(i < 0): return 1\\n            if(less + more == 0): return 0\\n            if(S[i] == \\'I\\'):\\n                for k in range(less):\\n                    res = (res + dp(i-1, k, less - k -1 + more)) % MOD\\n            elif(S[i] == \\'D\\'):\\n                for k in range(more):\\n                    res = (res + dp(i-1, less + k, more - k - 1)) % MOD\\n            return res\\n        \\n        return sum(dp(N-1, k, N-k) for k in range(N+1)) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186571,
                "title": "python-o-n-3-o-n-2-time-o-n-space-dp-solution-with-clear-explanation-no-relative-rank-stuff",
                "content": "Since I didn\\'t understand the relative rank stuff, I found this problem to be quite confusing until I saw this thread:\\nhttps://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/169126/Visualization-Key-to-the-DP-solution:-imagine-cutting-a-piece-of-paper-and-separating-the-halves\\n\\n**Property: If we increment elements that are greater than or equal to a certain value the D or I property will not be broken, as this only makes \"larger\" elements even larger.**\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length i depends on, and can be derived from, the number of solutions with length i-1, as follows:\\n\\n    We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n    We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n    ...\\n    We increment all elements that are greater than or equal to i, and see if we can append i to the end of the sequence.\\n\\n**Therefore, we only care about the last number of each existing valid permutation.**\\n\\nFor each j in the range (0, i), we want to find the number of valid permutations of len i ending in j. \\n* When placing j following a decreasing instruction \\'D\\', we want the last number in the existing permutation to have a higher value. \\n* When placing j following an increasing instruction \\'I\\', we want the last number in the existing permutation to have a lower value. \\n\\nWe use two DP arrays of len(S)+1, dp and dp2. We swap dp and dp2 at the end of each step.\\n\\n**D:** 10\\nThe only valid permutation for \\'D\\' is 10.\\n* solutions ending with 0: 1\\n* solutions ending with 1: 0\\n\\n**DI:** 102, 201\\nWe want the last number in each existing permutation to have a lower value than j.\\n* \\\\# solutions ending with 0: 0\\nWe cannot add a 0 to any existing valid permutation, since the only valid permutation for \\'D\\' is 10.\\n* \\\\# solutions ending with 1: dp2[1] = dp[0], which is 1\\nWe have 1 solution ending with a 0 we can add a 0 to, since we want the last number in the permutation to have a lower value.\\n* \\\\# solutions ending with 2: dp2[2] = dp[0] + dp[1], which is 1\\nWe have 1 solution ending with a 0 we can add a 2 to, since we want the last number in the permutation to have a lower value.\\n\\n**DID:** 5 permutations\\nWe want the last number in each existing permutation to have a higher value than j. \\n* \\\\# of solutions ending with 0: dp[0] + dp[1] + dp[2] = 2\\nWe increment all elements in 102, 201 that are >= 0 to get 213 and 312, which we can add a 0 to.\\n* \\\\# solutions ending with 1: dp[1] + dp[2] = 2\\nWe increment all elements in 102, 201 that are >= 1 to get 203 and 302, which we can add a 1 to.\\n* \\\\# solutions ending with 2: dp[2] = 1\\nSimilarly, the permutation 102 becomes 103, which we can add a 2 to.\\n* \\\\# solutions ending with 3: 0\\n\\n**DIDI:** 16 permutations\\nFrom this point onward, only the number of permutations is listed for the sake of brevity.\\n\\nsolutions ending with 0: 0\\nsolutions ending with 1: 2 (dp[0])\\nsolutions ending with 2: 4 (dp[0] + dp[1])\\nsolutions ending with 3: 5 (dp[0] + dp[1] + dp[2])\\nsolutions ending with 4: 5 (dp[0] + dp[1] + dp[2] + dp[3])\\n\\nNow let\\'s see the two different outcomes for adding an I or D to that sequence:\\n\\n**DIDID:** 61 permutations\\nsolutions ending with 0: 16 (dp[0] + dp[1] + dp[2] + dp[3] + dp[4])\\nsolutions ending with 1: 16 (dp[1] + dp[2] + dp[3] + dp[4])\\nsolutions ending with 2: 14 (dp[2] + dp[3] + dp[4])\\nsolutions ending with 3: 10 (dp[3] + dp[4])\\nsolutions ending with 4: 5 (dp[4])\\nsolutions ending with 5: 0\\n\\n**DIDII:** 35 permutations\\nsolutions ending with 0: 0 \\nsolutions ending with 1: 0 (dp[0])\\nsolutions ending with 2: 2 (dp[0] + dp[1])\\nsolutions ending with 3: 6 (dp[0] + dp[1] + dp[2])\\nsolutions ending with 4: 11 (dp[0] + dp[1] + dp[2] + dp[3])\\nsolutions ending with 5: 16 (dp[0] + dp[1] + dp[2] + dp[3] + dp[4])\\n\\nYou might be able to notice a pattern here:\\nWhen placing j following a decreasing instruction \\'D\\', then dp2[j] = sum of dp[j] to dp[i-1]\\nWhen placing j following an increasing instruction \\'I\\', then dp2[j] = sum of dp[0] to dp[j-1]\\n\\nTherefore:\\n\\n```\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for c in range(len(S)+1)]\\n        dp2 = [0 for c in range(len(S)+1)]\\n        \\n        for i in range(1, len(S) + 1):\\n            if S[i-1] == \\'D\\':\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[j:i])\\n            else:\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[:j])\\n            dp, dp2 = dp2, dp\\n            \\n        return sum(dp) % 1000000007\\n```\\n\\t\\t\\n\\t\\t\\nThis solution is O(n^3)\\nInstead of having to use sum() each inner loop, you can calculate prefix/suffix sums in order to bring the runtime down to O(n^2)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for c in range(len(S)+1)]\\n        dp2 = [0 for c in range(len(S)+1)]\\n        \\n        for i in range(1, len(S) + 1):\\n            if S[i-1] == \\'D\\':\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[j:i])\\n            else:\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[:j])\\n            dp, dp2 = dp2, dp\\n            \\n        return sum(dp) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246618,
                "title": "why-backtracking-memoization-is-working",
                "content": "To all Coders of the Leetcode Community this post needs to be addressed \\nwhy this solution is working ??\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int n;\\n    \\n    vector<int> vis;\\n    \\n    int dp[202][202];\\n    \\n    long long func(int i,int j,string &s){\\n        if(i == n) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        long long ans=0;\\n        if(s[i] == \\'D\\'){\\n            \\n            for(int k=j-1;k>=0;k--){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }\\n            }\\n        }else{\\n            for(int k=j+1;k<=n;k++){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[i][j] = ans;\\n        \\n    }\\n    \\n    int numPermsDISequence(string s) {\\n        \\n        n = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vis = vector<int> (n+1,false);\\n        \\n        long long ans = 0;\\n        for(int i=0;i<=n;i++){\\n            vis[i] = true;\\n            long long tmp = func(0,i,s);\\n            ans += tmp;\\n            ans%=mod;\\n            vis[i] = false;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int n;\\n    \\n    vector<int> vis;\\n    \\n    int dp[202][202];\\n    \\n    long long func(int i,int j,string &s){\\n        if(i == n) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        long long ans=0;\\n        if(s[i] == \\'D\\'){\\n            \\n            for(int k=j-1;k>=0;k--){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1285921,
                "title": "c-memoization-backtracking-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[201];\\n    long long int dp[202][202];\\n    int mod=1000000007;\\n    int util(string &s,int index,int prev){\\n        if(index==s.size()) return 1;\\n        \\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        \\n        long long int cnt=0;\\n        if(s[index]==\\'D\\'){\\n           for(int i=0;i<prev;i++){\\n               if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                     vis[i]=0;\\n               }\\n           } \\n        }\\n        else{\\n            for(int i=prev+1;i<=s.size();i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        long long int cnt=0;\\n         memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=s.size();i++){\\n            vis[i]=1;\\n            cnt+=(util(s,0,i))%mod;\\n            vis[i]=0;\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[201];\\n    long long int dp[202][202];\\n    int mod=1000000007;\\n    int util(string &s,int index,int prev){\\n        if(index==s.size()) return 1;\\n        \\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        \\n        long long int cnt=0;\\n        if(s[index]==\\'D\\'){\\n           for(int i=0;i<prev;i++){\\n               if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                     vis[i]=0;\\n               }\\n           } \\n        }\\n        else{\\n            for(int i=prev+1;i<=s.size();i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        long long int cnt=0;\\n         memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=s.size();i++){\\n            vis[i]=1;\\n            cnt+=(util(s,0,i))%mod;\\n            vis[i]=0;\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251715,
                "title": "c-soln-backtracking-dp",
                "content": "```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[201][202];\\n    int sol(string &s, int ind, int prev){\\n        if(ind==s.length()+1){return 1;}\\n        if(dp[ind][prev+1]!=-1)return dp[ind][prev+1];\\n        long ans=0;\\n        for(int i=0;i<=s.length();i++){\\n            if(vis[i]!=0)continue;\\n            if(prev!=-1){\\n                if(s[ind-1]==\\'D\\'){\\n                    if(i>prev)break;\\n                    vis[i]=1;\\n                    ans+=sol(s,ind+1,i);\\n                    vis[i]=0;\\n                }\\n                else{\\n                    if(i<prev)continue;\\n                    vis[i]=1;\\n                    ans+=sol(s, ind+1,i);\\n                    vis[i]=0;\\n                }\\n            }\\n            else {\\n                vis[i]=1;\\n                ans+=sol(s, ind+1, i);\\n                vis[i]=0;\\n            }\\n            \\n        }\\n        return dp[ind][prev+1]=ans%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        vis.resize(s.length()+1,0);\\n        return sol(s,0,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[201][202];\\n    int sol(string &s, int ind, int prev){\\n        if(ind==s.length()+1){return 1;}\\n        if(dp[ind][prev+1]!=-1)return dp[ind][prev+1];\\n        long ans=0;\\n        for(int i=0;i<=s.length();i++){\\n            if(vis[i]!=0)continue;\\n            if(prev!=-1){\\n                if(s[ind-1]==\\'D\\'){\\n                    if(i>prev)break;\\n                    vis[i]=1;\\n                    ans+=sol(s,ind+1,i);\\n                    vis[i]=0;\\n                }\\n                else{\\n                    if(i<prev)continue;\\n                    vis[i]=1;\\n                    ans+=sol(s, ind+1,i);\\n                    vis[i]=0;\\n                }\\n            }\\n            else {\\n                vis[i]=1;\\n                ans+=sol(s, ind+1, i);\\n                vis[i]=0;\\n            }\\n            \\n        }\\n        return dp[ind][prev+1]=ans%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        vis.resize(s.length()+1,0);\\n        return sol(s,0,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877923,
                "title": "dp-o-n-2-space-o-n-with-intuitive-walkthrough-about-how-to-derive-it",
                "content": "Knowing that we only have to figure out how many permutaitons there are, I stopped thinking about index orders, and instead thought about paths.\\n\\nConceptually, with D alone there\\'s only one path.\\n\\n```\\n *   \\n  \\\\\\n   * (ending)\\n ```\\n \\n If we do DI, then the up path can end either between the existing two nodes, or at the top:\\n\\n```\\n0:      * (ending)\\n1: *   /\\n    \\\\ /\\n2:   *\\n\\n0: *\\n1:  \\\\   *(ending)\\n     \\\\ /\\n2:    *\\n```\\n\\nThe way I began to represent this is the number of paths that END at a given index.\\nD: [0, 1]\\nDI: [1, 1, 0]\\n\\nNow, for DID, we should think about continuing the path that ends at index 0 and 1. Since it will have to go down from there, we\\'ll add an index and consider the number of places the current paths can go. When there are more than just 1 paths ending at an index, we\\'ll need to preserve the increasing possibilities, so I\\'m using variables instead of 1 to show how it should work.\\n\\n```\\n0: x |\\n1: y |\\n2: z |\\n3:   |  (add an index)\\n\\n// add x to all of the indices below it.\\n// add y to all of the indices below it.\\n// etc. for each index i from 1..n\\n// x = 1, y = 1, z = 0\\n0: x |\\n1: y | x\\n2: z | x y\\n3:   | x y z\\n\\n0: 1 |     -> 0\\n1: 1 | 1   -> 1\\n2: 0 | 1 1 -> 2\\n3:   | 1 1 -> 2\\n```\\n\\nSo DID = [0, 1, 2, 2] (The sum of these = 5)\\n\\nNow lets take it one step further for each direction to watch how it evolves:\\n\\n```\\nDIDD:\\n0: 0 |       -> 0\\n1: 1 |       -> 0\\n2: 2 | 1     -> 1\\n3: 2 | 1 2   -> 3\\n4:   | 1 2 2 -> 5\\n\\nDIDI:\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n```\\n\\nFor increasing the end paths, we have to first imagine shifting all of the indices up (down visually in my ascii art) by one and inserting a new index at 0 => [0 0 1 2 2]. Then accumulating each index to the indices before it. However, we don\\'t actually have shift all the data, we can just modify where we read the array from. That\\'s why it\\'s depicted above as adding the number of ending paths to all of the rows ABOVE OR EQUAL to that index.\\n\\nNow, at this point, we can look for patterns.\\nOne thing I spotted was this:\\n```\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n-------------------\\n       2*4 +\\n\\t     2*3 +\\n\\t\\t   1*2 +\\n\\t\\t     0*1\\n```\\nWhich, does give us the answer, but alas isn\\'t that useful for determining the next incremental step.\\nSo instead looking at each row rather than each column, we can see that \"2 2 1\" from the previous array is present, at index 0 and 1.\\nAnd it\\'s essentially a running sum from back to front.\\n\\nSo now we can translate that into an algorithm to compute each index:\\nSo, for the case of \"I\":\\n\\nassuming we index into the string with k, S[k] == \"I\":\\nn = k+1\\n\\n\\t// sum from n-1 to 0\\n\\t// writing from n-1 to 0\\n\\tdp[n] = 0;\\n\\tfor (int i = n-1; i >= 0; i--) {\\n\\t\\tdp[i] = (dp[i+1] + dp[i]) % m;\\n\\t}\\n\\nNow lets look at D again:\\n\\n    DIDD:\\n\\t0: 0 |       -> 0\\n\\t1: 1 |       -> 0\\n\\t2: 2 | 1     -> 1\\n\\t3: 2 | 2 1   -> 3\\n\\t4:   | 2 2 1 -> 5\\n\\nIndex 4 shows [2 2 1], and index 3 shows [2 1], so spotting the pattern, just like in the increasing case, we can accumulate the values from the previous step and store them, but this time we need to iterate through the array in the forwards direction when accumulating.\\n                \\n\\t// sum from 0 to n-1\\n\\t// writing from 1 to n\\n\\t//sum = dp[0];\\n\\tint saved  = dp[0];\\n\\tdp[0] = 0;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tint t = dp[i];\\n\\t\\tdp[i] = (dp[i-1] + saved) % m;\\n\\t\\tsaved = t;\\n\\t}\\n\\nI\\'m having to use some temporary values so I can modify the same array, since we need to iterate through it forward and shift it at the same time.\\n\\nHere\\'s the full solution:\\n\\n    int numPermsDISequence(string s) {\\n        int m = 1000000007;\\n        // make the buffer:\\n        int dp[s.size()+1];\\n        dp[0] = 1;\\n        \\n        int sum = 0;\\n        for (int k = 0; k < s.size(); k++) {\\n            int n = k+1;\\n            if (s[k] == \\'D\\') {\\n                // sum from 0 to n-1\\n                // writing to 1 to n\\n                //sum = dp[0];\\n                int saved  = dp[0];\\n                dp[0] = 0;\\n                for (int i = 1; i <= n; i++) {\\n                    int t = dp[i];\\n                    dp[i] = (dp[i-1] + saved) % m;\\n                    saved = t;\\n                }\\n            } else {\\n                // sum from n-1 to 0\\n                // writing from n-1 to 0\\n                dp[n] = 0;\\n                for (int i = n-1; i >= 0; i--) {\\n                    dp[i] = (dp[i+1] + dp[i]) % m;\\n                }\\n            }\\n        }\\n        sum = 0;\\n        for (int i = 0; i <= s.size(); i++) {\\n            sum = (sum + dp[i]) % m;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n *   \\n  \\\\\\n   * (ending)\\n ```\n```\\n0:      * (ending)\\n1: *   /\\n    \\\\ /\\n2:   *\\n\\n0: *\\n1:  \\\\   *(ending)\\n     \\\\ /\\n2:    *\\n```\n```\\n0: x |\\n1: y |\\n2: z |\\n3:   |  (add an index)\\n\\n// add x to all of the indices below it.\\n// add y to all of the indices below it.\\n// etc. for each index i from 1..n\\n// x = 1, y = 1, z = 0\\n0: x |\\n1: y | x\\n2: z | x y\\n3:   | x y z\\n\\n0: 1 |     -> 0\\n1: 1 | 1   -> 1\\n2: 0 | 1 1 -> 2\\n3:   | 1 1 -> 2\\n```\n```\\nDIDD:\\n0: 0 |       -> 0\\n1: 1 |       -> 0\\n2: 2 | 1     -> 1\\n3: 2 | 1 2   -> 3\\n4:   | 1 2 2 -> 5\\n\\nDIDI:\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n```\n```\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n-------------------\\n       2*4 +\\n\\t     2*3 +\\n\\t\\t   1*2 +\\n\\t\\t     0*1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 652054,
                "title": "java-dfs-with-memo",
                "content": "\\n```\\nclass Solution {\\n    private static int MOD = 1000000007;\\n    public int numPermsDISequence(String S) {\\n        int res = 0;\\n        Integer[][] dp = new Integer[S.length() + 1][S.length() + 1];\\n        \\n        for (int i = 0; i <= S.length(); i++) {\\n            res += dfs(i, S.length() - i, dp, S, 0);\\n            res = res % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int higher, int lower, Integer[][] dp, String S, int index) {\\n        if (index == S.length()) {\\n            return 1;\\n        }\\n        int d = S.charAt(index) == \\'D\\' ? 1 : 0;\\n        if (dp[higher][lower] != null) {\\n            return dp[higher][lower];\\n        }\\n        int count = 0;\\n        if (d == 1) {\\n            if (lower > 0) {\\n                for (int i = 0; i < lower; i++) {\\n                    count += dfs(higher + i, lower - (i + 1), dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        } else {\\n            if (higher > 0) {\\n                for (int i = 0; i < higher; i++) {\\n                    count += dfs(higher - (i + 1), lower + i, dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        }\\n        dp[higher][lower] = count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int MOD = 1000000007;\\n    public int numPermsDISequence(String S) {\\n        int res = 0;\\n        Integer[][] dp = new Integer[S.length() + 1][S.length() + 1];\\n        \\n        for (int i = 0; i <= S.length(); i++) {\\n            res += dfs(i, S.length() - i, dp, S, 0);\\n            res = res % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int higher, int lower, Integer[][] dp, String S, int index) {\\n        if (index == S.length()) {\\n            return 1;\\n        }\\n        int d = S.charAt(index) == \\'D\\' ? 1 : 0;\\n        if (dp[higher][lower] != null) {\\n            return dp[higher][lower];\\n        }\\n        int count = 0;\\n        if (d == 1) {\\n            if (lower > 0) {\\n                for (int i = 0; i < lower; i++) {\\n                    count += dfs(higher + i, lower - (i + 1), dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        } else {\\n            if (higher > 0) {\\n                for (int i = 0; i < higher; i++) {\\n                    count += dfs(higher - (i + 1), lower + i, dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        }\\n        dp[higher][lower] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606518,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long dp[][];\\n    public int numPermsDISequence(String s) {//i: string index   end: end with number end\\n        int len=s.length();\\n        long res=0;\\n        dp=new long[len+1][len+1];\\n        dp[0][0]=1;\\n        for(int i=1;i<=s.length();i++){\\n            char c=s.charAt(i-1);\\n            for(int end=0;end<=i;end++){\\n                long val=0;\\n                if(c==\\'D\\'){\\n                    for(int j=end;j<=i-1;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }else{\\n                    for(int j=0;j<end;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }\\n                dp[i][end]=val;\\n            }\\n        }\\n        for(int i=0;i<dp[0].length;i++){\\n            res+=dp[len][i];\\n            res%=mod;\\n        }\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long dp[][];\\n    public int numPermsDISequence(String s) {//i: string index   end: end with number end\\n        int len=s.length();\\n        long res=0;\\n        dp=new long[len+1][len+1];\\n        dp[0][0]=1;\\n        for(int i=1;i<=s.length();i++){\\n            char c=s.charAt(i-1);\\n            for(int end=0;end<=i;end++){\\n                long val=0;\\n                if(c==\\'D\\'){\\n                    for(int j=end;j<=i-1;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }else{\\n                    for(int j=0;j<end;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }\\n                dp[i][end]=val;\\n            }\\n        }\\n        for(int i=0;i<dp[0].length;i++){\\n            res+=dp[len][i];\\n            res%=mod;\\n        }\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289703,
                "title": "backtracking-to-dp-java-solution",
                "content": "**Idea**\\nWe will try all possibilities for all positions and backtracking when we can\\'t go further. `seen` maintains the visited numbers in per recursion tree branch.\\n\\n**Solution1** **TLE**\\n```\\nclass Solution {\\n    int[] seen = null;\\n    public int numPermsDISequence(String s) {\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount += numPerms(s, 0, i);\\n            seen[i] = 0;\\n        }\\n        return count;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Solution2** DP Memo for overlapping subproblems. `dp[j][p]` indicates number of permutations till `j`th char in `s` and for permutations ending with number `p` (`p` stands for parent in my recursion, since we are exploring the subtree rooted at `p` in the recursion call).\\n```\\nclass Solution {\\n    private static final int DIV = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % DIV + numPerms(s, 0, i) % DIV;\\n            seen[i] = 0;\\n        }\\n        return count % DIV;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i)  % DIV;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i) % DIV;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % DIV;\\n        return dp[j][p];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] seen = null;\\n    public int numPermsDISequence(String s) {\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount += numPerms(s, 0, i);\\n            seen[i] = 0;\\n        }\\n        return count;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private static final int DIV = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % DIV + numPerms(s, 0, i) % DIV;\\n            seen[i] = 0;\\n        }\\n        return count % DIV;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i)  % DIV;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i) % DIV;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % DIV;\\n        return dp[j][p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154540,
                "title": "memo-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int dp[201][201];\\n    int mod=1e9+7;\\n    int util(string &s,vector<int>&visited,int curr,int index,int n){\\n        if(index==s.length())\\n            return 1;\\n        if(dp[curr][index]!=-1)\\n            return dp[curr][index];\\n        int res=0;\\n        visited[curr]=true;\\n        if(s[index]==\\'I\\'){\\n            for(int i=curr+1;i<=n;i++)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }else{\\n            for(int i=curr-1;i>=0;i--)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }\\n        visited[curr]=false;\\n        return dp[curr][index]=res;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=s.length();\\n        vector<int>visited(n+1,false);\\n        int res=0;\\n        for(int i=0;i<=n;i++)\\n         res=(res+util(s,visited,i,0,n))%mod;\\n        return res;\\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int dp[201][201];\\n    int mod=1e9+7;\\n    int util(string &s,vector<int>&visited,int curr,int index,int n){\\n        if(index==s.length())\\n            return 1;\\n        if(dp[curr][index]!=-1)\\n            return dp[curr][index];\\n        int res=0;\\n        visited[curr]=true;\\n        if(s[index]==\\'I\\'){\\n            for(int i=curr+1;i<=n;i++)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3392399,
                "title": "backtracking-memoization-is-working-why",
                "content": "# Doubt\\n   Since to decide a unique state , we need:\\n\\n            1.index at which we are currently in string s\\n            2.previous element chosen\\n            3.set of numbers that are used or left.Here vis vector.\\n\\n   But i have done memoization over first two, but the soln is working.Can\\'t understand why??\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[202][202];\\n    ll mod=1e9+7;\\nint fun(int ind,int prev,int n,string&s, vector<bool>&vis)\\n{\\n    if(ind==s.size())\\n    {\\n        return 1;\\n    }\\n\\n     if(dp[ind][prev]!=-1) return dp[ind][prev];\\n    int ans=0;\\n    if(s[ind]==\\'D\\')\\n    {\\n       for(int i=prev-1;i>=0;i--)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n    else if(s[ind]==\\'I\\')\\n    {\\n        for(int i=prev+1;i<=n;i++)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n   return dp[ind][prev]=ans;\\n}\\n\\nint numPermsDISequence(string s) \\n{\\n    memset(dp,-1,sizeof(dp));\\n    ll n=s.size();\\n    vector<bool>vis(n+1,0);\\n    int ans=0;\\n    for(int i=0;i<=n;i++)\\n    {\\n        vis[i]=1;\\n        ans+=fun(0,i,n,s,vis);\\n        ans%=mod;\\n        vis[i]=0;\\n    }\\n    //cout<<\"ans=\"<<ans<<endl;\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[202][202];\\n    ll mod=1e9+7;\\nint fun(int ind,int prev,int n,string&s, vector<bool>&vis)\\n{\\n    if(ind==s.size())\\n    {\\n        return 1;\\n    }\\n\\n     if(dp[ind][prev]!=-1) return dp[ind][prev];\\n    int ans=0;\\n    if(s[ind]==\\'D\\')\\n    {\\n       for(int i=prev-1;i>=0;i--)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n    else if(s[ind]==\\'I\\')\\n    {\\n        for(int i=prev+1;i<=n;i++)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n   return dp[ind][prev]=ans;\\n}\\n\\nint numPermsDISequence(string s) \\n{\\n    memset(dp,-1,sizeof(dp));\\n    ll n=s.size();\\n    vector<bool>vis(n+1,0);\\n    int ans=0;\\n    for(int i=0;i<=n;i++)\\n    {\\n        vis[i]=1;\\n        ans+=fun(0,i,n,s,vis);\\n        ans%=mod;\\n        vis[i]=0;\\n    }\\n    //cout<<\"ans=\"<<ans<<endl;\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2781519,
                "title": "detailed-explanation-and-intuition",
                "content": "# Intuition\\n\\nThe possible lengths of `s`, and the fact that there\\'s a modulo involved, hints that were dealing with some sort of recursive function.\\n\\nIndeed, we have a very large number of alternatives for each step. For a 200 character string, there are 200 valid first choices to explore (some of which may later turn out to be invalid). Then, there\\'s potentially 199 choices, and so on, yielding $\\\\textrm{O}(n!)$.\\n\\nThis tells us that we need to memoize each step somehow. For memoization to work, we must describe the state in such a way that the state space isn\\'t too large.\\n\\nA naive first attempt at a state would be to store:\\n\\n1. $\\\\textrm{O}(n)$ - previously picked index\\n2. $\\\\textrm{O}(n)$ - remaining string length\\n3. $\\\\textrm{O}(n!)$ - set of remaining numbers\\n\\nClearly, (3) won\\'t work.\\n\\nAt this point when you\\'re stuck, it\\'s good to write down some different examples and look for clues. Try moving from a massive `n` to the next step, like `n = 100` to `n = 99`. Try to move from `n = 1` to `n = 0`. Try the other direction, i.e. to introduce a new number to the set.\\n\\nFor me, the breakthrough was when I imagined the last step of a long series of changes that started with `n = 100`. What possible numbers could be left in the set?\\n\\n$$\\n\\\\{ (0, 1), (0, 2), ..., (0, n) \\\\}\\\\\\\\\\n\\\\{ (1, 0), (1, 2), ..., (1, n) \\\\}\\\\\\\\\\n... \\\\\\\\\\n\\\\{ (n, 0), (n, 1), ..., (n, n-1) \\\\}\\\\\\\\\\n$$\\n\\nTo evaluate `\\'D\\'` or `\\'I\\'` with these pairs, it only mattered whether the pair was increasing or decreasing. In other words, we could reduce all these pairs to $(0, 1)$ or $(1, 0)$ and it would make no difference to the result.\\n\\nThis told me that the set could always contain the same numbers, i.e. from `0..n`. It was only the relative position of numbers that mattered.\\n\\n# Approach\\n\\nDue to the reasoning above, the set of possible choices is dependent only on the length of / position in `s` and the previously picked value `x`. This gives us a state space of $\\\\textrm{O}(n^2)$.\\n\\nOnce a valid current number is found, we pick it and continue evaluation. Since the set of numbers is reduced each turn, we must deduct 1 from number `y` when is larger than `x` (x is removed from the set).\\n\\nNote: it is trivial to change top-down to bottom-up, almost always at the expense of legibility. So I\\'ll stick with top-down here.\\n\\n# Complexity\\n\\n- Time complexity: $\\\\textrm{O}(n^2)$\\n- Space complexity: $\\\\textrm{O}(n^2)$\\n\\n# Code\\n\\n```go\\nconst mod = 1e9 + 7\\n\\nfunc numPermsDISequence(s string) int {\\n\\tvar res int\\n\\tn := len(s)\\n\\tmem := make([][]int, n+1)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, n+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tres = (res + numPerms(mem, s, i)) % mod\\n\\t}\\n\\treturn res\\n}\\n\\nfunc numPerms(mem [][]int, s string, x int) int {\\n\\tn := len(s)\\n\\tif mem[n][x] != -1 {\\n\\t\\treturn mem[n][x]\\n\\t}\\n\\tif len(s) == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tvar res int\\n\\tif s[0] == \\'I\\' {\\n\\t\\tfor y := x + 1; y <= n; y++ {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y-1)) % mod\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor y := x - 1; y >= 0; y-- {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y)) % mod\\n\\t\\t}\\n\\t}\\n\\tmem[n][x] = res\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nconst mod = 1e9 + 7\\n\\nfunc numPermsDISequence(s string) int {\\n\\tvar res int\\n\\tn := len(s)\\n\\tmem := make([][]int, n+1)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, n+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tres = (res + numPerms(mem, s, i)) % mod\\n\\t}\\n\\treturn res\\n}\\n\\nfunc numPerms(mem [][]int, s string, x int) int {\\n\\tn := len(s)\\n\\tif mem[n][x] != -1 {\\n\\t\\treturn mem[n][x]\\n\\t}\\n\\tif len(s) == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tvar res int\\n\\tif s[0] == \\'I\\' {\\n\\t\\tfor y := x + 1; y <= n; y++ {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y-1)) % mod\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor y := x - 1; y >= 0; y-- {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y)) % mod\\n\\t\\t}\\n\\t}\\n\\tmem[n][x] = res\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030781,
                "title": "python-dp-10-lines-of-code-detailed-comments",
                "content": "```\\ndef numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # len(dp) is the length of remaining unused set as remain_set\\n        # dp[i] means the last digit of any permutation formed by used set is remain_set[i]\\n        # so, initially, remain_set = [0, 1, ..,n]\\n        # dp[i] = 1\\n        # so, the remain_set for dp[i] is [0, 1,..,i-1, i+1..n]\\n        # Two edge cases:\\n        # remain_set for dp[0] becomes [1, 2,..,n]\\n        # remain_set for dp[n] becomes [0, 1, 2,..,n-1]\\n        # for the new remain_set, dp\\'s lenght becomes the length of new remain_set\\n        # let\\'s create a new dp1 which depends on s[0]\\n        # if s[0] is \\'I\\',\\n        # dp1[0] = dp[0] + dp[1]\\n        # dp1[i] = dp[0] + dp[1] + ..+ dp[i]\\n        # if s[0] is \\'D\\',\\n        # dp1[len(remain_set)-1 # n-1] = dp[n]\\n        # dp1[i] = dp[i+1] + dp[i+2] + ..+ dp[n]\\n        dp = [1] * (n+1)\\n        for c in s:\\n            dp1 = [0]*(len(dp)-1)\\n            if c == \"I\":\\n                for i in range(len(dp1)):\\n                    dp1[i] = sum(dp[:i+1])\\n            else:\\n                for i in range(len(dp1)-1, -1, -1):\\n                    dp1[i] = sum(dp[i+1:])\\n            dp = dp1\\n        return dp[0] % (10**9 + 7)",
                "solutionTags": [],
                "code": "```\\ndef numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # len(dp) is the length of remaining unused set as remain_set\\n        # dp[i] means the last digit of any permutation formed by used set is remain_set[i]\\n        # so, initially, remain_set = [0, 1, ..,n]\\n        # dp[i] = 1\\n        # so, the remain_set for dp[i] is [0, 1,..,i-1, i+1..n]\\n        # Two edge cases:\\n        # remain_set for dp[0] becomes [1, 2,..,n]\\n        # remain_set for dp[n] becomes [0, 1, 2,..,n-1]\\n        # for the new remain_set, dp\\'s lenght becomes the length of new remain_set\\n        # let\\'s create a new dp1 which depends on s[0]\\n        # if s[0] is \\'I\\',\\n        # dp1[0] = dp[0] + dp[1]\\n        # dp1[i] = dp[0] + dp[1] + ..+ dp[i]\\n        # if s[0] is \\'D\\',\\n        # dp1[len(remain_set)-1 # n-1] = dp[n]\\n        # dp1[i] = dp[i+1] + dp[i+2] + ..+ dp[n]\\n        dp = [1] * (n+1)\\n        for c in s:\\n            dp1 = [0]*(len(dp)-1)\\n            if c == \"I\":\\n                for i in range(len(dp1)):\\n                    dp1[i] = sum(dp[:i+1])\\n            else:\\n                for i in range(len(dp1)-1, -1, -1):\\n                    dp1[i] = sum(dp[i+1:])\\n            dp = dp1\\n        return dp[0] % (10**9 + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 4049287,
                "title": "explained-why-backtrack-memorization-working",
                "content": "why it works without explicitly saving the state of the visited array?\\n\\n\\nWhen we backtrack and return from a recursive call, we reset ```_ visited[curr] to false _``` which means that the state of visited is restored to what it was before the recursive call.\\n\\nThe memoization table dp is used to store and retrieve previously computed results for specific combinations of curr and index. This allows the algorithm to avoid redundant calculations and significantly improves its efficiency.\\n\\nIn summary, while the visited array is modified during the recursion, it is effectively reset to its original state when backtracking,``` _ thanks to the visited[curr] = false statement _ ``` \\nThe state of visited is managed correctly within the recursive calls, and the memoization table dp ensures that previously computed results are reused to avoid unnecessary computations. This is why the algorithm works correctly without explicitly saving the state of the visited array.\\n\\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    int n;\\n    int dp[203][203];\\n    int m=1e9+7;\\n    int solve(int idx,int prev, vector<int>&vis)\\n    {\\n        if(idx==n) return 1;        \\n        if(dp[idx+1][prev+1]!=-1) return dp[idx+1][prev+1];\\n        long long ans=0;\\n        if(idx==-1)\\n        {\\n            for(int i=0; i<=n; i++) \\n            {\\n                vis[i]=1;\\n                ans+=solve(0,i,vis)%m;\\n                ans%=m;\\n                vis[i]=0;\\n            }\\n        }else\\n        {\\n            for(int i=0; i<=n; i++)\\n            {\\n                if(vis[i]==0 )\\n                {\\n                    if(s[idx]==\\'D\\' &&i<prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }else if(s[idx]==\\'I\\' && i>prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[idx+1][prev+1]=(int)ans;\\n    }\\n    \\n    int numPermsDISequence(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        vector<int> vis(n+1,0);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(-1,-1,vis);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```_ visited[curr] to false _```\n``` _ thanks to the visited[curr] = false statement _ ```\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    int n;\\n    int dp[203][203];\\n    int m=1e9+7;\\n    int solve(int idx,int prev, vector<int>&vis)\\n    {\\n        if(idx==n) return 1;        \\n        if(dp[idx+1][prev+1]!=-1) return dp[idx+1][prev+1];\\n        long long ans=0;\\n        if(idx==-1)\\n        {\\n            for(int i=0; i<=n; i++) \\n            {\\n                vis[i]=1;\\n                ans+=solve(0,i,vis)%m;\\n                ans%=m;\\n                vis[i]=0;\\n            }\\n        }else\\n        {\\n            for(int i=0; i<=n; i++)\\n            {\\n                if(vis[i]==0 )\\n                {\\n                    if(s[idx]==\\'D\\' &&i<prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }else if(s[idx]==\\'I\\' && i>prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[idx+1][prev+1]=(int)ans;\\n    }\\n    \\n    int numPermsDISequence(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        vector<int> vis(n+1,0);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(-1,-1,vis);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649709,
                "title": "dp-solution",
                "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2333944,
                "title": "python-solution-tricky-question",
                "content": "```\\nclass Solution:\\n    # an implicit DP problem\\n    # For simplicity, let\\'s consider the sequence \"D\"\\n    # So we have the sequences [0,1] to permute\\n    # The valid permutation is [1,0]\\n    # Now let\\'s go to \"DI\", we add the number 2\\n    # and let\\'s separate the cases in which the sequence ends with different numbers\\n    # We see that 0 cannot be the end, because it cannot account for the I\\n    # We see that it can end with 1, by increasing every number larger than 1 by 1: [2, 0, 1]\\n    # We see the same applies for ending with 2: [1, 0, 2]\\n    # Now we consider the alternative \"DD\"\\n    # We see that we can get 0 to be the end by increasing all numbers larger or equal to 0 by 1: [2,1,0]\\n    # We cannot satisfy this for 1 and 2\\n    # Therefore, to solve the problem, we need to build the sequences from left to right\\n    # dp[i][j] = number of sequences that uses integers from [0,i] and ends with j\\n    # dp[0][0] = 1\\n    # If s = \"D\": dp[1][0] = dp[0][0] = 1; dp[1][1] = 0\\n    # If s = \"I\": dp[1][0] = 0; dp[1][1] = dp[0][0] = 1\\n    # If s = \"DI\": dp[2][0] = 0; dp[2][1] = dp[1][0] = 1; dp[2][2] = dp[1][0] + dp[1][1] = 1\\n    # If s = \"DD\": dp[2][0] = dp[1][0] + dp[1][1] = 1; dp[2][1] = dp[1][0] = 0; dp[2][2] = 0\\n    # If s = \"DID\": dp[3][0] = dp[2][0] + dp[2][1] + dp[2][2] = 0 + 1 + 1 = 2; dp[3][1] = dp[2][1] + dp[2][2] = 1 + 1 = 2; dp[3][2] =  dp[2][2] = 1; dp[3][3] = 0\\n    # As we see we should calculate prefix sum or suffix sums according to whether the current character is \"D\" or \"L\" respectively to facilitate calculations\\n    def numPermsDISequence(self, s: str) -> int:\\n        prev, MOD = [1], pow(10,9) + 7\\n        for i, c in enumerate(s):\\n            if c == \"D\":\\n                prefix = [0]*(i+2)\\n                for j in range(1,i+2,1):\\n                    prefix[j] = prefix[j-1] + prev[j-1]\\n                    prefix[j] %= MOD\\n                #print(\"prefix = \", prefix)\\n                nxt = [0]*(i+2)\\n                for j in range(i+1):\\n                    nxt[j] = prefix[i+1] - prefix[j]\\n            else:\\n                suffix = [0]*(i+2)\\n                for j in range(i,-1,-1):\\n                    suffix[j] = suffix[j+1] + prev[j]\\n                    suffix[j] %= MOD\\n                #print(\"suffix = \", suffix)\\n                nxt = [0]*(i+2)\\n                for j in range(1,i+2):\\n                    nxt[j] = suffix[0] - suffix[j]\\n            prev = nxt[:]\\n        return sum(prev) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # an implicit DP problem\\n    # For simplicity, let\\'s consider the sequence \"D\"\\n    # So we have the sequences [0,1] to permute\\n    # The valid permutation is [1,0]\\n    # Now let\\'s go to \"DI\", we add the number 2\\n    # and let\\'s separate the cases in which the sequence ends with different numbers\\n    # We see that 0 cannot be the end, because it cannot account for the I\\n    # We see that it can end with 1, by increasing every number larger than 1 by 1: [2, 0, 1]\\n    # We see the same applies for ending with 2: [1, 0, 2]\\n    # Now we consider the alternative \"DD\"\\n    # We see that we can get 0 to be the end by increasing all numbers larger or equal to 0 by 1: [2,1,0]\\n    # We cannot satisfy this for 1 and 2\\n    # Therefore, to solve the problem, we need to build the sequences from left to right\\n    # dp[i][j] = number of sequences that uses integers from [0,i] and ends with j\\n    # dp[0][0] = 1\\n    # If s = \"D\": dp[1][0] = dp[0][0] = 1; dp[1][1] = 0\\n    # If s = \"I\": dp[1][0] = 0; dp[1][1] = dp[0][0] = 1\\n    # If s = \"DI\": dp[2][0] = 0; dp[2][1] = dp[1][0] = 1; dp[2][2] = dp[1][0] + dp[1][1] = 1\\n    # If s = \"DD\": dp[2][0] = dp[1][0] + dp[1][1] = 1; dp[2][1] = dp[1][0] = 0; dp[2][2] = 0\\n    # If s = \"DID\": dp[3][0] = dp[2][0] + dp[2][1] + dp[2][2] = 0 + 1 + 1 = 2; dp[3][1] = dp[2][1] + dp[2][2] = 1 + 1 = 2; dp[3][2] =  dp[2][2] = 1; dp[3][3] = 0\\n    # As we see we should calculate prefix sum or suffix sums according to whether the current character is \"D\" or \"L\" respectively to facilitate calculations\\n    def numPermsDISequence(self, s: str) -> int:\\n        prev, MOD = [1], pow(10,9) + 7\\n        for i, c in enumerate(s):\\n            if c == \"D\":\\n                prefix = [0]*(i+2)\\n                for j in range(1,i+2,1):\\n                    prefix[j] = prefix[j-1] + prev[j-1]\\n                    prefix[j] %= MOD\\n                #print(\"prefix = \", prefix)\\n                nxt = [0]*(i+2)\\n                for j in range(i+1):\\n                    nxt[j] = prefix[i+1] - prefix[j]\\n            else:\\n                suffix = [0]*(i+2)\\n                for j in range(i,-1,-1):\\n                    suffix[j] = suffix[j+1] + prev[j]\\n                    suffix[j] %= MOD\\n                #print(\"suffix = \", suffix)\\n                nxt = [0]*(i+2)\\n                for j in range(1,i+2):\\n                    nxt[j] = suffix[0] - suffix[j]\\n            prev = nxt[:]\\n        return sum(prev) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293851,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880241,
                "title": "c-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dfs(vector<vector<int>> &dp,vector<bool> &vis,string &s,int in,int n,int last){\\n        if(in>=s.size()) return 1;\\n        if(dp[in][last]!=-1) return dp[in][last];\\n        if(s[in]==\\'D\\'){  \\n            long re = 0;\\n            for(int i = 0; i<last; ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n        else{\\n            long re = 0;\\n            for(int i = last+1; i<=s.size(); ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n    }\\n    int numPermsDISequence(string s) {\\n        int n = s.size(), i = 0; \\n        long re = 0;\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,0);\\n        \\n        if(s[0]==\\'D\\') i++; \\n        for(;i<=n;i++){\\n            vis[i] = 1;\\n            re = (re + dfs(dp,vis,s,0,n,i))%mod;\\n            vis[i] = 0;\\n        }\\n        return (int)re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dfs(vector<vector<int>> &dp,vector<bool> &vis,string &s,int in,int n,int last){\\n        if(in>=s.size()) return 1;\\n        if(dp[in][last]!=-1) return dp[in][last];\\n        if(s[in]==\\'D\\'){  \\n            long re = 0;\\n            for(int i = 0; i<last; ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n        else{\\n            long re = 0;\\n            for(int i = last+1; i<=s.size(); ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n    }\\n    int numPermsDISequence(string s) {\\n        int n = s.size(), i = 0; \\n        long re = 0;\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,0);\\n        \\n        if(s[0]==\\'D\\') i++; \\n        for(;i<=n;i++){\\n            vis[i] = 1;\\n            re = (re + dfs(dp,vis,s,0,n,i))%mod;\\n            vis[i] = 0;\\n        }\\n        return (int)re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261833,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        \\n        @cache \\n        def fn(i, x): \\n            \"\"\"Return number of valid permutation given x numbers smaller than previous one.\"\"\"\\n            if i == len(s): return 1 \\n            if s[i] == \"D\": \\n                if x == 0: return 0 # cannot decrease\\n                return fn(i, x-1) + fn(i+1, x-1)\\n            else: \\n                if x == len(s)-i: return 0 # cannot increase \\n                return fn(i, x+1) + fn(i+1, x)\\n        \\n        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        \\n        @cache \\n        def fn(i, x): \\n            \"\"\"Return number of valid permutation given x numbers smaller than previous one.\"\"\"\\n            if i == len(s): return 1 \\n            if s[i] == \"D\": \\n                if x == 0: return 0 # cannot decrease\\n                return fn(i, x-1) + fn(i+1, x-1)\\n            else: \\n                if x == len(s)-i: return 0 # cannot increase \\n                return fn(i, x+1) + fn(i+1, x)\\n        \\n        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645163,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++){\\n            dp[0][j] = 1;\\n        } \\n        for (int i = 0; i < n; i++){\\n            if (S[i] == \\'I\\'){\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            } else {\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;   \\n            }\\n        }  \\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++){\\n            dp[0][j] = 1;\\n        } \\n        for (int i = 0; i < n; i++){\\n            if (S[i] == \\'I\\'){\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            } else {\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;   \\n            }\\n        }  \\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490123,
                "title": "c-dp-100-100",
                "content": "I highly doubt if this is a real interview question or merely from contest, which adopts ideas/techniques in some fields. \\n \\nThe main challege to apply DP is the state space is too large, if remembering which numbers have been assigned. This challenge can be overcomed by using ranking. For people with background in discrete and combinatorics math, the idea is rather common. \\n\\nAlso, this problem requires some modeling technique commonly seen in optimal control/operations research. Dynamic programming models typically requires defining state and actions associated with the state. One can solve a DP model as a sequence of action choosing problems for each state. Another way is to regard state and action pair as a whole, and solve the DP by searching for the next state-and-actoin. As for which approach to take, it depends on specific problems. For this question, the latter one is more straightforward. \\n\\nTherefore, it is not a fair problem and should not be used in real interview. \\n\\n```\\n    int numPermsDISequence(string S) {\\n        const int M = 1e9 + 7, n = S.length(); \\n        vector<int> curr(n + 1, 1), next(n + 1, 0);\\n        for (int t = 0; t < n; ++t) {\\n            char c = S[t]; \\n            int sum = 0; \\n            if (c == \\'D\\') {\\n                for (int i = n - t - 1; i >=0; --i) {\\n                    sum = (curr[i + 1]%M + sum%M)%M;\\n                    next[i] = sum; \\n                }\\n            } else {\\n                for (int i = 0; i < n - t; ++i) {\\n                    sum = (curr[i]%M + sum%M)%M; \\n                    next[i] = sum;  \\n                }\\n            }\\n            swap(curr, next); \\n        } \\n        return curr.front(); \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numPermsDISequence(string S) {\\n        const int M = 1e9 + 7, n = S.length(); \\n        vector<int> curr(n + 1, 1), next(n + 1, 0);\\n        for (int t = 0; t < n; ++t) {\\n            char c = S[t]; \\n            int sum = 0; \\n            if (c == \\'D\\') {\\n                for (int i = n - t - 1; i >=0; --i) {\\n                    sum = (curr[i + 1]%M + sum%M)%M;\\n                    next[i] = sum; \\n                }\\n            } else {\\n                for (int i = 0; i < n - t; ++i) {\\n                    sum = (curr[i]%M + sum%M)%M; \\n                    next[i] = sum;  \\n                }\\n            }\\n            swap(curr, next); \\n        } \\n        return curr.front(); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482430,
                "title": "java-dfs-with-memo",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\t\\tint MOD = (int)1e9 + 7;\\n\\t\\tpublic int numPermsDISequence(String s) {\\n\\t\\t\\tif (s == null || s.length() == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tSet<Integer> hashSet = new HashSet<>();\\n\\t\\t\\tfor (int i = 0; i <= s.length(); i++) {\\n\\t\\t\\t\\thashSet.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong result = helper(s, 0, hashSet, null, null, new boolean[s.length() + 1][s.length() + 1], new long[s.length() + 1][s.length() + 1]);\\n\\t\\t\\tSystem.out.println(result);\\n\\t\\t\\treturn (int)(result % MOD);\\n\\t\\t}\\n\\n\\t\\tpublic long helper(String s, int startIndex, Set<Integer> hashSet, Integer lastNumber, Integer relativeIndex, boolean[][] visited, long[][] dp) {\\n\\t\\t\\tif (startIndex == s.length() + 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (relativeIndex != null && visited[startIndex][relativeIndex]) {\\n\\t\\t\\t\\treturn dp[startIndex][relativeIndex];\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong result = 0;\\n\\t\\t\\tint index = -1;\\n\\t\\t\\tPriorityQueue<Integer> pQueue = new PriorityQueue<Integer>(hashSet); \\n\\t\\t\\tfor (int i : pQueue) {\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\tif (startIndex != 0 && ((s.charAt(startIndex - 1) == \\'D\\' && i > lastNumber) || \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(s.charAt(startIndex - 1) == \\'I\\' && i < lastNumber))) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thashSet.remove(i);\\n\\t\\t\\t\\tresult += helper(s, startIndex + 1, hashSet, i, index, visited, dp);\\n\\t\\t\\t\\tresult %= MOD;\\n\\t\\t\\t\\thashSet.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (relativeIndex != null) {\\n\\t\\t\\t\\tvisited[startIndex][relativeIndex] = true;\\n\\t\\t\\t\\tdp[startIndex][relativeIndex] = result;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\'\\'\\'\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint MOD = (int)1e9 + 7;\\n\\t\\tpublic int numPermsDISequence(String s) {\\n\\t\\t\\tif (s == null || s.length() == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 257525,
                "title": "java-solution",
                "content": "```\\n    public int numPermsDISequence(String S) {\\n        int len = S.length(), N = len + 1, mod = 1000000007;\\n        int[][] dp = new int[N+1][N];\\n        \\n        for(int i = 0; i < N; i++) dp[1][i] = 1;\\n        \\n        for(int i = 1; i <= len; i++) {\\n            if(S.charAt(i-1) == \\'D\\') for(int j = N - i -1; j >= 0; j--) dp[i+1][j] = (dp[i+1][j+1] + dp[i][j+1])%mod;\\n            else  for(int j = 0; j <= N - i-1; j++) dp[i+1][j] = ((j > 0 ? dp[i+1][j-1] : 0) + dp[i][j])%mod;\\n        }\\n        \\n        return dp[N][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numPermsDISequence(String S) {\\n        int len = S.length(), N = len + 1, mod = 1000000007;\\n        int[][] dp = new int[N+1][N];\\n        \\n        for(int i = 0; i < N; i++) dp[1][i] = 1;\\n        \\n        for(int i = 1; i <= len; i++) {\\n            if(S.charAt(i-1) == \\'D\\') for(int j = N - i -1; j >= 0; j--) dp[i+1][j] = (dp[i+1][j+1] + dp[i][j+1])%mod;\\n            else  for(int j = 0; j <= N - i-1; j++) dp[i+1][j] = ((j > 0 ? dp[i+1][j-1] : 0) + dp[i][j])%mod;\\n        }\\n        \\n        return dp[N][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085333,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852423,
                "title": "editorial-like-solution-simple-to-understand-with-multiple-approaches-from-brute-force-to-optimal",
                "content": "The problem asks what is the number of valid permutations that follow a string of `\"DI\"` instructions, if a number `i` is used in a podition with `\\'D\\'` the next number must be in the range `0 <= j < i`, likewise if it\\'s in an `\\'I\\'` position the next number must be `i < j <= n` where `n` is the length if the string provided, the hard part comes in that we cannot repeat the same number, so it seems (but turns out not to be the case) that we need to remember all the previous numbers to solve the problem, let\\'s see how we might develop a solution.\\n\\n\\n# Approach #1: Brute-Force\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing that is recommended to be done in a complex problem like this one is to generate all possible solutions and discard the invalid ones, that can be done via backtracking, we define a helper function `backTrack` that keeps track of where in the string we are and what was the previous number used, and define a set `state` that contains all numbers previously used; at a given index position `i` we check for all numbers bigger/smaller than the previous number, if we can insert it into the permutation we add it to the stack, we we are done generating all it\\'s sub-solutions we remove it from the set, (this can also be done with a stack, which may be faster).\\nIf we reach `i == n` we finished generating a permutation and add `1` to our count (which I named `ans`).\\n\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a set/stack and a counter\\n2. Define the `backTrack` function:\\n2.1 If we reached the end, increase the counter\\n2.2 If not, go through all numbers lower/higher than the previous number and check if they can be added, if yes then add the number tot the set, call `backTrack` with `i+1` and this added number, when the function returns, remove the number from the set\\n3. Call `backTrack` for all possible starting number `0` to `n`\\n\\n# Complexity\\n- Time complexity: $$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAt any index `i` we have `i` options to choose from in worst-case, since `n` can go up to `200` this will result in a TLE.\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use a set/stack that will contain at most `n` numbers when a permutation is complete\\n\\n# Implementation (only python, sorry)\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        ans = [0]\\n        state = set()\\n        def backTrack(i, p):\\n            if i == n:\\n                ans[0] += 1\\n                return\\n            if s[i] == \"I\":\\n                for j in range(p+1, n+1):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            else:\\n                for j in range(0, p):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            return  \\n        for i in range(n+1):\\n            state.add(i)\\n            backTrack(0, i)\\n            state.remove(i)\\n        return ans[0]%(10**9+7)\\n```\\n\\n# Approach #2: Dynamic programming\\n\\n# Intuition\\nThe previous solution was too slow to be accepted, we need to find a faster way to calculate the answer. We first note that we got asked the number of valid permutations, so maybe (for this problem to be possible, we definitely) we don\\'t need to generate all possible permutations to know how many there are, usually we can break down a problem into sub-problems to generate an answer faster from solving sub-problems\\nAt first it may look like this is impossible to do here, since at each index the number we choose will affect all the possible choices in the future, but remembering we only need to know the quantity we may wonder if maybe the quantities are not dependent directly on the number you choose to place, let\\'s do a thought experiment, imagine instead of using the numbers `(1,2,3,4, ...)` to generate our permutatons we use `(1,1,1,1, ...)` only a bunch of ones, and when we use a number like `3` the whole thing turns into `(1,1,0,1, ...)` so we have a certain concept of \"order\" so that the problem is the same, now think about using `1` or `2` or `3`, in a given index `i` we would get accordingly `(0,1,1,1), (1,0,1,1), (1,1,0,1)` which are different, but look very similar! Why they all look so similar? because they all have the same idea of **relative ordering**, `1` is still smaller than `3` and `4` even when 2 is out of the equation and likewise for all the others, so if we only focus on the relative ordering of the numbers essentially all of the three sub-problems above are **identical**, so we can just represent them all as `(1,1,1)`.\\nThis is still not the complete picture, we know that the `\"ID\"` will limit our choice of next number, so returning to the last example, if the digit is `\\'I\\'`, then in the case of choosing `1` we would have `(0,1,1,1)` and the next number could be any of the following ones, but if we chose `2` the the sub-problem is `(1,0,1,1)` and we can only choose as the next number the ones to the right of the new zero, likewise if it were a `\\'D\\'` it would be the ones to the left of the zero, with that in mind we can now define our dynamic programming sub-problem.\\n\\n`\\ndp[i][j] = Solution to sub-problem s[i:n], if we can choose only ones bounded to the j\\'th one\\n`\\n\\nBy bounded I mean that if `s[i]` is `\\'I\\'` we can choose the ones from the `j` one to the right-end and if it is a `\\'D\\'` we can choose the ones from `j` one to the left-end.\\nFor example `dp[2][3]` for the tuple `(1,1,1,1,1,1,1)` is the solution to the sub-string `s[2:n]` using at position `2` any one that is from the inclusive left/right (depending on `s[2]`) of the highlighted one in `(1,1,_1_,1,1)`, notice that the size of the tuple is smaller by 2 than the original because we zero\\'ed two other ones in the original tuple, in general, if the original tuple is of size `n`, at index `i` the tuple will have size `n-i`.\\n\\nNow that we have a table, let\\'s see how we can generate answers from sub-problems. The base case is very simple, `s[n-1]` is either `\\'I\\'` or `\\'D\\'` and the tuple is simply `(1,1)`, we can define the base cases as follows:\\n```\\nif s[n-1] == \\'I\\':\\n    #If we choose 1, then it is impossible to increase\\n    dp[n-1][0] = 1\\n    dp[n-1][1] = 0\\nelif s[n-1] == \\'D:\\n    #If we choose 0, then it is impossible to decrease\\n    dp[n-1][0] = 0\\n    dp[n-1][1] = 1\\n```\\nThis idea of choosing the highest number or the lowest, makes it impossible to continue will keep re-occurring in later cases too.\\nFor an index `i < n-1` we know that if `s[i] == \\'I\\'` then the last number will have an answer of zero, if `s[i] == \\'D\\'` then the first number will have an answer of zero, in general `dp[i][j]\\n` will have all the answers that were pre-calculated in that row `i` (from the definition of the dp) and will also contain all the possible answers of the sub-problem at the `i+1` using only one to the left/right of it, which in our table happens that answer turns out to be stored in `dp[i+1][j]` (you can convince yourself of that by imagining how removing a one from a tuple changes the absolute postion of each remaining one), so our final update step looks like this.\\n\\n```\\nif s[n-1] == \\'I\\':\\n    if i == n-1:\\n        #If we choose 1, then it is impossible to increase\\n        dp[n-1][0] = 1\\n        dp[n-1][1] = 0\\n    else:\\n        if j == n-i:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j+1] + dp[i+1][j]\\nelif s[n-1] == \\'D:\\n    if i == n-1:\\n        #If we choose 0, then it is impossible to decrease\\n        dp[n-1][0] = 0\\n        dp[n-1][1] = 1\\n    else:\\n        if j == 0:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j-1] + dp[i+1][j]\\n```\\nPhew! That\\'s a pretty complicated update step, make sure you understand it, before writing it down because later on it will get worse! Now at last all that\\'s left to do is to write down the solution\\n\\n# Algorithm\\n1. Define our table `dp`\\n2. Go from the base case to the original case\\n3. Update the table according to the update step\\n4. return the `sum` of all possible start choices\\n\\n# Implementation (only python, sorry)\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[None for j in range(n-i+1)] for i in range(n)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[j][0] = 1\\n                    dp[j][1] = 0\\n                else:\\n                    dp[j][n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[j][i] = dp[j+1][i]+dp[j][i+1]\\n            else:\\n                if j == n-1:\\n                    dp[j][0] = 0\\n                    dp[j][1] = 1\\n                else:\\n                    dp[j][0] = 0\\n                    for i in range(1, n-j+1):\\n                        dp[j][i] = dp[j+1][i-1]+dp[j][i-1]\\n        return sum([dp[0][i] for i in range(n+1)])%(10**9+7)\\n```\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt only takes $O(1)$ to calculate the update step, we have `n + n-1 + n-2 + ... ` entries in the table, so $n^2$ time to compute every entry.\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe table has size $n^2$\\n\\n# Approach 3 DP + Double buffer\\n\\nWe notice that the update step only makes use of the last computed row and the current row being computed, so we can use two arrays and to calculate the whole ordeal, the space complexity will then be $O(n)$\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = None\\n        for j in range(n-1, 0-1, -1):\\n            ndp = [None for i in range(n-j+1)]\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    ndp[0] = 1\\n                    ndp[1] = 0\\n                else:\\n                    ndp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        ndp[i] = dp[i]+ndp[i+1]\\n            else:\\n                if j == n-1:\\n                    ndp[0] = 0\\n                    ndp[1] = 1\\n                else:\\n                    ndp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        ndp[i] = dp[i-1]+ndp[i-1]\\n            dp = ndp\\n        return sum(dp)%(10**9+7)\\n```\\n\\n# Approach 4 Optimized memory\\n\\nWe can make a solution with only one array, first notice that the update step of `\\'I\\'` is fairly easy to adapt to one array since the base case is in a completely new index, but in the `\\'D` case we need to update `i=0` so we set a variable `last` to remember the last value removed, but we need the last variable to update the next entry so we define an `nlast` to remember the variable that is about to be updated so that we can then update last with the  value that was before the update, whew... (see the code, it\\'s easier to understand)\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0 for _ in range(n+1)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[0] = 1\\n                    dp[1] = 0\\n                else:\\n                    dp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[i] = dp[i]+dp[i+1]\\n            else:\\n                if j == n-1:\\n                    dp[0] = 0\\n                    dp[1] = 1\\n                else:\\n                    last = dp[0]\\n                    dp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        nlast = dp[i]\\n                        dp[i] = last+dp[i-1]\\n                        last = nlast\\n        return sum(dp)%(10**9+7)\\n```\\n\\nAny comments or improvements are appreciated, thank you for reading!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        ans = [0]\\n        state = set()\\n        def backTrack(i, p):\\n            if i == n:\\n                ans[0] += 1\\n                return\\n            if s[i] == \"I\":\\n                for j in range(p+1, n+1):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            else:\\n                for j in range(0, p):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            return  \\n        for i in range(n+1):\\n            state.add(i)\\n            backTrack(0, i)\\n            state.remove(i)\\n        return ans[0]%(10**9+7)\\n```\n```\\nif s[n-1] == \\'I\\':\\n    #If we choose 1, then it is impossible to increase\\n    dp[n-1][0] = 1\\n    dp[n-1][1] = 0\\nelif s[n-1] == \\'D:\\n    #If we choose 0, then it is impossible to decrease\\n    dp[n-1][0] = 0\\n    dp[n-1][1] = 1\\n```\n```\\nif s[n-1] == \\'I\\':\\n    if i == n-1:\\n        #If we choose 1, then it is impossible to increase\\n        dp[n-1][0] = 1\\n        dp[n-1][1] = 0\\n    else:\\n        if j == n-i:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j+1] + dp[i+1][j]\\nelif s[n-1] == \\'D:\\n    if i == n-1:\\n        #If we choose 0, then it is impossible to decrease\\n        dp[n-1][0] = 0\\n        dp[n-1][1] = 1\\n    else:\\n        if j == 0:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j-1] + dp[i+1][j]\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[None for j in range(n-i+1)] for i in range(n)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[j][0] = 1\\n                    dp[j][1] = 0\\n                else:\\n                    dp[j][n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[j][i] = dp[j+1][i]+dp[j][i+1]\\n            else:\\n                if j == n-1:\\n                    dp[j][0] = 0\\n                    dp[j][1] = 1\\n                else:\\n                    dp[j][0] = 0\\n                    for i in range(1, n-j+1):\\n                        dp[j][i] = dp[j+1][i-1]+dp[j][i-1]\\n        return sum([dp[0][i] for i in range(n+1)])%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = None\\n        for j in range(n-1, 0-1, -1):\\n            ndp = [None for i in range(n-j+1)]\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    ndp[0] = 1\\n                    ndp[1] = 0\\n                else:\\n                    ndp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        ndp[i] = dp[i]+ndp[i+1]\\n            else:\\n                if j == n-1:\\n                    ndp[0] = 0\\n                    ndp[1] = 1\\n                else:\\n                    ndp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        ndp[i] = dp[i-1]+ndp[i-1]\\n            dp = ndp\\n        return sum(dp)%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0 for _ in range(n+1)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[0] = 1\\n                    dp[1] = 0\\n                else:\\n                    dp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[i] = dp[i]+dp[i+1]\\n            else:\\n                if j == n-1:\\n                    dp[0] = 0\\n                    dp[1] = 1\\n                else:\\n                    last = dp[0]\\n                    dp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        nlast = dp[i]\\n                        dp[i] = last+dp[i-1]\\n                        last = nlast\\n        return sum(dp)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731618,
                "title": "simple-c-solution-dynamic-programming-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<int>&curr,vector<int>&visited,string &s,int &n,vector<vector<long long>>&dp){\\n    if(index>=s.length() && curr.size()==n+1)return 1;\\n    if(dp[index+1][prev+1]!=-1)return dp[index+1][prev+1];\\n    long long ans=0;\\n    if(index==-1){\\n        for(int i=0;i<=n;i++){\\n            curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n        }\\n    }\\n    else if(index!=-1){\\n        if(s[index]==\\'I\\'){\\n            int previous=prev;\\n            for(int i=previous+1;i<=n;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n        else if(s[index]==\\'D\\'){\\n            int previous=prev;\\n            for(int i=0;i<previous;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    return dp[index+1][prev+1]=ans%mod;\\n}\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n  vector<int>visited(s.length()+1,0);\\n  vector<int>curr;\\n  vector<vector<long long>>dp(202,vector<long long>(202,-1));\\n  long long fa=hope(-1,-1,curr,visited,s,n,dp)%mod;\\n  int answer=fa;\\n  return answer;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<int>&curr,vector<int>&visited,string &s,int &n,vector<vector<long long>>&dp){\\n    if(index>=s.length() && curr.size()==n+1)return 1;\\n    if(dp[index+1][prev+1]!=-1)return dp[index+1][prev+1];\\n    long long ans=0;\\n    if(index==-1){\\n        for(int i=0;i<=n;i++){\\n            curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n        }\\n    }\\n    else if(index!=-1){\\n        if(s[index]==\\'I\\'){\\n            int previous=prev;\\n            for(int i=previous+1;i<=n;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n        else if(s[index]==\\'D\\'){\\n            int previous=prev;\\n            for(int i=0;i<previous;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    return dp[index+1][prev+1]=ans%mod;\\n}\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n  vector<int>visited(s.length()+1,0);\\n  vector<int>curr;\\n  vector<vector<long long>>dp(202,vector<long long>(202,-1));\\n  long long fa=hope(-1,-1,curr,visited,s,n,dp)%mod;\\n  int answer=fa;\\n  return answer;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633737,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def numPermsDISequence(s: String): Int = {\\n      val n = s.length\\n      val dp = Array.ofDim[Int](n+2, 2)\\n      val mod = 1000000007\\n      dp(1)(0) = 1\\n      for (i <- 1 to n) \\n        if (s(i-1) == \\'I\\') for (j <- 0 to i) dp(j+1)(i%2) = (dp(j)((i+1)%2) + dp(j)(i%2)) % mod\\n        else for (j <- 0 to i) dp(j+1)(i%2) = ((dp(i)((i+1)%2) + mod - dp(j)((i+1)%2)) % mod + dp(j)(i%2)) % mod\\n      dp(n+1)(n%2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def numPermsDISequence(s: String): Int = {\\n      val n = s.length\\n      val dp = Array.ofDim[Int](n+2, 2)\\n      val mod = 1000000007\\n      dp(1)(0) = 1\\n      for (i <- 1 to n) \\n        if (s(i-1) == \\'I\\') for (j <- 0 to i) dp(j+1)(i%2) = (dp(j)((i+1)%2) + dp(j)(i%2)) % mod\\n        else for (j <- 0 to i) dp(j+1)(i%2) = ((dp(i)((i+1)%2) + mod - dp(j)((i+1)%2)) % mod + dp(j)(i%2)) % mod\\n      dp(n+1)(n%2)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3513915,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n        int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\"I\" + S, S):\\n            dp = list(accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic int numPermsDISequence(String s) {\\n\\t\\tint length = s.length();\\n\\t\\tint mod = 1000000007;\\n\\t\\tint[] dp1 = new int[length + 1];\\n\\t\\tint[] dp2 = new int[length];\\n\\t\\tfor (int j = 0; j <= length; j++) {\\n\\t\\t\\tdp1[j] = 1;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'I\\') {\\n\\t\\t\\t\\tfor (int j = 0, curr = 0; j < length - i; j++) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = length - i - 1, curr = 0; j >= 0; j--) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j + 1]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp1 = Arrays.copyOf(dp2, length);\\n\\t\\t}\\n\\t\\treturn dp1[0];\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n        int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n};\\n```\n```Python3 []\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\"I\" + S, S):\\n            dp = list(accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```\n```Java []\\nclass Solution {\\n\\tpublic int numPermsDISequence(String s) {\\n\\t\\tint length = s.length();\\n\\t\\tint mod = 1000000007;\\n\\t\\tint[] dp1 = new int[length + 1];\\n\\t\\tint[] dp2 = new int[length];\\n\\t\\tfor (int j = 0; j <= length; j++) {\\n\\t\\t\\tdp1[j] = 1;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'I\\') {\\n\\t\\t\\t\\tfor (int j = 0, curr = 0; j < length - i; j++) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = length - i - 1, curr = 0; j >= 0; j--) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j + 1]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp1 = Arrays.copyOf(dp2, length);\\n\\t\\t}\\n\\t\\treturn dp1[0];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466073,
                "title": "c-3ms-dp-top-down-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1));\\n        for(int i=0;i<=n;i++){\\n            dp[0][i]=1+i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=n-i;j++){\\n                long long ans=0;\\n                if(s[i-1]==\\'I\\'){\\n                    ans=dp[i-1][n+1-i]-dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                else{\\n                    ans+=1LL*dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                if(j>0) ans+=dp[i][j-1];\\n                ans%=mod;\\n                dp[i][j]=ans;\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1));\\n        for(int i=0;i<=n;i++){\\n            dp[0][i]=1+i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=n-i;j++){\\n                long long ans=0;\\n                if(s[i-1]==\\'I\\'){\\n                    ans=dp[i-1][n+1-i]-dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                else{\\n                    ans+=1LL*dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                if(j>0) ans+=dp[i][j-1];\\n                ans%=mod;\\n                dp[i][j]=ans;\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455905,
                "title": "o-n-2-dp-with-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- dp[j] in the i-th round memorizes the number of permutations ends with j for s[0:i].\\n\\n- When s[i] is \\'D\\', update the ndp[j] with sum(dp[j:i]), which increases each element larger than j by one in the prefix.\\n- When s[i] is \\'I\\', update ndp[j] with sum(dp[0:j-1]) while keeping the prefix.\\n- Make use of the sum of prefix to get any sum(dp[j:i]) in $$O(1)$$\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int numPermsDISequence(string s) {\\n      int n=s.size(),mod=1e9+7;\\n      vector<int> dp{1};\\n      for(int i=0;i<n;i++){\\n          vector<int> pre{0}; //pre[i]=sum(dp[0:i-1])\\n          int tmp=0;\\n          for(auto j:dp) pre.emplace_back((j+pre.back())%mod);\\n          vector<int> ndp;\\n          if(s[i]==\\'D\\') for(int j=0;j<=i+1;j++) ndp.emplace_back(pre.back()>pre[j]?pre.back()-pre[j]:pre.back()-(pre[j]-mod)); //sum(dp[j,i])\\n          else for(int j=0;j<=i+1;j++) ndp.emplace_back(pre[j]); //sum(dp[0],...,dp[j-1])\\n          dp=ndp;\\n      }\\n      int result=0;\\n      for(auto i:dp)  result=(result+i)%mod;\\n      return result;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numPermsDISequence(string s) {\\n      int n=s.size(),mod=1e9+7;\\n      vector<int> dp{1};\\n      for(int i=0;i<n;i++){\\n          vector<int> pre{0}; //pre[i]=sum(dp[0:i-1])\\n          int tmp=0;\\n          for(auto j:dp) pre.emplace_back((j+pre.back())%mod);\\n          vector<int> ndp;\\n          if(s[i]==\\'D\\') for(int j=0;j<=i+1;j++) ndp.emplace_back(pre.back()>pre[j]?pre.back()-pre[j]:pre.back()-(pre[j]-mod)); //sum(dp[j,i])\\n          else for(int j=0;j<=i+1;j++) ndp.emplace_back(pre[j]); //sum(dp[0],...,dp[j-1])\\n          dp=ndp;\\n      }\\n      int result=0;\\n      for(auto i:dp)  result=(result+i)%mod;\\n      return result;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228861,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        n, mod = len(s), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,val):\\n            if i == n:\\n                return 1\\n\\n            if s[i] == \"D\":\\n                if val == 0: return 0\\n                return dfs(i,val-1) + dfs(i+1,val-1)\\n\\n            if s[i] == \"I\":\\n                if val == n-i: return 0\\n                return dfs(i,val+1) + dfs(i+1,val)\\n\\n        return sum([dfs(0,j) for j in range(n+1)])%mod\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        n, mod = len(s), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,val):\\n            if i == n:\\n                return 1\\n\\n            if s[i] == \"D\":\\n                if val == 0: return 0\\n                return dfs(i,val-1) + dfs(i+1,val-1)\\n\\n            if s[i] == \"I\":\\n                if val == n-i: return 0\\n                return dfs(i,val+1) + dfs(i+1,val)\\n\\n        return sum([dfs(0,j) for j in range(n+1)])%mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200100,
                "title": "c-easy-solution-using-dp-backtraking-optimal-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O($$N*N*N$$)\\n\\n- Space complexity:O($$N*N$$)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    //TC=O(N*N*N)\\n    //SC=O(N*N)\\n    int find(int ind,int pre,string& s,int n,vector<bool>& vis,vector<vector<int>>& dp){\\n        if(ind==n){\\n            return 1;\\n        }\\n        if(dp[ind][pre+1]!=-1){\\n            return dp[ind][pre+1];\\n        }\\n        int way1=0,way2=0;\\n        if(pre==-1){\\n            for(int i=0;i<=n;i++){\\n                if(!vis[i]){\\n                    vis[i]=true;\\n                    way1=(way1+find(ind,i,s,n,vis,dp))%mod;\\n                    vis[i]=false;\\n                }\\n            }\\n            return way1%mod;\\n        }\\n        else{\\n            if(s[ind]==\\'D\\'){\\n                for(int i=0;i<=n;i++){\\n                    if(i<pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                            way1=(way1+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n                }\\n            }else{\\n                for(int i=0;i<=n;i++){\\n                    if(i>pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                           \\n                            way2=(way2+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return dp[ind][pre+1]=(way1+way2)%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,false);\\n        return find(0,-1,s,n,vis,dp);\\n    }\\n};\\n```\\n# AUTHOR:JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    //TC=O(N*N*N)\\n    //SC=O(N*N)\\n    int find(int ind,int pre,string& s,int n,vector<bool>& vis,vector<vector<int>>& dp){\\n        if(ind==n){\\n            return 1;\\n        }\\n        if(dp[ind][pre+1]!=-1){\\n            return dp[ind][pre+1];\\n        }\\n        int way1=0,way2=0;\\n        if(pre==-1){\\n            for(int i=0;i<=n;i++){\\n                if(!vis[i]){\\n                    vis[i]=true;\\n                    way1=(way1+find(ind,i,s,n,vis,dp))%mod;\\n                    vis[i]=false;\\n                }\\n            }\\n            return way1%mod;\\n        }\\n        else{\\n            if(s[ind]==\\'D\\'){\\n                for(int i=0;i<=n;i++){\\n                    if(i<pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                            way1=(way1+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n                }\\n            }else{\\n                for(int i=0;i<=n;i++){\\n                    if(i>pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                           \\n                            way2=(way2+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return dp[ind][pre+1]=(way1+way2)%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,false);\\n        return find(0,-1,s,n,vis,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177930,
                "title": "scala-clean-functional-dp",
                "content": "Let `dp[i][j]` be the number of permutations that `s[i:]` could form with the first number be the `j`th smallest candidate number.\\n\\nThen if `s[i] == \\'D\\'`, because for `dp[i][j]` we already choose the `j`th smallest possible value, we can only choose the candidate numbers before `j` for the `i+1`th position. So `dp[i][j] = dp[i + 1][0] + dp[i + 1][1] + ... + dp[i + 1][j - 1]`.\\n\\nThe same logic applies to the case when `s[i] == \\'I`. We can choose the `j + 1`th, `j + 2`th... candidate value for position `i + 1`.  Note that because `j`th value is taken, the `j + 1`th value in `i`\\'s candidate numbers will be the `j`th value in `i+1`\\'s candidate numbers. So `dp[i][j] = dp[i + 1][j] + dp[i + 1][j + 1] + ...`.\\n\\nBecause `dp[i][]` only depends on `dp[i + 1][]`, we can eliminate the first dimension of dp states to save some memory.\\n```Scala\\nobject Solution {\\n  def numPermsDISequence(s: String): Int = {\\n    val mod = (1e9 + 7).toInt\\n    def add(x: Int, y: Int) = ((x + y) % mod + mod) % mod\\n\\n    s.reverse.foldLeft(Vector(1)) {\\n      case (dp, \\'D\\') => Vector.tabulate(dp.size + 1)(j => (0 until j).map(dp).fold(0)(add))\\n      case (dp, \\'I\\') => Vector.tabulate(dp.size + 1)(j => (j until dp.size).map(dp).fold(0)(add))\\n      case _ => null\\n    }.reduce(add)\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n  def numPermsDISequence(s: String): Int = {\\n    val mod = (1e9 + 7).toInt\\n    def add(x: Int, y: Int) = ((x + y) % mod + mod) % mod\\n\\n    s.reverse.foldLeft(Vector(1)) {\\n      case (dp, \\'D\\') => Vector.tabulate(dp.size + 1)(j => (0 until j).map(dp).fold(0)(add))\\n      case (dp, \\'I\\') => Vector.tabulate(dp.size + 1)(j => (j until dp.size).map(dp).fold(0)(add))\\n      case _ => null\\n    }.reduce(add)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3094901,
                "title": "easy-c-beginner-friendly-dp-backtracking-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[202][202];\\n    int mod = 1000000007;\\n    int recur(string &s, int i, int n,int idx){\\n        if(idx==n-1){\\n            return 1;\\n        }\\n        if(dp[idx][i]!=-1)\\n            return dp[idx][i];\\n        \\n        int res = 0;\\n        if(s[idx]==\\'D\\'){\\n            for(int j=i-1;j>=0;j--){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0; \\n            }\\n        }\\n        else{\\n            for(int j=i+1;j<n;j++){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0;\\n            }\\n        }\\n        return dp[idx][i] = res;\\n    }\\n\\n    int numPermsDISequence(string s) {\\n        int n = s.size()+1;\\n        vis.resize(n,0);\\n        for(int i=0;i<202;i++){\\n            for(int j=0;j<202;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vis[i] = 1;\\n            ans = (ans + (recur(s,i,n,0))%mod)%mod;\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[202][202];\\n    int mod = 1000000007;\\n    int recur(string &s, int i, int n,int idx){\\n        if(idx==n-1){\\n            return 1;\\n        }\\n        if(dp[idx][i]!=-1)\\n            return dp[idx][i];\\n        \\n        int res = 0;\\n        if(s[idx]==\\'D\\'){\\n            for(int j=i-1;j>=0;j--){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0; \\n            }\\n        }\\n        else{\\n            for(int j=i+1;j<n;j++){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0;\\n            }\\n        }\\n        return dp[idx][i] = res;\\n    }\\n\\n    int numPermsDISequence(string s) {\\n        int n = s.size()+1;\\n        vis.resize(n,0);\\n        for(int i=0;i<202;i++){\\n            for(int j=0;j<202;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vis[i] = 1;\\n            ans = (ans + (recur(s,i,n,0))%mod)%mod;\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066316,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the number of permutations of a string of length n that satisfy the condition that the string only contains \\'I\\' and \\'D\\' and where \\'I\\' represents increasing and \\'D\\' represents decreasing.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use Dynamic Programming to solve this problem. We create a 2D array dp[n+1][n+1] where dp[i][j] represent the number of permutations of the first i characters that end with j \\'I\\'s.\\n\\nWe iterate through the string one character at a time, and for each character, we check if it is an \\'I\\' or a \\'D\\'. If it is an \\'I\\', we update dp[i][j] using dp[i-1][k] where k is from j to i-1. If it is a \\'D\\', we update dp[i][j] using dp[i-1][k] where k is from 0 to j-1.\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }\\n    }\\n    int ans = 0;\\n    for (int i = 0; i <= n; i++)\\n        ans = (ans + dp[n][i]) % mod;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }\\n    }\\n    int ans = 0;\\n    for (int i = 0; i <= n; i++)\\n        ans = (ans + dp[n][i]) % mod;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007576,
                "title": "detailed-comments-for-an-o-n-2-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int numPermsDISequence(string s) {\\n        int N = s.size() + 1;\\n        vector<vector<int>> dp(N, vector<int>(N));\\n        const int mod = 1e9 + 7;\\n\\n        // dp[i][j] : answers for length=i+1 (using number [0,1,..,i]) that ends with j (j <= i)\\n        for (int j = 0; j < N; j++) {\\n            dp[0][j] = 1;\\n        }\\n\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // when we append j to the array, in order to avoid duplicate, by default, all the elements >= j in the previous array will automatically increment by one\\n                // e.g. [2, 1, 0] + [1] => [3, 2, 0, 1]\\n\\n                if (s[i-1] == \\'I\\') {\\n                    // dp[i][j] = dp[i-1][0] + dp[i-1][1] + .. dp[i-1][j-1]\\n                    dp[i][j] = j ? dp[i-1][j-1] : 0;\\n                } else {\\n                    // dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + .. dp[i-1][i-1]\\n                    dp[i][j] = dp[i-1][i-1] - (j ? dp[i-1][j-1] : 0);\\n                }\\n            }\\n\\n            // change dp[i][j] to prefix sum so that we can have O(N^2) overall complexity instead of O(N^3)\\n            for (int j = 1; j <= i; j++) {\\n                dp[i][j] += dp[i][j-1];\\n                dp[i][j] %= mod;\\n                if (dp[i][j] < 0) {\\n                    dp[i][j] += mod;\\n                }\\n            }\\n        }\\n\\n        return dp[N-1][N-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int numPermsDISequence(string s) {\\n        int N = s.size() + 1;\\n        vector<vector<int>> dp(N, vector<int>(N));\\n        const int mod = 1e9 + 7;\\n\\n        // dp[i][j] : answers for length=i+1 (using number [0,1,..,i]) that ends with j (j <= i)\\n        for (int j = 0; j < N; j++) {\\n            dp[0][j] = 1;\\n        }\\n\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // when we append j to the array, in order to avoid duplicate, by default, all the elements >= j in the previous array will automatically increment by one\\n                // e.g. [2, 1, 0] + [1] => [3, 2, 0, 1]\\n\\n                if (s[i-1] == \\'I\\') {\\n                    // dp[i][j] = dp[i-1][0] + dp[i-1][1] + .. dp[i-1][j-1]\\n                    dp[i][j] = j ? dp[i-1][j-1] : 0;\\n                } else {\\n                    // dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + .. dp[i-1][i-1]\\n                    dp[i][j] = dp[i-1][i-1] - (j ? dp[i-1][j-1] : 0);\\n                }\\n            }\\n\\n            // change dp[i][j] to prefix sum so that we can have O(N^2) overall complexity instead of O(N^3)\\n            for (int j = 1; j <= i; j++) {\\n                dp[i][j] += dp[i][j-1];\\n                dp[i][j] %= mod;\\n                if (dp[i][j] < 0) {\\n                    dp[i][j] += mod;\\n                }\\n            }\\n        }\\n\\n        return dp[N-1][N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990982,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_perms_di_sequence(s: String) -> i32 {\\n        let n = s.len();\\n        let m = 1_000_000_007;\\n        let mut dp = vec![vec![0; n + 1]; n + 1];\\n        dp[0][0] = 1;\\n        for i in 1..=n {\\n            for j in 0..=i {\\n                if s.chars().nth(i - 1).unwrap() == \\'D\\' {\\n                    for k in j..=i - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                } else if j > 0 {\\n                    for k in 0..=j - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                }\\n            }\\n        }\\n        let mut res = 0;\\n        for i in 0..=n {\\n            res = res % m + dp[n][i] % m;\\n        }\\n        (res % m) as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_perms_di_sequence(s: String) -> i32 {\\n        let n = s.len();\\n        let m = 1_000_000_007;\\n        let mut dp = vec![vec![0; n + 1]; n + 1];\\n        dp[0][0] = 1;\\n        for i in 1..=n {\\n            for j in 0..=i {\\n                if s.chars().nth(i - 1).unwrap() == \\'D\\' {\\n                    for k in j..=i - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                } else if j > 0 {\\n                    for k in 0..=j - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                }\\n            }\\n        }\\n        let mut res = 0;\\n        for i in 0..=n {\\n            res = res % m + dp[n][i] % m;\\n        }\\n        (res % m) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2918004,
                "title": "python3-top-down-dp-o-n-2",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n,ans = len(s),0\\n        mod = 1_00_00_00_000 + 7\\n        memo = [[-1] * 201 for i in range(201)]\\n        def dp(ind,prevNum):\\n            if ind < 0:\\n                return 1\\n            if memo[ind][prevNum] != -1:\\n                return memo[ind][prevNum]\\n            val = 0\\n            if s[ind] == \\'D\\':\\n                for more in range(prevNum+1,n+1):\\n                    if more not in vis:\\n                        vis.add(more)\\n                        val += dp(ind-1,more)\\n                        vis.remove(more)\\n            else:\\n                for less in range(prevNum):\\n                    if less not in vis:\\n                        vis.add(less)\\n                        val += dp(ind-1,less)\\n                        vis.remove(less)\\n            memo[ind][prevNum] = val\\n            return memo[ind][prevNum]\\n        for i in range(n+1):\\n            vis = set([i])\\n            ans += dp(n-1,i)\\n        return ans % mod\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n,ans = len(s),0\\n        mod = 1_00_00_00_000 + 7\\n        memo = [[-1] * 201 for i in range(201)]\\n        def dp(ind,prevNum):\\n            if ind < 0:\\n                return 1\\n            if memo[ind][prevNum] != -1:\\n                return memo[ind][prevNum]\\n            val = 0\\n            if s[ind] == \\'D\\':\\n                for more in range(prevNum+1,n+1):\\n                    if more not in vis:\\n                        vis.add(more)\\n                        val += dp(ind-1,more)\\n                        vis.remove(more)\\n            else:\\n                for less in range(prevNum):\\n                    if less not in vis:\\n                        vis.add(less)\\n                        val += dp(ind-1,less)\\n                        vis.remove(less)\\n            memo[ind][prevNum] = val\\n            return memo[ind][prevNum]\\n        for i in range(n+1):\\n            vis = set([i])\\n            ans += dp(n-1,i)\\n        return ans % mod\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862039,
                "title": "python-backtracking-works-and-easy-to-understand",
                "content": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)\\n\\n    def backtrack(self, s):  # with pruning and memo\\n        L = len(s)\\n        nums = set(range(-1, L + 1))  # dummy -1 as \\'pre\\', only happens when idx == 0 (in which case we don\\'t need var \\'pre\\')\\n\\n        @lru_cache(None)\\n        def backtrack(idx, pre):  # current index\\n            nums.remove(pre)\\n\\n            cnt = 0\\n            if not nums:            cnt = 1  # empty, it\\'s a valid permutation\\n            elif idx == 0:          cnt = sum(backtrack(idx + 1, num) for num in range(L + 1))\\n            elif s[idx - 1] == \\'D\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre) if num in nums)\\n            elif s[idx - 1] == \\'I\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre + 1, L + 1) if num in nums)\\n\\n            nums.add(pre)  # recover\\n            return cnt\\n\\n        return backtrack(0, -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)\\n\\n    def backtrack(self, s):  # with pruning and memo\\n        L = len(s)\\n        nums = set(range(-1, L + 1))  # dummy -1 as \\'pre\\', only happens when idx == 0 (in which case we don\\'t need var \\'pre\\')\\n\\n        @lru_cache(None)\\n        def backtrack(idx, pre):  # current index\\n            nums.remove(pre)\\n\\n            cnt = 0\\n            if not nums:            cnt = 1  # empty, it\\'s a valid permutation\\n            elif idx == 0:          cnt = sum(backtrack(idx + 1, num) for num in range(L + 1))\\n            elif s[idx - 1] == \\'D\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre) if num in nums)\\n            elif s[idx - 1] == \\'I\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre + 1, L + 1) if num in nums)\\n\\n            nums.add(pre)  # recover\\n            return cnt\\n\\n        return backtrack(0, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789671,
                "title": "c-backtracking-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788203,
                "title": "js-solution-dp",
                "content": "```\\nvar numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2465388,
                "title": "c-beginner-friendly-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(string &s, int index, vector<bool> &vis, int last, vector<vector<int> > &dp){\\n        //if we reach the last index, there will be single element left we can do this in one way.\\n        if(index == s.size()){\\n            return 1;\\n        }\\n        \\n        if(dp[index][last] != -1) return dp[index][last];\\n        \\n        //when we need less than last one\\n        long long cnt = 0;\\n        if(s[index] == \\'D\\'){\\n            for(int i=0; i<last; i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        //when we need greater than last one\\n        else{\\n            for(int i=last+1; i<=s.size(); i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        return dp[index][last] = cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        vector<bool> vis(s.size()+1, false);\\n        vector<vector<int> > dp(s.size()+2, vector<int>(s.size()+2, -1));\\n        \\n        //start with any number at first position, then apply conditions in function\\n        long long cnt = 0;\\n        for(int i=0; i<=s.size(); i++){\\n            vis[i] = true;\\n            cnt+=(solve(s, 0, vis, i, dp))%mod;\\n            vis[i] = false;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(string &s, int index, vector<bool> &vis, int last, vector<vector<int> > &dp){\\n        //if we reach the last index, there will be single element left we can do this in one way.\\n        if(index == s.size()){\\n            return 1;\\n        }\\n        \\n        if(dp[index][last] != -1) return dp[index][last];\\n        \\n        //when we need less than last one\\n        long long cnt = 0;\\n        if(s[index] == \\'D\\'){\\n            for(int i=0; i<last; i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        //when we need greater than last one\\n        else{\\n            for(int i=last+1; i<=s.size(); i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        return dp[index][last] = cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        vector<bool> vis(s.size()+1, false);\\n        vector<vector<int> > dp(s.size()+2, vector<int>(s.size()+2, -1));\\n        \\n        //start with any number at first position, then apply conditions in function\\n        long long cnt = 0;\\n        for(int i=0; i<=s.size(); i++){\\n            vis[i] = true;\\n            cnt+=(solve(s, 0, vis, i, dp))%mod;\\n            vis[i] = false;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450477,
                "title": "java-time-o-n-2-space-o-n-3ms-2ms-dp-n-1",
                "content": "```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n```\\nfrom dp[][] to dp[]\\n```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint mod = 1000000007;\\n\\tint[] dp = new int[n+1];\\n\\tdp[0] = 1;\\n\\tint c, sum,prev;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor(int j = 0; j<=i; j++){\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+dp[j])%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t} \\n\\t\\t} else {\\n\\t\\t\\tc = dp[i-1]+mod;\\n\\t\\t\\tsum = c%mod;\\n\\t\\t\\tfor(int j = 0; j<=i; j++) {\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+(c-dp[j])%mod)%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t }\\n\\t\\t} \\n\\t}\\n\\treturn dp[n]%mod;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n```\n```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint mod = 1000000007;\\n\\tint[] dp = new int[n+1];\\n\\tdp[0] = 1;\\n\\tint c, sum,prev;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor(int j = 0; j<=i; j++){\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+dp[j])%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t} \\n\\t\\t} else {\\n\\t\\t\\tc = dp[i-1]+mod;\\n\\t\\t\\tsum = c%mod;\\n\\t\\t\\tfor(int j = 0; j<=i; j++) {\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+(c-dp[j])%mod)%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t }\\n\\t\\t} \\n\\t}\\n\\treturn dp[n]%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352796,
                "title": "python3-solution",
                "content": "Solution, requires a bit of observation\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        myStore = [1]\\n        \\n        for index, val in enumerate(s):\\n            if val == 0:\\n                continue\\n            temp = []\\n            for i in range(index + 2):\\n                if val == \"I\":\\n                    curr = sum(myStore[i:])\\n                else:\\n                    curr = sum(myStore[:i])\\n                temp.append(curr)\\n            myStore = temp\\n        return sum(myStore) % (10**9+7)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        myStore = [1]\\n        \\n        for index, val in enumerate(s):\\n            if val == 0:\\n                continue\\n            temp = []\\n            for i in range(index + 2):\\n                if val == \"I\":\\n                    curr = sum(myStore[i:])\\n                else:\\n                    curr = sum(myStore[:i])\\n                temp.append(curr)\\n            myStore = temp\\n        return sum(myStore) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349395,
                "title": "java-solution",
                "content": "class Solution {\\n    private static final int mod = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % mod + numPerms(s, 0, i) % mod;\\n            seen[i] = 0;\\n        }\\n        return count % mod;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % mod + numPerms(s, j+1, i)  % mod;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % mod + numPerms(s, j+1, i) % mod;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % mod;\\n        return dp[j][p];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    private static final int mod = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % mod + numPerms(s, 0, i) % mod;\\n            seen[i] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2246352,
                "title": "anyone-can-modify-this-bfs-approach-with-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n        queue<pair<string,unordered_set<int>>> q;\\n        unordered_set<int> v;\\n        string str=\"\";\\n        for(int i=0;i<=n;++i)\\n        {\\n            str=\"\";\\n            v.clear();\\n            str+=(i+\\'0\\');\\n            v.insert(i);\\n            q.push({str,v});\\n        }\\n        int i=0;\\n        unordered_set<string> visall;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            if(i==n)\\n            {\\n                return q.size();\\n            }\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(visall.find(temp.first)!=visall.end())\\n                {\\n                    continue;\\n                }\\n                if(s[i]==\\'D\\')\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'-1;j>=0;--j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n            }\\n                else\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'+1;j<=n;++j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n        queue<pair<string,unordered_set<int>>> q;\\n        unordered_set<int> v;\\n        string str=\"\";\\n        for(int i=0;i<=n;++i)\\n        {\\n            str=\"\";\\n            v.clear();\\n            str+=(i+\\'0\\');\\n            v.insert(i);\\n            q.push({str,v});\\n        }\\n        int i=0;\\n        unordered_set<string> visall;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            if(i==n)\\n            {\\n                return q.size();\\n            }\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(visall.find(temp.first)!=visall.end())\\n                {\\n                    continue;\\n                }\\n                if(s[i]==\\'D\\')\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'-1;j>=0;--j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n            }\\n                else\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'+1;j<=n;++j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246128,
                "title": "c-easy",
                "content": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // unordered_set<int>st;\\n    int perm(int i, int prev, int n, string &s, vector<vector<int>>&dp, vector<bool>&vis)\\n    {\\n        //cout<<\"HERE\"<<i<<\"\\\\n\";\\n        if(i<0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][prev] != -1)\\n        {\\n            return dp[i][prev];\\n        }\\n        \\n        int ways = 0;\\n        \\n        if(i == n)\\n        {\\n            for(int j=0; j<=n;j++)\\n            {\\n                int x = j;\\n                vis[x] = true;\\n                //cout<<x<<\"\\\\n\";\\n                ways = (ways + perm(i-1, x, n, s, dp, vis))%mod;\\n                //cout<<ways<<\" \"<<x<<\"\\\\n\";\\n                vis[x] = false;\\n            }\\n        }\\n        else\\n        {\\n            if(s[i] == \\'D\\')\\n            {\\n                for(int j=0; j<=n; j++)\\n                {\\n                    if(vis[j] == true) continue;\\n                    int x = j;\\n                    if(prev < x)\\n                    {\\n                        vis[x] = true;\\n                        ways = (ways + perm(i-1, x,n, s, dp, vis))%mod;\\n                        vis[x] = false;\\n                    }\\n                    \\n                }\\n            }\\n            else\\n            {\\n                for(int j=0; j<=n; j++)\\n                {\\n                    if(vis[j] == true) continue;\\n                    int x = j;\\n                    if(prev > x)\\n                    {\\n                        vis[x] = true;\\n                        ways = (ways + perm(i-1, x,n, s, dp, vis))%mod;\\n                        vis[x] = false;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[i][prev] = ways;\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool>vis(s.size()+10, -1);\\n        for(int i=0; i<= s.size();i++)\\n        {\\n            vis[i] = false;\\n            //cout<<i<<\"\\\\n\";\\n        }\\n        vector<vector<int>>dp(s.size()+10, vector<int>(s.size()+10, -1));\\n        return perm(s.size(), s.size()+5, s.size(), s, dp, vis);\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // unordered_set<int>st;\\n    int perm(int i, int prev, int n, string &s, vector<vector<int>>&dp, vector<bool>&vis)\\n    {\\n        //cout<<\"HERE\"<<i<<\"\\\\n\";\\n        if(i<0)\\n        {\\n            return 1;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2245996,
                "title": "easy-c-solution-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    int m = 1e9+7;\\n    int helper(string &s, int i, vector<bool> &visit, int start){\\n        if(i==s.length()){\\n            return 1;\\n        }\\n        \\n        if(dp[i][start]!=-1){\\n            return dp[i][start];\\n        }\\n        if(s[i]==\\'D\\'){\\n            int ans = 0;\\n            for(int j = 0;j < start;j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = start+1;j <= s.length();j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool> visit(s.length()+1,false);\\n        int ans = 0;\\n             memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i <= s.length();i++){\\n            visit[i]=true;\\n       \\n            ans = (ans%m + helper(s,0,visit,i)%m)%m;\\n            visit[i]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    int m = 1e9+7;\\n    int helper(string &s, int i, vector<bool> &visit, int start){\\n        if(i==s.length()){\\n            return 1;\\n        }\\n        \\n        if(dp[i][start]!=-1){\\n            return dp[i][start];\\n        }\\n        if(s[i]==\\'D\\'){\\n            int ans = 0;\\n            for(int j = 0;j < start;j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = start+1;j <= s.length();j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool> visit(s.length()+1,false);\\n        int ans = 0;\\n             memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i <= s.length();i++){\\n            visit[i]=true;\\n       \\n            ans = (ans%m + helper(s,0,visit,i)%m)%m;\\n            visit[i]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245756,
                "title": "easy-c-solution",
                "content": "```\\nusing ll = long long;\\n\\nll dp[205][205];\\nconst ll mod = 1e9 + 7;\\nint n;\\n\\nll solve(int index, string &s, vector<int> &v, int piche)\\n{\\n    if (index >= s.size())\\n        return 1;\\n\\n    if (dp[index][piche] != -1)\\n        return dp[index][piche];\\n\\n    dp[index][piche] = 0;\\n\\n    if (s[index] == \\'D\\')\\n    {\\n        for (int i = 0; i < piche; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n    else\\n    {\\n        for (int i = piche + 1; i < n + 1; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n\\n    return dp[index][piche] %= mod;\\n\\n}\\n\\nclass Solution\\n{\\n    public:\\n        int numPermsDISequence(string s)\\n        {\\n            memset(dp, -1, sizeof(dp));\\n            n=s.size();\\n            \\n            if(n==1)\\n                return 1;\\n            \\n            vector<int>v(n+1,0);\\n            \\n            ll ans=0;\\n            \\n            for(int i=0;i<=n;++i)\\n            {\\n                v[i]=1;\\n                ans+=solve(0,s,v,i);\\n                ans%=mod;\\n                v[i]=0;\\n            }\\n            return ans;\\n            \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nusing ll = long long;\\n\\nll dp[205][205];\\nconst ll mod = 1e9 + 7;\\nint n;\\n\\nll solve(int index, string &s, vector<int> &v, int piche)\\n{\\n    if (index >= s.size())\\n        return 1;\\n\\n    if (dp[index][piche] != -1)\\n        return dp[index][piche];\\n\\n    dp[index][piche] = 0;\\n\\n    if (s[index] == \\'D\\')\\n    {\\n        for (int i = 0; i < piche; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n    else\\n    {\\n        for (int i = piche + 1; i < n + 1; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n\\n    return dp[index][piche] %= mod;\\n\\n}\\n\\nclass Solution\\n{\\n    public:\\n        int numPermsDISequence(string s)\\n        {\\n            memset(dp, -1, sizeof(dp));\\n            n=s.size();\\n            \\n            if(n==1)\\n                return 1;\\n            \\n            vector<int>v(n+1,0);\\n            \\n            ll ans=0;\\n            \\n            for(int i=0;i<=n;++i)\\n            {\\n                v[i]=1;\\n                ans+=solve(0,s,v,i);\\n                ans%=mod;\\n                v[i]=0;\\n            }\\n            return ans;\\n            \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172627,
                "title": "c-solution",
                "content": "```\\n//This is based on a couple others..\\n//I take no credit other than the obvious refactoring.\\n//I deliberately chose the one that seemed easier to understand, not the fastest.\\n\\npublic class Solution \\n{\\n    //Number of Permutations Table - Using long to avoid a lot of mod operations.\\n    long [,] np;\\n    int MOD;\\n    \\n    public void GetNumPermutationsEndingIn(int len, int end, int endStart, int endStop)\\n    {\\n        for(int k = endStart; k <= endStop; k++)\\n        {\\n            np[len,end] += np[len-1,k];\\n        }\\n        //This is just trying to keep the value from overflowing..\\n        if (np[len,end] > 0xFFFFFFFFFFFF)\\n        {\\n            np[len,end] = np[len,end]%this.MOD;\\n        }\\n    }\\n    \\n    public int NumPermsDISequence(string S) {\\n        int n = S.Length;\\n        this.MOD = 1000000000 + 7;\\n        this.np = new long[n+1,n+1];\\n        this.np[0,0] = 1;\\n        for(int len = 1; len <= n; len++)\\n        {\\n            for(int end = 0; end <= len; end++)\\n            {\\n                if(S[len-1] == \\'D\\')\\n                {\\n                    //Here the transformation is to decrease.  This means the previous MUST be bigger than this one.\\n                    //The starting point is apparently end not end-1 here to also include the number of permutations frm the previous as a starting point. \\n                    //The next np[len,end] is np[len-1,end] + np[len-1,end+1]... + np[len-1,len-1]\\n                    GetNumPermutationsEndingIn(len,end,  end/*prev end start*/, len-1/*prev end stop*/);\\n                }\\n                else\\n                {\\n                    //The next np[len,end] is np[len-1,0] + np[len-1,1]... + np[len-1,end-1]\\n                    GetNumPermutationsEndingIn(len,end,  0/*prev end start*/  , end-1/*prev end stop*/);\\n                }\\n            }\\n        }\\n        \\n        //To get the complete the complete set a simple sum is required.\\n        long res = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            res += np[n,i];\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//This is based on a couple others..\\n//I take no credit other than the obvious refactoring.\\n//I deliberately chose the one that seemed easier to understand, not the fastest.\\n\\npublic class Solution \\n{\\n    //Number of Permutations Table - Using long to avoid a lot of mod operations.\\n    long [,] np;\\n    int MOD;\\n    \\n    public void GetNumPermutationsEndingIn(int len, int end, int endStart, int endStop)\\n    {\\n        for(int k = endStart; k <= endStop; k++)\\n        {\\n            np[len,end] += np[len-1,k];\\n        }\\n        //This is just trying to keep the value from overflowing..\\n        if (np[len,end] > 0xFFFFFFFFFFFF)\\n        {\\n            np[len,end] = np[len,end]%this.MOD;\\n        }\\n    }\\n    \\n    public int NumPermsDISequence(string S) {\\n        int n = S.Length;\\n        this.MOD = 1000000000 + 7;\\n        this.np = new long[n+1,n+1];\\n        this.np[0,0] = 1;\\n        for(int len = 1; len <= n; len++)\\n        {\\n            for(int end = 0; end <= len; end++)\\n            {\\n                if(S[len-1] == \\'D\\')\\n                {\\n                    //Here the transformation is to decrease.  This means the previous MUST be bigger than this one.\\n                    //The starting point is apparently end not end-1 here to also include the number of permutations frm the previous as a starting point. \\n                    //The next np[len,end] is np[len-1,end] + np[len-1,end+1]... + np[len-1,len-1]\\n                    GetNumPermutationsEndingIn(len,end,  end/*prev end start*/, len-1/*prev end stop*/);\\n                }\\n                else\\n                {\\n                    //The next np[len,end] is np[len-1,0] + np[len-1,1]... + np[len-1,end-1]\\n                    GetNumPermutationsEndingIn(len,end,  0/*prev end start*/  , end-1/*prev end stop*/);\\n                }\\n            }\\n        }\\n        \\n        //To get the complete the complete set a simple sum is required.\\n        long res = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            res += np[n,i];\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053711,
                "title": "first-javascript-solution",
                "content": "```\\nfunction numPermsDISequence(s) {\\n    let mod = 1e9 + 7, dp = [[1], []], res = 0\\n\\n    for (let i = 1; i <= S.length; i++) {\\n        for (let j = 0; j <= i; j++) {\\n            let l = 0,  r = j\\n            if (s.charAt(i-1) === \\'D\\') {\\n                l = j, r = i\\n            }\\n            dp[1][j] = 0\\n            for (let k = l; k < r; k++) {\\n                dp[1][j] += dp[0][k]\\n                dp[1][j] %= mod\\n            }\\n        }\\n        [dp[0], dp[1]] = [dp[1], dp[0]]\\n    }\\n\\n    for (let cnt of dp.shift()) {\\n        res += cnt\\n        res %= mod\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numPermsDISequence(s) {\\n    let mod = 1e9 + 7, dp = [[1], []], res = 0\\n\\n    for (let i = 1; i <= S.length; i++) {\\n        for (let j = 0; j <= i; j++) {\\n            let l = 0,  r = j\\n            if (s.charAt(i-1) === \\'D\\') {\\n                l = j, r = i\\n            }\\n            dp[1][j] = 0\\n            for (let k = l; k < r; k++) {\\n                dp[1][j] += dp[0][k]\\n                dp[1][j] %= mod\\n            }\\n        }\\n        [dp[0], dp[1]] = [dp[1], dp[0]]\\n    }\\n\\n    for (let cnt of dp.shift()) {\\n        res += cnt\\n        res %= mod\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053260,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n,mod=1000000000+7;\\n    vector<vector<int>>mem;\\n    int solve(string &s,int index,int prev,vector<bool>&seen){\\n        if(index==n){\\n            return 1;\\n        } else if(mem[index][prev]!=-1){\\n            return mem[index][prev];\\n        } else {\\n            int ans=0;\\n            if(s[index]==\\'D\\'){\\n                for(int i=0;i<prev;i++){\\n                    if(!seen[i]){\\n                        seen[i]=true;\\n                        ans=(ans%mod+solve(s,index+1,i,seen)%mod)%mod;\\n                        seen[i]=false;\\n                    }\\n                }\\n            } else {\\n                for(int i=prev+1;i<=n;i++){\\n                    if(!seen[i]){\\n                        seen[i]=true;\\n                        ans=(ans%mod+solve(s,index+1,i,seen)%mod)%mod;\\n                        seen[i]=false;\\n                    }\\n                }\\n            }\\n            return mem[index][prev]=ans;\\n        }\\n    }\\npublic:\\n    int numPermsDISequence(string &s) {\\n        n=s.size();\\n        int ans=0;\\n        mem=vector<vector<int>>(n+1,vector<int>(n+1,-1));\\n        vector<bool>seen(n+1,false);\\n        for(int i=0;i<=n;i++){\\n            seen[i]=true;\\n            ans=(ans%mod+solve(s,0,i,seen)%mod)%mod;\\n            seen[i]=false;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    int n,mod=1000000000+7;\\n    vector<vector<int>>mem;\\n    int solve(string &s,int index,int prev,vector<bool>&seen){\\n        if(index==n){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1854816,
                "title": "python-solution-easy-explained-dp-well-writtten-code",
                "content": "Try putting Value at the position keeping in mind that the current value should be increasing or decreasing \\nTo check this check s[pos - 1] \\nNow since we cannot repeat any digit we should use a dictionary to keep in check what value we used so far .\\n\\nOnce you find the no. of answer having index  = i and last item = x , put it on dp\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def recursion(self,idx,s,prev,limit,val,used):\\n        if idx == limit + 1:\\n            return 1\\n        if (idx,prev) in self.dp:return self.dp[(idx,prev)]\\n        start = 0 if s[idx-1] == \\'D\\' else prev + 1\\n        end = prev -1 if s[idx-1] == \\'D\\' else limit\\n        ans = 0\\n        for i in range(start,end+1):\\n            if i in used and used[i]==True:continue\\n            used[i] = True\\n            ans+=self.recursion(idx+1,s,i,limit,val+str(i),used)\\n            used[i] = False\\n        self.dp[(idx,prev)]=ans\\n        return ans\\n    def numPermsDISequence(self, s: str) -> int:\\n        limit = len(s)\\n        ans = 0\\n        self.dp = {}\\n        for i in range(limit+1):\\n            ans+= self.recursion(1,s,i,limit,str(i),{i:True})\\n        return ans%1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def recursion(self,idx,s,prev,limit,val,used):\\n        if idx == limit + 1:\\n            return 1\\n        if (idx,prev) in self.dp:return self.dp[(idx,prev)]\\n        start = 0 if s[idx-1] == \\'D\\' else prev + 1\\n        end = prev -1 if s[idx-1] == \\'D\\' else limit\\n        ans = 0\\n        for i in range(start,end+1):\\n            if i in used and used[i]==True:continue\\n            used[i] = True\\n            ans+=self.recursion(idx+1,s,i,limit,val+str(i),used)\\n            used[i] = False\\n        self.dp[(idx,prev)]=ans\\n        return ans\\n    def numPermsDISequence(self, s: str) -> int:\\n        limit = len(s)\\n        ans = 0\\n        self.dp = {}\\n        for i in range(limit+1):\\n            ans+= self.recursion(1,s,i,limit,str(i),{i:True})\\n        return ans%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851457,
                "title": "memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[203][203];\\n    int mod=1e9+7;\\n    int solve(int index , string& s, vector<int> & visited , int prev){\\n        if(index==s.size()) return 1;\\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        int n=s.size();\\n        long long temp=0;\\n        if(s[index]==\\'D\\'){\\n            //0 to prev-1\\n            for(int i=0;i<=prev-1;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n\\n                    visited[i]=0;\\n                }\\n            }\\n        }else {\\n            //prev+1 to n\\n            for(int i=prev+1;i<=n;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=temp;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        int n=s.size();\\n        vector<int> visited(n+1,0);\\n        int count=0;\\n        for(int i=0;i<=n;i++){\\n            visited[i]=1;\\n            count= (count%mod+(long long)solve(0,s,visited,i)%mod)%mod;\\n            visited[i]=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[203][203];\\n    int mod=1e9+7;\\n    int solve(int index , string& s, vector<int> & visited , int prev){\\n        if(index==s.size()) return 1;\\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        int n=s.size();\\n        long long temp=0;\\n        if(s[index]==\\'D\\'){\\n            //0 to prev-1\\n            for(int i=0;i<=prev-1;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n\\n                    visited[i]=0;\\n                }\\n            }\\n        }else {\\n            //prev+1 to n\\n            for(int i=prev+1;i<=n;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=temp;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        int n=s.size();\\n        vector<int> visited(n+1,0);\\n        int count=0;\\n        for(int i=0;i<=n;i++){\\n            visited[i]=1;\\n            count= (count%mod+(long long)solve(0,s,visited,i)%mod)%mod;\\n            visited[i]=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307997,
                "title": "compiling-both-o-n-2-approaches",
                "content": "The first approach is based on [this](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)) post by lee215.\\n\\nIn both the cases we are avoiding looping through the values already looped through by the previous element by just using the previous values to make it O(n^2) instead of O(n^3).\\n```\\n// Runtime: 4ms\\nvoid firstApproach(string& s, int n, vvi&dp) {\\n        for (int i =0;i<=n;i++) dp[0][i] = 1;\\n        for (int i = 1;i<=n;i++) {\\n            if (s[i-1] == \\'I\\') {\\n                dp[i][0] = dp[i-1][0];\\n                for (int j=1;j<=n-i;j++) {\\n                    dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod; // summing dp[i-1][0..j]\\n                }\\n            } else {\\n                dp[i][n-i] = dp[i-1][n-i+1];\\n                for (int j=n-i-1;j>=0;j--) {\\n                    dp[i][j] = (dp[i][j+1] + dp[i-1][j+1])%mod; // summing dp[i-1][j+1...n-i+1]\\n                }\\n            }\\n        }\\n    }\\n```\\n\\n\\nThe second approach is based on the intuitions by wxd_sjtu [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation), another great explanation by ariawynn [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/186571/Python-O(N3)O(N2)-time-O(N)-space-DP-solution-with-clear-explanation-(no-%22relative-rank%22-stuff)).\\nA great visualisation for this approach is also provided by quadpixels [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/169126/Visualization-Key-to-the-DP-solution:-imagine-cutting-a-piece-of-paper-and-separating-the-halves)\\n\\n```\\n// Runtime: 4ms\\nvoid secondApproach(string& s, int n, vvi&dp) {\\n       for (int i=0;i<=n;i++) dp[0][i] = 1;\\n       for (int i = 1;i<=n;i++) {\\n           if (s[i-1] == \\'I\\') {\\n              dp[i][1] = dp[i-1][0];\\n               for (int j = 2;j<=i;j++) {\\n                   dp[i][j] = (dp[i][j-1] + dp[i-1][j-1])%mod; // summing dp[i-1][0...j-1]\\n               } \\n           } else {\\n               dp[i][i-1] = dp[i-1][i-1];\\n               for (int j = i-2;j>=0;j--) {\\n                   dp[i][j] = (dp[i][j+1] + dp[i-1][j])%mod; // summing dp[i-1][j...i-1]\\n               }\\n           }\\n       }\\n   }\\n```\\n\\nBoilerplate:\\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nint mod = 1e9+7;\\nint numPermsDISequence(string& s) {\\n\\tint n = s.size();\\n\\tvvi dp = vvi(n+1, vi(n+1,0));\\n\\tfirstApproach(s, n, dp);\\n\\t//secondApproach(s, n, dp);\\n\\tint ans =0;\\n\\tfor (int i: dp[n]) ans = (ans + i)%mod;\\n\\treturn ans;\\n}\\n```\\n\\nJust a compilation, kudos to the original posters.\\n",
                "solutionTags": [],
                "code": "```\\n// Runtime: 4ms\\nvoid firstApproach(string& s, int n, vvi&dp) {\\n        for (int i =0;i<=n;i++) dp[0][i] = 1;\\n        for (int i = 1;i<=n;i++) {\\n            if (s[i-1] == \\'I\\') {\\n                dp[i][0] = dp[i-1][0];\\n                for (int j=1;j<=n-i;j++) {\\n                    dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod; // summing dp[i-1][0..j]\\n                }\\n            } else {\\n                dp[i][n-i] = dp[i-1][n-i+1];\\n                for (int j=n-i-1;j>=0;j--) {\\n                    dp[i][j] = (dp[i][j+1] + dp[i-1][j+1])%mod; // summing dp[i-1][j+1...n-i+1]\\n                }\\n            }\\n        }\\n    }\\n```\n```\\n// Runtime: 4ms\\nvoid secondApproach(string& s, int n, vvi&dp) {\\n       for (int i=0;i<=n;i++) dp[0][i] = 1;\\n       for (int i = 1;i<=n;i++) {\\n           if (s[i-1] == \\'I\\') {\\n              dp[i][1] = dp[i-1][0];\\n               for (int j = 2;j<=i;j++) {\\n                   dp[i][j] = (dp[i][j-1] + dp[i-1][j-1])%mod; // summing dp[i-1][0...j-1]\\n               } \\n           } else {\\n               dp[i][i-1] = dp[i-1][i-1];\\n               for (int j = i-2;j>=0;j--) {\\n                   dp[i][j] = (dp[i][j+1] + dp[i-1][j])%mod; // summing dp[i-1][j...i-1]\\n               }\\n           }\\n       }\\n   }\\n```\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nint mod = 1e9+7;\\nint numPermsDISequence(string& s) {\\n\\tint n = s.size();\\n\\tvvi dp = vvi(n+1, vi(n+1,0));\\n\\tfirstApproach(s, n, dp);\\n\\t//secondApproach(s, n, dp);\\n\\tint ans =0;\\n\\tfor (int i: dp[n]) ans = (ans + i)%mod;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1239404,
                "title": "c-easy",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int mod = 1e9 + 7;\\n    map<pair<int,int>,int>dp;\\n    int countways(int id,int prev,vector<bool>&taken){\\n\\n        if(id==n+1){\\n            return 1;\\n        }\\n        if(dp.find({id,prev})!=dp.end()) return dp[{id,prev}];\\n        int ans = 0;\\n        if(s[id-1]==\\'D\\'){\\n            for(int i = 0;i<=prev;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        else{\\n            for(int i = prev+1;i<=n;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        return dp[{id,prev}] = ans%mod;\\n    }\\n    int numPermsDISequence(string _s) {\\n        s = _s;\\n        n = s.size();\\n        vector<bool>taken(n+1,false);\\n        int ans = 0;\\n        for(int i = 0;i<=n;i++){\\n            taken[i] = true;\\n            ans+=countways(1,i,taken)%mod;\\n            ans%=mod;\\n            taken[i] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int mod = 1e9 + 7;\\n    map<pair<int,int>,int>dp;\\n    int countways(int id,int prev,vector<bool>&taken){\\n\\n        if(id==n+1){\\n            return 1;\\n        }\\n        if(dp.find({id,prev})!=dp.end()) return dp[{id,prev}];\\n        int ans = 0;\\n        if(s[id-1]==\\'D\\'){\\n            for(int i = 0;i<=prev;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        else{\\n            for(int i = prev+1;i<=n;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        return dp[{id,prev}] = ans%mod;\\n    }\\n    int numPermsDISequence(string _s) {\\n        s = _s;\\n        n = s.size();\\n        vector<bool>taken(n+1,false);\\n        int ans = 0;\\n        for(int i = 0;i<=n;i++){\\n            taken[i] = true;\\n            ans+=countways(1,i,taken)%mod;\\n            ans%=mod;\\n            taken[i] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210448,
                "title": "java-dp-o-n-3",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Map<Integer, Integer> cache;\\n    public int numPermsDISequence(String s) {\\n        cache = new HashMap<>();\\n        return dpRec(s, 0, 0, s.length(), new boolean[s.length()+1]);\\n    }\\n    private int dpRec(String s, int i, int x, int y, boolean[] vis) {\\n        if(i == s.length()){\\n            int j;\\n            for(j = x; j <= y; j++) if(vis[j] == false) break;\\n            return (j <= y) ? 1 : 0;\\n        } \\n        int key = i*40000 + x*200 + y;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int count = 0;\\n        for(int j = x; j <= y; j++) {\\n            if(vis[j] == false) {\\n                vis[j] = true;\\n                count += (s.charAt(i) == \\'D\\') ? dpRec(s, i+1, 0, j-1, vis) : dpRec(s, i+1, j+1, s.length(), vis);\\n                count = count%MOD;\\n                vis[j] = false;\\n            }\\n        }\\n        cache.put(key, count);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Map<Integer, Integer> cache;\\n    public int numPermsDISequence(String s) {\\n        cache = new HashMap<>();\\n        return dpRec(s, 0, 0, s.length(), new boolean[s.length()+1]);\\n    }\\n    private int dpRec(String s, int i, int x, int y, boolean[] vis) {\\n        if(i == s.length()){\\n            int j;\\n            for(j = x; j <= y; j++) if(vis[j] == false) break;\\n            return (j <= y) ? 1 : 0;\\n        } \\n        int key = i*40000 + x*200 + y;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int count = 0;\\n        for(int j = x; j <= y; j++) {\\n            if(vis[j] == false) {\\n                vis[j] = true;\\n                count += (s.charAt(i) == \\'D\\') ? dpRec(s, i+1, 0, j-1, vis) : dpRec(s, i+1, j+1, s.length(), vis);\\n                count = count%MOD;\\n                vis[j] = false;\\n            }\\n        }\\n        cache.put(key, count);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181145,
                "title": "java-bottom-up-solution-dp",
                "content": "Let\\'s define our dp first:\\ndp[i][j]=permutations with lenght i with last digit j. The trick is that when you are iterating from i=1 to i=n, you select different j from 0 to i. Then, for each one of those j, you need to sum the relevant DPs. If S.charAt(i-1)=\\'I\\', then the prev digit should have been less than the current. So, we use the left half (0,j-1). If it is \\'D\\', then the prev digit should have been greater than the current one. So, we use (j,i-1). At the end, we sum up the last row dp[n][...] which means all the permuations with length n ending in different digits. Since the result might be big, be careful of the required mods.\\n```\\n   public int numPermsDISequence(String S) {\\n        int mod = 1_000_000_007;\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) { // We start from 1 to\\n            char c = S.charAt(i - 1);\\n            for (int j = 0; j <= i; j++) { // curr: dp[i][...] prev dp[i-1][...]\\n                long sum = 0;\\n                if (c == \\'I\\') { // Increasing- the prev digit was less than the current->use prev(0,j-1)\\n                    for (int k = 0; k <= j - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                } else { // c==\\'D\\'- Decreasing- the prev digit was greater than the current->use prev(j,i-1)\\n                    for (int k = j; k <= i - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                }\\n                dp[i][j] = sum;\\n            }\\n        }\\n        Long res = 0L; // Sum the last row- dp[n][...]\\n        for (int i = 0; i <= n; i++) res = (res + dp[n][i]) % mod;\\n        res = res % mod;\\n        return res.intValue();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int numPermsDISequence(String S) {\\n        int mod = 1_000_000_007;\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) { // We start from 1 to\\n            char c = S.charAt(i - 1);\\n            for (int j = 0; j <= i; j++) { // curr: dp[i][...] prev dp[i-1][...]\\n                long sum = 0;\\n                if (c == \\'I\\') { // Increasing- the prev digit was less than the current->use prev(0,j-1)\\n                    for (int k = 0; k <= j - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                } else { // c==\\'D\\'- Decreasing- the prev digit was greater than the current->use prev(j,i-1)\\n                    for (int k = j; k <= i - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                }\\n                dp[i][j] = sum;\\n            }\\n        }\\n        Long res = 0L; // Sum the last row- dp[n][...]\\n        for (int i = 0; i <= n; i++) res = (res + dp[n][i]) % mod;\\n        res = res % mod;\\n        return res.intValue();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119442,
                "title": "python3-top-down-dp",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        n = len(S) + 1\\n        @lru_cache(maxsize = 40000)\\n        def dfs(lastPos, pos):\\n            total = 0\\n            if pos == 0:\\n                for i in range(n):\\n                    total += dfs(i, pos + 1)\\n                return total%1000000007\\n            letter = S[pos - 1]\\n            if pos == len(S):\\n                if letter == \\'I\\':\\n                    return 1 - lastPos\\n                else:\\n                    return lastPos\\n            else:\\n                if letter == \\'I\\':\\n                    for i in range(lastPos, n-pos):\\n                        total += dfs(i, pos + 1)\\n                else:\\n                    for i in range(lastPos):\\n                        total += dfs(i, pos + 1)\\n                        \\n                return total%1000000007\\n            \\n        return dfs(0,0)%1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        n = len(S) + 1\\n        @lru_cache(maxsize = 40000)\\n        def dfs(lastPos, pos):\\n            total = 0\\n            if pos == 0:\\n                for i in range(n):\\n                    total += dfs(i, pos + 1)\\n                return total%1000000007\\n            letter = S[pos - 1]\\n            if pos == len(S):\\n                if letter == \\'I\\':\\n                    return 1 - lastPos\\n                else:\\n                    return lastPos\\n            else:\\n                if letter == \\'I\\':\\n                    for i in range(lastPos, n-pos):\\n                        total += dfs(i, pos + 1)\\n                else:\\n                    for i in range(lastPos):\\n                        total += dfs(i, pos + 1)\\n                        \\n                return total%1000000007\\n            \\n        return dfs(0,0)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115156,
                "title": "java",
                "content": "```\\npublic int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976437,
                "title": "c-dp-o-n-3",
                "content": "```\\n///v2[i][j] stores value of i!/((i-j)!*j!) \\n///v1[i][j] stores permutations for DI seq from j to j+i-1 \\n#define ll long long\\nclass Solution {\\npublic:\\n    ll p = 1e9+7;\\n    int numPermsDISequence(string s){\\n        ll n = s.size();\\n        vector < vector < ll > > v1( n+1 , vector<ll> ( n+1 , 1 ) );\\n        vector < vector < ll > > v2 = v1;\\n        for( int i = 1 ; i <= n ; i++) { \\n            for( int j = 0 ; j <= i ; j++) {\\n                if( j==0 || j==i ) v2[i][j] = 1 ;\\n                else v2[i][j] = ( v2[i-1][j-1] + v2[i-1][j] ) % p;\\n            }\\n        }\\n        for(ll i = 2 ; i <= n ; i++) {\\n            for(ll j = 0 ; j+i-1 < n ; j++) {\\n                v1[i][j] = 0 ;\\n                for(ll k = j ;k < i + j -1 ; k++) {\\n                    if( s[k] == \\'I\\' && s[k+1] == \\'D\\' ) {\\n                        v1[i][j] = ( v1[i][j] + ( ( v2[i][k+1-j] * v1[k-j][j] ) %p ) * v1[i+j-k-2][k+2] ) % p;\\n                    }\\n                }\\n                if( s[j] == \\'D\\' ) v1[i][j] = ( v1[i][j] + v1[i-1][j+1] ) %p;\\n                if( s[i+j-1] == \\'I\\' ) v1[i][j] = ( v1[i][j] + v1[i-1][j] ) %p;\\n            }\\n        }\\n        return v1[n][0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ll p = 1e9+7;\\n    int numPermsDISequence(string s){\\n        ll n = s.size();\\n        vector < vector < ll > > v1( n+1 , vector<ll> ( n+1 , 1 ) );\\n        vector < vector < ll > > v2 = v1;\\n        for( int i = 1 ; i <= n ; i++) { \\n            for( int j = 0 ; j <= i ; j++) {\\n                if( j==0 || j==i ) v2[i][j] = 1 ;\\n                else v2[i][j] = ( v2[i-1][j-1] + v2[i-1][j] ) % p;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 901920,
                "title": "cpp14-dp-solution",
                "content": "```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int dp[205][205];\\n        memset(dp , 0 ,sizeof dp) ;\\n        int n = S.length();\\n        for(int j = 1 ; j <= n + 1  ; ++j) dp[1][j] = 1;\\n\\n        for(int i = 2 ; i <= n + 1  ; ++i){\\n           // cout << \" i is \" << i << endl ; \\n            if(S[i - 2] == \\'D\\'){\\n                /// p[i] > p[i+1]\\n                int sum = 0;\\n                for(int j = n - i + 2 ; j >= 1 ; --j){\\n                    sum = sum + dp[i-1][j+1];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n            else if(S[i-2] == \\'I\\'){\\n                /// p[i] < p[i+1]\\n                int sum = 0;\\n                for(int j = 1 ; j <= n - i + 2 ; ++j){\\n                    sum = sum + dp[i-1][j];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n    \\n        }\\n        return dp[n+1][1] ;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int dp[205][205];\\n        memset(dp , 0 ,sizeof dp) ;\\n        int n = S.length();\\n        for(int j = 1 ; j <= n + 1  ; ++j) dp[1][j] = 1;\\n\\n        for(int i = 2 ; i <= n + 1  ; ++i){\\n           // cout << \" i is \" << i << endl ; \\n            if(S[i - 2] == \\'D\\'){\\n                /// p[i] > p[i+1]\\n                int sum = 0;\\n                for(int j = n - i + 2 ; j >= 1 ; --j){\\n                    sum = sum + dp[i-1][j+1];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n            else if(S[i-2] == \\'I\\'){\\n                /// p[i] < p[i+1]\\n                int sum = 0;\\n                for(int j = 1 ; j <= n - i + 2 ; ++j){\\n                    sum = sum + dp[i-1][j];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n    \\n        }\\n        return dp[n+1][1] ;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 898513,
                "title": "java-dp-solution-time-compexity-o-n2-space-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int MOD = 1000000007;\\n        int N = S.length();\\n        int [] dp = new int [N+1];\\n        dp[0] =1;\\n        int sum = 0;\\n        for(int i =1;i<=N;i++){\\n            char ch = S.charAt(i-1);\\n            int [] dp2 = new int[N+1];\\n            if(ch == \\'I\\'){\\n                for(int j = 1;j<=i;j++)\\n                    dp2[j] = (dp2[j-1]+dp[j-1])%MOD;\\n            }\\n            else{\\n                 for(int j = i-1;j>=0;j--)\\n                    dp2[j] = (dp2[j+1]+dp[j])%MOD;\\n            }\\n            dp = dp2;\\n        }\\n        int ans = 0;\\n        for(int num : dp)\\n            ans = (ans+num)%MOD;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int MOD = 1000000007;\\n        int N = S.length();\\n        int [] dp = new int [N+1];\\n        dp[0] =1;\\n        int sum = 0;\\n        for(int i =1;i<=N;i++){\\n            char ch = S.charAt(i-1);\\n            int [] dp2 = new int[N+1];\\n            if(ch == \\'I\\'){\\n                for(int j = 1;j<=i;j++)\\n                    dp2[j] = (dp2[j-1]+dp[j-1])%MOD;\\n            }\\n            else{\\n                 for(int j = i-1;j>=0;j--)\\n                    dp2[j] = (dp2[j+1]+dp[j])%MOD;\\n            }\\n            dp = dp2;\\n        }\\n        int ans = 0;\\n        for(int num : dp)\\n            ans = (ans+num)%MOD;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876768,
                "title": "python-dp-o-n-2",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        M = 10**9 + 7\\n        C = [1] + [0 for _ in range(len(S))]\\n        for n, id in enumerate(list(S), start=2):\\n            if id == \\'I\\':\\n                C = [sum(C[j - 1] for j in range(1, k)) % M for\\n                     k in range(1, n + 1)]\\n            elif id == \\'D\\':\\n                C = [sum(C[j - 1] for j in range(k, n)) % M for\\n                     k in range(1, n + 1)]\\n        return sum(C) % M\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        M = 10**9 + 7\\n        C = [1] + [0 for _ in range(len(S))]\\n        for n, id in enumerate(list(S), start=2):\\n            if id == \\'I\\':\\n                C = [sum(C[j - 1] for j in range(1, k)) % M for\\n                     k in range(1, n + 1)]\\n            elif id == \\'D\\':\\n                C = [sum(C[j - 1] for j in range(k, n)) % M for\\n                     k in range(1, n + 1)]\\n        return sum(C) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866925,
                "title": "js-solution",
                "content": "```js\\n/**\\n * @param {string} S\\n * @return {number}\\n */\\nexport default (S) => {\\n  let dp = [];\\n  const len = S.length;\\n  const mod = Math.pow(10, 9) + 7;\\n  // S=DID\\n  // len = 4,\\u6240\\u4EE5\\u8FD9\\u91CC\\u67090\\uFF0C1\\uFF0C2\\uFF0C3\\u56DB\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\n  // dp[i][j] \\u8868\\u793Ai\\u4E2A\\u6570\\u5B57\\u653E\\u7F6E\\u5B8C\\u6BD5\\uFF0C\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u7B2Cj\\u4F4D\\u7684\\u4E2A\\u6570\\n  // \\u6BD4\\u5982d[3][0] \\u8868\\u793A\\u57280\\uFF0C1\\uFF0C2\\uFF0C3\\u4E2D\\u5DF2\\u7ECF\\u9009\\u62E9\\u4E86\\u4E09\\u4E2A\\u6570\\u5B57\\uFF0C\\u6309\\u7167DID\\u7684\\u8981\\u6C42\\u5DF2\\u7ECF\\u653E\\u7F6E\\u5B8C\\u6BD5\\u4E86\\uFF0C\\u7136\\u540E\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u6570\\u5B57\\n  for (let i = 0; i <= len; i++) {\\n    dp[i] = [];\\n  }\\n  // \\u56E0\\u4E3A\\u67090\\uFF0C1\\uFF0C2\\uFF0C3 \\u56DB\\u4E2A\\u6570\\u5B57\\n  // dp[0][0] = 1, [0]\\n  // dp[0][1] = 1, [1]\\n  // dp[0][2] = 1, [2]\\n  // dp[0][3] = 1, [3]\\n  for (let i = 0; i <= len; i++) {\\n    dp[0][i] = 1;\\n  }\\n  // \\u8BA1\\u7B97dp[len][0]\\n  for (let i = 0; i < len; i++) {\\n    if (S.charAt(i) == \"I\") {\\n      // \\u56E0\\u4E3A\\u5DF2\\u7ECF\\u6709i\\u4E2A\\u6570\\u5B57\\u5DF2\\u7ECF\\u88AB\\u653E\\u7F6E\\u597D\\u4E86\\n      // \\u6BD4\\u5982\\u5F53i=0\\u7684\\u65F6\\u5019\\uFF0C\\u4E00\\u5171\\u9700\\u8981\\u653E0\\uFF0C1\\uFF0C2\\uFF0C3\\uFF0Ci=0\\uFF0C\\u5C31\\u662F\\u5DF2\\u7ECF0\\u7684\\u4F4D\\u7F6E\\u4E0A\\u5DF2\\u7ECF\\u653E\\u7F6E\\u4E86\\u4E00\\u4E2A\\u4E86\\uFF0C\\n      // \\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD8\\u6709\\u4E09\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\u4E5F\\u5C31\\u662Flen-i\\n      for (let j = 0, cur = 0; j < len - i; j++) {\\n        // \\u53D6\\u6A21\\n        cur = cur + dp[i][j];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    } else {\\n      // \\u5F53S.charAt(i) == \"D\"\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u5C31\\u662F\\u9700\\u8981\\u964D\\u5E8F\\uFF0C\\n      // \\u6BD4\\u5982\\u67090\\uFF0C 1\\uFF0C2\\uFF0C3\\uFF0C \\u5982\\u679C\\u9700\\u8981\\u653E\\u7F6Edp[1][2],\\u5219\\u53EA\\u6709\\u4E00\\u79CD\\u53EF\\u80FD\\uFF0C\\u90A3\\u5C31\\u662F\\u7B49\\u4E8Edp[0][3],\\n      // \\u4E0D\\u7136\\u5982\\u679C\\u653E\\u7F6E\\u4E86dp[1][2]\\u7684\\u65F6\\u5019\\uFF0C\\u57282\\u7684\\u4F4D\\u7F6E\\u653E\\u7F6E\\u7684\\u5143\\u7D20\\u80AF\\u5B9A\\u6BD4\\u524D\\u9762\\u7684\\u5927\\uFF0C\\u4E5F\\u5C31\\u662F\\u4E0D\\u7B26\\u5408S.charAt(i) == \"D\"\\n      for (let j = len - i - 1, cur = 0; j >= 0; j--) {\\n        cur = cur + dp[i][j + 1];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    }\\n  }\\n  return dp[len][0];\\n};\\n\\n \\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string} S\\n * @return {number}\\n */\\nexport default (S) => {\\n  let dp = [];\\n  const len = S.length;\\n  const mod = Math.pow(10, 9) + 7;\\n  // S=DID\\n  // len = 4,\\u6240\\u4EE5\\u8FD9\\u91CC\\u67090\\uFF0C1\\uFF0C2\\uFF0C3\\u56DB\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\n  // dp[i][j] \\u8868\\u793Ai\\u4E2A\\u6570\\u5B57\\u653E\\u7F6E\\u5B8C\\u6BD5\\uFF0C\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u7B2Cj\\u4F4D\\u7684\\u4E2A\\u6570\\n  // \\u6BD4\\u5982d[3][0] \\u8868\\u793A\\u57280\\uFF0C1\\uFF0C2\\uFF0C3\\u4E2D\\u5DF2\\u7ECF\\u9009\\u62E9\\u4E86\\u4E09\\u4E2A\\u6570\\u5B57\\uFF0C\\u6309\\u7167DID\\u7684\\u8981\\u6C42\\u5DF2\\u7ECF\\u653E\\u7F6E\\u5B8C\\u6BD5\\u4E86\\uFF0C\\u7136\\u540E\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u6570\\u5B57\\n  for (let i = 0; i <= len; i++) {\\n    dp[i] = [];\\n  }\\n  // \\u56E0\\u4E3A\\u67090\\uFF0C1\\uFF0C2\\uFF0C3 \\u56DB\\u4E2A\\u6570\\u5B57\\n  // dp[0][0] = 1, [0]\\n  // dp[0][1] = 1, [1]\\n  // dp[0][2] = 1, [2]\\n  // dp[0][3] = 1, [3]\\n  for (let i = 0; i <= len; i++) {\\n    dp[0][i] = 1;\\n  }\\n  // \\u8BA1\\u7B97dp[len][0]\\n  for (let i = 0; i < len; i++) {\\n    if (S.charAt(i) == \"I\") {\\n      // \\u56E0\\u4E3A\\u5DF2\\u7ECF\\u6709i\\u4E2A\\u6570\\u5B57\\u5DF2\\u7ECF\\u88AB\\u653E\\u7F6E\\u597D\\u4E86\\n      // \\u6BD4\\u5982\\u5F53i=0\\u7684\\u65F6\\u5019\\uFF0C\\u4E00\\u5171\\u9700\\u8981\\u653E0\\uFF0C1\\uFF0C2\\uFF0C3\\uFF0Ci=0\\uFF0C\\u5C31\\u662F\\u5DF2\\u7ECF0\\u7684\\u4F4D\\u7F6E\\u4E0A\\u5DF2\\u7ECF\\u653E\\u7F6E\\u4E86\\u4E00\\u4E2A\\u4E86\\uFF0C\\n      // \\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD8\\u6709\\u4E09\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\u4E5F\\u5C31\\u662Flen-i\\n      for (let j = 0, cur = 0; j < len - i; j++) {\\n        // \\u53D6\\u6A21\\n        cur = cur + dp[i][j];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    } else {\\n      // \\u5F53S.charAt(i) == \"D\"\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u5C31\\u662F\\u9700\\u8981\\u964D\\u5E8F\\uFF0C\\n      // \\u6BD4\\u5982\\u67090\\uFF0C 1\\uFF0C2\\uFF0C3\\uFF0C \\u5982\\u679C\\u9700\\u8981\\u653E\\u7F6Edp[1][2],\\u5219\\u53EA\\u6709\\u4E00\\u79CD\\u53EF\\u80FD\\uFF0C\\u90A3\\u5C31\\u662F\\u7B49\\u4E8Edp[0][3],\\n      // \\u4E0D\\u7136\\u5982\\u679C\\u653E\\u7F6E\\u4E86dp[1][2]\\u7684\\u65F6\\u5019\\uFF0C\\u57282\\u7684\\u4F4D\\u7F6E\\u653E\\u7F6E\\u7684\\u5143\\u7D20\\u80AF\\u5B9A\\u6BD4\\u524D\\u9762\\u7684\\u5927\\uFF0C\\u4E5F\\u5C31\\u662F\\u4E0D\\u7B26\\u5408S.charAt(i) == \"D\"\\n      for (let j = len - i - 1, cur = 0; j >= 0; j--) {\\n        cur = cur + dp[i][j + 1];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    }\\n  }\\n  return dp[len][0];\\n};\\n\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564801,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long giveres(int pos,int len,int choto, vector<vector<long long>>&dp,string &s){\\n        if(pos==len)\\n            return 1ll;\\n        long long &ret = dp[pos][choto];\\n        if(ret!=-1)\\n            return ret;\\n        ret = 0;\\n        if(s[pos-1]==\\'D\\'){\\n            for(int i = 1;i<=choto;i++){\\n                ret += giveres(pos+1,len,i-1,dp,s);\\n                if(ret>=mod)\\n                    ret%=-mod;\\n            }\\n        }\\n        else {\\n            for(int i = 1;i<=len-pos-choto;i++){\\n                ret += giveres(pos+1,len,i-1+choto,dp,s);\\n                if(ret>=mod)\\n                    ret %= mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    int numPermsDISequence(string S) {\\n        int len = S.size();\\n        vector<vector<long long>>dp(len+5,vector<long long>(len+5,-1));\\n        long long ans = 0;\\n        for(int i = 1;i<=len+1;i++){\\n            ans += giveres(1,len+1,i-1,dp,S);\\n            if(ans >= mod)\\n                ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long giveres(int pos,int len,int choto, vector<vector<long long>>&dp,string &s){\\n        if(pos==len)\\n            return 1ll;\\n        long long &ret = dp[pos][choto];\\n        if(ret!=-1)\\n            return ret;\\n        ret = 0;\\n        if(s[pos-1]==\\'D\\'){\\n            for(int i = 1;i<=choto;i++){\\n                ret += giveres(pos+1,len,i-1,dp,s);\\n                if(ret>=mod)\\n                    ret%=-mod;\\n            }\\n        }\\n        else {\\n            for(int i = 1;i<=len-pos-choto;i++){\\n                ret += giveres(pos+1,len,i-1+choto,dp,s);\\n                if(ret>=mod)\\n                    ret %= mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    int numPermsDISequence(string S) {\\n        int len = S.size();\\n        vector<vector<long long>>dp(len+5,vector<long long>(len+5,-1));\\n        long long ans = 0;\\n        for(int i = 1;i<=len+1;i++){\\n            ans += giveres(1,len+1,i-1,dp,S);\\n            if(ans >= mod)\\n                ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494725,
                "title": "rust-0ms-2-1mb-100",
                "content": "```rust\\n// translated from https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)\\npub fn num_perms_di_sequence(s: String) -> i32 {\\n    const MOD: i32 = 1_000_000_007;\\n    let n = s.len();\\n    let mut dp = vec![1; n + 1];\\n    let mut dp2 = vec![0; n];\\n//    println!(\"{:?}\", dp);\\n    for i in 0..n {\\n        if s[i..].chars().next().unwrap() == \\'I\\' {\\n            let mut cur = 0;\\n            for j in 0..n - i\\n            {\\n                cur = (cur + dp[j]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        } else {\\n            let mut cur = 0;\\n            for j in (0..n - i).rev() {\\n                cur = (cur + dp[j + 1]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        }\\n        dp[..n].copy_from_slice(&dp2[..n]);\\n//        println!(\"{:?}\", dp);\\n    }\\n    dp[0]\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n// translated from https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)\\npub fn num_perms_di_sequence(s: String) -> i32 {\\n    const MOD: i32 = 1_000_000_007;\\n    let n = s.len();\\n    let mut dp = vec![1; n + 1];\\n    let mut dp2 = vec![0; n];\\n//    println!(\"{:?}\", dp);\\n    for i in 0..n {\\n        if s[i..].chars().next().unwrap() == \\'I\\' {\\n            let mut cur = 0;\\n            for j in 0..n - i\\n            {\\n                cur = (cur + dp[j]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        } else {\\n            let mut cur = 0;\\n            for j in (0..n - i).rev() {\\n                cur = (cur + dp[j + 1]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        }\\n        dp[..n].copy_from_slice(&dp2[..n]);\\n//        println!(\"{:?}\", dp);\\n    }\\n    dp[0]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443745,
                "title": "python3-divide-and-conquer-solution-slightly-quicker-than-official-divide-and-conquer-solution",
                "content": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    @lru_cache(maxsize=None)\\n    def nCk(self, n, k):\\n        if k == 1: return n\\n        if k == 0 or n == k: return 1\\n        return self.nCk(n - 1, k - 1) + self.nCk(n - 1, k)\\n\\n    @lru_cache(maxsize=None)\\n    def numPermsDISequence(self, s: str) -> int:\\n        if len(s) <= 1: return 1\\n        n = len(s) + 1\\n        ans = 0\\n\\t\\t#Insert max number in every \\'DI\\' part, left and right part are choosed from left numbers\\n        for i in range(n - 1):\\n            if s[i:i + 2] == \\'ID\\': ans += self.nCk(n - 1, i + 1) * self.numPermsDISequence(s[:i]) * self.numPermsDISequence(s[i + 2:])\\n\\t\\t#Insert max number at start position if s[0] == \\'D\\'\\n        if s[0] == \\'D\\': ans += self.numPermsDISequence(s[1: n - 1])\\n\\t\\t#Same insert max number at end\\n        if s[n - 2] == \\'I\\': ans += self.numPermsDISequence(s[: n - 2])\\n        return ans % self.mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    @lru_cache(maxsize=None)\\n    def nCk(self, n, k):\\n        if k == 1: return n\\n        if k == 0 or n == k: return 1\\n        return self.nCk(n - 1, k - 1) + self.nCk(n - 1, k)\\n\\n    @lru_cache(maxsize=None)\\n    def numPermsDISequence(self, s: str) -> int:\\n        if len(s) <= 1: return 1\\n        n = len(s) + 1\\n        ans = 0\\n\\t\\t#Insert max number in every \\'DI\\' part, left and right part are choosed from left numbers\\n        for i in range(n - 1):\\n            if s[i:i + 2] == \\'ID\\': ans += self.nCk(n - 1, i + 1) * self.numPermsDISequence(s[:i]) * self.numPermsDISequence(s[i + 2:])\\n\\t\\t#Insert max number at start position if s[0] == \\'D\\'\\n        if s[0] == \\'D\\': ans += self.numPermsDISequence(s[1: n - 1])\\n\\t\\t#Same insert max number at end\\n        if s[n - 2] == \\'I\\': ans += self.numPermsDISequence(s[: n - 2])\\n        return ans % self.mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436007,
                "title": "python-dp",
                "content": "dp  \\n**Subproblem definition**:  dp[n][j] = number of permutations or [0,1,2,3,4,5,..., n-2, n-1] that end with j \\n**How many subproblems** O(n^2)\\n**Recurrence** \\n1. dp[n][j] = sigma dp[n-1][b] for all a < j if the last evolution is an increase\\n2. dp[n][j] = sigma dp[n-1][a] for all j <=b < n - 1  if the last evolution is an increase\\n\\n\\n**Time per subproblem** O(n)\\n**Final Answer** sigma dp[n][j] for j in [0,1,2,3,..., n-2,n-1]\\n\\n\\n\\n\\n\\n\\n\\n```\\nMOD  = 10 ** 9 + 7\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        mem, nn = {}, len(S) + 1\\n        res = 0\\n        for n in range(1, nn + 1):\\n            for j in range(n):\\n                r = self.f(n, j, S, mem)\\n                if n == nn:\\n                    res += r\\n                    res %= MOD\\n        return res\\n    \\n    \\n    def f(self, n, j, s, mem):\\n        # if n == 0 : return 0\\n        if n == 1:  return 1 if j == 0 else 0\\n        if (n,j) not in mem:\\n            mem[(n,j)] = sum([self.f(n - 1, a, s, mem) for a in range(j,n - 1)] or [0]) % MOD if s[n - 2] == \\'D\\' else sum([self.f(n - 1, b, s, mem) for b in range(j)] or [0]) % MOD\\n        return mem[(n,j)] \\n```",
                "solutionTags": [],
                "code": "```\\nMOD  = 10 ** 9 + 7\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        mem, nn = {}, len(S) + 1\\n        res = 0\\n        for n in range(1, nn + 1):\\n            for j in range(n):\\n                r = self.f(n, j, S, mem)\\n                if n == nn:\\n                    res += r\\n                    res %= MOD\\n        return res\\n    \\n    \\n    def f(self, n, j, s, mem):\\n        # if n == 0 : return 0\\n        if n == 1:  return 1 if j == 0 else 0\\n        if (n,j) not in mem:\\n            mem[(n,j)] = sum([self.f(n - 1, a, s, mem) for a in range(j,n - 1)] or [0]) % MOD if s[n - 2] == \\'D\\' else sum([self.f(n - 1, b, s, mem) for b in range(j)] or [0]) % MOD\\n        return mem[(n,j)] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 404899,
                "title": "i-have-a-question",
                "content": "these solutions seem like that they don\\'t consider the repetition pattern like that:\\nwhen input is: DID\\nwe all know that (3, 0, 2, 1) is valid\\nhowever, just use the dp way, dp[m][n] = sum(dp[m - 1][j < n when input[pos] == \\'D\\']) or \\ndp[m][n] = sum(dp[m - 1][j > n when input[pos] == \\'I\\'] can\\'t guarantee the pattern (3, 0, 3, 1)happen\\ncause the result can be larger than we expect!!\\n",
                "solutionTags": [],
                "code": "these solutions seem like that they don\\'t consider the repetition pattern like that:\\nwhen input is: DID\\nwe all know that (3, 0, 2, 1) is valid\\nhowever, just use the dp way, dp[m][n] = sum(dp[m - 1][j < n when input[pos] == \\'D\\']) or \\ndp[m][n] = sum(dp[m - 1][j > n when input[pos] == \\'I\\'] can\\'t guarantee the pattern (3, 0, 3, 1)happen\\ncause the result can be larger than we expect!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 356234,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, s):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s) + 1\\n        dp = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        dp[0][0] = 1\\n        for i in xrange(1,n):\\n            for j in xrange(i + 1):\\n                if s[i - 1] == \\'D\\':\\n                    for k in xrange(j,i):\\n                        dp[i][j] += dp[i - 1][k]\\n                elif s[i - 1] == \\'I\\':\\n                    for k in xrange(j):\\n                        dp[i][j] += dp[i - 1][k]\\n        return sum(dp[-1]) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, s):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s) + 1\\n        dp = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        dp[0][0] = 1\\n        for i in xrange(1,n):\\n            for j in xrange(i + 1):\\n                if s[i - 1] == \\'D\\':\\n                    for k in xrange(j,i):\\n                        dp[i][j] += dp[i - 1][k]\\n                elif s[i - 1] == \\'I\\':\\n                    for k in xrange(j):\\n                        dp[i][j] += dp[i - 1][k]\\n        return sum(dp[-1]) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343312,
                "title": "share-my-python3-solutions-with-o-n-3-and-o-n-2",
                "content": "(1)O(n^3):\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        if S[0] == \\'D\\':\\n            dp[1][0] = 1\\n        elif S[0] == \\'I\\':\\n            dp[1][1] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    for k in range(j, i):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n                elif S[i-1] == \\'I\\':\\n                    for k in range(0, j):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n\\n        ret = 0\\n        for k in range(n+1):\\n            ret += dp[n][k]\\n            ret %= mod\\n\\n        return ret\\n```\\n\\n(2) O(n^2): using prefix sum to optimize\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        dp[0][0] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][i-1] - dp[i-1][j-1] + dp[i][j-1]) % mod\\n                    else:\\n                        dp[i][j] = dp[i-1][i-1]\\n                elif S[i-1] == \\'I\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % mod\\n        \\n        return dp[n][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        if S[0] == \\'D\\':\\n            dp[1][0] = 1\\n        elif S[0] == \\'I\\':\\n            dp[1][1] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    for k in range(j, i):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n                elif S[i-1] == \\'I\\':\\n                    for k in range(0, j):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n\\n        ret = 0\\n        for k in range(n+1):\\n            ret += dp[n][k]\\n            ret %= mod\\n\\n        return ret\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        dp[0][0] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][i-1] - dp[i-1][j-1] + dp[i][j-1]) % mod\\n                    else:\\n                        dp[i][j] = dp[i-1][i-1]\\n                elif S[i-1] == \\'I\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % mod\\n        \\n        return dp[n][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317865,
                "title": "golang-dp-solution-o-n-2",
                "content": "I believe that everyone knows the following formula when **S[i-1] is \"D\"**,\\n```\\ndp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\\nSo,\\n```\\ndp[i][j-1] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\\n\\nAccordingly,\\n```\\ndp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n```\\nPlease note that dp[i][j-1] could be less than dp[i-1][j-1], because each intermediate result is modulo 1000000007, so we need to change the above formula a little bit as below for safety,\\n```\\ndp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n```\\n\\nSimilarly, we can easily get the following formula when S[i-1] is \"I\",\\n```\\ndp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n```\\n\\nSo the final solution is as below,\\n\\n```\\nfunc numPermsDISequence(S string) int {\\n    MOD := 1000000007\\n    N := len(S)\\n    dp := make([][]int, N+1)\\n    for i:=0; i<=N; i++ {\\n        dp[i] = make([]int, N+1)\\n    }\\n    \\n    for i:=0; i<=N; i++{\\n        dp[0][i] = 1\\n    }\\n    \\n    for i:=1; i<=N; i++ {\\n        for j:=0; j<=i; j++ {\\n            if S[i-1] == \\'D\\' {\\n                if j == 0 {\\n                    for k:=j; k<i; k++ {\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= MOD\\n                    }\\n                } else {\\n                    if dp[i][j-1] < dp[i-1][j-1] {\\n                        dp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n                    } else {\\n                        dp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n                    }\\n                    dp[i][j] %= MOD \\n                }\\n            } else {\\n                if j > 0 {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n                    dp[i][j] %= MOD\\n                }\\n            }\\n        }\\n    }\\n    \\n    ret := 0\\n    for i:=0; i<=N; i++ {\\n        ret += dp[N][i]\\n        ret %= MOD\\n    }\\n    \\n    return ret\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\n```\\ndp[i][j-1] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n```\n```\\nfunc numPermsDISequence(S string) int {\\n    MOD := 1000000007\\n    N := len(S)\\n    dp := make([][]int, N+1)\\n    for i:=0; i<=N; i++ {\\n        dp[i] = make([]int, N+1)\\n    }\\n    \\n    for i:=0; i<=N; i++{\\n        dp[0][i] = 1\\n    }\\n    \\n    for i:=1; i<=N; i++ {\\n        for j:=0; j<=i; j++ {\\n            if S[i-1] == \\'D\\' {\\n                if j == 0 {\\n                    for k:=j; k<i; k++ {\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= MOD\\n                    }\\n                } else {\\n                    if dp[i][j-1] < dp[i-1][j-1] {\\n                        dp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n                    } else {\\n                        dp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n                    }\\n                    dp[i][j] %= MOD \\n                }\\n            } else {\\n                if j > 0 {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n                    dp[i][j] %= MOD\\n                }\\n            }\\n        }\\n    }\\n    \\n    ret := 0\\n    for i:=0; i<=N; i++ {\\n        ret += dp[N][i]\\n        ret %= MOD\\n    }\\n    \\n    return ret\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308917,
                "title": "can-any-one-explain-the-proof-to-calculate-the-module-of-combination-in-the-second-solution",
                "content": "Can anyone please explain why we calculate inverse of factorial as pow(f, MOD-2, MOD) ? Thanks a lot.\\n\\n```\\n        facinv = [pow(f, MOD-2, MOD) for f in fac]\\n\\n        def binom(n, k):\\n            return fac[n] * facinv[n-k] % MOD * facinv[k] % MOD\\n```",
                "solutionTags": [],
                "code": "```\\n        facinv = [pow(f, MOD-2, MOD) for f in fac]\\n\\n        def binom(n, k):\\n            return fac[n] * facinv[n-k] % MOD * facinv[k] % MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 298593,
                "title": "c-beats-100-8ms-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        \\n\\tint max = S.size();\\n        if(max == 1)\\n            return 1;\\n\\tvector<long long> last(max + 1); // last[i] means when the end is i, the number of available\\n\\tif (S.at(0) == \\'D\\') {\\n\\t\\tlast[0] = 1;  \\n\\t} else {\\n\\t\\tlast[1] = 1;\\n\\t}\\n\\t\\n\\tfor (int i = 1; i < max; i++) { //i+1 means the len of array\\n\\t\\tif (S.at(i) == \\'D\\') {\\n\\t\\t\\tlast[i+1] = 0;\\n\\t\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\t\\tlast[j] = (last[j+1] + last[j]) % 1000000007; // last(i, j) = last(i-1, j) + last(i, j+1) ; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tlong long temp = last[0];\\n\\t\\t\\tlast[0] = 0;\\n\\t\\t\\tfor (int j = 1; j <= i + 1; j++) {\\n\\t\\t\\t\\tlong long x = last[j];\\n\\t\\t\\t\\tlast[j] = (temp + last[j - 1]) % 1000000007; //last(i, j) = last(i - 1, j - 1) + last(i, j - 1);\\n\\t\\t\\t\\ttemp = x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long ans = 0;\\n\\tfor (long long x : last)\\n\\t\\tans += x;\\n\\treturn ans % 1000000007;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        \\n\\tint max = S.size();\\n        if(max == 1)\\n            return 1;\\n\\tvector<long long> last(max + 1); // last[i] means when the end is i, the number of available\\n\\tif (S.at(0) == \\'D\\') {\\n\\t\\tlast[0] = 1;  \\n\\t} else {\\n\\t\\tlast[1] = 1;\\n\\t}\\n\\t\\n\\tfor (int i = 1; i < max; i++) { //i+1 means the len of array\\n\\t\\tif (S.at(i) == \\'D\\') {\\n\\t\\t\\tlast[i+1] = 0;\\n\\t\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\t\\tlast[j] = (last[j+1] + last[j]) % 1000000007; // last(i, j) = last(i-1, j) + last(i, j+1) ; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tlong long temp = last[0];\\n\\t\\t\\tlast[0] = 0;\\n\\t\\t\\tfor (int j = 1; j <= i + 1; j++) {\\n\\t\\t\\t\\tlong long x = last[j];\\n\\t\\t\\t\\tlast[j] = (temp + last[j - 1]) % 1000000007; //last(i, j) = last(i - 1, j - 1) + last(i, j - 1);\\n\\t\\t\\t\\ttemp = x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long ans = 0;\\n\\tfor (long long x : last)\\n\\t\\tans += x;\\n\\treturn ans % 1000000007;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213523,
                "title": "c-dp-solution-o-n-2",
                "content": "```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        /**\\n            \\u72B6\\u6001\\u5B9A\\u4E49\\uFF1A   \\u8BBE f(i,j) \\u662F\\u5E8F\\u5217<0..i>\\u4EE5 \"\\u7B2Cj\\u5C0F\\u5143\\u7D20\" \\u4E3A\\u5C3E\\u65F6\\u7684\\u6709\\u6548\\u5E8F\\u5217\\u6570, 0<=j<=i\\n            \\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1A   f(i,j) = sum{ f(i-1,k) }, k < j \\u6216 k > j\\n            \\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A   f(0,0) = 1\\n        **/\\n        int n = S.size();\\n        vector<int> dp(n+1,0), sum(n+1,0), aux(n+1,0);\\n        sum[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            aux[0] = dp[0] = S[i-1]==\\'I\\' ? 0 : sum[i-1];\\n            for (int j = 1; j <= i; j++) {\\n                dp[j]  = S[i-1]==\\'I\\' ? sum[j-1] : (sum[i-1]-sum[j-1]+MOD)%MOD; \\n                aux[j] = (aux[j-1] + dp[j]) % MOD;\\n            }\\n            swap(aux, sum);\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        /**\\n            \\u72B6\\u6001\\u5B9A\\u4E49\\uFF1A   \\u8BBE f(i,j) \\u662F\\u5E8F\\u5217<0..i>\\u4EE5 \"\\u7B2Cj\\u5C0F\\u5143\\u7D20\" \\u4E3A\\u5C3E\\u65F6\\u7684\\u6709\\u6548\\u5E8F\\u5217\\u6570, 0<=j<=i\\n            \\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1A   f(i,j) = sum{ f(i-1,k) }, k < j \\u6216 k > j\\n            \\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A   f(0,0) = 1\\n        **/\\n        int n = S.size();\\n        vector<int> dp(n+1,0), sum(n+1,0), aux(n+1,0);\\n        sum[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            aux[0] = dp[0] = S[i-1]==\\'I\\' ? 0 : sum[i-1];\\n            for (int j = 1; j <= i; j++) {\\n                dp[j]  = S[i-1]==\\'I\\' ? sum[j-1] : (sum[i-1]-sum[j-1]+MOD)%MOD; \\n                aux[j] = (aux[j-1] + dp[j]) % MOD;\\n            }\\n            swap(aux, sum);\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211592,
                "title": "c-o-n-3",
                "content": "```\\nint numPermsDISequence(string S) {\\n   const long long mod = 1e9 + 7;\\n   vector<long long> pre(S.size() + 1, 1), cur;\\n   for (auto c : S) {\\n      cur = vector<long long>(pre.size() - 1);\\n      for (int j = 0; j < pre.size(); j++) {\\n         for (int k = 0; k < pre.size(); k++) {\\n            if (c == \\'D\\' && k >= j) continue;\\n            if (c == \\'I\\' && k <= j) continue;\\n            auto k1 = k > j ? k - 1 : k;\\n            cur[k1] += pre[j]; cur[k1] %= mod;\\n         }\\n      }\\n      pre = move(cur);\\n   }\\n   return accumulate(pre.begin(), pre.end(), 0ll) % mod;\\n}",
                "solutionTags": [],
                "code": "```\\nint numPermsDISequence(string S) {\\n   const long long mod = 1e9 + 7;\\n   vector<long long> pre(S.size() + 1, 1), cur;\\n   for (auto c : S) {\\n      cur = vector<long long>(pre.size() - 1);\\n      for (int j = 0; j < pre.size(); j++) {\\n         for (int k = 0; k < pre.size(); k++) {\\n            if (c == \\'D\\' && k >= j) continue;\\n            if (c == \\'I\\' && k <= j) continue;\\n            auto k1 = k > j ? k - 1 : k;\\n            cur[k1] += pre[j]; cur[k1] %= mod;\\n         }\\n      }\\n      pre = move(cur);\\n   }\\n   return accumulate(pre.begin(), pre.end(), 0ll) % mod;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 209226,
                "title": "python-o-n-2-and-o-n-space-96-63",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        l, r = 0, len(S)+1\\n        dp =  [1] * r\\n        for j in S:\\n            new = [0] * r\\n            if j == \\'D\\':\\n                r -= 1\\n                for u in range(r-1,l-1,-1):\\n                    new[u] = new[u+1] + dp[u+1]\\n            elif j == \\'I\\':\\n                l += 1\\n                for u in range(l,r):\\n                    new[u] = new[u-1] + dp[u-1]\\n            dp = new\\n        return dp[l] % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        l, r = 0, len(S)+1\\n        dp =  [1] * r\\n        for j in S:\\n            new = [0] * r\\n            if j == \\'D\\':\\n                r -= 1\\n                for u in range(r-1,l-1,-1):\\n                    new[u] = new[u+1] + dp[u+1]\\n            elif j == \\'I\\':\\n                l += 1\\n                for u in range(l,r):\\n                    new[u] = new[u-1] + dp[u-1]\\n            dp = new\\n        return dp[l] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199444,
                "title": "10-lines-c-time-o-n-2-space-o-n-with-remark",
                "content": "```C++\\n// K(s, x) = nums of perms with tail ranking x\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// G(s, 0) = 0\\n// G(s, x) = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len) = G(s, s.len + 1) - G(s, x)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1) = G(s, x)\\n\\n// G(s, x + 1) = G(s, x) + K(s, x)\\n\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        vector<int64_t> G = {0, 1};\\n        \\n        for (int s_len = 0; s_len < S.size(); ++s_len) {\\n            vector<int64_t> nG = {0};\\n            \\n            for (int x = 0; x <= s_len + 1; ++x) {\\n                int64_t k = S[s_len] == \\'I\\' ? G[s_len + 1] - G[x] : G[x];\\n                nG.push_back((nG.back() + k + 1000000007) % 1000000007);\\n            }\\n            \\n            G.swap(nG);\\n        }\\n        \\n        return G[S.size() + 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n// K(s, x) = nums of perms with tail ranking x\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// G(s, 0) = 0\\n// G(s, x) = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len) = G(s, s.len + 1) - G(s, x)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1) = G(s, x)\\n\\n// G(s, x + 1) = G(s, x) + K(s, x)\\n\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        vector<int64_t> G = {0, 1};\\n        \\n        for (int s_len = 0; s_len < S.size(); ++s_len) {\\n            vector<int64_t> nG = {0};\\n            \\n            for (int x = 0; x <= s_len + 1; ++x) {\\n                int64_t k = S[s_len] == \\'I\\' ? G[s_len + 1] - G[x] : G[x];\\n                nG.push_back((nG.back() + k + 1000000007) % 1000000007);\\n            }\\n            \\n            G.swap(nG);\\n        }\\n        \\n        return G[S.size() + 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191960,
                "title": "java-beats-100",
                "content": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        if (S == null) {\\n            return 0;\\n        }\\n        int mod = (int) 1e9 + 7;\\n        int n = S.length() + 1;\\n        int[][] memo = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            memo[i][0] = 1;\\n        }\\n        int acc = 0;\\n        int up = 0;\\n        int down = S.length();\\n        for (int j = 1; j < n; j++) {\\n            if (S.charAt(j - 1) == \\'I\\') {\\n                up++;\\n                for (int i = up; i <= down; i++) {\\n                    memo[i][j] = (memo[i - 1][j] + memo[i - 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            } else {\\n                down--;\\n                for (int i = down; i >= up; i--) {\\n                    memo[i][j] = (memo[i + 1][j] + memo[i + 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        if (S == null) {\\n            return 0;\\n        }\\n        int mod = (int) 1e9 + 7;\\n        int n = S.length() + 1;\\n        int[][] memo = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            memo[i][0] = 1;\\n        }\\n        int acc = 0;\\n        int up = 0;\\n        int down = S.length();\\n        for (int j = 1; j < n; j++) {\\n            if (S.charAt(j - 1) == \\'I\\') {\\n                up++;\\n                for (int i = up; i <= down; i++) {\\n                    memo[i][j] = (memo[i - 1][j] + memo[i - 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            } else {\\n                down--;\\n                for (int i = down; i >= up; i--) {\\n                    memo[i][j] = (memo[i + 1][j] + memo[i + 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168647,
                "title": "c-stl-partial-sum-0ms",
                "content": "    class Solution {\\n    public:\\n        int numPermsDISequence(string S) {\\n            int n = S.size() + 1, d = 0, i = 0;\\n            vector<int> arr(n, 1);\\n            auto func = [](int a, int b) { return (a + b) % 1000000007; };\\n            for (char c : S) {\\n                if (c == \\'D\\') {\\n                    ++d;\\n                    partial_sum(arr.rbegin() + i, arr.rend() - d, arr.rbegin() + i, func);\\n                } else {\\n                    ++i;\\n                    partial_sum(arr.begin() + d, arr.end() - i, arr.begin() + d, func);\\n                }\\n            }\\n            return *(arr.begin() + d);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numPermsDISequence(string S) {\\n            int n = S.size() + 1, d = 0, i = 0;\\n            vector<int> arr(n, 1);\\n            auto func = [](int a, int b) { return (a + b) % 1000000007; }",
                "codeTag": "Java"
            },
            {
                "id": 168477,
                "title": "c-dp-solution-o-n-3-can-modify-to-o-n-2-with-some-thinking-process",
                "content": "It\\'s a \\'find a pattern\\' problem, but when you try to generate a dp formular, you first try to find a recursion formular. \\nIt basically uses an idea of mapping, if you use a 0, and you can reuse the result of 01234(for some thing like 4 char S \"DIDI\") as the result of 12345 (for some thing like 4 char S \"DIDI\") as the have same increase decrease pattern. So IDID  can be recusivaly caculated by I + DID.  You just think every possible starting num and find the correct count recusively.\\nThen you probably just want to find a dp pattern, the rule may change on some corner case as if you currently use a num, your next num (serve as a start num for a subproblem) is limited. But they do have a general pattern if you write down a 2d dp. I use a 2D dp and do it backward base on my recusion idea. You can presum or sum in for loop but I just leave it N^3.\\n```\\nint numPermsDISequence(string S) {\\n    \\n    vector<vector<long>> dp(S.size()+1,vector<long>(S.size(),0));\\n    int m = 1000000007;\\n    int n = S.size();\\n    \\n    if (S[n-1] == \\'D\\') {\\n        dp[0][n-1] = 0;\\n        dp[1][n-1] = 1;\\n    } else {\\n        dp[0][n-1] = 1;\\n        dp[1][n-1] = 0;\\n    }\\n    \\n    for (int j = n-2; j >= 0; j--) {\\n        if (S[j] == \\'D\\') {\\n            for (int i = 0; i <= n-j; i++) {\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= n-j ; i++) {\\n                for (int k = i; k < n-j; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long result = 0;\\n    for (int i = 0; i <= n; i++) {\\n        result += dp[i][0];\\n        result %= m;\\n    }\\n    \\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numPermsDISequence(string S) {\\n    \\n    vector<vector<long>> dp(S.size()+1,vector<long>(S.size(),0));\\n    int m = 1000000007;\\n    int n = S.size();\\n    \\n    if (S[n-1] == \\'D\\') {\\n        dp[0][n-1] = 0;\\n        dp[1][n-1] = 1;\\n    } else {\\n        dp[0][n-1] = 1;\\n        dp[1][n-1] = 0;\\n    }\\n    \\n    for (int j = n-2; j >= 0; j--) {\\n        if (S[j] == \\'D\\') {\\n            for (int i = 0; i <= n-j; i++) {\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= n-j ; i++) {\\n                for (int k = i; k < n-j; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long result = 0;\\n    for (int i = 0; i <= n; i++) {\\n        result += dp[i][0];\\n        result %= m;\\n    }\\n    \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168384,
                "title": "c-o-n-2-solution-with-only-one-1d-array-extremely-intuitive-detailed-thought-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int MOD = 1e9 + 7;\\n        deque<int> memo;\\n        memo.push_back(1);\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'D\\') {\\n                memo.push_back(0);\\n                for (int j = i; j >= 0; j--) {\\n                    memo[j] = (memo[j] + memo[j + 1]) % MOD;\\n                }\\n            } else {\\n                assert(S[i] == \\'I\\');\\n                memo.push_front(0);\\n                for (int j = 1; j <= i + 1; j++) {\\n                    memo[j] = (memo[j] + memo[j - 1]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int num: memo) {\\n            sum = (sum + num) % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nHow you derives the algorithm? Details below.\\n\\n# 1. Determine the parameters for DP\\nLet\\'s say you have already computed numPermsDISequence(3), can you compute numPermsDISequence(4)?\\nWe examine a sequence in numPermsDISequence(3), denoted by [ o o o ]. Imagine there are three pointers pointing to each of the token here. So we want to insert an item into the sequence. Let\\'s say S[4] = \"D\", how many ways can we insert the last item?\\nObviously, this depend on where the last pointer is pointing to. Let\\'s use bold token here to denote the item that the last of the  3 pointers points to, and \"I\" to denote how you insert the 4th item.\\n[ **o** o o ] -> [ I  **o** o o ]       1 way\\n[o **o** o ] -> [ I  o **o** o ]  [ o I **o** o ]       2 ways\\nso on so forth.\\nObviously, the number of ways you can insert the 4th token is dependent on where the 3rd pointer points to. So we need another parameter for DP purpose, which is the index of the last element in the array.\\n\\n# 2. Derive recursive formula\\nNow we have to start from scrach by redefining the function with an additional parameter we just described. Let\\'s say we have numPermsDISequence(3, *j*) for *j* in 0~2, which returns the ways of constructing length=3 sequence whose last element is *j*. For simplicity, Let F(*j*)=numPermsDISequence(3, *j*) and F\\'(*j*)=numPermsDISequence(4, *j*). How do we compute F\\'(*j*)? Again, let\\'s assume S[4] = \"D\".\\n\\nF\\'(0) will produces a sequence of [ I o o o ]. In order for that to happen, the bolden o can be any of the tokens after I. So:\\n\\n[ I **o** o o ]  [ I o **o** o ]  [ I o o  **o** ]\\nF\\'(0) = F(0) + F(1) + F(2)\\n\\nSimilarly, F\\'(1) = F(1) + F(2), F\\'(2) = F(2), F(3) = 0. Note that F(3) = 0 because there is no way you can produce [ o o o I ] no matter what.\\nLet n = 4. You have F\\'(j) = sum(F(k)) for k in j~n. To optimize sum computation, we simply compute from F\\'(n) to F\\'(0), because F\\'(k - 1) = sum( j= k-1 to n) = sum( j = k to n ) + F(k - 1) = F\\'(k) + F(k - 1)\\nIf we already have an array that maintains [ F(0), F(1), F(2) ], for the decreasing case, we only need to append a \"0\" to the **end of the array**, and then recompute F(2) ~ F(0) from **right to left**.\\n[ F(0), F(1), F(2), **F\\'(3) = 0** ]\\n[ F(0), F(1), **F\\'(3) + F(2)**, 0 ]\\n[ F(0), **F\\'(2) + F(1)**, F\\'(3) + F(2), 0 ]\\n[ **F\\'(1) + F(0)**, F\\'(2) + F(1), F\\'(3) + F(2), 0 ]\\n\\nWhen S[4] = \"I\". We simply mirror everything. We will push a 0 in the **start of the array** and then update sums from **left to right**.\\n\\nWe need a data structure to insert/remove an item at the beginning/end of array in O(1) time, and random access in O(1) time. Dynamic array will satisfy this requirement, which is deque in c++.\\n\\n# 3. Compute the result\\n\\nAt the end of the algorithm, numPermsDISequence(4) is simply ways of constructing arrays that the last element end in either 0, 1, 2 or 3. So result(4) = F\\'(0) + F\\'(1) + F\\'(2) + F\\'(3). We can use std::accumulate but due to the MOD requirement we have to compute it manually:(",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int MOD = 1e9 + 7;\\n        deque<int> memo;\\n        memo.push_back(1);\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'D\\') {\\n                memo.push_back(0);\\n                for (int j = i; j >= 0; j--) {\\n                    memo[j] = (memo[j] + memo[j + 1]) % MOD;\\n                }\\n            } else {\\n                assert(S[i] == \\'I\\');\\n                memo.push_front(0);\\n                for (int j = 1; j <= i + 1; j++) {\\n                    memo[j] = (memo[j] + memo[j - 1]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int num: memo) {\\n            sum = (sum + num) % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168300,
                "title": "dynamic-programming-o-n-3-solution",
                "content": "Use a helper function helper(start, end) to record the intermediate result in range [start... end]\\n```\\npublic class Solution {\\n    private static final int MOD = (int)1e9 + 7;\\n    private long[][] mem, c;\\n    private int n;\\n    public int numPermsDISequence(String S) {\\n        n = S.length();\\n        mem = new long[n + 1][n + 1];\\n        c = new long[n + 1][n + 1];\\n        return (int)helper(S, 0, n);\\n    }\\n\\n    private long helper(String s, int start, int end) {\\n        if (start >= end) return 1;\\n        if (mem[start][end] > 0) return mem[start][end];\\n        long res = 0;\\n        for (int i = start; i <= end; ++i) {\\n            boolean leftLess = (i == start) || s.charAt(i - 1) == \\'I\\';\\n            boolean rightLess = (i == end) || s.charAt(i) == \\'D\\';\\n            if (leftLess && rightLess) {\\n                long leftRes = helper(s, start, i - 1), rightRes = helper(s, i + 1, end);\\n                long prod = (leftRes * rightRes) % MOD;\\n                res += Comb(end - start, i - start) * prod;\\n                res %= MOD;\\n            }\\n        }\\n        return mem[start][end] = res;\\n    }\\n\\n    private long Comb(int n, int k) {\\n        if (k == 0 || n == k) return 1;\\n        if (c[n][k] > 0) return c[n][k];\\n        if (n == k) return 1;\\n        return c[n][k] = (Comb(n - 1, k - 1) + Comb(n - 1, k)) % MOD;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private static final int MOD = (int)1e9 + 7;\\n    private long[][] mem, c;\\n    private int n;\\n    public int numPermsDISequence(String S) {\\n        n = S.length();\\n        mem = new long[n + 1][n + 1];\\n        c = new long[n + 1][n + 1];\\n        return (int)helper(S, 0, n);\\n    }\\n\\n    private long helper(String s, int start, int end) {\\n        if (start >= end) return 1;\\n        if (mem[start][end] > 0) return mem[start][end];\\n        long res = 0;\\n        for (int i = start; i <= end; ++i) {\\n            boolean leftLess = (i == start) || s.charAt(i - 1) == \\'I\\';\\n            boolean rightLess = (i == end) || s.charAt(i) == \\'D\\';\\n            if (leftLess && rightLess) {\\n                long leftRes = helper(s, start, i - 1), rightRes = helper(s, i + 1, end);\\n                long prod = (leftRes * rightRes) % MOD;\\n                res += Comb(end - start, i - start) * prod;\\n                res %= MOD;\\n            }\\n        }\\n        return mem[start][end] = res;\\n    }\\n\\n    private long Comb(int n, int k) {\\n        if (k == 0 || n == k) return 1;\\n        if (c[n][k] > 0) return c[n][k];\\n        if (n == k) return 1;\\n        return c[n][k] = (Comb(n - 1, k - 1) + Comb(n - 1, k)) % MOD;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035286,
                "title": "p23-5",
                "content": "Puting n-1 and then putting nth\\nLet\\'s change the definition of dp matrix to make the calculation simple: let\\'s say dp[i][j] represents the number of permutation of number 0, 1, ... , i which ends with j. Also, it represents the answer of s.substring(0, i) which ends with j.\\nWe will have two conditions:\\n\\ns.charAt(i - 1) == \\'I\\': In this case, dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1]).\\ns.charAt(i - 1) == \\'D\\': In this case, dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1]).\\nImagine each time when appending the j to the previous permutations, you have to add 1 to each number in the previous permutation which is greater than or equals to j. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation (1, 0, 3, 2). We are trying to append 2. Now the (1, 0, 3, 2) changes to (1, 0, 4, 3) then appended with a 2. We have (1, 0, 4, 3, 2). Although the values change but the order and count don\\'t change.\\nWhy in case of D, <=l is used explanation\\nMethod:\\nstep 1.\\nfor the original permutation 1032, we add 1 to the digits that are larger than or equal to 2.\\n\\n1032->1043\\n  ^^\\nstep 2.\\nthen directly append 2 to 1043, i.e., 1043 -> 10432\\n\\nRemark on step 1:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival 2.\\n(2) More importantly, such operation on the digits will not break the original DI-rule. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward, you can validate yourself.",
                "solutionTags": [],
                "code": "Puting n-1 and then putting nth\\nLet\\'s change the definition of dp matrix to make the calculation simple: let\\'s say dp[i][j] represents the number of permutation of number 0, 1, ... , i which ends with j. Also, it represents the answer of s.substring(0, i) which ends with j.\\nWe will have two conditions:\\n\\ns.charAt(i - 1) == \\'I\\': In this case, dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1]).\\ns.charAt(i - 1) == \\'D\\': In this case, dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1]).\\nImagine each time when appending the j to the previous permutations, you have to add 1 to each number in the previous permutation which is greater than or equals to j. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation (1, 0, 3, 2). We are trying to append 2. Now the (1, 0, 3, 2) changes to (1, 0, 4, 3) then appended with a 2. We have (1, 0, 4, 3, 2). Although the values change but the order and count don\\'t change.\\nWhy in case of D, <=l is used explanation\\nMethod:\\nstep 1.\\nfor the original permutation 1032, we add 1 to the digits that are larger than or equal to 2.\\n\\n1032->1043\\n  ^^\\nstep 2.\\nthen directly append 2 to 1043, i.e., 1043 -> 10432\\n\\nRemark on step 1:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival 2.\\n(2) More importantly, such operation on the digits will not break the original DI-rule. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward, you can validate yourself.",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565857,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            },
            {
                "id": 1570469,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            },
            {
                "id": 1568500,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Matrix Block Sum",
        "question_content": "<p>Given a <code>m x n</code> matrix <code>mat</code> and an integer <code>k</code>, return <em>a matrix</em> <code>answer</code> <em>where each</em> <code>answer[i][j]</code> <em>is the sum of all elements</em> <code>mat[r][c]</code> <em>for</em>:</p>\n\n<ul>\n\t<li><code>i - k &lt;= r &lt;= i + k,</code></li>\n\t<li><code>j - k &lt;= c &lt;= j + k</code>, and</li>\n\t<li><code>(r, c)</code> is a valid position in the matrix.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n<strong>Output:</strong> [[12,21,16],[27,45,33],[24,39,28]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n<strong>Output:</strong> [[45,45,45],[45,45,45],[45,45,45]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;mat.length</code></li>\n\t<li><code>n ==&nbsp;mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n, k &lt;= 100</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 477041,
                "title": "java-prefix-sum-with-picture-explain-clean-code-o-m-n",
                "content": "**Similar problems:**\\n- [304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/discuss/572648/Java-Prefix-sum-with-Picture-explain-Clean-code)\\n- [1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold](https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold)\\n\\n**Image Explain**\\n![image](https://assets.leetcode.com/users/hiepit/image_1578762431.png)\\n\\n```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] sum = new int[m + 1][n + 1]; // sum[i][j] is sum of all elements from rectangle (0,0,i,j) as left, top, right, bottom corresponding\\n        for (int r = 1; r <= m; r++) {\\n            for (int c = 1; c <= n; c++) {\\n                sum[r][c] = mat[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        int[][] ans = new int[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int r1 = Math.max(0, r - K), c1 = Math.max(0, c - K);\\n                int r2 = Math.min(m - 1, r + K), c2 = Math.min(n - 1, c + K);\\n                r1++; c1++; r2++; c2++; // Since `sum` start with 1 so we need to increase r1, c1, r2, c2 by 1\\n                ans[r][c] = sum[r2][c2] - sum[r2][c1-1] - sum[r1-1][c2] + sum[r1-1][c1-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time: O(m\\\\*n), `m` is the number of rows, `n` is the number of columns of `mat`\\n- Space: O(m\\\\*n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] sum = new int[m + 1][n + 1]; // sum[i][j] is sum of all elements from rectangle (0,0,i,j) as left, top, right, bottom corresponding\\n        for (int r = 1; r <= m; r++) {\\n            for (int c = 1; c <= n; c++) {\\n                sum[r][c] = mat[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        int[][] ans = new int[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int r1 = Math.max(0, r - K), c1 = Math.max(0, c - K);\\n                int r2 = Math.min(m - 1, r + K), c2 = Math.min(n - 1, c + K);\\n                r1++; c1++; r2++; c2++; // Since `sum` start with 1 so we need to increase r1, c1, r2, c2 by 1\\n                ans[r][c] = sum[r2][c2] - sum[r2][c1-1] - sum[r1-1][c2] + sum[r1-1][c1-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500833,
                "title": "c-prefix-sum-with-explanation",
                "content": "This question is similar to a vector segment sum. \\n\\nTo extract sum of an arbitrary sub-array, we first form a prefix sum array.\\n[1, 2, 3, 4, 5] // original vector\\n[1, 3, 6, 10, 15] // prefix sum\\n\\nTo get sum of a sub array from index a to index b, sum(a, b), we can instead calculate prefix(b) - prefix(a-1)\\n\\nSimilar in 2D, we form prefix matrix, where sum[i][j] = sum of elements on top left of original matrix\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\n\\n[1, 3, 6]\\n[5, 12, 21]\\n[12, 27, 45]\\n\\nSimilarly, Sum of an arbitrary block from (i-K, j-K) to (i+K, j+K)\\nans(i, j) = prefix(i+K, j+K) - prefix(i+K, j-K-1) - prefix (i-K-1, j+K) + prefix(i-K-1, j-K-1);\\n\\n```\\nclass Solution {\\npublic: \\n    int sizeX, sizeY;\\n    int extractSum(int i, int j, const vector<vector<int> >& sum) {\\n        if (i < 0 || j < 0) return 0;\\n        if (i >= sizeX) i = sizeX - 1;\\n        if (j >= sizeY) j = sizeY - 1;\\n        return sum[i][j];\\n    }\\n        \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n        \\n        vector<vector<int>> sum(sizeX, vector<int>(sizeY, 0));\\n        // Calculate prefix matrix \\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                sum[i][j] = mat[i][j] + extractSum(i-1, j, sum) + extractSum(i, j-1, sum) - extractSum(i-1, j-1, sum);\\n            }\\n        }\\n        \\n        // Use prefix matrix to calculate our sum\\n        vector<vector<int>> ans(sizeX, vector<int>(sizeY, 0));\\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                ans[i][j] = extractSum(i+K, j+K, sum) - extractSum(i+K, j-K-1,sum) - extractSum (i-K-1, j+K, sum) + extractSum(i-K-1, j-K-1, sum);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: \\n    int sizeX, sizeY;\\n    int extractSum(int i, int j, const vector<vector<int> >& sum) {\\n        if (i < 0 || j < 0) return 0;\\n        if (i >= sizeX) i = sizeX - 1;\\n        if (j >= sizeY) j = sizeY - 1;\\n        return sum[i][j];\\n    }\\n        \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n        \\n        vector<vector<int>> sum(sizeX, vector<int>(sizeY, 0));\\n        // Calculate prefix matrix \\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                sum[i][j] = mat[i][j] + extractSum(i-1, j, sum) + extractSum(i, j-1, sum) - extractSum(i-1, j-1, sum);\\n            }\\n        }\\n        \\n        // Use prefix matrix to calculate our sum\\n        vector<vector<int>> ans(sizeX, vector<int>(sizeY, 0));\\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                ans[i][j] = extractSum(i+K, j+K, sum) - extractSum(i+K, j-K-1,sum) - extractSum (i-K-1, j+K, sum) + extractSum(i-K-1, j-K-1, sum);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482730,
                "title": "python-js-go-c-o-m-n-integral-image-dp-w-explanation",
                "content": "O( m*n ) sol. based on integral image technique ( 2D DP ).\\n\\n---\\n\\n**Explanation on integral image**:\\n\\nHere we use the technique of **integral image**, which is introduced to **speed up block computation**.\\n\\nAlso, this technique is practical and common in the field of matrix operation and image processing such as [filtering](https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3) and feature extraction.\\n\\nBlock sum formula on integral image.\\n **Block-sum** of **red rectangle** = **block-sum of D - block-sum of B - block-sum of C + block-sum of A**\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1579243522.png)\\n\\n---\\n\\n**Example** of integral image ( focus on the purple block ).\\n\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1579244254.png)\\n\\n\\n---\\n\\n**Implementation**:\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            summation = 0\\n            \\n            for x in range(0, w):\\n                summation += mat[y][x]\\n                integral_image[y][x] = summation\\n                \\n                if y > 0:\\n                    integral_image[y][x] += integral_image[y-1][x]\\n        \\n        \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar matrixBlockSum = function(mat, k) {\\n    \\n    let [h, w] = [ mat.length, mat[0].length ];\\n    \\n    let integralImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    let outputImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( let y = 0 ; y < h ; y++){\\n        let pixelSum = 0;\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( let y = 0 ; y < h ; y++){\\n        \\n        let [minRow, maxRow] = [ Math.max(0, y-k), Math.min(h-1, y+k)];\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            \\n            let [minCol, maxCol] = [ Math.max(0, x-k), Math.min(w-1, x+k)];\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n            \\n            \\n        }\\n    }\\n        \\n    return outputImg;\\n    \\n    \\n};\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\n    const int h = mat.size(), w = mat[0].size();\\n    \\n    vector< vector<int> > integralImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    vector< vector<int> > outputImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( int y = 0 ; y < h ; y++){\\n        int pixelSum = 0;\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( int y = 0 ; y < h ; y++){\\n        \\n        const int minRow = max(0, y-k), maxRow = min(h-1, y+k);\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            \\n            const int minCol = max(0, x-k), maxCol = min(w-1, x+k);\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    }\\n};\\n```\\n\\n---\\n\\n**Go**:\\n\\n```\\nfunc create2DArray( h, w int) [][]int{\\n    \\n    matrix  := make( [][]int, h )\\n    row := make( []int, h * w)\\n    \\n    for y := 0 ; y < h ; y++{\\n        matrix[ y ] = row[ y*w : (y+1)*w ] \\n    }\\n    \\n    return matrix\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n\\n\\nfunc matrixBlockSum(mat [][]int, k int) [][]int {\\n    \\n    h, w := len(mat), len(mat[0])\\n    \\n    integralImg  := create2DArray(h, w)\\n    outputImg := create2DArray(h, w)\\n    \\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for y := 0 ; y < h ; y++{\\n        pixelSum := 0;\\n        \\n        for  x := 0 ; x < w ;x++{\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if y > 0 { \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for y := 0 ; y < h ; y++{\\n        \\n        minRow := max(0, y-k)\\n        maxRow := min(h-1, y+k)\\n        \\n        for x := 0 ; x < w ;x++ {\\n            \\n            minCol := max(0, x-k)\\n            maxCol := min(w-1, x+k)\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    \\n\\n}\\n```\\n\\n---\\n\\nShare another implementation with update function in bottom-up\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def update(x, y):\\n            \\n            # add current pixel\\n            result = mat[y][x]\\n            \\n            if x:\\n                # add integral image of left pixel\\n                result += integral_image[y][x-1]\\n            \\n            if y:\\n                # add integral image of top pixel\\n                result +=  integral_image[y-1][x]\\n\\n            if x and y:\\n                # remove repeated part of top-left pixel\\n                result -=  integral_image[y-1][x-1]\\n            \\n            return result\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            for x in range(0, w):\\n                integral_image[y][x] = update(x, y)\\n                \\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\\n\\n</details>\\n\\n---\\n\\n**Implentation** with integral image building in top-down DP \\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def build_integral_image(x, y):\\n            \\n            if (x < 0) or (y < 0):\\n                \\n                ## base case:\\n                # zero for those pixels out of valid boundary\\n                return 0\\n            \\n            if integral_image[y][x]:\\n                ## base case:\\n                # direcly look-up table\\n                return integral_image[y][x]\\n            \\n            ## general cases\\n            # comptue and update integral image at (x, y)\\n            \\n            integral_image[y][x] = mat[y][x] + build_integral_image(x, y-1) + build_integral_image(x-1, y) - build_integral_image(x-1, y-1)\\n            \\n            return integral_image[y][x]\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        build_integral_image(w-1, h-1)\\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\\n\\n</details>\\n\\n---\\n\\nRelated leetcode challenge:\\n[Leetcode #304 Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/)\\n\\n[Leetcode #303 Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/)\\n\\n---\\n\\nReference:\\n[Integral Image in wikipedia](https://en.wikipedia.org/wiki/Summed-area_table)\\n\\n---\\n\\nFurther reading:\\n[1] [Integral Image in OpenCV API](https://docs.opencv.org/master/d5/de6/group__cudaarithm__reduce.html#ga07e5104eba4bf45212ac9dbc5bf72ba6)\\n\\n[2] [ImageJ: Integral Image Filter](https://imagej.net/Integral_Image_Filters)\\n\\n---\\n\\nThanks for your reading.\\n\\nWish you have a nice day.\\n\\nMeow~\\uD83D\\uDE3A",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            summation = 0\\n            \\n            for x in range(0, w):\\n                summation += mat[y][x]\\n                integral_image[y][x] = summation\\n                \\n                if y > 0:\\n                    integral_image[y][x] += integral_image[y-1][x]\\n        \\n        \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\n```\\nvar matrixBlockSum = function(mat, k) {\\n    \\n    let [h, w] = [ mat.length, mat[0].length ];\\n    \\n    let integralImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    let outputImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( let y = 0 ; y < h ; y++){\\n        let pixelSum = 0;\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( let y = 0 ; y < h ; y++){\\n        \\n        let [minRow, maxRow] = [ Math.max(0, y-k), Math.min(h-1, y+k)];\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            \\n            let [minCol, maxCol] = [ Math.max(0, x-k), Math.min(w-1, x+k)];\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n            \\n            \\n        }\\n    }\\n        \\n    return outputImg;\\n    \\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\n    const int h = mat.size(), w = mat[0].size();\\n    \\n    vector< vector<int> > integralImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    vector< vector<int> > outputImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( int y = 0 ; y < h ; y++){\\n        int pixelSum = 0;\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( int y = 0 ; y < h ; y++){\\n        \\n        const int minRow = max(0, y-k), maxRow = min(h-1, y+k);\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            \\n            const int minCol = max(0, x-k), maxCol = min(w-1, x+k);\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    }\\n};\\n```\n```\\nfunc create2DArray( h, w int) [][]int{\\n    \\n    matrix  := make( [][]int, h )\\n    row := make( []int, h * w)\\n    \\n    for y := 0 ; y < h ; y++{\\n        matrix[ y ] = row[ y*w : (y+1)*w ] \\n    }\\n    \\n    return matrix\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n\\n\\nfunc matrixBlockSum(mat [][]int, k int) [][]int {\\n    \\n    h, w := len(mat), len(mat[0])\\n    \\n    integralImg  := create2DArray(h, w)\\n    outputImg := create2DArray(h, w)\\n    \\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for y := 0 ; y < h ; y++{\\n        pixelSum := 0;\\n        \\n        for  x := 0 ; x < w ;x++{\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if y > 0 { \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for y := 0 ; y < h ; y++{\\n        \\n        minRow := max(0, y-k)\\n        maxRow := min(h-1, y+k)\\n        \\n        for x := 0 ; x < w ;x++ {\\n            \\n            minCol := max(0, x-k)\\n            maxCol := min(w-1, x+k)\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    \\n\\n}\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def update(x, y):\\n            \\n            # add current pixel\\n            result = mat[y][x]\\n            \\n            if x:\\n                # add integral image of left pixel\\n                result += integral_image[y][x-1]\\n            \\n            if y:\\n                # add integral image of top pixel\\n                result +=  integral_image[y-1][x]\\n\\n            if x and y:\\n                # remove repeated part of top-left pixel\\n                result -=  integral_image[y-1][x-1]\\n            \\n            return result\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            for x in range(0, w):\\n                integral_image[y][x] = update(x, y)\\n                \\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def build_integral_image(x, y):\\n            \\n            if (x < 0) or (y < 0):\\n                \\n                ## base case:\\n                # zero for those pixels out of valid boundary\\n                return 0\\n            \\n            if integral_image[y][x]:\\n                ## base case:\\n                # direcly look-up table\\n                return integral_image[y][x]\\n            \\n            ## general cases\\n            # comptue and update integral image at (x, y)\\n            \\n            integral_image[y][x] = mat[y][x] + build_integral_image(x, y-1) + build_integral_image(x-1, y) - build_integral_image(x-1, y-1)\\n            \\n            return integral_image[y][x]\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        build_integral_image(w-1, h-1)\\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620405,
                "title": "easy-prefix-logic-explanation-with-matrix-example-python-soution",
                "content": "### Explanation:\\n\\nLets consider this Matrix to Explain with visualisation:\\n\\t\\n\\t1,   2,   3\\n\\t4,   5,   6\\n\\t7,   8,   9\\n\\n**Step 1:** Make a prefix-matrix where each row has prefix sum independent of any other row. Matrix will look like this:\\n\\t\\n\\t1,   3,   6\\n\\t4,   9,   15\\n\\t7,   15,  24\\n\\n**i.e.,**\\n\\n\\t1,   1+2,   1+2+3\\n\\t4,   4+5,   4+5+6\\n\\t7,   7+8,   7+8+9\\n\\n**Step 2:** Turn the prefix-matrix from **Step 1**  to another prefix-matrix but now column wise. This shlould be:\\n\\n\\t1,       3,         6\\n\\t1+4,     3+9,       6+15\\n\\t1+4+7,   3+9+15,    6+15+24\\n\\t\\n**i.e,**\\n\\t\\n\\t\\t1,   3,   6\\n\\t\\t5,   12,  21\\n\\t\\t12,  27,  45\\n\\nWhy did we perform above two steps? Must be thinking right? Let me Explain.\\n\\nSuppose we want a sum for the square block of diagonal *[11 to 22]* (as in r1c1 to r2c2) then we need to eliminate the block *[00 to 02]* and *[00 to 20]* from the sum present in last index of the block(we are calculating sum for), which is index *22* with value **45**.  Then add back the block which we eliminated twice, that is *[00 to 00]*. (whole operation is performed using prefix-matrix we generated in **Step 2**). Lets take a visual of what i meant:\\n\\n\\t1,   2,   3\\n\\t4\\n\\t7\\n\\t\\nis the part we need to remove from original matrix to get sum for non x values in:\\n\\n\\tx,   x,   x\\n\\tx,   5,   6\\n\\tx,   8,   9\\n\\n**So we do it by calculating total sum upto index *22* which is 45 (from prefix-matrix):**\\n**sum**=45\\n\\n**Now remove upper block:**\\n**sum**=45-(1+2+3) *(at index 02 in pefix-matrix)* = 39\\n\\n**Now remove left block:** \\n**sum**=39-(1+4+7) *(at index 20 in pefix-matrix)* = 27\\n\\n**As we can see \\'1\\' is removed twice we will add it once to balance:**\\n**sum**=27+(1) *(at index 00 in prefix-matrix)*  = 28 // extra added block can be aquired from position prefix-matrix[r-1][c-1] where r and c are starting index of required bolck whose sum we are calculating for.\\n\\nSo answer is 28 if your block for which sum to be calculated is:\\n\\t\\n\\tx,   x,   x\\n\\tx,   11,  12\\n\\tx,   21,  22\\n\\n### Code:\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        prefMat=[[0 for i in range(n)] for j in range(m)]\\n        #Step 1\\n\\t\\tfor i in range(m):\\n            prefMat[i][0]=mat[i][0]\\n            for j in range(1,n):\\n                prefMat[i][j]=prefMat[i][j-1]+mat[i][j]\\n        #Step 2        \\n        for i in range(n):\\n            prefMat[0][i]=prefMat[0][i]\\n            for j in range(1,m):\\n                prefMat[j][i]=prefMat[j-1][i]+prefMat[j][i]\\n        #Calculate\\n        for i in range(m):\\n            ru=max(i-k,0)\\n            rd=min(i+k,m-1)\\n            for j in range(n):\\n                cl=max(0,j-k)\\n                cr=min(n-1,j+k)\\n                value=prefMat[rd][cr]\\n                if ru-1>=0:\\n                    value-=prefMat[ru-1][cr]\\n                if cl-1>=0:\\n                    value-=prefMat[rd][cl-1]\\n                if ru-1>=0 and cl-1>=0:\\n                    value+=prefMat[ru-1][cl-1]\\n                \\n                mat[i][j]=value\\n        return mat\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        prefMat=[[0 for i in range(n)] for j in range(m)]\\n        #Step 1\\n\\t\\tfor i in range(m):\\n            prefMat[i][0]=mat[i][0]\\n            for j in range(1,n):\\n                prefMat[i][j]=prefMat[i][j-1]+mat[i][j]\\n        #Step 2        \\n        for i in range(n):\\n            prefMat[0][i]=prefMat[0][i]\\n            for j in range(1,m):\\n                prefMat[j][i]=prefMat[j-1][i]+prefMat[j][i]\\n        #Calculate\\n        for i in range(m):\\n            ru=max(i-k,0)\\n            rd=min(i+k,m-1)\\n            for j in range(n):\\n                cl=max(0,j-k)\\n                cr=min(n-1,j+k)\\n                value=prefMat[rd][cr]\\n                if ru-1>=0:\\n                    value-=prefMat[ru-1][cr]\\n                if cl-1>=0:\\n                    value-=prefMat[rd][cl-1]\\n                if ru-1>=0 and cl-1>=0:\\n                    value+=prefMat[ru-1][cl-1]\\n                \\n                mat[i][j]=value\\n        return mat\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549010,
                "title": "c-64-38-time-100-00-space-graph-illustration",
                "content": "I wrote the  [article](https://juejin.im/post/5e78172b51882549194990d6) in Chinese as well. \\n\\n---\\n\\n`mat[r][c] for i - K <= r <= i + K, j - K <= c <= j + K, and (r, c) is a valid position in the matrix` is actually a square centered at `(i,j)` and has side length of `2K+1`.  if `r < 0 ` or `r >= m`, `c < 0` or `c >= n`, it could become a rectangle or a smaller square.\\n\\nBelow is an example of a 3 * 3 matrix. `K = 1` in this case.\\n![image](https://assets.leetcode.com/users/oliwang/image_1584967433.png)\\n\\nSo, how can we find a uniform way to calculate the sum of the yellow cells? This is when I remembered prefix sum. Generating a prefix sum array for a 1D array is quite straight forward. In a 2D array, the calculation is slightly different. The value of `prefix_sum[i][j]` is the sum of the values in the rectangle where `(i,j)` and `(0,0)` are the two opposite corners.  This will help us avoid most of the repeating calculation.\\n\\nHaving calculated the prefix sum matrix, our problem becomes `prefix_sum[i+K][j+K]` minus the blue squares in the below graph. For example, `answer[2][2] = prefix_sum[2][2] - prefix_sum[0][2]-prefix_sum[2][0] + prefix_sum[0][0]`.\\n\\n![image](https://assets.leetcode.com/users/oliwang/image_1584968690.png)\\n\\n``` c++\\n\\n#include<iostream>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        vector<vector<int>> prefix_sum = prefixSum(mat);\\n        vector<vector<int>> answer = prefix_sum;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                int upper_i = ((i+K) >= mat.size()) ? (mat.size()-1) : (i+K);\\n                int upper_j = ((j+K) >= mat[0].size()) ? (mat[0].size()-1) : (j+K);\\n                \\n                int lower_i = ((i-K) <= 0 ) ? 0 : (i-K);\\n                int lower_j = ((j-K) <= 0 ) ? 0 : (j-K);\\n            \\n                \\n                answer[i][j] = prefix_sum[upper_i][upper_j] - ((lower_i == 0) ? 0 : prefix_sum[lower_i-1][upper_j]) - ((lower_j == 0) ? 0 : prefix_sum[upper_i][lower_j-1]) + ((lower_i == 0) || (lower_j == 0)  ? 0 : prefix_sum[lower_i-1][lower_j-1]);\\n            }\\n        }\\n    \\n        \\n        return answer;\\n        \\n    }\\n    \\n    vector<vector<int>> prefixSum(vector<vector<int>>& mat) {\\n        vector<vector<int>> prefix_sum = mat;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                sum = sum + mat[i][j];\\n                if (i > 0) {\\n                    prefix_sum[i][j] = sum + prefix_sum[i-1][j];\\n                } else {\\n                    prefix_sum[i][j] = sum;   \\n                }\\n            }\\n        }\\n        \\n        return prefix_sum;\\n    }\\n\\n};\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "``` c++\\n\\n#include<iostream>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        vector<vector<int>> prefix_sum = prefixSum(mat);\\n        vector<vector<int>> answer = prefix_sum;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                int upper_i = ((i+K) >= mat.size()) ? (mat.size()-1) : (i+K);\\n                int upper_j = ((j+K) >= mat[0].size()) ? (mat[0].size()-1) : (j+K);\\n                \\n                int lower_i = ((i-K) <= 0 ) ? 0 : (i-K);\\n                int lower_j = ((j-K) <= 0 ) ? 0 : (j-K);\\n            \\n                \\n                answer[i][j] = prefix_sum[upper_i][upper_j] - ((lower_i == 0) ? 0 : prefix_sum[lower_i-1][upper_j]) - ((lower_j == 0) ? 0 : prefix_sum[upper_i][lower_j-1]) + ((lower_i == 0) || (lower_j == 0)  ? 0 : prefix_sum[lower_i-1][lower_j-1]);\\n            }\\n        }\\n    \\n        \\n        return answer;\\n        \\n    }\\n    \\n    vector<vector<int>> prefixSum(vector<vector<int>>& mat) {\\n        vector<vector<int>> prefix_sum = mat;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                sum = sum + mat[i][j];\\n                if (i > 0) {\\n                    prefix_sum[i][j] = sum + prefix_sum[i-1][j];\\n                } else {\\n                    prefix_sum[i][j] = sum;   \\n                }\\n            }\\n        }\\n        \\n        return prefix_sum;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 821782,
                "title": "c-98-faster-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        vector<vector<int> > dp(matrix.size()+1,vector<int>(matrix[0].size()+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i < dp.size(); i++) {\\n            for (int j = 1; j < dp[0].size(); j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        \\n        \\n        //the result vector we are going to return\\n        vector<vector<int>> ans(matrix.size(),vector<int>(matrix[0].size(),0));\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                int m=matrix.size();\\n                int n=matrix[i].size();\\n                int r1=max(0,i-k)+1; //starting row coordinate of the block\\n                int c1=max(0,j-k)+1; //starting column coordinate of the block\\n                int r2= min(i+k+1,m); //ending row coordinate of the block\\n                int c2= min(j+k+1,n); // ending column coordinate of the block\\n                \\n                ans[i][j]=dp[r2][c2]+dp[r1-1][c1-1]-dp[r1-1][c2]-dp[r2][c1-1]; //value of the block calculated with the dp vector built\\n                \\n            }\\n        }\\n      return ans;  \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        vector<vector<int> > dp(matrix.size()+1,vector<int>(matrix[0].size()+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i < dp.size(); i++) {\\n            for (int j = 1; j < dp[0].size(); j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        \\n        \\n        //the result vector we are going to return\\n        vector<vector<int>> ans(matrix.size(),vector<int>(matrix[0].size(),0));\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                int m=matrix.size();\\n                int n=matrix[i].size();\\n                int r1=max(0,i-k)+1; //starting row coordinate of the block\\n                int c1=max(0,j-k)+1; //starting column coordinate of the block\\n                int r2= min(i+k+1,m); //ending row coordinate of the block\\n                int c2= min(j+k+1,n); // ending column coordinate of the block\\n                \\n                ans[i][j]=dp[r2][c2]+dp[r1-1][c1-1]-dp[r1-1][c2]-dp[r2][c1-1]; //value of the block calculated with the dp vector built\\n                \\n            }\\n        }\\n      return ans;  \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627291,
                "title": "detailed-explanation-of-optimal-substructure-and-subproblems-with-example",
                "content": "**Solution#1:** `O(cols * rows^2)` runtime and `O(rows*cols)` space complexity. (I kept the time complexity is little more, so that it\\'s easier to understand)\\n\\n**Idea:**\\n* Maintain a `rowPrefix` 2D array in which `rowPrefix[i][j]` is the prefix sum upto `j`th column in the `i`th row\\n* Now, let\\'s determine `ans[i][j]` (result)\\n* For given `i`, calculate `rowStart` and `rowEnd` (Keeping the validity of ranges according to boundary)\\n* Calculate `colStart` and `colEnd` (Keeping the validity of ranges according to boundary)\\n* iterate from `rowStart` to `rowEnd` and determine the sum of the sub-matrix using the `rowPrefix` submatrix\\n\\nFor example,\\n```\\n1 2 3                       1  (1+2=)3  (1+2+3=) 6\\n4 5 6   =>    rowPrefix =   4  (4+5=)9  (4+5+6=)15\\n7 8 9                       7  (7+8=)15 (7+8+9=)24\\n```\\n\\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] rowPrefix = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\trowPrefix[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: rowPrefix[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(0, i-K),\\n\\t\\t\\trowEnd = Math.min(rows-1, i+K);\\n\\n\\t\\t// System.out.println(\"rowStart: \" + rowStart + \" rowEnd: \" + rowEnd);\\n\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(0, j-K),\\n\\t\\t\\t\\tcolEnd = Math.min(cols-1, j+K),\\n\\t\\t\\t\\tsum = 0;\\n\\n\\t\\t\\t// System.out.println(\"colStart: \" + colStart + \" colEnd: \" + colEnd);\\n\\t\\t\\tfor (int r = rowStart; r <= rowEnd; r++) {\\n\\t\\t\\t\\tsum += rowPrefix[r][colEnd] - (colStart > 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t? rowPrefix[r][colStart - 1]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: 0);\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"sum: \" + sum);\\n\\t\\t\\tans[i][j] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\n**Solution#2:** `O(cols * rows)` runtime and space complexity\\n\\n**Idea:**\\n* Expand the `prefixSum` matrix to contain the sum of all elements in the subarray from `0..i` and `0..j` i.e. `prefixSum[i][j]` = sum of all matrix elements from `[0,0]` to `[i,j]`\\n* For building such a prefixSum for 2D matrix, we will first build a rowPrefix matrix like the approach above, and then on top of it, we will add column prefixes.\\n* After that, let\\'s determine `ans[i][j]` (result)\\n* For given `i`, calculate `rowStart` and `rowEnd` (Keeping the validity of ranges according to boundary)\\n* Calculate `colStart` and `colEnd` (Keeping the validity of ranges according to boundary)\\n* To determine the sum of all elements from `[rowStart, colStart]` to `[rowEnd, colEnd]`, we will do the following:  ``` [rowEnd, colEnd] - [rowStart-1, colEnd] - [rowEnd, colStart-1] - [rowStart-1, colStart-1]```\\n\\t* Basically, we have the sum of submatrix from `[0,0]` to `[rowEnd, colEnd]`  and we are stripping off the upper strip `[rowStart-1, colEnd]` left strip `[rowEnd, colStart-1]`. While doing this, notice that, we subtracted, the sum of submatrix `[0,0]` to `[rowStart-1, colStart-1]` twice. So, we add it back again.\\n\\t* Now, add the boundary line sanitation to above mentioned formula. \\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] prefixSum = new int[rows][cols];\\n\\n\\t// calculate row prefix sum first\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: prefixSum[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\t// calculate the row and column prefix sum on top of row prefix sum\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] += prefixSum[i-1][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(i-K, 0),\\n\\t\\t\\trowEnd = Math.min(i+K, rows-1);\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(j-K, 0),\\n\\t\\t\\t\\tcolEnd = Math.min(j+K, cols-1);\\n\\n\\t\\t\\tans[i][j] = prefixSum[rowEnd][colEnd]\\n\\t\\t\\t\\t- (rowStart > 0\\n\\t\\t\\t\\t   ? prefixSum[rowStart - 1][colEnd]\\n\\t\\t\\t\\t   : 0) // upper strip\\n\\t\\t\\t\\t- (colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowEnd][colStart - 1]\\n\\t\\t\\t\\t  : 0) // left strip\\n\\t\\t\\t\\t+ (rowStart > 0 && colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowStart-1][colStart - 1]\\n\\t\\t\\t\\t  : 0); // left-top corner of the submatrix will be subtracted twice, so adding it once, so that it gets subtracted overall only once.\\n\\n\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nPhew!! Long post!! If this was helpful to you, please upvote :)",
                "solutionTags": [],
                "code": "```\\n1 2 3                       1  (1+2=)3  (1+2+3=) 6\\n4 5 6   =>    rowPrefix =   4  (4+5=)9  (4+5+6=)15\\n7 8 9                       7  (7+8=)15 (7+8+9=)24\\n```\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] rowPrefix = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\trowPrefix[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: rowPrefix[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(0, i-K),\\n\\t\\t\\trowEnd = Math.min(rows-1, i+K);\\n\\n\\t\\t// System.out.println(\"rowStart: \" + rowStart + \" rowEnd: \" + rowEnd);\\n\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(0, j-K),\\n\\t\\t\\t\\tcolEnd = Math.min(cols-1, j+K),\\n\\t\\t\\t\\tsum = 0;\\n\\n\\t\\t\\t// System.out.println(\"colStart: \" + colStart + \" colEnd: \" + colEnd);\\n\\t\\t\\tfor (int r = rowStart; r <= rowEnd; r++) {\\n\\t\\t\\t\\tsum += rowPrefix[r][colEnd] - (colStart > 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t? rowPrefix[r][colStart - 1]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: 0);\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"sum: \" + sum);\\n\\t\\t\\tans[i][j] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n``` [rowEnd, colEnd] - [rowStart-1, colEnd] - [rowEnd, colStart-1] - [rowStart-1, colStart-1]```\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] prefixSum = new int[rows][cols];\\n\\n\\t// calculate row prefix sum first\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: prefixSum[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\t// calculate the row and column prefix sum on top of row prefix sum\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] += prefixSum[i-1][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(i-K, 0),\\n\\t\\t\\trowEnd = Math.min(i+K, rows-1);\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(j-K, 0),\\n\\t\\t\\t\\tcolEnd = Math.min(j+K, cols-1);\\n\\n\\t\\t\\tans[i][j] = prefixSum[rowEnd][colEnd]\\n\\t\\t\\t\\t- (rowStart > 0\\n\\t\\t\\t\\t   ? prefixSum[rowStart - 1][colEnd]\\n\\t\\t\\t\\t   : 0) // upper strip\\n\\t\\t\\t\\t- (colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowEnd][colStart - 1]\\n\\t\\t\\t\\t  : 0) // left strip\\n\\t\\t\\t\\t+ (rowStart > 0 && colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowStart-1][colStart - 1]\\n\\t\\t\\t\\t  : 0); // left-top corner of the submatrix will be subtracted twice, so adding it once, so that it gets subtracted overall only once.\\n\\n\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521997,
                "title": "python-two-approaches-easy-to-understand-w-explanation",
                "content": "### Approach 1: Brute Force\\n\\nThis is by far the simplest and shortest solution. How it works:\\n\\n- Loop through each ```(x, y)``` coordinate in the resultant array ```result```.\\n- At each ```result[x][y]```, get the appropriate subarray from the matrix ```mat```. I.e., for each ```(x, y)``` in ```result```, get the subarray ```mat[x-k:x+k+1][y-k:y+k+1]```. Then we need to factor in the matrix length and breadth:\\n\\n```python\\ndef getSubarray(mat: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the following: mat[x-k:x+k+1][y-k:y+k+1].\\n\\tIf x - k < 0 --> Use index x = 0 instead\\n\\tIf y - k < 0 --> Use index y = 0 instead\\n\\tIf x + k >= len(mat) --> Use index x = len(mat)-1 instead\\n\\tIf y + k >- len(mat[0]) --> Use index y = len(mat[0])-1 instead\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn mat[max(x-k, 0):min(x+k+1, len(mat)][max(y-k, 0):min(y+k+1, len(mat[0])]\\n```\\n\\n- Compute the sum of the entire subarray and save into ```result[x][y]```.\\n\\n```python\\ndef sumOfSubarray(arr: List[List[int]]) -> int:\\n\\t\"\"\"\\n\\tPython pseudocode to calculate the sum of all the elements in the given array.\\n\\tresult = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\tresult += arr[i][j]\\n\\treturn result\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn sum(sum(arr[i]) for i in range(len(arr)))\\n```\\n\\nThat\\'s all. You can probably optimise the runtime using sliding window technique, but this approach is the easiest to come up with.\\n\\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = sum(sum(mat[x][max(0, j-k):min(n, j+k+1)])\\n                                   for x in range(max(0, i-k), min(m, i+k+1)))\\n        return result\\n```\\n\\nTime Complexity: O(mnk^2), due to the nested sum functions.\\nSpace Complexity: O(1) auxillary space.\\nResult: Almost 2s runtime, 15MB used space. Not great, obviously.\\n\\n---\\n\\n### Approach 2: Prefix Sum\\n\\n[This blog](https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/) describes the algorithm quite well. Essentially the algorithm consists of the following:\\n\\n- On our first pass through the matrix ```mat```, we obtain the cumulative sum of the elements above and to the left of the current element, including the element itself.\\n\\nI.e., for each ```(x, y)``` in ```mat```, we obtain ```sumOfSubarray(mat[:x+1][:y+1])``` (refer to the pseudocode above). The reason why we can do this in one pass is because of DP:\\n\\n```python\\ndef prefixSum(mat: List[List[int]]) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the prefix sum of the given array via DP.\\n\\t\"\"\"\\n\\tresult = mat[:][:]  # essentially copies the array\\n\\tfor i in range(len(mat)):\\n\\t\\tfor j in range(len(mat[0])):\\n\\t\\t\\tresult[i][j] += (result[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i][j-1] if j > 0 else 0) + \\\\          # add prefix sum of (i, j-1), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1), if it exists\\n\\treturn result\\n```\\n\\n- Calculate the block sum at each ```(x, y)``` using the prefix sum.\\n\\nThe prefix sum is optimal for this task because we can actually **calculate the block sum from the prefix sum in O(1) time**, according to the formula ```S(D) + S(A) - S(B) - S(C)```. (Again, refer to [this blog](https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/) for a more detailed explanation.) This ensures our code runs within O(mn) time, even at the cost of having to loop through the matrix again.\\n\\nAgain, we need to account for the matrix borders. Similar to approach 1, we can just replace all nonexistent matrix coordinates with 0, since the matrix ```mat``` only contains positive integers (```1 <= mat[i][j] <= 100```).\\n\\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n\\t\\t\\n\\t\\t# Calculate the prefix sum\\n        prefix = mat[:][:]  # essentially copies the entire array\\n        for i in range(m):\\n            for j in range(n):\\n                prefix[i][j] += (prefix[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j) if it exists\\n                                (prefix[i][j-1] if j > 0 else 0) - \\\\          # add prefix sum of (i, j-1) if it exists\\n                                (prefix[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1) if it exists\\n\\t\\t\\n\\t\\t# Calculate the block sum from the prefix sum\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = prefix[min(i+k, m-1)][min(j+k, n-1)] + \\\\                  # S(D), bounded by m x n\\n                               (prefix[i-k-1][j-k-1] if i-k > 0 and j-k > 0 else 0) - \\\\  # S(A), if it exists\\n                               (prefix[i-k-1][min(j+k, n-1)] if i-k > 0 else 0) - \\\\      # S(B), if it exists\\n                               (prefix[min(i+k, m-1)][j-k-1] if j-k > 0 else 0)          # S(C), if it exists\\n        return result\\n\\t\\t# we could technically shorten the block sum calculation into one line of code, but that is super unreadable\\n```\\n\\nTime Complexity: O(mn), since the calculations performed in the nested loops are of O(1) time complexity.\\nSpace Complexity: O(mn) auxillary space, due to the prefix sum matrix.\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/65e45a40-3085-4431-aa16-0eaaeb25d119_1634276576.3804398.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```(x, y)```\n```result```\n```result[x][y]```\n```mat```\n```(x, y)```\n```result```\n```mat[x-k:x+k+1][y-k:y+k+1]```\n```python\\ndef getSubarray(mat: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the following: mat[x-k:x+k+1][y-k:y+k+1].\\n\\tIf x - k < 0 --> Use index x = 0 instead\\n\\tIf y - k < 0 --> Use index y = 0 instead\\n\\tIf x + k >= len(mat) --> Use index x = len(mat)-1 instead\\n\\tIf y + k >- len(mat[0]) --> Use index y = len(mat[0])-1 instead\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn mat[max(x-k, 0):min(x+k+1, len(mat)][max(y-k, 0):min(y+k+1, len(mat[0])]\\n```\n```result[x][y]```\n```python\\ndef sumOfSubarray(arr: List[List[int]]) -> int:\\n\\t\"\"\"\\n\\tPython pseudocode to calculate the sum of all the elements in the given array.\\n\\tresult = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\tresult += arr[i][j]\\n\\treturn result\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn sum(sum(arr[i]) for i in range(len(arr)))\\n```\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = sum(sum(mat[x][max(0, j-k):min(n, j+k+1)])\\n                                   for x in range(max(0, i-k), min(m, i+k+1)))\\n        return result\\n```\n```mat```\n```(x, y)```\n```mat```\n```sumOfSubarray(mat[:x+1][:y+1])```\n```python\\ndef prefixSum(mat: List[List[int]]) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the prefix sum of the given array via DP.\\n\\t\"\"\"\\n\\tresult = mat[:][:]  # essentially copies the array\\n\\tfor i in range(len(mat)):\\n\\t\\tfor j in range(len(mat[0])):\\n\\t\\t\\tresult[i][j] += (result[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i][j-1] if j > 0 else 0) + \\\\          # add prefix sum of (i, j-1), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1), if it exists\\n\\treturn result\\n```\n```(x, y)```\n```S(D) + S(A) - S(B) - S(C)```\n```mat```\n```1 <= mat[i][j] <= 100```\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n\\t\\t\\n\\t\\t# Calculate the prefix sum\\n        prefix = mat[:][:]  # essentially copies the entire array\\n        for i in range(m):\\n            for j in range(n):\\n                prefix[i][j] += (prefix[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j) if it exists\\n                                (prefix[i][j-1] if j > 0 else 0) - \\\\          # add prefix sum of (i, j-1) if it exists\\n                                (prefix[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1) if it exists\\n\\t\\t\\n\\t\\t# Calculate the block sum from the prefix sum\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = prefix[min(i+k, m-1)][min(j+k, n-1)] + \\\\                  # S(D), bounded by m x n\\n                               (prefix[i-k-1][j-k-1] if i-k > 0 and j-k > 0 else 0) - \\\\  # S(A), if it exists\\n                               (prefix[i-k-1][min(j+k, n-1)] if i-k > 0 else 0) - \\\\      # S(B), if it exists\\n                               (prefix[min(i+k, m-1)][j-k-1] if j-k > 0 else 0)          # S(C), if it exists\\n        return result\\n\\t\\t# we could technically shorten the block sum calculation into one line of code, but that is super unreadable\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561884,
                "title": "java-dp-solution-clean-code-o-m-n",
                "content": "```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] ans = new int[m][n];\\n        \\n        int[][] t = new int[m + 1][n + 1];\\n        \\n        for (int i = 1; i < t.length; i++) {\\n            for (int j = 1; j < t[0].length; j++) {\\n                t[i][j] = t[i - 1][j] + t[i][j - 1] + mat[i - 1][j - 1] - t[i - 1][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = Math.max(0, i - K) + 1;\\n                int c1 = Math.max(0, j - K) + 1;\\n                int r2 = Math.min(m, i + K + 1);\\n                int c2 = Math.min(n, j + K + 1);\\n                ans[i][j] = t[r2][c2] - t[r1 - 1][c2] - t[r2][c1 - 1] + t[r1 - 1][c1 - 1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] ans = new int[m][n];\\n        \\n        int[][] t = new int[m + 1][n + 1];\\n        \\n        for (int i = 1; i < t.length; i++) {\\n            for (int j = 1; j < t[0].length; j++) {\\n                t[i][j] = t[i - 1][j] + t[i][j - 1] + mat[i - 1][j - 1] - t[i - 1][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = Math.max(0, i - K) + 1;\\n                int c1 = Math.max(0, j - K) + 1;\\n                int r2 = Math.min(m, i + K + 1);\\n                int c2 = Math.min(n, j + K + 1);\\n                ans[i][j] = t[r2][c2] - t[r1 - 1][c2] - t[r2][c1 - 1] + t[r1 - 1][c1 - 1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499970,
                "title": "problem-explanation-in-python-step-by-step-o-m-n-98-speed-and-100-memory",
                "content": "In order to answer this problem we may use the following idea in the array:\\n\\n**input, K = 1**\\n|  |  |  |\\n|---|---|---|\\n| a | b | c |\\n| d | e | f |\\n| g | h | i |\\n| | | |\\n\\n**output:**\\n|   |   |   |\\n|---|---|---|\\n|(a+b)+(d+e)|       (a+b+c)+(d+e+f)|         (b+c) + (e+f)|\\n|(a+b)+(d+e)+(g+h)| (a+b+c)+(d+e+f)+(g+h+i)| (b+c) + (e+f) + (h+i)|\\n|(a+b)+(d+e)|       (d+e+f)+(g+h+i)|         (e+f) + (h+i)|\\n| | | |\\n\\nit\\'s pretty much the same as compute the sum for rows and then make\\nthe sum into the columns:\\n**rowSum:**\\n||||\\n|-|-|-|\\n|(a+b)| (a+b+c)| (b+c)|\\n|(d+e)| (d+e+f)| (e+f)|\\n|(g+h)| (g+h+i)| (h+i)|\\n||||\\n\\nand the output will be made such as:\\n```\\noutput[i][j] = sum{k from -K to K}(rowSum[i+k][j])\\n```\\n\\nNow the idea is how to compute fast that row sum (that by the way,\\nis the same thing of the column sum in the output but in Y axis).\\nwe may notice that:\\n```\\nrowSum[i][j] = sum{k from -K to K}(mat[i][j+k])\\nrowSum[i][j+1] = sum{k from -K to K}(mat[i][j+1+k])\\n```\\n  \\nbut that\\'s the same as: \\n```\\nrowSum[i][j+1] = sum{k from -K+1 to K+1}(mat[i][j+k]) \\n```\\n\\nand we can compute it by saying that \\n``` \\nrowSum[i][j+1] = (sum{k from -K to K}(mat[i][j+k]))-mat[i][j-K]+mat[i][j+K+1] \\nrowSum[i][j+1] = rowSum[i][j]-mat[i][j-K]+mat[i][j+K+1] \\n\\nlet j+1 = l \\nrowSum[i][l] = rowSum[i][l-1]-mat[i][l-K-1]+mat[i][l+K] \\n``` \\n \\nand now we have our DP to compute the row in complexity O(n), but\\nhow we compute m rows, the overral complexity is O(m*n), and in the\\nY axis there\\'s the same situation\\n\\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        rowSum = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        ans = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        \\n        # Compute the sum of every group in the row with a DP\\n        # complexity: O(m*n)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):\\n                if j > 0:\\n                    rowSum[i][j] = rowSum[i][j-1]\\n                    a = mat[i][j-K-1] if j-K-1 >= 0 else 0 # or 0\\n                    b = mat[i][j+K] if j+K < len(mat[i]) else 0 # or 0\\n                    rowSum[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(j+K+1, len(mat[i]))):\\n                        rowSum[i][j] += mat[i][k]\\n        \\n        # Uses the computed sum of rows to compute the sum\\n        # of the squares with the same DP but now for columns\\n        # complexity: O(m*n)\\n        for i in range(len(rowSum)):\\n            for j in range(len(rowSum[i])):\\n                if i > 0:\\n                    ans[i][j] = ans[i-1][j]\\n                    a = rowSum[i-K-1][j] if i-K-1 >= 0 else 0 # or 0\\n                    b = rowSum[i+K][j] if i+K < len(rowSum) else 0 # or 0\\n                    ans[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(i+K+1, len(rowSum))):\\n                        ans[i][j] += rowSum[k][j]\\n        \\n        # total complexity: O(m*n)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\noutput[i][j] = sum{k from -K to K}(rowSum[i+k][j])\\n```\n```\\nrowSum[i][j] = sum{k from -K to K}(mat[i][j+k])\\nrowSum[i][j+1] = sum{k from -K to K}(mat[i][j+1+k])\\n```\n```\\nrowSum[i][j+1] = sum{k from -K+1 to K+1}(mat[i][j+k]) \\n```\n``` \\nrowSum[i][j+1] = (sum{k from -K to K}(mat[i][j+k]))-mat[i][j-K]+mat[i][j+K+1] \\nrowSum[i][j+1] = rowSum[i][j]-mat[i][j-K]+mat[i][j+K+1] \\n\\nlet j+1 = l \\nrowSum[i][l] = rowSum[i][l-1]-mat[i][l-K-1]+mat[i][l+K] \\n```\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        rowSum = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        ans = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        \\n        # Compute the sum of every group in the row with a DP\\n        # complexity: O(m*n)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):\\n                if j > 0:\\n                    rowSum[i][j] = rowSum[i][j-1]\\n                    a = mat[i][j-K-1] if j-K-1 >= 0 else 0 # or 0\\n                    b = mat[i][j+K] if j+K < len(mat[i]) else 0 # or 0\\n                    rowSum[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(j+K+1, len(mat[i]))):\\n                        rowSum[i][j] += mat[i][k]\\n        \\n        # Uses the computed sum of rows to compute the sum\\n        # of the squares with the same DP but now for columns\\n        # complexity: O(m*n)\\n        for i in range(len(rowSum)):\\n            for j in range(len(rowSum[i])):\\n                if i > 0:\\n                    ans[i][j] = ans[i-1][j]\\n                    a = rowSum[i-K-1][j] if i-K-1 >= 0 else 0 # or 0\\n                    b = rowSum[i+K][j] if i+K < len(rowSum) else 0 # or 0\\n                    ans[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(i+K+1, len(rowSum))):\\n                        ans[i][j] += rowSum[k][j]\\n        \\n        # total complexity: O(m*n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125935,
                "title": "c-prefix-sum-matrix-o-n-m-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf U have done [range-sum-query-2d-immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/description/) problem  this seems real easy if not then it is  a hell brain storming question  espacially for those who don\\'t have done matrix problems . Look at this for best explanation : [Expalantion for this Concept](https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/3122950/cprefix-sum-using-two-equations-of-matrixo1/)\\nAfter doing above There is just a liitle change which u will look direclty in code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum of 2D Matrix : Get this appraoch from [here](https://leetcode.com/problems/range-sum-query-2d-immutable/description/)\\nAnd **Also UPVOTE If FOUND HELPFULL**\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\n\\nint bound(int i, int j,const vector<vector<int>>&dp) {\\n      if (i < 0 || j < 0) return 0;\\n        if (i >= n) i = n - 1;\\n        if (j >= m) j = m- 1;\\n        return dp[i+1][j+1];\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n         n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i+1][j+1]=dp[i+1][j]+matrix[i][j]+dp[i][j+1]-dp[i][j];\\n            }\\n        }\\n        int i=1;\\n        cout<<bound(1,1,dp);\\n      vector<vector<int>>ans(n,vector<int>(m));\\n       for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                ans[i][j]=bound(i+k,j+k,dp)-bound(i-k-1,j+k,dp)-bound(i+k,j-k-1,dp)+bound(i-k-1,j-k-1,dp);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\n\\nint bound(int i, int j,const vector<vector<int>>&dp) {\\n      if (i < 0 || j < 0) return 0;\\n        if (i >= n) i = n - 1;\\n        if (j >= m) j = m- 1;\\n        return dp[i+1][j+1];\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n         n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i+1][j+1]=dp[i+1][j]+matrix[i][j]+dp[i][j+1]-dp[i][j];\\n            }\\n        }\\n        int i=1;\\n        cout<<bound(1,1,dp);\\n      vector<vector<int>>ans(n,vector<int>(m));\\n       for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                ans[i][j]=bound(i+k,j+k,dp)-bound(i-k-1,j+k,dp)-bound(i+k,j-k-1,dp)+bound(i-k-1,j-k-1,dp);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1152097,
                "title": "c-solution-beats-100-time-87-memory-using-cumulative-sum",
                "content": "1. Firstly, we calculate the cumulative sum upto indexes i & j and change the matrix elements into their cumulative sum.\\n2. Then we calculate the area of possible square or rectangle using cumulative sum calculated in the first step.\\n![image](https://assets.leetcode.com/users/images/2dd9f447-1866-462d-ab2a-70f13cfe555e_1618089334.5831802.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> ans( n,vector<int> (m, 0));\\n        for(int i=1; i<n; i++) mat[i][0] += mat[i-1][0];\\n        for(int i=1; i<m; i++) mat[0][i] += mat[0][i-1];\\n        for(int r=1; r<n; r++) for(int c = 1; c<m; c++)\\n                mat[r][c] += mat[r-1][c] + mat[r][c-1] - mat[r-1][c-1];\\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int r_max = min(n-1,i+k), c_max = min(m-1,j+k);\\n                if (i>k && j>k) ans[i][j] = mat[r_max][c_max] + mat[i-k-1][j-k-1] \\n                        - mat[r_max][j-k-1] - mat[i-k-1][c_max];\\n                else if (i>k) ans[i][j] = mat[r_max][c_max] - mat[i-k-1][c_max];\\n                else if (j>k) ans[i][j] = mat[r_max][c_max] - mat[r_max][j-k-1];\\n                else ans[i][j] = mat[r_max][c_max];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/950b530f-b4dd-4fd4-b376-2e3f7a21e1bc_1618089527.711017.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> ans( n,vector<int> (m, 0));\\n        for(int i=1; i<n; i++) mat[i][0] += mat[i-1][0];\\n        for(int i=1; i<m; i++) mat[0][i] += mat[0][i-1];\\n        for(int r=1; r<n; r++) for(int c = 1; c<m; c++)\\n                mat[r][c] += mat[r-1][c] + mat[r][c-1] - mat[r-1][c-1];\\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int r_max = min(n-1,i+k), c_max = min(m-1,j+k);\\n                if (i>k && j>k) ans[i][j] = mat[r_max][c_max] + mat[i-k-1][j-k-1] \\n                        - mat[r_max][j-k-1] - mat[i-k-1][c_max];\\n                else if (i>k) ans[i][j] = mat[r_max][c_max] - mat[i-k-1][c_max];\\n                else if (j>k) ans[i][j] = mat[r_max][c_max] - mat[r_max][j-k-1];\\n                else ans[i][j] = mat[r_max][c_max];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711729,
                "title": "python-dp-o-m-n",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        mat[:] = [[0] * (n + 1)] + [[0] + row for row in mat]\\n        res = [[0] * n for i in range(m)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1]\\n                \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(i - K, 0), min(i + K + 1, m)\\n                c1, c2 = max(j - K, 0), min(j + K + 1, n)\\n                res[i][j] = mat[r2][c2] - mat[r2][c1] - mat[r1][c2] + mat[r1][c1]\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        mat[:] = [[0] * (n + 1)] + [[0] + row for row in mat]\\n        res = [[0] * n for i in range(m)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1]\\n                \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(i - K, 0), min(i + K + 1, m)\\n                c1, c2 = max(j - K, 0), min(j + K + 1, n)\\n                res[i][j] = mat[r2][c2] - mat[r2][c1] - mat[r1][c2] + mat[r1][c1]\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612738,
                "title": "100-100-dp-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int> >& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1));\\n        dp[0][0]=mat[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+mat[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+mat[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+mat[i][j];\\n            }\\n        }\\n        vector<vector<int> > ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=dp[min(i+k,m-1)][min(j+k,n-1)]-((j-k-1)>=0 ? dp[min(i+k,m-1)][j-k-1] : 0)-((i-k-1)>=0 ? dp[i-k-1][min(n-1,j+k)] : 0)+(((j-k-1)>=0 && (i-k-1)>=0) ? dp[i-k-1][j-k-1] : 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int> >& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1));\\n        dp[0][0]=mat[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+mat[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+mat[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+mat[i][j];\\n            }\\n        }\\n        vector<vector<int> > ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=dp[min(i+k,m-1)][min(j+k,n-1)]-((j-k-1)>=0 ? dp[min(i+k,m-1)][j-k-1] : 0)-((i-k-1)>=0 ? dp[i-k-1][min(n-1,j+k)] : 0)+(((j-k-1)>=0 && (i-k-1)>=0) ? dp[i-k-1][j-k-1] : 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477045,
                "title": "java-precompute",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n        int[][] pre = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < n; j++) {\\n                sum += mat[i][j];\\n                pre[i][j] = sum;\\n            }\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int r1 = Math.max(0, i - k);\\n                int r2 = Math.min(m - 1, i + k);\\n                int c1 = Math.max(0, j - k); \\n                int c2 = Math.min(n - 1, j + k);\\n                for(int t = r1; t <= r2; t++) {\\n                    ans[i][j] += pre[t][c2];\\n                    if(c1 != 0) ans[i][j] -= pre[t][c1 - 1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n        int[][] pre = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < n; j++) {\\n                sum += mat[i][j];\\n                pre[i][j] = sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2852898,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    int m, n;\\npublic:\\n    int block_sum(int row, int col, vector<vector<int>>& prefix_sum, int k) {\\n        // relevant points are\\n        // bottom corner            -> row + k,     col + k\\n        // top corner               -> row - k,     col - k;\\n        // pre up corner            -> row - k - 1, col - k - 1;\\n        // right up corner          -> row - k - 1, col + k\\n        // left down corner         -> row + k,     col - k - 1\\n        // sum \\n        // value(bottom corner) - value(right up) - value(left down) + value(pre up corner);\\n        int bot_corner_row = min(row + k, m - 1);\\n        int bot_corner_col = min(col + k, n - 1);\\n        // Base block\\n        int res = prefix_sum[bot_corner_row][bot_corner_col];\\n        // Block 1 - Upper block\\n        if ((row - k - 1) >= 0) {\\n            int right_up_corner_col = min(col + k, n - 1);\\n            res -= prefix_sum[row - k - 1][right_up_corner_col];\\n        }\\n        // Block 2 - Left block\\n        if ((col - k - 1) >= 0) {\\n            int left_down_corner_row = min(row + k, m - 1);\\n            res -= prefix_sum[left_down_corner_row][col - k - 1];\\n        } \\n        // Block 3 - upper left block\\n        // Add if both Block 1 & 2 reduced its sum\\n        if (((row - k - 1) >= 0) && ((col - k - 1) >= 0)) {\\n            res += prefix_sum[row - k - 1][col - k - 1];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        vector<vector<int>> prefix_sum(m, vector<int>(n, 0));\\n        vector<vector<int>> result(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int row_sum = 0;\\n            for (int j = 0; j < n; ++j) {\\n                // Prefix sum is accumulated sum of row element + upper prefix sum cell\\n                row_sum += mat[i][j];\\n                prefix_sum[i][j] = row_sum;\\n                if (i > 0) {\\n                    prefix_sum[i][j] += prefix_sum[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result[i][j] = block_sum(i, j, prefix_sum, k);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\npublic:\\n    int block_sum(int row, int col, vector<vector<int>>& prefix_sum, int k) {\\n        // relevant points are\\n        // bottom corner            -> row + k,     col + k\\n        // top corner               -> row - k,     col - k;\\n        // pre up corner            -> row - k - 1, col - k - 1;\\n        // right up corner          -> row - k - 1, col + k\\n        // left down corner         -> row + k,     col - k - 1\\n        // sum \\n        // value(bottom corner) - value(right up) - value(left down) + value(pre up corner);\\n        int bot_corner_row = min(row + k, m - 1);\\n        int bot_corner_col = min(col + k, n - 1);\\n        // Base block\\n        int res = prefix_sum[bot_corner_row][bot_corner_col];\\n        // Block 1 - Upper block\\n        if ((row - k - 1) >= 0) {\\n            int right_up_corner_col = min(col + k, n - 1);\\n            res -= prefix_sum[row - k - 1][right_up_corner_col];\\n        }\\n        // Block 2 - Left block\\n        if ((col - k - 1) >= 0) {\\n            int left_down_corner_row = min(row + k, m - 1);\\n            res -= prefix_sum[left_down_corner_row][col - k - 1];\\n        } \\n        // Block 3 - upper left block\\n        // Add if both Block 1 & 2 reduced its sum\\n        if (((row - k - 1) >= 0) && ((col - k - 1) >= 0)) {\\n            res += prefix_sum[row - k - 1][col - k - 1];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        vector<vector<int>> prefix_sum(m, vector<int>(n, 0));\\n        vector<vector<int>> result(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int row_sum = 0;\\n            for (int j = 0; j < n; ++j) {\\n                // Prefix sum is accumulated sum of row element + upper prefix sum cell\\n                row_sum += mat[i][j];\\n                prefix_sum[i][j] = row_sum;\\n                if (i > 0) {\\n                    prefix_sum[i][j] += prefix_sum[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result[i][j] = block_sum(i, j, prefix_sum, k);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477790,
                "title": "c-simple-prefix-sum-for-matrix-o-n-m",
                "content": "Observe that for any (i, j) the required sum would of the submatrix for the cells : `(i - k, j - k)` to `(i + k, j + k)` [Considering the bounds of the matrix].\\n\\nSo, use prefix sum technique to calculate the prefix sum in `dp` matrix and use it for evaluating required solution.\\n\\nTime : `O(n*m)`\\nSpace : `O(n*m)`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans;\\n        int n = mat.size();\\n        if(n == 0)\\n            return ans;\\n        int m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                    dp[i][j] = mat[0][0];\\n                else if(i == 0)\\n                    dp[i][j] = dp[i][j-1] + mat[i][j];\\n                else if(j == 0)\\n                    dp[i][j] = dp[i - 1][j] + mat[i][j];\\n                else\\n                    dp[i][j] =  dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int s = (i - k >= 0 ? i - k : 0), e = (j - k >= 0 ? j - k : 0);\\n                int s1 = (i + k < n ? i + k : n - 1), e1 = (j + k < m ? j + k : m - 1);\\n                \\n                int sum = dp[s1][e1];\\n                if(s >= 1 && e >= 1)\\n                    sum += dp[s - 1][e - 1];\\n                if(s >= 1)\\n                    sum -= dp[s-1][e1];\\n                if(e >= 1)\\n                    sum -= dp[s1][e - 1];\\n                mat[i][j] = sum;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans;\\n        int n = mat.size();\\n        if(n == 0)\\n            return ans;\\n        int m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                    dp[i][j] = mat[0][0];\\n                else if(i == 0)\\n                    dp[i][j] = dp[i][j-1] + mat[i][j];\\n                else if(j == 0)\\n                    dp[i][j] = dp[i - 1][j] + mat[i][j];\\n                else\\n                    dp[i][j] =  dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int s = (i - k >= 0 ? i - k : 0), e = (j - k >= 0 ? j - k : 0);\\n                int s1 = (i + k < n ? i + k : n - 1), e1 = (j + k < m ? j + k : m - 1);\\n                \\n                int sum = dp[s1][e1];\\n                if(s >= 1 && e >= 1)\\n                    sum += dp[s - 1][e - 1];\\n                if(s >= 1)\\n                    sum -= dp[s-1][e1];\\n                if(e >= 1)\\n                    sum -= dp[s1][e - 1];\\n                mat[i][j] = sum;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151689,
                "title": "beats-100-prefix-sum-tc-o-n-m-sc-o-n-m-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->PreFix sum will give solution in O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Prefix Sum.\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>presum;\\n    int solve(vector<vector<int>>&ans,int row1, int col1, int row2, int col2) {\\n        int sum=0;\\n        sum+=presum[row2][col2];\\n        if(col1>0) sum-=presum[row2][col1-1];\\n        if(row1>0) sum-=presum[row1-1][col2];\\n        if(col1>0 && row1>0) sum+=presum[row1-1][col1-1];\\n        return sum;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        presum=matrix;\\n        for(int i=1;i<n;i++)\\n            presum[0][i]+=presum[0][i-1];\\n        for(int i=1;i<m;i++)\\n            presum[i][0]+=presum[i-1][0];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                presum[i][j]+=presum[i-1][j]+presum[i][j-1]-presum[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=solve(ans,(i<k)?0:i-k,(j<k)?0:j-k,(i+k)>=m?m-1:i+k,(j+k)>=n?n-1:j+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>presum;\\n    int solve(vector<vector<int>>&ans,int row1, int col1, int row2, int col2) {\\n        int sum=0;\\n        sum+=presum[row2][col2];\\n        if(col1>0) sum-=presum[row2][col1-1];\\n        if(row1>0) sum-=presum[row1-1][col2];\\n        if(col1>0 && row1>0) sum+=presum[row1-1][col1-1];\\n        return sum;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        presum=matrix;\\n        for(int i=1;i<n;i++)\\n            presum[0][i]+=presum[0][i-1];\\n        for(int i=1;i<m;i++)\\n            presum[i][0]+=presum[i-1][0];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                presum[i][j]+=presum[i-1][j]+presum[i][j-1]-presum[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=solve(ans,(i<k)?0:i-k,(j<k)?0:j-k,(i+k)>=m?m-1:i+k,(j+k)>=n?n-1:j+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513557,
                "title": "javascript-dp-solution-beats-100-00",
                "content": "Run time - O (m*n)\\n```\\n\\nvar matrixBlockSum = function(mat, K) {\\n    // create DP Table matrix (m+1 * n+1)\\n    let dp = Array(mat.length + 1);\\n\\t// set first row value as 0\\n    dp[0] = Array(mat[0].length + 1).fill(0);\\n\\t\\n    // fill dp table with cumulative sum from (0,0) to (i,j)\\n    for(let i = 0; i < mat.length; i++){\\n        dp[i+1] = [0];\\n        for(let j = 0; j < mat[0].length; j++){\\n            dp[i+1][j+1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n        }\\n    }\\n    // find sum of r, c cells (cells in square) using DP table (inclusion/exclusion)\\n    for(let i = 0; i < mat.length; i++){\\n        for(let j = 0; j < mat[0].length;j++){\\n            let r1 = Math.max(0, i - K), r2 = Math.min(mat.length - 1, i + K);\\n            let c1 = Math.max(0, j - K), c2 = Math.min(mat[0].length - 1, j + K);\\n            // r1++; r2++; c1++; c2++;\\n            mat[i][j] = dp[r2 + 1][c2 + 1] - dp[r1][c2 + 1] - dp[r2 + 1][c1] + dp[r1][c1]\\n        }\\n    }\\n    // used mat as result matrix\\n    return mat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nvar matrixBlockSum = function(mat, K) {\\n    // create DP Table matrix (m+1 * n+1)\\n    let dp = Array(mat.length + 1);\\n\\t// set first row value as 0\\n    dp[0] = Array(mat[0].length + 1).fill(0);\\n\\t\\n    // fill dp table with cumulative sum from (0,0) to (i,j)\\n    for(let i = 0; i < mat.length; i++){\\n        dp[i+1] = [0];\\n        for(let j = 0; j < mat[0].length; j++){\\n            dp[i+1][j+1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n        }\\n    }\\n    // find sum of r, c cells (cells in square) using DP table (inclusion/exclusion)\\n    for(let i = 0; i < mat.length; i++){\\n        for(let j = 0; j < mat[0].length;j++){\\n            let r1 = Math.max(0, i - K), r2 = Math.min(mat.length - 1, i + K);\\n            let c1 = Math.max(0, j - K), c2 = Math.min(mat[0].length - 1, j + K);\\n            // r1++; r2++; c1++; c2++;\\n            mat[i][j] = dp[r2 + 1][c2 + 1] - dp[r1][c2 + 1] - dp[r2 + 1][c1] + dp[r1][c1]\\n        }\\n    }\\n    // used mat as result matrix\\n    return mat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477275,
                "title": "c-concise-solution",
                "content": "```\\nclass Solution\\n{\\n    vector<vector<int>> mat;\\npublic:\\n    int get_rectangle_sum(int x, int y, int p, int q);\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k);\\n};\\n\\nint Solution :: get_rectangle_sum(int x, int y, int p, int q)\\n{\\n    int top_left = x and y ? mat[x-1][y-1] : 0;\\n    int top_right = x ? mat[x-1][q] : 0;\\n    int bot_left = y ? mat[p][y-1] : 0;\\n    int bot_right = mat[p][q];\\n    \\n    \\n    int sum = bot_right - top_right;\\n    sum -= (bot_left - top_left);\\n    \\n    return sum;\\n}\\n\\nvector<vector<int>> Solution :: matrixBlockSum(vector<vector<int>>& input_matrix, int k)\\n{\\n    // Serious Bug (Due to Name Collision)\\n    this->mat = input_matrix;\\n    \\n    int row = mat.size();\\n    int col = mat[0].size();\\n    \\n    // Convert to partial sum\\n    for(int i = 0; i < row; i++)\\n    {\\n        int running_sum = 0;\\n        for(int j = 0; j < col; j++)\\n        {\\n            running_sum += mat[i][j];\\n            mat[i][j] = running_sum + (i ? mat[i-1][j] : 0);\\n        }\\n    }\\n    \\n    vector<vector<int>> res(row, vector<int>(col, 0));\\n    \\n    for(int i = 0; i < row; i++)\\n    {\\n        for(int j = 0; j < col; j++)\\n        {\\n            int x = i-k, y = j-k;\\n            int p = i+k, q = j+k;\\n            \\n            res[i][j] = get_rectangle_sum(max(0,x), max(0,y), min(row - 1, p), min(col - 1, q));\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    vector<vector<int>> mat;\\npublic:\\n    int get_rectangle_sum(int x, int y, int p, int q);\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k);\\n};\\n\\nint Solution :: get_rectangle_sum(int x, int y, int p, int q)\\n{\\n    int top_left = x and y ? mat[x-1][y-1] : 0;\\n    int top_right = x ? mat[x-1][q] : 0;\\n    int bot_left = y ? mat[p][y-1] : 0;\\n    int bot_right = mat[p][q];\\n    \\n    \\n    int sum = bot_right - top_right;\\n    sum -= (bot_left - top_left);\\n    \\n    return sum;\\n}\\n\\nvector<vector<int>> Solution :: matrixBlockSum(vector<vector<int>>& input_matrix, int k)\\n{\\n    // Serious Bug (Due to Name Collision)\\n    this->mat = input_matrix;\\n    \\n    int row = mat.size();\\n    int col = mat[0].size();\\n    \\n    // Convert to partial sum\\n    for(int i = 0; i < row; i++)\\n    {\\n        int running_sum = 0;\\n        for(int j = 0; j < col; j++)\\n        {\\n            running_sum += mat[i][j];\\n            mat[i][j] = running_sum + (i ? mat[i-1][j] : 0);\\n        }\\n    }\\n    \\n    vector<vector<int>> res(row, vector<int>(col, 0));\\n    \\n    for(int i = 0; i < row; i++)\\n    {\\n        for(int j = 0; j < col; j++)\\n        {\\n            int x = i-k, y = j-k;\\n            int p = i+k, q = j+k;\\n            \\n            res[i][j] = get_rectangle_sum(max(0,x), max(0,y), min(row - 1, p), min(col - 1, q));\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502618,
                "title": "python3-simple-and-very-fast-with-prefix-sums-of-prefix-sums",
                "content": "## Introduction\\n\\nEasy and clean approach in Python3:\\n\\n1. Compute prefix sums on the input matrix across columns for each row\\n2. Compute prefix sums **on the prefix sums** across rows for each column.\\n3. Update every cell in the input matrix using #2 above in O(1) runtime regardless of K\\n\\n**Runtime**: O(m * n) * O(1)\\n**Storage**: O(m * n)\\n\\n*Note: Because we are reusing the input `mat` for the output storage, we only use `n * m` extra storage in this implementation.  Also, we could use clever approaches to do all of this inplace if needed. :)*\\n\\n## Approach\\nThe important realization for this approach is as follows:\\n\\nWe have a columnar prefix sum of a prefix sum of rows for the matrix. That means that any given cell `(y, x)` in this \"prefix prefix sum\" (call it `DP`) contains the total sum from cells 0 to x, 0 to y.  Using the same approach as Prefix Sum subtraction to get sub-sums in a 1d array, we can do this in a 2d array as well, but with a small adjustment to deal with double-counting numbers.\\n\\nGiven a cell at `(y, x)` and a `k` value, we can come up with the min and max cells that represent the sub-matrix.  We need to find `(y1,x1)` and `(y2,x2`) by using `k` as an offset, and repespecting the max and min values of each dimension.\\n\\n```\\nx1 = max(0, j-k)\\nx2 = min(j+k, m-1)\\ny1 = max(0, i-k)\\ny2 = min(i+k, n-1)\\n```\\n\\nTo determine the sub-matrix sub, we use the following simple formula:\\n\\n`subsum = DP[y2][x2] - DP[y2][x1-1] - DPS[y1-1][x2] + DPS[y1-1][x1-1]`\\n\\n\\n\\n## Example\\n\\nTake the sample input matrix below with 5 columns and 7 rows.\\n\\n![image](https://assets.leetcode.com/users/images/63dc10d8-c29c-403b-a093-6469d98e7726_1661825409.936886.png)\\n\\nWe can compute the prefix sums per row to get the following result. We simply add the subtotal starting from position to each cell from left to right.  For example, in row `0`, we start with `1`, add `8` to get `9`, and `9` to get `18`, add `8` to get `26`, and add `6` to get `32`.\\n\\n![image](https://assets.leetcode.com/users/images/9541cf22-9b4c-4374-b0e6-00d47b50d4c5_1661825526.9198332.png)\\n\\nWe can now compute prefix sums on this set of prefix sums, but going top-to-bottom this time.\\n\\n![image](https://assets.leetcode.com/users/images/83d435a0-8a1b-4b6c-bafe-0119f81ba33f_1661826391.938828.png)\\n\\nNow, if we want to know the total of all cells in the original matrix, we just read it from `DP[6][4]` as `183`. \\n\\nAssume we want to get the total sub-area of a cell at `y=2`, `x=2`, with `k=1`.  That would mean we need:\\n\\n`x1 = 1, y1 = 1, x2 = 3, y2 = 3`\\n\\nBy simple inspection of the input matrix, we observe the total as `46`.  \\n\\n![image](https://assets.leetcode.com/users/images/3689fde1-d360-411e-ac36-e3580d15dd90_1661824837.394279.png)\\n\\nNow, let\\'s look at the Prefix Prefix Sum array to look up the answer that way\\n\\n![image](https://assets.leetcode.com/users/images/fc932ffe-b0fa-4aeb-b460-412cd4b73022_1661826773.2453089.png)\\n\\n`subsum = DP[y2][x2] - DP[y2][x1-1] - DPS[y1-1][x2] + DPS[y1-1][x1-1]`\\n`subsum = DP[3][3] - DP[3][0] - DPS[0][3] + DPS[0][0]`\\n`subsum = 81 - 10 - 26 + 1`\\n`subsum = 46`\\n\\nNote that these lookups are constant time, so it\\'s very efficient to do it per cell in the input matrix.\\n\\n## Code\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        dp = [[mat[i][j] for j in range(m)] for i in range(n)]\\n\\n        # Prefix Sums Left to Right\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] += (dp[i][j-1] if j > 0 else 0)\\n        \\n        # Prefix Sums of Sums Top to Bottom\\n        for j in range(m):\\n            for i in range(n):\\n                dp[i][j] += (dp[i-1][j] if i > 0 else 0)\\n                        \\n        # Update input Mat with sum per cell\\n        for i in range(n):\\n            for j in range(m):\\n                x1, x2 = max(0, j-k), min(j+k, m-1)\\n                y1, y2 = max(0, i-k), min(i+k, n-1)\\n                dy = dp[y1-1][x2] if y1 > 0 else 0\\n                dx = dp[y2][x1-1] if x1 > 0 else 0\\n                dz = dp[y1-1][x1-1] if (x1 > 0 and y1 > 0) else 0\\n                mat[i][j] = dp[y2][x2] - dy - dx + dz\\n\\n        return mat\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nx1 = max(0, j-k)\\nx2 = min(j+k, m-1)\\ny1 = max(0, i-k)\\ny2 = min(i+k, n-1)\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        dp = [[mat[i][j] for j in range(m)] for i in range(n)]\\n\\n        # Prefix Sums Left to Right\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] += (dp[i][j-1] if j > 0 else 0)\\n        \\n        # Prefix Sums of Sums Top to Bottom\\n        for j in range(m):\\n            for i in range(n):\\n                dp[i][j] += (dp[i-1][j] if i > 0 else 0)\\n                        \\n        # Update input Mat with sum per cell\\n        for i in range(n):\\n            for j in range(m):\\n                x1, x2 = max(0, j-k), min(j+k, m-1)\\n                y1, y2 = max(0, i-k), min(i+k, n-1)\\n                dy = dp[y1-1][x2] if y1 > 0 else 0\\n                dx = dp[y2][x1-1] if x1 > 0 else 0\\n                dz = dp[y1-1][x1-1] if (x1 > 0 and y1 > 0) else 0\\n                mat[i][j] = dp[y2][x2] - dy - dx + dz\\n\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723821,
                "title": "java-prefixsum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[][] prefixSum = new int[rows+1][cols+1];\\n        for (int i = 1; i <=rows; i++)\\n            for (int j = 1; j<=cols; j++)\\n                prefixSum[i][j] = mat[i-1][j-1] - prefixSum[i-1][j-1] + prefixSum[i-1][j] + prefixSum[i][j-1];\\n        \\n        int[][] result = new int[rows][cols];\\n        for (int i=0; i<rows;i++)\\n            for (int j =0; j < cols; j++){\\n                int i_min = i-k>= 0? i-k:0;\\n                int i_max = Math.min(i+k, rows-1);\\n                int j_min = j-k>=0? j-k:0;\\n                int j_max = Math.min(j+k, cols-1);\\n                result[i][j] = prefixSum[i_min][j_min]+prefixSum[i_max+1][j_max+1] - prefixSum[i_max+1][j_min] -prefixSum[i_min][j_max+1];\\n            }\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[][] prefixSum = new int[rows+1][cols+1];\\n        for (int i = 1; i <=rows; i++)\\n            for (int j = 1; j<=cols; j++)\\n                prefixSum[i][j] = mat[i-1][j-1] - prefixSum[i-1][j-1] + prefixSum[i-1][j] + prefixSum[i][j-1];\\n        \\n        int[][] result = new int[rows][cols];\\n        for (int i=0; i<rows;i++)\\n            for (int j =0; j < cols; j++){\\n                int i_min = i-k>= 0? i-k:0;\\n                int i_max = Math.min(i+k, rows-1);\\n                int j_min = j-k>=0? j-k:0;\\n                int j_max = Math.min(j+k, cols-1);\\n                result[i][j] = prefixSum[i_min][j_min]+prefixSum[i_max+1][j_max+1] - prefixSum[i_max+1][j_min] -prefixSum[i_min][j_max+1];\\n            }\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572339,
                "title": "c-solution-using-prefix-sum-of-matrix",
                "content": "First, we need to calculate the prefix matrix of the given matrix. Then we can make changes to each element in it according to given \\'k\\'.\\nFor prefix matrix, pre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]\\n\\n**Time and Space Complexities :** Time Complexity : O(mxn), Auxiliary Space : O(mxn)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(), n=mat[0].size();\\n        //calculating prefix-sum of matrix - prefix[i][j] = prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i>0) mat[i][j] += mat[i-1][j];\\n                if(j>0) mat[i][j] += mat[i][j-1];\\n                if(i>0 && j>0) mat[i][j] -= mat[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        \\n        //calculating matrix block sum\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int r0=max(0, i-k), c0=max(0, j-k), r1=min(m-1, i+k), c1=min(n-1, j+k);\\n                \\n                ans[i][j] = mat[r1][c1];\\n                if(r0>0) ans[i][j] -= mat[r0-1][c1];\\n                if(c0>0) ans[i][j] -= mat[r1][c0-1];\\n                if(r0>0 && c0>0) ans[i][j] += mat[r0-1][c0-1];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nIf you like my solution, please upvote :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(), n=mat[0].size();\\n        //calculating prefix-sum of matrix - prefix[i][j] = prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i>0) mat[i][j] += mat[i-1][j];\\n                if(j>0) mat[i][j] += mat[i][j-1];\\n                if(i>0 && j>0) mat[i][j] -= mat[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        \\n        //calculating matrix block sum\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int r0=max(0, i-k), c0=max(0, j-k), r1=min(m-1, i+k), c1=min(n-1, j+k);\\n                \\n                ans[i][j] = mat[r1][c1];\\n                if(r0>0) ans[i][j] -= mat[r0-1][c1];\\n                if(c0>0) ans[i][j] -= mat[r1][c0-1];\\n                if(r0>0 && c0>0) ans[i][j] += mat[r0-1][c0-1];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543109,
                "title": "c-straight-forward-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k)\\n    {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c, 0));\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int val = 0;\\n                int minrow = i - k;\\n                int maxrow = i + k;\\n                int mincol = j - k;\\n                int maxcol = j + k;\\n                while (minrow < 0) ++minrow;\\n                while (maxrow > (r - 1)) --maxrow;\\n                while (mincol < 0) ++mincol;\\n                while (maxcol > (c - 1)) --maxcol;\\n                for (int p = minrow; p <= maxrow; ++p)\\n                {\\n                    for (int q = mincol; q <= maxcol; ++q)\\n                    {\\n                        val += mat[p][q];\\n                    }\\n                }\\n                ans[i][j] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k)\\n    {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c, 0));\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int val = 0;\\n                int minrow = i - k;\\n                int maxrow = i + k;\\n                int mincol = j - k;\\n                int maxcol = j + k;\\n                while (minrow < 0) ++minrow;\\n                while (maxrow > (r - 1)) --maxrow;\\n                while (mincol < 0) ++mincol;\\n                while (maxcol > (c - 1)) --maxcol;\\n                for (int p = minrow; p <= maxrow; ++p)\\n                {\\n                    for (int q = mincol; q <= maxcol; ++q)\\n                    {\\n                        val += mat[p][q];\\n                    }\\n                }\\n                ans[i][j] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522510,
                "title": "c-using-prefix-sum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        //use prefix sum for every row\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }\\n        }\\n        int minRow,minCol,maxRow,maxCol,currSum;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                minRow=max(0,i-k);\\n                maxRow=min(m-1,i+k);\\n                minCol=max(0,j-k);\\n                maxCol=min(n-1,j+k);\\n                //now for every row get the sum of arr between minCol and maxCol\\n                currSum=0;\\n                for(int k=minRow;k<=maxRow;k++)\\n                {\\n                    currSum+=mat[k][maxCol];\\n                    if(minCol>0)\\n                        currSum-=mat[k][minCol-1];\\n                }\\n                ans[i][j]=currSum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        //use prefix sum for every row\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }\\n        }\\n        int minRow,minCol,maxRow,maxCol,currSum;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                minRow=max(0,i-k);\\n                maxRow=min(m-1,i+k);\\n                minCol=max(0,j-k);\\n                maxCol=min(n-1,j+k);\\n                //now for every row get the sum of arr between minCol and maxCol\\n                currSum=0;\\n                for(int k=minRow;k<=maxRow;k++)\\n                {\\n                    currSum+=mat[k][maxCol];\\n                    if(minCol>0)\\n                        currSum-=mat[k][minCol-1];\\n                }\\n                ans[i][j]=currSum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221745,
                "title": "java-prefix-sum-approach-99-faster",
                "content": "The general approach would for every cell of i and j get the possible range of row and column then add all the cell. But in this case it will take very long time and can cause TLE. So we need to come up with the batter approach.\\n\\nSo we will use the prefix sum approach like for an example ->\\n1 2 3 4\\n4 5 6 7\\n8 9 8 7\\nthis is matrix first we are going add all the elements by its row like mat[i][j] += mat[i][j-1]\\n1  3   6  10\\n4  9  15 22\\n8 17 25 32\\nthen we are adding all elements as per itscolums like mat[i][j] += mat[i-1][j]\\n 1    3    6   10\\n 5   12  21  32\\n13  29  46  64\\n\\nThe Idea is, when we get a range of upper limit and lower limit then we can use this addition value so that we will not loop though again and again for every cell\\n\\n##### How does it work ->\\nlet consider this exaple\\n![image](https://assets.leetcode.com/users/images/85b57ea3-9bb9-4566-adca-f47c1249d06d_1621608724.7525039.png)\\nas per some randome value lets say we need to add this rectangle then we can get the value directly which is highlighted in hexagonal cell.\\nSo we can say\\n```\\nif(i_low <= 0 &&  j_low <= 0) result[i][j] = mat[i_up][j_up];\\n```\\nnow consider this,\\n![image](https://assets.leetcode.com/users/images/8a8f4487-6e5a-40d9-aa01-c64e3fa5dda7_1621608974.3861787.png)\\nif we need to add this rectangle then we can say value heighlighted in hexagonal - value highlighted in circle cause that the extra addition added in the hexagonal highlighted value.\\nSo\\n```\\nif(i_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1];\\n```\\nNow consider this,\\n![image](https://assets.leetcode.com/users/images/c84f3378-bb83-46c4-930b-5aedef9b81ab_1621609312.8315823.png)\\nif we need to add this matrix then the value will be, value highlighted in hexagonal - value highlighted in circle same as previous. So,\\n```\\nif(j_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_low-1][j_up];\\n```\\nNow consider this one,\\n![image](https://assets.leetcode.com/users/images/b2cd7180-d9cc-4863-ae89-e9901e25db6d_1621609878.505047.png)\\nif i_low and j_low both are not less or equal to zero then it would be like, after subtracting 2 circle values from the hexagonal value we need to add the value highlighted with star because that\\'s the common value (intersaction part) we are subtracting towice so we need to add it again once.\\n```\\n// if i_ow and j_low are not <= 0\\nresult[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1] - mat[i_low-1][j_up] + mat[i_low-1][j_low-1];\\n```\\n\\nand this is the total code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n = mat.length, m = mat[0].length;\\n        int[][] result = new int[n][m];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 1 ; j < m ; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        for(int j = 0 ; j < m ; j++){\\n            for(int i = 1 ; i < n ; i++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                int i_low = i-k, i_up = i+k;\\n                int j_low = j-k, j_up = j+k;\\n\\t\\t\\t\\t// if i_up and j_up is exceeding the range then we have to make it as the maximum possible range in the matrix.\\n                if(i_up >= n) i_up = n-1;\\n                if(j_up >= m) j_up = m-1;\\n                if(i_low <= 0 && j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up];\\n                } else if(i_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1];\\n                } else if(j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_low-1][j_up];\\n                } else result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1]-\\n                    mat[i_low-1][j_up]+mat[i_low-1][j_low-1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nTC --> Linear Time Complexity\\nSC --> Also  linear as we are storing the values into result matrix\\n![image](https://assets.leetcode.com/users/images/c29981dc-116e-48ff-a826-cb09e71cf12c_1621610434.64838.png)\\n### Thank You, Happy Learning....",
                "solutionTags": [],
                "code": "```\\nif(i_low <= 0 &&  j_low <= 0) result[i][j] = mat[i_up][j_up];\\n```\n```\\nif(i_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1];\\n```\n```\\nif(j_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_low-1][j_up];\\n```\n```\\n// if i_ow and j_low are not <= 0\\nresult[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1] - mat[i_low-1][j_up] + mat[i_low-1][j_low-1];\\n```\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n = mat.length, m = mat[0].length;\\n        int[][] result = new int[n][m];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 1 ; j < m ; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        for(int j = 0 ; j < m ; j++){\\n            for(int i = 1 ; i < n ; i++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                int i_low = i-k, i_up = i+k;\\n                int j_low = j-k, j_up = j+k;\\n\\t\\t\\t\\t// if i_up and j_up is exceeding the range then we have to make it as the maximum possible range in the matrix.\\n                if(i_up >= n) i_up = n-1;\\n                if(j_up >= m) j_up = m-1;\\n                if(i_low <= 0 && j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up];\\n                } else if(i_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1];\\n                } else if(j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_low-1][j_up];\\n                } else result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1]-\\n                    mat[i_low-1][j_up]+mat[i_low-1][j_low-1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884851,
                "title": "c-o-m-n-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n            int n=mat.size(),m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n                for(int j=1;j<m;j++){\\n                        mat[i][j]+=mat[i][j-1];\\n                }\\n        }\\n            for(int i=0;i<m;i++){\\n                for(int j=1;j<n;j++){\\n                        mat[j][i]+=mat[j-1][i];\\n                }\\n        }\\n            vector<vector<int> > ans(n,vector<int>(m,0));\\n            for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                            int x1=max(-1,i-K-1),y1=max(-1,j-K-1),x2=min(n-1,i+K),y2=min(m-1,j+K);\\n                            if(x1==-1 && y1==-1){\\n                                    ans[i][j]=mat[x2][y2];\\n                            }\\n                            else if(x1==-1 || y1==-1){\\n                                    if(x1==-1)\\n                                            x1=x2;\\n                                    if(y1==-1)\\n                                            y1=y2;\\n                                    ans[i][j]=mat[x2][y2]-mat[x1][y1];\\n                            }\\n                            else\\n                                    ans[i][j]=mat[x2][y2]+mat[x1][y1]-mat[x1][y2]-mat[x2][y1];\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n            int n=mat.size(),m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n                for(int j=1;j<m;j++){\\n                        mat[i][j]+=mat[i][j-1];\\n                }\\n        }\\n            for(int i=0;i<m;i++){\\n                for(int j=1;j<n;j++){\\n                        mat[j][i]+=mat[j-1][i];\\n                }\\n        }\\n            vector<vector<int> > ans(n,vector<int>(m,0));\\n            for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                            int x1=max(-1,i-K-1),y1=max(-1,j-K-1),x2=min(n-1,i+K),y2=min(m-1,j+K);\\n                            if(x1==-1 && y1==-1){\\n                                    ans[i][j]=mat[x2][y2];\\n                            }\\n                            else if(x1==-1 || y1==-1){\\n                                    if(x1==-1)\\n                                            x1=x2;\\n                                    if(y1==-1)\\n                                            y1=y2;\\n                                    ans[i][j]=mat[x2][y2]-mat[x1][y1];\\n                            }\\n                            else\\n                                    ans[i][j]=mat[x2][y2]+mat[x1][y1]-mat[x1][y2]-mat[x2][y1];\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520251,
                "title": "python-solution-with-visualized-explanations-for-integrated-images",
                "content": "The key idea here is integrated image, a widely used technique in the field of image processing.\\n\\n![image](https://assets.leetcode.com/users/xuawai/image_1582632235.png)\\n\\nAnd the sum of a sub-matrix `S = A[1][1] + A[1][2] + A[2][1] + A[2][2]` can be calculated as `S = S1 - S2 - S3 + S4 = B[2][2]-B[2][0]-B[0][2]+B[0][0]`, which is th basis of our solution.\\n\\n![image](https://assets.leetcode.com/users/xuawai/image_1582632240.png)\\n\\n----\\n\\nSince `(r, c)` might be an invalid position in the matrix, we expand the matrix first to save the effort dealing with boundary conditions. For more details, refer to the codes. \\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int):\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        /* expand the m*n matrix to (m+2*(K+1))*(n+2*(K+1)) matrix */\\n        def expand(mat, K):\\n            new_mat = [[0 for _ in range(n + 2 * (K + 1))] for _ in range(m + 2 * (K + 1))]\\n            for i in range(m):\\n                for j in range(n):\\n                    new_mat[i + K + 1][j + K + 1] = mat[i][j]\\n            return new_mat\\n\\n        mat = expand(mat, K)\\n        /* compute the integrated image */\\n        for i in range(m + 2 * (K + 1)):\\n            for j in range(n + 2 * (K + 1)):\\n                top_v = mat[i - 1][j] if i - 1 >= 0 else 0\\n                left_v = mat[i][j - 1] if j - 1 >= 0 else 0\\n                top_left_v = mat[i - 1][j - 1] if i - 1 >= 0 and j - 1 >= 0 else 0\\n                mat[i][j] = mat[i][j] + top_v + left_v - top_left_v\\n\\n        /* compute the sum of each sub-matrix for answer[i][j].\\n         No boundary conditions have to be considered since we have expanded the original matrix\\n\\t\\t*/\\n        ans = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = mat[i + (K+1) + K][j + (K+1) + K] - mat[i + (K+1) + K][j]\\\\\\n                            - mat[i][j + (K+1) + K] + mat[i][j]\\n        return ans\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int):\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        /* expand the m*n matrix to (m+2*(K+1))*(n+2*(K+1)) matrix */\\n        def expand(mat, K):\\n            new_mat = [[0 for _ in range(n + 2 * (K + 1))] for _ in range(m + 2 * (K + 1))]\\n            for i in range(m):\\n                for j in range(n):\\n                    new_mat[i + K + 1][j + K + 1] = mat[i][j]\\n            return new_mat\\n\\n        mat = expand(mat, K)\\n        /* compute the integrated image */\\n        for i in range(m + 2 * (K + 1)):\\n            for j in range(n + 2 * (K + 1)):\\n                top_v = mat[i - 1][j] if i - 1 >= 0 else 0\\n                left_v = mat[i][j - 1] if j - 1 >= 0 else 0\\n                top_left_v = mat[i - 1][j - 1] if i - 1 >= 0 and j - 1 >= 0 else 0\\n                mat[i][j] = mat[i][j] + top_v + left_v - top_left_v\\n\\n        /* compute the sum of each sub-matrix for answer[i][j].\\n         No boundary conditions have to be considered since we have expanded the original matrix\\n\\t\\t*/\\n        ans = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = mat[i + (K+1) + K][j + (K+1) + K] - mat[i + (K+1) + K][j]\\\\\\n                            - mat[i][j + (K+1) + K] + mat[i][j]\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 477219,
                "title": "short-python",
                "content": "Of course with prefix sums, as always, so O(mn).\\n```\\nfrom itertools import accumulate as acc\\n\\nclass Solution:\\n    def matrixBlockSum(self, A, K):\\n        m, n = len(A), len(A[0])\\n        ps = [*zip(*map(acc, zip(*map(acc, A))))]\\n        def s(i, j):\\n            return i >= 0 <= j and ps[min(i, m-1)][min(j, n-1)]\\n        return [[s(i+K, j+K) - s(i-K-1, j+K) - s(i+K, j-K-1) + s(i-K-1, j-K-1)\\n                 for j in range(n)] for i in range(m)]\\n```\\nFirst I compute prefix sums, so that `ps[i][j]` is the sum of the submatrix from top-left to (i, j):\\n```\\n     A:                 ps:\\n[[1, 2, 3],      [( 1,  3,  6),\\n [4, 5, 6],  =>   ( 5, 12, 21),\\n [7, 8, 9]]       (12, 27, 45)]\\n```\\nFor example `ps[1][1] = 12` = 1+2+4+5.\\n\\nMy helper `s` looks up the `ps` value and adjusts out-of-bounds requests.\\n\\nAnd then I just compute the requested submatrix sums the usual way by combining four prefix sums.",
                "solutionTags": [],
                "code": "```\\nfrom itertools import accumulate as acc\\n\\nclass Solution:\\n    def matrixBlockSum(self, A, K):\\n        m, n = len(A), len(A[0])\\n        ps = [*zip(*map(acc, zip(*map(acc, A))))]\\n        def s(i, j):\\n            return i >= 0 <= j and ps[min(i, m-1)][min(j, n-1)]\\n        return [[s(i+K, j+K) - s(i-K-1, j+K) - s(i+K, j-K-1) + s(i-K-1, j-K-1)\\n                 for j in range(n)] for i in range(m)]\\n```\n```\\n     A:                 ps:\\n[[1, 2, 3],      [( 1,  3,  6),\\n [4, 5, 6],  =>   ( 5, 12, 21),\\n [7, 8, 9]]       (12, 27, 45)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477083,
                "title": "python-numpy-solution",
                "content": "```\\nimport numpy as np\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        mat2 = np.array(mat)\\n        m,n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                LCi, UCi = max(0,i-K), min(m,i+K)\\n                LCj, UCj = max(0,j-K), min(m,j+K)\\n                mat[i][j] = np.sum(mat2[LCi:UCi+1,LCj:UCj+1])\\n                \\n        return mat\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        mat2 = np.array(mat)\\n        m,n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                LCi, UCi = max(0,i-K), min(m,i+K)\\n                LCj, UCj = max(0,j-K), min(m,j+K)\\n                mat[i][j] = np.sum(mat2[LCi:UCi+1,LCj:UCj+1])\\n                \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484196,
                "title": "java-fast-solution-o-mn",
                "content": "![image](https://assets.leetcode.com/users/images/231cba59-fa97-41fd-b1eb-db0144d2a42a_1632532391.2037432.jpeg)\\nAbout how to calcuate specific sum, you can find the solution from the problem 304:https://leetcode.com/problems/range-sum-query-2d-immutable/submissions/\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] sum = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    sum[i][j] = mat[i][j];\\n                }else if(i == 0){\\n                    sum[0][j] = sum[0][j - 1] + mat[i][j];\\n                }else if(j == 0){\\n                    sum[i][0] = sum[i - 1][j] + mat[i][j];\\n                }else{\\n                    sum[i][j] = mat[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int[][] result = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            int iLow = Math.max(i - k, 0);\\n            int iHigh = Math.min(i + k, m - 1);\\n            for(int j = 0; j < n; j++){\\n                int jLow = Math.max(j - k, 0);\\n                int jHigh = Math.min(j + k, n - 1);\\n                if(iLow == 0 && jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh];\\n                }\\n                else if(iLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1];\\n                }\\n                else if(jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iLow - 1][jHigh];\\n                }else{\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1] - sum[iLow - 1][jHigh] + sum[iLow - 1][jLow - 1];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] sum = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    sum[i][j] = mat[i][j];\\n                }else if(i == 0){\\n                    sum[0][j] = sum[0][j - 1] + mat[i][j];\\n                }else if(j == 0){\\n                    sum[i][0] = sum[i - 1][j] + mat[i][j];\\n                }else{\\n                    sum[i][j] = mat[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int[][] result = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            int iLow = Math.max(i - k, 0);\\n            int iHigh = Math.min(i + k, m - 1);\\n            for(int j = 0; j < n; j++){\\n                int jLow = Math.max(j - k, 0);\\n                int jHigh = Math.min(j + k, n - 1);\\n                if(iLow == 0 && jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh];\\n                }\\n                else if(iLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1];\\n                }\\n                else if(jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iLow - 1][jHigh];\\n                }else{\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1] - sum[iLow - 1][jHigh] + sum[iLow - 1][jLow - 1];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450572,
                "title": "2-c-solution-explained-one-with-dp-and-one-without-dp",
                "content": "# **Brute force**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t//m and n are the size of the matrix (m * n)\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        vector<vector<int>> res(m);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//start point of the rectangle to add for current res (so the most left-top value to add)\\n\\t\\t\\t\\t//note : when i - k or j - k is less than 0 set them to 0 to avoid errors\\n                int start_i = max(i - k, 0);\\n                int start_j = max(j - k, 0);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//end point of the rectangle to add for current res (so the most right-bottom value to add)\\n\\t\\t\\t\\t//note : when i + k is more than m set it to m - 1 to avoid errors\\n\\t\\t\\t\\t//note : when j + k is more than n set it to n - 1 to avoid errors\\n\\t\\t\\t\\tint end_i = min(i + k, m - 1);\\n                int end_j = min(j + k, n - 1);\\n\\n\\t\\t\\t     //temp is used to get the sum of the rectangle to add ( from the most left-top value to add to the most right-bottom value to add)\\n\\t\\t\\t\\t int temp = 0;\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t//start the loop from the most left-top value to add to the most right-bottom value to add\\n\\t\\t\\t\\t//and add the value gotten from the loop to temp \\n                for (int i2 = start_i; i2 <= end_i; i2++) {\\n                    for (int j2 = start_j; j2 <= end_j; j2++) {\\n                        temp += mat[i2][j2];\\n                    }\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//save temp to res[i]\\n                res[i].push_back(temp);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# **Solution with dp**\\n##### a graphic example of this code \\n\\n`mat =` ![image](https://assets.leetcode.com/users/images/234e98d6-434b-49a3-bc33-d33e13792eb4_1631032286.5834684.png)\\n\\nprefix is the sum of all value on the its left and top values\\n`prefix  =`![image](https://assets.leetcode.com/users/images/fe9f070e-5c55-4fd8-b2e8-5db3d80bc4c6_1631032590.110889.png) \\nexample steps to get prefix \\n\\t1   = 1![image](https://assets.leetcode.com/users/images/cfd78e47-38ad-4b9a-b6ca-dde2f118fe70_1631032780.6209137.png)\\n3   = 1 + 2 ![image](https://assets.leetcode.com/users/images/a54b950b-29c2-4a16-b253-26f80a25b9ee_1631032813.739592.png)\\n6   = 1 + 2 + 3 ![image](https://assets.leetcode.com/users/images/bfa5d3db-892c-4d8d-ab36-d1e9789fd926_1631032834.894085.png)\\n5   = 1 + 4![image](https://assets.leetcode.com/users/images/c3e2cd7c-9a9a-4071-871b-f85feec8135b_1631032850.5958931.png)\\n12 = 1+ 2 +4 +5![image](https://assets.leetcode.com/users/images/3a02c080-71c0-4117-bf08-3bcad0f78863_1631032892.6218936.png)\\n...\\n\\n`k  = 1   ` `mat =` ![image](https://assets.leetcode.com/users/images/234e98d6-434b-49a3-bc33-d33e13792eb4_1631032286.5834684.png)     `prefix  =`![image](https://assets.leetcode.com/users/images/fe9f070e-5c55-4fd8-b2e8-5db3d80bc4c6_1631032590.110889.png)  `dp = `![image](https://assets.leetcode.com/users/images/04e4a05b-7ab3-4808-9cdd-80f99da9b021_1631033116.2625937.png)  \\n \\n example of step to get dp[2][2] (the last one on the bot-right)\\n*  we want this part![image](https://assets.leetcode.com/users/images/754c1718-e7a7-4cbb-b7f7-2e0b86a16873_1631033419.5090227.png)\\n*  so we get `prefix[2][2]` which is equal to 45 so the sum of all matrix ![image](https://assets.leetcode.com/users/images/5e49b9a9-b6e9-479a-be9a-c02d9599635e_1631033363.605127.png)\\n* from that we remove the top part ![image](https://assets.leetcode.com/users/images/be1ec77a-981f-4ac6-8a8d-ea0aed446aca_1631033449.1404293.png)\\n* then we remove the left part ![image](https://assets.leetcode.com/users/images/7bc15293-eb4d-42ea-8544-ab6ab4d9a62f_1631033472.9346817.png)\\n* since we remove the top left part twice we need to add it back ![image](https://assets.leetcode.com/users/images/10e4a526-a078-4de9-8055-fba6a30ca427_1631033525.752147.png)\\n* now we get the part that we want. \\n\\n\\n```\\n class Solution {\\n public:\\n     vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t //m and n are the size of the matrix (m * n)\\n         int m = mat.size(), n = mat[0].size();\\n\\t\\t \\n\\t\\t //see above to know what prefix is\\n         vector<vector<int>> prefix(m,vector<int> (n));\\n\\n         for (int i = 0; i < m; i++) {\\n             int sum = 0;\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//sum is sum of all value of the left of mat[i][j] (include mat[i][j])\\n                 sum += mat[i][j];\\n\\t\\t\\t\\t //prefix is the sum of all value above and left of prefix[i][j] (include mat([i][j])\\n                 prefix[i][j] = sum + prefix[max(i - 1,0)][j];\\n             }\\n         }\\n\\n         vector<vector<int>> dp(m,vector<int>(n));\\n         for (int i = 0; i < m; i++) {\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t //index of the most top value to add\\n                 int start_i = i - k;\\n                 //index of the most left value to add\\n\\t\\t\\t\\t int start_j = j - k;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex of the most bottom value to add\\n                 int end_i = min(i + k, m - 1);\\n\\t\\t\\t\\t index of the most right value to add \\n                 int end_j = min(j + k, n - 1);\\n\\n                 int extraPart = 0;\\n\\t\\t\\t\\t //if start_i is less than 1 means that there ins\\'t any extra part on the top\\n                 if (start_i > 0)extraPart += prefix[start_i - 1][end_j];\\n\\t\\t\\t\\t //if start_j is less than 1 means that there isn\\'t any extra part on the left\\n                 if (start_j > 0)extraPart += prefix[end_i][start_j - 1];\\n\\n                 //this is the part that extraPart count 2 times (so this part will delete 2 times, instead of 1, so we need to add it back)\\n                 int PartToAdd = 0;\\n\\t\\t\\t\\t //if start_i or start_j is less than 1 means that there isn\\'t a part that is delete twice\\n\\t\\t\\t\\t //because if start_i is less than 1 means we dind\\'t delete anything of the top, same for start_j (instead of the top, this case the left part)\\n                 if (start_i > 0 && start_j > 0)PartToAdd += prefix[start_i - 1][start_j - 1];\\n\\n                 dp[i][j] = prefix[end_i][end_j] - extraPart + PartToAdd;\\n             }\\n         }\\n\\n\\n         return dp;\\n     }\\n };\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t//m and n are the size of the matrix (m * n)\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        vector<vector<int>> res(m);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//start point of the rectangle to add for current res (so the most left-top value to add)\\n\\t\\t\\t\\t//note : when i - k or j - k is less than 0 set them to 0 to avoid errors\\n                int start_i = max(i - k, 0);\\n                int start_j = max(j - k, 0);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//end point of the rectangle to add for current res (so the most right-bottom value to add)\\n\\t\\t\\t\\t//note : when i + k is more than m set it to m - 1 to avoid errors\\n\\t\\t\\t\\t//note : when j + k is more than n set it to n - 1 to avoid errors\\n\\t\\t\\t\\tint end_i = min(i + k, m - 1);\\n                int end_j = min(j + k, n - 1);\\n\\n\\t\\t\\t     //temp is used to get the sum of the rectangle to add ( from the most left-top value to add to the most right-bottom value to add)\\n\\t\\t\\t\\t int temp = 0;\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t//start the loop from the most left-top value to add to the most right-bottom value to add\\n\\t\\t\\t\\t//and add the value gotten from the loop to temp \\n                for (int i2 = start_i; i2 <= end_i; i2++) {\\n                    for (int j2 = start_j; j2 <= end_j; j2++) {\\n                        temp += mat[i2][j2];\\n                    }\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//save temp to res[i]\\n                res[i].push_back(temp);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\n class Solution {\\n public:\\n     vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t //m and n are the size of the matrix (m * n)\\n         int m = mat.size(), n = mat[0].size();\\n\\t\\t \\n\\t\\t //see above to know what prefix is\\n         vector<vector<int>> prefix(m,vector<int> (n));\\n\\n         for (int i = 0; i < m; i++) {\\n             int sum = 0;\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//sum is sum of all value of the left of mat[i][j] (include mat[i][j])\\n                 sum += mat[i][j];\\n\\t\\t\\t\\t //prefix is the sum of all value above and left of prefix[i][j] (include mat([i][j])\\n                 prefix[i][j] = sum + prefix[max(i - 1,0)][j];\\n             }\\n         }\\n\\n         vector<vector<int>> dp(m,vector<int>(n));\\n         for (int i = 0; i < m; i++) {\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t //index of the most top value to add\\n                 int start_i = i - k;\\n                 //index of the most left value to add\\n\\t\\t\\t\\t int start_j = j - k;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex of the most bottom value to add\\n                 int end_i = min(i + k, m - 1);\\n\\t\\t\\t\\t index of the most right value to add \\n                 int end_j = min(j + k, n - 1);\\n\\n                 int extraPart = 0;\\n\\t\\t\\t\\t //if start_i is less than 1 means that there ins\\'t any extra part on the top\\n                 if (start_i > 0)extraPart += prefix[start_i - 1][end_j];\\n\\t\\t\\t\\t //if start_j is less than 1 means that there isn\\'t any extra part on the left\\n                 if (start_j > 0)extraPart += prefix[end_i][start_j - 1];\\n\\n                 //this is the part that extraPart count 2 times (so this part will delete 2 times, instead of 1, so we need to add it back)\\n                 int PartToAdd = 0;\\n\\t\\t\\t\\t //if start_i or start_j is less than 1 means that there isn\\'t a part that is delete twice\\n\\t\\t\\t\\t //because if start_i is less than 1 means we dind\\'t delete anything of the top, same for start_j (instead of the top, this case the left part)\\n                 if (start_i > 0 && start_j > 0)PartToAdd += prefix[start_i - 1][start_j - 1];\\n\\n                 dp[i][j] = prefix[end_i][end_j] - extraPart + PartToAdd;\\n             }\\n         }\\n\\n\\n         return dp;\\n     }\\n };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182021,
                "title": "simple-c-solution-with-video",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<vector<int>>a(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int x=-k;x<=k;x++){\\n                    if(i+x>=0 && i+x<n){\\n                        int l=max(j-k,0);\\n                        int r=j+k+1;\\n                        a[i+x][l]+=mat[i][j];\\n                        if(r<m) a[i+x][r]-=mat[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            for(int j=0;j<m;j++){\\n                sum+=a[i][j];\\n                a[i][j]=sum;\\n            }\\n        }\\n        re-\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<vector<int>>a(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int x=-k;x<=k;x++){\\n                    if(i+x>=0 && i+x<n){\\n                        int l=max(j-k,0);\\n                        int r=j+k+1;\\n                        a[i+x][l]+=mat[i][j];\\n                        if(r<m) a[i+x][r]-=mat[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            for(int j=0;j<m;j++){\\n                sum+=a[i][j];\\n                a[i][j]=sum;\\n            }\\n        }\\n        re-\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147882,
                "title": "2ms-100-faster-dp-solution-concept-of-prefix-sum-in-2-d-array",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    int n,m;\\n    int dp[][];\\n    int findSum(int r,int s,int p,int q){\\n        return dp[r+1][s+1]-dp[r+1][q]-dp[p][s+1]+dp[p][q];\\n    }\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        this.n=mat.length;\\n        this.m=mat[0].length;\\n         dp=new int[n+1][m+1];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                dp[i+1][j+1]=mat[i][j]+dp[i][j+1]+dp[i+1][j]-dp[i][j];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n                mat[i][j]=findSum(i+k<n ? i+k : n-1,j+k<m ? j+k : m-1,i-k>=0 ? i-k : 0 , j-k>=0 ? j-k : 0);\\n        }\\n        return mat;\\n    }\\n}\\n```\\nTime : O(n*m) \\nSpace: O(n*m)\\n***please,upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    int dp[][];\\n    int findSum(int r,int s,int p,int q){\\n        return dp[r+1][s+1]-dp[r+1][q]-dp[p][s+1]+dp[p][q];\\n    }\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        this.n=mat.length;\\n        this.m=mat[0].length;\\n         dp=new int[n+1][m+1];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                dp[i+1][j+1]=mat[i][j]+dp[i][j+1]+dp[i+1][j]-dp[i][j];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n                mat[i][j]=findSum(i+k<n ? i+k : n-1,j+k<m ? j+k : m-1,i-k>=0 ? i-k : 0 , j-k>=0 ? j-k : 0);\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838172,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int dp[][] = new int[m+1][n+1];\\n        int ans[][] = new int[m][n];\\n        computePrefix(dp,mat,m,n);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K);\\n               int r2 = Math.min(m - 1, i + K), c2 = Math.min(n - 1, j + K);   \\n               ans[i][j] = rangeSum(dp,r1,c1,r2,c2);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void computePrefix(int[][]dp,int[][]mat,int m, int n){\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];\\n    }\\n    \\n    int rangeSum(int[][]dp,int r1,int c1, int r2, int c2){\\n        r1++; c1++; r2++; c2++;\\n        return dp[r2][c2] - dp[r1-1][c2] - dp[r2][c1-1] + dp[r1-1][c1-1];\\n    }\\n}\\n```\\n\\nPrefix sum technique on 2D matrix with amazing video link (Problem num 304)\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/discuss/836388/java-prefix-sum-inplace",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int dp[][] = new int[m+1][n+1];\\n        int ans[][] = new int[m][n];\\n        computePrefix(dp,mat,m,n);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K);\\n               int r2 = Math.min(m - 1, i + K), c2 = Math.min(n - 1, j + K);   \\n               ans[i][j] = rangeSum(dp,r1,c1,r2,c2);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void computePrefix(int[][]dp,int[][]mat,int m, int n){\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];\\n    }\\n    \\n    int rangeSum(int[][]dp,int r1,int c1, int r2, int c2){\\n        r1++; c1++; r2++; c2++;\\n        return dp[r2][c2] - dp[r1-1][c2] - dp[r2][c1-1] + dp[r1-1][c1-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831195,
                "title": "javascript-typescript-solution",
                "content": "// JS\\n// Runtime: 100 ms, faster than 83.15% of JavaScript online submissions for Matrix Block Sum.\\n// Memory Usage: 39.9 MB, less than 20.22% of JavaScript online submissions for Matrix Block Sum.\\n```\\nvar matrixBlockSum = function (mat, K) {\\n  const dp = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n};\\n```\\n\\n// TS\\n// Runtime: 100 ms, faster than 100.00% of TypeScript online submissions for Matrix Block Sum.\\n// Memory Usage: 40.6 MB, less than 100.00% of TypeScript online submissions for Matrix Block Sum.\\n```\\nfunction matrixBlockSum(mat: number[][], K: number): number[][] {\\n  const dp: number[][] = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n}\\n```\\n\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar matrixBlockSum = function (mat, K) {\\n  const dp = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n};\\n```\n```\\nfunction matrixBlockSum(mat: number[][], K: number): number[][] {\\n  const dp: number[][] = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826274,
                "title": "c-prefix-sum-solution",
                "content": "Runtime: 16 ms, faster than 89.46% of C++ online submissions for Matrix Block Sum.\\nMemory Usage: 9.3 MB, less than 97.16% of C++ online submissions for Matrix Block Sum.\\n\\nSolve using prefix sum of row wise sum and then colum wise sum.\\n```\\nGiven Matrix:\\n\\n1, 2, 3\\n4, 5, 6\\n7, 8, 9\\n\\nPrefix Sum matrix:\\n\\n1, 2, 3                     1, 3, 6                               1, 3, 6\\n4, 5, 6       Row Sum ->    4 ,9, 15          Column Sum->        5, 12, 21\\n7, 8, 9                     7, 15, 24                             12, 27, 45 \\n\\nThen exclude and include index based on conditions.\\n\\nGiven K, there is lr,hr and lc,hc for index i and j of Matrix\\nResult [i][j] = mat[hr][hc] - mat[hr][lc-1] - mat[lr-1][hc] + mat[lr-1][lc-1]\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int max(int a, int b)\\n    {\\n        return a>b?a:b;\\n    }\\n    int min(int a, int b)\\n    {\\n        return a<b?a:b;\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        \\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> res(r,vector<int>(c));\\n        \\n        int sum = 0;\\n        for(int i=0;i<r;i++)\\n        {\\n            sum = 0;\\n            for(int j=0;j<c;j++)\\n            {\\n                sum+= mat[i][j];\\n                if(i>0)mat[i][j] = mat[i-1][j] + sum;\\n                else mat[i][j] = sum;\\n            }\\n        }\\n\\n        int lower_i;\\n        int lower_j;\\n        int upper_i;\\n        int upper_j;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                lower_i = max(0,i-K);\\n                upper_i = min(i+K,r-1);\\n                lower_j = max(0,j-K);\\n                upper_j = min(j+K,c-1);\\n                \\n                res[i][j] = mat[upper_i][upper_j] - ((lower_j==0)?0:mat[upper_i][lower_j-1]) - ((lower_i==0)?0:mat[lower_i-1][upper_j]) + ((lower_i==0 || lower_j==0)?0:mat[lower_i-1][lower_j-1]);\\n            }         \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nGiven Matrix:\\n\\n1, 2, 3\\n4, 5, 6\\n7, 8, 9\\n\\nPrefix Sum matrix:\\n\\n1, 2, 3                     1, 3, 6                               1, 3, 6\\n4, 5, 6       Row Sum ->    4 ,9, 15          Column Sum->        5, 12, 21\\n7, 8, 9                     7, 15, 24                             12, 27, 45 \\n\\nThen exclude and include index based on conditions.\\n\\nGiven K, there is lr,hr and lc,hc for index i and j of Matrix\\nResult [i][j] = mat[hr][hc] - mat[hr][lc-1] - mat[lr-1][hc] + mat[lr-1][lc-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int max(int a, int b)\\n    {\\n        return a>b?a:b;\\n    }\\n    int min(int a, int b)\\n    {\\n        return a<b?a:b;\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        \\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> res(r,vector<int>(c));\\n        \\n        int sum = 0;\\n        for(int i=0;i<r;i++)\\n        {\\n            sum = 0;\\n            for(int j=0;j<c;j++)\\n            {\\n                sum+= mat[i][j];\\n                if(i>0)mat[i][j] = mat[i-1][j] + sum;\\n                else mat[i][j] = sum;\\n            }\\n        }\\n\\n        int lower_i;\\n        int lower_j;\\n        int upper_i;\\n        int upper_j;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                lower_i = max(0,i-K);\\n                upper_i = min(i+K,r-1);\\n                lower_j = max(0,j-K);\\n                upper_j = min(j+K,c-1);\\n                \\n                res[i][j] = mat[upper_i][upper_j] - ((lower_j==0)?0:mat[upper_i][lower_j-1]) - ((lower_i==0)?0:mat[lower_i-1][upper_j]) + ((lower_i==0 || lower_j==0)?0:mat[lower_i-1][lower_j-1]);\\n            }         \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457291,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> answer(mat.size(), vector<int>(mat[0].size()));\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.size()) {\\n                    rowEnd = mat.size() - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].size()) {\\n                    colEnd = mat[0].size() - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n    int blockSum(vector<vector<int>>& mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> answer(mat.size(), vector<int>(mat[0].size()));\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.size()) {\\n                    rowEnd = mat.size() - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].size()) {\\n                    colEnd = mat[0].size() - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n    int blockSum(vector<vector<int>>& mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421407,
                "title": "c-easy-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n```\\n1. Create a 2D vector sum of size (row+1) x (col+1) and initialize all elements to 0.\\n\\n2. Compute the prefix sum of the input matrix mat and store the results in sum using the formula:\\n\\n    sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1]\\n\\n3. Create a 2D vector ans of size row x col and initialize all elements to 0.\\n\\n4. For each element ans[i][j] in the output matrix:\\n\\n    Compute the coordinates of the submatrix to sum over using the variables x1, y1, x2, and y2, where:\\n\\n    x1 = max(0, i-k)\\n    y1 = max(0, j-k)\\n    x2 = min(row, i+k+1)\\n    y2 = min(col, j+k+1)\\n\\n5. Compute the sum of the submatrix using the prefix sum stored in sum and store the result in ans[i][j] using the formula:\\n\\n    ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]\\nReturn the output matrix ans.\\n\\n\\n\\n```\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        \\n        // Create a 2D vector to store the prefix sum\\n        vector<vector<int>> sum(row+1, vector<int>(col+1, 0));\\n\\n        // Compute prefix sum\\n        for(int i=1; i<=row; i++) {\\n            for(int j=1; j<=col; j++) {\\n                // Compute the sum of the submatrix from (0, 0) to (i-1, j-1)\\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1];\\n            }\\n        }\\n\\n        // Compute answer\\n        vector<vector<int>> ans(row, vector<int>(col, 0));\\n        for(int i=0; i<row; i++) {\\n            for(int j=0; j<col; j++) {\\n                // Compute the coordinates of the submatrix\\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                int x2 = min(row, i+k+1);\\n                int y2 = min(col, j+k+1);\\n\\n                // Compute the sum of the submatrix using the prefix sum\\n                ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nPlease upvote if you find this helpful!",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n1. Create a 2D vector sum of size (row+1) x (col+1) and initialize all elements to 0.\\n\\n2. Compute the prefix sum of the input matrix mat and store the results in sum using the formula:\\n\\n    sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1]\\n\\n3. Create a 2D vector ans of size row x col and initialize all elements to 0.\\n\\n4. For each element ans[i][j] in the output matrix:\\n\\n    Compute the coordinates of the submatrix to sum over using the variables x1, y1, x2, and y2, where:\\n\\n    x1 = max(0, i-k)\\n    y1 = max(0, j-k)\\n    x2 = min(row, i+k+1)\\n    y2 = min(col, j+k+1)\\n\\n5. Compute the sum of the submatrix using the prefix sum stored in sum and store the result in ans[i][j] using the formula:\\n\\n    ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]\\nReturn the output matrix ans.\\n\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        \\n        // Create a 2D vector to store the prefix sum\\n        vector<vector<int>> sum(row+1, vector<int>(col+1, 0));\\n\\n        // Compute prefix sum\\n        for(int i=1; i<=row; i++) {\\n            for(int j=1; j<=col; j++) {\\n                // Compute the sum of the submatrix from (0, 0) to (i-1, j-1)\\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1];\\n            }\\n        }\\n\\n        // Compute answer\\n        vector<vector<int>> ans(row, vector<int>(col, 0));\\n        for(int i=0; i<row; i++) {\\n            for(int j=0; j<col; j++) {\\n                // Compute the coordinates of the submatrix\\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                int x2 = min(row, i+k+1);\\n                int y2 = min(col, j+k+1);\\n\\n                // Compute the sum of the submatrix using the prefix sum\\n                ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151656,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Brute force appoarch-->\\n\\n# Approach\\n<!-- Iterate through each grid and perform the query -->\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(n*m)^2\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum(int r1,int c1,int r2,int c2,vector<vector<int>>& mat){\\n        int res=0;\\n        for(int i=r1;i<=r2;i++){\\n            for(int j=c1;j<=c2;j++)\\n              res+=mat[i][j];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=i-k<0?0:i-k;\\n               int r2=i+k>=n?n-1:i+k;\\n               int c1=j-k<0?0:j-k;\\n                int c2=j+k>=m?m-1:j+k;\\n                ans[i][j]=sum(r1,c1,r2,c2,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(int r1,int c1,int r2,int c2,vector<vector<int>>& mat){\\n        int res=0;\\n        for(int i=r1;i<=r2;i++){\\n            for(int j=c1;j<=c2;j++)\\n              res+=mat[i][j];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=i-k<0?0:i-k;\\n               int r2=i+k>=n?n-1:i+k;\\n               int c1=j-k<0?0:j-k;\\n                int c2=j+k>=m?m-1:j+k;\\n                ans[i][j]=sum(r1,c1,r2,c2,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303421,
                "title": "python-faster-than-99-o-m-n-dynamic-programming",
                "content": "* First create **a table** where each element equals **the sum of all the elements** that is **left or above** to it (including itself).\\n* Then use this table to **calculate each position**, the trick is mat[i][j]=table[rol1][col1]-table[rol1][col2]-table[rol2][col1]+table[rol2][col2] as the following picture shows( here suppose **K=1**).\\n![image](https://assets.leetcode.com/users/images/f32ade49-1d7f-4754-8745-259864e4cb07_1658222708.851402.png)\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        table = [[0]*(n+1) for _ in range(m+1)]\\n        # res=table.copy()\\n        for i in range(m):\\n            for j in range(n):\\n                table[i+1][j+1]=mat[i][j]+table[i+1][j]+table[i][j+1]-table[i][j]\\n        for i in range(m):\\n            for j in range(n):\\n                rol1=i+K+1 if i+K+1<m+1 else m\\n                rol2=i-K if i-K>=0 else 0\\n                col1=j+K+1 if j+K+1<n+1 else n\\n                col2=j-K if j-K>=0 else 0\\n                mat[i][j]=table[rol1][col1]-table[rol1][col2]-table[rol2][col1]+table[rol2][col2]\\n        return mat\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        table = [[0]*(n+1) for _ in range(m+1)]\\n        # res=table.copy()\\n        for i in range(m):\\n            for j in range(n):\\n                table[i+1][j+1]=mat[i][j]+table[i+1][j]+table[i][j+1]-table[i][j]\\n        for i in range(m):\\n            for j in range(n):\\n                rol1=i+K+1 if i+K+1<m+1 else m\\n                rol2=i-K if i-K>=0 else 0\\n                col1=j+K+1 if j+K+1<n+1 else n\\n                col2=j-K if j-K>=0 else 0\\n                mat[i][j]=table[rol1][col1]-table[rol1][col2]-table[rol2][col1]+table[rol2][col2]\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014863,
                "title": "java-separate-row-and-column-calculations-faster-than-99",
                "content": "We can firstly consider only the rows: traverse each row, and calculate the sum of (2k + 1) numbers for each entry. Store these row sums in an mn matrix rowSum[][].\\n\\nAnd then use the same method for the columns. Traverse each column, and calculate the sum of (2k + 1) numbers from rowSum[][].\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m][n];\\n        int[][] rowSum = new int[m][n];\\n        \\n        // firstly, calculate the row sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (j == 0) {\\n                    for (int l = 0; l <= k && l < n; l++) {\\n                        rowSum[i][j] += mat[i][l];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (j+k < n) next = mat[i][j+k];\\n                    if (j-1-k >= 0) prev = mat[i][j-1-k];\\n\\n                    rowSum[i][j] = rowSum[i][j-1] + next - prev;\\n                }\\n            }\\n        }\\n        \\n        // secondly, calculate the column sum\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (i == 0) {\\n                    for (int l = 0; l <= k && l < m; l++) {\\n                        dp[i][j] += rowSum[l][j];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (i+k < m) next = rowSum[i+k][j];\\n                    if (i-1-k >= 0) prev = rowSum[i-1-k][j];\\n\\n                    dp[i][j] = dp[i-1][j] + next - prev;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m][n];\\n        int[][] rowSum = new int[m][n];\\n        \\n        // firstly, calculate the row sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (j == 0) {\\n                    for (int l = 0; l <= k && l < n; l++) {\\n                        rowSum[i][j] += mat[i][l];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (j+k < n) next = mat[i][j+k];\\n                    if (j-1-k >= 0) prev = mat[i][j-1-k];\\n\\n                    rowSum[i][j] = rowSum[i][j-1] + next - prev;\\n                }\\n            }\\n        }\\n        \\n        // secondly, calculate the column sum\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (i == 0) {\\n                    for (int l = 0; l <= k && l < m; l++) {\\n                        dp[i][j] += rowSum[l][j];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (i+k < m) next = rowSum[i+k][j];\\n                    if (i-1-k >= 0) prev = rowSum[i-1-k][j];\\n\\n                    dp[i][j] = dp[i-1][j] + next - prev;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904651,
                "title": "explained-c-dynamic-programming-solution-using-prefix-sum-2d-o-n-m",
                "content": "**Explanation**\\n1. First, we will create a 2D vector named dp where `dp[i][j]` is the sum of all cells from `(0,0)` to `(i,j)`.\\n2. Then we will build our ans vector, where `ans[i][j] = dp[i+k][j+k] - dp[i-k-1][j+k] - dp[i+k][j-k-1] + dp[i-k-1][j-k-1];`\\n3. Finally return the vector `ans`.\\n**Don\\'t forget to upvote if this help you !**\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> prefix(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                prefix[i][j] = (j > 0 ? prefix[i][j-1] + mat[i][j] : mat[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<int>>dp(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + prefix[i][j];\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int top_row = min(i + k, n - 1), top_col = min(j + k, m - 1);\\n                int down_row_top_col = (i - k - 1 < 0 ? 0 : dp[i-k-1][top_col]);\\n                int top_row_down_col = ( j -k - 1 < 0 ? 0 : dp[top_row][j-k-1]);\\n                int down_row_down_col = ( i- k - 1 < 0 || j - k -1 < 0 ? 0 : dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j] = dp[top_row][top_col] - down_row_top_col - top_row_down_col + down_row_down_col;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> prefix(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                prefix[i][j] = (j > 0 ? prefix[i][j-1] + mat[i][j] : mat[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<int>>dp(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + prefix[i][j];\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int top_row = min(i + k, n - 1), top_col = min(j + k, m - 1);\\n                int down_row_top_col = (i - k - 1 < 0 ? 0 : dp[i-k-1][top_col]);\\n                int top_row_down_col = ( j -k - 1 < 0 ? 0 : dp[top_row][j-k-1]);\\n                int down_row_down_col = ( i- k - 1 < 0 || j - k -1 < 0 ? 0 : dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j] = dp[top_row][top_col] - down_row_top_col - top_row_down_col + down_row_down_col;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746375,
                "title": "c-frefixsum-in-matrix-3ms-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k) {\\n\\t\\t\\tint m = mat.size(), n = mat[0].size();\\n\\n\\t\\t\\tvector<vector<int>> ans(m, vector<int>(n));\\n\\t\\t\\tvector<vector<int>> prefix_sum(105, vector<int>(105));\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint x = i + 1, y = j + 1;\\n\\t\\t\\t\\t\\tprefix_sum[x][y] = mat[i][j] + prefix_sum[x][y - 1] + prefix_sum[x - 1][y] - prefix_sum[x - 1][y - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint r1, r2, c1, c2;\\n\\t\\t\\t\\t\\tr1 = ((i - k >= 0) ? i - k : 0);\\n\\t\\t\\t\\t\\tc1 = ((j - k >= 0) ? j - k : 0);\\n\\t\\t\\t\\t\\tr2 = ((i + k <= m - 1) ? i + k : m - 1);\\n\\t\\t\\t\\t\\tc2 = ((j + k <= n - 1) ? j + k : n - 1);\\n\\n\\t\\t\\t\\t\\tans[i][j] = prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k) {\\n\\t\\t\\tint m = mat.size(), n = mat[0].size();\\n\\n\\t\\t\\tvector<vector<int>> ans(m, vector<int>(n));\\n\\t\\t\\tvector<vector<int>> prefix_sum(105, vector<int>(105));\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint x = i + 1, y = j + 1;\\n\\t\\t\\t\\t\\tprefix_sum[x][y] = mat[i][j] + prefix_sum[x][y - 1] + prefix_sum[x - 1][y] - prefix_sum[x - 1][y - 1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1716889,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        #calculate the value sum with mat[0][0] as top left corner, and mat[i][j] as the bottom right corner and store in dp matrix\\n        #res[i][j] is the sum of the square with mat[i-k][j-k] as the top right corner and mat[i+k][j+k] as the bottom right corner\\n        #square sum of row1co1 as top left and row2col2 as the bottom right = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        #O(m*n) time and space\\n        \\n        m, n = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] + mat[i][j] - dp[i][j]\\n                \\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, row2 = max(0, i - k), min(i + k, m-1)\\n                col1, col2 = max(0, j - k), min(j + k, n-1)\\n                res[i][j] = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        \\n        return res\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        #calculate the value sum with mat[0][0] as top left corner, and mat[i][j] as the bottom right corner and store in dp matrix\\n        #res[i][j] is the sum of the square with mat[i-k][j-k] as the top right corner and mat[i+k][j+k] as the bottom right corner\\n        #square sum of row1co1 as top left and row2col2 as the bottom right = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        #O(m*n) time and space\\n        \\n        m, n = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] + mat[i][j] - dp[i][j]\\n                \\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, row2 = max(0, i - k), min(i + k, m-1)\\n                col1, col2 = max(0, j - k), min(j + k, n-1)\\n                res[i][j] = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        \\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357430,
                "title": "python-o-mn-easy-using-slicing",
                "content": "```class Solution(object):\\n    def matrixBlockSum(self, mat, k):\\n         \\n        col = len(mat[0])\\n        row=len(mat)\\n        new_mat = [[0]*col for i in range(0,row)]\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                new_mat[i][j] = sum([sum(ele[max(j-k,0):min(j+k+1,col)]) for ele in mat[max(i-k,0):min(i+k+1,row)]])\\n                \\n        return new_mat",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution(object):\\n    def matrixBlockSum(self, mat, k):\\n         \\n        col = len(mat[0])\\n        row=len(mat)\\n        new_mat = [[0]*col for i in range(0,row)]\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                new_mat[i][j] = sum([sum(ele[max(j-k,0):min(j+k+1,col)]) for ele in mat[max(i-k,0):min(i+k+1,row)]])\\n                \\n        return new_mat",
                "codeTag": "Java"
            },
            {
                "id": 1235611,
                "title": "c-easy-cumulative-sum-dp",
                "content": "12ms\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        \\n        \\n     \\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                int r1=max(0,i-k)+1; //starting row coordinate of the block\\n                int c1=max(0,j-k)+1; //starting column coordinate of the block\\n                int r2= min(i+k+1,m); //ending row coordinate of the block\\n                int c2= min(j+k+1,n); // ending column coordinate of the block\\n                \\n                ans[i][j]=dp[r2][c2]+dp[r1-1][c1-1]-dp[r1-1][c2]-dp[r2][c1-1]; //value of the block calculated with the dp vector built\\n                \\n            }\\n        }\\n      return ans;  \\n        \\n        \\n    }\\n};\\n\\n/*\\n    Given Matrix:\\n\\n    1, 2, 3\\n    4, 5, 6\\n    7, 8, 9\\n\\n    Prefix Sum matrix:\\n\\n    1, 2, 3                     1, 3, 6                               1, 3, 6\\n    4, 5, 6       Row Sum ->    4 ,9, 15          Column Sum->        5, 12, 21     -> final dp matrix\\n    7, 8, 9                     7, 15, 24                             12, 27, 45 \\n    \\n    To get sum of a sub array from index a to index b, sum(a, b), we can instead calculate prefix(b) - prefix(a-1)\\n    \\n    Similarly, Sum of an arbitrary block from (i-K, j-K) to (i+K, j+K)\\nans(i, j) = prefix(i+K, j+K) - prefix(i+K, j-K-1) - prefix (i-K-1, j+K) + prefix(i-K-1, j-K-1);\\n\\n*/",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1167795,
                "title": "c-4ms-beats-98-74",
                "content": "\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        /*\\n        1 2 3 \\n        4 5 6\\n        7 8 9\\n            \\n        result matrix\\n        12 21 16\\n        27 45 33\\n        24 39 28\\n        \\n        prefix matrix\\n        1  3  6\\n        5  12 21\\n        12 27 45\\n        \\n        \\n        */\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        \\n        vector<vector<int>> sum = mat, res = mat;\\n        \\n        for (int i = 1; i < c; ++i)\\n        {\\n            sum[0][i] += sum[0][i - 1];\\n        }\\n        for (int i = 1; i < r; ++i)\\n        {\\n            sum[i][0] += sum[i - 1][0];\\n        }\\n        \\n        for (int i = 1; i < r; ++i)\\n        {\\n            for (int j = 1; j < c; ++j)\\n            {\\n                sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int north = i - k <= 0 ? 0 : i - k;\\n                int south = i + k >= r ? r - 1 : i + k;\\n                \\n                int west = j - k <= 0 ? 0 : j - k;\\n                int east = j + k >= c ? c - 1 : j + k;\\n                \\n                res[i][j] = sum[south][east];\\n                \\n                if (north != 0)\\n                {\\n                    res[i][j] -= sum[north - 1][east];\\n                }\\n                if (west != 0)\\n                {\\n                    res[i][j] -= sum[south][west - 1];\\n                }\\n                if (north != 0 and west != 0)\\n                {\\n                    res[i][j] += sum[north - 1][west - 1];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        /*\\n        1 2 3 \\n        4 5 6\\n        7 8 9\\n            \\n        result matrix\\n        12 21 16\\n        27 45 33\\n        24 39 28\\n        \\n        prefix matrix\\n        1  3  6\\n        5  12 21\\n        12 27 45\\n        \\n        \\n        */\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        \\n        vector<vector<int>> sum = mat, res = mat;\\n        \\n        for (int i = 1; i < c; ++i)\\n        {\\n            sum[0][i] += sum[0][i - 1];\\n        }\\n        for (int i = 1; i < r; ++i)\\n        {\\n            sum[i][0] += sum[i - 1][0];\\n        }\\n        \\n        for (int i = 1; i < r; ++i)\\n        {\\n            for (int j = 1; j < c; ++j)\\n            {\\n                sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int north = i - k <= 0 ? 0 : i - k;\\n                int south = i + k >= r ? r - 1 : i + k;\\n                \\n                int west = j - k <= 0 ? 0 : j - k;\\n                int east = j + k >= c ? c - 1 : j + k;\\n                \\n                res[i][j] = sum[south][east];\\n                \\n                if (north != 0)\\n                {\\n                    res[i][j] -= sum[north - 1][east];\\n                }\\n                if (west != 0)\\n                {\\n                    res[i][j] -= sum[south][west - 1];\\n                }\\n                if (north != 0 and west != 0)\\n                {\\n                    res[i][j] += sum[north - 1][west - 1];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 809144,
                "title": "c-dynamic-programming-sol-o-n2-similar-to-304-range-sum-query-2d-immutable",
                "content": "Similar to #304 Range Sum Query 2D-Immutable first solve that then do this.\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=1;i<n;i++){\\n            mat[i][0]+=mat[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            mat[0][j]+=mat[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=(mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=max(0,i-k),r2=min(n-1,i+k);\\n                int c1=max(0,j-k),c2=min(m-1,j+k);\\n                if(r1!=0 && c1!=0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1]-mat[r1-1][c2]+mat[r1-1][c1-1];\\n                }else if(r1==0 && c1==0){\\n                    ans[i][j]=mat[r2][c2];\\n                }else if(r1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1];\\n                }else if(c1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r1-1][c2];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=1;i<n;i++){\\n            mat[i][0]+=mat[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            mat[0][j]+=mat[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=(mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=max(0,i-k),r2=min(n-1,i+k);\\n                int c1=max(0,j-k),c2=min(m-1,j+k);\\n                if(r1!=0 && c1!=0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1]-mat[r1-1][c2]+mat[r1-1][c1-1];\\n                }else if(r1==0 && c1==0){\\n                    ans[i][j]=mat[r2][c2];\\n                }else if(r1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1];\\n                }else if(c1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r1-1][c2];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725648,
                "title": "python-3-explanation-diagram-192-ms",
                "content": "* This problem is asking us to build an `answer` matrix by drawing out boxes from each current point with a width and height of `K`.\\n* This problem is visualised for the first example given in the question, with `K=1`:\\n\\n![image](https://assets.leetcode.com/users/images/2ee753c9-efe2-4847-80bb-4fd79cc69aae_1594209444.6316206.png)\\n\\n* The brute-force method requires solving **overlapping sub-problems** multiple times. So here a Dynamic Programming approach should be followed.\\n* We can *store* the results for our overlapping sub-problems by using a cumulative sum.\\n* Each entry `i, j` in `cumulativeSum` stores the sum from drawing a box from `row=0, col=0` to `row=i, col=j`.\\n* This problem can therefore be broken down into two sub-problems:\\n1. How do we build a cumulative sum matrix?\\n2. How do we use this cumulative sum matrix?\\n\\n* In the first example given, we need to build a `cumulativeSum` matrix that looks like:\\n\\n```\\nK=1\\nmat = [\\n\\t[1, 2, 3],\\n\\t[4, 5, 6],\\n\\t[7, 8, 9]\\n]\\ncumulativeSum = [\\n\\t[1 , 3 , 6 ],\\n\\t[5 , 12, 21],\\n\\t[12, 27, 45]\\n]\\nanswer = [\\n\\t[12, 21, 16],\\n\\t[27, 45, 33],\\n\\t[24, 39, 28]\\n]\\n```\\n* To build a `cumulativeSum` matrix we can re-use the previous results in the matrix, working from the top left corner.\\n```\\ndef getCumulativeSum(mat: List[List[int]], m: int, n: int) -> List[List[int]]:\\n\\tcumulativeSum = [[None for _ in range(n)] for _ in range(m)]\\n    cumulativeSum[0][0] = mat[0][0] # Base case.\\n        \\n    # For the 0th row and 0th column, you just add what\\'s left or above the current point in the cumulativeSum matrix.\\n    for c in range(1, n):\\n\\t\\tcumulativeSum[0][c] = cumulativeSum[0][c - 1] + mat[0][c]\\n\\tfor r in range(1, m):\\n\\t\\tcumulativeSum[r][0] = cumulativeSum[r - 1][0] + mat[r][0]\\n        \\n\\t# For other rows and columns, add what\\'s above, what\\'s to the left, and subtract what\\'s above & to the left respectively.\\n    for r in range(1, m):\\n\\t\\tfor c in range(1, n):\\n\\t\\t\\tcumulativeSum[r][c] = mat[r][c] + cumulativeSum[r-1][c] + cumulativeSum[r][c-1] - cumulativeSum[r-1][c-1]\\n                \\n\\treturn cumulativeSum\\n```\\n* We can then use the entries in `cumulativeSum` by taking the bottom-right-most element of the box drawn by adding or taking away `K` from the current index.\\n* This is illustrated easily by considering some examples in the visualisation at the top:\\n1. For `row=0, col=0` of `answer` (circled in red), the box drawn for `K=1` is the red box in `mat`. The sum of this red box is just `cumulativeSum[1][1]`.\\n2. For `row=0, col=2` of `answer` (circled in yellow), the box drawn for `K=1` is the yellow box in `mat`. The sum of this yellow box is `cumulativeSum[1][2] - cumulativeSum[1][0]` because we want to ignore the sum of `mat[0][0] + mat[1][0]`.\\n3. For `row=2, col=2` of `answer` (circled in purple), the box drawn for `K=1` is the purple box in `mat`. The sum of this purple box is `cumulativeSum[2][2] - cumulativeSum[0][2] - cumulativeSum[2][0] + cumulativeSum[0][0]`.\\n```\\ndef matrixBlockSum(mat: List[List[int]], K: int) -> List[List[int]]:\\n\\tm, n = len(mat), len(mat[0])\\n        \\n    cumulativeSum = getCumulativeSum(mat, m, n)\\n        \\n    answer = [[None for _ in range(n)] for _ in range(m)]\\n        \\n    for r in range(m):\\n\\t\\tfor c in range(n):\\n\\t\\t\\t# Tuples of (row, col) that are JUST outside of the box drawn by:\\n            # (i - K <= r <= i + k) & (j - k <= c <= j + k)\\n\\t\\t\\t# Be careful to not go out of the range of mat by using min().\\n            bottomLeft = (min(r + K, m - 1), c - K - 1)\\n            topLeft = (r - K - 1, c - K - 1)\\n            topRight = (r - K - 1, min(c + K, n - 1))\\n                                \\n            # Adjust these points if they go outside of the matrix, if they do, set to None.\\n            bottomLeft = None if any(x < 0 for x in bottomLeft) else bottomLeft\\n            topLeft = None if any(x < 0 for x in topLeft) else topLeft\\n            topRight = None if any(x < 0 for x in topRight) else topRight\\n                \\n            # Find the bottom-right-most point drawn by the box (mentioned above).\\n            # It must be capped to the bottom-right-most point of the matrix in case it overshoots.\\n            toAddRow, toAddCol = (min(r + K, m - 1), min(c + K, n - 1))\\n            toAdd = cumulativeSum[toAddRow][toAddCol]\\n                \\n            answerValue = toAdd\\n            if bottomLeft is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[bottomLeft[0]][bottomLeft[1]]\\n\\t\\t\\tif topRight is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[topRight[0]][topRight[1]]\\n\\t\\t\\tif all(point is not None for point in [bottomLeft, topRight, topLeft]):\\n\\t\\t\\t\\tanswerValue += cumulativeSum[topLeft[0]][topLeft[1]]\\n                \\n\\t\\t\\tanswer[r][c] = answerValue\\n        \\n\\treturn answer\\n```",
                "solutionTags": [],
                "code": "```\\nK=1\\nmat = [\\n\\t[1, 2, 3],\\n\\t[4, 5, 6],\\n\\t[7, 8, 9]\\n]\\ncumulativeSum = [\\n\\t[1 , 3 , 6 ],\\n\\t[5 , 12, 21],\\n\\t[12, 27, 45]\\n]\\nanswer = [\\n\\t[12, 21, 16],\\n\\t[27, 45, 33],\\n\\t[24, 39, 28]\\n]\\n```\n```\\ndef getCumulativeSum(mat: List[List[int]], m: int, n: int) -> List[List[int]]:\\n\\tcumulativeSum = [[None for _ in range(n)] for _ in range(m)]\\n    cumulativeSum[0][0] = mat[0][0] # Base case.\\n        \\n    # For the 0th row and 0th column, you just add what\\'s left or above the current point in the cumulativeSum matrix.\\n    for c in range(1, n):\\n\\t\\tcumulativeSum[0][c] = cumulativeSum[0][c - 1] + mat[0][c]\\n\\tfor r in range(1, m):\\n\\t\\tcumulativeSum[r][0] = cumulativeSum[r - 1][0] + mat[r][0]\\n        \\n\\t# For other rows and columns, add what\\'s above, what\\'s to the left, and subtract what\\'s above & to the left respectively.\\n    for r in range(1, m):\\n\\t\\tfor c in range(1, n):\\n\\t\\t\\tcumulativeSum[r][c] = mat[r][c] + cumulativeSum[r-1][c] + cumulativeSum[r][c-1] - cumulativeSum[r-1][c-1]\\n                \\n\\treturn cumulativeSum\\n```\n```\\ndef matrixBlockSum(mat: List[List[int]], K: int) -> List[List[int]]:\\n\\tm, n = len(mat), len(mat[0])\\n        \\n    cumulativeSum = getCumulativeSum(mat, m, n)\\n        \\n    answer = [[None for _ in range(n)] for _ in range(m)]\\n        \\n    for r in range(m):\\n\\t\\tfor c in range(n):\\n\\t\\t\\t# Tuples of (row, col) that are JUST outside of the box drawn by:\\n            # (i - K <= r <= i + k) & (j - k <= c <= j + k)\\n\\t\\t\\t# Be careful to not go out of the range of mat by using min().\\n            bottomLeft = (min(r + K, m - 1), c - K - 1)\\n            topLeft = (r - K - 1, c - K - 1)\\n            topRight = (r - K - 1, min(c + K, n - 1))\\n                                \\n            # Adjust these points if they go outside of the matrix, if they do, set to None.\\n            bottomLeft = None if any(x < 0 for x in bottomLeft) else bottomLeft\\n            topLeft = None if any(x < 0 for x in topLeft) else topLeft\\n            topRight = None if any(x < 0 for x in topRight) else topRight\\n                \\n            # Find the bottom-right-most point drawn by the box (mentioned above).\\n            # It must be capped to the bottom-right-most point of the matrix in case it overshoots.\\n            toAddRow, toAddCol = (min(r + K, m - 1), min(c + K, n - 1))\\n            toAdd = cumulativeSum[toAddRow][toAddCol]\\n                \\n            answerValue = toAdd\\n            if bottomLeft is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[bottomLeft[0]][bottomLeft[1]]\\n\\t\\t\\tif topRight is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[topRight[0]][topRight[1]]\\n\\t\\t\\tif all(point is not None for point in [bottomLeft, topRight, topLeft]):\\n\\t\\t\\t\\tanswerValue += cumulativeSum[topLeft[0]][topLeft[1]]\\n                \\n\\t\\t\\tanswer[r][c] = answerValue\\n        \\n\\treturn answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 631096,
                "title": "python-easy-to-understand-solution",
                "content": "A standard template you can follow when solving 2D prefix/range problems. \\n```py\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        h, w = len(mat), len(mat[0])\\n        \\n        data = [[0 for i in range(w)] for j in range(h)]\\n        \\n        # precompute the matrix sums\\n        for i in range(h):\\n            for j in range(w):\\n                res = 0\\n                if(i > 0): res += data[i-1][j]\\n                if(j > 0): res += data[i][j-1]\\n                if(i > 0 and j > 0): res -= data[i-1][j-1]\\n                \\n                res += mat[i][j]\\n                data[i][j] = res\\n        \\n        for i in range(h):\\n            for j in range(w):\\n                x1, y1, x2, y2 = max(i-K,0), max(j-K,0), min(i+K,h-1), min(j+K,w-1)\\n                \\n                # find the sum of elements in between x1, y1 and x2,y2 (inclusive)\\n                res = data[x2][y2]\\n                if(x1 > 0): res -= data[x1-1][y2]\\n                if(y1 > 0): res -= data[x2][y1-1]\\n                if(x1 > 0 and y1 > 0): res += data[x1-1][y1-1]\\n                \\n                mat[i][j] = res\\n        \\n        return mat\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        h, w = len(mat), len(mat[0])\\n        \\n        data = [[0 for i in range(w)] for j in range(h)]\\n        \\n        # precompute the matrix sums\\n        for i in range(h):\\n            for j in range(w):\\n                res = 0\\n                if(i > 0): res += data[i-1][j]\\n                if(j > 0): res += data[i][j-1]\\n                if(i > 0 and j > 0): res -= data[i-1][j-1]\\n                \\n                res += mat[i][j]\\n                data[i][j] = res\\n        \\n        for i in range(h):\\n            for j in range(w):\\n                x1, y1, x2, y2 = max(i-K,0), max(j-K,0), min(i+K,h-1), min(j+K,w-1)\\n                \\n                # find the sum of elements in between x1, y1 and x2,y2 (inclusive)\\n                res = data[x2][y2]\\n                if(x1 > 0): res -= data[x1-1][y2]\\n                if(y1 > 0): res -= data[x2][y1-1]\\n                if(x1 > 0 and y1 > 0): res += data[x1-1][y1-1]\\n                \\n                mat[i][j] = res\\n        \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478050,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int[][] temp = new int[n + 1][m + 1];\\n        for (int i = 0; i < n; i++) {\\n            temp[i + 1][1] = temp[i][1] + mat[i][0];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            temp[1][i + 1] = temp[1][i] + mat[0][i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                temp[i + 1][j + 1] = temp[i][j + 1] + temp[i + 1][j] - temp[i][j] + mat[i][j];\\n            }\\n        }\\n        int[][] res = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = i - K >= 0 ? i - K : 0;\\n                int y1 = j - K >= 0 ? j - K : 0;\\n                int x2 = i + K + 1<= n ? i + K + 1 : n;\\n                int y2 = j + K + 1<= m ? j + K + 1 : m;\\n                res[i][j] = temp[x2][y2] - temp[x2][y1] - temp[x1][y2] + temp[x1][y1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int[][] temp = new int[n + 1][m + 1];\\n        for (int i = 0; i < n; i++) {\\n            temp[i + 1][1] = temp[i][1] + mat[i][0];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            temp[1][i + 1] = temp[1][i] + mat[0][i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                temp[i + 1][j + 1] = temp[i][j + 1] + temp[i + 1][j] - temp[i][j] + mat[i][j];\\n            }\\n        }\\n        int[][] res = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = i - K >= 0 ? i - K : 0;\\n                int y1 = j - K >= 0 ? j - K : 0;\\n                int x2 = i + K + 1<= n ? i + K + 1 : n;\\n                int y2 = j + K + 1<= m ? j + K + 1 : m;\\n                res[i][j] = temp[x2][y2] - temp[x2][y1] - temp[x1][y2] + temp[x1][y1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477029,
                "title": "dp-java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int [][]dp = new int[m+1][n+1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        int [][]ans = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l = Math.max(0, j - K);\\n                int r = Math.min(n-1, j + K)+1;\\n                int u = Math.max(0, i - K);\\n                int d = Math.min(m-1, i + K)+1;\\n                ans[i][j] = dp[d][r] - dp[d][l] - dp[u][r] + dp[u][l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int [][]dp = new int[m+1][n+1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        int [][]ans = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l = Math.max(0, j - K);\\n                int r = Math.min(n-1, j + K)+1;\\n                int u = Math.max(0, i - K);\\n                int d = Math.min(m-1, i + K)+1;\\n                ans[i][j] = dp[d][r] - dp[d][l] - dp[u][r] + dp[u][l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241051,
                "title": "c-solution-with-comments-and-diagram",
                "content": "first we\\'ll create prefix sum matrix (in this case named \"pre\" ).\\n.\\n.\\n.\\n.\\nnow to find sum of shaded region\\n![image](https://assets.leetcode.com/users/images/110e8f9f-e45d-486b-800c-53c4ab80b208_1677607180.5857232.jpeg)\\n.\\n.\\n.\\n.\\nwe\\'ll subtract section A and section B to sum till now and add section C as it is subtracted twice\\n![image](https://assets.leetcode.com/users/images/293c82e7-0d54-44b4-a22c-dc4ba7a7ee94_1677607258.4063761.jpeg)\\nie, in this case, sum of shaded region = 45- 12- 6+ 1\\n.\\n.\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        // prefix sum\\n        int m= mat.size(), n= mat[0].size(), temp;\\n        vector<vector<int>> pre(m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                pre[i+1][j+1]= mat[i][j]+pre[i][j+1]+pre[i+1][j]-pre[i][j];\\n            \\n        \\n        // creating ans matrix using prefix sum matrix(pre)\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int iup= max(0,i-k), idown= min(m-1,i+k), jleft= max(0,j-k), jright= min(n-1, j+k);\\n                temp= pre[idown+1][jright+1]  -pre[idown+1][jleft]  -pre[iup][jright+1]  +pre[iup][jleft];\\n                ans[i][j]= temp;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        // prefix sum\\n        int m= mat.size(), n= mat[0].size(), temp;\\n        vector<vector<int>> pre(m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                pre[i+1][j+1]= mat[i][j]+pre[i][j+1]+pre[i+1][j]-pre[i][j];\\n            \\n        \\n        // creating ans matrix using prefix sum matrix(pre)\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int iup= max(0,i-k), idown= min(m-1,i+k), jleft= max(0,j-k), jright= min(n-1, j+k);\\n                temp= pre[idown+1][jright+1]  -pre[idown+1][jleft]  -pre[iup][jright+1]  +pre[iup][jleft];\\n                ans[i][j]= temp;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160155,
                "title": "java-solution-1-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            for(int i = 1; i < m; i++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res[i][j] = getSum(mat, i, j, k);\\n            }\\n        }\\n\\n        return res;\\n    }\\n    private int getSum(int[][] mat, int i, int j, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int endRow = Math.min(m - 1, i + k);\\n        int endCol = Math.min(n - 1, j + k);\\n\\n        int sum = mat[endRow][endCol];\\n        int n1 = (j - k - 1 >= 0) ? mat[endRow][j - k - 1] : 0;\\n        int n2 = (i - k - 1 >= 0) ? mat[i - k - 1][endCol] : 0;\\n        int n3 = (j - k - 1 >= 0 && i - k - 1 >= 0) ? mat[i - k - 1][j - k - 1] : 0;\\n\\n        return sum - n1 - n2 + n3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            for(int i = 1; i < m; i++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res[i][j] = getSum(mat, i, j, k);\\n            }\\n        }\\n\\n        return res;\\n    }\\n    private int getSum(int[][] mat, int i, int j, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int endRow = Math.min(m - 1, i + k);\\n        int endCol = Math.min(n - 1, j + k);\\n\\n        int sum = mat[endRow][endCol];\\n        int n1 = (j - k - 1 >= 0) ? mat[endRow][j - k - 1] : 0;\\n        int n2 = (i - k - 1 >= 0) ? mat[i - k - 1][endCol] : 0;\\n        int n3 = (j - k - 1 >= 0 && i - k - 1 >= 0) ? mat[i - k - 1][j - k - 1] : 0;\\n\\n        return sum - n1 - n2 + n3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144858,
                "title": "simple-traverse",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++) {\\n                int sum = 0;\\n                for (int r = max(0, i - k); r < min(n, i + k + 1); r++)\\n                    for (int c = max(0, j - k); c < min(m, j + k + 1); c++) \\n                        sum += mat[r][c];\\n                res[i][j] = sum;\\n            }\\n        return res;         \\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++) {\\n                int sum = 0;\\n                for (int r = max(0, i - k); r < min(n, i + k + 1); r++)\\n                    for (int c = max(0, j - k); c < min(m, j + k + 1); c++) \\n                        sum += mat[r][c];\\n                res[i][j] = sum;\\n            }\\n        return res;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702062,
                "title": "c-clean-code-with-comments-and-explaination",
                "content": "1. declare a 2d vector t. t[i][j] means total sum for the rectangle from (0,0) to (i, j). \\n2.  loop through matrix, find max values of x2, x1, y2, y1 acc to k. readjust the value if they fall out of matrix range.\\n3.   the k matrix sum would be  rectangle (x1,y1) to (x2, y2) which can be calculated using t matrix . \\n \\n\\n ```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<vector<int>> t( m, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if( i == 0 && j == 0) t[i][j] = mat[i][j];\\n                else if( i == 0 ) t[i][j] = t[i][j-1] + mat[i][j];\\n                else if( j == 0 ) t[i][j] = t[i-1][j] + mat[i][j];\\n                else t[i][j] = mat[i][j] + t[i-1][j] + t[i][j-1] - t[i-1][j-1];\\n            }\\n        }\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                \\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                \\n                int x2 = min(i + k, m-1);\\n                int y2 = min(j + k, n-1);\\n                \\n                res[i][j] = t[x2][y2] - ( x1 > 0 ? t[x1-1][y2] : 0) - ( y1 > 0 ? t[x2][y1-1] : 0 ) + ( (x1 > 0 && y1 > 0) ? t[x1-1][y1-1] : 0 );  \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<vector<int>> t( m, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if( i == 0 && j == 0) t[i][j] = mat[i][j];\\n                else if( i == 0 ) t[i][j] = t[i][j-1] + mat[i][j];\\n                else if( j == 0 ) t[i][j] = t[i-1][j] + mat[i][j];\\n                else t[i][j] = mat[i][j] + t[i-1][j] + t[i][j-1] - t[i-1][j-1];\\n            }\\n        }\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                \\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                \\n                int x2 = min(i + k, m-1);\\n                int y2 = min(j + k, n-1);\\n                \\n                res[i][j] = t[x2][y2] - ( x1 > 0 ? t[x1-1][y2] : 0) - ( y1 > 0 ? t[x2][y1-1] : 0 ) + ( (x1 > 0 && y1 > 0) ? t[x1-1][y1-1] : 0 );  \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645671,
                "title": "java-solution-with-hard-code-loop-array",
                "content": "\\n# Approach\\nLoop Array \\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n     \\n        int[][] res = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++)\\n            for (int j = 0; j < mat[0].length; j++)\\n                res[i][j]=sumMat(k,mat,i,j);\\n\\n        return res;\\n    }\\n\\n    int sumMat(int k, int[][] mat, int i, int j) {\\n        int sum = 0;\\n\\n        for (int a = i - k; a <= i + k; a++)\\n            if (a >= 0 && mat.length > a)\\n                for (int b = j - k; b <= j + k; b++)\\n                    if (b >= 0 && mat[0].length > b)\\n                        sum+=mat[a][b];\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n     \\n        int[][] res = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++)\\n            for (int j = 0; j < mat[0].length; j++)\\n                res[i][j]=sumMat(k,mat,i,j);\\n\\n        return res;\\n    }\\n\\n    int sumMat(int k, int[][] mat, int i, int j) {\\n        int sum = 0;\\n\\n        for (int a = i - k; a <= i + k; a++)\\n            if (a >= 0 && mat.length > a)\\n                for (int b = j - k; b <= j + k; b++)\\n                    if (b >= 0 && mat[0].length > b)\\n                        sum+=mat[a][b];\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557036,
                "title": "time-and-space-90-and-80-beats-constant-space-time-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int i,j,m = mat.size(),n = mat[0].size();\\n        for(i = 0; i < m ;i++){\\n            for(j = 0; j < n; j++){\\n                if(i==0&&j==0)continue;\\n                else if(i==0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1];\\n                }\\n            }\\n        }\\n        int a,b,c,d;\\n        vector<vector<int>> ans(m,vector<int> (n));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                a = max(i-k,0);\\n                b = max(0,j-k);\\n                c = min(i+k,m-1);\\n                d = min(j+k,n-1);\\n                if(a==0&&b==0){\\n                    ans[i][j] = mat[c][d];\\n                }else if(a==0){\\n                    ans[i][j] = mat[c][d]-mat[c][b-1];\\n                }else if(b==0){\\n                    ans[i][j] = mat[c][d]-mat[a-1][d];\\n                }else{\\n                    ans[i][j] = mat[c][d]+mat[a-1][b-1]-mat[a-1][d]-mat[c][b-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int i,j,m = mat.size(),n = mat[0].size();\\n        for(i = 0; i < m ;i++){\\n            for(j = 0; j < n; j++){\\n                if(i==0&&j==0)continue;\\n                else if(i==0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1];\\n                }\\n            }\\n        }\\n        int a,b,c,d;\\n        vector<vector<int>> ans(m,vector<int> (n));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                a = max(i-k,0);\\n                b = max(0,j-k);\\n                c = min(i+k,m-1);\\n                d = min(j+k,n-1);\\n                if(a==0&&b==0){\\n                    ans[i][j] = mat[c][d];\\n                }else if(a==0){\\n                    ans[i][j] = mat[c][d]-mat[c][b-1];\\n                }else if(b==0){\\n                    ans[i][j] = mat[c][d]-mat[a-1][d];\\n                }else{\\n                    ans[i][j] = mat[c][d]+mat[a-1][b-1]-mat[a-1][d]-mat[c][b-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547723,
                "title": "python-solution-do-304-first",
                "content": "Then you can copy and paste!\\n```\\nclass Solution:\\n    # First go back to Leetcode 304. Range Sum Query 2D - Immutable\\n    # Prepare the prefix sum matrix first\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] + mat[i-1][j-1] - prefix_sum[i-1][j-1]\\n        \\n        result = [[0 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, col1 = max(0, i-k), max(0,j-k)\\n                row2, col2 = min(m-1, i+k), min(n-1,j+k)\\n                result[i][j] = prefix_sum[row2+1][col2+1] - prefix_sum[row1][col2+1] - prefix_sum[row2+1][col1] + prefix_sum[row1][col1]\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # First go back to Leetcode 304. Range Sum Query 2D - Immutable\\n    # Prepare the prefix sum matrix first\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] + mat[i-1][j-1] - prefix_sum[i-1][j-1]\\n        \\n        result = [[0 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, col1 = max(0, i-k), max(0,j-k)\\n                row2, col2 = min(m-1, i+k), min(n-1,j+k)\\n                result[i][j] = prefix_sum[row2+1][col2+1] - prefix_sum[row1][col2+1] - prefix_sum[row2+1][col1] + prefix_sum[row1][col1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372339,
                "title": "python-comulative-sum-array",
                "content": "Comulative sum array is like a prefix sum array (1D), but for 2D arrays.\\n\\nThis is the same as [304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/). \\n\\nLet\\'s quickly look at an example:\\nInput:\\n```\\n1  2  3\\n4  5  6\\n7  8  9\\n```\\n\\nYou create comulative sum array and add 0 paddings, to ease edge case calculations:\\n```\\n0  0  0  0\\n0  1  3  6\\n0  5 12 21\\n0 12 27 45\\n```\\n\\nNow imagine that you need to get in O(1) sum of any rectangular part of the original array:\\n\\nYou calc rectange sum for **each** matrix[r][c] element:\\ne.g. you are at [3][5], k = 2, so you calc sum of rectangle at x1y1 [3-2][5-2] to x2y2[3+2][5+2] and store it in res[3][5]\\n\\n![image](https://assets.leetcode.com/users/images/f20b6ebf-b645-4012-ab4d-017582252751_1659501890.2643135.png)\\n*The picture is not mine, It just depicts what I need:*\\n\\nThis\\n```\\n0  0  0  0\\n0\\n0\\n0\\n```\\npadding is used to avoid pesky out-of-boundary-cases.\\n\\nBack to our example:\\nYou\\'d like to calc quickly sum of \\n```\\n5 6\\n8 9\\n```\\n\\nAccording to the picture above you do the following math:\\n`45 - 12 - 6 + 1 = 28`, and according to `5 + 6 + 8 + 9 = 28`.\\n\\n**That\\'s it.**\\n\\n**Like and subscribe (c) ???**\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, matrix: List[List[int]], k: int) -> List[List[int]]:\\n        ROWS, COLS = len(matrix), len(matrix[0])\\n        \\n        prefix_sums = [[0] * (COLS + 1) for _ in range(ROWS + 1)]\\n        \\n        for r in range(1, ROWS + 1):\\n            for c in range(1, COLS + 1):\\n                prefix_sums[r][c] = prefix_sums[r - 1][c] + prefix_sums[r][c - 1] + \\\\\\n                    matrix[r - 1][c - 1] - prefix_sums[r - 1][c - 1]\\n\\n        res = [[0] * COLS for _ in range(ROWS)]\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                res[r][c] = prefix_sums[min(r + k + 1, ROWS)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[max(r - k, 0)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[min(r + k + 1, ROWS)][max(c - k, 0)] + \\\\\\n                    prefix_sums[max(r - k, 0)][max(c - k, 0)]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1  2  3\\n4  5  6\\n7  8  9\\n```\n```\\n0  0  0  0\\n0  1  3  6\\n0  5 12 21\\n0 12 27 45\\n```\n```\\n0  0  0  0\\n0\\n0\\n0\\n```\n```\\n5 6\\n8 9\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, matrix: List[List[int]], k: int) -> List[List[int]]:\\n        ROWS, COLS = len(matrix), len(matrix[0])\\n        \\n        prefix_sums = [[0] * (COLS + 1) for _ in range(ROWS + 1)]\\n        \\n        for r in range(1, ROWS + 1):\\n            for c in range(1, COLS + 1):\\n                prefix_sums[r][c] = prefix_sums[r - 1][c] + prefix_sums[r][c - 1] + \\\\\\n                    matrix[r - 1][c - 1] - prefix_sums[r - 1][c - 1]\\n\\n        res = [[0] * COLS for _ in range(ROWS)]\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                res[r][c] = prefix_sums[min(r + k + 1, ROWS)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[max(r - k, 0)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[min(r + k + 1, ROWS)][max(c - k, 0)] + \\\\\\n                    prefix_sums[max(r - k, 0)][max(c - k, 0)]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936092,
                "title": "c-using-prefix-sum-and-dp-with-time-and-space-o-rxc",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) mat[i][j] += mat[i][j-1];\\n                else if(j==0) mat[i][j] += mat[i-1][j];\\n                else mat[i][j] += (mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int mir = max(i-k,0);\\n                int mic = max(j-k,0);\\n                int mar = min(i+k,n-1);\\n                int mac = min(j+k,m-1);\\n                \\n                if(mir==0 && mic==0) ans[i][j] = mat[mar][mac];\\n                else if(mir==0) ans[i][j] = mat[mar][mac] - mat[mar][mic-1];\\n                else if(mic==0) ans[i][j] = mat[mar][mac] - mat[mir-1][mac];\\n                else ans[i][j] = mat[mar][mac] - mat[mar][mic-1] - mat[mir-1][mac] + mat[mir-1][mic-1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) mat[i][j] += mat[i][j-1];\\n                else if(j==0) mat[i][j] += mat[i-1][j];\\n                else mat[i][j] += (mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int mir = max(i-k,0);\\n                int mic = max(j-k,0);\\n                int mar = min(i+k,n-1);\\n                int mac = min(j+k,m-1);\\n                \\n                if(mir==0 && mic==0) ans[i][j] = mat[mar][mac];\\n                else if(mir==0) ans[i][j] = mat[mar][mac] - mat[mar][mic-1];\\n                else if(mic==0) ans[i][j] = mat[mar][mac] - mat[mir-1][mac];\\n                else ans[i][j] = mat[mar][mac] - mat[mar][mic-1] - mat[mir-1][mac] + mat[mir-1][mic-1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704940,
                "title": "javascript-beats-84-in-memory-brute-force",
                "content": "```\\n/**\\n * @param {number[][]} mat\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar matrixBlockSum = function(mat, k) {\\n    var outputMatrix=[];\\n    for(var i=0; i<mat.length; i++)\\n        {\\n            var tempArr=[];\\n            for(var j=0; j<mat[i].length; j++)\\n                    tempArr.push((calcSum(mat, k, i, j)));\\n                \\n            outputMatrix.push(tempArr);\\n        }\\n    return outputMatrix;\\n};\\n\\nfunction calcSum(mat, k, i, j)\\n{\\n    var r= ((i-k)>0)?i-k:0;\\n    var r1=((i+k)<mat.length)?i+k:mat.length-1;\\n    var c1=((j+k)<mat[0].length)?j+k:mat[0].length-1;\\n    var sum=0;\\n    while(r<=r1)\\n        {\\n            var c= ((j-k)>0)?j-k:0;\\n            while(c<=c1)\\n                    sum+=mat[r][c++];      \\n            r++;\\n        }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar matrixBlockSum = function(mat, k) {\\n    var outputMatrix=[];\\n    for(var i=0; i<mat.length; i++)\\n        {\\n            var tempArr=[];\\n            for(var j=0; j<mat[i].length; j++)\\n                    tempArr.push((calcSum(mat, k, i, j)));\\n                \\n            outputMatrix.push(tempArr);\\n        }\\n    return outputMatrix;\\n};\\n\\nfunction calcSum(mat, k, i, j)\\n{\\n    var r= ((i-k)>0)?i-k:0;\\n    var r1=((i+k)<mat.length)?i+k:mat.length-1;\\n    var c1=((j+k)<mat[0].length)?j+k:mat[0].length-1;\\n    var sum=0;\\n    while(r<=r1)\\n        {\\n            var c= ((j-k)>0)?j-k:0;\\n            while(c<=c1)\\n                    sum+=mat[r][c++];      \\n            r++;\\n        }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1622887,
                "title": "c-dp-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int j = 0; j < n; ++j) {\\n            for(int i = 1; i < m; ++i) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int l = j - k, r = j + k, t = i - k, b = i + k;\\n                int prefixTop = t <= 0 ? 0 : mat[t - 1][min(r, n - 1)];\\n                int prefixLeft = l <= 0 ? 0 : mat[min(b, m - 1)][l - 1];\\n                int prefixTopLeft = t > 0 && l > 0 ? mat[t - 1][l - 1] : 0;\\n                \\n                ans[i][j] = mat[min(b, m - 1)][min(r, n - 1)] - prefixTop - prefixLeft + prefixTopLeft; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int j = 0; j < n; ++j) {\\n            for(int i = 1; i < m; ++i) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int l = j - k, r = j + k, t = i - k, b = i + k;\\n                int prefixTop = t <= 0 ? 0 : mat[t - 1][min(r, n - 1)];\\n                int prefixLeft = l <= 0 ? 0 : mat[min(b, m - 1)][l - 1];\\n                int prefixTopLeft = t > 0 && l > 0 ? mat[t - 1][l - 1] : 0;\\n                \\n                ans[i][j] = mat[min(b, m - 1)][min(r, n - 1)] - prefixTop - prefixLeft + prefixTopLeft; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498515,
                "title": "python-dp-based-2-approaches-93-5",
                "content": "Both are DP approaches.\\n\\n**Approach 1**: Calculate sum for each index mat[index, index-k:index+k+1]. Peform this using the  value of previous  sum  already calculated and also taking care of the boundary conditions.\\n\\nTimewise: 58.6%\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, i-k)\\n                MAX = min(i+k, M-1)\\n                if i == 0:\\n                    for k in range(MIN, MAX+1):\\n                        dp[i][j] += mat[k][j]\\n                else:\\n                    SUB = 0 if MIN == 0 else mat[MIN-1][j]\\n                    ADD = 0 if i+k >= M else mat[MAX][j]\\n                    dp[i][j] += dp[i-1][j] - SUB + ADD\\n        \\n\\t\\t\\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, j-k)\\n                MAX = min(j+k, N-1)\\n                if j == 0:\\n                    for k in range(MIN, MAX+1):\\n                        res[i][j] += dp[i][k]\\n                else:\\n                    SUB = 0 if MIN == 0 else dp[i][MIN-1]\\n                    ADD = 0 if j+k >= N else dp[i][MAX]\\n                    res[i][j] += res[i][j-1] - SUB + ADD\\n        \\n        return res\\n```\\n\\n\\n**Approach 2**: Using prefix sum. Calculate the prefix sum for all indexes and then calculate the result by subtracting the portion that is not in range of (i-k,i+k),(j-k,j+k).\\n\\nTimwise this  is superior: 93.5%\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        # For prefix  sum\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        dp[0][0] = mat[0][0]\\n        # row\\n        for i in range(1, M):\\n            dp[i][0] = dp[i-1][0] + mat[i][0]\\n            \\n        # column\\n        for j in range(1, N):\\n            dp[0][j] = dp[0][j-1] + mat[0][j]\\n        \\n        # remaining\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                dp[i][j] = mat[i][j] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\\n        \\n        \\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN_i, MIN_j = max(0, i-k), max(0, j-k)\\n                MAX_i, MAX_j = min(i+k, M-1), min(j+k, N-1)\\n                if MIN_i > 0 and MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]-dp[MAX_i][MIN_j-1]+dp[MIN_i-1][MIN_j-1]\\n                elif MIN_i > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]\\n                elif MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MAX_i][MIN_j-1]\\n                else:\\n                    res[i][j] = dp[MAX_i][MAX_j]\\n        \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, i-k)\\n                MAX = min(i+k, M-1)\\n                if i == 0:\\n                    for k in range(MIN, MAX+1):\\n                        dp[i][j] += mat[k][j]\\n                else:\\n                    SUB = 0 if MIN == 0 else mat[MIN-1][j]\\n                    ADD = 0 if i+k >= M else mat[MAX][j]\\n                    dp[i][j] += dp[i-1][j] - SUB + ADD\\n        \\n\\t\\t\\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, j-k)\\n                MAX = min(j+k, N-1)\\n                if j == 0:\\n                    for k in range(MIN, MAX+1):\\n                        res[i][j] += dp[i][k]\\n                else:\\n                    SUB = 0 if MIN == 0 else dp[i][MIN-1]\\n                    ADD = 0 if j+k >= N else dp[i][MAX]\\n                    res[i][j] += res[i][j-1] - SUB + ADD\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        # For prefix  sum\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        dp[0][0] = mat[0][0]\\n        # row\\n        for i in range(1, M):\\n            dp[i][0] = dp[i-1][0] + mat[i][0]\\n            \\n        # column\\n        for j in range(1, N):\\n            dp[0][j] = dp[0][j-1] + mat[0][j]\\n        \\n        # remaining\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                dp[i][j] = mat[i][j] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\\n        \\n        \\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN_i, MIN_j = max(0, i-k), max(0, j-k)\\n                MAX_i, MAX_j = min(i+k, M-1), min(j+k, N-1)\\n                if MIN_i > 0 and MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]-dp[MAX_i][MIN_j-1]+dp[MIN_i-1][MIN_j-1]\\n                elif MIN_i > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]\\n                elif MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MAX_i][MIN_j-1]\\n                else:\\n                    res[i][j] = dp[MAX_i][MAX_j]\\n        \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481232,
                "title": "faster-than-100-c-submissions-easy-to-understand-prefix-sum",
                "content": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        /*\\n        mat[3][3] = {\\n            {1,2,3},\\n            {4,5,6},\\n            {7,8,9}\\n        };\\n        */\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on rows\\n        mat[3][3] = {\\n            {1,3,6},\\n            {4,9,15},\\n            {7,15,24}\\n        };\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on cols\\n        mat[3][3] = {\\n            {1,3,6},\\n            {5,12,21},\\n            {12,27,45}\\n        };\\n        */\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            vector<int> ans_i(n);\\n            int first_row = i-k,last_row = i+k;\\n            for(int j=0;j<n;j++){ \\n                int first_col = j-k, last_col = j+k;\\n                last_row = (last_row>m-1)?m-1:last_row;\\n                last_col = (last_col>n-1)?n-1:last_col;\\n                ans_i[j] = mat[last_row][last_col];\\n                if(first_row-1 >= 0 && first_col-1 >=0){ ans_i[j] += mat[first_row-1][first_col-1]; }\\n                if(first_row-1 >=0){ ans_i[j] -= mat[first_row-1][last_col]; }\\n                if(first_col-1 >=0){ ans_i[j] -= mat[last_row][first_col-1]; }\\n            }\\n            ans.push_back(ans_i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        /*\\n        mat[3][3] = {\\n            {1,2,3},\\n            {4,5,6},\\n            {7,8,9}\\n        };\\n        */\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on rows\\n        mat[3][3] = {\\n            {1,3,6},\\n            {4,9,15},\\n            {7,15,24}\\n        };\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on cols\\n        mat[3][3] = {\\n            {1,3,6},\\n            {5,12,21},\\n            {12,27,45}\\n        };\\n        */\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            vector<int> ans_i(n);\\n            int first_row = i-k,last_row = i+k;\\n            for(int j=0;j<n;j++){ \\n                int first_col = j-k, last_col = j+k;\\n                last_row = (last_row>m-1)?m-1:last_row;\\n                last_col = (last_col>n-1)?n-1:last_col;\\n                ans_i[j] = mat[last_row][last_col];\\n                if(first_row-1 >= 0 && first_col-1 >=0){ ans_i[j] += mat[first_row-1][first_col-1]; }\\n                if(first_row-1 >=0){ ans_i[j] -= mat[first_row-1][last_col]; }\\n                if(first_col-1 >=0){ ans_i[j] -= mat[last_row][first_col-1]; }\\n            }\\n            ans.push_back(ans_i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478007,
                "title": "c-solution-time-o-nm",
                "content": "Time complexity: O(nm)\\nspace complexity: O(nm)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)dp[i][j]+=dp[i][j-1];\\n                if(i>0&&j>0)dp[i][j]-=dp[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // cout<<dp[i][j]<<\" \";\\n                int lfx=max(0,j-k);\\n                int rtx=min(m-1,j+k);\\n                int lfy=max(0,i-k);\\n                int rty=min(n-1,i+k);\\n                mat[i][j]=dp[rty][rtx];\\n                if(lfy>0)mat[i][j]-=dp[lfy-1][rtx];\\n                if(lfx>0)mat[i][j]-=dp[rty][lfx-1];\\n                if(lfy>0&&lfx>0)mat[i][j]+=dp[lfy-1][lfx-1];\\n                \\n            }\\n            // cout<<endl;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)dp[i][j]+=dp[i][j-1];\\n                if(i>0&&j>0)dp[i][j]-=dp[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // cout<<dp[i][j]<<\" \";\\n                int lfx=max(0,j-k);\\n                int rtx=min(m-1,j+k);\\n                int lfy=max(0,i-k);\\n                int rty=min(n-1,i+k);\\n                mat[i][j]=dp[rty][rtx];\\n                if(lfy>0)mat[i][j]-=dp[lfy-1][rtx];\\n                if(lfx>0)mat[i][j]-=dp[rty][lfx-1];\\n                if(lfy>0&&lfx>0)mat[i][j]+=dp[lfy-1][lfx-1];\\n                \\n            }\\n            // cout<<endl;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1437029,
                "title": "prefix-sum-java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }\\n        }\\n        int[][] ans=new int[mat.length][mat[0].length];\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                int rowStart=i-k<0?0:i-k;\\n                int rowEnd=i+k>=mat.length?mat.length-1:i+k;\\n                int colStart=j-k<0?0:j-k;\\n                int colEnd=j+k>=mat[0].length?mat[0].length-1:j+k;\\n                int sum=0;\\n                for(int v=rowStart;v<=rowEnd;v++){\\n                    sum+=mat[v][colEnd];\\n                    if(colStart!=0) sum-=mat[v][colStart-1];\\n                }\\n                ans[i][j]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1378690,
                "title": "python-faster-than-99-84ms-time-o-n-m",
                "content": "```Python\\ndef solveRow(row, k):\\n    \\'\\'\\'\\n    O(n)\\n    Where n is the number of elements in the row\\n    \\'\\'\\'\\n    n = len(row)\\n    k = min(k, n)\\n    newRow = []\\n    right = k\\n    left = 0\\n    total = sum(row[0: right + 1])\\n    newRow.append(total)\\n    \\n    for index in range(1, n):\\n        if index > k:\\n            total -= row[left]\\n            left += 1\\n        \\n        if index < n - k:\\n            right += 1\\n            total += row[right]\\n        newRow.append(total)\\n        \\n    return newRow\\n    \\n\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = [solveRow(row,k) for row in mat]   # O(n*m)\\n        ans = [solveRow(x, k) for x in zip(*ans)] # O(n*m)  Transpose\\n        return [list(x) for x in zip(*ans)] # Transpose again\\n\\n```\\n![image](https://assets.leetcode.com/users/images/aa8b440c-9cb1-49f6-9887-f0155c688ed8_1627911629.6227188.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\ndef solveRow(row, k):\\n    \\'\\'\\'\\n    O(n)\\n    Where n is the number of elements in the row\\n    \\'\\'\\'\\n    n = len(row)\\n    k = min(k, n)\\n    newRow = []\\n    right = k\\n    left = 0\\n    total = sum(row[0: right + 1])\\n    newRow.append(total)\\n    \\n    for index in range(1, n):\\n        if index > k:\\n            total -= row[left]\\n            left += 1\\n        \\n        if index < n - k:\\n            right += 1\\n            total += row[right]\\n        newRow.append(total)\\n        \\n    return newRow\\n    \\n\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = [solveRow(row,k) for row in mat]   # O(n*m)\\n        ans = [solveRow(x, k) for x in zip(*ans)] # O(n*m)  Transpose\\n        return [list(x) for x in zip(*ans)] # Transpose again\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257786,
                "title": "java-prefix-sum-with-explanation",
                "content": "**Idea:** When the query is for cell `(i, j)`, you actually look for cell `(i + k, j + k)` i.e. the bottom right corner of the required block. The rest of the question is same as [Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable). \\n\\nCalculate prefix-sum matrix of the matrix. Then subtract out-of-boundary top and right rectangles (prefix sum cells corresponding to them), then add back intersection of these 2 rectangles as you\\'ve subtracted the intersection twice. \\n\\nExplanation of this logic is in [Approach#4 of Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable) and also in this [CV article](https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/).\\n\\n**T/S:** O(mn), where m x n are the dimensions of the matrix.\\n\\n```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tvar prefixSum = getPrefixSum(mat);\\n\\tvar m = mat.length;\\n\\tvar n = mat[0].length;\\n\\tvar blockSum = new int[mat.length][mat[0].length];\\n\\t\\n\\tfor (var i = 0; i < m; i++) {\\n\\t\\tfor (var j = 0; j < n; j++) {\\n\\n\\t\\t\\tvar bottomRightX = Math.min(m, i + 1 + k);\\n\\t\\t\\tvar bottomRightY = Math.min(n, j + 1 + k);\\n\\n\\t\\t\\tvar topLeftX = Math.max(0, i - k);\\n\\t\\t\\tvar topLeftY = Math.max(0, j - k);\\n\\n\\t\\t\\tblockSum[i][j] = prefixSum[bottomRightX][bottomRightY] // bottom right corner\\n\\t\\t\\t\\t\\t- prefixSum[bottomRightX][topLeftY] // top neighbor of block\\n\\t\\t\\t\\t\\t- prefixSum[topLeftX][bottomRightY] // left neighbor of block\\n\\t\\t\\t\\t\\t+ prefixSum[topLeftX][topLeftY]; // intersection of top and left neighbors\\n\\t\\t}\\n\\t}\\n\\treturn blockSum;\\n}\\n\\nprivate int[][] getPrefixSum(int[][] mat) {\\n\\tvar prefixSum = new int[mat.length + 1][mat[0].length + 1];\\n\\tfor (var i = 1; i < prefixSum.length; i++)\\n\\t\\tfor (var j = 1; j < prefixSum[0].length; j++)\\n\\t\\t\\tprefixSum[i][j] = prefixSum[i][j - 1]\\n\\t\\t\\t\\t\\t+ prefixSum[i - 1][j]\\n\\t\\t\\t\\t\\t- prefixSum[i - 1][j - 1]\\n\\t\\t\\t\\t\\t+ mat[i - 1][j - 1];\\n\\treturn prefixSum;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tvar prefixSum = getPrefixSum(mat);\\n\\tvar m = mat.length;\\n\\tvar n = mat[0].length;\\n\\tvar blockSum = new int[mat.length][mat[0].length];\\n\\t\\n\\tfor (var i = 0; i < m; i++) {\\n\\t\\tfor (var j = 0; j < n; j++) {\\n\\n\\t\\t\\tvar bottomRightX = Math.min(m, i + 1 + k);\\n\\t\\t\\tvar bottomRightY = Math.min(n, j + 1 + k);\\n\\n\\t\\t\\tvar topLeftX = Math.max(0, i - k);\\n\\t\\t\\tvar topLeftY = Math.max(0, j - k);\\n\\n\\t\\t\\tblockSum[i][j] = prefixSum[bottomRightX][bottomRightY] // bottom right corner\\n\\t\\t\\t\\t\\t- prefixSum[bottomRightX][topLeftY] // top neighbor of block\\n\\t\\t\\t\\t\\t- prefixSum[topLeftX][bottomRightY] // left neighbor of block\\n\\t\\t\\t\\t\\t+ prefixSum[topLeftX][topLeftY]; // intersection of top and left neighbors\\n\\t\\t}\\n\\t}\\n\\treturn blockSum;\\n}\\n\\nprivate int[][] getPrefixSum(int[][] mat) {\\n\\tvar prefixSum = new int[mat.length + 1][mat[0].length + 1];\\n\\tfor (var i = 1; i < prefixSum.length; i++)\\n\\t\\tfor (var j = 1; j < prefixSum[0].length; j++)\\n\\t\\t\\tprefixSum[i][j] = prefixSum[i][j - 1]\\n\\t\\t\\t\\t\\t+ prefixSum[i - 1][j]\\n\\t\\t\\t\\t\\t- prefixSum[i - 1][j - 1]\\n\\t\\t\\t\\t\\t+ mat[i - 1][j - 1];\\n\\treturn prefixSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248856,
                "title": "c-prefix-row-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        int row[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0){\\n                    row[i][j]=mat[i][j];\\n                }\\n                else{\\n                    row[i][j]=row[i][j-1]+mat[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mat[i][j]=0;\\n                for(int l=max(0,i-k);l<=min(n-1,i+k);l++){\\n                mat[i][j]+=row[l][min(m-1,j+k)]-((j-k-1<0)?0:row[l][max(0,j-k-1)]);\\n                \\n              }\\n                \\n          }\\n        }\\n        return mat;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        int row[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0){\\n                    row[i][j]=mat[i][j];\\n                }\\n                else{\\n                    row[i][j]=row[i][j-1]+mat[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mat[i][j]=0;\\n                for(int l=max(0,i-k);l<=min(n-1,i+k);l++){\\n                mat[i][j]+=row[l][min(m-1,j+k)]-((j-k-1<0)?0:row[l][max(0,j-k-1)]);\\n                \\n              }\\n                \\n          }\\n        }\\n        return mat;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209634,
                "title": "matrix-block-sum-python-prefix-sum-simple-implementation-dynamic-programming",
                "content": "First we make a prefix sum array and than just simple implementation \\n```\\nclass Solution:\\n    \\n    import sys\\n    input = sys.stdin.readline\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n= len(mat)\\n        \\n        m = len(mat[0])\\n        \\n        pre=[ [ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        pre[0][0] = mat[0][0]\\n        \\n        \\n        for i in range(1,m):\\n            \\n            pre[0][i] += pre[0][i-1] + mat[0][i]\\n            \\n        for j in range(1,n):\\n            \\n            pre[j][0] += pre[j-1][0] + mat[j][0]\\n            \\n        \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                \\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]+mat[i][j]\\n                \\n        \\n        result = [[ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                \\n                \\n                r1=  min(i+k,n-1)\\n                c1 = min(j+k , m-1)\\n                \\n                \\n                result[i][j]= pre[r1][c1]\\n                \\n                \\n                \\n                if i-k>0:\\n                    result[i][j] -= pre[i-k-1][c1] # we have to delete extra sum\\n                    \\n                if j-k>0:\\n                    result[i][j] -= pre[r1][j-k-1] # we have to delete extra sum\\n                    \\n                    \\n                if i-k>0 and j-k>0:\\n                    \\n                    result[i][j] += pre[i-k-1][j-k-1] # because we have deleted common sum two times\\n                    \\n        return result\\n                    \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \\n    import sys\\n    input = sys.stdin.readline\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n= len(mat)\\n        \\n        m = len(mat[0])\\n        \\n        pre=[ [ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        pre[0][0] = mat[0][0]\\n        \\n        \\n        for i in range(1,m):\\n            \\n            pre[0][i] += pre[0][i-1] + mat[0][i]\\n            \\n        for j in range(1,n):\\n            \\n            pre[j][0] += pre[j-1][0] + mat[j][0]\\n            \\n        \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                \\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]+mat[i][j]\\n                \\n        \\n        result = [[ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                \\n                \\n                r1=  min(i+k,n-1)\\n                c1 = min(j+k , m-1)\\n                \\n                \\n                result[i][j]= pre[r1][c1]\\n                \\n                \\n                \\n                if i-k>0:\\n                    result[i][j] -= pre[i-k-1][c1] # we have to delete extra sum\\n                    \\n                if j-k>0:\\n                    result[i][j] -= pre[r1][j-k-1] # we have to delete extra sum\\n                    \\n                    \\n                if i-k>0 and j-k>0:\\n                    \\n                    result[i][j] += pre[i-k-1][j-k-1] # because we have deleted common sum two times\\n                    \\n        return result\\n                    \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168483,
                "title": "easy-to-understand-solution-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector <vector<int>> cache, ans;\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        cache.resize(r, vector<int>(c, 0));\\n        ans.resize(r, vector<int>(c, 0));\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                cache[i][j] = mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 1; j < c; j++) {\\n                cache[i][j] += cache[i][j-1];\\n            }\\n        }\\n        \\n        for(int j = 0; j < c; j++) {\\n            for(int i = 1; i < r; i++) {\\n                cache[i][j] += cache[i-1][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                int tr = i - k - 1, tc = j - k - 1;\\n                int br = min(r - 1, i + k), bc = min(c - 1, j + k);\\n                \\n                int removeSum = 0;\\n                \\n                if(tc >= 0) removeSum += cache[br][tc];\\n                if(tr >= 0) removeSum += cache[tr][bc];\\n\\n                if(tr >= 0 and tc >= 0) removeSum -= cache[tr][tc];\\n                \\n                ans[i][j] = cache[br][bc] - removeSum;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector <vector<int>> cache, ans;\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        cache.resize(r, vector<int>(c, 0));\\n        ans.resize(r, vector<int>(c, 0));\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                cache[i][j] = mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 1; j < c; j++) {\\n                cache[i][j] += cache[i][j-1];\\n            }\\n        }\\n        \\n        for(int j = 0; j < c; j++) {\\n            for(int i = 1; i < r; i++) {\\n                cache[i][j] += cache[i-1][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                int tr = i - k - 1, tc = j - k - 1;\\n                int br = min(r - 1, i + k), bc = min(c - 1, j + k);\\n                \\n                int removeSum = 0;\\n                \\n                if(tc >= 0) removeSum += cache[br][tc];\\n                if(tr >= 0) removeSum += cache[tr][bc];\\n\\n                if(tr >= 0 and tc >= 0) removeSum -= cache[tr][tc];\\n                \\n                ans[i][j] = cache[br][bc] - removeSum;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151268,
                "title": "java-prefix-sum-dynamic-programming-o-n-2-solution-faster-than-95-of-submissions",
                "content": "```\\nclass Solution {\\npublic static int[][] matrixBlockSum(int[][] mat, int k) {\\n        int r = mat.length;\\n        int c = mat[0].length;\\n        int[][] sum = new int[r][c];\\n        int[][] ans = new int[r][c];\\n        sum[0][0]=mat[0][0];\\n        for(int i = 1;i<r;i++) {\\n            sum[i][0]=mat[i][0]+sum[i-1][0];\\n        }\\n        for(int i = 1;i<c;i++) {\\n            sum[0][i]=mat[0][i]+sum[0][i-1];\\n        }\\n        for(int i = 1;i<r;i++) {\\n            for(int j = 1;j<c;j++) {\\n               sum[i][j]+=(mat[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]);\\n            }   \\n        }\\n\\t\\t\\n        int r1,c1,r2,c2;\\n        // (r1c1) is top left corner and (r2,c2) is bottom-right corner of sub-matrix \\n\\t\\t\\n\\t\\tfor(int i = 0;i<r;i++) {\\n            for(int j = 0;j<c;j++) {\\n                r1 = Math.max(0,i-k);\\n                r2 = Math.min(r-1,i+k);\\n                c1 = Math.max(0,j-k);\\n                c2 = Math.min(c-1,j+k);\\n                ans[i][j] = sum[r2][c2];\\n                if(r1>0 && c1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]+sum[r2][c1-1]-sum[r1-1][c1-1]);\\n                }\\n                else if(r1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]);\\n                }\\n                else if(c1>0) {\\n                    ans[i][j]-=sum[r2][c1-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\t\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic static int[][] matrixBlockSum(int[][] mat, int k) {\\n        int r = mat.length;\\n        int c = mat[0].length;\\n        int[][] sum = new int[r][c];\\n        int[][] ans = new int[r][c];\\n        sum[0][0]=mat[0][0];\\n        for(int i = 1;i<r;i++) {\\n            sum[i][0]=mat[i][0]+sum[i-1][0];\\n        }\\n        for(int i = 1;i<c;i++) {\\n            sum[0][i]=mat[0][i]+sum[0][i-1];\\n        }\\n        for(int i = 1;i<r;i++) {\\n            for(int j = 1;j<c;j++) {\\n               sum[i][j]+=(mat[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]);\\n            }   \\n        }\\n\\t\\t\\n        int r1,c1,r2,c2;\\n        // (r1c1) is top left corner and (r2,c2) is bottom-right corner of sub-matrix \\n\\t\\t\\n\\t\\tfor(int i = 0;i<r;i++) {\\n            for(int j = 0;j<c;j++) {\\n                r1 = Math.max(0,i-k);\\n                r2 = Math.min(r-1,i+k);\\n                c1 = Math.max(0,j-k);\\n                c2 = Math.min(c-1,j+k);\\n                ans[i][j] = sum[r2][c2];\\n                if(r1>0 && c1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]+sum[r2][c1-1]-sum[r1-1][c1-1]);\\n                }\\n                else if(r1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]);\\n                }\\n                else if(c1>0) {\\n                    ans[i][j]-=sum[r2][c1-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081223,
                "title": "short",
                "content": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& m, int K) \\n{       \\n\\tint N(size(m)), M(size(m[0]));\\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t\\tm[i][j] += (i ? m[i-1][j] : 0) + (j ? m[i][j-1] : 0) - (i and j ? m[i-1][j-1] : 0);\\n\\n    vector out(N, vector(M, 0));  \\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t{\\n\\t\\t\\tauto bi{min(i+K, N-1)}, bj{min(j+K, M-1)}, ui{max(i-K, 0)}, uj{max(j-K, 0)};\\n\\t\\t\\tout[i][j] = m[bi][bj] - (ui ? m[ui-1][bj] : 0) - (uj ? m[bi][uj-1] : 0) + (ui and uj ? m[ui-1][uj-1] : 0);\\n\\t\\t}\\n\\n\\treturn out;\\n}\\n```\\n`ui` - upper `i`;\\n`uj` - upper `j`;\\n`bi` - bottom `i`;\\n`bj` - bottom `j`.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/48561368-819b-4c0c-932f-5c6086717a10_1614196016.36988.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& m, int K) \\n{       \\n\\tint N(size(m)), M(size(m[0]));\\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t\\tm[i][j] += (i ? m[i-1][j] : 0) + (j ? m[i][j-1] : 0) - (i and j ? m[i-1][j-1] : 0);\\n\\n    vector out(N, vector(M, 0));  \\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t{\\n\\t\\t\\tauto bi{min(i+K, N-1)}, bj{min(j+K, M-1)}, ui{max(i-K, 0)}, uj{max(j-K, 0)};\\n\\t\\t\\tout[i][j] = m[bi][bj] - (ui ? m[ui-1][bj] : 0) - (uj ? m[bi][uj-1] : 0) + (ui and uj ? m[ui-1][uj-1] : 0);\\n\\t\\t}\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010493,
                "title": "java-o-m-n-runtime-using-sum-matrix",
                "content": "Let\\'s imagine we have a box, and we want to shade in as much of that box at any given point given the boundaries. Let\\'s say we\\'re given a sum matrix, which tells us the sum of all elements above and to the left of us. Then we can use some algebra to calculate the box around any given point. \\n\\nTo do this, we go as far right as we can before we hit our position `j + K`. We also go as far down as we can, which is `i + K`. This is represented as the `minimum` of `M-1` and `i+K` , and `N-1` and `j+K`. Because our sum matrix is shifted 1 to the right to avoid the case where our left boundary is out of the matrix, we add all values in our math by 1 index. Then we need to start removing all of the stuff that\\'s outside our boundary to the left. This is done similarly, in which if the left boundary `j-K-1` or the top boundary `i-K-1` exists, we subtract everything from there. But because we subtracted some elements twice, we have to add back all the top left elements that overlapped by adding `(i-K, j-K)`.\\n\\nTo help visualize this, a good exercise is to plot points A, B, C, D on paper, and shade in the boxes that we\\'re adding and subtracting. The code is short and simple, but try to recreate it yourself!\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int M = mat.length, N = mat[0].length;\\n        int[][] res = new int[M][N], sum = new int[M+1][N+1];\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                sum[i+1][j+1] = mat[i][j] + sum[i+1][j] + sum[i][j+1] - sum[i][j];\\n            }\\n        }\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                int A = Math.max(0, i-K), B = Math.max(0, j-K), C = Math.min(M, i+K+1), D = Math.min(N, j+K+1);\\n                res[i][j] = sum[C][D] - sum[A][D] - sum[C][B] + sum[A][B];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int M = mat.length, N = mat[0].length;\\n        int[][] res = new int[M][N], sum = new int[M+1][N+1];\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                sum[i+1][j+1] = mat[i][j] + sum[i+1][j] + sum[i][j+1] - sum[i][j];\\n            }\\n        }\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                int A = Math.max(0, i-K), B = Math.max(0, j-K), C = Math.min(M, i+K+1), D = Math.min(N, j+K+1);\\n                res[i][j] = sum[C][D] - sum[A][D] - sum[C][B] + sum[A][B];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975548,
                "title": "java-96-faster-using-pre-calcualted-sum-matrix",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int M = mat.length;\\n        int N = mat[0].length;\\n        \\n        int[][] dp = new int[M+1][N+1];\\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                \\n                int r1 = Math.max(0, i-K);\\n                int c1 = Math.max(0, j-K);\\n                int r2 = Math.min(M-1, i+K);\\n                int c2 = Math.min(N-1, j+K);\\n                \\n                mat[i][j] = dp[r2+1][c2+1] -dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int M = mat.length;\\n        int N = mat[0].length;\\n        \\n        int[][] dp = new int[M+1][N+1];\\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                \\n                int r1 = Math.max(0, i-K);\\n                int c1 = Math.max(0, j-K);\\n                int r2 = Math.min(M-1, i+K);\\n                int c2 = Math.min(N-1, j+K);\\n                \\n                mat[i][j] = dp[r2+1][c2+1] -dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950320,
                "title": "simple-python-solution",
                "content": "simply code up the instructions\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n\\t\\t# initialize the output\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        \\n\\t\\t# code up the instructions with the max/min trick\\n        for i in range(m):\\n            for j in range(n):\\n                answer[i][j] = sum(\\n                    mat[r][c] for r in range(max(0, i-K), min(m, i+K+1)) \\n                              for c in range(max(0, j - K), min(n, j+K+1))\\n                )\\n        \\n        return answer\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n\\t\\t# initialize the output\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        \\n\\t\\t# code up the instructions with the max/min trick\\n        for i in range(m):\\n            for j in range(n):\\n                answer[i][j] = sum(\\n                    mat[r][c] for r in range(max(0, i-K), min(m, i+K+1)) \\n                              for c in range(max(0, j - K), min(n, j+K+1))\\n                )\\n        \\n        return answer\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 943647,
                "title": "c-95-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        int m = mat.size();\\n        if(m == 0) return mat;\\n        int n = mat[0].size();\\n        if(n == 0) return mat;\\n        \\n        dp = vector<vector<int>> (m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mat[i][j] = helper(i-K, i+K, j-K, j+K, m, n);\\n            }\\n        }\\n        return mat;\\n    }\\n    int helper(int iMin, int iMax, int jMin, int jMax, int m, int n)\\n    {\\n        iMin = iMin < 0 ? 0 : iMin;\\n        iMax = iMax >= m ? m-1 : iMax;\\n        jMin = jMin < 0 ? 0 : jMin;\\n        jMax = jMax >= n ? n-1 : jMax;\\n        return dp[iMax+1][jMax+1] + dp[iMin][jMin] - dp[iMax+1][jMin] - dp[iMin][jMax+1]; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        int m = mat.size();\\n        if(m == 0) return mat;\\n        int n = mat[0].size();\\n        if(n == 0) return mat;\\n        \\n        dp = vector<vector<int>> (m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mat[i][j] = helper(i-K, i+K, j-K, j+K, m, n);\\n            }\\n        }\\n        return mat;\\n    }\\n    int helper(int iMin, int iMax, int jMin, int jMax, int m, int n)\\n    {\\n        iMin = iMin < 0 ? 0 : iMin;\\n        iMax = iMax >= m ? m-1 : iMax;\\n        jMin = jMin < 0 ? 0 : jMin;\\n        jMax = jMax >= n ? n-1 : jMax;\\n        return dp[iMax+1][jMax+1] + dp[iMin][jMin] - dp[iMax+1][jMin] - dp[iMin][jMax+1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910337,
                "title": "clean-java-code-with-explanation-beats-97",
                "content": "The idea here is to calculate a prefix sum of the 2D Array. Any cell in prefixSum represents the sum of all values formed by the rectangle (0,0) and(i,j). \\n\\nIllustration\\n\\n![image](https://assets.leetcode.com/users/images/65722fe3-7503-4af2-a98d-f3217658056f_1603669488.6309206.png)\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] prefixSum = new int[m][n];\\n        int[][] result = new int[m][n];\\n        \\n        prefixSum[0][0] = mat[0][0];\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            prefixSum[i][0] = mat[i][0] + prefixSum[i-1][0];    \\n        }\\n        \\n        for(int j=1; j<n; j++)\\n        {\\n            prefixSum[0][j] = mat[0][j] + prefixSum[0][j-1];    \\n        }\\n            \\n        for(int i=1; i<m; i++)\\n        {\\n            for(int j=1; j<n; j++)\\n            {\\n                prefixSum[i][j] = mat[i][j] + prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1];\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                int r1 = Math.max(0, i-K);\\n                int c1 = Math.max(0, j-K);\\n                int r2 = Math.min(m-1, i+K);\\n                int c2 = Math.min(n-1, j+K);\\n                \\n                result[i][j] = prefixSum[r2][c2];\\n                \\n                if(r1 > 0)\\n                    result[i][j] -= prefixSum[r1-1][c2];             \\n                \\n                if(c1 > 0)\\n                    result[i][j] -= prefixSum[r2][c1-1];             \\n                \\n                if(r1 > 0 && c1 > 0)\\n                    result[i][j] += prefixSum[r1-1][c1-1];          \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] prefixSum = new int[m][n];\\n        int[][] result = new int[m][n];\\n        \\n        prefixSum[0][0] = mat[0][0];\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            prefixSum[i][0] = mat[i][0] + prefixSum[i-1][0];    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 873441,
                "title": "o-m-n-python-without-indices",
                "content": "It\\'s always the `i`s and `j`s that trip me up when solving this type of problem, so I thought I\\'d implement a solution in Python that doesn\\'t use any `i`s or `j`s at all, using some of the tools found in the `itertools` module.\\n\\nSay `K == 1`, then for each row, we first want to compute the sums of overlapping groups of `3` -- that\\'s `2*K + 1`. Here\\'s an example. It\\'s convenient to bookend the row with `K` zeroes.\\n\\n```txt\\nrow = [4, 2, 9, 1]\\nsummed_row = [6 15, 12, 10]\\n\\n  0   4   2   9   1   0\\n  0 + 4 + 2             = 6\\n      4 + 2 + 9         = 15\\n          2 + 9 + 1     = 12\\n              9 + 1 + 0 = 10\\n```\\n\\nYou might notice as we go from one sum to the next, we only have to subtract one value at the left end, and add one value at the right end. We can do this efficiently by using a FIFO queue to keep track of the values in the current sum. This is what the `sums` generator does in the implementation below.\\n\\nOnce we\\'ve done this for each row, we have a new matrix, and are half way to solving the problem. We\\'ve summed row-wise; we now need to sum column-wise. To do this, we just transpose the new matrix, apply this process again, and transpose it back.\\n\\n```python\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            queue = collections.deque()\\n            total = 0\\n            bookended_iterable = itertools.chain(\\n                itertools.repeat(0, K),\\n                iterable,\\n                itertools.repeat(0, K),\\n            )\\n            for value in bookended_iterable:\\n                queue.append(value)\\n                total += value\\n                if len(queue) == 2*K + 1:\\n                    yield total\\n                    total -= queue.popleft()\\n        new_mat_1 = (sums(row) for row in mat)\\n        new_mat_2 = (sums(row) for row in zip(*new_mat_1))\\n        return [list(row) for row in zip(*new_mat_2)]\\n```\\n\\nHere\\'s another implementation along similar lines. This one is actually a little bit faster because all the iteration is done inside `map` and `itertools` functions, which are all implemented in C. In fact, last I checked, this scored 100% for runtime.\\n\\n```python\\nfrom itertools  import accumulate, chain, repeat, tee, islice\\nfrom operator   import sub\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            bookended = chain(repeat(0, K), iterable, repeat(0, K))\\n            it1, it2 = tee(accumulate(bookended, initial=0))\\n            return map(sub, islice(it1, 2*K+1, None), it2)\\n        new_mat_1 = map(sums, mat)\\n        new_mat_2 = map(sums, zip(*new_mat_1))\\n        return list(map(list, zip(*new_mat_2)))\\n```\\n\\nAnd finally, a one-liner using numpy/scipy. This isn\\'t fast enough for the test-cases unfortunately:\\n\\n```python\\nimport numpy as np\\nfrom scipy.ndimage import convolve\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, k):\\n        return convolve(mat, np.ones((2*k+1, 2*k+1)), mode=\\'constant\\')\\n```",
                "solutionTags": [],
                "code": "```txt\\nrow = [4, 2, 9, 1]\\nsummed_row = [6 15, 12, 10]\\n\\n  0   4   2   9   1   0\\n  0 + 4 + 2             = 6\\n      4 + 2 + 9         = 15\\n          2 + 9 + 1     = 12\\n              9 + 1 + 0 = 10\\n```\n```python\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            queue = collections.deque()\\n            total = 0\\n            bookended_iterable = itertools.chain(\\n                itertools.repeat(0, K),\\n                iterable,\\n                itertools.repeat(0, K),\\n            )\\n            for value in bookended_iterable:\\n                queue.append(value)\\n                total += value\\n                if len(queue) == 2*K + 1:\\n                    yield total\\n                    total -= queue.popleft()\\n        new_mat_1 = (sums(row) for row in mat)\\n        new_mat_2 = (sums(row) for row in zip(*new_mat_1))\\n        return [list(row) for row in zip(*new_mat_2)]\\n```\n```python\\nfrom itertools  import accumulate, chain, repeat, tee, islice\\nfrom operator   import sub\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            bookended = chain(repeat(0, K), iterable, repeat(0, K))\\n            it1, it2 = tee(accumulate(bookended, initial=0))\\n            return map(sub, islice(it1, 2*K+1, None), it2)\\n        new_mat_1 = map(sums, mat)\\n        new_mat_2 = map(sums, zip(*new_mat_1))\\n        return list(map(list, zip(*new_mat_2)))\\n```\n```python\\nimport numpy as np\\nfrom scipy.ndimage import convolve\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, k):\\n        return convolve(mat, np.ones((2*k+1, 2*k+1)), mode=\\'constant\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856544,
                "title": "easy-to-read-code-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref_sum(n, vector<int>(m, 0)), res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pref_sum[i][j] = mat[i][j];\\n                if (i - 1 >= 0) pref_sum[i][j] += pref_sum[i - 1][j];\\n                if (j - 1 >= 0) pref_sum[i][j] += pref_sum[i][j - 1];\\n                if (i - 1 >= 0 && j - 1 >= 0) pref_sum[i][j] -= pref_sum[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = max(i - k, 0), y1 = max(j - k, 0), x2 = min(i + k, n - 1), y2 = min(j + k, m - 1);\\n                res[i][j] = pref_sum[x2][y2];\\n                if (x1 - 1 >= 0) res[i][j] -= pref_sum[x1 - 1][y2];\\n                if (y1 - 1 >= 0) res[i][j] -= pref_sum[x2][y1 - 1];\\n                if (x1 - 1 >= 0 && y1 - 1 >= 0) res[i][j] += pref_sum[x1 - 1][y1 - 1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref_sum(n, vector<int>(m, 0)), res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pref_sum[i][j] = mat[i][j];\\n                if (i - 1 >= 0) pref_sum[i][j] += pref_sum[i - 1][j];\\n                if (j - 1 >= 0) pref_sum[i][j] += pref_sum[i][j - 1];\\n                if (i - 1 >= 0 && j - 1 >= 0) pref_sum[i][j] -= pref_sum[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = max(i - k, 0), y1 = max(j - k, 0), x2 = min(i + k, n - 1), y2 = min(j + k, m - 1);\\n                res[i][j] = pref_sum[x2][y2];\\n                if (x1 - 1 >= 0) res[i][j] -= pref_sum[x1 - 1][y2];\\n                if (y1 - 1 >= 0) res[i][j] -= pref_sum[x2][y1 - 1];\\n                if (x1 - 1 >= 0 && y1 - 1 >= 0) res[i][j] += pref_sum[x1 - 1][y1 - 1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847598,
                "title": "o-n-2-time-complexity-python-solution-using-prefix-sum",
                "content": "```\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        n = len(mat)\\n        m = len(mat[0])\\n        dp = [[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j]  + dp[i][j-1] - dp[i-1][j-1] \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                r1 = max(i-K-1,0)\\n                c1 = max(j-K-1,0)\\n                r2 = min(i+K,n)\\n                c2 = min(j+K,m)\\n                mat[i-1][j-1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1]\\n        return mat\\n\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        n = len(mat)\\n        m = len(mat[0])\\n        dp = [[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j]  + dp[i][j-1] - dp[i-1][j-1] \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                r1 = max(i-K-1,0)\\n                c1 = max(j-K-1,0)\\n                r2 = min(i+K,n)\\n                c2 = min(j+K,m)\\n                mat[i-1][j-1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1]\\n        return mat\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 812592,
                "title": "c-solution-easy-to-understand-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int give(int num,int n)\\n    {\\n        if(num < 0)\\n            return 0;\\n        if(num>=n)\\n            return n-1;\\n        return num;\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        for(int i=0;i<mat.size();i++)\\n            for(int j=1;j<mat[0].size();j++)\\n                mat[i][j]+=mat[i][j-1];\\n        \\n        for(int i=0;i<mat[0].size();i++)\\n            for(int j=1;j<mat.size();j++)\\n                mat[j][i]+=mat[j-1][i];\\n        \\n        vector<vector<int>> ans;        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            vector<int> v;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                int val = 0;\\n                val+=mat[give(i+k,n)][give(j+k,m)];\\n                if(i > k)\\n                    val-=mat[give(i-k-1,n)][give(j+k,m)];\\n                if(j > k)\\n                    val-=mat[give(i+k,n)][give(j-k-1,m)];\\n                if(i>k and j>k)\\n                    val+=mat[give(i-k-1,n)][give(j-k-1,m)];\\n                \\n                v.push_back(val);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int give(int num,int n)\\n    {\\n        if(num < 0)\\n            return 0;\\n        if(num>=n)\\n            return n-1;\\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 733714,
                "title": "super-clean-python-o-n-m-solution",
                "content": "**Super Clean Python | O(n * m) solution**\\n\\nClean Python Code reaching the solution in an organized manner. It looks like a college homework lol.\\n\\n```\\nfmax     = lambda x,y: x if x>y else y # 33% Faster than Python\\'s Built-in MAX Function\\nfmin     = lambda x,y: x if x<y else y # Idem for MIN Function\\ninizero  = lambda r,c: [[0]*c for _ in range(r)]\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        r,c = len(mat), len(mat[0])\\n        #\\n        # -----------------------------------\\n        #         Range Sums Up to [i,j]\\n        # -----------------------------------\\n        #\\n        Sum    = inizero(r,c)\\n        #\\n        # First Row Initilization\\n        s = 0\\n        for j in range(c):\\n            s        += mat[0][j]\\n            Sum[0][j] = s\\n        #\\n        # First Column Initilization\\n        s = 0\\n        for i in range(r):\\n            s        += mat[i][0]\\n            Sum[i][0] = s\\n        #\\n        # Center Range\\n        for i in range(1,r):\\n            for j in range(1,c):\\n                Sum[i][j] = mat[i][j] + Sum[i-1][j] + Sum[i][j-1] - Sum[i-1][j-1]\\n        #\\n        # -----------------------------------\\n        #         Final Answer\\n        # -----------------------------------\\n        res = inizero(r,c)\\n        for i in range(r):\\n            for j in range(c):\\n                i1,j1 = fmax(0  ,i-K),fmax(0  ,j-K)\\n                i2,j2 = fmin(r-1,i+K),fmin(c-1,j+K)\\n                #\\n                a = Sum[i2][j2]\\n                if i1>0:\\n                    a -= Sum[i1-1][j2]\\n                    if j1>0:\\n                        a += Sum[i1-1][j1-1] # This was being subtracted twice\\n                if j1>0:\\n                    a -= Sum[i2][j1-1]\\n                res[i][j] = a\\n        #\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfmax     = lambda x,y: x if x>y else y # 33% Faster than Python\\'s Built-in MAX Function\\nfmin     = lambda x,y: x if x<y else y # Idem for MIN Function\\ninizero  = lambda r,c: [[0]*c for _ in range(r)]\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        r,c = len(mat), len(mat[0])\\n        #\\n        # -----------------------------------\\n        #         Range Sums Up to [i,j]\\n        # -----------------------------------\\n        #\\n        Sum    = inizero(r,c)\\n        #\\n        # First Row Initilization\\n        s = 0\\n        for j in range(c):\\n            s        += mat[0][j]\\n            Sum[0][j] = s\\n        #\\n        # First Column Initilization\\n        s = 0\\n        for i in range(r):\\n            s        += mat[i][0]\\n            Sum[i][0] = s\\n        #\\n        # Center Range\\n        for i in range(1,r):\\n            for j in range(1,c):\\n                Sum[i][j] = mat[i][j] + Sum[i-1][j] + Sum[i][j-1] - Sum[i-1][j-1]\\n        #\\n        # -----------------------------------\\n        #         Final Answer\\n        # -----------------------------------\\n        res = inizero(r,c)\\n        for i in range(r):\\n            for j in range(c):\\n                i1,j1 = fmax(0  ,i-K),fmax(0  ,j-K)\\n                i2,j2 = fmin(r-1,i+K),fmin(c-1,j+K)\\n                #\\n                a = Sum[i2][j2]\\n                if i1>0:\\n                    a -= Sum[i1-1][j2]\\n                    if j1>0:\\n                        a += Sum[i1-1][j1-1] # This was being subtracted twice\\n                if j1>0:\\n                    a -= Sum[i2][j1-1]\\n                res[i][j] = a\\n        #\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572515,
                "title": "c-solution-very-precise-beats-100-memory",
                "content": "First we calculate the required prefix sum for the entire matrix.\\nThen we store the required block sum in ans[i][j] taking care of boundary cases.\\nSee pictures for better visualisation.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& a, int k) {\\n        int m=a.size();\\n        int n=a[0].size();\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]+a[i-1][j-1]-dp[i-1][j-1];\\n            }\\n        }\\n         \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                int x=dp[min(m,i+k)][min(n,j+k)];\\n                int y=dp[max(0,i-k-1)][min(n,j+k)];\\n                int w=dp[min(m,i+k)][max(0,j-k-1)];\\n                int z=dp[max(0,i-k-1)][max(0,j-k-1)];\\n                \\n                ans[i-1][j-1]=x+z-(y+w);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& a, int k) {\\n        int m=a.size();\\n        int n=a[0].size();\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]+a[i-1][j-1]-dp[i-1][j-1];\\n            }\\n        }\\n         \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                int x=dp[min(m,i+k)][min(n,j+k)];\\n                int y=dp[max(0,i-k-1)][min(n,j+k)];\\n                int w=dp[min(m,i+k)][max(0,j-k-1)];\\n                int z=dp[max(0,i-k-1)][max(0,j-k-1)];\\n                \\n                ans[i-1][j-1]=x+z-(y+w);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485815,
                "title": "c-understandable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n\\t\\tint M = mat.size();\\n\\t\\tint N = mat[0].size();\\n\\t\\tvector<vector<int>> ans(M, vector<int>(N, 0));\\n\\t\\tfor (int i = 0; i < mat.size(); i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[i].size(); j++) {\\n\\t\\t\\t\\tint rLower = ((i - K) < 0 ? 0 : (i - K));\\n\\t\\t\\t\\tint rUpper = (i + K) >= mat.size() ? (mat.size() - 1) : (i + K);\\n\\t\\t\\t\\tint cLower = ((j - K) < 0 ? 0 : (j - K));\\n\\t\\t\\t\\tint cUpper = (j + K) >= mat[i].size() ? (mat[i].size() - 1) : (j + K);\\n\\t\\t\\t\\tgetRangeSum(mat, rLower, rUpper, cLower, cUpper, i, j, ans);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid getRangeSum(vector<vector<int>> &mat, int rL, int rU, int cL, int cU, int i, int j, vector<vector<int>>& ans) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int r = rL; r <= rU; r++) {\\n\\t\\t\\tfor (int c = cL; c <= cU; c++) {\\n\\t\\t\\t\\tsum += mat[r][c];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[i][j] += sum;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n\\t\\tint M = mat.size();\\n\\t\\tint N = mat[0].size();\\n\\t\\tvector<vector<int>> ans(M, vector<int>(N, 0));\\n\\t\\tfor (int i = 0; i < mat.size(); i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[i].size(); j++) {\\n\\t\\t\\t\\tint rLower = ((i - K) < 0 ? 0 : (i - K));\\n\\t\\t\\t\\tint rUpper = (i + K) >= mat.size() ? (mat.size() - 1) : (i + K);\\n\\t\\t\\t\\tint cLower = ((j - K) < 0 ? 0 : (j - K));\\n\\t\\t\\t\\tint cUpper = (j + K) >= mat[i].size() ? (mat[i].size() - 1) : (j + K);\\n\\t\\t\\t\\tgetRangeSum(mat, rLower, rUpper, cLower, cUpper, i, j, ans);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid getRangeSum(vector<vector<int>> &mat, int rL, int rU, int cL, int cU, int i, int j, vector<vector<int>>& ans) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int r = rL; r <= rU; r++) {\\n\\t\\t\\tfor (int c = cL; c <= cU; c++) {\\n\\t\\t\\t\\tsum += mat[r][c];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[i][j] += sum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485225,
                "title": "python3-short-and-fast-88ms-double-sliding-window",
                "content": "# Explanation\\nFirst take the matrix and build a matrix of sliding column sums.\\n\\nThen for that resulting matrix, build a matrix of sliding row sums.\\n\\nSo for example, with K=1:\\n```\\n1  2  3    +cols    5  7  9    +rows   12 21 16\\n4  5  6    ---->   12 15 18    ---->   27 45 33\\n7  8  9            11 13 15            24 39 28\\n```\\n\\nNote that we could do rows first, then columns. The order is arbritrary.\\n\\n# Code\\n\\n```python\\nclass Solution:\\n  def matrixBlockSum(self, grid: List[List[int]], K: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    \\n    # build a matrix of sliding window sums for each row\\n    dp = [[0] * w for _ in range(h)]    \\n    for x in range(w):\\n      dp[0][x] = sum(row[x] for row in grid[0:min(h, K+1)])\\n      for i in range(1, h):\\n        dp[i][x] = dp[i-1][x] + (grid[K+i][x] if K+i < h else 0) - (grid[i-K-1][x] if 0 < i-K else 0)\\n    \\n    # build a matrix of sliding window sums for each column of that matrix\\n    for y in range(h):\\n      grid[y][0] = sum(dp[y][0:min(w, K+1)])\\n      for i in range(1, w):\\n        grid[y][i] = grid[y][i-1] + (dp[y][K+i] if K+i < w else 0) - (dp[y][i-K-1] if 0 < i-K else 0)\\n\\n    return grid\\n```",
                "solutionTags": [],
                "code": "```\\n1  2  3    +cols    5  7  9    +rows   12 21 16\\n4  5  6    ---->   12 15 18    ---->   27 45 33\\n7  8  9            11 13 15            24 39 28\\n```\n```python\\nclass Solution:\\n  def matrixBlockSum(self, grid: List[List[int]], K: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    \\n    # build a matrix of sliding window sums for each row\\n    dp = [[0] * w for _ in range(h)]    \\n    for x in range(w):\\n      dp[0][x] = sum(row[x] for row in grid[0:min(h, K+1)])\\n      for i in range(1, h):\\n        dp[i][x] = dp[i-1][x] + (grid[K+i][x] if K+i < h else 0) - (grid[i-K-1][x] if 0 < i-K else 0)\\n    \\n    # build a matrix of sliding window sums for each column of that matrix\\n    for y in range(h):\\n      grid[y][0] = sum(dp[y][0:min(w, K+1)])\\n      for i in range(1, w):\\n        grid[y][i] = grid[y][i-1] + (dp[y][K+i] if K+i < w else 0) - (dp[y][i-K-1] if 0 < i-K else 0)\\n\\n    return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483611,
                "title": "java-with-explanation-beats-96",
                "content": "class Solution {\\n     /**\\n    Take the element iend and jend and subtract  mat[istart - 1][jend]\\n    and mat[iend][jstart - 1] elemnt from it. since mat[istart-1][jstart-1] is subtracted\\n    twice just add itt once more\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int[][] dp = new int[mat.length][mat[0].length ];\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        //col wise addition\\n        for(int i=0; i< row; i++){\\n            for( int j =1; j < col; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        //row wise addition\\n        for(int i=1; i< row; i++){\\n            for( int j =0; j < col; j++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        \\n        int istart, iend, jstart, jend;\\n        int case1 = 0, case2=0, case3=0;\\n        for(int i=0; i < row; i++){\\n            for(int j=0; j < col; j++){\\n                istart = i - K >0 ? i-K : 0;\\n                iend = i + K < row-1 ? i+K : row-1;\\n                jstart = j - K >0 ? j-K : 0;\\n                jend = j + K < col-1 ? j+K : col-1;\\n                \\n                //iend - K ith index on jth col - case1\\n                //jend - K th index on ith row - case2\\n                \\n                case1 =case2=case3=0;\\n                if(istart - 1 >= 0){\\n                    case1 = mat[istart - 1][jend];\\n                }\\n                 \\n                if(jstart - 1 >=0 ){\\n                    case2 = mat[iend][jstart - 1];\\n                }\\n                if(istart - 1 >=0 && jstart-1>=0){\\n                    case3 = mat[istart-1][jstart-1];\\n                }\\n                int jind = jstart-K >0 ? jstart - K : 0;\\n               \\n                dp[i][j]= mat[iend][jend] - case1 - case2 + case3;\\n            }\\n        }\\n        return dp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     /**\\n    Take the element iend and jend and subtract  mat[istart - 1][jend]\\n    and mat[iend][jstart - 1] elemnt from it. since mat[istart-1][jstart-1] is subtracted\\n    twice just add itt once more\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int[][] dp = new int[mat.length][mat[0].length ];\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        //col wise addition\\n        for(int i=0; i< row; i++){\\n            for( int j =1; j < col; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 482820,
                "title": "matrix-block-sum-in-java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        int [][] arr= new int[m][n];\\n        \\n        for(int i=0; i<m ; i++)\\n        { \\n            for(int j=0; j<n ;j++)\\n            {   \\n                int sum=0;\\n              \\n                 for(int r=  Math.max(0,i-K); r<=i+K  && r<m; r++)\\n               {\\n                      for(int c=  Math.max(0,j-K); c<=j+K && c<n ;c++)\\n                  {   \\n                \\n                       sum=sum+mat[r][c];\\n                        \\n                    }\\n                      \\n               }\\n                 arr[i][j]=sum;\\n        \\n    }\\n}\\n        \\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        int [][] arr= new int[m][n];\\n        \\n        for(int i=0; i<m ; i++)\\n        { \\n            for(int j=0; j<n ;j++)\\n            {   \\n                int sum=0;\\n              \\n                 for(int r=  Math.max(0,i-K); r<=i+K  && r<m; r++)\\n               {\\n                      for(int c=  Math.max(0,j-K); c<=j+K && c<n ;c++)\\n                  {   \\n                \\n                       sum=sum+mat[r][c];\\n                        \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 477031,
                "title": "c-2d-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        std::vector<std::vector<int>>  ret;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        std::vector<std::vector<int>> dp(m+1,std::vector<int>(n+1,0));\\n        for(int i = 1; i <= mat.size(); i++)\\n        {\\n            for(int j = 1; j <= mat[0].size(); j++)\\n            {\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            std::vector<int> temp;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                int rBegin = std::max(0,i - K);\\n                int rEnd = std::min(m-1,i + K);\\n                int cBegin = std::max(0,j - K);\\n                int cEnd = std::min(n - 1, j+K);\\n                int value = dp[rEnd+1][cEnd+1] - dp[rEnd+1][cBegin] - dp[rBegin][cEnd+1] + dp[rBegin][cBegin];\\n                temp.push_back(value);\\n            }\\n            ret.push_back(temp);\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        std::vector<std::vector<int>>  ret;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        std::vector<std::vector<int>> dp(m+1,std::vector<int>(n+1,0));\\n        for(int i = 1; i <= mat.size(); i++)\\n        {\\n            for(int j = 1; j <= mat[0].size(); j++)\\n            {\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            std::vector<int> temp;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                int rBegin = std::max(0,i - K);\\n                int rEnd = std::min(m-1,i + K);\\n                int cBegin = std::max(0,j - K);\\n                int cEnd = std::min(n - 1, j+K);\\n                int value = dp[rEnd+1][cEnd+1] - dp[rEnd+1][cBegin] - dp[rBegin][cEnd+1] + dp[rBegin][cBegin];\\n                temp.push_back(value);\\n            }\\n            ret.push_back(temp);\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515360,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[][]=new int[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                int rowS=i-k;\\n                int rowE=i+k;\\n                int colS=j-k;\\n                int colE=j+k;\\n\\n                if(rowS<0){\\n                    rowS=0;\\n                }\\n                if(rowE>=n){\\n                    rowE=n-1;\\n                }\\n\\n                if(colS<0){\\n                    colS=0;\\n                }\\n                if(colE>=m){\\n                    colE=m-1;\\n                }\\n\\n                ans[i][j]=sum(rowS,rowE,colS,colE,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int sum(int rowS,int rowE,int colS,int colE,int[][] mat){\\n        int sum=0;\\n\\n        for(int i=rowS;i<=rowE;i++){\\n            for(int j=colS;j<=colE;j++){\\n                sum+=mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[][]=new int[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                int rowS=i-k;\\n                int rowE=i+k;\\n                int colS=j-k;\\n                int colE=j+k;\\n\\n                if(rowS<0){\\n                    rowS=0;\\n                }\\n                if(rowE>=n){\\n                    rowE=n-1;\\n                }\\n\\n                if(colS<0){\\n                    colS=0;\\n                }\\n                if(colE>=m){\\n                    colE=m-1;\\n                }\\n\\n                ans[i][j]=sum(rowS,rowE,colS,colE,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int sum(int rowS,int rowE,int colS,int colE,int[][] mat){\\n        int sum=0;\\n\\n        for(int i=rowS;i<=rowE;i++){\\n            for(int j=colS;j<=colE;j++){\\n                sum+=mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456842,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] answer = new int[mat.length][mat[0].length];\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.length) {\\n                    rowEnd = mat.length - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].length) {\\n                    colEnd = mat[0].length - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] answer = new int[mat.length][mat[0].length];\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.length) {\\n                    rowEnd = mat.length - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].length) {\\n                    colEnd = mat[0].length - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417283,
                "title": "simple-prefix-sum-with-explanation-c-python",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref(n+1, vector<int>(m+1, 0));\\n        // Calculating prefix sum\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                // note that while counting for [i-1][j] and [i][j-1];\\n                // pref[i-1][j-1] will be added twice. So we reduce it once.\\n                pref[i][j] = mat[i-1][j-1] + pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1];\\n            }\\n        }\\n\\n        // Find the sum of the elements specified in the K-block\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                // checking for all pairs to be in bounds.\\n                int r1 = max(0, i-k);\\n                int c1 = max(0, j-k);\\n                int r2 = min(n-1, i+k);\\n                int c2 = min(m-1, j+k);\\n                // finding res[i][j] = bottom right - bottom left - top right + top left\\n                res[i][j] = pref[r2+1][c2+1] - pref[r2+1][c1] - pref[r1][c2+1] + pref[r1][c1];\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```\\nPython code for the same: \\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        pref = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                pref[i][j] = mat[i - 1][j - 1] + pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1]\\n\\n        res = [[0] * m for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                r1 = max(0, i - k)\\n                c1 = max(0, j - k)\\n                r2 = min(n - 1, i + k)\\n                c2 = min(m - 1, j + k)\\n                res[i][j] = pref[r2 + 1][c2 + 1] - pref[r2 + 1][c1] - pref[r1][c2 + 1] + pref[r1][c1]\\n\\n        return res\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n- Space complexity: $$O(n+m)$$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref(n+1, vector<int>(m+1, 0));\\n        // Calculating prefix sum\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                // note that while counting for [i-1][j] and [i][j-1];\\n                // pref[i-1][j-1] will be added twice. So we reduce it once.\\n                pref[i][j] = mat[i-1][j-1] + pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1];\\n            }\\n        }\\n\\n        // Find the sum of the elements specified in the K-block\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                // checking for all pairs to be in bounds.\\n                int r1 = max(0, i-k);\\n                int c1 = max(0, j-k);\\n                int r2 = min(n-1, i+k);\\n                int c2 = min(m-1, j+k);\\n                // finding res[i][j] = bottom right - bottom left - top right + top left\\n                res[i][j] = pref[r2+1][c2+1] - pref[r2+1][c1] - pref[r1][c2+1] + pref[r1][c1];\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        pref = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                pref[i][j] = mat[i - 1][j - 1] + pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1]\\n\\n        res = [[0] * m for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                r1 = max(0, i - k)\\n                c1 = max(0, j - k)\\n                r2 = min(n - 1, i + k)\\n                c2 = min(m - 1, j + k)\\n                res[i][j] = pref[r2 + 1][c2 + 1] - pref[r2 + 1][c1] - pref[r1][c2 + 1] + pref[r1][c1]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697196,
                "title": "beats-96-c-t-c-o-n-m-pre-computation-prefixsum-rowcolumn",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& arr, int k) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        vector<vector<int>> answer(n,vector<int>(m,0));\\n        \\n        //Pre-Computation (PrefixSum-Row)\\n        for(int i = 0;i<n;++i){\\n            for(int j = m-1;j>0;--j){\\n                arr[i][j-1]+=arr[i][j];\\n            }\\n        }\\n        //Pre-Computation (PrefixSum-RowCol)\\n        for(int i = 0;i<m;++i){\\n            for(int j = n-1;j>0;--j){\\n                arr[j-1][i]+=arr[j][i];\\n            }\\n        }\\n\\n        //Answer\\n        for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < m; ++j)\\n        {\\n            int p = max(0, i - k);\\n            int q = max(0, j - k);\\n            answer[i][j] = arr[p][q];\\n            if (j + k + 1 < m)\\n            {\\n                answer[i][j] -= arr[p][j + k + 1];\\n            }\\n            if (i + k + 1 < n)\\n            {\\n                if (j + k + 1 < m)\\n                {\\n                    answer[i][j] -= (arr[i + k + 1][q] - arr[i + k + 1][j + k + 1]);\\n                }\\n                else\\n                {\\n                    answer[i][j] -= arr[i + k + 1][q];\\n                }\\n            }\\n        }\\n    }\\n    return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& arr, int k) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        vector<vector<int>> answer(n,vector<int>(m,0));\\n        \\n        //Pre-Computation (PrefixSum-Row)\\n        for(int i = 0;i<n;++i){\\n            for(int j = m-1;j>0;--j){\\n                arr[i][j-1]+=arr[i][j];\\n            }\\n        }\\n        //Pre-Computation (PrefixSum-RowCol)\\n        for(int i = 0;i<m;++i){\\n            for(int j = n-1;j>0;--j){\\n                arr[j-1][i]+=arr[j][i];\\n            }\\n        }\\n\\n        //Answer\\n        for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < m; ++j)\\n        {\\n            int p = max(0, i - k);\\n            int q = max(0, j - k);\\n            answer[i][j] = arr[p][q];\\n            if (j + k + 1 < m)\\n            {\\n                answer[i][j] -= arr[p][j + k + 1];\\n            }\\n            if (i + k + 1 < n)\\n            {\\n                if (j + k + 1 < m)\\n                {\\n                    answer[i][j] -= (arr[i + k + 1][q] - arr[i + k + 1][j + k + 1]);\\n                }\\n                else\\n                {\\n                    answer[i][j] -= arr[i + k + 1][q];\\n                }\\n            }\\n        }\\n    }\\n    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697161,
                "title": "c-prefix-sum-too-easy-solution",
                "content": "[**1314. Matrix Block Sum**](https://leetcode.com/problems/matrix-block-sum/)\\n\\n**`Time Complexity : O(m*n)`**\\n**`Space Complexity : O(m*n)`**\\n\\n```\\n\\t vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>>v(m+1, vector<int>(n+1));\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                v[i+1][j+1]=mat[i][j]+v[i+1][j]+v[i][j+1]-v[i][j];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n;j++){\\n                int r1=i-k<0?0:i-k;\\n                int r2=i+k>=m?m-1:i+k;\\n                int c1=j-k<0?0:j-k;\\n                int c2=j+k>=n?n-1:j+k;\\n                mat[i][j]=v[r2+1][c2+1]-v[r1][c2+1]-v[r2+1][c1]+v[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n```\\n***Happy Coding :)***\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>>v(m+1, vector<int>(n+1));\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                v[i+1][j+1]=mat[i][j]+v[i+1][j]+v[i][j+1]-v[i][j];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n;j++){\\n                int r1=i-k<0?0:i-k;\\n                int r2=i+k>=m?m-1:i+k;\\n                int c1=j-k<0?0:j-k;\\n                int c2=j+k>=n?n-1:j+k;\\n                mat[i][j]=v[r2+1][c2+1]-v[r1][c2+1]-v[r2+1][c1]+v[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651950,
                "title": "brute-force-matrix-block-sum-better-than-20-submission-java",
                "content": "class Solution {\\n    \\n    public int helper(int[][] mat, int x, int y, int k){\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i<mat.length; i++){\\n            \\n            for(int j = 0; j<mat[0].length; j++){\\n                \\n                if(x-k <= i && i <= x+k && y-k <= j && j <= y+k){\\n                    sum += mat[i][j];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        \\n        int[][] ans = new int[mat.length][mat[0].length];\\n        \\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                ans[i][j] = helper(mat, i, j, k);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int helper(int[][] mat, int x, int y, int k){\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i<mat.length; i++){\\n            \\n            for(int j = 0; j<mat[0].length; j++){\\n                \\n                if(x-k <= i && i <= x+k && y-k <= j && j <= y+k){\\n                    sum += mat[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2642852,
                "title": "python3-solved-using-prefix-sum",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(m^2*n)\\n    #Space-Complexity: O(m*n)\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[None for _ in range(n)] for z in range(m)]\\n        for a in range(m):\\n            prefix_sum[a][0] = mat[a][0]\\n        #for each row, initialize the prefix sum!\\n        for i in range(0, m, 1):\\n            for j in range(1, n, 1):\\n                prefix_sum[i][j] = prefix_sum[i][j-1] + mat[i][j]\\n        #now, for each entry of mat (r,c), we need to get sum of all elements in (r- k) <= row <= r + k\\n        #and columns s.t. c - k <= col <= c + k!\\n        \\n        #we have to not consider rows that are out of bounds!\\n        ans = [[-100 for _ in range(n)] for _ in range(m)]\\n        #we will fill up this answer as we go!\\n        \\n        for r in range(m):\\n            for j in range(n):\\n                #for the current ans[r][j] entry we are answering for, we can compute the\\n                #lowest and highest in-bounds value for row-wise and column-wise!\\n                lr, hr = max(0, r - k), min(r + k, m - 1)\\n                lc, hc = max(0, j - k), min(j + k, n - 1)\\n                total = 0 \\n                for row in range(lr, hr + 1):\\n                    subtraction = None\\n                    if(lc == 0):\\n                        subtraction = 0\\n                    else:\\n                        subtraction = prefix_sum[row][lc-1]\\n                    sub_sum = prefix_sum[row][hc] - subtraction\\n                    total += sub_sum\\n                ans[r][j] = total\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(m^2*n)\\n    #Space-Complexity: O(m*n)\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[None for _ in range(n)] for z in range(m)]\\n        for a in range(m):\\n            prefix_sum[a][0] = mat[a][0]\\n        #for each row, initialize the prefix sum!\\n        for i in range(0, m, 1):\\n            for j in range(1, n, 1):\\n                prefix_sum[i][j] = prefix_sum[i][j-1] + mat[i][j]\\n        #now, for each entry of mat (r,c), we need to get sum of all elements in (r- k) <= row <= r + k\\n        #and columns s.t. c - k <= col <= c + k!\\n        \\n        #we have to not consider rows that are out of bounds!\\n        ans = [[-100 for _ in range(n)] for _ in range(m)]\\n        #we will fill up this answer as we go!\\n        \\n        for r in range(m):\\n            for j in range(n):\\n                #for the current ans[r][j] entry we are answering for, we can compute the\\n                #lowest and highest in-bounds value for row-wise and column-wise!\\n                lr, hr = max(0, r - k), min(r + k, m - 1)\\n                lc, hc = max(0, j - k), min(j + k, n - 1)\\n                total = 0 \\n                for row in range(lr, hr + 1):\\n                    subtraction = None\\n                    if(lc == 0):\\n                        subtraction = 0\\n                    else:\\n                        subtraction = prefix_sum[row][lc-1]\\n                    sub_sum = prefix_sum[row][hc] - subtraction\\n                    total += sub_sum\\n                ans[r][j] = total\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2495663,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn matrix_block_sum(mat: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let k = k as usize;\\n        let mut memo = vec![vec![0;m+1];n+1];\\n        for i in 0..n {\\n            for j in 0..m {\\n                memo[i+1][j+1] = memo[i+1][j] + memo[i][j+1] - memo[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        let mut result = vec![vec![0;m];n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                let i_min = i.saturating_sub(k);\\n                let i_max = std::cmp::min(i+k, n-1);\\n                let j_min = j.saturating_sub(k);\\n                let j_max = std::cmp::min(j+k, m-1);\\n\\n                result[i][j] = memo[i_max+1][j_max+1] - memo[i_max+1][j_min]\\n                    - memo[i_min][j_max+1] + memo[i_min][j_min];\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn matrix_block_sum(mat: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let k = k as usize;\\n        let mut memo = vec![vec![0;m+1];n+1];\\n        for i in 0..n {\\n            for j in 0..m {\\n                memo[i+1][j+1] = memo[i+1][j] + memo[i][j+1] - memo[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        let mut result = vec![vec![0;m];n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                let i_min = i.saturating_sub(k);\\n                let i_max = std::cmp::min(i+k, n-1);\\n                let j_min = j.saturating_sub(k);\\n                let j_max = std::cmp::min(j+k, m-1);\\n\\n                result[i][j] = memo[i_max+1][j_max+1] - memo[i_max+1][j_min]\\n                    - memo[i_min][j_max+1] + memo[i_min][j_min];\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485584,
                "title": "inclusion-exclusion-principle",
                "content": "Hi, Are there other similar questions involving Inclusion Exclusion principle? I found Range Sum 2d, 1d similar too.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2463288,
                "title": "python3-matrix-block-sum-using-simple-for-loops",
                "content": "class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r2=min(i+k,m-1)\\n                r1=max(i-k,0)\\n                c2=min(j+k,n-1)\\n                c1=max(j-k,0)\\n                sum1=0\\n                for z in range(r1,r2+1):\\n                    sum1=sum1+sum(mat[z][c1:c2+1])      \\n                res[i][j]=sum1\\n        return (res)",
                "solutionTags": [],
                "code": "class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r2=min(i+k,m-1)\\n                r1=max(i-k,0)\\n                c2=min(j+k,n-1)\\n                c1=max(j-k,0)\\n                sum1=0\\n                for z in range(r1,r2+1):\\n                    sum1=sum1+sum(mat[z][c1:c2+1])      \\n                res[i][j]=sum1\\n        return (res)",
                "codeTag": "Java"
            },
            {
                "id": 2442879,
                "title": "c-prefix-sum-tc-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                mat[i][j]=mat[i][j]+mat[i-1][j];\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                int row_s = i-k;\\n                int col_s = j-k;\\n                int row_e = i+k;\\n                int col_e = j+k;\\n                \\n                if(row_e>=m) row_e=m-1;\\n                if(col_e>=n) col_e=n-1;\\n                \\n                int tot = mat[row_e][col_e];\\n                \\n                int temp = 0;\\n                \\n                if(row_s-1>=0){\\n                    temp+=mat[row_s-1][col_e];\\n                } \\n                if(col_s-1>=0){\\n                    temp+=mat[row_e][col_s-1];\\n                }\\n                if(row_s-1>=0 && col_s-1>=0) {\\n                    temp-=mat[row_s-1][col_s-1];\\n                }\\n                \\n                tot = tot-temp;\\n                \\n                ans[i][j]=tot;\\n            }\\n        }\\n        \\n        // for(int i=0;i<m;i++) {\\n        //     for(int j=0;j<n;j++) {\\n        //         cout<<ans[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                mat[i][j]=mat[i][j]+mat[i-1][j];\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                int row_s = i-k;\\n                int col_s = j-k;\\n                int row_e = i+k;\\n                int col_e = j+k;\\n                \\n                if(row_e>=m) row_e=m-1;\\n                if(col_e>=n) col_e=n-1;\\n                \\n                int tot = mat[row_e][col_e];\\n                \\n                int temp = 0;\\n                \\n                if(row_s-1>=0){\\n                    temp+=mat[row_s-1][col_e];\\n                } \\n                if(col_s-1>=0){\\n                    temp+=mat[row_e][col_s-1];\\n                }\\n                if(row_s-1>=0 && col_s-1>=0) {\\n                    temp-=mat[row_s-1][col_s-1];\\n                }\\n                \\n                tot = tot-temp;\\n                \\n                ans[i][j]=tot;\\n            }\\n        }\\n        \\n        // for(int i=0;i<m;i++) {\\n        //     for(int j=0;j<n;j++) {\\n        //         cout<<ans[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2427295,
                "title": "easy-to-understand-solution-c",
                "content": "**Intuition:** Here sum matrix is used to find out the sum of all the elements in the previous rows including current row and all previous column elements including current column. \\nThen what I do in the second for loop is that I actually add the entry for that cell in sum matrix and then subtract the sum of the out of range rows above the current cell and then again subtract the sum of out of range columns to the left of the current cell. Since the common part of these 2 subtracted parts is getting subtracted twice, we add it again. \\nTime complexity: O(mn) \\nSpace Complexity: O(mn) (for sum matrix)\\nwhere m and n are the row size and column size of the matrix given.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> sum(m,vector<int> (n,0)),ans(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                sum[i][j]=mat[i][j];\\n                if(i-1>=0) sum[i][j]+=sum[i-1][j];\\n                if(j-1>=0) sum[i][j]+=sum[i][j-1];\\n                if(i-1>=0 && j-1>=0) sum[i][j]-=sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int temp=0;\\n                temp+=sum[min(i+k,m-1)][min(j+k,n-1)];\\n                if(j-k-1>=0) temp-=sum[min(i+k,m-1)][j-k-1];\\n                if(i-k-1>=0) temp-=sum[max(i-k-1,0)][min(j+k,n-1)];\\n                if(i-k-1>=0 && j-k-1>=0) temp+=sum[max(i-k-1,0)][max(j-k-1,0)];\\n                ans[i][j]=temp;\\n            }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you this helped you!",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> sum(m,vector<int> (n,0)),ans(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                sum[i][j]=mat[i][j];\\n                if(i-1>=0) sum[i][j]+=sum[i-1][j];\\n                if(j-1>=0) sum[i][j]+=sum[i][j-1];\\n                if(i-1>=0 && j-1>=0) sum[i][j]-=sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int temp=0;\\n                temp+=sum[min(i+k,m-1)][min(j+k,n-1)];\\n                if(j-k-1>=0) temp-=sum[min(i+k,m-1)][j-k-1];\\n                if(i-k-1>=0) temp-=sum[max(i-k-1,0)][min(j+k,n-1)];\\n                if(i-k-1>=0 && j-k-1>=0) temp+=sum[max(i-k-1,0)][max(j-k-1,0)];\\n                ans[i][j]=temp;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397613,
                "title": "c-bruteforce",
                "content": "![image](https://assets.leetcode.com/users/images/11a8fb2c-9246-4c42-8e8a-f168278c72f7_1659957737.559068.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\tint m=mat.size();\\n\\t\\t\\tint n=mat[0].size();\\n\\t\\t\\tvector<vector<int>>grid(m,vector<int>(n,0));\\n\\t\\t\\tfor(int r=0;r<m;r++){\\n\\t\\t\\t\\tfor(int c=0;c<n;c++){\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\tfor(int i=max(r-k,0);i<=min(r+k,m-1);i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=max(c-k,0);j<=min(c+k,n-1);j++){\\n\\t\\t\\t\\t\\t\\t\\tsum+=mat[i][j];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrid[r][c]=sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn grid;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\tint m=mat.size();\\n\\t\\t\\tint n=mat[0].size();\\n\\t\\t\\tvector<vector<int>>grid(m,vector<int>(n,0));\\n\\t\\t\\tfor(int r=0;r<m;r++){\\n\\t\\t\\t\\tfor(int c=0;c<n;c++){\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\tfor(int i=max(r-k,0);i<=min(r+k,m-1);i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=max(c-k,0);j<=min(c+k,n-1);j++){\\n\\t\\t\\t\\t\\t\\t\\tsum+=mat[i][j];\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2350180,
                "title": "c-o-n-m-optimized-clean-code-prefixsum",
                "content": "***If you understood the solution, Please upvote the solution***\\n\\nIdea : Based on Inclusion, Exclusion and Prefix Sum\\nFirst creating a prefix sum matrix which is named as ```grid``` in the code, ```grid[i][j]``` represents the sum of every element till i and j in the initial matrix.\\n\\nNow creating a answer matrix, each element of this will be calculated as\\n1. The sum of the maximum index possible, ie ``` maxRow=min(i+k,n-1),maxCol=min(j+k,m-1) ```\\n2. The difference of ```i-k-1,maxCol``` index, if it is valid\\n3. The difference of ```maxRow,j-k-1``` index, if it is valid\\n4. And the addition of ```i-k-1,j-k-1``` index, as from step 2 and 3 this was subtracted twice and we alredy had one of these from step 1, so now our answer is less by  ```i-k-1,j-k-1``` index, therefore adding it to balance\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        \\n        vector<vector<int>>grid(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int minus=(i-1>=0 && j-1>=0)?grid[i-1][j-1]:0;\\n                int add1=(i-1>=0)?grid[i-1][j]:0;\\n                int add2=(j-1>=0)?grid[i][j-1]:0;\\n                grid[i][j]=mat[i][j]+add1+add2-minus;\\n            }\\n        }\\n        \\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int maxRow=min(i+k,n-1),maxCol=min(j+k,m-1);\\n                int base=grid[maxRow][maxCol];\\n                base-=(i-k-1>=0)?grid[i-k-1][maxCol]:0;\\n                base-=(j-k-1>=0)?grid[maxRow][j-k-1]:0;\\n                base+=(i-k-1>=0 && j-k-1>=0)?grid[i-k-1][j-k-1]:0;\\n                ans[i][j]=base;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```grid```\n```grid[i][j]```\n``` maxRow=min(i+k,n-1),maxCol=min(j+k,m-1) ```\n```i-k-1,maxCol```\n```maxRow,j-k-1```\n```i-k-1,j-k-1```\n```i-k-1,j-k-1```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        \\n        vector<vector<int>>grid(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int minus=(i-1>=0 && j-1>=0)?grid[i-1][j-1]:0;\\n                int add1=(i-1>=0)?grid[i-1][j]:0;\\n                int add2=(j-1>=0)?grid[i][j-1]:0;\\n                grid[i][j]=mat[i][j]+add1+add2-minus;\\n            }\\n        }\\n        \\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int maxRow=min(i+k,n-1),maxCol=min(j+k,m-1);\\n                int base=grid[maxRow][maxCol];\\n                base-=(i-k-1>=0)?grid[i-k-1][maxCol]:0;\\n                base-=(j-k-1>=0)?grid[maxRow][j-k-1]:0;\\n                base+=(i-k-1>=0 && j-k-1>=0)?grid[i-k-1][j-k-1]:0;\\n                ans[i][j]=base;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292090,
                "title": "my-java-solution",
                "content": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n        int i = mat.length, j = mat[0].length;\\n        int[][] answer = new int[i][j];\\n        int rLowerBound, rUpperBound, r;\\n        int cLowerBound, cUpperBound, c;\\n        int num;\\n\\n        for (r = 0; r < i; r++) {\\n            for (c = 0; c < j; c++) {\\n                rLowerBound = r - k;\\n                rUpperBound = r + k;\\n                rLowerBound = Math.max(rLowerBound, 0);\\n                rUpperBound = Math.min(rUpperBound, i - 1);\\n\\n                cLowerBound = c - k;\\n                cUpperBound = c + k;\\n                cLowerBound = Math.max(cLowerBound, 0);\\n                cUpperBound = Math.min(cUpperBound, j - 1);\\n\\n                num = 0;\\n                for (int indexR = rLowerBound; indexR <= rUpperBound; indexR++) {\\n                    for (int indexC = cLowerBound; indexC <= cUpperBound; indexC++) {\\n                        num += mat[indexR][indexC];\\n                    }\\n                }\\n\\n                answer[r][c] = num;\\n            }\\n        }\\n        return answer;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n        int i = mat.length, j = mat[0].length;\\n        int[][] answer = new int[i][j];\\n        int rLowerBound, rUpperBound, r;\\n        int cLowerBound, cUpperBound, c;\\n        int num;\\n\\n        for (r = 0; r < i; r++) {\\n            for (c = 0; c < j; c++) {\\n                rLowerBound = r - k;\\n                rUpperBound = r + k;\\n                rLowerBound = Math.max(rLowerBound, 0);\\n                rUpperBound = Math.min(rUpperBound, i - 1);\\n\\n                cLowerBound = c - k;\\n                cUpperBound = c + k;\\n                cLowerBound = Math.max(cLowerBound, 0);\\n                cUpperBound = Math.min(cUpperBound, j - 1);\\n\\n                num = 0;\\n                for (int indexR = rLowerBound; indexR <= rUpperBound; indexR++) {\\n                    for (int indexC = cLowerBound; indexC <= cUpperBound; indexC++) {\\n                        num += mat[indexR][indexC];\\n                    }\\n                }\\n\\n                answer[r][c] = num;\\n            }\\n        }\\n        return answer;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2281598,
                "title": "c-prefix-sum-time-o-m-n",
                "content": "This question is very similar to **[304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/matrix-block-sum/)**. I don\\'t kown how to solve the **Prefix Sum** questions at first. But when I meet some of them. I get two ideas about this kind of problems.\\n\\n * If the question asks we to do something form the edges (the front or back of an array, the leaves or head of a tree, the edges of a matrix...), we could consider to do it with prefix sum.\\n * If the question asks we to get something continous especially sum, we could consider prefix sum because we could use subtraction to get all continous sum.\\n * ...\\n\\nThis is my ideas. I am working hard to learn it, too. So if you have other idea or if I have any wrong, welcome to talk and point out!\\n\\nMy full code is as follows:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        for(int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                mat[i][j] += (i == 0 ? 0 : mat[i - 1][j]) + (j == 0 ? 0 : mat[i][j - 1]) - (i == 0 || j == 0 ? 0 : mat[i - 1][j - 1]);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int r1 = i - k > 0 ? i - k - 1 : -1;\\n                int r2 = i + k < m ? i + k : m - 1;\\n                int c1 = j - k > 0 ? j - k - 1 : -1;\\n                int c2 = j + k < n ? j + k : n - 1;\\n                dp[i][j] = mat[r2][c2] - (c1 == -1 ? 0 : mat[r2][c1]) - (r1 == -1 ? 0 : mat[r1][c2]) + (r1 == -1 || c1 == -1 ? 0 : mat[r1][c1]);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```\\n\\nTime complexity:  O(m\\\\*n)\\nSpace complexity:  O(m\\\\*n)\\n\\n**PLEASE UPVOTE IF HOPEFUL TO YOU, THANKS!!!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        for(int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                mat[i][j] += (i == 0 ? 0 : mat[i - 1][j]) + (j == 0 ? 0 : mat[i][j - 1]) - (i == 0 || j == 0 ? 0 : mat[i - 1][j - 1]);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int r1 = i - k > 0 ? i - k - 1 : -1;\\n                int r2 = i + k < m ? i + k : m - 1;\\n                int c1 = j - k > 0 ? j - k - 1 : -1;\\n                int c2 = j + k < n ? j + k : n - 1;\\n                dp[i][j] = mat[r2][c2] - (c1 == -1 ? 0 : mat[r2][c1]) - (r1 == -1 ? 0 : mat[r1][c2]) + (r1 == -1 || c1 == -1 ? 0 : mat[r1][c1]);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248821,
                "title": "easy-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size()-1, n=mat[0].size()-1;\\n        vector<vector<int>> sum_vector(m+1, vector<int>(n+1,0));\\n        \\n        for(int i=0; i<=m; ++i){\\n            int row = 0;\\n            for(int j=0; j<=n; ++j){\\n                row += mat[i][j];\\n                if(i!=0)    sum_vector[i][j] = sum_vector[i-1][j];\\n                sum_vector[i][j] += row;\\n            }\\n        }\\n        \\n        int rstart, rend, cstart, cend;\\n        \\n        for(int i=0; i<=m; ++i)\\n            for(int j=0; j<=n; ++j){\\n                \\n                rstart=i-k, rend=i+k, cstart=j-k, cend=j+k;\\n                \\n                if(rstart<0) rstart=0;\\n                if(rend>m) rend=m;\\n                if(cstart<0) cstart=0;\\n                if(cend>n) cend=n;\\n                \\n                if(rstart==0 and cstart==0) mat[i][j] = sum_vector[rend][cend];\\n                else if(rstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rend][cstart-1];\\n                else if(cstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rstart-1][cend];\\n                else mat[i][j] = sum_vector[rend][cend]\\n                                  - sum_vector[rend][cstart-1] \\n                                  - sum_vector[rstart-1][cend]\\n                                  + sum_vector[rstart-1][cstart-1];\\n            }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size()-1, n=mat[0].size()-1;\\n        vector<vector<int>> sum_vector(m+1, vector<int>(n+1,0));\\n        \\n        for(int i=0; i<=m; ++i){\\n            int row = 0;\\n            for(int j=0; j<=n; ++j){\\n                row += mat[i][j];\\n                if(i!=0)    sum_vector[i][j] = sum_vector[i-1][j];\\n                sum_vector[i][j] += row;\\n            }\\n        }\\n        \\n        int rstart, rend, cstart, cend;\\n        \\n        for(int i=0; i<=m; ++i)\\n            for(int j=0; j<=n; ++j){\\n                \\n                rstart=i-k, rend=i+k, cstart=j-k, cend=j+k;\\n                \\n                if(rstart<0) rstart=0;\\n                if(rend>m) rend=m;\\n                if(cstart<0) cstart=0;\\n                if(cend>n) cend=n;\\n                \\n                if(rstart==0 and cstart==0) mat[i][j] = sum_vector[rend][cend];\\n                else if(rstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rend][cstart-1];\\n                else if(cstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rstart-1][cend];\\n                else mat[i][j] = sum_vector[rend][cend]\\n                                  - sum_vector[rend][cstart-1] \\n                                  - sum_vector[rstart-1][cend]\\n                                  + sum_vector[rstart-1][cstart-1];\\n            }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236760,
                "title": "c-easy-dp-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        if(n==1 && n==m)\\n            return mat;\\n        \\n        vector<vector<int> > ans(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i][j-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x = i>k?i-k:0;\\n                int y = i+k<n?i+k:n-1;\\n                for(int q=x;q<=y;q++)\\n                {\\n                    if(j<=k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1];\\n                    else if(j<=k && j+k<m)\\n                        ans[i][j] += mat[q][j+k];\\n                    else if(j>k && j+k<m)\\n                        ans[i][j] += mat[q][j+k]-mat[q][j-k-1];\\n                    else if(j>k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1]-mat[q][j-k-1];\\n                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        if(n==1 && n==m)\\n            return mat;\\n        \\n        vector<vector<int> > ans(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i][j-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x = i>k?i-k:0;\\n                int y = i+k<n?i+k:n-1;\\n                for(int q=x;q<=y;q++)\\n                {\\n                    if(j<=k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1];\\n                    else if(j<=k && j+k<m)\\n                        ans[i][j] += mat[q][j+k];\\n                    else if(j>k && j+k<m)\\n                        ans[i][j] += mat[q][j+k]-mat[q][j-k-1];\\n                    else if(j>k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1]-mat[q][j-k-1];\\n                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200931,
                "title": "python-slow-but-intuitive-solution",
                "content": "**\\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F Up Vote If You Like My Answers \\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F**\\n\\nWhen in an interview, it helps to start with a line of though and not rush into making it optimized at the first time.\\n\\nThis is my **slow** solution just to help people who need the first concept.\\n\\nThe idea is to check each row that is ```i-k <= row <= i+k``` and sum the element in the range ``` j-k:<= col <= j+k```.\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = []\\n        for i in range(len(mat)):\\n            temp_row = []\\n            for j in range(len(mat[0])):           \\n                i_start = max(i-k,0)\\n                i_end = min(i+k,len(mat)-1)\\n                j_start = max(j-k,0)\\n                j_end = min(j+k,len(mat)-1)\\n                temp = 0\\n                while i_start<=i_end:\\n                    temp += sum(mat[i_start][j_start:j_end+1])\\n                    i_start += 1\\n                temp_row.append(temp)\\n            ans.append(temp_row)\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```i-k <= row <= i+k```\n``` j-k:<= col <= j+k```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = []\\n        for i in range(len(mat)):\\n            temp_row = []\\n            for j in range(len(mat[0])):           \\n                i_start = max(i-k,0)\\n                i_end = min(i+k,len(mat)-1)\\n                j_start = max(j-k,0)\\n                j_end = min(j+k,len(mat)-1)\\n                temp = 0\\n                while i_start<=i_end:\\n                    temp += sum(mat[i_start][j_start:j_end+1])\\n                    i_start += 1\\n                temp_row.append(temp)\\n            ans.append(temp_row)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176131,
                "title": "prefix-sum-simple-solution-c",
                "content": "No need to explain dry run once you will surely understand the solution\\n\\n**Upvote if you understood**\\n```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        vector<vector<int>> sum(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                sum[i][j]=mat[i-1][j-1]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int si=(i-k<0)?0:i-k;\\n                int sj=(j-k<0)?0:j-k;\\n                \\n                int ei=(i+k>=m)?m-1:i+k;\\n                int ej=(j+k>=n)?n-1:j+k;\\n                si++,sj++,ei++,ej++;\\n                ans[i][j]=sum[ei][ej]-sum[si-1][ej]-sum[ei][sj-1]+sum[si-1][sj-1];\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        vector<vector<int>> sum(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                sum[i][j]=mat[i-1][j-1]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int si=(i-k<0)?0:i-k;\\n                int sj=(j-k<0)?0:j-k;\\n                \\n                int ei=(i+k>=m)?m-1:i+k;\\n                int ej=(j+k>=n)?n-1:j+k;\\n                si++,sj++,ei++,ej++;\\n                ans[i][j]=sum[ei][ej]-sum[si-1][ej]-sum[ei][sj-1]+sum[si-1][sj-1];\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2118428,
                "title": "matrix-block-sum-java-prefix-sum-range-sum-2d-logic",
                "content": "#### **Matrix Block Sum**\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        \\n        int n = mat.length, m = mat[0].length, r1, c1, r2, c2;\\n        int[][] preSum = new int[n+1][m+1];\\n        for (int i=1; i<=n; i++) {\\n            for (int j=1; j<=m; j++) {\\n                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + mat[i-1][j-1] - preSum[i-1][j-1];\\n            }\\n        }\\n        \\n        int[][] result = new int[n][m];\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                r1 = Math.max(i-k, 0);\\n                c1 = Math.max(j-k, 0);\\n                r2 = Math.min(i+k, n-1);\\n                c2 = Math.min(j+k, m-1);\\n                result[i][j] = preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1]; \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        \\n        int n = mat.length, m = mat[0].length, r1, c1, r2, c2;\\n        int[][] preSum = new int[n+1][m+1];\\n        for (int i=1; i<=n; i++) {\\n            for (int j=1; j<=m; j++) {\\n                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + mat[i-1][j-1] - preSum[i-1][j-1];\\n            }\\n        }\\n        \\n        int[][] result = new int[n][m];\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                r1 = Math.max(i-k, 0);\\n                c1 = Math.max(j-k, 0);\\n                r2 = Math.min(i+k, n-1);\\n                c2 = Math.min(j+k, m-1);\\n                result[i][j] = preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1]; \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051995,
                "title": "python-o-mn-2-pass-sliding-window-98",
                "content": "https://leetcode.com/submissions/detail/702345541/\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        s1 = [[0 for j in range(n)] for i in range(m)]\\n        s2 = [[0 for j in range(n)] for i in range(m)]\\n        # For each row, do a sliding window summing: add the value that \"comes into window\"\\n\\t\\t# and subtract the value \"going out of the window\".\\n        for i in range(m):\\n            x = sum(mat[i][0:k])\\n            for j in range(n):\\n                if j + k < n:\\n                    x += mat[i][j+k]\\n                if j - k - 1 >= 0:\\n                    x -= mat[i][j-k-1]\\n                s1[i][j] = x\\n        # Now do the same in columns\\n        for j in range(n):\\n            x = sum(s1[z][j] for z in range(min(m, k)))\\n            for i in range(m):\\n                if i + k < m:\\n                    x += s1[i+k][j]\\n                if i - k - 1 >= 0:\\n                    x -= s1[i-k-1][j]\\n                s2[i][j] = x\\n        return s2\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        s1 = [[0 for j in range(n)] for i in range(m)]\\n        s2 = [[0 for j in range(n)] for i in range(m)]\\n        # For each row, do a sliding window summing: add the value that \"comes into window\"\\n\\t\\t# and subtract the value \"going out of the window\".\\n        for i in range(m):\\n            x = sum(mat[i][0:k])\\n            for j in range(n):\\n                if j + k < n:\\n                    x += mat[i][j+k]\\n                if j - k - 1 >= 0:\\n                    x -= mat[i][j-k-1]\\n                s1[i][j] = x\\n        # Now do the same in columns\\n        for j in range(n):\\n            x = sum(s1[z][j] for z in range(min(m, k)))\\n            for i in range(m):\\n                if i + k < m:\\n                    x += s1[i+k][j]\\n                if i - k - 1 >= 0:\\n                    x -= s1[i-k-1][j]\\n                s2[i][j] = x\\n        return s2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026877,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] prefix, int k) {\\n        int m = prefix.length;\\n        int n = prefix[0].length;\\n        for (int i = 1; i < n;i++) prefix[0][i] += prefix[0][i-1];\\n        for (int i = 1; i < m; i++){\\n            prefix[i][0] += prefix[i-1][0];\\n            for (int j = 1; j < n;j++) prefix[i][j] += prefix[i-1][j] + prefix[i][j -1] - prefix[i-1][j-1];\\n        }int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int ar = Math.min(i + k, m - 1);\\n                int ac = Math.min(j + k, n - 1);\\n                int ir = i - k - 1;\\n                int ic = j - k - 1;\\n                int m1 = ir >= 0? prefix[ir][ac] : 0;\\n                int m2 = ic >= 0? prefix[ar][ic] : 0;\\n                int a1 = ir >= 0 && ic >= 0? prefix[ir][ic] : 0;\\n                res[i][j] += prefix[ar][ac] - m1 - m2 + a1;        \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] prefix, int k) {\\n        int m = prefix.length;\\n        int n = prefix[0].length;\\n        for (int i = 1; i < n;i++) prefix[0][i] += prefix[0][i-1];\\n        for (int i = 1; i < m; i++){\\n            prefix[i][0] += prefix[i-1][0];\\n            for (int j = 1; j < n;j++) prefix[i][j] += prefix[i-1][j] + prefix[i][j -1] - prefix[i-1][j-1];\\n        }int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int ar = Math.min(i + k, m - 1);\\n                int ac = Math.min(j + k, n - 1);\\n                int ir = i - k - 1;\\n                int ic = j - k - 1;\\n                int m1 = ir >= 0? prefix[ir][ac] : 0;\\n                int m2 = ic >= 0? prefix[ar][ic] : 0;\\n                int a1 = ir >= 0 && ic >= 0? prefix[ir][ic] : 0;\\n                res[i][j] += prefix[ar][ac] - m1 - m2 + a1;        \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977955,
                "title": "c-easy-solution-naive-optimal",
                "content": "**NAIVE**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\t   int r=mat.size(),c=mat[0].size();\\n\\t\\t\\t\\t\\tvector<vector<int>> ans(r,vector<int>(c,0));\\n\\t\\t\\t  for(int i=0;i<r;i++){\\n\\t\\t\\t\\t  for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\t  for(int i1=i-k;i1<=i+k;i1++){\\n\\t\\t\\t\\t\\t\\t  if(i1>=0 && i1<r){\\n\\t\\t\\t\\t\\t\\t  for(int j1=j-k;j1<=j+k;j1++){\\n\\t\\t\\t\\t\\t\\t\\t   if(j1>=0 && j1<c){\\n\\t\\t\\t\\t\\t\\t\\t\\t   sum+=mat[i1][j1];\\n\\t\\t\\t\\t\\t\\t\\t   }    \\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  ans[i][j]=sum;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t  }\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\n\\t\\n **OPTIMAL**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\t   int r=mat.size(),c=mat[0].size();\\n\\t\\t\\t   vector<vector<int>> dp(r,vector<int>(c,0));\\n\\n\\t\\t\\t //filling dp matrix\\n\\t\\t\\t for(int i=0;i<r;i++){\\n\\t\\t\\t\\t for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t  if(i==0 or j==0){\\n\\t\\t\\t\\t\\t\\t   if(i==0 && j==0) dp[i][j]=mat[i][j];\\n\\t\\t\\t\\t\\t\\t   else if(i==0) dp[i][j]=mat[i][j]+dp[i][j-1];\\n\\t\\t\\t\\t\\t\\t   else if(j==0) dp[i][j]=mat[i][j]+dp[i-1][j];\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+mat[i][j];\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\n\\t\\t\\t vector<vector<int>> ans(r, vector<int>(c));\\n\\t\\t\\t//computing answer\\n\\t\\t\\tfor(int i=0;i<r;i++){\\n\\t\\t\\t\\tfor(int j=0;j<c;j++){\\n\\t\\t\\t\\t   int rmax=min(r-1,i+k);\\n\\t\\t\\t\\t   int rmin=max(0,i-k);\\n\\t\\t\\t\\t   int cmax=min(c-1,j+k);\\n\\t\\t\\t\\t   int cmin=max(0,j-k);\\n\\n\\t\\t\\t\\t   if(rmin==0 && cmin==0) ans[i][j]=dp[rmax][cmax];\\n\\t\\t\\t\\t   else if(rmin==0) ans[i][j]=dp[rmax][cmax]-dp[rmax][cmin-1];\\n\\t\\t\\t\\t   else if(cmin==0) ans[i][j]=dp[rmax][cmax]-dp[rmin-1][cmax];\\n\\t\\t\\t\\t   else ans[i][j]=dp[rmax][cmax]-dp[rmax][cmin-1]-dp[rmin-1][cmax]\\n\\t\\t\\t\\t\\t\\t\\t\\t  +dp[rmin-1][cmin-1];\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n**NOTE**: You can further save space in optimal solution by just updating mat instead of creating DP !\\n\\nPlease DO **UPVOTE** \\u2B06\\uFE0F If It was **Helpful** !\\n",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\t   int r=mat.size(),c=mat[0].size();\\n\\t\\t\\t\\t\\tvector<vector<int>> ans(r,vector<int>(c,0));\\n\\t\\t\\t  for(int i=0;i<r;i++){\\n\\t\\t\\t\\t  for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\t  for(int i1=i-k;i1<=i+k;i1++){\\n\\t\\t\\t\\t\\t\\t  if(i1>=0 && i1<r){\\n\\t\\t\\t\\t\\t\\t  for(int j1=j-k;j1<=j+k;j1++){\\n\\t\\t\\t\\t\\t\\t\\t   if(j1>=0 && j1<c){\\n\\t\\t\\t\\t\\t\\t\\t\\t   sum+=mat[i1][j1];\\n\\t\\t\\t\\t\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1974903,
                "title": "python-easy-to-understand-with-notes-80-less-memory",
                "content": "```\\n/*\\n    approach: \\n    create a matrix of sum where sum[i][j]th element is the sum\\n    of all the elements from mat[0][0] to mat[i][j]\\n    sum[0][0] = arr[0][0]\\n    for i = 0, sum[0][j] = arr[0][j] + sum[0][j-1]\\n    for j = 0, sum[i][0] = arr[i][0] + sum[i-1][0]\\n    for i>1 and j>1\\n    sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] for i in [1, n] and j in [1, n]\\n    \\n    given matrix\\n    1 2 3\\n    4 5 6\\n    7 8 9\\n    \\n    sum matrix\\n    1 3 6\\n    5 12 21\\n    11 27 45\\n    \\n    for i = 2, j = 1\\n    start_row = 1, start_col = 0\\n    end_row = 2, end_col = 2\\n    sum[i][j] = sum[2][2] - sum[start_row-1][end_col]\\n    \\n    now to create the result matrix, \\n    for i, j get 4 values, \\n    start_row, start_col, end_row, end_col\\n    if start_row == 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col]\\n      \\n    elif start_row == 0 and start_col != 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[end_row][start_col-1]\\n    \\n    elif start_row != 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col]\\n      \\n    else:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col] - sum[end_row][start_col-1]\\n                  + sum[start_row-1][start_col-1]\\n                  \\n*/\\n```\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        mat_sum = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        result = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        mat_sum[0][0] = mat[0][0]\\n        for i in range(1, len(mat)):\\n            mat_sum[i][0] = mat_sum[i-1][0] + mat[i][0]\\n        for i in range(1, len(mat[0])):\\n            mat_sum[0][i] = mat_sum[0][i-1] + mat[0][i]\\n            \\n        for i in range(1, len(mat)):\\n            for j in range(1, len(mat[0])):\\n                mat_sum[i][j] = mat_sum[i-1][j] + mat_sum[i][j-1] + mat[i][j] - mat_sum[i-1][j-1]\\n                \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                # get the matrix for which we need to get the sum\\n                start_row = max(i - k, 0)\\n                end_row = min(i + k, len(mat)-1)\\n                start_col = max(j - k, 0)\\n                end_col = min(j + k, len(mat[0])-1)\\n                if start_row-1<0 and start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col]\\n                elif start_row-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[end_row][start_col-1]\\n                elif start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col]\\n                else:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col] - mat_sum[end_row][start_col-1] + mat_sum[start_row-1][start_col-1]\\n        # print(result)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n/*\\n    approach: \\n    create a matrix of sum where sum[i][j]th element is the sum\\n    of all the elements from mat[0][0] to mat[i][j]\\n    sum[0][0] = arr[0][0]\\n    for i = 0, sum[0][j] = arr[0][j] + sum[0][j-1]\\n    for j = 0, sum[i][0] = arr[i][0] + sum[i-1][0]\\n    for i>1 and j>1\\n    sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] for i in [1, n] and j in [1, n]\\n    \\n    given matrix\\n    1 2 3\\n    4 5 6\\n    7 8 9\\n    \\n    sum matrix\\n    1 3 6\\n    5 12 21\\n    11 27 45\\n    \\n    for i = 2, j = 1\\n    start_row = 1, start_col = 0\\n    end_row = 2, end_col = 2\\n    sum[i][j] = sum[2][2] - sum[start_row-1][end_col]\\n    \\n    now to create the result matrix, \\n    for i, j get 4 values, \\n    start_row, start_col, end_row, end_col\\n    if start_row == 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col]\\n      \\n    elif start_row == 0 and start_col != 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[end_row][start_col-1]\\n    \\n    elif start_row != 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col]\\n      \\n    else:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col] - sum[end_row][start_col-1]\\n                  + sum[start_row-1][start_col-1]\\n                  \\n*/\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        mat_sum = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        result = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        mat_sum[0][0] = mat[0][0]\\n        for i in range(1, len(mat)):\\n            mat_sum[i][0] = mat_sum[i-1][0] + mat[i][0]\\n        for i in range(1, len(mat[0])):\\n            mat_sum[0][i] = mat_sum[0][i-1] + mat[0][i]\\n            \\n        for i in range(1, len(mat)):\\n            for j in range(1, len(mat[0])):\\n                mat_sum[i][j] = mat_sum[i-1][j] + mat_sum[i][j-1] + mat[i][j] - mat_sum[i-1][j-1]\\n                \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                # get the matrix for which we need to get the sum\\n                start_row = max(i - k, 0)\\n                end_row = min(i + k, len(mat)-1)\\n                start_col = max(j - k, 0)\\n                end_col = min(j + k, len(mat[0])-1)\\n                if start_row-1<0 and start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col]\\n                elif start_row-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[end_row][start_col-1]\\n                elif start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col]\\n                else:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col] - mat_sum[end_row][start_col-1] + mat_sum[start_row-1][start_col-1]\\n        # print(result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929669,
                "title": "java-dp-faster-than-96",
                "content": "```\\nclass Solution {\\n    /*\\n    1  2  3  4  5\\n    6  7  8  9  10\\n    11 12 13 14 15\\n    16 17 18 19 20\\n    \\n    dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j-1] - dp[i - 1][j - 1];\\n    result[i - 1][j - 1] = dp[i + k][j + k] - dp[i + k][j - k - 1] - dp[i - k - 1][j + k] + dp[i - k - 1][j - k - 1]\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int maxX = Math.min(m, i + k);\\n                int maxY = Math.min(n, j + k);\\n                int x = Math.max(0, i - k - 1) ;\\n                int y = Math.max(0, j - k - 1) ;\\n                mat[i - 1][j - 1] = dp[maxX][maxY] - dp[maxX][y] - dp[x][maxY] +  dp[x][y];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    1  2  3  4  5\\n    6  7  8  9  10\\n    11 12 13 14 15\\n    16 17 18 19 20\\n    \\n    dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j-1] - dp[i - 1][j - 1];\\n    result[i - 1][j - 1] = dp[i + k][j + k] - dp[i + k][j - k - 1] - dp[i - k - 1][j + k] + dp[i - k - 1][j - k - 1]\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int maxX = Math.min(m, i + k);\\n                int maxY = Math.min(n, j + k);\\n                int x = Math.max(0, i - k - 1) ;\\n                int y = Math.max(0, j - k - 1) ;\\n                mat[i - 1][j - 1] = dp[maxX][maxY] - dp[maxX][y] - dp[x][maxY] +  dp[x][y];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898387,
                "title": "easy-c-solution-using-prefix-sum-matrix",
                "content": "# **Concept:- First build a 2D matrix dp where dp[i][j]= sum of all the cells from (0,0) to (i,j).**\\n# **Now the answer[i][j] = dp[i+k][j+k]-dp[i-k-1][j+k]-dp[i+k][j-k-1]+dp[i-k-1][j-k-1]**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>>dp(mat.size(),vector<int>(mat[0].size())),prefix(mat.size(),vector<int>(mat[0].size())),ans(mat.size(),vector<int>(mat[0].size()));\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                prefix[i][j]=(j>0?prefix[i][j-1]+mat[i][j]:mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                dp[i][j]=(i>0?dp[i-1][j]:0)+prefix[i][j];\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                int row_top=(i+k<mat.size()?i+k:mat.size()-1);\\n                int col_top=(j+k<mat[0].size()?j+k:mat[0].size()-1);\\n                int ar=(i-k-1<0?0:dp[i-k-1][col_top]);\\n                int ac=(j-k-1<0?0:dp[row_top][j-k-1]);\\n                int arc=(i-k-1<0 || j-k-1<0?0:dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j]=dp[row_top][col_top]-ar-ac+arc;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>>dp(mat.size(),vector<int>(mat[0].size())),prefix(mat.size(),vector<int>(mat[0].size())),ans(mat.size(),vector<int>(mat[0].size()));\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                prefix[i][j]=(j>0?prefix[i][j-1]+mat[i][j]:mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                dp[i][j]=(i>0?dp[i-1][j]:0)+prefix[i][j];\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                int row_top=(i+k<mat.size()?i+k:mat.size()-1);\\n                int col_top=(j+k<mat[0].size()?j+k:mat[0].size()-1);\\n                int ar=(i-k-1<0?0:dp[i-k-1][col_top]);\\n                int ac=(j-k-1<0?0:dp[row_top][j-k-1]);\\n                int arc=(i-k-1<0 || j-k-1<0?0:dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j]=dp[row_top][col_top]-ar-ac+arc;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857515,
                "title": "c-neat-code-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans(mat.size(), vector<int>(mat[0].size(), 0));\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                if(i == 0 and j == 0){\\n                    continue;\\n                }else if(i == 0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j == 0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += (mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                int r1 = (i - k >= 0) ? i - k : 0;\\n                int c1 = (j - k >= 0) ? j - k : 0;\\n                int r2 = (i + k < mat.size()) ? i + k : mat.size() - 1;\\n                int c2 = (j + k < mat[0].size()) ? j + k : mat[0].size() - 1;\\n                if(r1 == 0 and c1 == 0){\\n                    ans[i][j] = mat[r2][c2];\\n                }else if(r1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r2][c1-1];\\n                }else if(c1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2];\\n                }else{\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2] - mat[r2][c1-1] + mat[r1-1][c1-1];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans(mat.size(), vector<int>(mat[0].size(), 0));\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                if(i == 0 and j == 0){\\n                    continue;\\n                }else if(i == 0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j == 0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += (mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                int r1 = (i - k >= 0) ? i - k : 0;\\n                int c1 = (j - k >= 0) ? j - k : 0;\\n                int r2 = (i + k < mat.size()) ? i + k : mat.size() - 1;\\n                int c2 = (j + k < mat[0].size()) ? j + k : mat[0].size() - 1;\\n                if(r1 == 0 and c1 == 0){\\n                    ans[i][j] = mat[r2][c2];\\n                }else if(r1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r2][c1-1];\\n                }else if(c1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2];\\n                }else{\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2] - mat[r2][c1-1] + mat[r1-1][c1-1];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846258,
                "title": "easy-to-understand-java-code",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rl,ru,cl,cu,sum;\\n        int u= mat.length;\\n        int v= mat[0].length;\\n        int [][] ans = new int[u][v];       \\n        for(int i=0;i<u;i++){\\n            for(int j=0;j<v;j++){\\n                rl=(i-k)<0?0:(i-k);\\n                cl=(j-k)<0?0:(j-k);\\n                ru=(i+k)<mat.length-1?(i+k):mat.length-1;\\n                cu=(j+k)<mat[0].length-1?(j+k):mat[0].length-1;\\n                sum=0;\\n                for(int r=rl;r<=ru;r++){\\n                    for(int c=cl;c<=cu;c++){\\n                        sum+=mat[r][c];\\n                    }                    \\n                }\\n                ans[i][j]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rl,ru,cl,cu,sum;\\n        int u= mat.length;\\n        int v= mat[0].length;\\n        int [][] ans = new int[u][v];       \\n        for(int i=0;i<u;i++){\\n            for(int j=0;j<v;j++){\\n                rl=(i-k)<0?0:(i-k);\\n                cl=(j-k)<0?0:(j-k);\\n                ru=(i+k)<mat.length-1?(i+k):mat.length-1;\\n                cu=(j+k)<mat[0].length-1?(j+k):mat[0].length-1;\\n                sum=0;\\n                for(int r=rl;r<=ru;r++){\\n                    for(int c=cl;c<=cu;c++){\\n                        sum+=mat[r][c];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1799507,
                "title": "python-easy-to-read-and-understand-range-query-sum-2d",
                "content": "```\\nclass Solution:\\n    def sumRegion(self, matrix, row1, col1, row2, col2):\\n        ans = 0\\n        for i in range(row1, row2+1):\\n            x1 = matrix[i][col2]\\n            x2 = 0 if col1 == 0 else matrix[i][col1-1]\\n            ans += x1-x2\\n        return ans\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        t = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            sums = 0\\n            for j in range(n):\\n                sums += mat[i][j]\\n                t[i][j] = sums\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(0, i-k), min(m-1, i+k)\\n                c1, c2 = max(0, j-k), min(n-1, j+k)\\n                mat[i][j] = self.sumRegion(t, r1, c1, r2, c2)\\n        \\n        return mat",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRegion(self, matrix, row1, col1, row2, col2):\\n        ans = 0\\n        for i in range(row1, row2+1):\\n            x1 = matrix[i][col2]\\n            x2 = 0 if col1 == 0 else matrix[i][col1-1]\\n            ans += x1-x2\\n        return ans\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        t = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            sums = 0\\n            for j in range(n):\\n                sums += mat[i][j]\\n                t[i][j] = sums\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(0, i-k), min(m-1, i+k)\\n                c1, c2 = max(0, j-k), min(n-1, j+k)\\n                mat[i][j] = self.sumRegion(t, r1, c1, r2, c2)\\n        \\n        return mat",
                "codeTag": "Java"
            },
            {
                "id": 1780151,
                "title": "matrix-block-sum-solution-java",
                "content": "class Solution {\\n   public int[][] matrixBlockSum(int[][] mat, int K) {\\n    int m = mat.length, n = mat[0].length;\\n    int[][] rangeSum = new int[m + 1][n + 1];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            rangeSum[i + 1][j + 1] = rangeSum[i + 1][j] + rangeSum[i][j + 1] - rangeSum[i][j] + mat[i][j];\\n    int[][] ans = new int[m][n];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K), r2 = Math.min(m, i + K + 1), c2 = Math.min(n, j + K + 1);\\n            ans[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] - rangeSum[r1][c2] + rangeSum[r1][c1];\\n        }\\n    return ans;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   public int[][] matrixBlockSum(int[][] mat, int K) {\\n    int m = mat.length, n = mat[0].length;\\n    int[][] rangeSum = new int[m + 1][n + 1];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            rangeSum[i + 1][j + 1] = rangeSum[i + 1][j] + rangeSum[i][j + 1] - rangeSum[i][j] + mat[i][j];\\n    int[][] ans = new int[m][n];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K), r2 = Math.min(m, i + K + 1), c2 = Math.min(n, j + K + 1);\\n            ans[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] - rangeSum[r1][c2] + rangeSum[r1][c1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1705596,
                "title": "c-simple-and-elegant-solution-o-n-m",
                "content": "```\\nclass Solution {\\n\\n    // Returns 0 for out of bound indices access;\\nprivate:\\n    int getValue(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||i>=M ||j<0||j>=N) return 0;\\n        \\n        return mat[i][j];\\n    }\\n    // Returns border value for out of bound indices access if called\\nprivate:\\n    int getValueCap(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||j<0) return 0;\\n        i = min(i,M-1);\\n        j = min(j,N-1);\\n        return mat[i][j];\\n    }\\n\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        // Converting to cumulative sum array;\\n        for(int i = 0;i<M;i++)\\n            for(int j=0;j<N;j++)\\n                mat[i][j] += ( getValue(mat, i-1,j) + getValue(mat, i,j-1) - getValue(mat, i-1,j-1) );\\n        \\n        vector<vector<int>> result(M, vector<int>(N));\\n        // result[i][j] = mat[i+k][j+k] - mat[i+k][j-k-1] - mat[i-k-1][j+k] + mat[i-k-1][j-k-1]\\n        for(int i = 0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                int r1 = i-k, r2 = i+k;\\n                int c1 = j-k, c2 = j+k;\\n                int val = getValueCap(mat,r2,c2);\\n                val += getValueCap(mat, r1-1, c1-1);\\n                val -= getValueCap(mat, r2, c1-1);\\n                val -= getValueCap(mat, r1-1, c2);\\n                result[i][j] = val;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Returns 0 for out of bound indices access;\\nprivate:\\n    int getValue(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||i>=M ||j<0||j>=N) return 0;\\n        \\n        return mat[i][j];\\n    }\\n    // Returns border value for out of bound indices access if called\\nprivate:\\n    int getValueCap(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||j<0) return 0;\\n        i = min(i,M-1);\\n        j = min(j,N-1);\\n        return mat[i][j];\\n    }\\n\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        // Converting to cumulative sum array;\\n        for(int i = 0;i<M;i++)\\n            for(int j=0;j<N;j++)\\n                mat[i][j] += ( getValue(mat, i-1,j) + getValue(mat, i,j-1) - getValue(mat, i-1,j-1) );\\n        \\n        vector<vector<int>> result(M, vector<int>(N));\\n        // result[i][j] = mat[i+k][j+k] - mat[i+k][j-k-1] - mat[i-k-1][j+k] + mat[i-k-1][j-k-1]\\n        for(int i = 0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                int r1 = i-k, r2 = i+k;\\n                int c1 = j-k, c2 = j+k;\\n                int val = getValueCap(mat,r2,c2);\\n                val += getValueCap(mat, r1-1, c1-1);\\n                val -= getValueCap(mat, r2, c1-1);\\n                val -= getValueCap(mat, r1-1, c2);\\n                result[i][j] = val;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656876,
                "title": "prefix-sum-meaningful-variable-names",
                "content": "Here is the image which helps to understand prefix sum in matrix:\\n\\n![image](https://assets.leetcode.com/users/images/c0f1961f-0037-410f-b364-189f02d4b374_1640881207.2176192.png)\\n\\nAs far as we add or subtract `OA` sector twice (because it\\'s a part of `OB` and `OC`), we need adjust our answer. Other stuff is straightforward. \\nDo not hesitate asking questions.\\n\\n```javascript\\nfunction matrixBlockSum(mat, k) {\\n    const rows = mat.length, cols = mat[0].length;\\n    const sums = Array.from(mat, (row) => Array.from(row));\\n    \\n    // calc prefix sums\\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            sums[row][col] += \\n                (sums[row][col - 1] ?? 0) // left sum\\n                + (sums[row - 1]?.[col] ?? 0) // top sum\\n                - (sums[row - 1]?.[col - 1] ?? 0); // diagonal sum\\n        }\\n    }\\n    const answer = Array.from(mat, () => new Array(cols).fill(0));\\n    \\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            const top = row - k - 1,\\n                  left = col - k - 1,\\n                  right = Math.min(cols - 1, col + k),\\n                  bottom = Math.min(rows - 1, row + k);\\n            \\n            answer[row][col] = sums[bottom][right];\\n            if (top >= 0) {\\n                answer[row][col] -= sums[top][right];\\n            }\\n            if (left >= 0) {\\n                answer[row][col] -= sums[bottom][left];\\n            }\\n            if (top >= 0 && left >= 0) {\\n                answer[row][col] += sums[top][left];\\n            }\\n        }\\n    }\\n    \\n    return answer;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```javascript\\nfunction matrixBlockSum(mat, k) {\\n    const rows = mat.length, cols = mat[0].length;\\n    const sums = Array.from(mat, (row) => Array.from(row));\\n    \\n    // calc prefix sums\\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            sums[row][col] += \\n                (sums[row][col - 1] ?? 0) // left sum\\n                + (sums[row - 1]?.[col] ?? 0) // top sum\\n                - (sums[row - 1]?.[col - 1] ?? 0); // diagonal sum\\n        }\\n    }\\n    const answer = Array.from(mat, () => new Array(cols).fill(0));\\n    \\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            const top = row - k - 1,\\n                  left = col - k - 1,\\n                  right = Math.min(cols - 1, col + k),\\n                  bottom = Math.min(rows - 1, row + k);\\n            \\n            answer[row][col] = sums[bottom][right];\\n            if (top >= 0) {\\n                answer[row][col] -= sums[top][right];\\n            }\\n            if (left >= 0) {\\n                answer[row][col] -= sums[bottom][left];\\n            }\\n            if (top >= 0 && left >= 0) {\\n                answer[row][col] += sums[top][left];\\n            }\\n        }\\n    }\\n    \\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1648797,
                "title": "python3-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        new=mat[:][:]\\n        for i in range(m):\\n            for j in range(n):\\n                if i-1>=0: new[i][j]+=new[i-1][j]\\n                if j-1>=0: new[i][j]+=new[i][j-1]\\n                if i-1>=0 and j-1>=0: new[i][j]-=new[i-1][j-1]\\n                    \\n        res=[[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j]+=new[min(m-1,i+k)][min(n-1,j+k)]\\n                res[i][j]-=new[i-k-1][min(n-1,j+k)] if i-k>0 else 0\\n                res[i][j]-=new[min(m-1,i+k)][j-k-1] if j-k>0 else 0\\n                res[i][j]+=new[i-k-1][j-k-1] if i-k>0 and j-k>0 else 0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        new=mat[:][:]\\n        for i in range(m):\\n            for j in range(n):\\n                if i-1>=0: new[i][j]+=new[i-1][j]\\n                if j-1>=0: new[i][j]+=new[i][j-1]\\n                if i-1>=0 and j-1>=0: new[i][j]-=new[i-1][j-1]\\n                    \\n        res=[[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j]+=new[min(m-1,i+k)][min(n-1,j+k)]\\n                res[i][j]-=new[i-k-1][min(n-1,j+k)] if i-k>0 else 0\\n                res[i][j]-=new[min(m-1,i+k)][j-k-1] if j-k>0 else 0\\n                res[i][j]+=new[i-k-1][j-k-1] if i-k>0 and j-k>0 else 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611038,
                "title": "c-row-based-sliding-window-prefix-sum-solution-32-ms",
                "content": "![image](https://assets.leetcode.com/users/images/0bffdb50-741c-4b44-9002-c0da4e56adec_1638979800.6208327.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n));\\n        \\n        //cumulative sum\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]=mat[i][j-1]+mat[i][j];\\n            }\\n        }\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int l=i-k;l<=i+k;l++)\\n                {\\n                    if(l>=0 && l<m)\\n                    {\\n                        if(j+k<n)\\n                            answer[i][j]+=mat[l][j+k];\\n                        else\\n                            answer[i][j]+=mat[l][n-1];\\n                        \\n                        if(j-k>0)\\n                            answer[i][j]-=mat[l][j-k-1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n));\\n        \\n        //cumulative sum\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]=mat[i][j-1]+mat[i][j];\\n            }\\n        }\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int l=i-k;l<=i+k;l++)\\n                {\\n                    if(l>=0 && l<m)\\n                    {\\n                        if(j+k<n)\\n                            answer[i][j]+=mat[l][j+k];\\n                        else\\n                            answer[i][j]+=mat[l][n-1];\\n                        \\n                        if(j-k>0)\\n                            answer[i][j]-=mat[l][j-k-1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587446,
                "title": "c-o-m-n-solution-with-brief-command",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> res(m, vector<int>(n)), dp(m, vector<int>(n));\\n        dp = mat;\\n        for (int i = 0; i < m; ++i) { //build dp for row\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) { //build dp for column\\n                dp[i][j] += dp[i-1][j];\\n            }\\n        }\\n        for (int i = 0; i < m; ++i) { //need to check if left top index is zero or not\\n            int i_min = i - k < 0 ? 0 : i - k;\\n            int i_max = i + k >= m ? m - 1 : i + k;\\n            for (int j = 0; j < n; ++j) {\\n                int j_min = j - k < 0 ? 0 : j - k;\\n                int j_max = j + k >= n ? n - 1 : j + k;\\n                if (!i_min && !j_min) res[i][j] = dp[i_max][j_max];\\n                else if (!i_min) res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1];\\n                else if (!j_min) res[i][j] = dp[i_max][j_max] - dp[i_min-1][j_max];\\n                else res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1] - dp[i_min-1][j_max] + dp[i_min-1][j_min-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> res(m, vector<int>(n)), dp(m, vector<int>(n));\\n        dp = mat;\\n        for (int i = 0; i < m; ++i) { //build dp for row\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) { //build dp for column\\n                dp[i][j] += dp[i-1][j];\\n            }\\n        }\\n        for (int i = 0; i < m; ++i) { //need to check if left top index is zero or not\\n            int i_min = i - k < 0 ? 0 : i - k;\\n            int i_max = i + k >= m ? m - 1 : i + k;\\n            for (int j = 0; j < n; ++j) {\\n                int j_min = j - k < 0 ? 0 : j - k;\\n                int j_max = j + k >= n ? n - 1 : j + k;\\n                if (!i_min && !j_min) res[i][j] = dp[i_max][j_max];\\n                else if (!i_min) res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1];\\n                else if (!j_min) res[i][j] = dp[i_max][j_max] - dp[i_min-1][j_max];\\n                else res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1] - dp[i_min-1][j_max] + dp[i_min-1][j_min-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586168,
                "title": "c-dp-solution-100",
                "content": "Store the prefix Sum and then use prefix sum to find answer for each element.\\nTC-O(m*n)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(), m=mat[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0&&j>0)\\n                    dp[i][j]-=dp[i-1][j-1];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)\\n                    dp[i][j]+=dp[i][j-1];\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int row1=i-k-1;\\n                int row2=min(n-1,i+k);\\n                int col1=j-k-1;\\n                int col2=min(m-1, j+k);\\n                ans[i][j]=dp[row2][col2];\\n                if(row1>=0)\\n                    ans[i][j]-=dp[row1][col2];\\n                if(col1>=0)\\n                    ans[i][j]-=dp[row2][col1];\\n                if(row1>=0 && col1>=0)\\n                    ans[i][j]+=dp[row1][col1];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(), m=mat[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0&&j>0)\\n                    dp[i][j]-=dp[i-1][j-1];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)\\n                    dp[i][j]+=dp[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1551665,
                "title": "java-96-dp-solution-with-comments-o-m-n-runtime",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\t\\t\\tint m = mat.length;\\n\\t\\t\\tint n = mat[0].length;\\n\\t\\t\\tint[][] result = new int[m][n];\\n\\n\\t\\t\\t// the horizontal presum matrix where preSum[i][j] holds \\n\\t\\t\\t// the sum of mat[i][0] + ... + mat[i][j-1]\\n\\t\\t\\t// note that preSum[i][0] is 0 so that preSum[i][j2+1] - preSum[i][j1]\\n\\t\\t\\t// would give us the sum of mat[i][j1] + ... + mat[i][j2]\\n\\t\\t\\tint[][] preSumH = new int[m][n+1];\\n\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) {\\n\\t\\t\\t\\t\\tpreSumH[i][j] = preSumH[i][j-1] + mat[i][j-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// populate the first row of the result\\n\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\tfor(int x = 0; x <= k; x++) {\\n\\t\\t\\t\\t\\tresult[0][j] += preSumH[x][Math.min(n, j+k+1)] - preSumH[x][Math.max(0, j-k)];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// finally the recurrence relationship is that result[i][j] is simply result[i-1][j]\\n\\t\\t\\t// removing the sum of top row of result[i-1][j] block\\n\\t\\t\\t// and adding the sum of bottom row of result[i][j] block\\n\\t\\t\\tfor(int i = 1; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tresult[i][j] = result[i-1][j];\\n\\t\\t\\t\\t\\tif(i - 1 - k >= 0) {\\n\\t\\t\\t\\t\\t\\tresult[i][j] -= preSumH[i - 1 - k][Math.min(n, j+k+1)] - preSumH[i - 1 - k][Math.max(0, j-k)];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(i + k < m) {\\n\\t\\t\\t\\t\\t\\tresult[i][j] += preSumH[i+k][Math.min(n, j+k+1)] - preSumH[i+k][Math.max(0, j-k)];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\t\\t\\tint m = mat.length;\\n\\t\\t\\tint n = mat[0].length;\\n\\t\\t\\tint[][] result = new int[m][n];\\n\\n\\t\\t\\t// the horizontal presum matrix where preSum[i][j] holds \\n\\t\\t\\t// the sum of mat[i][0] + ... + mat[i][j-1]\\n\\t\\t\\t// note that preSum[i][0] is 0 so that preSum[i][j2+1] - preSum[i][j1]\\n\\t\\t\\t// would give us the sum of mat[i][j1] + ... + mat[i][j2]\\n\\t\\t\\tint[][] preSumH = new int[m][n+1];\\n\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) {\\n\\t\\t\\t\\t\\tpreSumH[i][j] = preSumH[i][j-1] + mat[i][j-1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1540546,
                "title": "clean-fast-java-solution-o-n-2-time-and-space-3ms",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] matSum = new int[mat.length + 1][mat[0].length + 1];\\n        int[][] retMat = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                sum += mat[i][j];\\n                matSum[i + 1][j + 1] = sum + matSum[i][j + 1]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                int rb = Math.min(j + k, mat[0].length - 1);\\n                int lb = Math.max(j - k, 0);\\n                int tb = Math.max(i - k, 0);\\n                int bb = Math.min(i + k, mat.length - 1);\\n                \\n                retMat[i][j] = matSum[bb + 1][rb + 1] - matSum[tb][rb + 1] - matSum[bb + 1][lb] + matSum[tb][lb];\\n            }\\n        }\\n        \\n        return retMat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] matSum = new int[mat.length + 1][mat[0].length + 1];\\n        int[][] retMat = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                sum += mat[i][j];\\n                matSum[i + 1][j + 1] = sum + matSum[i][j + 1]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                int rb = Math.min(j + k, mat[0].length - 1);\\n                int lb = Math.max(j - k, 0);\\n                int tb = Math.max(i - k, 0);\\n                int bb = Math.min(i + k, mat.length - 1);\\n                \\n                retMat[i][j] = matSum[bb + 1][rb + 1] - matSum[tb][rb + 1] - matSum[bb + 1][lb] + matSum[tb][lb];\\n            }\\n        }\\n        \\n        return retMat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539762,
                "title": "c-prefixsum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int>> rangeSum(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                rangeSum[i][j] = rangeSum[i - 1][j] + rangeSum[i][j - 1] \\n                    - rangeSum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = max(i - k, 0);\\n                int c1 = max(j - k, 0);\\n                int r2 = min(i + k + 1, m);\\n                int c2 = min(j + k + 1, n);\\n                res[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] -\\n                    rangeSum[r1][c2] + rangeSum[r1][c1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int>> rangeSum(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                rangeSum[i][j] = rangeSum[i - 1][j] + rangeSum[i][j - 1] \\n                    - rangeSum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = max(i - k, 0);\\n                int c1 = max(j - k, 0);\\n                int r2 = min(i + k + 1, m);\\n                int c2 = min(j + k + 1, n);\\n                res[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] -\\n                    rangeSum[r1][c2] + rangeSum[r1][c1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524791,
                "title": "python3-self-explanatory-prefix-sum-based-solution",
                "content": "## How to calculate block-sum with prefix-sum\\n1. First calculate a prefix sum matrix for next step\\'s use\\n\\t- define dp[i][j] to be prefix sum of rectangle from (0,0) to (i,j).\\n\\t- to calculate prefix sum, let\\'s say we want to calculate position **d** in the commented example matrix (**see diagram below**), we first add prefix sum of position **b** and **c**, then subtract prefix sum at **a** since it was calculated twice.\\n\\t- then we add matrix value at itself mat[**d**]\\n2. After we have the *prefix sum* matrix ready, we can calculate *block sum* matrix using *prefix sum* matrix.\\n3. Let\\'s say to calculate *block sum* at position **d** (say the position is **[i][j]**) with **k**. It is the prefix sum of:\\n\\t- +*lower right point* **[i+k][j+k]**\\n\\t-  -*upper right point* **[i-k-1][j+k]**\\n\\t-  -*lower left point* **[i+k][j-k-1]** \\n\\t-  +*upper left point* **[i-k-1][j-k-1]** (since the area was subtracted twice)\\n4. **Notice** here we want to avoid position falls outside the matrix valid region:\\n\\t- lower right point should be at max position at prefix sum matrix\\'s lower right corner.\\n\\t- upper right point should be set to zero only when row is less than 0, column should max at right border.\\n\\t- lower left point should be set to zero only when column is less than 0, row should max at bottom border.\\n\\nconsider this matrix for example:\\n```\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n\\t\\t[ ][c][d][ ]           \\n        [-][ ][ ][+]\\n\\t\\t\\n\\t\\tprefix sum: dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n\\t\\t\\n                            lower_right     upper_right      lower_left         upper_left\\n        block_sum[(i,j)] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n\\t\\t(with k)\\n```\\n\\n## Solution beat 83% runtime\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \"\"\"\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n        [ ][c][d][ ] dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n        [-][ ][ ][+]\\n                                lower_right     upper_right     lower_left        upper_left\\n        block_sum[(i,j), k] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n        \"\"\"\\n        # dp[i][j] is the prefix sum of all elemnt before i, j\\n        dp = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # init dp\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                # init dp left & upper border\\n                if i == 0 and j == 0:\\n                    dp[i][j] = mat[i][j]\\n                    continue\\n                elif i == 0:\\n                    dp[i][j] = mat[i][j] + dp[i][j-1]\\n                    continue\\n                elif j == 0:\\n                    dp[i][j] = mat[i][j] + dp[i-1][j]\\n                    continue\\n                    \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j]\\n        \\n        # for m in mat:\\n        #     print(m)\\n        # print(\"--------------\")\\n        # for i in dp:\\n        #     print(i)\\n            \\n        res = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # calculate block sum\\n        row_max = len(res) - 1\\n        col_max = len(res[0]) - 1\\n        for i in range(len(res)):\\n            for j in range(len(res[0])):\\n                lower_right = dp[min(i+k, row_max)][min(j+k, col_max)]\\n                upper_left = 0 if (i-k-1<0 or j-k-1<0) else dp[i-k-1][j-k-1]\\n                lower_left = 0 if (j-k-1<0) else dp[min(i+k, row_max)][j-k-1]\\n                upper_right = 0 if (i-k-1<0) else dp[i-k-1][min(j+k, col_max)]\\n                \\n                res[i][j] = lower_right - upper_right - lower_left + upper_left\\n                \\n        return res\\n            \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n\\t\\t[ ][c][d][ ]           \\n        [-][ ][ ][+]\\n\\t\\t\\n\\t\\tprefix sum: dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n\\t\\t\\n                            lower_right     upper_right      lower_left         upper_left\\n        block_sum[(i,j)] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n\\t\\t(with k)\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \"\"\"\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n        [ ][c][d][ ] dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n        [-][ ][ ][+]\\n                                lower_right     upper_right     lower_left        upper_left\\n        block_sum[(i,j), k] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n        \"\"\"\\n        # dp[i][j] is the prefix sum of all elemnt before i, j\\n        dp = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # init dp\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                # init dp left & upper border\\n                if i == 0 and j == 0:\\n                    dp[i][j] = mat[i][j]\\n                    continue\\n                elif i == 0:\\n                    dp[i][j] = mat[i][j] + dp[i][j-1]\\n                    continue\\n                elif j == 0:\\n                    dp[i][j] = mat[i][j] + dp[i-1][j]\\n                    continue\\n                    \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j]\\n        \\n        # for m in mat:\\n        #     print(m)\\n        # print(\"--------------\")\\n        # for i in dp:\\n        #     print(i)\\n            \\n        res = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # calculate block sum\\n        row_max = len(res) - 1\\n        col_max = len(res[0]) - 1\\n        for i in range(len(res)):\\n            for j in range(len(res[0])):\\n                lower_right = dp[min(i+k, row_max)][min(j+k, col_max)]\\n                upper_left = 0 if (i-k-1<0 or j-k-1<0) else dp[i-k-1][j-k-1]\\n                lower_left = 0 if (j-k-1<0) else dp[min(i+k, row_max)][j-k-1]\\n                upper_right = 0 if (i-k-1<0) else dp[i-k-1][min(j+k, col_max)]\\n                \\n                res[i][j] = lower_right - upper_right - lower_left + upper_left\\n                \\n        return res\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511154,
                "title": "java-simple-idea-but-trivial-not-bad-performance",
                "content": "idea is straight forward.\\n\\nimaging there is a box (center is i, j)  in `mat`, what you need is get sum of the box and put in `ans` with same i, j\\n\\n1. calculate first one\\n2. for first row, calculate from left to right (image move the box left to right), baseed on the left one, decrease if there is a colum out of the box, increase if there is a colum included.\\n3. for the rest, calculate based on upper one. decrease if there is a row out of the box, increase if there is a row included in\\n\\nNode: trivial but works and straight forword\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        \\n        int [][] ans = new int [row][col];\\n        \\n        // init fist one\\n        for (int i = 0; i < row && i <= k; i++) {\\n            for (int j = 0; j < col && j <= k; j++) {\\n                ans[0][0] += mat[i][j];\\n            }\\n        }\\n        \\n\\n        \\n        for (int i = 0; i < row; i++) {\\n            int rTop = i - k;\\n            int rBot = i + k;\\n            \\n            for (int j = 0; j < col; j++) {\\n                // skip first one\\n                if (i==0 && j==0) continue;\\n                \\n                // get range\\n                int cLeft = j - k;\\n                int cRight = j + k;\\n                \\n                if (i == 0) {\\n                    // first line, left to right\\n                    ans[i][j] = ans[i][j - 1];\\n                    if (rTop <= 0) rTop = 0;\\n                    if (rBot >= row) rBot = row - 1;\\n\\t\\t\\t\\t\\t\\n                    if (cLeft > 0) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] -= mat[q][cLeft - 1];\\n                        }\\n                    }\\n                    if (cRight <= col - 1) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] += mat[q][cRight];\\n                        }\\n                    }\\n                }else {\\n                    // not firest line\\n                    ans[i][j] = ans[i - 1][j];\\n                    if (cLeft < 0) cLeft = 0;\\n                    if (cRight >= col) cRight = col - 1;\\n\\t\\t\\t\\t\\t\\n                    if (rTop > 0) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] -= mat[rTop - 1][q]; \\n                        }\\n                    }\\n                    if (rBot <= row - 1) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] += mat[rBot][q];\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        \\n        int [][] ans = new int [row][col];\\n        \\n        // init fist one\\n        for (int i = 0; i < row && i <= k; i++) {\\n            for (int j = 0; j < col && j <= k; j++) {\\n                ans[0][0] += mat[i][j];\\n            }\\n        }\\n        \\n\\n        \\n        for (int i = 0; i < row; i++) {\\n            int rTop = i - k;\\n            int rBot = i + k;\\n            \\n            for (int j = 0; j < col; j++) {\\n                // skip first one\\n                if (i==0 && j==0) continue;\\n                \\n                // get range\\n                int cLeft = j - k;\\n                int cRight = j + k;\\n                \\n                if (i == 0) {\\n                    // first line, left to right\\n                    ans[i][j] = ans[i][j - 1];\\n                    if (rTop <= 0) rTop = 0;\\n                    if (rBot >= row) rBot = row - 1;\\n\\t\\t\\t\\t\\t\\n                    if (cLeft > 0) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] -= mat[q][cLeft - 1];\\n                        }\\n                    }\\n                    if (cRight <= col - 1) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] += mat[q][cRight];\\n                        }\\n                    }\\n                }else {\\n                    // not firest line\\n                    ans[i][j] = ans[i - 1][j];\\n                    if (cLeft < 0) cLeft = 0;\\n                    if (cRight >= col) cRight = col - 1;\\n\\t\\t\\t\\t\\t\\n                    if (rTop > 0) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] -= mat[rTop - 1][q]; \\n                        }\\n                    }\\n                    if (rBot <= row - 1) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] += mat[rBot][q];\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498803,
                "title": "python-dynamic-programming-method-easy-to-read",
                "content": "Hi,\\n\\nThis method is inspired by the hints provided with the problem. If you have any question feel free to ask.\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \"\"\"\\n        dp[i][j] is the sum of mat[r][c] for 0 <= r <= i and 0 <= c <= j\\n        \"\"\"\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        dp[0][0] = mat[0][0]\\n        \\n        # First column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i - 1][0] + mat[i][0]\\n            \\n        # First row\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j - 1] + mat[0][j]\\n          \\n        # Inside\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] =  mat[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\\n        \\n        \"\"\"\\n        k = 1, Calcul of answer[2][2]\\n        \\n        1 2 3                 1 2 3   1 _ _   1 2 3   1 _ _\\n        4 5 6  -->  5 6  -->  4 5 6 - 4 _ _ - _ _ _ + _ _ _  -->  28\\n        7 8 9       8 9       7 8 9   7 _ _   _ _ _   _ _ _\\n                           bottom-right     top_right\\n                                    bottom-left      top_left\\n        \"\"\"\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            top, bottom = i - k - 1, min(m - 1, i + k)\\n            for j in range(n):\\n                left, right = j - k - 1, min(n - 1, j + k)\\n                top_left = dp[top][left] if top >= 0 and left >= 0 else 0\\n                top_right = dp[top][right] if top >= 0 else 0\\n                bottom_left = dp[bottom][left] if left >= 0 else 0\\n                bottom_right = dp[bottom][right]\\n                \\n                answer[i][j] = bottom_right - bottom_left - top_right + top_left \\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \"\"\"\\n        dp[i][j] is the sum of mat[r][c] for 0 <= r <= i and 0 <= c <= j\\n        \"\"\"\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        dp[0][0] = mat[0][0]\\n        \\n        # First column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i - 1][0] + mat[i][0]\\n            \\n        # First row\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j - 1] + mat[0][j]\\n          \\n        # Inside\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] =  mat[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\\n        \\n        \"\"\"\\n        k = 1, Calcul of answer[2][2]\\n        \\n        1 2 3                 1 2 3   1 _ _   1 2 3   1 _ _\\n        4 5 6  -->  5 6  -->  4 5 6 - 4 _ _ - _ _ _ + _ _ _  -->  28\\n        7 8 9       8 9       7 8 9   7 _ _   _ _ _   _ _ _\\n                           bottom-right     top_right\\n                                    bottom-left      top_left\\n        \"\"\"\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            top, bottom = i - k - 1, min(m - 1, i + k)\\n            for j in range(n):\\n                left, right = j - k - 1, min(n - 1, j + k)\\n                top_left = dp[top][left] if top >= 0 and left >= 0 else 0\\n                top_right = dp[top][right] if top >= 0 else 0\\n                bottom_left = dp[bottom][left] if left >= 0 else 0\\n                bottom_right = dp[bottom][right]\\n                \\n                answer[i][j] = bottom_right - bottom_left - top_right + top_left \\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394523,
                "title": "c-prefix-sum-easy-to-understand-solution",
                "content": "**Runtime: 4 ms, faster than 99.10% of C++ online submissions for Matrix Block Sum.\\nMemory Usage: 9.2 MB, less than 91.97% of C++ online submissions for Matrix Block Sum.**\\n```\\n\\nclass Solution {\\npublic:\\n    int sizeX,sizeY;\\n\\t\\n    int getA(int i,int j,vector<vector<int>>& sum){\\n        if(i<0||j<0){return 0;}\\n        if(i >= sizeX ){i = sizeX-1;}\\n        if(j >= sizeY ){j = sizeY-1;}\\n        return sum[i][j];\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n                        \\n        for(int i=0;i<sizeX;i++){\\n            for(int j=1;j<sizeY;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=0;i<sizeY;i++){\\n            for(int j=1;j<sizeX;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n\\n        vector<vector<int>> ans(sizeX,vector<int>(sizeY,0));\\n        for(int i=0;i<sizeX;i++){\\n            for(int j=0;j<sizeY;j++){\\n                ans[i][j] = getA(i+k,j+k,mat) - getA(i-k-1,j+k,mat) - getA(i+k,j-k-1,mat) + getA(i-k-1,j-k-1,mat);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int sizeX,sizeY;\\n\\t\\n    int getA(int i,int j,vector<vector<int>>& sum){\\n        if(i<0||j<0){return 0;}\\n        if(i >= sizeX ){i = sizeX-1;}\\n        if(j >= sizeY ){j = sizeY-1;}\\n        return sum[i][j];\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n                        \\n        for(int i=0;i<sizeX;i++){\\n            for(int j=1;j<sizeY;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=0;i<sizeY;i++){\\n            for(int j=1;j<sizeX;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n\\n        vector<vector<int>> ans(sizeX,vector<int>(sizeY,0));\\n        for(int i=0;i<sizeX;i++){\\n            for(int j=0;j<sizeY;j++){\\n                ans[i][j] = getA(i+k,j+k,mat) - getA(i-k-1,j+k,mat) - getA(i+k,j-k-1,mat) + getA(i-k-1,j-k-1,mat);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380721,
                "title": "clean-java-code-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i =0;i<mat.length;i++){\\n            for(int j =0;j<mat[0].length;j++){\\n                if(i==0&&j==0) continue;\\n                else if(i==0){\\n                    mat[i][j]+=mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }else{\\n                    mat[i][j]+=(mat[i][j-1]+mat[i-1][j]-mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int ans[][] = new int[mat.length][mat[0].length];\\n        for(int i =0;i<ans.length;i++){\\n            for(int j =0;j<ans[0].length;j++){\\n                int first_corner_i = Math.max(0,i-k);\\n                int first_corner_j = Math.max(0,j-k);\\n                int second_corner_i = Math.min(mat.length-1,i+k);\\n                int second_corner_j = Math.min(mat[0].length-1,j+k);\\n                \\n                int sum = mat[second_corner_i][second_corner_j];\\n                \\n                if(first_corner_i-1>=0){\\n                    sum-=mat[first_corner_i-1][second_corner_j];\\n                }\\n                \\n                if(first_corner_j-1>=0){\\n                    sum-=mat[second_corner_i][first_corner_j-1];\\n                }\\n                \\n                if(first_corner_i-1>=0&&first_corner_j-1>=0){\\n                    sum+=mat[first_corner_i-1][first_corner_j-1];\\n                }\\n                \\n                ans[i][j] = sum;\\n             }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i =0;i<mat.length;i++){\\n            for(int j =0;j<mat[0].length;j++){\\n                if(i==0&&j==0) continue;\\n                else if(i==0){\\n                    mat[i][j]+=mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }else{\\n                    mat[i][j]+=(mat[i][j-1]+mat[i-1][j]-mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int ans[][] = new int[mat.length][mat[0].length];\\n        for(int i =0;i<ans.length;i++){\\n            for(int j =0;j<ans[0].length;j++){\\n                int first_corner_i = Math.max(0,i-k);\\n                int first_corner_j = Math.max(0,j-k);\\n                int second_corner_i = Math.min(mat.length-1,i+k);\\n                int second_corner_j = Math.min(mat[0].length-1,j+k);\\n                \\n                int sum = mat[second_corner_i][second_corner_j];\\n                \\n                if(first_corner_i-1>=0){\\n                    sum-=mat[first_corner_i-1][second_corner_j];\\n                }\\n                \\n                if(first_corner_j-1>=0){\\n                    sum-=mat[second_corner_i][first_corner_j-1];\\n                }\\n                \\n                if(first_corner_i-1>=0&&first_corner_j-1>=0){\\n                    sum+=mat[first_corner_i-1][first_corner_j-1];\\n                }\\n                \\n                ans[i][j] = sum;\\n             }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327800,
                "title": "python-3-yummy-and-easy-to-follow-brute-force-o-k-2-m-n",
                "content": "```class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        copy = [[0]*len(mat[0]) for _ in mat]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                total = 0\\n                # quadratic wrt k\\n                for r in range(max(0,i-k), min(i+k+1, len(mat))):\\n                    for c in range(max(0,j-k), min(j+k+1,len(mat[0]))):\\n                        total += mat[r][c]\\n                copy[i][j] = total\\n        return copy\\n```\\n\\nEnjoy :\\')",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        copy = [[0]*len(mat[0]) for _ in mat]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                total = 0\\n                # quadratic wrt k\\n                for r in range(max(0,i-k), min(i+k+1, len(mat))):\\n                    for c in range(max(0,j-k), min(j+k+1,len(mat[0]))):\\n                        total += mat[r][c]\\n                copy[i][j] = total\\n        return copy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305882,
                "title": "c-clean-code",
                "content": "\\n```\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(); \\n        vector<vector<int>> sum = mat, res = mat;\\n        for(int j = 1; j < n; ++j) {\\n            for(int i = 0; i < m; ++i) \\n                sum[i][j] += sum[i][j - 1];\\n        }\\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) \\n                sum[i][j] += sum[i - 1][j];\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int max_r = i + k >= m ? m - 1 : i + k;\\n                int max_c = j + k >= n ? n - 1 : j + k;\\n                res[i][j] = sum[max_r][max_c];\\n                if(j - k > 0) res[i][j] -= sum[max_r][j - k - 1];\\n                if(i - k > 0) res[i][j] -= sum[i - k - 1][max_c];\\n                if((i - k > 0) && (j - k > 0)) res[i][j] += sum[i - k - 1][j - k - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(); \\n        vector<vector<int>> sum = mat, res = mat;\\n        for(int j = 1; j < n; ++j) {\\n            for(int i = 0; i < m; ++i) \\n                sum[i][j] += sum[i][j - 1];\\n        }\\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) \\n                sum[i][j] += sum[i - 1][j];\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int max_r = i + k >= m ? m - 1 : i + k;\\n                int max_c = j + k >= n ? n - 1 : j + k;\\n                res[i][j] = sum[max_r][max_c];\\n                if(j - k > 0) res[i][j] -= sum[max_r][j - k - 1];\\n                if(i - k > 0) res[i][j] -= sum[i - k - 1][max_c];\\n                if((i - k > 0) && (j - k > 0)) res[i][j] += sum[i - k - 1][j - k - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269317,
                "title": "c-simple-prefix-sum-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        vector<vector<int>>row,col;\\n        \\n        \\n        //prefix sum row-wise\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n               sum+=matrix[i][j];\\n               v.push_back(sum);\\n            }\\n            row.push_back(v);\\n        }\\n\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 int start=max(i-k,0);//row start pos\\n                 int end=min(i+k+1,n);//row end pos\\n                \\n                 int start1=max(j-k,0);//col start pos\\n                 int end1=min(j+k,m-1);//col end pos\\n                \\n                \\n                \\n                      int t=0;\\n                for(int f=start;f<end;f++)\\n                {\\n              \\n                    if(start1-1>=0)\\n                    {\\n                        t-=row[f][start1-1];\\n                    }\\n                    \\n                    t+=row[f][end1];\\n                }\\n                ans[i][j]=t;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6f30c13d-3756-472d-9f6b-d1dfe226f22d_1623576443.8117292.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        vector<vector<int>>row,col;\\n        \\n        \\n        //prefix sum row-wise\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n               sum+=matrix[i][j];\\n               v.push_back(sum);\\n            }\\n            row.push_back(v);\\n        }\\n\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 int start=max(i-k,0);//row start pos\\n                 int end=min(i+k+1,n);//row end pos\\n                \\n                 int start1=max(j-k,0);//col start pos\\n                 int end1=min(j+k,m-1);//col end pos\\n                \\n                \\n                \\n                      int t=0;\\n                for(int f=start;f<end;f++)\\n                {\\n              \\n                    if(start1-1>=0)\\n                    {\\n                        t-=row[f][start1-1];\\n                    }\\n                    \\n                    t+=row[f][end1];\\n                }\\n                ans[i][j]=t;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266094,
                "title": "1314-sum-of-rect-i-k-j-k-i-k-j-k-se-ne-sw-nw",
                "content": "---\\n\\n- Sometimes it becomes an obsession :D\\n\\n---\\n\\n**Algo**\\n\\n- We have a matrix  `m rows  x  n columns`\\n- We need sum of all elements in a rectangle, that is part of the matrix\\n- Rectangle is from   `[i-k, j-k]`  point to   `[i+k][j+k]`\\n- Since we need to do this for all i & j, we need a better plan to be fast\\n- Assume somehow we did sums of all below rectangles:\\n  - [0,0, 0,0],   [0,0, 0,1],   [0,0, 0,2] <------------------ summing from left gets us this\\n  - [0,0, 1,0],   **[0,0, 1,1],   [0,0, 1,2]**\\n  - [0,0, 2,0],   **[0,0, 2,1],   [0,0, 2,2]**\\n  - ---- above can be got by adding curr + above element\\n- Now to get sum of rectangle **[0,0, 22]** is   [0,0, 2,2]   -  [0,0, 2,0] - [0,0, 0,2]   + [0,0, 0,0] (because this got remove twice)\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Step1 - Add/ Subtract prefix sums**\\n\\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n\\n        for (let i = 0; i < M.length; i++) {\\n            let prefixSum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                prefixSum += M[i][j];\\n                memo[i][j] = prefixSum;\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let sum = 0;\\n                for (let k = i - K; k <= i + K; k++) {\\n                    if (k >= 0 && k < m) {\\n                        sum +=\\n                                              memo[k][Math.min(j + K, n - 1)] -\\n                            (j - K - 1 >= 0 ? memo[k][j - K - 1             ] : 0);\\n                    }\\n                }\\n                M[i][j] = sum;\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/890bda7b-77d5-44ca-b405-f4517852bd13_1623468682.631645.png)\\n\\n---\\n\\n**Step2 - Add/ Subtract Matrix sums**\\n\\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i][j] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i][j] += memo[i - 1][j];\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let iminusK = i - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = j - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m - 1); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n - 1); // take as much as possible on right\\n\\n                // prettier-ignore\\n                {\\n                    let SE =                                memo[iplusK] [jplusK]     ;\\n                    let NE = iminusK >= 0                 ? memo[iminusK][jplusK]  : 0;\\n                    let SW =                 jminusK >= 0 ? memo[iplusK][jminusK]  : 0;\\n                    let NW = iminusK >= 0 && jminusK >= 0 ? memo[iminusK][jminusK] : 0;\\n                    M[i][j] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/826b2358-055c-41ed-8ca4-8c79fb24280a_1623468346.1044695.png)\\n\\n---\\n\\n**Step3 - Add/ Subtract Matrix sums - optimized memo, extra left column & top row to reduce conditions**\\n\\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i + 1][j + 1] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i + 1][j + 1] += memo[i][j + 1];\\n            }\\n        }\\n\\n        for (let i = 1; i <= m; i++) {\\n            for (let j = 1; j <= n; j++) {\\n                let iminusK = Math.max(i - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = Math.max(j - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n); // take as much as possible on right\\n\\n                {\\n                    let SE = memo[iplusK][jplusK];\\n                    let NE = memo[iminusK][jplusK];\\n                    let SW = memo[iplusK][jminusK];\\n                    let NW = memo[iminusK][jminusK];\\n\\n                    M[i - 1][j - 1] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e9fc662a-4817-4d27-9d70-281395fe8f8c_1623468290.707332.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n\\n        for (let i = 0; i < M.length; i++) {\\n            let prefixSum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                prefixSum += M[i][j];\\n                memo[i][j] = prefixSum;\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let sum = 0;\\n                for (let k = i - K; k <= i + K; k++) {\\n                    if (k >= 0 && k < m) {\\n                        sum +=\\n                                              memo[k][Math.min(j + K, n - 1)] -\\n                            (j - K - 1 >= 0 ? memo[k][j - K - 1             ] : 0);\\n                    }\\n                }\\n                M[i][j] = sum;\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i][j] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i][j] += memo[i - 1][j];\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let iminusK = i - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = j - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m - 1); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n - 1); // take as much as possible on right\\n\\n                // prettier-ignore\\n                {\\n                    let SE =                                memo[iplusK] [jplusK]     ;\\n                    let NE = iminusK >= 0                 ? memo[iminusK][jplusK]  : 0;\\n                    let SW =                 jminusK >= 0 ? memo[iplusK][jminusK]  : 0;\\n                    let NW = iminusK >= 0 && jminusK >= 0 ? memo[iminusK][jminusK] : 0;\\n                    M[i][j] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i + 1][j + 1] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i + 1][j + 1] += memo[i][j + 1];\\n            }\\n        }\\n\\n        for (let i = 1; i <= m; i++) {\\n            for (let j = 1; j <= n; j++) {\\n                let iminusK = Math.max(i - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = Math.max(j - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n); // take as much as possible on right\\n\\n                {\\n                    let SE = memo[iplusK][jplusK];\\n                    let NE = memo[iminusK][jplusK];\\n                    let SW = memo[iplusK][jminusK];\\n                    let NW = memo[iminusK][jminusK];\\n\\n                    M[i - 1][j - 1] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250670,
                "title": "easy-solution-using-prefix-sum-dp",
                "content": "```\\nclass Solution {\\n\\n    int query(vector<vector<int>>& dp, int sr , int sc , int er , int ec)\\n    {\\n        if(sr == 0 && sc != 0)\\n            return dp[er][ec] - dp[er][sc-1];\\n        if(sr != 0 && sc == 0)\\n            return dp[er][ec] - dp[sr-1][ec];\\n        if(sr == 0 && sc == 0)\\n            return dp[er][ec];\\n        else\\n            return dp[er][ec] - dp[er][sc-1] - dp[sr-1][ec] + dp[sr-1][sc-1];\\n           \\n    }\\n    \\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        vector<vector<int>>dp(n , vector<int>(m , 0))  , fin(n , vector<int>(m , 0));\\n        \\n        dp[0][0] = mat[0][0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0] = dp[i-1][0] + mat[i][0];\\n        }\\n        for(int j=1;j<m;j++)\\n        {\\n            dp[0][j] = dp[0][j-1] + mat[0][j];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] + mat[i][j] - dp[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int sr , sc , er , ec;\\n                sr = max(0 , i-k);\\n                sc = max(0 , j-k);\\n                er = min(i+k , n-1);\\n                ec = min(j+k , m-1);\\n                fin[i][j] = query(dp , sr , sc , er , ec);\\n            }\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int query(vector<vector<int>>& dp, int sr , int sc , int er , int ec)\\n    {\\n        if(sr == 0 && sc != 0)\\n            return dp[er][ec] - dp[er][sc-1];\\n        if(sr != 0 && sc == 0)\\n            return dp[er][ec] - dp[sr-1][ec];\\n        if(sr == 0 && sc == 0)\\n            return dp[er][ec];\\n        else\\n            return dp[er][ec] - dp[er][sc-1] - dp[sr-1][ec] + dp[sr-1][sc-1];\\n           \\n    }\\n    \\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        vector<vector<int>>dp(n , vector<int>(m , 0))  , fin(n , vector<int>(m , 0));\\n        \\n        dp[0][0] = mat[0][0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0] = dp[i-1][0] + mat[i][0];\\n        }\\n        for(int j=1;j<m;j++)\\n        {\\n            dp[0][j] = dp[0][j-1] + mat[0][j];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] + mat[i][j] - dp[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int sr , sc , er , ec;\\n                sr = max(0 , i-k);\\n                sc = max(0 , j-k);\\n                er = min(i+k , n-1);\\n                ec = min(j+k , m-1);\\n                fin[i][j] = query(dp , sr , sc , er , ec);\\n            }\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242482,
                "title": "java-o-n-2-with-explanation",
                "content": "Basic idea is to calcualte the cumulative sum of each cell (i,j). Cumulative cell is sum of all cells in rectangular block -> (0, 0) to (i, j)\\nFor a given cell, cumulative cell (i, j) can be formed recursively as\\ncsum(i, j) = val(i, j) + csum(i - 1, j) + csum (i, j - 1) - csum(i - 1, j - 1);\\nWhy we are subtracting csum(i - 1, j - 1), reason is it is being added twice as part of csum(i - 1, j) and csum (i, j - 1)\\n\\nSay we performed above and created a 2d array of cumulative sums dp[][].\\n\\ndp[i][j] gives cumulative sum from (0,0) to (i, j)\\n\\nOnce we have cumulative sums, for each cell again we follow the same procedure. For given cell (i, j), all four corners at limit k are\\ntop left (i - k, j - k), top right (i - k, j + k), bottom left (i + k, j - k), bottom right (i + k, j + k)\\n\\nFor cell (i,j) answer is cumulative sum of rectangle (i - k, j - k) to (i + k, j + k). We can calculate the sum of this rectangle using the dp array we created. \\n\\nAnswer is cumulative sum of the rectangle (0, 0) to bottom right (i + k, j + k) - csum from (0,0) to top right (i - k - 1, j + k) - csum from (0,0) to bottom left (i + k, j - k - 1) + csum from (0,0) to (i - k - 1, j - k - 1).\\n\\nAgain why are we add csum from (0,0) to (i - k - 1, j - k - 1), cause it is removed twice once in csum from (0,0) to top right (i - k - 1, j + k) and then in csum from (0,0) to bottom left (i + k, j - k - 1)\\n\\n```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tint m = mat.length, n = mat[0].length;\\n\\tint[][] dp = new int[m][n];\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0;j < n; j++){\\n\\t\\t\\tif(i > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i - 1][j];\\n\\t\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\t\\tdp[i][j] -= dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i][j - 1];\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] += mat[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tint lri = Math.min(m - 1, i + k), lrj = Math.min(n - 1, j + k);\\n\\t\\t\\tint llj = Math.max(0, j - k);\\n\\t\\t\\tint uli = Math.max(0, i - k);\\n\\t\\t\\tmat[i][j] = dp[lri][lrj];\\n\\t\\t\\tif(llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[lri][llj - 1];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[uli - 1][lrj];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0 && llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] += dp[uli - 1][llj - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mat;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tint m = mat.length, n = mat[0].length;\\n\\tint[][] dp = new int[m][n];\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0;j < n; j++){\\n\\t\\t\\tif(i > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i - 1][j];\\n\\t\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\t\\tdp[i][j] -= dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i][j - 1];\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] += mat[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tint lri = Math.min(m - 1, i + k), lrj = Math.min(n - 1, j + k);\\n\\t\\t\\tint llj = Math.max(0, j - k);\\n\\t\\t\\tint uli = Math.max(0, i - k);\\n\\t\\t\\tmat[i][j] = dp[lri][lrj];\\n\\t\\t\\tif(llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[lri][llj - 1];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[uli - 1][lrj];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0 && llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] += dp[uli - 1][llj - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mat;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233629,
                "title": "python-with-prefix-sum-and-dp",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row-1][col] + mat[row][col]\\n                    \\n        for row in range(m):\\n            for col in range(n):\\n                if col == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row][col-1] + mat[row][col]\\n    \\n        ans = [[0] * n for _ in range(m)]\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                n_row = min(row + k, m - 1)\\n                n_col = min(col + k, n - 1)\\n                right_top_row = row - k - 1\\n                right_top_col = n_col\\n                \\n                left_bot_row = n_row\\n                left_bot_col = col - k - 1\\n                \\n                left_top_row = row - k - 1\\n                left_top_col = col - k - 1\\n                \\n                target_val = mat[n_row][n_col]\\n                right_top = 0\\n                left_bot = 0\\n                left_top = 0\\n                \\n                if right_top_row >= 0:\\n                    right_top = mat[right_top_row][right_top_col]\\n                    \\n                if left_bot_col >= 0:\\n                    left_bot = mat[left_bot_row][left_bot_col]\\n                    \\n                if left_top_row >= 0 and left_top_col >= 0:\\n                    left_top = mat[left_top_row][left_top_col]\\n                    \\n                ans[row][col] = target_val - right_top - left_bot + left_top\\n        return ans\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row-1][col] + mat[row][col]\\n                    \\n        for row in range(m):\\n            for col in range(n):\\n                if col == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row][col-1] + mat[row][col]\\n    \\n        ans = [[0] * n for _ in range(m)]\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                n_row = min(row + k, m - 1)\\n                n_col = min(col + k, n - 1)\\n                right_top_row = row - k - 1\\n                right_top_col = n_col\\n                \\n                left_bot_row = n_row\\n                left_bot_col = col - k - 1\\n                \\n                left_top_row = row - k - 1\\n                left_top_col = col - k - 1\\n                \\n                target_val = mat[n_row][n_col]\\n                right_top = 0\\n                left_bot = 0\\n                left_top = 0\\n                \\n                if right_top_row >= 0:\\n                    right_top = mat[right_top_row][right_top_col]\\n                    \\n                if left_bot_col >= 0:\\n                    left_bot = mat[left_bot_row][left_bot_col]\\n                    \\n                if left_top_row >= 0 and left_top_col >= 0:\\n                    left_top = mat[left_top_row][left_top_col]\\n                    \\n                ans[row][col] = target_val - right_top - left_bot + left_top\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1228090,
                "title": "concise-solution-c-98-faster-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int left = (j==0) ? 0 : mat[i][j-1]; //top rectangle\\n                int top = (i==0) ? 0 : mat[i-1][j]; //left rectangle\\n                int diag = (i==0 || j==0) ? 0 : mat[i-1][j-1]; // top-left square\\n                mat[i][j] += left + top - diag;\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int i1 = max(i-k,0) , j1 = max(j-k,0);    // top indices\\n                int i2 = min(i+k,n-1) , j2 = min(j+k,m-1);  // bottom indices\\n                \\n                int left = (j1==0) ? 0 : mat[i2][j1-1];\\n                int top = (i1==0) ? 0 : mat[i1-1][j2];\\n                int diag = (i1==0 || j1==0) ? 0 : mat[i1-1][j1-1];\\n                ans[i][j] = mat[i2][j2] - top - left + diag;    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int left = (j==0) ? 0 : mat[i][j-1]; //top rectangle\\n                int top = (i==0) ? 0 : mat[i-1][j]; //left rectangle\\n                int diag = (i==0 || j==0) ? 0 : mat[i-1][j-1]; // top-left square\\n                mat[i][j] += left + top - diag;\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int i1 = max(i-k,0) , j1 = max(j-k,0);    // top indices\\n                int i2 = min(i+k,n-1) , j2 = min(j+k,m-1);  // bottom indices\\n                \\n                int left = (j1==0) ? 0 : mat[i2][j1-1];\\n                int top = (i1==0) ? 0 : mat[i1-1][j2];\\n                int diag = (i1==0 || j1==0) ? 0 : mat[i1-1][j1-1];\\n                ans[i][j] = mat[i2][j2] - top - left + diag;    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189786,
                "title": "c-easy-understanding",
                "content": "```\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int rows=mat.size(),col=mat[0].size();\\n        vector<vector<int>> ans(rows+1,vector<int>(col+1,0));\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n                ans[i][j]=mat[i-1][j-1]+ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n            {\\n                int minRow =i-k-1>0?i-k-1:0;\\n                int maxRow=i+k<rows?i+k:rows;\\n                int minCol= j-k-1>0?j-k-1:0;\\n                int maxCol=j+k<col?j+k:col;\\n                 mat[i-1][j-1]=ans[minRow][minCol]+ans[maxRow][maxCol]-ans[minRow][maxCol]-ans[maxRow][minCol];\\n            }\\n        return mat;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int rows=mat.size(),col=mat[0].size();\\n        vector<vector<int>> ans(rows+1,vector<int>(col+1,0));\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n                ans[i][j]=mat[i-1][j-1]+ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n            {\\n                int minRow =i-k-1>0?i-k-1:0;\\n                int maxRow=i+k<rows?i+k:rows;\\n                int minCol= j-k-1>0?j-k-1:0;\\n                int maxCol=j+k<col?j+k:col;\\n                 mat[i-1][j-1]=ans[minRow][minCol]+ans[maxRow][maxCol]-ans[minRow][maxCol]-ans[maxRow][minCol];\\n            }\\n        return mat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166550,
                "title": "c-short-prefix-sum",
                "content": "Area of shaded region = Area till region 1 - Area 2 - Area 3 + Area 4\\n[Note : region 2 and 3 are squares including region 4]\\n![image](https://assets.leetcode.com/users/images/280e9e1d-ef56-442f-b2f1-695e65e3066b_1618842951.4908242.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        vector<vector<int>> arr = mat;\\n        \\n        for(int i=0; i<r-1; i++)\\n            arr[i+1][0] += arr[i][0]; \\n        \\n        for(int j=0; j<c-1; j++)\\n            arr[0][j+1] += arr[0][j];\\n        \\n        for(int i=1; i<r; i++)\\n            for(int j=1; j<c; j++)\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] + arr[i][j] - arr[i-1][j-1];\\n        \\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++){\\n                int lr = min(i+k, r-1), lc = min(j+k, c-1), ur=max(0, i-k-1), uc = max(0, j-k-1);\\n                res[i][j] = arr[lr][lc] - ((i-k-1>=0) ? arr[i-k-1][lc]:0) - ((j-k-1>=0) ? arr[lr][j-k-1]:0) + ((i-k-1>=0 && j-k-1>=0) ? arr[i-k-1][j-k-1]:0);\\n            }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        vector<vector<int>> arr = mat;\\n        \\n        for(int i=0; i<r-1; i++)\\n            arr[i+1][0] += arr[i][0]; \\n        \\n        for(int j=0; j<c-1; j++)\\n            arr[0][j+1] += arr[0][j];\\n        \\n        for(int i=1; i<r; i++)\\n            for(int j=1; j<c; j++)\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] + arr[i][j] - arr[i-1][j-1];\\n        \\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++){\\n                int lr = min(i+k, r-1), lc = min(j+k, c-1), ur=max(0, i-k-1), uc = max(0, j-k-1);\\n                res[i][j] = arr[lr][lc] - ((i-k-1>=0) ? arr[i-k-1][lc]:0) - ((j-k-1>=0) ? arr[lr][j-k-1]:0) + ((i-k-1>=0 && j-k-1>=0) ? arr[i-k-1][j-k-1]:0);\\n            }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157753,
                "title": "python-matrix-row-col-prefix-solution",
                "content": "class Solution:\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        def prefix_sum(mat):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    if not temp:\\n\\n                        temp.append(mat[i][j])\\n\\n                    else:\\n                        temp.append(mat[i][j] + temp[-1])\\n\\n                ans.append(temp)\\n\\n            return ans\\n\\n\\n        def prefix_col(mat):\\n\\n            for i in range(1,len(mat)):\\n\\n                for j in  range(len(mat[0])):\\n\\n                    mat[i][j] += mat[i-1][j]\\n\\n            return mat\\n\\n        def find_sum(x2,y2,x1,y1,mat):\\n\\n            x2,y2 = min(len(mat)-1,x2),min(len(mat[0])-1,y2)\\n            x1,y1 = max(x1,0),max(y1,0)\\n\\n            sm = mat[x2][y2]\\n\\n            if x1-1 >= 0:\\n                sm -= mat[x1-1][y2]\\n\\n            if y1-1 >= 0:\\n                sm -= mat[x2][y1-1]\\n\\n            if x1-1 >=0 and y1-1 >=0:\\n                sm += mat[x1-1][y1-1]\\n\\n            return sm\\n\\n\\n        def block_sum(mat,k):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    temp.append(find_sum(i+k,j+k,i-k,j-k,mat))\\n\\n                ans.append(temp)\\n\\n            return ans\\n        \\n\\n        ult_mat = prefix_col(prefix_sum(mat))\\n        return block_sum(ult_mat,K)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        def prefix_sum(mat):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    if not temp:\\n\\n                        temp.append(mat[i][j])\\n\\n                    else:\\n                        temp.append(mat[i][j] + temp[-1])\\n\\n                ans.append(temp)\\n\\n            return ans\\n\\n\\n        def prefix_col(mat):\\n\\n            for i in range(1,len(mat)):\\n\\n                for j in  range(len(mat[0])):\\n\\n                    mat[i][j] += mat[i-1][j]\\n\\n            return mat\\n\\n        def find_sum(x2,y2,x1,y1,mat):\\n\\n            x2,y2 = min(len(mat)-1,x2),min(len(mat[0])-1,y2)\\n            x1,y1 = max(x1,0),max(y1,0)\\n\\n            sm = mat[x2][y2]\\n\\n            if x1-1 >= 0:\\n                sm -= mat[x1-1][y2]\\n\\n            if y1-1 >= 0:\\n                sm -= mat[x2][y1-1]\\n\\n            if x1-1 >=0 and y1-1 >=0:\\n                sm += mat[x1-1][y1-1]\\n\\n            return sm\\n\\n\\n        def block_sum(mat,k):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    temp.append(find_sum(i+k,j+k,i-k,j-k,mat))\\n\\n                ans.append(temp)\\n\\n            return ans\\n        \\n\\n        ult_mat = prefix_col(prefix_sum(mat))\\n        return block_sum(ult_mat,K)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1138023,
                "title": "simple-dp-solution",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        pre_sum = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                pre_sum[i][j] = mat[i-1][j-1]+pre_sum[i-1][j]+pre_sum[i][j-1]-pre_sum[i-1][j-1]\\n        ans = [[0]*n for _ in range(m)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                start_r = max(i-K, 1)\\n                start_c = max(j-K, 1)\\n                end_r = min(i+K, m)\\n                end_c = min(j+K, n)\\n                ans[i-1][j-1] = pre_sum[end_r][end_c] - pre_sum[start_r-1][end_c] - pre_sum[end_r][start_c-1] + pre_sum[start_r-1][start_c-1]\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        pre_sum = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                pre_sum[i][j] = mat[i-1][j-1]+pre_sum[i-1][j]+pre_sum[i][j-1]-pre_sum[i-1][j-1]\\n        ans = [[0]*n for _ in range(m)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                start_r = max(i-K, 1)\\n                start_c = max(j-K, 1)\\n                end_r = min(i+K, m)\\n                end_c = min(j+K, n)\\n                ans[i-1][j-1] = pre_sum[end_r][end_c] - pre_sum[start_r-1][end_c] - pre_sum[end_r][start_c-1] + pre_sum[start_r-1][start_c-1]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1133196,
                "title": "c-dynamic-solved-with-design-class",
                "content": "```\\n// Help Class to do calculation\\n/* Idea is to calculate area. which can be calculated with formula\\n\\t   Sum(ABCD)=Sum(OD)\\u2212Sum(OB)\\u2212Sum(OC)+Sum(OA)\\n\\t   For example we have this matrix\\n\\t\\tO--|--|--|--|--|\\n\\t\\t|--|--A--|--|--B\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--C--|--|--D */\\nclass MatrixManipulation {\\n\\tpublic:\\n\\t\\tvector<vector<pair<int,int>>> matrix;\\n\\n\\t\\tMatrixManipulation(vector<vector<int>>& matrix) {\\n\\t\\t\\t/* Init matrix with prefix sum. I used pair because we may need the original numbers of the matrix. Not in this problem but generally*/\\n\\t\\t\\tif (matrix.size() == 0 || matrix[0].size() == 0) return;\\n\\t        for (int i = 0; i < matrix.size(); i++) {\\n\\t            int liniarSum = 0;\\n\\t            vector<pair<int,int>> v;\\n\\n\\t            for (int j = 0; j < matrix[i].size(); j++) {\\n\\t                liniarSum += matrix[i][j];\\n\\t                if (i != 0) {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum + this->matrix[i-1][j].second};\\n\\t                    v.push_back(inter);\\n\\t                } else {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum};\\n\\t                    v.push_back(inter);\\n\\t                }\\n\\t            }\\n\\t            this->matrix.push_back(v);\\n\\t        }\\n\\t\\t}\\n\\n\\t\\tint sumRegion(int row1, int col1, int row2, int col2) {\\n\\t        int completArea = this->matrix[row2][col2].second;  // Sum(OD) is from (0,0) -> (row2, col2); \\n\\t        int top = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t   // SUM(OB);\\n\\t        int left = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t  // SUM(OC)\\n\\t        int duplicate = 0;\\n\\t        if (row1 != 0) { \\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            top = this->matrix[row1-1][col2].second; // SUM(OB) is from (0,0) -> (row1-1, col2);\\n\\t        }\\n\\t        if (col1 != 0) { \\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            left = this->matrix[row2][col1-1].second; // SUM(OC) is from (0,0) -> (row2, col1-1);\\n\\t        }\\n\\t        if (row1 != 0 && col1 != 0) {\\n\\t        \\t\\t\\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            duplicate = this->matrix[row1-1][col1-1].second; // SUM(OA) if from (0,0) -> (row1-1, col1 - 1);\\n\\t            /* duplicate is 2 times extract from area because of top and left. This part is intersection part of this 2 area \\n\\t               that\\'s why is needed to add it back. */\\n\\t        } \\n\\t        return completArea - top - left + duplicate; \\n\\t    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        // Preparing matrix to work with.\\n        MatrixManipulation matrix(mat);\\n        std::vector<std::vector<int>> ans;\\n        int vertical = mat.size() - 1;\\n        int horizontal = mat[0].size() - 1;\\n        for(int i = 0; i < mat.size(); i++) {\\n            std::vector<int> v;\\n            for(int j = 0; j < mat[i].size(); j++) {\\n                // Init left top corner\\n                int verticalTopLeft = i - K;\\n                int horizontalTopLeft = j - K;\\n\\n                // Init right bottom corner\\n                int verticalBottRight = i + K;\\n                int horizontalBottRight = j + K;\\n\\n                if (verticalTopLeft < 0) {\\n                    verticalTopLeft = 0;\\n                }\\n\\n                if (horizontalTopLeft < 0) {\\n                    horizontalTopLeft = 0;\\n                }\\n\\n                if (verticalBottRight > vertical) {\\n                    verticalBottRight = vertical;\\n                }\\n\\n                if(horizontalBottRight > horizontal) {\\n                    horizontalBottRight = horizontal;\\n                }\\n                v.push_back(matrix.sumRegion(verticalTopLeft, horizontalTopLeft, verticalBottRight, horizontalBottRight));\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Help Class to do calculation\\n/* Idea is to calculate area. which can be calculated with formula\\n\\t   Sum(ABCD)=Sum(OD)\\u2212Sum(OB)\\u2212Sum(OC)+Sum(OA)\\n\\t   For example we have this matrix\\n\\t\\tO--|--|--|--|--|\\n\\t\\t|--|--A--|--|--B\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--C--|--|--D */\\nclass MatrixManipulation {\\n\\tpublic:\\n\\t\\tvector<vector<pair<int,int>>> matrix;\\n\\n\\t\\tMatrixManipulation(vector<vector<int>>& matrix) {\\n\\t\\t\\t/* Init matrix with prefix sum. I used pair because we may need the original numbers of the matrix. Not in this problem but generally*/\\n\\t\\t\\tif (matrix.size() == 0 || matrix[0].size() == 0) return;\\n\\t        for (int i = 0; i < matrix.size(); i++) {\\n\\t            int liniarSum = 0;\\n\\t            vector<pair<int,int>> v;\\n\\n\\t            for (int j = 0; j < matrix[i].size(); j++) {\\n\\t                liniarSum += matrix[i][j];\\n\\t                if (i != 0) {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum + this->matrix[i-1][j].second};\\n\\t                    v.push_back(inter);\\n\\t                } else {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum};\\n\\t                    v.push_back(inter);\\n\\t                }\\n\\t            }\\n\\t            this->matrix.push_back(v);\\n\\t        }\\n\\t\\t}\\n\\n\\t\\tint sumRegion(int row1, int col1, int row2, int col2) {\\n\\t        int completArea = this->matrix[row2][col2].second;  // Sum(OD) is from (0,0) -> (row2, col2); \\n\\t        int top = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t   // SUM(OB);\\n\\t        int left = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t  // SUM(OC)\\n\\t        int duplicate = 0;\\n\\t        if (row1 != 0) { \\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            top = this->matrix[row1-1][col2].second; // SUM(OB) is from (0,0) -> (row1-1, col2);\\n\\t        }\\n\\t        if (col1 != 0) { \\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            left = this->matrix[row2][col1-1].second; // SUM(OC) is from (0,0) -> (row2, col1-1);\\n\\t        }\\n\\t        if (row1 != 0 && col1 != 0) {\\n\\t        \\t\\t\\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            duplicate = this->matrix[row1-1][col1-1].second; // SUM(OA) if from (0,0) -> (row1-1, col1 - 1);\\n\\t            /* duplicate is 2 times extract from area because of top and left. This part is intersection part of this 2 area \\n\\t               that\\'s why is needed to add it back. */\\n\\t        } \\n\\t        return completArea - top - left + duplicate; \\n\\t    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        // Preparing matrix to work with.\\n        MatrixManipulation matrix(mat);\\n        std::vector<std::vector<int>> ans;\\n        int vertical = mat.size() - 1;\\n        int horizontal = mat[0].size() - 1;\\n        for(int i = 0; i < mat.size(); i++) {\\n            std::vector<int> v;\\n            for(int j = 0; j < mat[i].size(); j++) {\\n                // Init left top corner\\n                int verticalTopLeft = i - K;\\n                int horizontalTopLeft = j - K;\\n\\n                // Init right bottom corner\\n                int verticalBottRight = i + K;\\n                int horizontalBottRight = j + K;\\n\\n                if (verticalTopLeft < 0) {\\n                    verticalTopLeft = 0;\\n                }\\n\\n                if (horizontalTopLeft < 0) {\\n                    horizontalTopLeft = 0;\\n                }\\n\\n                if (verticalBottRight > vertical) {\\n                    verticalBottRight = vertical;\\n                }\\n\\n                if(horizontalBottRight > horizontal) {\\n                    horizontalBottRight = horizontal;\\n                }\\n                v.push_back(matrix.sumRegion(verticalTopLeft, horizontalTopLeft, verticalBottRight, horizontalBottRight));\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120894,
                "title": "c-o-n-m-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n    \\n        if(mat.empty())\\n            return {};\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=1;i<n;i++)\\n            mat[i][0] += mat[i-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n            mat[0][j] += mat[0][j-1];\\n        \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1];\\n        }\\n        \\n        vector<vector<int> >res(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                \\n                int upI = min(n-1,i+k);\\n                int upJ = min(m-1,j+k);\\n                \\n                res[i][j] = mat[upI][upJ];\\n                \\n                if(j-k-1 >= 0)\\n                    res[i][j] -= mat[upI][j-k-1];\\n                \\n                if(i-k-1 >= 0)\\n                    res[i][j] -= mat[i-k-1][upJ];\\n                \\n                if(j-k-1 >= 0 && i-k-1 >= 0)\\n                    res[i][j] += mat[i-k-1][j-k-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n    \\n        if(mat.empty())\\n            return {};\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=1;i<n;i++)\\n            mat[i][0] += mat[i-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n            mat[0][j] += mat[0][j-1];\\n        \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1];\\n        }\\n        \\n        vector<vector<int> >res(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                \\n                int upI = min(n-1,i+k);\\n                int upJ = min(m-1,j+k);\\n                \\n                res[i][j] = mat[upI][upJ];\\n                \\n                if(j-k-1 >= 0)\\n                    res[i][j] -= mat[upI][j-k-1];\\n                \\n                if(i-k-1 >= 0)\\n                    res[i][j] -= mat[i-k-1][upJ];\\n                \\n                if(j-k-1 >= 0 && i-k-1 >= 0)\\n                    res[i][j] += mat[i-k-1][j-k-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564684,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1832600,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1566925,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1575426,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1844400,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1790606,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1574294,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1929781,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1724000,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1720905,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1564684,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1832600,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1566925,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1575426,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1844400,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1790606,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1574294,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1929781,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1724000,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1720905,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            }
        ]
    }
]