[
    {
        "title": "Self Crossing",
        "question_content": "You are given an array of integers distance.\nYou start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\nReturn true if your path crosses itself or false if it does not.\n&nbsp;\nExample 1:\n\nInput: distance = [2,1,1,2]\nOutput: true\nExplanation: The path crosses itself at the point (0, 1).\n\nExample 2:\n\nInput: distance = [1,2,3,4]\nOutput: false\nExplanation: The path does not cross itself at any point.\n\nExample 3:\n\nInput: distance = [1,1,1,2,1]\nOutput: true\nExplanation: The path crosses itself at the point (0, 0).\n\n&nbsp;\nConstraints:\n\n\t1 <=&nbsp;distance.length <= 105\n\t1 <=&nbsp;distance[i] <= 105",
        "solutions": [
            {
                "id": 79131,
                "title": "java-oms-with-explanation",
                "content": "    // Categorize the self-crossing scenarios, there are 3 of them: \\n    // 1. Fourth line crosses first line and works for fifth line crosses second line and so on...\\n    // 2. Fifth line meets first line and works for the lines after\\n    // 3. Sixth line crosses first line and works for the lines after\\n    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int l = x.length;\\n            if(l <= 3) return false;\\n            \\n            for(int i = 3; i < l; i++){\\n                if(x[i] >= x[i-2] && x[i-1] <= x[i-3]) return true;  //Fourth line crosses first line and onward\\n                if(i >=4)\\n                {\\n                    if(x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2]) return true; // Fifth line meets first line and onward\\n                }\\n                if(i >=5)\\n                {\\n                    if(x[i-2] - x[i-4] >= 0 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3] - x[i-5] && x[i-1] <= x[i-3]) return true;  // Sixth line crosses first line and onward\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int l = x.length;\\n            if(l <= 3) return false;\\n            \\n            for(int i = 3; i < l; i++){\\n                if(x[i] >= x[i-2] && x[i-1] <= x[i-3]) return true;  //Fourth line crosses first line and onward\\n                if(i >=4)\\n                {\\n                    if(x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2]) return true; // Fifth line meets first line and onward\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 79141,
                "title": "another-python",
                "content": "Checking out every six pack.\\n\\n**Solution 1**\\n\\n    def isSelfCrossing(self, x):\\n        return any(d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b)\\n                   for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6]\\n                                            for i in xrange(len(x))))\\n\\n**Solution 2**\\n\\n    def isSelfCrossing(self, x):\\n        b = c = d = e = 0\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n\\n**Explanation**\\n\\n                b                              b\\n       +----------------+             +----------------+\\n       |                |             |                |\\n       |                |             |                | a\\n     c |                |           c |                |\\n       |                | a           |                |    f\\n       +----------->    |             |                | <----+\\n                d       |             |                |      | e\\n                        |             |                       |\\n                                      +-----------------------+\\n                                                   d\\n\\nDraw a line of length `a`. Then draw further lines of lengths `b`, `c`, etc. How does the `a`-line get crossed? From the left by the `d`-line or from the right by the `f`-line, see the above picture. I just encoded the criteria for actually crossing it.\\n\\nTwo details:\\n\\n- In both cases, `d` needs to be at least `b`. In the first case to cross the `a`-line directly, and in the second case to get behind it so that the `f`-line can cross it. So I factored out `d >= b`.\\n- The \"special case\" of the `e`-line stabbing the `a`-line from below is covered because in that case, the `f`-line \"crosses\" it (note that even if there is no actual `f`-line, my code uses `f = 0` and thus still finds that \"crossing\").",
                "solutionTags": [
                    "Python"
                ],
                "code": "Checking out every six pack.\\n\\n**Solution 1**\\n\\n    def isSelfCrossing(self, x):\\n        return any(d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b)\\n                   for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6]\\n                                            for i in xrange(len(x))))\\n\\n**Solution 2**\\n\\n    def isSelfCrossing(self, x):\\n        b = c = d = e = 0\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n\\n**Explanation**\\n\\n                b                              b\\n       +----------------+             +----------------+\\n       |                |             |                |\\n       |                |             |                | a\\n     c |                |           c |                |\\n       |                | a           |                |    f\\n       +----------->    |             |                | <----+\\n                d       |             |                |      | e\\n                        |             |                       |\\n                                      +-----------------------+\\n                                                   d\\n\\nDraw a line of length `a`. Then draw further lines of lengths `b`, `c`, etc. How does the `a`-line get crossed? From the left by the `d`-line or from the right by the `f`-line, see the above picture. I just encoded the criteria for actually crossing it.\\n\\nTwo details:\\n\\n- In both cases, `d` needs to be at least `b`. In the first case to cross the `a`-line directly, and in the second case to get behind it so that the `f`-line can cross it. So I factored out `d >= b`.\\n- The \"special case\" of the `e`-line stabbing the `a`-line from below is covered because in that case, the `f`-line \"crosses\" it (note that even if there is no actual `f`-line, my code uses `f = 0` and thus still finds that \"crossing\").",
                "codeTag": "Python3"
            },
            {
                "id": 79168,
                "title": "simple-java-solution",
                "content": "    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            if (x.length <= 3) {\\n                return false;\\n            }\\n            int i = 2;\\n            // keep spiraling outward\\n            while (i < x.length && x[i] > x[i - 2]) {\\n                i++;\\n            }\\n            if (i >= x.length) {\\n                return false;\\n            }\\n            // transition from spiraling outward to spiraling inward\\n            if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                    (i == 3 && x[i] == x[i - 2])) {\\n                x[i - 1] -= x[i - 3];\\n            }\\n            i++;\\n            // keep spiraling inward\\n            while (i < x.length) {\\n                if (x[i] >= x[i - 2]) {\\n                    return true;\\n                }\\n                i++;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            if (x.length <= 3) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 729133,
                "title": "how-to-explain-to-interviewer-335-self-crossing",
                "content": "#### 1. Clarify\\n1) What if one line hits another line\\'s end/start point? Is that \"crossing\"? - Answer is Yes\\n\\n#### 2. Idea\\nThere are three cases of self crossing as shown below:\\n\\n**In case 1, self-crossing condition is i >= 3 && x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]\\uFF1A**\\n<img src=\"https://assets.leetcode.com/users/images/d1886cb6-443e-4fb2-815a-45fcb17951be_1594409670.779942.png\" width=\"300\">\\n\\n\\n**In case 2, self-crossing condition is i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]**\\n<img src=\"https://assets.leetcode.com/users/images/cf0313ef-46e4-4368-996e-f8233bd6b40f_1594409704.3358605.png\" width=\"300\">\\n\\n\\n**In case 3, self-crossing condition is i >= 5 && x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 1] <= x[i - 3] && x[i - 4] + x[i] >= x[i - 2]**\\n<img src=\"https://assets.leetcode.com/users/images/09166a56-ec6f-4cf6-b7f9-027d5697f659_1594409703.788015.png\" width=\"300\">\\n\\n\\n\\n#### 3. Write Code\\n```java\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i = 3; i < x.length; i ++){\\n            if(i >= 3 && x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            \\n            if(i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) return true;\\n            \\n            if(i >= 5 && x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 1] <= x[i - 3] && x[i - 4] + x[i] >= x[i - 2]) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n#### 4. Test Cases\\nRun test cases by hand or use the IDE\\n\\n#### 5. Complexity Analysis\\nTime Complexity: O(n)  where n is the length of the array x\\nSpace Compleixty: O(1)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i = 3; i < x.length; i ++){\\n            if(i >= 3 && x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            \\n            if(i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) return true;\\n            \\n            if(i >= 5 && x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 1] <= x[i - 3] && x[i - 4] + x[i] >= x[i - 2]) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79133,
                "title": "c-simple-solution",
                "content": "    class Solution\\n    {\\n    public:\\n        bool isSelfCrossing(vector<int>& x)\\n        {\\n            x.insert(x.begin(), 4, 0);\\n    \\n            int len = x.size();\\n            int i = 4;\\n    \\n            // outer spiral\\n            for (; i < len && x[i] > x[i - 2]; i++);\\n    \\n            if (i == len) return false;\\n    \\n            // check border\\n            if (x[i] >= x[i - 2] - x[i - 4])\\n            {\\n                x[i - 1] -= x[i - 3];\\n            }\\n    \\n            // inner spiral\\n            for (i++; i < len && x[i] < x[i - 2]; i++);\\n    \\n            return i != len;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        bool isSelfCrossing(vector<int>& x)\\n        {\\n            x.insert(x.begin(), 4, 0);\\n    \\n            int len = x.size();\\n            int i = 4;\\n    \\n            // outer spiral\\n            for (; i < len && x[i] > x[i - 2]; i++);\\n    \\n            if (i == len) return false;\\n    \\n            // check border\\n            if (x[i] >= x[i - 2] - x[i - 4])\\n            {\\n                x[i - 1] -= x[i - 3];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79175,
                "title": "the-best-submission-in-c-searching-for-the-crossing-patterns-is-the-key",
                "content": "After drawing a few crossing cases ourselves, we can simply find out there are two basic patterns:\\n\\n - x[i-1]<=x[i-3] && x[i]>=x[i-2] the ending circle line cross the beginning circle line in one circle;\\n - i>=5 && x[i-1]<=x[i-3] && x[i]>=x[i-2]-x[i-4] the second line of the next circle cross the the beginning of the previous circle between two adjacent circles;\\n\\nBut still that is not over yet, how about some special cases? How about the first line of the next circle and the previous circle? Yeah, the beginning line of the next circle can overlap the the first line of the previous circle - another two adjacent circles case: \\n\\n - i>=4 && x[i-1]==x[i-3] && x[i]>=x[i-2]-x[i-4]\\n\\nQuite straightforward. Then we can test our patterns now, however soon we will find out that the second cases  is not strong enough to cover all possible situations - the second line of the next circle crossing the previous circle at the its first line\\n\\n - [3,3,3,2,1,1] is an example here, so x[i-2]>=x[i-4] then must be added to our conditions;\\n - [3,3,4,4,10,4,4,,3,3] is another typical example for x[i-3]<=x[i-1]+x[i-5] condition, which also should be added to make the constrained conditions stronger;\\n\\nAt last, we make it! Bang! End of story with a very terse, clean and efficient code as follows.\\n\\n**Updated: 2016-09-12** For better and easier reasoning, here is the thinking thread.\\nSuppose `i` is the current line, then:\\n\\n- i and i-3 can cross \\n- i and i-4 can cross\\n- i and i-5 can cross \\n\\nno more or no less just exactly the right combination.\\n\\nNow it's time for us to restrict the conditions to make them just happen.\\n\\ni and i-3\\n> i>=i-2 && i-1<=i-3\\n\\ni and i-4\\n>i+i-4>=i-2 && i-1==i-3\\n\\ni and i-5\\n> i+i-4>=i-2 && i-2>=i-4 && i-1+i-5>=i-3 && i-1<=i-3\\n\\n----------\\nIn C\\n\\n```\\nbool isSelfCrossing(int* x, int size)\\n{\\n    for(int i = 3; i < size; i++)\\n    {\\n        if(x[i]>=x[i-2] && x[i-1]<=x[i-3]) return true;\\n        if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true;\\n        if(i>=5 && x[i-2]-x[i-4]>=0 && x[i]>=x[i-2]-x[i-4] && x[i-1]>=x[i-3]-x[i-5] && x[i-1]<=x[i-3]) return true;\\n    }\\n    return false;\\n}\\n```\\n\\nIn C++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n\\tfor(int i = 3; i < x.size(); i++) {\\n\\t\\tif(x[i-1]<=x[i-3] && x[i]>=x[i-2]) return true;\\n\\t\\tif(i>3 && x[i]+x[i-4]>=x[i-2] && x[i-1]==x[i-3]) return true;\\n\\t\\tif(i>4 && x[i-1]+x[i-5]>=x[i-3] && x[i-1]<=x[i-3] && x[i]+x[i-4]>=x[i-2] && x[i-4]<=x[i-2]) return true;\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSelfCrossing(int* x, int size)\\n{\\n    for(int i = 3; i < size; i++)\\n    {\\n        if(x[i]>=x[i-2] && x[i-1]<=x[i-3]) return true;\\n        if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true;\\n        if(i>=5 && x[i-2]-x[i-4]>=0 && x[i]>=x[i-2]-x[i-4] && x[i-1]>=x[i-3]-x[i-5] && x[i-1]<=x[i-3]) return true;\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n\\tfor(int i = 3; i < x.size(); i++) {\\n\\t\\tif(x[i-1]<=x[i-3] && x[i]>=x[i-2]) return true;\\n\\t\\tif(i>3 && x[i]+x[i-4]>=x[i-2] && x[i-1]==x[i-3]) return true;\\n\\t\\tif(i>4 && x[i-1]+x[i-5]>=x[i-3] && x[i-1]<=x[i-3] && x[i]+x[i-4]>=x[i-2] && x[i-4]<=x[i-2]) return true;\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79140,
                "title": "re-post-2-o-n-c-0ms-solutions",
                "content": "The first solution is well described in [KuangYuan's post][1] and the idea is to enumerate all the self-crossing cases. Basically, there are three cases\\nCase1:  self-crossing is formed by the last 4 lines (like a closed rectangle)\\nCase 2: self-crossing is formed by the last 5 lines (still like a closed rectangle with one edge having two moves)\\nCase 3: self-crossing is formed by the last 6 lines (like two overlapped rectangles)\\n\\n    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(),i;\\n            for(i=3; i<len;++i)\\n            {\\n                if(x[i]>=x[i-2] && x[i-1] <= x[i-3]) return true; // case 1, the consecutive four lines form a cross\\n                if(i>3 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true; // case 2, the consecutive five lines form a cross\\n                if(i>4 && x[i-2]>=x[i-4] && x[i-4]+x[i]>=x[i-2] && x[i-1]<=x[i-3] && x[i-5] + x[i-1]>=x[i-3]) return true;// case 3, the consecutive six lines form a cross\\n            }\\n            return false;\\n        }\\n    };\\n\\nThe second solution is to categorize all the non-self-crossing cases: basically we can only have two valid cases: one is \"grow spiral\" (which means the curve expands like spiral and there is no boundaries in x and y axis) and the other is \"shrink spiral\" (which means the spiral curve becomes smaller and smaller and the boundaries in x and y axis are the last move in that direction). The self-crossing cases can only happen in the \"shrink\" case and it happens only when x[i]>=x[i-2]. The \"grow\" case can become a \"shrink\" case and that only happens when x[i]<=x[i-2]. The  \"shrink\" case can not change to a \"grow\" case.\\nIn the solution, we use a bool grow_spiral to indicate whether the current one is a \"grow spiral\". if before x[i], it is a  \"shrink spiral\", we only need to check if a self-crossing happen (i.e. x[i]>=x[i-2]); if it is a \"grow spiral\", we check if x[i] changes from \"grow\" to \"shrink\" (i.e. x[i]<=x[i-2]), we need to update the boundary x[i-1] (in some cases, it can be x[i-1]-x[i-3]). \\n\\n\\n    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(), i;\\n            if(len<=3) return false;\\n            bool grow_spiral;\\n\\n            for(i=3, grow_spiral = x[2]>x[0]; i<len;++i)\\n            {\\n                if(!grow_spiral && x[i]>=x[i-2]) return true;//if it is a \"shrink\" case before x[i] and cross happens\\n                if(grow_spiral && x[i]<=x[i-2])\\n                { // if it is a grow case, and x[i] changes it to shrink\\n                        grow_spiral = false;\\n                        x[i-1] = x[i] + (i>=4?x[i-4]:0)<x[i-2]? x[i-1]:x[i-1]-x[i-3];// update boundary\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\nMy special thank goes to  hohomi for pointing out one bug in Solution 2 and I believe I fixed it.\\n\\n\\n  [1]: https://leetcode.com/discuss/88054/java-oms-with-explanation",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(),i;\\n            for(i=3; i<len;++i)\\n            {\\n                if(x[i]>=x[i-2] && x[i-1] <= x[i-3]) return true; // case 1, the consecutive four lines form a cross\\n                if(i>3 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true; // case 2, the consecutive five lines form a cross\\n                if(i>4 && x[i-2]>=x[i-4] && x[i-4]+x[i]>=x[i-2] && x[i-1]<=x[i-3] && x[i-5] + x[i-1]>=x[i-3]) return true;// case 3, the consecutive six lines form a cross\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79142,
                "title": "java-solution-based-on-spiral-direction-status",
                "content": "I solved this problem based on spiral direction status. Here is the accepted code: \\n\\n \\tpublic static boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tboolean inside = false;\\n\\t\\tfor (int i = 3; i < x.length; i++) {\\n\\t\\t\\tif(inside) {\\n\\t\\t\\t\\tif (x[i] >= x[i - 2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tif(x[i-1] > x[i-3])\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint x5 = i>=5 ? x[i-5] : 0;\\n\\t\\t\\tint x4 = i>=4 ? x[i-4] : 0;\\n\\t\\t\\tif(x[i-1] >= x[i-3] - x5) {\\n\\t\\t\\t\\tif(x[i] >= x[i-2] - x4)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tif(x[i] >= x[i-2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tinside=true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\nFor this question, to keep the line not crossed, it can be in following conditions: \\n\\n1. Keep spiraling outside.\\n2. Keep spiraling inside.\\n3. Not crossing during transition from outside spiral into inside spiral. \\n\\nAnd one observation is once it starts to spiral inside, it will never spiral outside.  \\n\\nBased on this observation, we keep one flag: inside which is initialized to false,\\n\\nDuring spiraling outside, and inside, the check is very simple: just check x[i] < x[i-2] for inside spiral. In outside spiral phase, as long as x[i-1] > x[i-3], it's not possible to cross in this step. \\n\\nOnce x[i-1] > x[i-3] condition is broken, we will trigger the transition period: In this period, it has two conditions, \\n\\n1. If this turn back line is towards line x[i-5] (possible cross x[i-5])\\n2. If this turn back line is not towards line x[i-5]. in that case, it will go towards x[i-3] instead. \\n\\nWe need to calculate the max line for x[i] for the two cases.\\n\\nWhen i<4 and i<5 corner case, to avoid many if/else we just prepend two additional steps as if they are moving 0 length. So assign x4 and x5 to 0 respectively.\\n\\nThis solution compare to other solution based on 3 different crossing condition, it's slight better as it will only look back x[i-4] and x[i-4] during transition period (once only). In other two phases, it will only compare two edges.",
                "solutionTags": [],
                "code": "I solved this problem based on spiral direction status. Here is the accepted code: \\n\\n \\tpublic static boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tboolean inside = false;\\n\\t\\tfor (int i = 3; i < x.length; i++) {\\n\\t\\t\\tif(inside) {\\n\\t\\t\\t\\tif (x[i] >= x[i - 2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tif(x[i-1] > x[i-3])\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint x5 = i>=5 ? x[i-5] : 0;\\n\\t\\t\\tint x4 = i>=4 ? x[i-4] : 0;\\n\\t\\t\\tif(x[i-1] >= x[i-3] - x5) {\\n\\t\\t\\t\\tif(x[i] >= x[i-2] - x4)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tif(x[i] >= x[i-2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tinside=true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\nFor this question, to keep the line not crossed, it can be in following conditions: \\n\\n1. Keep spiraling outside.\\n2. Keep spiraling inside.\\n3. Not crossing during transition from outside spiral into inside spiral. \\n\\nAnd one observation is once it starts to spiral inside, it will never spiral outside.  \\n\\nBased on this observation, we keep one flag: inside which is initialized to false,\\n\\nDuring spiraling outside, and inside, the check is very simple: just check x[i] < x[i-2] for inside spiral. In outside spiral phase, as long as x[i-1] > x[i-3], it's not possible to cross in this step. \\n\\nOnce x[i-1] > x[i-3] condition is broken, we will trigger the transition period: In this period, it has two conditions, \\n\\n1. If this turn back line is towards line x[i-5] (possible cross x[i-5])\\n2. If this turn back line is not towards line x[i-5]. in that case, it will go towards x[i-3] instead. \\n\\nWe need to calculate the max line for x[i] for the two cases.\\n\\nWhen i<4 and i<5 corner case, to avoid many if/else we just prepend two additional steps as if they are moving 0 length. So assign x4 and x5 to 0 respectively.\\n\\nThis solution compare to other solution based on 3 different crossing condition, it's slight better as it will only look back x[i-4] and x[i-4] during transition period (once only). In other two phases, it will only compare two edges.",
                "codeTag": "Unknown"
            },
            {
                "id": 3089493,
                "title": "c-solution-o-n-time-complexity-pure-maths",
                "content": "# Approach\\n We observe that the point rotates in counter clockwise format.If the no of elements in distance is less than 4 then it cant even complete a full circle so it always returns False.\\nWe apply for loop from 4 to the last line\\n Next it can cross only in two ways :\\n\\n\\n### **When the 4th line meets the 1st line**\\n![WhatsApp Image 7 PM.jpeg](https://assets.leetcode.com/users/images/687c105e-778f-4f3c-989b-2ad109608144_1674462721.4440026.jpeg)\\n\\nIn the image above we notice when the 4th line meets the 1st line..It occurs only when two conditions satisfy:\\n1. The 4th line(i-3) should be longer than 2nd line(i-1)\\n2. The 3rd line(i-2) should be shorter than 1st line(i)\\n\\nSo we return True.\\n\\n### **When the 6th line meets the 1st line**\\n Only when length is longer than 5\\n![WhatsApp Imagjpeg.jpeg](https://assets.leetcode.com/users/images/288d36fd-5ee7-4d45-a25e-42981fc8b156_1674463517.289606.jpeg)\\n\\nIn the image above we notice that the 6th line should cross the 1st line..The conditions for it to occur are:\\n1. The 3rd line(i-2) must be longer than 1st line(i) \\n2. The 2nd line(i-1) must be shorter than 4th line(i-3)\\n3. The sum of 2nd line(i-1) and 6th line(i-5) must be greater than the 4th line(i-3)\\n4. The 1st line(i) and the 5th line(i-4) must be greater than the 3rd line(i-2)\\n\\nSo we return True.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4) return false;\\n        distance.insert(distance.begin(),0);\\n        for(int i=3;i<distance.size();i++){\\n            if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) return true;\\n            if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n//UPVOTE IF YOU LIKED THE ANSWER..THANK YOU\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4) return false;\\n        distance.insert(distance.begin(),0);\\n        for(int i=3;i<distance.size();i++){\\n            if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) return true;\\n            if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n//UPVOTE IF YOU LIKED THE ANSWER..THANK YOU\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806502,
                "title": "c-code-with-explanation",
                "content": "This problem looks like how to check the crossing line, so the naive way is maintaining the existing lines, and checking if there are any intersections from the current line. Unfortunately, this approach needs O(n^2) query in the worst case.\\n\\nThe key point of the problem is for each line i, we only need to check 2 lines: line i-3 and line i-5. \\n\\nHere is the reason. \\n* Firstly, the vertical line can only intersect with horizon line(except one special case: two vertical line may intersect at (0, 0)). \\n* Then we note that we move to the next position following the fixed pattern: up, left, down, right, and so on, in other words, counterclockwise. Thus, there are 3 possible outputs:\\n\\t1. expansion case (line i has a possible intersection with line i-5):\\n![image](https://assets.leetcode.com/users/images/3f41bb90-af78-4c13-805b-476c30c94255_1646043347.182547.png)\\n\\n\\t2. contraction case (line i has a possible intersection with line i-3):\\n![image](https://assets.leetcode.com/users/images/d73d2868-1ea1-4e4e-aefa-1e805afc9137_1646043438.367299.png)\\n\\t\\n\\t3. expansion+contraction case (line i has a possible intersection with line i-3 and line i-5):\\n![image](https://assets.leetcode.com/users/images/bd58bd95-ba1e-4eff-9654-7f2282866225_1646043494.1786318.png)\\n\\nHere is my code:\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if (distance.size() <= 3) return false; //only can have intersection with more than 4 lines\\n\\n        distance.insert(distance.begin(), 0); //for the edge case: line i intersect with line i-4 at (0, 0)\\n        for (int i = 3; i < distance.size(); i++) {\\n            //check line i-3\\n            if (distance[i - 2] <= distance[i] && distance[i - 1] <= distance[i - 3]) return true;\\n\\n            //check line i-5\\n            if (i >= 5) {\\n                if (distance[i - 1] <= distance[i - 3] && distance[i - 1] >= distance[i - 3] - distance[i - 5] \\n                    && distance[i - 2] >= distance[i - 4] && distance[i - 2] <= distance[i - 4] + distance[i])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if (distance.size() <= 3) return false; //only can have intersection with more than 4 lines\\n\\n        distance.insert(distance.begin(), 0); //for the edge case: line i intersect with line i-4 at (0, 0)\\n        for (int i = 3; i < distance.size(); i++) {\\n            //check line i-3\\n            if (distance[i - 2] <= distance[i] && distance[i - 1] <= distance[i - 3]) return true;\\n\\n            //check line i-5\\n            if (i >= 5) {\\n                if (distance[i - 1] <= distance[i - 3] && distance[i - 1] >= distance[i - 3] - distance[i - 5] \\n                    && distance[i - 2] >= distance[i - 4] && distance[i - 2] <= distance[i - 4] + distance[i])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79192,
                "title": "java-o-n-o-1-0ms-solution-with-explanation",
                "content": "There are only 3 scenarios where it won't cross itself.\\n\\n1. The distances of the moves parallel to each other keeps going up (growing spiral).\\n2. The distances of the moves parallel to each other keeps going down (shrinking spiral).\\n3. The distances of the moves parallel to each other first keeps going up, then keeps going down (shrinking spiral inside of the growing spiral), and never goes up.\\n\\nOur code just needs to check if there're any things violating the above rules.\\n\\nI feel there should be smarter approaches. Please reply as answer or comments. :P\\n\\n    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int a1, a2, a3, a4, a5;\\n            \\n            // if it's increasing\\n            boolean up = false;\\n            \\n            if (x.length < 4) {\\n                return false;\\n            }\\n            \\n            a1 = 0;\\n            a2 = x[0];\\n            a3 = x[1];\\n            a4 = x[2];\\n            \\n            if (a2 < a4) {\\n                up = true;\\n            }\\n            else {\\n                up = false;\\n            }\\n            \\n            for (int i = 3; i < x.length; i++) {\\n                a5 = x[i];\\n                \\n                if (!up && a5 >= a3) {\\n                    return true;\\n                }\\n                else if (up && a5 <= a3) {\\n                    // succeeded in turning into decreasing\\n                    if (a5 + a1 < a3 || (i + 1 < x.length && x[i + 1] + a2 < a4)) {\\n                        up = false;\\n                    }\\n                    // not end yet\\n                    else if (i + 1 < x.length) {\\n                        return true;\\n                    }\\n                }\\n                \\n                a1 = a2;\\n                a2 = a3;\\n                a3 = a4;\\n                a4 = a5;\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int a1, a2, a3, a4, a5;\\n            \\n            // if it's increasing\\n            boolean up = false;\\n            \\n            if (x.length < 4) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1223251,
                "title": "a-short-clean-solution-in-c-in-one-pass-o-n-and-o-1-memory",
                "content": "# Idea for the solution\\nThe pattern formed is an outward spiral, followed by an inward spiral. Once the inward spiral has started, we cannot start spiralling out, if it does then it intersects itself.\\n\\nBoth of the spirals obviously don\\'t intersect themselves, so all we need to check is if they intersect each other. The first edge which is part of the inward spiral (smaller than the edge along the same axis N-S or E-W) is called the contracting edge, represented in the code as `pos`.\\n\\n# Spiral Intersection Condition\\nTo check if the spirals intersect, we need to ensure that the size of the spirals (largest edge, last edge of outward spiral and first of inward spiral) don\\'t add up to the space in between them (which is cause by the edge in between the two spirals). Therefore we come up with the and of two conditions, each along one of the axes:\\n\\n```\\nbool cond1 = distance[pos] + distance[pos - 4] >= distance[pos - 2] \\nbool cond2 = distance[pos + 1] + distance[pos - 3] >= distance[pos - 1] \\nreturn cond1 and cond2\\n```\\nHere pos is the index of the contracting edge.\\n# Final Implementation\\n\\nFollowing is the full implementation in C++\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int pos = -1;\\n        int n = distance.size();\\n        for (int i = 2; i < n; i++) {\\n            if (distance[i] >= distance[i - 2] && pos != -1) {\\n                return true; // Tried to expand or static after contracting phase\\n            } else if (distance[i] <= distance[i - 2] && pos == -1) {\\n                pos = i; // The contracting phase starts at this edge\\n            }\\n        }\\n        if (pos == -1) return false;\\n        return ((pos >= 0 ? distance[pos] : 0) + (pos >= 4 ? distance[pos - 4] : 0) >= (pos >= 2 ? distance[pos - 2] : 0)) && \\n            ((pos < n - 1 ? distance[pos + 1] : 0) + (pos >= 3 ? distance[pos - 3] : 0) >= (pos >= 1 ? distance[pos - 1] : 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Geometry"
                ],
                "code": "```\\nbool cond1 = distance[pos] + distance[pos - 4] >= distance[pos - 2] \\nbool cond2 = distance[pos + 1] + distance[pos - 3] >= distance[pos - 1] \\nreturn cond1 and cond2\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int pos = -1;\\n        int n = distance.size();\\n        for (int i = 2; i < n; i++) {\\n            if (distance[i] >= distance[i - 2] && pos != -1) {\\n                return true; // Tried to expand or static after contracting phase\\n            } else if (distance[i] <= distance[i - 2] && pos == -1) {\\n                pos = i; // The contracting phase starts at this edge\\n            }\\n        }\\n        if (pos == -1) return false;\\n        return ((pos >= 0 ? distance[pos] : 0) + (pos >= 4 ? distance[pos - 4] : 0) >= (pos >= 2 ? distance[pos - 2] : 0)) && \\n            ((pos < n - 1 ? distance[pos + 1] : 0) + (pos >= 3 ? distance[pos - 3] : 0) >= (pos >= 1 ? distance[pos - 1] : 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153188,
                "title": "c-very-simple-no-complex-logic-not-much-ifelse",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& a) {\\n        int n = a.size();\\n\\tif (n <= 3) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool f = true;\\n\\n\\tif (a[2] <= a[0]) {\\n\\t\\tf = false;\\n\\t}\\n\\n\\tfor (int i = 3; i < n; i++) {\\n\\n\\t\\tif (!f) {\\n\\t\\t\\tif (a[i] >= a[i - 2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t\\n\\t\\t\\tif (a[i] <= a[i - 2]) {\\n\\t\\t\\t\\tf = false;\\n\\t\\t\\t\\tif (a[i - 2] - a[i - 4] <= a[i]) {\\n\\t\\t\\t\\t\\ta[i - 1] = a[i - 1] - a[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& a) {\\n        int n = a.size();\\n\\tif (n <= 3) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool f = true;\\n\\n\\tif (a[2] <= a[0]) {\\n\\t\\tf = false;\\n\\t}\\n\\n\\tfor (int i = 3; i < n; i++) {\\n\\n\\t\\tif (!f) {\\n\\t\\t\\tif (a[i] >= a[i - 2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t\\n\\t\\t\\tif (a[i] <= a[i - 2]) {\\n\\t\\t\\t\\tf = false;\\n\\t\\t\\t\\tif (a[i - 2] - a[i - 4] <= a[i]) {\\n\\t\\t\\t\\t\\ta[i - 1] = a[i - 1] - a[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900931,
                "title": "this-explaination-made-my-life-easy",
                "content": "This video made things clear https://www.youtube.com/watch?v=ajFikcnQV1I \\n\\nTo summerise, problem is broken in 3 cases, \\n![image](https://assets.leetcode.com/users/images/06cb65f8-3b4a-4a87-aa65-c8e52709ed87_1603072520.2768774.png)\\n\\n![image](https://assets.leetcode.com/users/images/3e9bcd87-5b0d-4f55-9caa-486c529c45fc_1603072568.686776.png)\\n\\n![image](https://assets.leetcode.com/users/images/d2c12c8c-1070-4a5a-bb76-593c97487945_1603074025.8367305.png)\\n\\n\\nHere is C++ equivalent,\\n```\\nbool isSelfCrossing(vector<int>& x) {\\n        for(int i = 3; i < x.size(); i++)\\n        {\\n            // x[0] >= x[2], x[3] >= x[1]\\n            if(x[i - 3] >= x[i - 1] && x[i] >= x[i - 2])\\n            {\\n                return true;\\n            }\\n\\n            if(i >= 4)\\n            {\\n                // x[1] == x[3], x[0] + x[4] >= x[2]\\n                if(x[i - 3] == x[i - 1] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            if(i >= 5)\\n            {\\n                // x[3] >= x[1], x[2] >= x[4], x[0] + x[4] >= x[2], x[1] + x[5] >= x[3]\\n                if(x[i - 2] >= x[i - 4] && x[i - 3] >= x[i - 1] && \\n                   (x[i - 5] + x[i - 1]) >= x[i - 3] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isSelfCrossing(vector<int>& x) {\\n        for(int i = 3; i < x.size(); i++)\\n        {\\n            // x[0] >= x[2], x[3] >= x[1]\\n            if(x[i - 3] >= x[i - 1] && x[i] >= x[i - 2])\\n            {\\n                return true;\\n            }\\n\\n            if(i >= 4)\\n            {\\n                // x[1] == x[3], x[0] + x[4] >= x[2]\\n                if(x[i - 3] == x[i - 1] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            if(i >= 5)\\n            {\\n                // x[3] >= x[1], x[2] >= x[4], x[0] + x[4] >= x[2], x[1] + x[5] >= x[3]\\n                if(x[i - 2] >= x[i - 4] && x[i - 3] >= x[i - 1] && \\n                   (x[i - 5] + x[i - 1]) >= x[i - 3] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79159,
                "title": "an-ascii-art-explanation-of-this-problem-and-my-c-solution",
                "content": "    //           =   a l l    c a s e s   =\\n    // \\n    //     case 1     case 2: expanding   case 3: collapsing\\n    //                     (global)           (local)\\n    //                  (not crossing)   (may not crossing)\\n    // \\n    //    <------+     +------------+      +---------+\\n    //           |     |            |      |         |\\n    //           |     |  +-----+   |      |  +---+  |\\n    //           |     |  |     |   |      |  |   |  :\\n    //           #     |  |     #   |      |  v   |  :\\n    //                 |  |         |      |      |  \\n    //                 |  +---------+      +------+  \\n    //                 |\\n    //                 +--------->\\n    // \\n    //     case 4: failed expanding                \\n    //      \\n    //      +----+\\n    //      |    |\\n    //      |  <----[2]----^     [2]: second failure\\n    //      |    #         |\\n    //      |             [1]    [1]: first  failure\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 5: failed expanding & then collapsing\\n    // \\n    //      +----+\\n    //      |    |\\n    //      |    |  +------+\\n    //      |    #  | [C]  |     [C]: may be perfectly collapsed\\n    //      |       +--->  |\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 6: failed expanding                \\n    // \\n    //         +---+\\n    //         |   |\\n    //         |   |\\n    //         |   #\\n    //         |\\n    //       <---[2]----+        [2]: second failure\\n    //         |        |\\n    //         |       [1]       [1]: first  failure\\n    //         |        |\\n    //         +--------+\\n    // \\n    //     case 7: failed expanding & then collapsing\\n    // \\n    //         +------+\\n    //         |      |\\n    //         |      #\\n    //         |\\n    //         |  +-----------+\\n    //         |  |  +-----+  |\\n    //         |  |  +-->  | [1] [1]: failure\\n    //         |  |        |  |\\n    //         |  +--------+  |\\n    //         +--------------+\\n    // \\n    //    *notice: case 3 = case 6 + case 7\\n    // \\n    //     case 8: docking!\\n    // \\n    //         +-------+\\n    //         |       |\\n    //         |       #\\n    //         |\\n    //         |       ^\\n    //         |       |\\n    //         +-------+\\n    // \\n    // #: starting point \\n    \\n    // case 3\\n    bool isPerfectCollapsing( int cur, int len, int *data )\\n    {\\n        while ( cur < len ) {\\n            if ( data[cur] < data[cur-2] ) {\\n                ++cur;\\n            } else { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    bool isPerfect( int *data, int len )\\n    {\\n        // case 1\\n        if ( len <= 2 ) { return true; }\\n        // case 8\\n        if ( len >= 5 &&\\n             data[3]==data[1] &&\\n             data[2]<=data[0]+data[4] )\\n        {\\n            return false;\\n        }\\n    \\n        int cur = 2;\\n        while ( cur < len && data[cur] > data[cur-2] ) {\\n            ++cur;\\n        }\\n        if ( cur == len || cur == len-1 ) {\\n            // case 2: perfect expanding\\n            return true;\\n        }\\n    \\n        // collapsed!\\n        if ( cur == 2 || cur == 3 ) {\\n            // case 3\\n            return isPerfectCollapsing( ++cur, len, data );\\n        }\\n    \\n        if ( data[cur]+data[cur-4] >= data[cur-2] ) {                    // case 4/5\\n            if ( ++cur < len ) {\\n                if ( data[cur]+data[cur-4] >= data[cur-2] ) {            // case 4\\n                    return false;\\n                } else { return isPerfectCollapsing(++cur, len, data); } // case 5\\n            } else { return true; }\\n        } else { return isPerfectCollapsing(++cur, len, data); }         // case 6/7\\n    }\\n    \\n    bool isSelfCrossing( int *x, int xSize ) {\\n        return !isPerfect( x, xSize );\\n    }",
                "solutionTags": [],
                "code": "    //           =   a l l    c a s e s   =\\n    // \\n    //     case 1     case 2: expanding   case 3: collapsing\\n    //                     (global)           (local)\\n    //                  (not crossing)   (may not crossing)\\n    // \\n    //    <------+     +------------+      +---------+\\n    //           |     |            |      |         |\\n    //           |     |  +-----+   |      |  +---+  |\\n    //           |     |  |     |   |      |  |   |  :\\n    //           #     |  |     #   |      |  v   |  :\\n    //                 |  |         |      |      |  \\n    //                 |  +---------+      +------+  \\n    //                 |\\n    //                 +--------->\\n    // \\n    //     case 4: failed expanding                \\n    //      \\n    //      +----+\\n    //      |    |\\n    //      |  <----[2]----^     [2]: second failure\\n    //      |    #         |\\n    //      |             [1]    [1]: first  failure\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 5: failed expanding & then collapsing\\n    // \\n    //      +----+\\n    //      |    |\\n    //      |    |  +------+\\n    //      |    #  | [C]  |     [C]: may be perfectly collapsed\\n    //      |       +--->  |\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 6: failed expanding                \\n    // \\n    //         +---+\\n    //         |   |\\n    //         |   |\\n    //         |   #\\n    //         |\\n    //       <---[2]----+        [2]: second failure\\n    //         |        |\\n    //         |       [1]       [1]: first  failure\\n    //         |        |\\n    //         +--------+\\n    // \\n    //     case 7: failed expanding & then collapsing\\n    // \\n    //         +------+\\n    //         |      |\\n    //         |      #\\n    //         |\\n    //         |  +-----------+\\n    //         |  |  +-----+  |\\n    //         |  |  +-->  | [1] [1]: failure\\n    //         |  |        |  |\\n    //         |  +--------+  |\\n    //         +--------------+\\n    // \\n    //    *notice: case 3 = case 6 + case 7\\n    // \\n    //     case 8: docking!\\n    // \\n    //         +-------+\\n    //         |       |\\n    //         |       #\\n    //         |\\n    //         |       ^\\n    //         |       |\\n    //         +-------+\\n    // \\n    // #: starting point \\n    \\n    // case 3\\n    bool isPerfectCollapsing( int cur, int len, int *data )\\n    {\\n        while ( cur < len ) {\\n            if ( data[cur] < data[cur-2] ) {\\n                ++cur;\\n            } else { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    bool isPerfect( int *data, int len )\\n    {\\n        // case 1\\n        if ( len <= 2 ) { return true; }\\n        // case 8\\n        if ( len >= 5 &&\\n             data[3]==data[1] &&\\n             data[2]<=data[0]+data[4] )\\n        {\\n            return false;\\n        }\\n    \\n        int cur = 2;\\n        while ( cur < len && data[cur] > data[cur-2] ) {\\n            ++cur;\\n        }\\n        if ( cur == len || cur == len-1 ) {\\n            // case 2: perfect expanding\\n            return true;\\n        }\\n    \\n        // collapsed!\\n        if ( cur == 2 || cur == 3 ) {\\n            // case 3\\n            return isPerfectCollapsing( ++cur, len, data );\\n        }\\n    \\n        if ( data[cur]+data[cur-4] >= data[cur-2] ) {                    // case 4/5\\n            if ( ++cur < len ) {\\n                if ( data[cur]+data[cur-4] >= data[cur-2] ) {            // case 4\\n                    return false;\\n                } else { return isPerfectCollapsing(++cur, len, data); } // case 5\\n            } else { return true; }\\n        } else { return isPerfectCollapsing(++cur, len, data); }         // case 6/7\\n    }\\n    \\n    bool isSelfCrossing( int *x, int xSize ) {\\n        return !isPerfect( x, xSize );\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3244854,
                "title": "335-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe algorithm checks three possible cases for each line of the path, starting from the 3rd line. If any of the cases is true, the function returns True, meaning the path crosses itself. If none of the cases is true after looping through all the lines, the function returns False, meaning the path does not cross itself.\\n\\nThe three cases are:\\n\\n1. The current line crosses the line 3 steps before it.\\n2. The current line crosses the line 4 steps before it.\\n3. The current line crosses the line 5 steps before it.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    # If there are less than 4 values in the array, the path can\\'t cross itself\\n    if len(x) <= 3:\\n      return False\\n\\n    # Loop through the array starting from the 3rd index\\n    for i in range(3, len(x)):\\n      # Case 1: current line crosses the line 3 steps before it\\n      #           _______\\n      #         |      |\\n      #         |      |\\n      # ________|______| <-- current line\\n      #         |          |\\n      #         |          |\\n      #         |__________| <-- line 3 steps before\\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\\n        return True\\n      \\n      # Case 2: current line crosses the line 4 steps before it\\n      #         _____\\n      #        |      |\\n      #        |      |\\n      #        |      |________\\n      #        |               |\\n      #        |               |\\n      #        |_______________| <-- current line\\n      #              line 4 steps before\\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\\n        return True\\n      \\n      # Case 3: current line crosses the line 5 steps before it\\n      #         ______\\n      #        |      |\\n      #        |      |\\n      #        |______| <-- line 5 steps before\\n      #               |\\n      #               |\\n      #         ______|_______\\n      #        |              |\\n      #        |              |\\n      #        |______________| <-- current line\\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\\n        return True\\n\\n    # If no crossing has been found, the path does not cross itself\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    # If there are less than 4 values in the array, the path can\\'t cross itself\\n    if len(x) <= 3:\\n      return False\\n\\n    # Loop through the array starting from the 3rd index\\n    for i in range(3, len(x)):\\n      # Case 1: current line crosses the line 3 steps before it\\n      #           _______\\n      #         |      |\\n      #         |      |\\n      # ________|______| <-- current line\\n      #         |          |\\n      #         |          |\\n      #         |__________| <-- line 3 steps before\\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\\n        return True\\n      \\n      # Case 2: current line crosses the line 4 steps before it\\n      #         _____\\n      #        |      |\\n      #        |      |\\n      #        |      |________\\n      #        |               |\\n      #        |               |\\n      #        |_______________| <-- current line\\n      #              line 4 steps before\\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\\n        return True\\n      \\n      # Case 3: current line crosses the line 5 steps before it\\n      #         ______\\n      #        |      |\\n      #        |      |\\n      #        |______| <-- line 5 steps before\\n      #               |\\n      #               |\\n      #         ______|_______\\n      #        |              |\\n      #        |              |\\n      #        |______________| <-- current line\\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\\n        return True\\n\\n    # If no crossing has been found, the path does not cross itself\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262213,
                "title": "simplest-java-solution-with-text-explaintation",
                "content": "situation1:fourth line cross first line;like a rectangle\\nsituation2:fifth line meet first line;like a rectangle\\nsituation3:sixth line cross first line;like a capital letter L{\\n\\tx[i] represents the sixth line;\\n\\tx[i-2]must bigger than x[i-4], or it won\\'t cross or become situation 1,2;\\n\\tx[i-1]must smaller than x[i-3], or  it won\\'t cross or become situation 1,2;\\n\\tx[i-1]+x[i-5]must bigger than or equal to x[i-3],x[i]+x[i-4]must bigger than or equal to x[i-2] or it won\\'t cross or become situation 1,2;\\n}\\n\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length<4)return false;\\n        for(int i=3;i<x.length;i++){\\n            if(x[i]>=x[i-2]&&x[i-1]<=x[i-3])return true;\\n            if(x.length>4&&i>3&&x[i-1]==x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;\\n            if(x.length>5&&i>4&&x[i-2]>x[i-4]&&x[i-1]<x[i-3]&&\\n               (x[i-5]+x[i-1])>=x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;  \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length<4)return false;\\n        for(int i=3;i<x.length;i++){\\n            if(x[i]>=x[i-2]&&x[i-1]<=x[i-3])return true;\\n            if(x.length>4&&i>3&&x[i-1]==x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;\\n            if(x.length>5&&i>4&&x[i-2]>x[i-4]&&x[i-1]<x[i-3]&&\\n               (x[i-5]+x[i-1])>=x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;  \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79184,
                "title": "my-java-solution",
                "content": "This problem reminds me of an old snake game where snake eats its own tail..\\n<p>It pretty clear that once x[i]<=x[i-2] the snake will become 'trapped' and eventually will eat itself. From there on we need to find conditions of when this happens. The easiest one is x[i]>=x[i-2]. The other 2 are a little tricker:<p>\\nFirst one  is when snake catches it's tail at 0 degree angle. For example [1,1,2,1,1] <p>\\nSecond one when it catches it's tail at 90 degree angle. For example  [1,1,2,2,1,1]\\n\\n\\n\\n    public boolean isSelfCrossing(int[] x) {\\n    \\tboolean snakeTrapped = false;\\n    \\tfor (int i=2;i<x.length;i++){\\n    \\t\\tif (snakeTrapped){\\n    \\t\\t     if (x[i]>=x[i-2])\\n    \\t\\t\\t    return true;\\n    \\t\\t\\t else if (i>=4 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t\\t else if (i>=5 && x[i-3]-x[i-1]-x[i-5]<=0 && x[i-3]>x[i-5] && x[i]+x[i-4]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t}\\n    \\t\\telse if (x[i]<=x[i-2])\\n    \\t\\t\\tsnakeTrapped = true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "solutionTags": [],
                "code": "This problem reminds me of an old snake game where snake eats its own tail..\\n<p>It pretty clear that once x[i]<=x[i-2] the snake will become 'trapped' and eventually will eat itself. From there on we need to find conditions of when this happens. The easiest one is x[i]>=x[i-2]. The other 2 are a little tricker:<p>\\nFirst one  is when snake catches it's tail at 0 degree angle. For example [1,1,2,1,1] <p>\\nSecond one when it catches it's tail at 90 degree angle. For example  [1,1,2,2,1,1]\\n\\n\\n\\n    public boolean isSelfCrossing(int[] x) {\\n    \\tboolean snakeTrapped = false;\\n    \\tfor (int i=2;i<x.length;i++){\\n    \\t\\tif (snakeTrapped){\\n    \\t\\t     if (x[i]>=x[i-2])\\n    \\t\\t\\t    return true;\\n    \\t\\t\\t else if (i>=4 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t\\t else if (i>=5 && x[i-3]-x[i-1]-x[i-5]<=0 && x[i-3]>x[i-5] && x[i]+x[i-4]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t}\\n    \\t\\telse if (x[i]<=x[i-2])\\n    \\t\\t\\tsnakeTrapped = true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 79185,
                "title": "a-simple-python-solution-with-explanation",
                "content": "This is based on dong.wang.1694's [second solution][1] with a little modification. \\n\\nThe basic idea is like this:\\n1) When expanding, we never collide. \\n\\n2) When shrinking, we collide when we go back too far. For example, if two steps ago, we went upward for 8, this time we can't go down for more than 7 or it is a collision.\\n\\n3) The tricky part is when transitioning from expanding to shrinking, we may get an early collision!!\\n\\n\\n    class Solution(object):\\n        def isSelfCrossing(self, x):\\n\\n            n = len(x)\\n            x.append(0.5)        # let x[-1] = 0.5\\n            if n < 4: return False\\n            grow = x[2] > x[0]\\n                \\n            for i in range(3,n):\\n                if not grow and x[i] >= x[i-2]: return True\\n                if grow and x[i] <= x[i-2]:\\n                    grow = False\\n                    if x[i] + x[i-4] >= x[i-2]:\\n                        x[i-1] -= x[i-3]\\n            return False\\n\\nGraph\\n    \\n                                              +------------+\\n        +---------+                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |       i-4  <----+                   |            |\\n    i-2 |         |       |                   |            +\\n        |         |       |                   |\\n        |                 |i                  |\\n        |                 |                   |         <---------------+\\n        |                 |                   |                         |\\n        +---------+-------+                   |                         |\\n                  ^                           |                         |\\n                  |                           +-------------------------+\\n                  |\\n    \\n    \\n        x[i] + x[i-4] >= x[i-2]                  x[i] + x[i-4] < x[i-2]\\n        Then, possible early collision,          nothing has to be changed\\n        pretend we have started from\\n        the plus sign point\\n\\nwhen x[3] == x\\\\[1], we have to deal with a very special case. So we pretend we have started from a point 0.5 to the left of the origin making this case identical to what we have discussed above. \\n\\n            1\\n      +------------+\\n      |            |\\n      |            |\\n      |            |0\\n      |            |\\n      |            |\\n    2 |            |\\n      |            +\\n      |\\n      |\\n      |            ^\\n      |            |\\n      |            |\\n      +------------+\\n            3\\n\\n\\n  [1]: https://leetcode.com/discuss/88196/re-post-2-o-n-c-0ms-solutions\\n  [2]: https://leetcode.com/discuss/88075/java-o-n-logical-solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "This is based on dong.wang.1694's [second solution][1] with a little modification. \\n\\nThe basic idea is like this:\\n1) When expanding, we never collide. \\n\\n2) When shrinking, we collide when we go back too far. For example, if two steps ago, we went upward for 8, this time we can't go down for more than 7 or it is a collision.\\n\\n3) The tricky part is when transitioning from expanding to shrinking, we may get an early collision!!\\n\\n\\n    class Solution(object):\\n        def isSelfCrossing(self, x):\\n\\n            n = len(x)\\n            x.append(0.5)        # let x[-1] = 0.5\\n            if n < 4: return False\\n            grow = x[2] > x[0]\\n                \\n            for i in range(3,n):\\n                if not grow and x[i] >= x[i-2]: return True\\n                if grow and x[i] <= x[i-2]:\\n                    grow = False\\n                    if x[i] + x[i-4] >= x[i-2]:\\n                        x[i-1] -= x[i-3]\\n            return False\\n\\nGraph\\n    \\n                                              +------------+\\n        +---------+                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |       i-4  <----+                   |            |\\n    i-2 |         |       |                   |            +\\n        |         |       |                   |\\n        |                 |i                  |\\n        |                 |                   |         <---------------+\\n        |                 |                   |                         |\\n        +---------+-------+                   |                         |\\n                  ^                           |                         |\\n                  |                           +-------------------------+\\n                  |\\n    \\n    \\n        x[i] + x[i-4] >= x[i-2]                  x[i] + x[i-4] < x[i-2]\\n        Then, possible early collision,          nothing has to be changed\\n        pretend we have started from\\n        the plus sign point\\n\\nwhen x[3] == x\\\\[1], we have to deal with a very special case. So we pretend we have started from a point 0.5 to the left of the origin making this case identical to what we have discussed above. \\n\\n            1\\n      +------------+\\n      |            |\\n      |            |\\n      |            |0\\n      |            |\\n      |            |\\n    2 |            |\\n      |            +\\n      |\\n      |\\n      |            ^\\n      |            |\\n      |            |\\n      +------------+\\n            3\\n\\n\\n  [1]: https://leetcode.com/discuss/88196/re-post-2-o-n-c-0ms-solutions\\n  [2]: https://leetcode.com/discuss/88075/java-o-n-logical-solution",
                "codeTag": "Java"
            },
            {
                "id": 79160,
                "title": "5-lines-cpp-code-with-clear-logic",
                "content": "Basic observations:\\n1. No crossing is produced when the path keeps going either 'inward' or 'outward'.\\n2. A path without crossing is either one of the two above cases or a combination of both (an outward path transit into an inward path).\\n\\n    class Solution {\\n    public:\\n       bool isSelfCrossing(std::vector<int>& x) {\\n          // started 'outside', walk until 'inside' a rectangle\\n          int i; for(i=2; i<x.size()&&x[i]>x[i-2]; i++);\\n          // out->in transition step\\n          if( i>2 && x[i] >= x[i-2]-(i==3?0:x[i-4]) ) x[i-1] -= x[i-3];\\n          // we are inside a rectangle now, check for crossing\\n          for(i++; i<x.size()&&x[i]<x[i-2]; i++);\\n          // crossing detected if end is not reached\\n          return i<x.size();\\n       }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n       bool isSelfCrossing(std::vector<int>& x) {\\n          // started 'outside', walk until 'inside' a rectangle\\n          int i; for(i=2; i<x.size()&&x[i]>x[i-2]; i++);\\n          // out->in transition step\\n          if( i>2 && x[i] >= x[i-2]-(i==3?0:x[i-4]) ) x[i-1] -= x[i-3];\\n          // we are inside a rectangle now, check for crossing\\n          for(i++; i<x.size()&&x[i]<x[i-2]; i++);\\n          // crossing detected if end is not reached\\n          return i<x.size();\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3490803,
                "title": "easiest-javascript-solution-with-more-optimization",
                "content": "```\\nPlease Give An Up-Vote If This Solution Helps You !!!\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code implements a solution to check whether a given set of points (represented as an array) form a self-crossing polygon or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is to traverse the points array and check if any line segments intersect with any previous line segments. The code starts by checking if the number of points is greater than 3, which is the minimum required to form a self-crossing polygon. If the number of points is less than or equal to 3, the code returns false indicating that no self-crossing is possible.\\n\\nThe code then traverses the points array and checks if the points are spiraling outward or inward. It maintains an index \\'i\\' which is initialized to 2, and then moves forward until the points are no longer spiraling outward. If the points are no longer spiraling outward, the code checks if they are spiraling inward. If they are, it checks if the current line segment intersects with any of the previous line segments. If it does, the code returns true indicating that a self-crossing has occurred. Otherwise, it continues to traverse the points array until the end and returns false indicating that no self-crossing has occurred.\\n\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The code traverses the entire points array once, which takes `O(n)` time where n is the number of points in the array.\\n\\n- The code checks if the points are spiraling outward, which can take up to n-2 iterations in the worst case. Therefore, the time complexity of this operation is `O(n)`.\\n\\n- The code then checks if the points are spiraling inward, which can take up to n-4 iterations in the worst case. Therefore, the time complexity of this operation is also `O(n)`.\\n\\n- Finally, the code checks if the current line segment intersects with any of the previous line segments, which takes constant time.\\n\\nTherefore, the overall time complexity of the code is `O(n)`.\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a single variable \\'i\\' to maintain the index of the current point, which takes constant space.\\n\\nTherefore, the space complexity of the code is `O(1)`.\\n\\n# Mind It\\nTherefore, both the time and space complexity of the code are constant with respect to the number of points.\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nPlease Give An Up-Vote If This Solution Helps You !!!\\n```\n```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982519,
                "title": "python-o-n-o-1-method-time-beats-90",
                "content": "The basic idea is:\\n**To not touch itself, a spiral can only grow larger then grow smaller, but cannot grow smaller and then go larger.** Or, whenever a distance[i] <= distance[i - 2], all following distance[i] must < distance[i - 2] or the spiral will meet itself. This criterion is kinda like the pandora\\'s box so I will use this as a indicator.\\nBeside the basic requirement, there are two special cases at the first step after opening the pandora\\'s box which is even stricter, I will not talk too much in detail cuz they are kinda trivial but you can draw them and easily see why they are special.\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        i = 2\\n        pandora = float(\\'inf\\')\\n        while i < len(distance):\\n            if pandora == float(\\'inf\\') and distance[i] <= distance[i - 2]:#the pandora\\'s box is opened\\n                pandora = i\\n                i += 1\\n                continue\\n            if pandora != float(\\'inf\\'):\\n                if distance[i] >= distance[i - 2]:#general requirement\\n                    return True\\n                if pandora == 3 and i == 4:#special case type1\\n                    if distance[i - 1] == distance[i - 3]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True\\n                if pandora >= 4 and i == pandora + 1:#special case type2\\n                    if distance[i - 1] >= distance[i - 3] - distance[i - 5]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True \\n            i += 1\\n        return False",
                "solutionTags": [],
                "code": "The basic idea is:\\n**To not touch itself, a spiral can only grow larger then grow smaller, but cannot grow smaller and then go larger.** Or, whenever a distance[i] <= distance[i - 2], all following distance[i] must < distance[i - 2] or the spiral will meet itself. This criterion is kinda like the pandora\\'s box so I will use this as a indicator.\\nBeside the basic requirement, there are two special cases at the first step after opening the pandora\\'s box which is even stricter, I will not talk too much in detail cuz they are kinda trivial but you can draw them and easily see why they are special.\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        i = 2\\n        pandora = float(\\'inf\\')\\n        while i < len(distance):\\n            if pandora == float(\\'inf\\') and distance[i] <= distance[i - 2]:#the pandora\\'s box is opened\\n                pandora = i\\n                i += 1\\n                continue\\n            if pandora != float(\\'inf\\'):\\n                if distance[i] >= distance[i - 2]:#general requirement\\n                    return True\\n                if pandora == 3 and i == 4:#special case type1\\n                    if distance[i - 1] == distance[i - 3]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True\\n                if pandora >= 4 and i == pandora + 1:#special case type2\\n                    if distance[i - 1] >= distance[i - 3] - distance[i - 5]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True \\n            i += 1\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 993157,
                "title": "python-93-5-very-concise-and-understandable-solution-10-lines-of-code",
                "content": "```\\n\\n\\n# Written by : Dhruv_Vavliya\\n\\n# just think about 4,5,6 --length arrays \\ndef self_crossing(x):\\n    for i in range(3,len(x)):\\n\\n        if x[i-3]>=x[i-1] and x[i]>=x[i-2]:\\n            return True\\n        \\n        if i>=4:\\n            if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                return True\\n\\n        if i>=5:\\n            if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                return True\\n\\n    return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n\\n# Written by : Dhruv_Vavliya\\n\\n# just think about 4,5,6 --length arrays \\ndef self_crossing(x):\\n    for i in range(3,len(x)):\\n\\n        if x[i-3]>=x[i-1] and x[i]>=x[i-2]:\\n            return True\\n        \\n        if i>=4:\\n            if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                return True\\n\\n        if i>=5:\\n            if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                return True\\n\\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 647656,
                "title": "c-diagrams-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if (x.size() >= 5 && x[3] == x[1] && x[0]+x[4] >= x[2]) {\\n            /*\\n             Crossing in a loop:\\n                 2\\n             3 \\u250C\\u2500\\u2500\\u2500\\u2500\\u2510\\n               \\u2514\\u2500\\u2550\\u2550>\\u25181\\n               4  0  (overlapped)\\n            */\\n            return true;\\n        }\\n        \\n        for (int i = 3; i < x.size(); i++) {\\n            if (x[i] >= x[i-2] && x[i-1] <= x[i-3]) {\\n                /*\\n                 Case 1:\\n                    i-2\\n                 i-1\\u250C\\u2500\\u2510\\n                    \\u2514\\u2500\\u253C\\u2500>i\\n                     i-3\\n                */\\n                return true;\\n            } else if (i >= 5 && (x[i-4] <= x[i-2] && x[i] + x[i-4] >= x[i-2])\\n                    && (x[i-1] <= x[i-3] && x[i-1] + x[i-5] >= x[i-3])) {\\n                 /*\\n                  Case 2:\\n                    i-4\\n                    \\u250C\\u2500\\u2500\\u2510 \\n                    \\u2502i<\\u253C\\u2500\\u2510\\n                 i-3\\u2502 i-5\\u2502i-1\\n                    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2518\\n                      i-2\\n                */\\n                 return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if (x.size() >= 5 && x[3] == x[1] && x[0]+x[4] >= x[2]) {\\n            /*\\n             Crossing in a loop:\\n                 2\\n             3 \\u250C\\u2500\\u2500\\u2500\\u2500\\u2510\\n               \\u2514\\u2500\\u2550\\u2550>\\u25181\\n               4  0  (overlapped)\\n            */\\n            return true;\\n        }\\n        \\n        for (int i = 3; i < x.size(); i++) {\\n            if (x[i] >= x[i-2] && x[i-1] <= x[i-3]) {\\n                /*\\n                 Case 1:\\n                    i-2\\n                 i-1\\u250C\\u2500\\u2510\\n                    \\u2514\\u2500\\u253C\\u2500>i\\n                     i-3\\n                */\\n                return true;\\n            } else if (i >= 5 && (x[i-4] <= x[i-2] && x[i] + x[i-4] >= x[i-2])\\n                    && (x[i-1] <= x[i-3] && x[i-1] + x[i-5] >= x[i-3])) {\\n                 /*\\n                  Case 2:\\n                    i-4\\n                    \\u250C\\u2500\\u2500\\u2510 \\n                    \\u2502i<\\u253C\\u2500\\u2510\\n                 i-3\\u2502 i-5\\u2502i-1\\n                    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2518\\n                      i-2\\n                */\\n                 return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533866,
                "title": "python-24ms-covers-corner-cases",
                "content": "Note the results from Leetcode offical console:\\n```\\nx = [0] # False\\nx = [0,0] # False\\nx = [0,0,0] # False\\nx = [0,0,0,0] # True\\n```\\n\\nMy solution:\\n```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    \"\"\"     N\\n            ^\\n            |\\n      W <--- ---> E\\n            |\\n            v\\n            S\\n\\n    Self-Crossing Scenarios:\\n\\n              Case 1                  Case 2                  Case 3               \\n                b                       b                       b                  \\n       +----------------+      +----------------+      +----------------+          \\n       |                |      |                |      |                |          \\n       |                |      |                |      |                |          \\n     c |                | a  c |                | a  c |                | a        \\n       |                |      |                |      |                |    f     \\n       +--------------->|      |                |      |                | <----+   \\n                d       |      |                ^ e    |                |      | e \\n                               |                |      |                       |   \\n                               +----------------+      +-----------------------+   \\n                                        d                       d                  \\n    \"\"\"\\n    a, b, c, d, e, f = [-1] * 6\\n    for z in x:\\n      f, e, d, c, b, a = e, d, c, b, a, z\\n      if d >= 0 and (c <= a) and (d >= b):\\n        return True\\n      if e >= 0 and (c > a) and (d == b) and (e >= c - a):\\n        return True\\n      if f >= 0 and (c > a) and (d > b) and (e >= c - a and e <= c) and (f >= d - b):\\n        return True\\n    return False\\n```",
                "solutionTags": [],
                "code": "```\\nx = [0] # False\\nx = [0,0] # False\\nx = [0,0,0] # False\\nx = [0,0,0,0] # True\\n```\n```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    \"\"\"     N\\n            ^\\n            |\\n      W <--- ---> E\\n            |\\n            v\\n            S\\n\\n    Self-Crossing Scenarios:\\n\\n              Case 1                  Case 2                  Case 3               \\n                b                       b                       b                  \\n       +----------------+      +----------------+      +----------------+          \\n       |                |      |                |      |                |          \\n       |                |      |                |      |                |          \\n     c |                | a  c |                | a  c |                | a        \\n       |                |      |                |      |                |    f     \\n       +--------------->|      |                |      |                | <----+   \\n                d       |      |                ^ e    |                |      | e \\n                               |                |      |                       |   \\n                               +----------------+      +-----------------------+   \\n                                        d                       d                  \\n    \"\"\"\\n    a, b, c, d, e, f = [-1] * 6\\n    for z in x:\\n      f, e, d, c, b, a = e, d, c, b, a, z\\n      if d >= 0 and (c <= a) and (d >= b):\\n        return True\\n      if e >= 0 and (c > a) and (d == b) and (e >= c - a):\\n        return True\\n      if f >= 0 and (c > a) and (d > b) and (e >= c - a and e <= c) and (f >= d - b):\\n        return True\\n    return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470000,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func isSelfCrossing(_ x: [Int]) -> Bool {\\n        var n = x.count\\n        if n <= 3 {\\n            return false\\n        }\\n        for i in 3..<n {\\n            if x[i] >= x[i-2] && x[i-1] <= x[i-3] {\\n                return true\\n            }\\n            if i >= 4 && x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2] {\\n                return true\\n            }\\n            if i >= 5 && x[i-2] >= x[i-4] && x[i-3] >= x[i-1] && x[i] + x[i-4] >= x[i-2] && x[i-1] + x[i-5] >= x[i-3] {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSelfCrossing(_ x: [Int]) -> Bool {\\n        var n = x.count\\n        if n <= 3 {\\n            return false\\n        }\\n        for i in 3..<n {\\n            if x[i] >= x[i-2] && x[i-1] <= x[i-3] {\\n                return true\\n            }\\n            if i >= 4 && x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2] {\\n                return true\\n            }\\n            if i >= 5 && x[i-2] >= x[i-4] && x[i-3] >= x[i-1] && x[i] + x[i-4] >= x[i-2] && x[i-1] + x[i-5] >= x[i-3] {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503602,
                "title": "alternative-one-pass-solution-proofs",
                "content": "Let curve C be formed as in the problem, by joining segments s(i) of length d(i).\\n\\nThe intuition here is that a non-self-intersecting curve built this way is made of two spirals, first spiraling out with growing d(i), and then spiraling in, with decreasing d(i) (of course one of those spirals may be empty).\\n\\n**Theorem 1**:  Suppose C is not self-intersecting. Then either d(i+2)>d(i) for all i, or there exists I such that d(i+2)>d(i) for all i<I, d(I+2)<=d(I) and  d(i+2)<d(i) for all i>I. \\n \\n**Theorem 2**: If d(i+2)>d(i) for all i then C is not-self intersecting.\\nSuppose, on the other hand, there exists I such that d(i+2)>d(i)  for all i<I, d(I+2)<=d(I) and\\n  d(i+2)<d(i) for all i>I. Then, either (after possibly padding the path with 0-length segments so \\n  that both s(I-2) and s(I+3) exist) segments s(I-2) and s(I+3) intersect, or C is not self-intersecting.\\n  \\n  **Corollary**: If C is self-intersecting, then either exists  i such that  s(i) intersects s(i+3) or exists  i such that s(i) intersects s(i+5).\\n  \\n  Code from Theorems:\\n  \\n  \\n\\n  \\n\\t   for i in range(len(distance)-2):\\n\\t\\t\\t\\tif distance[i+2]<=distance[i]:\\n\\t\\t\\t\\t\\tI=i\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False \\n\\t\\tfor i in range(I+1, len(distance)-2):\\n\\t\\t\\tif distance[i+2]>=distance[i]:\\n\\t\\t\\t\\treturn True \\n\\t\\t\\t\\n    ls=[0]*6\\n\\tfor j in range(-2, 4):\\n\\t\\tif len(distance)-1>=I+j>=0:\\n\\t\\t\\tls[j+2]=distance[I+j]        \\n\\treturn ls[0]+ls[4]>=ls[2] and ls[1]+ls[5]>=ls[3]\\n\\n\\nYou can find \"code from Corollary\" in most of the solutions.\\n\\n#### Proofs:\\n\\n\\n**Proof sketch of Theorem 1**: Suppose C is not self-intersecting.  Consider the smallest I such that d(I+2)<=d(I) (if there is no such I we are done). Then, possibly after rotation we have the picture like this:\\n\\n>              |   \\n>          s(I)|        |\\n>              |_______ | s(I+2)\\n>                s(I+1)\\n\\n Thus if C is not self intersecting,  d(I+3)<d(I+1). By induction,  d(i+2)<d(i) for all i>I.\\n \\n**Proof sketch of Theorem 2**:  Consider the initial part of C, consisting of the first I+2\\n segments s(0),..., s(I+1). This part \"spirals out\" and is not self-intersecting. More strongly,\\n for any segment in this part, all previous segments lie to one side of that segment.\\n (If the segment is running up, the previous ones are to the left, if its running left the previous ones are below etc. This can be proved by induction on the segment number, see Bonus Lemma 1 below.) Thus the segment can never intersect any of the previous ones, and indeed that part of C is not self intersecting.\\n   \\n  If this is all of C (i.e. if d(i+2)>d(i) for all i), then the whole c is non-self intersecting.\\n   \\n   If not, then consider the \"end\" part of C consisting of the segments s(I+1),..., s(n), which \"spiral in\". By our assumption, it has d(i+2)<d(i), but  if we retrace that part backwards, as s(n), s(n-1), ... s(I+1),  will have d(i+2)>d(i) and will be like the initial part, except turning right instead of left. Thus this part of C is also not self-intersecting and has the \"segments after s(j) are to one side of s(j)\" property as well.\\n\\nThus we have a picture like so:\\n  \\n>           s(I-1) \\n>           _______              s(I+3)\\n>          |   ____|s(I-2)       _______\\n>      s(I)|   s(I-3)     s(I+4)|       |\\n>          |____________________________| s(I+2)\\n>                  s(I+1)\\n      \\n with initial part of C inside the box made by part of s(I), s(I-1), s(I-2) and s(I-3) and the \"end\" part of C inside the box made by part of s(I+1), s(I-2), s(I+3) and s(I+4). If these boxes don\\'t intersect, then C is not self intersecting. But these boxes intersect precisely when  s(I-2) intersects s(I+3).\\n    \\n**Proof of corollary**: We prove the contrapositive. Since s(i+3) intersects s(i) precisely when d(i+2)<=d(i) and d(i+3)>=d(i),\\n    if this does not happen, then either d(i+2)>d(i) always, or as soon as d(I+2)<=d(I) for the first time we have d(i+2)<d(i) for all i>I. Thus, in either case, we are in the situation of Theorem 2.  But then by that Theorem, if s(I-2) does not intersect s(I+3) the curve is not self-intersecting. The corollary follows.\\n      \\n    \\n----\\n\\n**Bonus**:\\n\\n**Lemma 1**: Suppose  d(i+2)>d(i) for all i<I. Then for any segment s(i) with i<I:\\n\\n0) if s(i) is going up (i.e. i%4==0), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are less than those of the points of s(i)).\\n\\n1) if s(i) is going left (i.e. i%4==1), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly below that segment \\n(i.e. the y-coordinates of all points are less than those of the points of s(i)).\\n\\n2) if s(i) is going down (i.e. i%4==2), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are bigger than those of the points of s(i)).\\n\\n3) if s(i) is going right (i.e. i%4==3), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly above that segment \\n(i.e. the y-coordinates of all points are greater than those of the points of s(i)).\\n\\n\\n\\n\\nProof:\\n\\n0) Consider  i=4k. \\nWhen k=0 there is nothing to prove. We proceed by induction on k. \\nTh segment s(4k) has x-coordinate x(k)=-d(2)+d(4)-d(6)+...+d(4k), which is \\nequal to x(k-1)+(-d(4k-2)+d(4k)). Since d(4k)> d(4k-2) by assumption, x(k)>x(k-1).\\nThen by induction hypothesis, all the segments up to s(4k-5) have x-coordinates below \\nx(k-1), so below x(k) as well. Thus we only need to worry about\\n s(4k-5), s(4k-4), s(4k-3) and s(4k-2). But all of these are (non-strictly) \\n to the left of s(4k-4), and so all their points have x-coordinates <=x(k-1)<x(k)\\n as well. This completes the proof.\\n \\n The proofs for all other cases are analogous (they are all \"rotated versions\" of each other.)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Let curve C be formed as in the problem, by joining segments s(i) of length d(i).\\n\\nThe intuition here is that a non-self-intersecting curve built this way is made of two spirals, first spiraling out with growing d(i), and then spiraling in, with decreasing d(i) (of course one of those spirals may be empty).\\n\\n**Theorem 1**:  Suppose C is not self-intersecting. Then either d(i+2)>d(i) for all i, or there exists I such that d(i+2)>d(i) for all i<I, d(I+2)<=d(I) and  d(i+2)<d(i) for all i>I. \\n \\n**Theorem 2**: If d(i+2)>d(i) for all i then C is not-self intersecting.\\nSuppose, on the other hand, there exists I such that d(i+2)>d(i)  for all i<I, d(I+2)<=d(I) and\\n  d(i+2)<d(i) for all i>I. Then, either (after possibly padding the path with 0-length segments so \\n  that both s(I-2) and s(I+3) exist) segments s(I-2) and s(I+3) intersect, or C is not self-intersecting.\\n  \\n  **Corollary**: If C is self-intersecting, then either exists  i such that  s(i) intersects s(i+3) or exists  i such that s(i) intersects s(i+5).\\n  \\n  Code from Theorems:\\n  \\n  \\n\\n  \\n\\t   for i in range(len(distance)-2):\\n\\t\\t\\t\\tif distance[i+2]<=distance[i]:\\n\\t\\t\\t\\t\\tI=i\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False \\n\\t\\tfor i in range(I+1, len(distance)-2):\\n\\t\\t\\tif distance[i+2]>=distance[i]:\\n\\t\\t\\t\\treturn True \\n\\t\\t\\t\\n    ls=[0]*6\\n\\tfor j in range(-2, 4):\\n\\t\\tif len(distance)-1>=I+j>=0:\\n\\t\\t\\tls[j+2]=distance[I+j]        \\n\\treturn ls[0]+ls[4]>=ls[2] and ls[1]+ls[5]>=ls[3]\\n\\n\\nYou can find \"code from Corollary\" in most of the solutions.\\n\\n#### Proofs:\\n\\n\\n**Proof sketch of Theorem 1**: Suppose C is not self-intersecting.  Consider the smallest I such that d(I+2)<=d(I) (if there is no such I we are done). Then, possibly after rotation we have the picture like this:\\n\\n>              |   \\n>          s(I)|        |\\n>              |_______ | s(I+2)\\n>                s(I+1)\\n\\n Thus if C is not self intersecting,  d(I+3)<d(I+1). By induction,  d(i+2)<d(i) for all i>I.\\n \\n**Proof sketch of Theorem 2**:  Consider the initial part of C, consisting of the first I+2\\n segments s(0),..., s(I+1). This part \"spirals out\" and is not self-intersecting. More strongly,\\n for any segment in this part, all previous segments lie to one side of that segment.\\n (If the segment is running up, the previous ones are to the left, if its running left the previous ones are below etc. This can be proved by induction on the segment number, see Bonus Lemma 1 below.) Thus the segment can never intersect any of the previous ones, and indeed that part of C is not self intersecting.\\n   \\n  If this is all of C (i.e. if d(i+2)>d(i) for all i), then the whole c is non-self intersecting.\\n   \\n   If not, then consider the \"end\" part of C consisting of the segments s(I+1),..., s(n), which \"spiral in\". By our assumption, it has d(i+2)<d(i), but  if we retrace that part backwards, as s(n), s(n-1), ... s(I+1),  will have d(i+2)>d(i) and will be like the initial part, except turning right instead of left. Thus this part of C is also not self-intersecting and has the \"segments after s(j) are to one side of s(j)\" property as well.\\n\\nThus we have a picture like so:\\n  \\n>           s(I-1) \\n>           _______              s(I+3)\\n>          |   ____|s(I-2)       _______\\n>      s(I)|   s(I-3)     s(I+4)|       |\\n>          |____________________________| s(I+2)\\n>                  s(I+1)\\n      \\n with initial part of C inside the box made by part of s(I), s(I-1), s(I-2) and s(I-3) and the \"end\" part of C inside the box made by part of s(I+1), s(I-2), s(I+3) and s(I+4). If these boxes don\\'t intersect, then C is not self intersecting. But these boxes intersect precisely when  s(I-2) intersects s(I+3).\\n    \\n**Proof of corollary**: We prove the contrapositive. Since s(i+3) intersects s(i) precisely when d(i+2)<=d(i) and d(i+3)>=d(i),\\n    if this does not happen, then either d(i+2)>d(i) always, or as soon as d(I+2)<=d(I) for the first time we have d(i+2)<d(i) for all i>I. Thus, in either case, we are in the situation of Theorem 2.  But then by that Theorem, if s(I-2) does not intersect s(I+3) the curve is not self-intersecting. The corollary follows.\\n      \\n    \\n----\\n\\n**Bonus**:\\n\\n**Lemma 1**: Suppose  d(i+2)>d(i) for all i<I. Then for any segment s(i) with i<I:\\n\\n0) if s(i) is going up (i.e. i%4==0), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are less than those of the points of s(i)).\\n\\n1) if s(i) is going left (i.e. i%4==1), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly below that segment \\n(i.e. the y-coordinates of all points are less than those of the points of s(i)).\\n\\n2) if s(i) is going down (i.e. i%4==2), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are bigger than those of the points of s(i)).\\n\\n3) if s(i) is going right (i.e. i%4==3), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly above that segment \\n(i.e. the y-coordinates of all points are greater than those of the points of s(i)).\\n\\n\\n\\n\\nProof:\\n\\n0) Consider  i=4k. \\nWhen k=0 there is nothing to prove. We proceed by induction on k. \\nTh segment s(4k) has x-coordinate x(k)=-d(2)+d(4)-d(6)+...+d(4k), which is \\nequal to x(k-1)+(-d(4k-2)+d(4k)). Since d(4k)> d(4k-2) by assumption, x(k)>x(k-1).\\nThen by induction hypothesis, all the segments up to s(4k-5) have x-coordinates below \\nx(k-1), so below x(k) as well. Thus we only need to worry about\\n s(4k-5), s(4k-4), s(4k-3) and s(4k-2). But all of these are (non-strictly) \\n to the left of s(4k-4), and so all their points have x-coordinates <=x(k-1)<x(k)\\n as well. This completes the proof.\\n \\n The proofs for all other cases are analogous (they are all \"rotated versions\" of each other.)\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1018879,
                "title": "java-arm-leg-and-swirl",
                "content": "A self-crossing state is determined by the current state and a few successive preceding states. The popular 3-scenario solution  checks the current state and different combinations of these preceding states (https://leetcode.com/problems/self-crossing/discuss/79131/Java-Oms-with-explanation).\\n\\nThe following solution uses a helper method to deal with \"array index out of bound\" issue. Meanwhile, it approaches the problem from a two-case perspective: 1) conditions that current segment crosses its second predecessor (term[i - 2]) and 2) conditions that the current one crosses its fourth predecessor (term[i - 4]). By resummarizing and reorganizing checking conditions, this solution attempts to make the code more general and conciser.\\n\\n```\\npublic boolean isSelfCrossing(int[] x) {\\n  boolean arm = false;\\n  boolean leg = false;\\n  \\n  for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n  }\\n  return false;\\n}\\n\\nprivate int f(int[] x, int index) {\\n  return (index < 0) ? 0 : x[index];\\n}\\n```\\n\\n**Notes:** \\n1. In each step of iteration, we only compare the current `x[i]` with `a` and `b`, where `b` is the length of its second predeccessor (`x[i - 2]`), and `a` is the difference between its second predecessor and fourth predecessor, that is`x[i - 2] - x[i - 4]`. \\n2. the first two statements within the for-loop block define `a` and `b`.\\n3. the last two statements check whether the current state goes into `arm` state or `leg` state.\\n4. the middle two statments check that once in `arm` or `leg` state, whether the current segment cross its predecessors.\\n5. the main purpose of this solution is to simplify complicated compound conditions in each `if()` statements.\\n6. `a`, `b`, `arm` and `leg` are not good identifiers. To make complicated concepts intuitive, `a` and `arm` represents \\'the shorter segment\\', `b` and `leg` represents \\'the longer ones\\'.\\n7. the condition `(a > 0)` in `if (leg && x[i] >= a && a > 0)` precludes the ***inward swirls***, it only checks the ***outward swirl***.\\n```\\n   // Asterisk(*) is the starting position of the paths\\n      ___ ___ ___                     ___ ___\\n     |    ___    |                   |       |   |\\n\\t |       |   |                   |       *   |\\n\\t |___ ___|   *                   |___ ___ ___|\\n   // inward swirl                   outward swirl\\n```\\n**Observations beyond the code:**\\n1. an `inward swirl` path can only hit its `inner walls`; an `outward swirl` can hit its `outer walls`\\n2. an `inward swirl` cannot change to `outward swirl` before crossing itself\\n3. an `outward swirl` can change to an `inward swirl` under some conditions\\n4. an `inward swirl` can only have `arm` state, and never `leg` state\\n5. an `outward swirl` can only have one step of `leg` state, its next step is either crossing its `outer walls` or change to the `arm` state\\n6. hitting or crossing the starting point is defined as crossing `outer walls`\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isSelfCrossing(int[] x) {\\n  boolean arm = false;\\n  boolean leg = false;\\n  \\n  for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n  }\\n  return false;\\n}\\n\\nprivate int f(int[] x, int index) {\\n  return (index < 0) ? 0 : x[index];\\n}\\n```\n```\\n   // Asterisk(*) is the starting position of the paths\\n      ___ ___ ___                     ___ ___\\n     |    ___    |                   |       |   |\\n\\t |       |   |                   |       *   |\\n\\t |___ ___|   *                   |___ ___ ___|\\n   // inward swirl                   outward swirl\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708886,
                "title": "cannot-find-symbol-arrayutils-in-java",
                "content": "I would like to add a zero in front of the input array `x` by using ArrayUtils:\\n```\\nx = ArrayUtils.add(x, 0, 0);\\n```\\nHowever,  Leetcode gave an error saying: `cannot find symbol ArrayUtils`. Can anyone advise?",
                "solutionTags": [],
                "code": "```\\nx = ArrayUtils.add(x, 0, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504464,
                "title": "c-double-100-surpass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 5) {\\n            return x.size() >= 4 && x[0] >= x[2] and x[3] >= x[1];\\n        }\\n        if ((x[3] < x[1] && x[4] >= x[2]) || (x[3] == x[1] && x[0] + x[4] >= x[2])) {\\n            return true;\\n        }\\n        for (int i = 5; i < x.size(); i++) {\\n            if (x[i - 1] >= x[i - 3]) {\\n                continue;\\n            }\\n            if (x[i - 2] <= x[i - 4]) {\\n                if (x[i] < x[i - 2]) {\\n                    continue;\\n                } else {\\n                    return true;\\n                }\\n            }\\n            if (x[i - 1] + x[i - 5] >= x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 5) {\\n            return x.size() >= 4 && x[0] >= x[2] and x[3] >= x[1];\\n        }\\n        if ((x[3] < x[1] && x[4] >= x[2]) || (x[3] == x[1] && x[0] + x[4] >= x[2])) {\\n            return true;\\n        }\\n        for (int i = 5; i < x.size(); i++) {\\n            if (x[i - 1] >= x[i - 3]) {\\n                continue;\\n            }\\n            if (x[i - 2] <= x[i - 4]) {\\n                if (x[i] < x[i - 2]) {\\n                    continue;\\n                } else {\\n                    return true;\\n                }\\n            }\\n            if (x[i - 1] + x[i - 5] >= x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349110,
                "title": "python-check-every-6-lines",
                "content": "For each line, just check its next 6 lines. If not crossed, then skip it and do the same \"6-line check\" on the next line. Because if a line doesn\\'t get crossed in 6 steps, then even if it get crossed later, some other line must get crossed before it.\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        n=len(x)\\n        def helper(i):\\n            steps=[x[k+i] if k+i<n else 0 for k in range(6)]\\n            if steps[3]<steps[1]:\\n                return False\\n            if steps[2]<=steps[0]:\\n                return True\\n            if steps[3]>=steps[1] and steps[4]>=(steps[2]-steps[0]) and steps[4]<=steps[2] and steps[5]>=(steps[3]-steps[1]):\\n                return True\\n            return False\\n        return any(helper(i) for i in range(n-3))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        n=len(x)\\n        def helper(i):\\n            steps=[x[k+i] if k+i<n else 0 for k in range(6)]\\n            if steps[3]<steps[1]:\\n                return False\\n            if steps[2]<=steps[0]:\\n                return True\\n            if steps[3]>=steps[1] and steps[4]>=(steps[2]-steps[0]) and steps[4]<=steps[2] and steps[5]>=(steps[3]-steps[1]):\\n                return True\\n            return False\\n        return any(helper(i) for i in range(n-3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79134,
                "title": "java-simple-solution",
                "content": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length < 4)    return false;\\n        int i = 0, base = 0;\\n        while(i+4 <= x.length){\\n            if(x[i] - x[i+2] >= 0 && x[i+1] - x[i+3] <= base)  return true;\\n            else if(x[i+1] - x[i+3] > base)     base = 0;\\n            else    base = x[i];\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length < 4)    return false;\\n        int i = 0, base = 0;\\n        while(i+4 <= x.length){\\n            if(x[i] - x[i+2] >= 0 && x[i+1] - x[i+3] <= base)  return true;\\n            else if(x[i+1] - x[i+3] > base)     base = 0;\\n            else    base = x[i];\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79135,
                "title": "c-simple-single-pass-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4) return false;\\n        bool bInc = x[2] > x[0];\\n        for(int i = 3; i < x.size(); i++){\\n            if(bInc){\\n                //increasing spiral\\n                if(x[i] <= x[i - 2]){\\n                    bInc = false;\\n                    //handle border\\n                    if(x[i] >= x[i - 2] - (i < 4 ? 0 : x[i-4]) )\\n                        x[i-1] -= x[i-3];\\n                }\\n            }\\n            else{\\n                //decreasing spiral\\n                if(x[i] >= x[i-2]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4) return false;\\n        bool bInc = x[2] > x[0];\\n        for(int i = 3; i < x.size(); i++){\\n            if(bInc){\\n                //increasing spiral\\n                if(x[i] <= x[i - 2]){\\n                    bInc = false;\\n                    //handle border\\n                    if(x[i] >= x[i - 2] - (i < 4 ? 0 : x[i-4]) )\\n                        x[i-1] -= x[i-3];\\n                }\\n            }\\n            else{\\n                //decreasing spiral\\n                if(x[i] >= x[i-2]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79152,
                "title": "very-clear-c",
                "content": "The key is to determine whether the circles are growing bigger or smaller. If it keeps growing bigger, then return false and if it keeps growing smaller, then return false. The only case when return true is when it converts from growing bigger to growing smaller, which is x[i] <= x[i-2]. Then whether it self-cross depends on x[i+1].\\n\\n```\\nbool isSelfCrossing(vector<int>& x){\\n\\n\\tif (x.size() < 4) return false;\\n\\n\\tint n = x.size();\\n\\n\\tbool larger = x[2] > x[0];\\n\\tfor (int i = 3; i < n;){\\n\\t\\tif (!larger){\\n\\t\\t\\tif (x[i] >= x[i - 2]) return true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (x[i] <= x[i - 2]){\\n\\t\\t\\t\\tlarger = false;\\n\\t\\t\\t\\tif (x[i] == x[i - 2]) {\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}else if ( i-4>=0 && x[i] >= x[i-2] - x[i - 4]){\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++i;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSelfCrossing(vector<int>& x){\\n\\n\\tif (x.size() < 4) return false;\\n\\n\\tint n = x.size();\\n\\n\\tbool larger = x[2] > x[0];\\n\\tfor (int i = 3; i < n;){\\n\\t\\tif (!larger){\\n\\t\\t\\tif (x[i] >= x[i - 2]) return true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (x[i] <= x[i - 2]){\\n\\t\\t\\t\\tlarger = false;\\n\\t\\t\\t\\tif (x[i] == x[i - 2]) {\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}else if ( i-4>=0 && x[i] >= x[i-2] - x[i - 4]){\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++i;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79170,
                "title": "easy-to-understand-0ms-c-solution-without-obscure-tricks",
                "content": "Consider the last three vertical segments of the path: let's assume that the pattern of them is \\u2191, \\u2193, \\u2191(the other pattern(\\u2193, \\u2191, \\u2193) is just the same if we put the path upside down), now we're going to check whether next horizontal segment will intersect with any segments on the path, then we got 2 possible situations in which the current horizontal segment have no chance of intersecting with other segments except for the last three vertical ones, that is to say we just need to keep the last three ones and check them one by one when we deal with the current horizontal segment. As for the vertical situation, all the conclusions are similar.\\n\\nMy C++ code:\\n\\n    class Solution {\\n        struct Seg {\\n            int start[2], end[2];\\n            Seg(int a[], int b[]) {\\n                start[0] = a[0];\\n                start[1] = a[1];\\n                end[0] = b[0];\\n                end[1] = b[1];\\n            }\\n            bool Intersect(Seg &other) {\\n                if (this->start[0] == this->end[0]) return other.Intersect(*this);\\n                int left = this->start[0], right = this->end[0];\\n                if (left > right) swap(left, right);\\n                int up = other.start[1], down = other.end[1];\\n                if (up < down) swap(up, down);\\n                return this->start[1] >= down && this->start[1] <= up &&\\n                       other.start[0] >= left && other.start[0] <= right;\\n            }\\n        };\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            deque<Seg> segs[2];\\n            int cur[2] = {0, 0};\\n            int direction = 0;\\n            int move[4][2] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n            for (int step: x) {\\n                int next[2];\\n                next[0] = cur[0] + step * move[direction][0];\\n                next[1] = cur[1] + step * move[direction][1];\\n                if (next[0] == next[1] && next[1] == 0) return true;\\n                Seg seg(cur, next);\\n                if (segs[1-(direction%2)].size() >= 2 && seg.Intersect(segs[1-(direction%2)][0])) return true;\\n                if (segs[1-(direction%2)].size() >= 3 && seg.Intersect(segs[1-(direction%2)][1])) return true;\\n                segs[direction%2].push_back(seg);\\n                if (segs[direction%2].size() > 3) segs[direction%2].pop_front();\\n                direction = (direction + 1) % 4;\\n                cur[0] = next[0];\\n                cur[1] = next[1];\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        struct Seg {\\n            int start[2], end[2];\\n            Seg(int a[], int b[]) {\\n                start[0] = a[0];\\n                start[1] = a[1];\\n                end[0] = b[0];\\n                end[1] = b[1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3231786,
                "title": "explained-c-o-n-time-and-o-1-space-beats-99-on-time-and-memory-spiral-approach",
                "content": "# Intuition\\nYou have to realize that this is spiral movement. There can be two kinds of spiral movement. One in which the spiral can keep growing outward. Each move is larger than the previous and we spiral outward. The other is inward sprial.\\n\\nOutward spiral can go transition to invard spiral if one of the moves is not large enough. Inward spiral can never become an outward spiral.\\n\\n# Approach\\n\\nAfter first 3 moves, you have to see if this is going to start as an outward spiral or inward spiral. Handle outward spiral first. Break out of the movement loop if we transition to inward spiral. Then handle inward spiral.\\n\\nAt all times, we keep track of our walls on left, up, right and down side. We need to check against these walls based on the kind of spiral we are in.\\n\\nWhen we transition from outward to inward spiral we need to carefully adjust one of the walls (see code).\\n\\nWe need to handle an edge case of visiting (0, 0) **on** the 5th move since this walls approach doesn\\'t handle that.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n#include <assert.h>\\n\\nstatic const int xMove[4] = {0, -1, 0, 1};\\nstatic const int yMove[4] = {1, 0, -1, 0};\\n\\nvoid move(int& x, int& y, int dis, int& cur) {\\n    x += xMove[cur] * dis;\\n    y += yMove[cur] * dis;\\n    cur = (cur+1)%4;\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int x = 0, y = 0, cur = 0, i = 0, n = distance.size();\\n        if (n <= 3) return false;\\n\\n        int limits[4]; // right, up, left, down\\n        limits[cur] = 0;\\n        move(x, y, distance[i++], cur); // moved up.\\n        limits[cur] = y;\\n        move(x, y, distance[i++], cur); // moved left.\\n        limits[cur] = x;\\n        move(x, y, distance[i++], cur); // moved down.\\n        limits[cur] = y;\\n        if (y < 0) {\\n            // Outward spiral. We can\\'t hit limits here.\\n            while (i < n) {\\n                move(x, y, distance[i++], cur);\\n                // Did we move past our limit?\\n                bool inward = false;\\n                switch (cur) {\\n                    case 0: // moved right.\\n                        inward = x <= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 1: // moved up.\\n                        inward = y <= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    case 2: // moved left.\\n                        inward = x >= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 3: // moved down.\\n                        inward = y >= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    default:\\n                        assert(false);\\n                }\\n                if (inward) {\\n                    // Correct the limits.\\n                    if (i > 4) {\\n                        switch (cur) {\\n                            case 0: // moved right.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y + distance[i-2] - distance[i-4];\\n                                break;\\n                            case 1: // moved up.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 2: // moved left.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 3: // moved down.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x + distance[i-2] - distance[i-4];\\n                                break;\\n                            default:\\n                                assert(false);\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        // Inward spiral.\\n        while (i < n) {\\n            move(x, y, distance[i++], cur);\\n            // Did we move past our limit?\\n            bool crossed = false;\\n            switch (cur) {\\n                case 0: // moved right.\\n                    crossed = x >= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 1: // moved up.\\n                    crossed = y >= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                case 2: // moved left.\\n                    crossed = x <= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 3: // moved down.\\n                    crossed = y <= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                default:\\n                    assert(false);\\n            }\\n            if (crossed) return true;\\n            if (x == 0 && y == 0) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <assert.h>\\n\\nstatic const int xMove[4] = {0, -1, 0, 1};\\nstatic const int yMove[4] = {1, 0, -1, 0};\\n\\nvoid move(int& x, int& y, int dis, int& cur) {\\n    x += xMove[cur] * dis;\\n    y += yMove[cur] * dis;\\n    cur = (cur+1)%4;\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int x = 0, y = 0, cur = 0, i = 0, n = distance.size();\\n        if (n <= 3) return false;\\n\\n        int limits[4]; // right, up, left, down\\n        limits[cur] = 0;\\n        move(x, y, distance[i++], cur); // moved up.\\n        limits[cur] = y;\\n        move(x, y, distance[i++], cur); // moved left.\\n        limits[cur] = x;\\n        move(x, y, distance[i++], cur); // moved down.\\n        limits[cur] = y;\\n        if (y < 0) {\\n            // Outward spiral. We can\\'t hit limits here.\\n            while (i < n) {\\n                move(x, y, distance[i++], cur);\\n                // Did we move past our limit?\\n                bool inward = false;\\n                switch (cur) {\\n                    case 0: // moved right.\\n                        inward = x <= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 1: // moved up.\\n                        inward = y <= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    case 2: // moved left.\\n                        inward = x >= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 3: // moved down.\\n                        inward = y >= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    default:\\n                        assert(false);\\n                }\\n                if (inward) {\\n                    // Correct the limits.\\n                    if (i > 4) {\\n                        switch (cur) {\\n                            case 0: // moved right.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y + distance[i-2] - distance[i-4];\\n                                break;\\n                            case 1: // moved up.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 2: // moved left.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 3: // moved down.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x + distance[i-2] - distance[i-4];\\n                                break;\\n                            default:\\n                                assert(false);\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        // Inward spiral.\\n        while (i < n) {\\n            move(x, y, distance[i++], cur);\\n            // Did we move past our limit?\\n            bool crossed = false;\\n            switch (cur) {\\n                case 0: // moved right.\\n                    crossed = x >= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 1: // moved up.\\n                    crossed = y >= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                case 2: // moved left.\\n                    crossed = x <= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 3: // moved down.\\n                    crossed = y <= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                default:\\n                    assert(false);\\n            }\\n            if (crossed) return true;\\n            if (x == 0 && y == 0) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2960837,
                "title": "python-95-no-math-just-space-for-time-make-it-an-easy-problem",
                "content": "# Intuition\\r\\nSince the problem scale is not very large, why not exchange space for time?\\r\\n\\r\\n# Approach\\r\\nkeep track of every single points we pass throught\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(nm)$$\\r\\n\\r\\n- Space complexity:\\r\\n$$O(nm)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nfrom operator import sub\\r\\nMOVE = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\r\\nclass Solution:\\r\\n    def isSelfCrossing(self, distance):\\r\\n        return self.space_4_time(distance)\\r\\n\\r\\n    def space_4_time(self, distance):\\r\\n        if all(map(sub, distance[1:], distance[:-1])): return False  # spiral out\\r\\n\\r\\n        pos, visit = (0, 0), set([(0, 0)])\\r\\n\\r\\n        for idx, length in enumerate(distance):\\r\\n            dx, dy = MOVE[idx % 4]  # 0n1w2s3e\\r\\n            for _ in range(length):\\r\\n                pos = (pos[0] + dx, pos[1] + dy)\\r\\n                if pos in visit: return True\\r\\n                visit.add(pos)\\r\\n        return False\\r\\n\\r\\n    def math(self, x):\\r\\n        \\'\\'\\' it\\'s not about coordinates, it\\'s only about previous six line\\'s length \\'\\'\\'\\r\\n        L = len(x)\\r\\n        if L < 4: return False\\r\\n\\r\\n        l1, l2, l3, l4, l5, l6 = x[2], x[1], x[0], 0, 0, 0\\r\\n        for i in range(3, L):\\r\\n            l1, l2, l3, l4, l5, l6 = x[i], l1, l2, l3, l4, l5  # rotation to get equivalent six line\\r\\n\\r\\n            if l4 >= l2 and l1 >= l3: return True  # 4 lines, shape like: \\'4\\'\\r\\n            if l4 == l2 and (l1 + l5) >= l3: return True  # 5 lines, shape like: \\'O\\'\\r\\n            if (l6 + l2) >= l4 >= l2 and (l5 + l1) >= l3 >= l5: return True  # 6 lines, shape like \\'L\\'\\r\\n        return False\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\r\\nfrom operator import sub\\r\\nMOVE = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\r\\nclass Solution:\\r\\n    def isSelfCrossing(self, distance):\\r\\n        return self.space_4_time(distance)\\r\\n\\r\\n    def space_4_time(self, distance):\\r\\n        if all(map(sub, distance[1:], distance[:-1])): return False  # spiral out\\r\\n\\r\\n        pos, visit = (0, 0), set([(0, 0)])\\r\\n\\r\\n        for idx, length in enumerate(distance):\\r\\n            dx, dy = MOVE[idx % 4]  # 0n1w2s3e\\r\\n            for _ in range(length):\\r\\n                pos = (pos[0] + dx, pos[1] + dy)\\r\\n                if pos in visit: return True\\r\\n                visit.add(pos)\\r\\n        return False\\r\\n\\r\\n    def math(self, x):\\r\\n        \\'\\'\\' it\\'s not about coordinates, it\\'s only about previous six line\\'s length \\'\\'\\'\\r\\n        L = len(x)\\r\\n        if L < 4: return False\\r\\n\\r\\n        l1, l2, l3, l4, l5, l6 = x[2], x[1], x[0], 0, 0, 0\\r\\n        for i in range(3, L):\\r\\n            l1, l2, l3, l4, l5, l6 = x[i], l1, l2, l3, l4, l5  # rotation to get equivalent six line\\r\\n\\r\\n            if l4 >= l2 and l1 >= l3: return True  # 4 lines, shape like: \\'4\\'\\r\\n            if l4 == l2 and (l1 + l5) >= l3: return True  # 5 lines, shape like: \\'O\\'\\r\\n            if (l6 + l2) >= l4 >= l2 and (l5 + l1) >= l3 >= l5: return True  # 6 lines, shape like \\'L\\'\\r\\n        return False\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517599,
                "title": "python-three-cases",
                "content": "This is an implementation of a solution provided [here](https://leetcode.com/problems/self-crossing/discuss/79141/Another-python...).\\n\\n**Solution**:\\nBelow are three configurations such that a series of lines will cross itself. The orentiation doesn\\'t of lines does not matter. Thus, check if a series of lines match one of the three configurations. If yes, return True. Else, continue to the next line.\\n\\n```\\n    Case 1                  Case 2                  Case 2\\n                c                       d                       e\\n       +----------------+      +----------------+      +----------------+\\n       |                |      |                |      |                |\\n       |                |      |                |      |                |\\n     b |                | d  c |                | e  d |                | f\\n       |                |      |                |      |                |    a\\n       +--------------->|      |                |      |                | <----+\\n                a       |      |                ^ a    |                |      | b\\n                               |                |      |                       |\\n                               +----------------+      +-----------------------+\\n                                        b                       c\\n```\\n\\n**Complexity**:\\n    Time: O(n)\\n    Space: O(1)\\n\\t\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: list[int]) -> bool:\\n\\n        # Initialize the latest 6 lines to 0\\n        a = b = c = d = e = f = 0\\n\\n        for n in distance:\\n            f, e, d, c, b, a = e, d, c, b, a, n\\n\\n            # Case 1: 4 lines configuration that can cross iself\\n            if d > 0 and c <= a and b <= d:\\n                return True\\n\\n            # Case 2: 5 lines configuration that can cross iself\\n            if e > 0 and b == d and c <= a + e:\\n                return True\\n\\n            # Case 3: 6 lines configuration that can cross iself\\n            if (\\n                f > 0\\n                and c >= a\\n                and c >= e\\n                and c <= a + e\\n                and d >= b\\n                and d >= f\\n                and d <= b + f\\n            ):\\n                return True\\n                \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    Case 1                  Case 2                  Case 2\\n                c                       d                       e\\n       +----------------+      +----------------+      +----------------+\\n       |                |      |                |      |                |\\n       |                |      |                |      |                |\\n     b |                | d  c |                | e  d |                | f\\n       |                |      |                |      |                |    a\\n       +--------------->|      |                |      |                | <----+\\n                a       |      |                ^ a    |                |      | b\\n                               |                |      |                       |\\n                               +----------------+      +-----------------------+\\n                                        b                       c\\n```\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: list[int]) -> bool:\\n\\n        # Initialize the latest 6 lines to 0\\n        a = b = c = d = e = f = 0\\n\\n        for n in distance:\\n            f, e, d, c, b, a = e, d, c, b, a, n\\n\\n            # Case 1: 4 lines configuration that can cross iself\\n            if d > 0 and c <= a and b <= d:\\n                return True\\n\\n            # Case 2: 5 lines configuration that can cross iself\\n            if e > 0 and b == d and c <= a + e:\\n                return True\\n\\n            # Case 3: 6 lines configuration that can cross iself\\n            if (\\n                f > 0\\n                and c >= a\\n                and c >= e\\n                and c <= a + e\\n                and d >= b\\n                and d >= f\\n                and d <= b + f\\n            ):\\n                return True\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152629,
                "title": "no-memory-o-n-3",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance)<4:\\n            return False\\n        for d in range(3,len(distance)):\\n            if (distance[d-1]-distance[d-3]<1 and distance[d]>=distance[d-2]) or (d>3 and distance[d-1]-distance[d-3]==0 and distance[d]+distance[d-4]>=distance[d-2]) or (d>4 and distance[d-1]+distance[d-5]>=distance[d-3] and distance[d-1]<=distance[d-3] and distance[d]+distance[d-4]>=distance[d-2] and distance[d-2]>=distance[d-4]):\\n                return True\\n        return False\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance)<4:\\n            return False\\n        for d in range(3,len(distance)):\\n            if (distance[d-1]-distance[d-3]<1 and distance[d]>=distance[d-2]) or (d>3 and distance[d-1]-distance[d-3]==0 and distance[d]+distance[d-4]>=distance[d-2]) or (d>4 and distance[d-1]+distance[d-5]>=distance[d-3] and distance[d-1]<=distance[d-3] and distance[d]+distance[d-4]>=distance[d-2] and distance[d-2]>=distance[d-4]):\\n                return True\\n        return False\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1959315,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    class Solution {\\n\\n    public boolean isSelfCrossing(int[] x) {\\n\\tboolean arm = false;\\n\\tboolean leg = false;\\n    for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n\\t}\\n\\treturn false;\\n\\t}\\n\\tprivate int f(int[] x, int index) {\\n\\treturn (index < 0) ? 0 : x[index];\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean isSelfCrossing(int[] x) {\\n\\tboolean arm = false;\\n\\tboolean leg = false;\\n    for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1566430,
                "title": "16ms-18mb-o-n-solution-with-explanations",
                "content": "This problem drove me crazy, so much time spent on it :) The solution could be more generic but It works in linear time... The idea is to start by incrementing `i` until the path stops to expand. Then, there is three cases :\\n* 1)  `i` is less than `4`. Then we just have to verify the the distances are decreasing. For example :\\n\\n```text\\n__ __ __\\n|      |\\n       |\\n\\t   *\\n\\t   \\nwhere * is the origin\\n```\\nHere, the distance stops to increase at `i = 2`. The only possibility that there is a self-crossing therefore is that `distance[i - 2] < distance[i]`\\n* 2) I added a special case for the loop path cases if `i == 4`...\\n* 3) To understand the last case, see following image. This is a bit tricky and not so elegant, I have to admit  :\\n![image](https://user-images.githubusercontent.com/36661586/140738703-18ab1c6f-c874-467f-a04d-620143b0bf1e.png)\\nHere, the distances stop to increase at `i = 10`. Then we check that the next segment does not cross the \"first spiral\". If so, we are back with the same logic as the first case and check that the distances are decreasing..\\n\\nI know the code could be better, but I hope it may be helpful :)\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n    \\n        int n = distance.size(); \\n        \\n        // no chance that there is a self crossing if less than 3 segments\\n        if(n < 2) return false;\\n        \\n        // increment i as long as distance increases (spiral)\\n        int i = 2;\\n        while(i < n && distance[i] >= distance[i - 2]) i++;\\n        \\n        // since distance is no more increasing, it has to decrease\\n        if(i < 4) {\\n            \\n            while(i < n && distance[i] < distance[i - 2]) i++;\\n            \\n            if(i != n) return true;\\n            \\n        } else {\\n            \\n            // in case of loop path that returns to (0, 0)\\n            if(n == 4) {\\n                \\n                if(distance[i - 1] == distance[i - 3] && distance[i - 2] == distance[i - 4]) return true;\\n                \\n            } else {\\n            \\n                if(i < n - 1) i++;\\n\\n                if(i < n && distance[i - 2] - distance[i - 4] <= distance[i]) {\\n                    \\n                    if(i >= 5) {\\n                        \\n                        if(distance[i - 3] - distance[i - 1] <= distance[i - 5]) {\\n                            return true;\\n                        }\\n                        \\n                    } else {\\n                        return true;\\n                    }\\n                }\\n\\n                // same logic, distances have to decrease\\n                while(i < n && distance[i] < distance[i - 2]) i++;\\n                if(i != n)  \\n                    return true;                 \\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```text\\n__ __ __\\n|      |\\n       |\\n\\t   *\\n\\t   \\nwhere * is the origin\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n    \\n        int n = distance.size(); \\n        \\n        // no chance that there is a self crossing if less than 3 segments\\n        if(n < 2) return false;\\n        \\n        // increment i as long as distance increases (spiral)\\n        int i = 2;\\n        while(i < n && distance[i] >= distance[i - 2]) i++;\\n        \\n        // since distance is no more increasing, it has to decrease\\n        if(i < 4) {\\n            \\n            while(i < n && distance[i] < distance[i - 2]) i++;\\n            \\n            if(i != n) return true;\\n            \\n        } else {\\n            \\n            // in case of loop path that returns to (0, 0)\\n            if(n == 4) {\\n                \\n                if(distance[i - 1] == distance[i - 3] && distance[i - 2] == distance[i - 4]) return true;\\n                \\n            } else {\\n            \\n                if(i < n - 1) i++;\\n\\n                if(i < n && distance[i - 2] - distance[i - 4] <= distance[i]) {\\n                    \\n                    if(i >= 5) {\\n                        \\n                        if(distance[i - 3] - distance[i - 1] <= distance[i - 5]) {\\n                            return true;\\n                        }\\n                        \\n                    } else {\\n                        return true;\\n                    }\\n                }\\n\\n                // same logic, distances have to decrease\\n                while(i < n && distance[i] < distance[i - 2]) i++;\\n                if(i != n)  \\n                    return true;                 \\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236841,
                "title": "worked-but-couldn-t-pass-the-time-limit-exceeded",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        directions = [\\'up\\', \\'left\\', \\'down\\', \\'right\\']\\n        dirIndex = 0\\n        points = [[0,0]]\\n        count = 0\\n        for i in range(len(distance)):\\n            newPoint_x = points[len(points)-1][0]\\n            newPoint_y = points[len(points)-1][1]\\n            for j in range(distance[i]):\\n                if i % 4 == 0:\\n                    count += 1\\n                if directions[dirIndex] == \\'up\\':\\n                    newPoint_x += 1\\n                elif directions[dirIndex] == \\'left\\':\\n                    newPoint_y -= 1\\n                elif directions[dirIndex] == \\'down\\':\\n                    newPoint_x -= 1\\n                elif directions[dirIndex] == \\'right\\':\\n                    newPoint_y += 1\\n                newPoint = [newPoint_x, newPoint_y]\\n                for point in points:\\n                    if newPoint == point:\\n                        return True\\n                points.append(newPoint)\\n            if i != 0 and i % 3 == 0:\\n                points = points[count-1:]\\n                count = 0\\n            dirIndex += 1\\n            if dirIndex == len(directions):\\n                dirIndex = 0\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        directions = [\\'up\\', \\'left\\', \\'down\\', \\'right\\']\\n        dirIndex = 0\\n        points = [[0,0]]\\n        count = 0\\n        for i in range(len(distance)):\\n            newPoint_x = points[len(points)-1][0]\\n            newPoint_y = points[len(points)-1][1]\\n            for j in range(distance[i]):\\n                if i % 4 == 0:\\n                    count += 1\\n                if directions[dirIndex] == \\'up\\':\\n                    newPoint_x += 1\\n                elif directions[dirIndex] == \\'left\\':\\n                    newPoint_y -= 1\\n                elif directions[dirIndex] == \\'down\\':\\n                    newPoint_x -= 1\\n                elif directions[dirIndex] == \\'right\\':\\n                    newPoint_y += 1\\n                newPoint = [newPoint_x, newPoint_y]\\n                for point in points:\\n                    if newPoint == point:\\n                        return True\\n                points.append(newPoint)\\n            if i != 0 and i % 3 == 0:\\n                points = points[count-1:]\\n                count = 0\\n            dirIndex += 1\\n            if dirIndex == len(directions):\\n                dirIndex = 0\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062118,
                "title": "c-breaking-down-the-loops-into-expanding-and-contracting-modes",
                "content": "We have two modes to keep track of. Initially, we are in the expanding mode and we stay in this mode as long as the previous move in the same axis is shorter than the current mode.\\nThe other is the contracting mode. When changing modes, one thing is important to note: If the current move is shorter than the difference of the two previous moves in the same axis, the upper limit in the perpendicular axis is the length of the last move, otherwise it is the difference of the previous moves.\\n\\nCase 1:\\n```txt\\n_________ \\n|        |\\n|\\n|           |\\n|___________| \\n^           ^\\nThe range between the arrows is the limit\\n```\\n\\nCase 2:\\n```txt\\n_________ \\n|        |\\n|        |  |\\n|           |\\n|___________| \\n         ^  ^\\nThe range between the arrows is the limit\\n```\\n\\nIn the contracting mode, the length of the current move has to be strictly less than the previous move in the same axis to not self intersect.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x)\\n    {\\n        array prev = {0, 0};\\n        array diff = {0, 0};\\n        auto i = x.begin();\\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i < diff[0])\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else if (*i <= prev[0])\\n            {\\n                prev[0] = diff[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else\\n            {\\n                diff[0] = diff[1];\\n                diff[1] = *i - prev[0];\\n                prev[0] = prev[1];\\n                prev[1] = *i;\\n            }\\n        }\\n        \\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i >= prev[0])\\n                return true;\\n            else\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i;                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```txt\\n_________ \\n|        |\\n|\\n|           |\\n|___________| \\n^           ^\\nThe range between the arrows is the limit\\n```\n```txt\\n_________ \\n|        |\\n|        |  |\\n|           |\\n|___________| \\n         ^  ^\\nThe range between the arrows is the limit\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x)\\n    {\\n        array prev = {0, 0};\\n        array diff = {0, 0};\\n        auto i = x.begin();\\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i < diff[0])\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else if (*i <= prev[0])\\n            {\\n                prev[0] = diff[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else\\n            {\\n                diff[0] = diff[1];\\n                diff[1] = *i - prev[0];\\n                prev[0] = prev[1];\\n                prev[1] = *i;\\n            }\\n        }\\n        \\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i >= prev[0])\\n                return true;\\n            else\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i;                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965541,
                "title": "python3-with-explanation-clear-naming",
                "content": "Keep at most previous 5 edges will be able to decide the state of collision of the currect node.\\ncorner case: same direction, collide with (0,0); which can only happen during the fifth step\\nwhen deal with two cross lines, need to handle \"equal senarios\" carefully\\n```\\nclass Solution:\\n    \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        # corner cases [2,1,1,2], was missed in the first attempt\\n        # perpendicular lines crossing, didn\\'t handle equal cases well initially\\n        length = len(x)\\n        self.i = 0 # west east\\n        self.j = 0 # north south\\n        if length < 4:\\n            return False\\n        self.edge_list = []\\n        self.max_count_edge = 5\\n        for index in range(0, length):\\n            [new_i, new_j] = self.getNewPoint(index, x[index])\\n            if self.checkConflict([self.i, self.j], [new_i, new_j]):\\n                return True\\n            self.move(new_i, new_j)\\n        return False\\n    def checkConflict(self, start, end):\\n        length = len(self.edge_list)\\n        if length < 3:\\n            return False\\n        if length == 4:\\n            edge_to_check = self.edge_list[0]\\n            if start[0] == 0 and end[1] >= edge_to_check[0][0] and end[1] <= edge_to_check[0][1]:\\n                return True\\n        for i in [length - 3, length - 5]:\\n            if i < 0:\\n                break\\n            edge_to_check = self.edge_list[i]\\n            if self.checkEdgeConflict([start, end], edge_to_check):\\n                return True\\n        return False\\n    def checkEdgeConflict(self, cur_edge, edge_to_check):\\n        # cur_edge[0][0] and cur_edge[1][0] vs edge_to_check[0][0]\\n        flag_x_inbetween = (not ((cur_edge[0][0]>edge_to_check[0][0]) == (cur_edge[1][0]>edge_to_check[1][0]))) or (cur_edge[0][0]==edge_to_check[0][0]) or (cur_edge[1][0]==edge_to_check[1][0])\\n        flag_y_inbetween = (not ((cur_edge[0][1]>edge_to_check[0][1]) == (cur_edge[1][1]>edge_to_check[1][1]))) or (cur_edge[0][1]==edge_to_check[0][1]) or (cur_edge[1][1]==edge_to_check[1][1])\\n        return flag_x_inbetween and flag_y_inbetween\\n    def getNewPoint(self, index, step) :\\n        new_i = self.i\\n        new_j = self.j\\n        if index%4 == 0:\\n            new_j = self.j + step\\n        if index%4 == 1:\\n            new_i = self.i - step\\n        if index%4 == 2:\\n            new_j = self.j - step\\n        if index%4 == 3:\\n            new_i = self.i + step\\n        return [new_i, new_j]\\n    def move(self, new_i, new_j) :\\n        self.addEdge([self.i, self.j], [new_i, new_j])\\n        self.i = new_i\\n        self.j = new_j\\n    def addEdge(self, start, end):\\n        self.edge_list.append([start, end])\\n        if len(self.edge_list) > self.max_count_edge:\\n            self.edge_list.pop(0)\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        # corner cases [2,1,1,2], was missed in the first attempt\\n        # perpendicular lines crossing, didn\\'t handle equal cases well initially\\n        length = len(x)\\n        self.i = 0 # west east\\n        self.j = 0 # north south\\n        if length < 4:\\n            return False\\n        self.edge_list = []\\n        self.max_count_edge = 5\\n        for index in range(0, length):\\n            [new_i, new_j] = self.getNewPoint(index, x[index])\\n            if self.checkConflict([self.i, self.j], [new_i, new_j]):\\n                return True\\n            self.move(new_i, new_j)\\n        return False\\n    def checkConflict(self, start, end):\\n        length = len(self.edge_list)\\n        if length < 3:\\n            return False\\n        if length == 4:\\n            edge_to_check = self.edge_list[0]\\n            if start[0] == 0 and end[1] >= edge_to_check[0][0] and end[1] <= edge_to_check[0][1]:\\n                return True\\n        for i in [length - 3, length - 5]:\\n            if i < 0:\\n                break\\n            edge_to_check = self.edge_list[i]\\n            if self.checkEdgeConflict([start, end], edge_to_check):\\n                return True\\n        return False\\n    def checkEdgeConflict(self, cur_edge, edge_to_check):\\n        # cur_edge[0][0] and cur_edge[1][0] vs edge_to_check[0][0]\\n        flag_x_inbetween = (not ((cur_edge[0][0]>edge_to_check[0][0]) == (cur_edge[1][0]>edge_to_check[1][0]))) or (cur_edge[0][0]==edge_to_check[0][0]) or (cur_edge[1][0]==edge_to_check[1][0])\\n        flag_y_inbetween = (not ((cur_edge[0][1]>edge_to_check[0][1]) == (cur_edge[1][1]>edge_to_check[1][1]))) or (cur_edge[0][1]==edge_to_check[0][1]) or (cur_edge[1][1]==edge_to_check[1][1])\\n        return flag_x_inbetween and flag_y_inbetween\\n    def getNewPoint(self, index, step) :\\n        new_i = self.i\\n        new_j = self.j\\n        if index%4 == 0:\\n            new_j = self.j + step\\n        if index%4 == 1:\\n            new_i = self.i - step\\n        if index%4 == 2:\\n            new_j = self.j - step\\n        if index%4 == 3:\\n            new_i = self.i + step\\n        return [new_i, new_j]\\n    def move(self, new_i, new_j) :\\n        self.addEdge([self.i, self.j], [new_i, new_j])\\n        self.i = new_i\\n        self.j = new_j\\n    def addEdge(self, start, end):\\n        self.edge_list.append([start, end])\\n        if len(self.edge_list) > self.max_count_edge:\\n            self.edge_list.pop(0)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 892944,
                "title": "very-clear-and-short-python-solution",
                "content": "Only spiral expanding and spiral contracting pattern could maintain this spiral line not self crossing, and the state transition relation is \\n```\\n`spiral expanding` -> `spiral contracting`->`self crossing`\\n   |^|______|               |^|______| \\n   \\n```\\nwe only need to remember past 4 moves and denote the origin at start as 4 zero moves to avoid discussing nasty special cases\\n\\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        q = deque([0,0,0,0])\\n        contract = False\\n        for x in arr:\\n            if contract:\\n                if x >= q[-2]:\\n                    return True\\n            else:\\n                if x <= q[-2]:\\n                    if x >= q[-2] - q[-4]:\\n                        q[-1] -= q[-3]\\n                    contract = True\\n            q.append(x)\\n            if len(q) > 4:\\n                q.popleft()\\n        return False\\n```\\n\\nwe can futher optimize the implementation without queue operations\\n\\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        contract = False\\n        n = len(arr)\\n        arr.extend([0,0,0,0])\\n        for i, x in enumerate(arr):\\n            if i == n:\\n                break\\n            if contract:\\n                if x >= arr[i-2]:\\n                    return True\\n            else:\\n                if x <= arr[i-2]:\\n                    if x >= arr[i-2] - arr[i-4]:\\n                        arr[i-1] -= arr[i-3]\\n                    contract = True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n`spiral expanding` -> `spiral contracting`->`self crossing`\\n   |^|______|               |^|______| \\n   \\n```\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        q = deque([0,0,0,0])\\n        contract = False\\n        for x in arr:\\n            if contract:\\n                if x >= q[-2]:\\n                    return True\\n            else:\\n                if x <= q[-2]:\\n                    if x >= q[-2] - q[-4]:\\n                        q[-1] -= q[-3]\\n                    contract = True\\n            q.append(x)\\n            if len(q) > 4:\\n                q.popleft()\\n        return False\\n```\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        contract = False\\n        n = len(arr)\\n        arr.extend([0,0,0,0])\\n        for i, x in enumerate(arr):\\n            if i == n:\\n                break\\n            if contract:\\n                if x >= arr[i-2]:\\n                    return True\\n            else:\\n                if x <= arr[i-2]:\\n                    if x >= arr[i-2] - arr[i-4]:\\n                        arr[i-1] -= arr[i-3]\\n                    contract = True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888803,
                "title": "cpp-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if(x.size() < 4)\\n            return false;\\n        \\n        for(int i = 3; i < x.size(); i++) {\\n            if(x[i] >= x[i-2] and x[i-1] <= x[i-3])\\n                return true;\\n            if(i >= 4) {\\n                if(x[i-1] == x[i-3] and x[i] >= x[i-2]-x[i-4])\\n                    return true;\\n            }\\n            if(i >= 5) {\\n                if(x[i-2]-x[i-4] >= 0 and x[i] >= x[i-2]-x[i-4] and\\n                   x[i-1] >= x[i-3]-x[i-5] and x[i-1] <= x[i-3]) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if(x.size() < 4)\\n            return false;\\n        \\n        for(int i = 3; i < x.size(); i++) {\\n            if(x[i] >= x[i-2] and x[i-1] <= x[i-3])\\n                return true;\\n            if(i >= 4) {\\n                if(x[i-1] == x[i-3] and x[i] >= x[i-2]-x[i-4])\\n                    return true;\\n            }\\n            if(i >= 5) {\\n                if(x[i-2]-x[i-4] >= 0 and x[i] >= x[i-2]-x[i-4] and\\n                   x[i-1] >= x[i-3]-x[i-5] and x[i-1] <= x[i-3]) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726245,
                "title": "python-top-80-speed-o-n-time-o-1-space-dimensionless-coordinates",
                "content": "**Python - Top 80% Speed - O(n) time, O(1) space - Dimensionless Coordinates**\\n\\nThe code below uses Dimensionless Coordinates (p,q) to detect collisions with walls. The solution is fairly efficient/valid, but the conversions between Coordinate Systems can be tedious.\\n\\n```\\ndef point_intersection(qa0,qb0,pc0,walls):\\n    for qa,qb,pc in walls[1:]:\\n        if pc0==pc:\\n            if qa<=qa0<=qb or qa<=qb0<=qb:\\n                return True\\n    return False\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        if len(A)<4:\\n            return False\\n        i,j = 0,0\\n        di,dj = 0,1\\n        iwalls, jwalls = [ [posInf]*3 for _ in range(3)], [ [posInf]*3 for _ in range(3)]\\n        for x in A:\\n            i0,j0 = i,j\\n            i += di*x\\n            j += dj*x\\n            #\\n            if di: # di: p,q = i,j\\n                q,p1,p2 = j, min(i0,i),max(i0,i)\\n                walls = iwalls[1:]\\n            else: # dj: p,q = j,i\\n                q,p1,p2 = i, min(j0,j),max(j0,j)\\n                walls = jwalls[1:]\\n            # Wall Collision Detector\\n            for qa,qb,pc in walls:\\n                if qa<=q<=qb and p1<=pc<=p2:\\n                    return True\\n            # Point Collision Detector\\n            parallels = iwalls if dj else jwalls\\n            if point_intersection(p1,p2,q, parallels ):\\n                return True\\n            # Build New Walls ( dj movements span horizontal walls (iwalls) )\\n            if dj:\\n                iwalls = [ [p1,p2,q], *iwalls[:-1] ]\\n            else:\\n                jwalls = [ [p1,p2,q], *jwalls[:-1] ]\\n            di,dj = -dj,di\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef point_intersection(qa0,qb0,pc0,walls):\\n    for qa,qb,pc in walls[1:]:\\n        if pc0==pc:\\n            if qa<=qa0<=qb or qa<=qb0<=qb:\\n                return True\\n    return False\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        if len(A)<4:\\n            return False\\n        i,j = 0,0\\n        di,dj = 0,1\\n        iwalls, jwalls = [ [posInf]*3 for _ in range(3)], [ [posInf]*3 for _ in range(3)]\\n        for x in A:\\n            i0,j0 = i,j\\n            i += di*x\\n            j += dj*x\\n            #\\n            if di: # di: p,q = i,j\\n                q,p1,p2 = j, min(i0,i),max(i0,i)\\n                walls = iwalls[1:]\\n            else: # dj: p,q = j,i\\n                q,p1,p2 = i, min(j0,j),max(j0,j)\\n                walls = jwalls[1:]\\n            # Wall Collision Detector\\n            for qa,qb,pc in walls:\\n                if qa<=q<=qb and p1<=pc<=p2:\\n                    return True\\n            # Point Collision Detector\\n            parallels = iwalls if dj else jwalls\\n            if point_intersection(p1,p2,q, parallels ):\\n                return True\\n            # Build New Walls ( dj movements span horizontal walls (iwalls) )\\n            if dj:\\n                iwalls = [ [p1,p2,q], *iwalls[:-1] ]\\n            else:\\n                jwalls = [ [p1,p2,q], *jwalls[:-1] ]\\n            di,dj = -dj,di\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682848,
                "title": "java-1ms-12-some-explanation",
                "content": "I had to learn how two points intersect in order to do this solution, i have followed the intersection formula here https://www.g e e k s for g e e k s.org/check-if-two-given-line-segments-intersect/ and here https://www.***.org/orientation-3-ordered-points/. \\nThis video helped a little as well https://www.youtube.com/watch?v=wCR48FqkI4w&feature=emb_title\\n\\nOnce you know how to find the intersection of the two lines, the logic is easy to figure. \\n\\nScenarios I thought about\\n1.Intersection as per the example\\n\\u250C\\u2500\\u2500\\u2500\\u2510\\n \\u2502              \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500>\\n                \\u2502\\n\\n2. Collenear\\n\\u250C\\u2500\\u2500\\u2500\\u2510----|\\n \\u2502              \\u2502        |\\n\\u2514\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500|\\n\\n3. No intersection\\n   --------------|\\n\\u250C\\u2500\\u2500\\u2500\\u2510        |\\n \\u2502               \\u2502         |\\n\\u2514\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500|\\n    \\n\\n```\\nclass Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int max = 6;\\n\\n            LinkedList<Point> points = new LinkedList<>();\\n            Point prev = new Point(0, 0);\\n            points.add(prev);\\n\\n            for (int i = 0; i < x.length; i++) {\\n                Point curr;\\n                if (i % 4 == 0) {\\n                    curr = new Point(prev.x - x[i], prev.y);\\n                } else if (i % 4 == 1) {\\n                    curr = new Point(prev.x, prev.y - x[i]);\\n                } else if (i % 4 == 2) {\\n                    curr = new Point(prev.x + x[i], prev.y);\\n                } else {\\n                    curr = new Point(prev.x, prev.y + x[i]);\\n                }\\n\\n                if (points.size() > 3) {//first first three points you need not calculate the intersection, needs 4 or more points for calculating intersection\\n                    for (int j = 0; j < 3; j++) {\\n                        if (isIntersect(points.get(j), points.get(j + 1), prev, curr)) {\\n                            return true;\\n                        }\\n                    }\\n\\n                    if (points.size() == max) {\\n                        points.removeFirst();//trying to maintain constant space O(1) by removing old points\\n                    }\\n                }\\n                points.add(curr);\\n                prev = curr;\\n            }\\n            return false;\\n        }\\n\\n\\t//see links above for the formulas\\n        public boolean isIntersect(Point p1, Point q1, Point p2, Point q2) {\\n            if(p2==q1)return false;\\n            int o1 = ori(p1, q1, p2);\\n            int o2 = ori(p1, q1, q2);\\n            int o3 = ori(p2, q2, p1);\\n            int o4 = ori(p2, q2, q1);\\n\\n            if (o1 != o2 && o3 != o4) {\\n                return true;\\n            }\\n\\n            //p1,p2,q1\\n            if (o1 == 0 && onseg(p1, p2, q1)) return true; // If O1 is 0 that means the 3 points are on the same line already, onSeg is trying to see if q1 is in between p1 and p2. If so, it is colleniar\\n            if (o2 == 0 && onseg(p1, q2, q1)) return true;\\n            if (o3 == 0 && onseg(p2, p1, q2)) return true;\\n            if (o4 == 0 && onseg(p2, q1, q2)) return true;\\n\\n            return false;\\n        }\\n\\n        public boolean onseg(Point p, Point q, Point r) {\\n            if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\\n                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y))\\n                return true;\\n\\n            return false;\\n        }\\n\\n        public int ori(Point a, Point b, Point c) {\\n            int val = (b.y - a.y) * (c.x - b.x) - (c.y - b.y) * (b.x - a.x);\\n            if (val == 0) {\\n                return 0;\\n            }\\n            return val < 0 ? 1 : 2;\\n        }\\n\\n        class Point {\\n            int x;\\n            int y;\\n\\n            public Point(int x, int y) {\\n                this.x = x;\\n                this.y = y;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int max = 6;\\n\\n            LinkedList<Point> points = new LinkedList<>();\\n            Point prev = new Point(0, 0);\\n            points.add(prev);\\n\\n            for (int i = 0; i < x.length; i++) {\\n                Point curr;\\n                if (i % 4 == 0) {\\n                    curr = new Point(prev.x - x[i], prev.y);\\n                } else if (i % 4 == 1) {\\n                    curr = new Point(prev.x, prev.y - x[i]);\\n                } else if (i % 4 == 2) {\\n                    curr = new Point(prev.x + x[i], prev.y);\\n                } else {\\n                    curr = new Point(prev.x, prev.y + x[i]);\\n                }\\n\\n                if (points.size() > 3) {//first first three points you need not calculate the intersection, needs 4 or more points for calculating intersection\\n                    for (int j = 0; j < 3; j++) {\\n                        if (isIntersect(points.get(j), points.get(j + 1), prev, curr)) {\\n                            return true;\\n                        }\\n                    }\\n\\n                    if (points.size() == max) {\\n                        points.removeFirst();//trying to maintain constant space O(1) by removing old points\\n                    }\\n                }\\n                points.add(curr);\\n                prev = curr;\\n            }\\n            return false;\\n        }\\n\\n\\t//see links above for the formulas\\n        public boolean isIntersect(Point p1, Point q1, Point p2, Point q2) {\\n            if(p2==q1)return false;\\n            int o1 = ori(p1, q1, p2);\\n            int o2 = ori(p1, q1, q2);\\n            int o3 = ori(p2, q2, p1);\\n            int o4 = ori(p2, q2, q1);\\n\\n            if (o1 != o2 && o3 != o4) {\\n                return true;\\n            }\\n\\n            //p1,p2,q1\\n            if (o1 == 0 && onseg(p1, p2, q1)) return true; // If O1 is 0 that means the 3 points are on the same line already, onSeg is trying to see if q1 is in between p1 and p2. If so, it is colleniar\\n            if (o2 == 0 && onseg(p1, q2, q1)) return true;\\n            if (o3 == 0 && onseg(p2, p1, q2)) return true;\\n            if (o4 == 0 && onseg(p2, q1, q2)) return true;\\n\\n            return false;\\n        }\\n\\n        public boolean onseg(Point p, Point q, Point r) {\\n            if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\\n                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y))\\n                return true;\\n\\n            return false;\\n        }\\n\\n        public int ori(Point a, Point b, Point c) {\\n            int val = (b.y - a.y) * (c.x - b.x) - (c.y - b.y) * (b.x - a.x);\\n            if (val == 0) {\\n                return 0;\\n            }\\n            return val < 0 ? 1 : 2;\\n        }\\n\\n        class Point {\\n            int x;\\n            int y;\\n\\n            public Point(int x, int y) {\\n                this.x = x;\\n                this.y = y;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583129,
                "title": "python-with-detailed-explanation",
                "content": "Please refer to the detailed explanation in the video below.\\nhttps://www.youtube.com/watch?v=ajFikcnQV1I\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        \\n        if not x  or len(x) <= 3:\\n            return False\\n        \\n        n = len(x)\\n        \\n        for i in range(3, n):\\n            # X(0) >= X(2)  X(3) >= X(1)\\n            \\n            if x[i-3] >= x[i-1] and x[i] >= x[i-2]:\\n                return True\\n            \\n            # X(1) == X(3)  X(0) + X(4) >= X(2)\\n            if i >= 4 and x[i-3] == x[i-1] and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n            # X(3) >= X(1) X(2) >= X(4) X(0) + X(4) >=X(2)    X(1) + X(5) >= X(3)\\n            if i >= 5 and x[i-2] >= x[i-4] and x[i-3] >= x[i-1] and (x[i-5] + x[i-1] >= x[i-3]) and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        \\n        if not x  or len(x) <= 3:\\n            return False\\n        \\n        n = len(x)\\n        \\n        for i in range(3, n):\\n            # X(0) >= X(2)  X(3) >= X(1)\\n            \\n            if x[i-3] >= x[i-1] and x[i] >= x[i-2]:\\n                return True\\n            \\n            # X(1) == X(3)  X(0) + X(4) >= X(2)\\n            if i >= 4 and x[i-3] == x[i-1] and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n            # X(3) >= X(1) X(2) >= X(4) X(0) + X(4) >=X(2)    X(1) + X(5) >= X(3)\\n            if i >= 5 and x[i-2] >= x[i-4] and x[i-3] >= x[i-1] and (x[i-5] + x[i-1] >= x[i-3]) and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535684,
                "title": "python-solution-with-explanation",
                "content": "After drawing some examples,\\n![image](https://assets.leetcode.com/users/jslu0418/image_1583883320.png)\\nWe notice that, at any step, we at most need to know previous 5 steps\\' points to know if the move made by current step is valid or not.\\n\\nSuppose we are at (-2) now at Figure(a), we either walk to a point that is below (-6) and above (-3) (case a)\\nor walk into the vertical range defined by [(-6),(-5)] inclusively (case b), or we reach a point above (-5) (case c)\\n\\nIn case (a), next time after we turn left and walk towards west a little bit, we can only turn left and walk to south, which there is only one line contraint defined by (-3) and (-2). After that we will never face the complicated case as Figure (a).\\n\\nIn case (b), similarly, we turn left again, but in this scenario, our horizontal valid space is less than case (a), we can feel free to move (-3) to its right making it has same x-coord as (-6), then we can still use (-3) and (-2) to define the constraint for next step. Same as case(b), we will step into ease cases since now.\\n\\nCase (c) put us into a same situation as we start at point (-2).\\n\\nTherefore, when we at (-2), we could determine the case of the next step by how long we walk from (-2) to (-1), and in each case, we could calculate that in the next step, when we are at (-1), how far we can move at most without crashing the wall in front of us.\\n\\nOn we are in the simple case as Figure(d) -> Figure(f), actually we only need to keep 3 previous points to solve the problem.\\n\\nSorry the code is too messy while I want to use the index for directions to deal with different cases.\\n\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x)<4:\\n            return False\\n        drt=[(0,1), (-1, 0), (0, -1), (1, 0)]\\n        idx=0\\n        ## Initialize first 3 points\\n        q=[(0,0),]\\n        i=0\\n        while i<2:\\n            q.append(self.move(q[-1],drt[idx],x[i]))\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n        limit=float(\\'inf\\')\\n        ranges=[(q[-2][(idx+1)%2],q[-3][(idx+1)%2], q[-2][idx%2]),]\\n        ## Start with the 4th point, we will calculate its next step\\'s valid value.\\n        while i<len(x):\\n            ## invalid move\\n            if x[i]>=limit:\\n                return True\\n            cur=self.move(q[-1], drt[idx], x[i])\\n            ran=0\\n            for r in range(len(ranges)):\\n                if ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]>((-1)**((oldidx/2)+1))*ranges[r][0] and ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]<=((-1)**((oldidx/2)+1))*ranges[r][1]:\\n                    limit=(ranges[r][2]-cur[(idx)%2])*((-1)**((idx/2)+1))\\n                    break\\n                ran=r+1\\n            q.append(cur)\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n            if ran==len(ranges):\\n                limit=float(\\'inf\\')\\n                if len(q)>=5:\\n                    ranges=[(q[-2][(idx+1)%2],q[-5][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-5][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-5][idx%2])]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2],q[-4][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-4][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-4][idx%2])]\\n            else:\\n                ## If it goes to a way there is a wall in front, reduce the cases to only one\\n                if ran==len(ranges)-1 and ran>0 and len(q)>=5:\\n                    if idx%2==0:\\n                        q[-3]=(q[-3][(idx)%2],q[-5][(idx+1)%2])\\n                    else:\\n                        q[-3]=(q[-5][(idx+1)%2],q[-3][idx%2])\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n            if len(q)>5:\\n                q=q[-5:]\\n        return False\\n\\n    def move(self, cur, drt, val):\\n        return cur[0]+drt[0]*val, cur[1]+drt[1]*val\\n\\t\\t```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x)<4:\\n            return False\\n        drt=[(0,1), (-1, 0), (0, -1), (1, 0)]\\n        idx=0\\n        ## Initialize first 3 points\\n        q=[(0,0),]\\n        i=0\\n        while i<2:\\n            q.append(self.move(q[-1],drt[idx],x[i]))\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n        limit=float(\\'inf\\')\\n        ranges=[(q[-2][(idx+1)%2],q[-3][(idx+1)%2], q[-2][idx%2]),]\\n        ## Start with the 4th point, we will calculate its next step\\'s valid value.\\n        while i<len(x):\\n            ## invalid move\\n            if x[i]>=limit:\\n                return True\\n            cur=self.move(q[-1], drt[idx], x[i])\\n            ran=0\\n            for r in range(len(ranges)):\\n                if ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]>((-1)**((oldidx/2)+1))*ranges[r][0] and ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]<=((-1)**((oldidx/2)+1))*ranges[r][1]:\\n                    limit=(ranges[r][2]-cur[(idx)%2])*((-1)**((idx/2)+1))\\n                    break\\n                ran=r+1\\n            q.append(cur)\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n            if ran==len(ranges):\\n                limit=float(\\'inf\\')\\n                if len(q)>=5:\\n                    ranges=[(q[-2][(idx+1)%2],q[-5][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-5][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-5][idx%2])]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2],q[-4][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-4][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-4][idx%2])]\\n            else:\\n                ## If it goes to a way there is a wall in front, reduce the cases to only one\\n                if ran==len(ranges)-1 and ran>0 and len(q)>=5:\\n                    if idx%2==0:\\n                        q[-3]=(q[-3][(idx)%2],q[-5][(idx+1)%2])\\n                    else:\\n                        q[-3]=(q[-5][(idx+1)%2],q[-3][idx%2])\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n            if len(q)>5:\\n                q=q[-5:]\\n        return False\\n\\n    def move(self, cur, drt, val):\\n        return cur[0]+drt[0]*val, cur[1]+drt[1]*val\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 528276,
                "title": "c-solution",
                "content": "````c\\nenum state {\\n    inwrap,\\n    mid,\\n    outwrap\\n};\\nbool isSelfCrossing(int* x, int xSize){\\n    int dir[4] = {0};\\n    int p = 0;\\n    #define ADD(n) \\\\\\n    do {\\\\\\n        dir[p] = n;\\\\\\n        p = (p+1) % 4;\\\\\\n    } while(0)\\n    #define GET(n) (dir[(p+4-n) % 4])\\n    enum state s = outwrap;\\n    for (int i = 0; i < xSize; i++) {\\n        switch(s) {\\n            case outwrap:\\n                if (x[i] > GET(2)) {\\n                    s = outwrap;\\n                } else if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    s = mid;\\n                }\\n                break;\\n            case mid:\\n                if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    return true;\\n                }\\n                break;\\n            case inwrap:\\n                if (x[i] >= GET(2)) {\\n                    return true;\\n                }\\n                break;\\n            default:\\n                break;\\n        }\\n        ADD(x[i]);\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "````c\\nenum state {\\n    inwrap,\\n    mid,\\n    outwrap\\n};\\nbool isSelfCrossing(int* x, int xSize){\\n    int dir[4] = {0};\\n    int p = 0;\\n    #define ADD(n) \\\\\\n    do {\\\\\\n        dir[p] = n;\\\\\\n        p = (p+1) % 4;\\\\\\n    } while(0)\\n    #define GET(n) (dir[(p+4-n) % 4])\\n    enum state s = outwrap;\\n    for (int i = 0; i < xSize; i++) {\\n        switch(s) {\\n            case outwrap:\\n                if (x[i] > GET(2)) {\\n                    s = outwrap;\\n                } else if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    s = mid;\\n                }\\n                break;\\n            case mid:\\n                if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    return true;\\n                }\\n                break;\\n            case inwrap:\\n                if (x[i] >= GET(2)) {\\n                    return true;\\n                }\\n                break;\\n            default:\\n                break;\\n        }\\n        ADD(x[i]);\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275873,
                "title": "java-solution-check-if-each-line-intersects-the-previous-5-lines",
                "content": "The short solutions people are posting can be difficult to come up with.\\nThis solution might be more verbose / clear.\\n* When drawing a horizontal line, check if it intersects any of the 3 previous vertical lines.\\n* When drawing a vertical line, check if it intersects any of the 3 previous horizontal lines.\\n* intersects() only works for the case where 1 line is horizontal and the other line is vertical\\n\\n```\\nclass Line {\\n    public int x1,y1,x2,y2;\\n    public Line (int x1, int y1, int x2, int y2) {\\n        this.x1=x1;\\n        this.y1=y1;\\n        this.x2=x2;\\n        this.y2=y2;\\n    }\\n    public boolean isHor() {\\n        return y1==y2;\\n    }\\n    public boolean isVer() {\\n        return x1==x2;\\n    }\\n    public String tos() {\\n        return \"(\"+x1+\",\"+y1+\")-(\"+x2+\",\"+y2+\")\";\\n    }\\n}\\n\\nclass Solution {\\n    private boolean intersects(Line l1, Line l2) {\\n        if (!l1.isVer()) {\\n            return intersects(l2, l1);\\n        }\\n        \\n        // l1 is vertical, l2 is horizontal\\n        int yMin = Math.min(l1.y1, l1.y2);\\n        int yMax = Math.max(l1.y1, l1.y2);\\n        if (l2.y1 < yMin || l2.y1 > yMax)\\n            return false;\\n        \\n        int xMin = Math.min(l2.x1, l2.x2);\\n        int xMax = Math.max(l2.x1, l2.x2);\\n        if (l1.x1 < xMin || l1.x1 > xMax)\\n            return false;\\n        \\n        // System.out.println(l1.tos() +\" hits \"+l2.tos());\\n        return true;\\n    }\\n    \\n    public boolean isSelfCrossing(int[] moves) {\\n        int[] dx={0,-1,0,1};\\n        int[] dy={-1,0,1,0};\\n        int dir=0;\\n        int atX=0,atY=0;\\n        \\n        ArrayList<Line> q = new ArrayList<Line>();\\n        q.add(new Line(0,0,0,0)); // Edge case [1,1,2,1,1] (requires long explanation)\\n        \\n        for (int v : moves) {\\n            Line newLine = new Line(atX,atY,atX+dx[dir]*v,atY+dy[dir]*v);\\n            //System.out.println(\"draw \"+newLine.tos());\\n            for (int i = q.size() - 3; i >= 0; i -= 2)\\n                if (intersects(newLine, q.get(i)))\\n                    return true;\\n            \\n            q.add(newLine);\\n            if (q.size()>5)\\n                q.remove(0);\\n            atX=newLine.x2;\\n            atY=newLine.y2;\\n            dir = (dir+1)%4;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Line {\\n    public int x1,y1,x2,y2;\\n    public Line (int x1, int y1, int x2, int y2) {\\n        this.x1=x1;\\n        this.y1=y1;\\n        this.x2=x2;\\n        this.y2=y2;\\n    }\\n    public boolean isHor() {\\n        return y1==y2;\\n    }\\n    public boolean isVer() {\\n        return x1==x2;\\n    }\\n    public String tos() {\\n        return \"(\"+x1+\",\"+y1+\")-(\"+x2+\",\"+y2+\")\";\\n    }\\n}\\n\\nclass Solution {\\n    private boolean intersects(Line l1, Line l2) {\\n        if (!l1.isVer()) {\\n            return intersects(l2, l1);\\n        }\\n        \\n        // l1 is vertical, l2 is horizontal\\n        int yMin = Math.min(l1.y1, l1.y2);\\n        int yMax = Math.max(l1.y1, l1.y2);\\n        if (l2.y1 < yMin || l2.y1 > yMax)\\n            return false;\\n        \\n        int xMin = Math.min(l2.x1, l2.x2);\\n        int xMax = Math.max(l2.x1, l2.x2);\\n        if (l1.x1 < xMin || l1.x1 > xMax)\\n            return false;\\n        \\n        // System.out.println(l1.tos() +\" hits \"+l2.tos());\\n        return true;\\n    }\\n    \\n    public boolean isSelfCrossing(int[] moves) {\\n        int[] dx={0,-1,0,1};\\n        int[] dy={-1,0,1,0};\\n        int dir=0;\\n        int atX=0,atY=0;\\n        \\n        ArrayList<Line> q = new ArrayList<Line>();\\n        q.add(new Line(0,0,0,0)); // Edge case [1,1,2,1,1] (requires long explanation)\\n        \\n        for (int v : moves) {\\n            Line newLine = new Line(atX,atY,atX+dx[dir]*v,atY+dy[dir]*v);\\n            //System.out.println(\"draw \"+newLine.tos());\\n            for (int i = q.size() - 3; i >= 0; i -= 2)\\n                if (intersects(newLine, q.get(i)))\\n                    return true;\\n            \\n            q.add(newLine);\\n            if (q.size()>5)\\n                q.remove(0);\\n            atX=newLine.x2;\\n            atY=newLine.y2;\\n            dir = (dir+1)%4;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134499,
                "title": "easy-understand-python3-solution",
                "content": "First, we do not need to consider the fact that this edge is larger than the opposite edge, like `[1,2,3,4,5]`. So `if x[i] > x[i-2]:pass`. And `if len(x) < 4:return False`. Three sides cannot intersect.\\n\\nHere we consider two situations when the `x[i]<=x[i-2]`\\uFF1A\\n1.There is no intermediate edge between this edge and the opposite edge. Like\\n```\\n[3,3,2,x]\\n```\\nThen the `x[i+1] < x[i-1]` should be established otherwise the two sides intersect.\\n2.There is an intermediate edge between this edge and the opposite edge.Like\\n```\\n[2,3,4,5,a,b]\\n```\\nIf `a>(4-2)` then `b < (5-3)` should be established otherwise the two sides intersect.\\nif `a<(4-2)` then `b < 5` should be established otherwise the two sides intersect.\\nSo I can get the solution. I append two zero to `x` for preventing the `IndexError`\\nSolution:\\n```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        x.append(0)\\n        x.append(0)\\n        for i in range(2,len(x)-2):\\n            if x[i] <= x[i-2]:\\n                tmp = x[i-2] - x[i-4]\\n                if tmp > 0:\\n                    if x[i]>=tmp:\\n                        if x[i+1] != 0 and x[i+1] >= x[i-1]-x[i-3]:\\n                            return True\\n                    else:\\n                        if x[i+1] >= x[i-1]:\\n                            return True\\n                else:\\n                    if x[i+1] >= x[i-1]:\\n                        return True\\n        return False\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[3,3,2,x]\\n```\n```\\n[2,3,4,5,a,b]\\n```\n```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        x.append(0)\\n        x.append(0)\\n        for i in range(2,len(x)-2):\\n            if x[i] <= x[i-2]:\\n                tmp = x[i-2] - x[i-4]\\n                if tmp > 0:\\n                    if x[i]>=tmp:\\n                        if x[i+1] != 0 and x[i+1] >= x[i-1]-x[i-3]:\\n                            return True\\n                    else:\\n                        if x[i+1] >= x[i-1]:\\n                            return True\\n                else:\\n                    if x[i+1] >= x[i-1]:\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111767,
                "title": "concise-c-solution-with-graph-and-text-explaination",
                "content": "Inspired by @munsteur 's [solution](https://discuss.leetcode.com/topic/39428/simple-java-solution).\\n```\\nclass Solution{\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4){\\n            return false;\\n        }        \\n        // Check outward spiral\\n        size_t i = 2, lastIdx = x.size() - 1;\\n        while(x[i] > x[i-2]){\\n            if(i == lastIdx) return false;\\n            i++;\\n        }\\n        \\n        // Transit to inward spiral\\n        // Three cases:\\n        // 1. x[i] is longer than x[i-2] - x[i - 4], and of course shorter than x[x-2], so next line x[i + 1] may cross with x[i - 4], unless it's shorter than x[i-1] - x[i - 3]. \\n        // 2. A very special case, i == 3, and x[3] == x[1], so x[4] may touch x[0], unless it's shorter than x[2] - x[0];\\n        // 3. normal cases, we just need ensure x[i] < x[i-2] in following steps;\\n        // To handle case 1) and 2), we can make x[i - 1] = x[i - 1] - x[i - 3], so we can proceed with same condition check logic as case 3).\\n        if((i == 3 && x[3] == x[1]) || (x[i] >= x[i-2] - x[i-4])){\\n            x[i-1] -= x[i-3];\\n        }\\n        \\n        // Check inward spiral\\n        while(++i <= lastIdx && x[i] < x[i-2]);\\n        return i <= lastIdx;\\n    }\\n};\\n```\\nBelow are 3 pictures to explain the 3 inward spiral transition cases:\\nCase 1.\\n![case 1](https://image.ibb.co/kGrJrm/case1.png)\\n\\nCase2.\\n![case 2](https://image.ibb.co/dPbhj6/case2.png)\\n\\nCase 3.\\n![case 3](https://image.ibb.co/mz6nHR/case3.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4){\\n            return false;\\n        }        \\n        // Check outward spiral\\n        size_t i = 2, lastIdx = x.size() - 1;\\n        while(x[i] > x[i-2]){\\n            if(i == lastIdx) return false;\\n            i++;\\n        }\\n        \\n        // Transit to inward spiral\\n        // Three cases:\\n        // 1. x[i] is longer than x[i-2] - x[i - 4], and of course shorter than x[x-2], so next line x[i + 1] may cross with x[i - 4], unless it's shorter than x[i-1] - x[i - 3]. \\n        // 2. A very special case, i == 3, and x[3] == x[1], so x[4] may touch x[0], unless it's shorter than x[2] - x[0];\\n        // 3. normal cases, we just need ensure x[i] < x[i-2] in following steps;\\n        // To handle case 1) and 2), we can make x[i - 1] = x[i - 1] - x[i - 3], so we can proceed with same condition check logic as case 3).\\n        if((i == 3 && x[3] == x[1]) || (x[i] >= x[i-2] - x[i-4])){\\n            x[i-1] -= x[i-3];\\n        }\\n        \\n        // Check inward spiral\\n        while(++i <= lastIdx && x[i] < x[i-2]);\\n        return i <= lastIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79137,
                "title": "python-solution-and-tips",
                "content": "Draw lines and number those lines. You will find the pattern soon.\\n\\nThe `i-th` can only cross `i-3th`, `i-4th` or `i-5th` on the first crossing.\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        for i in range(3, len(x)):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\\n                return True\\n            if i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\\n                return True\\n            if i >= 5 and x[i-1] <= x[i-3] and x[i-3] <= x[i-1] + x[i-5] and x[i] + x[i-4] >= x[i-2] and x[i-4] <= x[i-2]:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        for i in range(3, len(x)):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\\n                return True\\n            if i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\\n                return True\\n            if i >= 5 and x[i-1] <= x[i-3] and x[i-3] <= x[i-1] + x[i-5] and x[i] + x[i-4] >= x[i-2] and x[i-4] <= x[i-2]:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79173,
                "title": "sharing-my-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int i, n = x.size();\\n            for(i=0; i<n; i++)\\n            {\\n                if(i>=3 && x[i]>=x[i-2] && x[i-1]<=x[i-3])\\n                    return true;\\n                    \\n                if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2])\\n                    return true;\\n                    \\n                if(i>=5 && x[i]+x[i-4]>=x[i-2] && x[i-1]+x[i-5]>=x[i-3] && x[i-2]>=x[i-4] && x[i-3]>=x[i-1])\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int i, n = x.size();\\n            for(i=0; i<n; i++)\\n            {\\n                if(i>=3 && x[i]>=x[i-2] && x[i-1]<=x[i-3])\\n                    return true;\\n                    \\n                if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2])\\n                    return true;\\n                    \\n                if(i>=5 && x[i]+x[i-4]>=x[i-2] && x[i-1]+x[i-5]>=x[i-3] && x[i-2]>=x[i-4] && x[i-3]>=x[i-1])\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79183,
                "title": "java-one-pass-solution-0ms",
                "content": "No direction attributes are used. Redundant code but easy to understand.\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        \\n        // Check for initial four values manually.\\n        if(x.length < 4){\\n            for(int el : x){\\n                if(el == 0)return true;\\n            }\\n            return false;\\n        }\\n        \\n    \\n        for(int i = 3 ; i < x.length ; i++) {\\n            int cur = x[i];\\n            if(cur == 0)return true;\\n            //At any point of time, i-1 has to be less than i-3 in order to intersect. Draw few figures to realize this.\\n            if( x[i-1] <= x[i-3]){\\n                // Basic case. Straight forward intersection.\\n                if(cur >= x[i-2] ){\\n                    return true;\\n                }\\n                //Special case.\\n                if(i>=5){\\n                    // if i-2 edge is less than i-4 th edge then it cannot intersect no matter what if i < i-2 th edge.\\n                    if(x[i-2] < x[i-4])continue;\\n                    // the intersecting case.\\n                    if( (x[i] + x[i-4] >= x[i-2]) && ( x[i-1] + x[i-5] >= x[i-3] ) ) return true;\\n                }\\n            }\\n            // equals case\\n            if(i>=4)if(x[i-1] == x[i-3] && cur+ x[i-4] == x[i-2]) return true;\\n            \\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "No direction attributes are used. Redundant code but easy to understand.\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        \\n        // Check for initial four values manually.\\n        if(x.length < 4){\\n            for(int el : x){\\n                if(el == 0)return true;\\n            }\\n            return false;\\n        }\\n        \\n    \\n        for(int i = 3 ; i < x.length ; i++) {\\n            int cur = x[i];\\n            if(cur == 0)return true;\\n            //At any point of time, i-1 has to be less than i-3 in order to intersect. Draw few figures to realize this.\\n            if( x[i-1] <= x[i-3]){\\n                // Basic case. Straight forward intersection.\\n                if(cur >= x[i-2] ){\\n                    return true;\\n                }\\n                //Special case.\\n                if(i>=5){\\n                    // if i-2 edge is less than i-4 th edge then it cannot intersect no matter what if i < i-2 th edge.\\n                    if(x[i-2] < x[i-4])continue;\\n                    // the intersecting case.\\n                    if( (x[i] + x[i-4] >= x[i-2]) && ( x[i-1] + x[i-5] >= x[i-3] ) ) return true;\\n                }\\n            }\\n            // equals case\\n            if(i>=4)if(x[i-1] == x[i-3] && cur+ x[i-4] == x[i-2]) return true;\\n            \\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4081177,
                "title": "expressive-solution",
                "content": "Very bad drawing but how i approached this question\\n![image.png](https://assets.leetcode.com/users/images/86c57f11-e9d4-4133-9272-523a39b05d47_1695484128.517365.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        \"\"\"\\n        1st way to cross NWSE , East meets north, E and W must be same length\\n        and N>=S\\n        2nd way NWSEN , North overlaps with north , E==W and S<= N1+N2\\n        3rd way NWSENW , West overlaps with first North, W1<\\n        \"\"\"\\n        if(len(distance)<=3):\\n            return False\\n        for i in range(3,len(distance)):\\n            if(distance[i]>=distance[i-2] and distance[i-3]>=distance[i-1]):\\n                return True\\n            if(i>=4 and distance[i-1]==distance[i-3] and distance[i-2]<=distance[i]+distance[i-4]):\\n                return True\\n            if(i>=5 and distance[i-4]<distance[i-2] and distance[i]+distance[i-4]>=distance[i-2] and distance[i-1]+distance[i-5]>=distance[i-3] and distance[i-1]<=distance[i-3]):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        \"\"\"\\n        1st way to cross NWSE , East meets north, E and W must be same length\\n        and N>=S\\n        2nd way NWSEN , North overlaps with north , E==W and S<= N1+N2\\n        3rd way NWSENW , West overlaps with first North, W1<\\n        \"\"\"\\n        if(len(distance)<=3):\\n            return False\\n        for i in range(3,len(distance)):\\n            if(distance[i]>=distance[i-2] and distance[i-3]>=distance[i-1]):\\n                return True\\n            if(i>=4 and distance[i-1]==distance[i-3] and distance[i-2]<=distance[i]+distance[i-4]):\\n                return True\\n            if(i>=5 and distance[i-4]<distance[i-2] and distance[i]+distance[i-4]>=distance[i-2] and distance[i-1]+distance[i-5]>=distance[i-3] and distance[i-1]<=distance[i-3]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942830,
                "title": "o-n-time-o-1-memory-solution-with-proof-of-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly we can see that the figure can be spiral goes outside spining or inside spining.\\n\\nAlso it can try to change its spining direction once...once,but few times.\\n\\nWhat means few?\\nIt means that it goes outside several times,then few times it is in the \"changing\" condition and then always inside.\\n\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/4d7766c6-79c4-407e-bd69-13a5c4375d67_1692648667.6833699.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we will make a rule which shows is there on the k step crossing with something before or it is not.\\n\\nSo,let\\'s start with spiral spining only outside and once it crosses itself.\\nWe will cann elements from the tail,for example 5th element means k-5th element from the start.\\n\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/901fd96f-0161-4dc4-b180-20b15250c159_1692649112.3803544.png)\\nObviously if 3th>=1th and 0th>=2th then we have an intersection points.\\n\\nSo,what about outside spining?\\nYou will laugh,but rule stays the same!\\nDo not believe to me? Check it yourself then.\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/579df074-b07d-4b3b-a063-eed8da592aa7_1692649267.804402.png)\\n\\nSo,that was great,but what about changing direction?\\nObviously to detect this condition we need to make sure that\\n2th<=0th+4th else we have nothing to speak about.\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/0553544d-a80f-439d-bc2e-78405b8307f4_1692649587.6485841.png)\\n\\nBut what if yes,how can we be sure that 0th goes exactly through 5th?\\nOf course by adding few rules\\n1th<=3th and 1th>=3th-5th\\nIt will prove that 0th lies between 4th and 6th\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/f886a756-cc0f-4b3b-b3e4-b6e05e3927b6_1692649768.4962103.png)\\n\\nBut we need 3th-5th>0 else we do not have a gap between 6th and 2th to make it all possible...Then it is the another rule.\\n\\nBut what if k=4?Then we can not see 5th...\\nOk,we will deal with that by saying 5th=0\\nBut it means our rule now has 3th>=1th and 3th<=1th.Let\\'s rewrite it like 3th=1th.\\n\\nNow we have checked all the cases which are possible!\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nSo,have we missed something?\\nOf course we have.\\nSpiral can be changing its direction only several times and after finaly changing it from undetermined to another than it was before it will NEVER be able to go into any another condition.\\nLet\\'s make the second solution with this useful fact.\\n\\nFirstly we will check the rule of the spiral spining (does not matter in what direction)\\nThen we will detect the period of its cahnging and after just relax and only check the spiral spining.\\nAs you remember,the rules for outside and inside spining is the same,that is why we do not need to watch each case exactly.\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/29ed2232-edf5-4a84-bd6c-55a714c022ee_1692652010.8186808.png)\\n\\nOk,what is the rule of starting the changing process?\\nIt is 2th>=4 and 2th>=0th.\\nIf that happens in the first part where we check the spining,we just start the second part of our algorithm with checking the changing condition.\\nAnd when this rule stops holding,we say that it is spining again and never will be something another.\\n\\nIf in any part of our algorithm we have reached the end,we just say that we have meet no intersection points.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    //case 3\\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize<5) {return false;}\\n    //case 4\\n    if (\\n        (distance[4-2]<=distance[4]+distance[4-4])&&\\n        (distance[4-3]>=distance[4-1])&&\\n        (distance[4-3]==distance[4-1])\\n    ) {return true;}\\n\\n    if (distanceSize<6) {return false;}\\n    //case 5+\\n    for (int g=5;g<distanceSize;g++) {\\n        \\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)\\n        ) {return true;}\\n        \\n        /*\\n        Rule itself if you wish,start g from 3 up to distancesize\\n        if (\\n            (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            )||(\\n                (g>=4)&&\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            )\\n        ) {return true;}\\n        */\\n    }\\n    return false;\\n}\\n\\n\\n\\n//and now the another solution with those 3 parts\\n\\n\\n\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    int g=4;\\n    bool cond=true;\\n    \\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize==4) {return false;}\\n\\n    while (cond==true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        if (\\n            (distance[g-2]>=distance[g-4])&&\\n            (distance[g-2]>=distance[g])\\n        ) {\\n            cond=false;\\n            if (\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    \\n    while (cond==false) {\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)            \\n        ) {\\n            return true;\\n        }\\n        if (\\n            (distance[g-2]<distance[g-4])||\\n            (distance[g-2]>distance[g])\\n        ) {\\n            cond=true;\\n            if (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    while (true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    return false;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    //case 3\\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize<5) {return false;}\\n    //case 4\\n    if (\\n        (distance[4-2]<=distance[4]+distance[4-4])&&\\n        (distance[4-3]>=distance[4-1])&&\\n        (distance[4-3]==distance[4-1])\\n    ) {return true;}\\n\\n    if (distanceSize<6) {return false;}\\n    //case 5+\\n    for (int g=5;g<distanceSize;g++) {\\n        \\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)\\n        ) {return true;}\\n        \\n        /*\\n        Rule itself if you wish,start g from 3 up to distancesize\\n        if (\\n            (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            )||(\\n                (g>=4)&&\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            )\\n        ) {return true;}\\n        */\\n    }\\n    return false;\\n}\\n\\n\\n\\n//and now the another solution with those 3 parts\\n\\n\\n\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    int g=4;\\n    bool cond=true;\\n    \\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize==4) {return false;}\\n\\n    while (cond==true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        if (\\n            (distance[g-2]>=distance[g-4])&&\\n            (distance[g-2]>=distance[g])\\n        ) {\\n            cond=false;\\n            if (\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    \\n    while (cond==false) {\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)            \\n        ) {\\n            return true;\\n        }\\n        if (\\n            (distance[g-2]<distance[g-4])||\\n            (distance[g-2]>distance[g])\\n        ) {\\n            cond=true;\\n            if (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    while (true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    return false;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936031,
                "title": "easy-lineartime-solution-java-kotlin-hyder-nabi",
                "content": "\\n# Java\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if(distance.length<=3)return false;\\n        for(int i=3;i<distance.length;i++){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true;\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true;\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Kotlin\\n```\\nclass Solution {\\n    fun isSelfCrossing(distance: IntArray): Boolean {\\n        if(distance.size<=3)return false\\n        for(i in 3..distance.size-1){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if(distance.length<=3)return false;\\n        for(int i=3;i<distance.length;i++){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true;\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true;\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun isSelfCrossing(distance: IntArray): Boolean {\\n        if(distance.size<=3)return false\\n        for(i in 3..distance.size-1){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930467,
                "title": "swift-easy-solution-100-beat-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n       \\n       if distance.count  <= 3 { return false }\\n\\n        var newArr = Array(1...(distance.count-1))\\n        newArr.append(1)\\n        \\n        if newArr == distance {\\n            return false\\n        }\\n        \\n      \\n        \\n        var arr = [(Int,Int)]()\\n        var x = 0\\n        var y = 0\\n        arr.append((x,y))\\n        var i = 0\\n        \\n        while i < distance.count {\\n            \\n            for j in 0..<distance[i] {\\n                \\n                if (i % 4) == 0 { // N\\n                    y += 1\\n                    \\n                }else if (i % 4) == 1 { // W\\n                    x -= 1\\n                    \\n                }else if (i % 4) == 2 { // S\\n                    y -= 1\\n                    \\n                }else { // E\\n                    x += 1\\n                }\\n                \\n                if arr.contains(where: {$0.0 == x && $0.1 == y}) {\\n                    return true\\n                }\\n                \\n                arr.append((x,y))\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n       \\n       if distance.count  <= 3 { return false }\\n\\n        var newArr = Array(1...(distance.count-1))\\n        newArr.append(1)\\n        \\n        if newArr == distance {\\n            return false\\n        }\\n        \\n      \\n        \\n        var arr = [(Int,Int)]()\\n        var x = 0\\n        var y = 0\\n        arr.append((x,y))\\n        var i = 0\\n        \\n        while i < distance.count {\\n            \\n            for j in 0..<distance[i] {\\n                \\n                if (i % 4) == 0 { // N\\n                    y += 1\\n                    \\n                }else if (i % 4) == 1 { // W\\n                    x -= 1\\n                    \\n                }else if (i % 4) == 2 { // S\\n                    y -= 1\\n                    \\n                }else { // E\\n                    x += 1\\n                }\\n                \\n                if arr.contains(where: {$0.0 == x && $0.1 == y}) {\\n                    return true\\n                }\\n                \\n                arr.append((x,y))\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929788,
                "title": "guru",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n      \\n        if (distance.length < 4) {\\n            return false; // A path with less than 4 distances can\\'t cross itself.\\n        }\\n        \\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                // Case 1: Fourth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\\n                // Case 2: Fifth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 1] <= distance[i - 3] &&\\n                distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                // Case 3: Sixth segment crosses the first segment.\\n                return true;\\n            }\\n        }\\n        \\n        return false; // No self-crossing path found.\\n    }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n      \\n        if (distance.length < 4) {\\n            return false; // A path with less than 4 distances can\\'t cross itself.\\n        }\\n        \\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                // Case 1: Fourth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\\n                // Case 2: Fifth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 1] <= distance[i - 3] &&\\n                distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                // Case 3: Sixth segment crosses the first segment.\\n                return true;\\n            }\\n        }\\n        \\n        return false; // No self-crossing path found.\\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881186,
                "title": "key-idea-explained-linear-algebra-python",
                "content": "```\\n\"\"\"\\nThere are 3 possible cuts:\\n\\n1. Converge cut (every 4 segments)\\n            b \\n   +----------------+ \\n   |                | \\n   |                | \\n c |                | a \\n   |                |      \\n   +--------------->|      \\n            d       |    \\n\\n2. Rectangular cut (every 5 segments)\\n           b          \\n  +----------------+  \\n  |                |  \\n  |                |  \\nc |                | a\\n  |                |  \\n  |                |  \\n  |                ^ e\\n  |                |  \\n  +----------------+  \\n           d          \\n\\n3. Diverge cut (every 6 segments)\\n           b                 \\n  +----------------+         \\n  |                |         \\n  |                |         \\nc |                | a       \\n  |                |    f    \\n  |                | <----+  \\n  |                |      | e\\n  |                       |  \\n  +-----------------------+  \\n           d                 \\n\\n```\\nSo basically we need to keep track of past 6 segments and check for all three cases\\n\\nChecking for cuts is not too hard because we all segments are either vertical or horizontal\\n\\nBut I wanted to figure out a generalised way to check if two segments intersect using linear algebra so I am doing more calculations than I need to. \\n\\n**Time: O(n)\\nSpace: O(1)**\\n```\\ndef isSelfCrossing(self, distance: List[int]) -> bool:\\n    n = len(distance)\\n    if n < 4: return False\\n\\n    direction = [[0, 1], [-1, 0], [0, -1], [1, 0]]\\n    def move(x, y, i):\\n        dis = distance[i]\\n        dx, dy = direction[i%4]\\n        return [x + dx*dis, y + dy*dis]\\n\\n    def subtract(p1, p2):\\n        return [p2[i] - p1[i] for i in range(len(p1))]\\n\\n    # check if a p3 is b.w p1 and p2\\n    def check_point_on_segment(p1, p2, p3):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        \\n        mu = None\\n        for i in range(n):\\n            if r12[i] != 0:\\n                mu = r13[i]/r12[i]\\n                break\\n        return (p1 == p3) or (0<=mu<=1 and all([p1[i] + mu*r12[i] == p3[i] for i in range(n)]))\\n    \\n    # check if segments [p1, p2] and [p3, p4] intersect\\n    def check_segment_intersect(p1, p2, p3, p4):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        r34 = subtract(p3, p4)\\n        denom = (r34[0]*r12[1] - r12[0]*r34[1])\\n        # the two segments are parallel\\n        if denom == 0:\\n            return check_point_on_segment(p1, p2, p3) or check_point_on_segment(p1, p2, p4)\\n        # the two segments are not parallel\\n        mu = (r34[0]*r13[1] - r13[0]*r34[1])/denom\\n        return 0<=mu<=1 and check_point_on_segment(p3, p4, [p1[i] + mu*r12[i] for i in range(n)])\\n        \\n    x = y = 0\\n    que = deque([[0, 0]])\\n    for i in range(n):\\n        x, y = move(x, y, i)\\n        que.append([x, y])\\n        if len(que) >= 5 and check_segment_intersect(que[0], que[1], que[3], que[4]):\\n            return True\\n        if len(que) >= 6 and check_segment_intersect(que[0], que[1], que[4], que[5]):\\n            return True\\n        if len(que) == 7:\\n            if check_segment_intersect(que[0], que[1], que[5], que[6]):\\n                return True\\n            que.popleft()\\n    \\n    return False\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n\"\"\"\\nThere are 3 possible cuts:\\n\\n1. Converge cut (every 4 segments)\\n            b \\n   +----------------+ \\n   |                | \\n   |                | \\n c |                | a \\n   |                |      \\n   +--------------->|      \\n            d       |    \\n\\n2. Rectangular cut (every 5 segments)\\n           b          \\n  +----------------+  \\n  |                |  \\n  |                |  \\nc |                | a\\n  |                |  \\n  |                |  \\n  |                ^ e\\n  |                |  \\n  +----------------+  \\n           d          \\n\\n3. Diverge cut (every 6 segments)\\n           b                 \\n  +----------------+         \\n  |                |         \\n  |                |         \\nc |                | a       \\n  |                |    f    \\n  |                | <----+  \\n  |                |      | e\\n  |                       |  \\n  +-----------------------+  \\n           d                 \\n\\n```\n```\\ndef isSelfCrossing(self, distance: List[int]) -> bool:\\n    n = len(distance)\\n    if n < 4: return False\\n\\n    direction = [[0, 1], [-1, 0], [0, -1], [1, 0]]\\n    def move(x, y, i):\\n        dis = distance[i]\\n        dx, dy = direction[i%4]\\n        return [x + dx*dis, y + dy*dis]\\n\\n    def subtract(p1, p2):\\n        return [p2[i] - p1[i] for i in range(len(p1))]\\n\\n    # check if a p3 is b.w p1 and p2\\n    def check_point_on_segment(p1, p2, p3):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        \\n        mu = None\\n        for i in range(n):\\n            if r12[i] != 0:\\n                mu = r13[i]/r12[i]\\n                break\\n        return (p1 == p3) or (0<=mu<=1 and all([p1[i] + mu*r12[i] == p3[i] for i in range(n)]))\\n    \\n    # check if segments [p1, p2] and [p3, p4] intersect\\n    def check_segment_intersect(p1, p2, p3, p4):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        r34 = subtract(p3, p4)\\n        denom = (r34[0]*r12[1] - r12[0]*r34[1])\\n        # the two segments are parallel\\n        if denom == 0:\\n            return check_point_on_segment(p1, p2, p3) or check_point_on_segment(p1, p2, p4)\\n        # the two segments are not parallel\\n        mu = (r34[0]*r13[1] - r13[0]*r34[1])/denom\\n        return 0<=mu<=1 and check_point_on_segment(p3, p4, [p1[i] + mu*r12[i] for i in range(n)])\\n        \\n    x = y = 0\\n    que = deque([[0, 0]])\\n    for i in range(n):\\n        x, y = move(x, y, i)\\n        que.append([x, y])\\n        if len(que) >= 5 and check_segment_intersect(que[0], que[1], que[3], que[4]):\\n            return True\\n        if len(que) >= 6 and check_segment_intersect(que[0], que[1], que[4], que[5]):\\n            return True\\n        if len(que) == 7:\\n            if check_segment_intersect(que[0], que[1], que[5], que[6]):\\n                return True\\n            que.popleft()\\n    \\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3835978,
                "title": "python-solution-3-ways-to-self-cross",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nSimulating the process would take up too much memory and time. We need a geometrical solution\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nLogically break down the possibilities of self cross: it could cross from the left, bottom, or the right. Also, checking beyond 6 previous steps is unnecessary, for any self cross with paths before that would have detected earlier\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n)$$\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(1)$$\\r\\n# Code\\r\\n```\\r\\nfrom typing import List\\r\\n\\r\\n\\r\\nclass Solution:\\r\\n    \\'\\'\\'\\r\\n    Two points to note: \\r\\n    1. The Cartesian coordinate system is symmetric wih 90 degree rotations\\r\\n    2. To cross a previous path with a future step, one can cross from left, right or from below\\r\\n    \\'\\'\\'\\r\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\r\\n        b = c = d = e = f = 0\\r\\n        for a in distance:\\r\\n            # cross from left\\r\\n            if d > 0 and d >= b and a >= c:\\r\\n                return True\\r\\n            # cross from below\\r\\n            if e > 0 and c <= a + e and b == d:\\r\\n                return True\\r\\n            # cross from the right\\r\\n            if f > 0 and b <= d <= b + f and e <= c <= a + e:\\r\\n                return True\\r\\n            b, c, d, e, f = a, b, c, d, e \\r\\n        return False\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nfrom typing import List\\r\\n\\r\\n\\r\\nclass Solution:\\r\\n    \\'\\'\\'\\r\\n    Two points to note: \\r\\n    1. The Cartesian coordinate system is symmetric wih 90 degree rotations\\r\\n    2. To cross a previous path with a future step, one can cross from left, right or from below\\r\\n    \\'\\'\\'\\r\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\r\\n        b = c = d = e = f = 0\\r\\n        for a in distance:\\r\\n            # cross from left\\r\\n            if d > 0 and d >= b and a >= c:\\r\\n                return True\\r\\n            # cross from below\\r\\n            if e > 0 and c <= a + e and b == d:\\r\\n                return True\\r\\n            # cross from the right\\r\\n            if f > 0 and b <= d <= b + f and e <= c <= a + e:\\r\\n                return True\\r\\n            b, c, d, e, f = a, b, c, d, e \\r\\n        return False\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819803,
                "title": "c-o-n-solution-time-95-53-space-91-06",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        // We can prove that:\\n        // Suppose 0, 1, ..., i-1 is not self-crossing,\\n        // if i doesn\\'t intersect with i-3 and i-5, \\n        // then i doesn\\'t intersect with any segment before i.\\n        // This is because the directions are always changing\\n        // in a sprial: N->W->S->E->N...\\n        int n = distance.size();\\n        for (int i = 3; i < n; ++i) {\\n            int x0 = distance[i];\\n            int x1 = distance[i-1];\\n            int x2 = distance[i-2];\\n            int x3 = distance[i-3];\\n            // i intersects with i-3\\n            if (x0 >= x2 && x1 <= x3) {\\n                return true;\\n            }\\n            // i intersects with i-5\\n            if (i >= 4) {\\n                int d1 = x2 - distance[i-4];\\n                int d2 = x3 - x1;\\n                // when i = 4, consider x[i-5] = 0,\\n                // to detect the corner case that segment 4\\n                // crosses point (0, 0)\\n                int x5 = 0;\\n                if (i >= 5) {\\n                    x5 = distance[i-5];\\n                }\\n                if (d1 >= 0 && d1 <= x0 && d2 >= 0 && d2 <= x5) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        // We can prove that:\\n        // Suppose 0, 1, ..., i-1 is not self-crossing,\\n        // if i doesn\\'t intersect with i-3 and i-5, \\n        // then i doesn\\'t intersect with any segment before i.\\n        // This is because the directions are always changing\\n        // in a sprial: N->W->S->E->N...\\n        int n = distance.size();\\n        for (int i = 3; i < n; ++i) {\\n            int x0 = distance[i];\\n            int x1 = distance[i-1];\\n            int x2 = distance[i-2];\\n            int x3 = distance[i-3];\\n            // i intersects with i-3\\n            if (x0 >= x2 && x1 <= x3) {\\n                return true;\\n            }\\n            // i intersects with i-5\\n            if (i >= 4) {\\n                int d1 = x2 - distance[i-4];\\n                int d2 = x3 - x1;\\n                // when i = 4, consider x[i-5] = 0,\\n                // to detect the corner case that segment 4\\n                // crosses point (0, 0)\\n                int x5 = 0;\\n                if (i >= 5) {\\n                    x5 = distance[i-5];\\n                }\\n                if (d1 >= 0 && d1 <= x0 && d2 >= 0 && d2 <= x5) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778354,
                "title": "c-brute-force",
                "content": "The dirty way: compute coordinates, add points to a list, check intersection between each 2 segments (*the `Intersect` method can be written shorter than that, I know; there\\'s much room for optimization overall*).\\n\\nAnyway, to avoid TLE we can figure out there\\'s a certain limit when comparing segments, as there\\'s no need to look back more than 5 segments. If a intersection occurs based on the provided rules, it will happen within this limited number of moves or it won\\'t happen at all; and this opens the way for a totally different and much more performant approach...\\n\\nPlease upvote below if you reached reading this far :) thank you!\\n\\n# Code\\n```\\npublic class Solution\\n{\\n\\n    bool Intersect(int Ax1, int Ay1, int Ax2, int Ay2, int Bx1, int By1, int Bx2, int By2)\\n    {\\n        bool isAVertical = Ax1 == Ax2;\\n        bool isBVertical = Bx1 == Bx2;\\n\\n        if (Ax1 > Ax2) { var aux = Ax1; Ax1 = Ax2; Ax2 = aux; }\\n        if (Ay1 > Ay2) { var aux = Ay1; Ay1 = Ay2; Ay2 = aux; }\\n        if (Bx1 > Bx2) { var aux = Bx1; Bx1 = Bx2; Bx2 = aux; }\\n        if (By1 > By2) { var aux = By1; By1 = By2; By2 = aux; }\\n\\n        if (isAVertical)\\n        {\\n            if (isBVertical)\\n                return Ax1 == Bx1 && Ay1 <= By2 && Ay2 >= By1;\\n            return Ay1 <= By1 && By1 <= Ay2 && Bx1 <= Ax1 && Ax1 <= Bx2;\\n        }\\n        else\\n        {\\n            if (!isBVertical)\\n                return Ay1 == By1 && Ax1 <= Bx2 && Ax2 >= Bx1;\\n            return By1 <= Ay1 && Ay1 <= By2 && Ax1 <= Bx1 && Bx1 <= Ax2;\\n        }\\n    }\\n\\n    public bool IsSelfCrossing(int[] distance)\\n    {\\n        List<(int x, int y)> l = new();\\n\\n        // 0 - N, 1 - W, 2 - S, 3 - E\\n        int direction = -1;\\n\\n        (int x, int y) lastP = new(0, 0);\\n        l.Add(lastP);\\n\\n        for (int i = 0; i < distance.Length; i++)\\n        {\\n            var d = distance[i];\\n            direction = ++direction % 4;\\n\\n            var newX = lastP.x;\\n            var newY = lastP.y;\\n            switch (direction)\\n            {\\n                case 0: newY += d; break;\\n                case 1: newX -= d; break;\\n                case 2: newY -= d; break;\\n                case 3: newX += d; break;\\n            }\\n            (int x, int y) newPoint = new(newX, newY);\\n\\n            // useless to check before\\n            if (l.Count >= 4)\\n                for (int j = Math.Max(1, l.Count - 5); j < l.Count - 2; j++)\\n                    if (Intersect(l[j - 1].x, l[j - 1].y, l[j].x, l[j].y, l[l.Count - 1].x, l[l.Count - 1].y, newPoint.x, newPoint.y))\\n                        return true;\\n\\n            l.Add(newPoint);\\n            lastP = newPoint;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n\\n    bool Intersect(int Ax1, int Ay1, int Ax2, int Ay2, int Bx1, int By1, int Bx2, int By2)\\n    {\\n        bool isAVertical = Ax1 == Ax2;\\n        bool isBVertical = Bx1 == Bx2;\\n\\n        if (Ax1 > Ax2) { var aux = Ax1; Ax1 = Ax2; Ax2 = aux; }\\n        if (Ay1 > Ay2) { var aux = Ay1; Ay1 = Ay2; Ay2 = aux; }\\n        if (Bx1 > Bx2) { var aux = Bx1; Bx1 = Bx2; Bx2 = aux; }\\n        if (By1 > By2) { var aux = By1; By1 = By2; By2 = aux; }\\n\\n        if (isAVertical)\\n        {\\n            if (isBVertical)\\n                return Ax1 == Bx1 && Ay1 <= By2 && Ay2 >= By1;\\n            return Ay1 <= By1 && By1 <= Ay2 && Bx1 <= Ax1 && Ax1 <= Bx2;\\n        }\\n        else\\n        {\\n            if (!isBVertical)\\n                return Ay1 == By1 && Ax1 <= Bx2 && Ax2 >= Bx1;\\n            return By1 <= Ay1 && Ay1 <= By2 && Ax1 <= Bx1 && Bx1 <= Ax2;\\n        }\\n    }\\n\\n    public bool IsSelfCrossing(int[] distance)\\n    {\\n        List<(int x, int y)> l = new();\\n\\n        // 0 - N, 1 - W, 2 - S, 3 - E\\n        int direction = -1;\\n\\n        (int x, int y) lastP = new(0, 0);\\n        l.Add(lastP);\\n\\n        for (int i = 0; i < distance.Length; i++)\\n        {\\n            var d = distance[i];\\n            direction = ++direction % 4;\\n\\n            var newX = lastP.x;\\n            var newY = lastP.y;\\n            switch (direction)\\n            {\\n                case 0: newY += d; break;\\n                case 1: newX -= d; break;\\n                case 2: newY -= d; break;\\n                case 3: newX += d; break;\\n            }\\n            (int x, int y) newPoint = new(newX, newY);\\n\\n            // useless to check before\\n            if (l.Count >= 4)\\n                for (int j = Math.Max(1, l.Count - 5); j < l.Count - 2; j++)\\n                    if (Intersect(l[j - 1].x, l[j - 1].y, l[j].x, l[j].y, l[l.Count - 1].x, l[l.Count - 1].y, newPoint.x, newPoint.y))\\n                        return true;\\n\\n            l.Add(newPoint);\\n            lastP = newPoint;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770599,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def isSelfCrossing(distance: Array[Int]): Boolean =\\n      if (distance.length <= 3) false\\n      else (3 until distance.length).exists(e =>\\n          distance(e - 2) <= distance(e) && distance(e - 1) <= distance(e - 3) ||\\n          e >= 4 && distance(e - 1) == distance(e - 3) && distance(e - 2) <= distance(e) + distance(e - 4) ||\\n          e >= 5 && distance(e - 4) <= distance(e - 2) && distance(e - 2) <= distance(e) + distance(e - 4) && distance(e - 1) <= distance(e - 3) && distance(e - 3) <= distance(e - 1) + distance(e - 5))\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def isSelfCrossing(distance: Array[Int]): Boolean =\\n      if (distance.length <= 3) false\\n      else (3 until distance.length).exists(e =>\\n          distance(e - 2) <= distance(e) && distance(e - 1) <= distance(e - 3) ||\\n          e >= 4 && distance(e - 1) == distance(e - 3) && distance(e - 2) <= distance(e) + distance(e - 4) ||\\n          e >= 5 && distance(e - 4) <= distance(e - 2) && distance(e - 2) <= distance(e) + distance(e - 4) && distance(e - 1) <= distance(e - 3) && distance(e - 3) <= distance(e - 1) + distance(e - 5))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3751044,
                "title": "java-solution-explained",
                "content": "# Intuiton -\\nThe given code is a method `isSelfCrossing` that takes an integer array `x` as input and determines if the array represents a self-crossing shape or not. The intuition behind the code is to iterate through the array starting from the fourth element and check for various conditions that indicate a self-crossing shape.\\n\\n# Approach -\\n1. If the length of the array is less than or equal to 3, it is not possible to form a self-crossing shape, so the method returns `false`.\\n2. The loop starts from the fourth element of the array and iterates until the end.\\n3. Within each iteration, the code checks three different conditions to determine if a self-crossing shape is encountered.\\n4. If any of the conditions are satisfied, the method returns `true` indicating a self-crossing shape is present.\\n5. If none of the conditions are met after iterating through the entire array, the method returns `false`.\\n\\n# Complexity - \\n- Time Complexity: The code iterates through the given array once, starting from the fourth element. Therefore, the time complexity is O(n), where n is the length of the array.\\n- Space Complexity: The code uses a constant amount of extra space for variables and does not depend on the input size. Hence, the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isSelfCrossing(int[] x) {\\n    if (x.length <= 3)\\n      return false;\\n\\n    for (int i = 3; i < x.length; ++i) {\\n      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])\\n        return true;\\n      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])\\n        return true;\\n      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] && x[i - 1] <= x[i - 3] &&\\n          x[i - 3] <= x[i - 1] + x[i - 5])\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isSelfCrossing(int[] x) {\\n    if (x.length <= 3)\\n      return false;\\n\\n    for (int i = 3; i < x.length; ++i) {\\n      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])\\n        return true;\\n      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])\\n        return true;\\n      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] && x[i - 1] <= x[i - 3] &&\\n          x[i - 3] <= x[i - 1] + x[i - 5])\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704549,
                "title": "spiral-and-same-coordinates-check",
                "content": "# Approach\\nFirst spiral check.\\nSecond each move make new point {0,0}, {0,1}...\\nLast check if we have two points with same coordinates.\\nBut I think there is a case that will not go through this solution.\\nIdk.\\n\\n# Code\\n```\\n        public class Solution\\n        {\\n            public bool IsSelfCrossing(int[] distance)\\n            {\\n                int[][] points = new int[1][];\\n                points[0] = new int[2] { 0, 0 };\\n                int currentx = 0;\\n                int currenty = 0;\\n                int direction = 0;\\n                for (int i = 0; i < distance.Length - 1; i++)\\n                {\\n                    if (i == distance.Length - 2)\\n                    {\\n                        return false;\\n                    }\\n                    if (distance[i+1] - distance[i] >= 1)\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                foreach (var item in distance)\\n                {\\n                    direction++;\\n                    switch (direction)\\n                    {\\n                        case 1:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty + 1;\\n                                currenty += 1;\\n                            }\\n                            break;\\n                        case 2:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx - 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx -= 1;\\n                            }\\n                            break;\\n                        case 3:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty - 1;\\n                                currenty -= 1;\\n                            }\\n                            break;\\n                        case 4:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx + 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx += 1;\\n                            }\\n                            direction = 0;\\n                            break;\\n                    }\\n                }\\n                for (int i = 0; i < points.Length; i++)\\n                {\\n                    for (int j = i + 1; j < points.Length; j++)\\n                    {\\n                        if (points[i][0] == points[j][0] && points[i][1] == points[j][1])\\n                        {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        public class Solution\\n        {\\n            public bool IsSelfCrossing(int[] distance)\\n            {\\n                int[][] points = new int[1][];\\n                points[0] = new int[2] { 0, 0 };\\n                int currentx = 0;\\n                int currenty = 0;\\n                int direction = 0;\\n                for (int i = 0; i < distance.Length - 1; i++)\\n                {\\n                    if (i == distance.Length - 2)\\n                    {\\n                        return false;\\n                    }\\n                    if (distance[i+1] - distance[i] >= 1)\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                foreach (var item in distance)\\n                {\\n                    direction++;\\n                    switch (direction)\\n                    {\\n                        case 1:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty + 1;\\n                                currenty += 1;\\n                            }\\n                            break;\\n                        case 2:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx - 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx -= 1;\\n                            }\\n                            break;\\n                        case 3:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty - 1;\\n                                currenty -= 1;\\n                            }\\n                            break;\\n                        case 4:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx + 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx += 1;\\n                            }\\n                            direction = 0;\\n                            break;\\n                    }\\n                }\\n                for (int i = 0; i < points.Length; i++)\\n                {\\n                    for (int j = i + 1; j < points.Length; j++)\\n                    {\\n                        if (points[i][0] == points[j][0] && points[i][1] == points[j][1])\\n                        {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580993,
                "title": "bad",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        \\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            \\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            \\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i-1] <= distance[i-3] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        \\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            \\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            \\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i-1] <= distance[i-3] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538232,
                "title": "best-100ms-efficiency-java-script-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480990,
                "title": "optional-expansion-phase-followed-by-optional-shrinking-phase",
                "content": "# Intuition\\nSo as not to cross, the spiral needs to either keep expanding, or keep shrinking, or start with an expansion phase and switch over once to the shrinking phase.\\n\\n# Code\\n```\\n#include <vector>\\n\\nenum class State\\n{\\n    BEGIN,\\n    EXPANDING,\\n    FIRST_SHRINK,\\n    SHRINKING,\\n};\\n\\nclass Solution\\n{\\npublic:\\n    bool isSelfCrossing(std::vector<int> &distance)\\n    {\\n        State state = State::BEGIN;\\n        for (int i = 2; i < distance.size(); i++)\\n        {\\n            int p = distance[i - 2];\\n            int c = distance[i];\\n            if (c > p)\\n            {\\n                if (state == State::SHRINKING || state == State::FIRST_SHRINK)\\n                {\\n                    return true;\\n                }\\n                state = State::EXPANDING;\\n            }\\n            else if (state == State::SHRINKING)\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n            else if (state == State::EXPANDING)\\n            {\\n                if (c >= distance[i - 2] - (i >= 4 ? distance[i - 4] : 0))\\n                {\\n                    distance[i - 1] -= distance[i - 3];\\n                }\\n                state = State::FIRST_SHRINK;\\n            }\\n            else if (state == State::BEGIN)\\n            {\\n                state = State::FIRST_SHRINK;\\n            }\\n            else\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n\\nenum class State\\n{\\n    BEGIN,\\n    EXPANDING,\\n    FIRST_SHRINK,\\n    SHRINKING,\\n};\\n\\nclass Solution\\n{\\npublic:\\n    bool isSelfCrossing(std::vector<int> &distance)\\n    {\\n        State state = State::BEGIN;\\n        for (int i = 2; i < distance.size(); i++)\\n        {\\n            int p = distance[i - 2];\\n            int c = distance[i];\\n            if (c > p)\\n            {\\n                if (state == State::SHRINKING || state == State::FIRST_SHRINK)\\n                {\\n                    return true;\\n                }\\n                state = State::EXPANDING;\\n            }\\n            else if (state == State::SHRINKING)\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n            else if (state == State::EXPANDING)\\n            {\\n                if (c >= distance[i - 2] - (i >= 4 ? distance[i - 4] : 0))\\n                {\\n                    distance[i - 1] -= distance[i - 3];\\n                }\\n                state = State::FIRST_SHRINK;\\n            }\\n            else if (state == State::BEGIN)\\n            {\\n                state = State::FIRST_SHRINK;\\n            }\\n            else\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3370250,
                "title": "java-100-easy-solution-0sec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic boolean isSelfCrossing(int[] x) {\\nboolean arm = false;\\nboolean leg = false;\\nfor (int i = 2; i < x.length; ++i) {\\nint a = f(x, i - 2) - f(x, i - 4);\\nint b = f(x, i - 2);\\n\\nif (arm && x[i] >= b)          return true;  // cross [i - 2]\\nif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\nif (x[i] < a)       arm = true;\\nelse if (x[i] <= b) leg = true;\\n}\\nreturn false;\\n}\\nprivate int f(int[] x, int index) {\\nreturn (index < 0) ? 0 : x[index];\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\npublic boolean isSelfCrossing(int[] x) {\\nboolean arm = false;\\nboolean leg = false;\\nfor (int i = 2; i < x.length; ++i) {\\nint a = f(x, i - 2) - f(x, i - 4);\\nint b = f(x, i - 2);\\n\\nif (arm && x[i] >= b)          return true;  // cross [i - 2]\\nif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\nif (x[i] < a)       arm = true;\\nelse if (x[i] <= b) leg = true;\\n}\\nreturn false;\\n}\\nprivate int f(int[] x, int index) {\\nreturn (index < 0) ? 0 : x[index];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350069,
                "title": "c-path-crossing",
                "content": "# Intuition\\nTo determine if the path crosses itself, we need to keep track of the coordinates we visit during the movement. We can do this by maintaining two sets - one for the x-coordinates and one for the y-coordinates.\\n# Approach\\nWe will initialize our current coordinates to `(0, 0)` and then move in a counter-clockwise direction using the given `distance` array. During each move, we will check if the new coordinates we reach already exist in our sets. If they do, it means the path has crossed itself, and we return `true`. If not, we add the new coordinates to our sets and continue with the next move.\\n# Complexity\\n- Time complexity:\\n `O(n)` where `n` is the length of the `distance` array since we traverse the array once.\\n\\n\\n- Space complexity:\\n`O(n)` where `n` is the length of the `distance` array, as we may have to store all the visited coordinates.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        if (len < 4) {\\n            return false;\\n        }\\n        for (int i = 3; i < len; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] == distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 4] + distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Geometry",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        if (len < 4) {\\n            return false;\\n        }\\n        for (int i = 3; i < len; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] == distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 4] + distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323479,
                "title": "solution",
                "content": "```C++ []\\nstatic const auto _ = []{ return ios_base::sync_with_stdio(false), 0; }();\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance)\\n    {\\n        int r[7]{};\\n        int i = 0;\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            r[0] = dx;\\n            if (dx <= r[4])\\n            {\\n                if (dx >= -r[6])\\n                    r[3] = -r[5];\\n                ++i;\\n                break;\\n            }\\n        }\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            if (dx >= r[4])\\n                return true;\\n            r[0] = dx;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        b = c = d = e = 0\\n        x = distance\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length <= 3) {\\n            return false;\\n        }\\n        int i = 2;\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic const auto _ = []{ return ios_base::sync_with_stdio(false), 0; }();\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance)\\n    {\\n        int r[7]{};\\n        int i = 0;\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            r[0] = dx;\\n            if (dx <= r[4])\\n            {\\n                if (dx >= -r[6])\\n                    r[3] = -r[5];\\n                ++i;\\n                break;\\n            }\\n        }\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            if (dx >= r[4])\\n                return true;\\n            r[0] = dx;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        b = c = d = e = 0\\n        x = distance\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n```\n```Java []\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length <= 3) {\\n            return false;\\n        }\\n        int i = 2;\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313838,
                "title": "spatial-reasoning-explained-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we consider what a crossing is, it is the moment when we have a planar cross on both the horizontal and vertical axis of their number lines within the last 6 total steps. For this, you need to record 5 current steps and the one you are taking. This will let you know whether or not your current step will incur a crossing as you do. To make this easier to maintain overtime, we can use a deque and the appendleft and pop processes to maintain updates. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a deque of 5 zeros to represent the last 5 steps in the past \\nThen, for each step in distance \\n- The first even axis offset we will consider is if steps[2] >= steps[0] > 0. This would imply that steps at 2, which is back towards steps at 0, has crossed it on that axis of values \\n- The odd axis will have three parts to it\\n    -  the first of which is if the current step is greater than or equal to the step taken two moves ago \\n    - The second part of the odd axis is if the current step has undone any of the advantage incurred by the prior step at steps 1 less the advance made at steps 3, and that that difference was positive\\n    - The third part is actually an even offset axis, and concerns steps at 2, 4, and 0. If 4 was able to undo the movement of 2 against 0, this is also necessary to be a satisfactory odd offset \\n    - all tgether, the odd offset is determined if the first part is true or both parts two and three are true \\n- If we have an even offset and an odd offset, we have a crossing as we have necessarily crossed both x and y axis of concern \\n- At the end of the check, add the current step to the front of the deque and pop off the last item so it does not grow. \\n\\nIf we never return in the loop we never will, return False   \\n\\nWe do not need more than 5 entries, since whenever we update to a new situation after 6 movements, we have completed three of each axis comparisons. The next one necessarily takes into account the prior moves, and as such is not based on the current location but the changes in location. This is why the odd offset needs to also involve the other prior axis far enough back. \\n\\n# Complexity\\n- Time complexity: O(N) as we take all the steps eventually \\n\\n- Space complexity: O(1) as we only need a deque of size 5 \\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        # make a deque of correct size \\n        steps = collections.deque([0, 0, 0, 0, 0])\\n        # for each step we could take \\n        for step in distance : \\n            # if we have an offset cross on the current even axis \\n            even_offset_1 = (steps[2] >= steps[0] > 0)\\n            # if we have either an instance where we have an offset cross on the odd axis most recent\\n            odd_offset_1 = (step >= steps[1])\\n            # or if now have a cross on the odd axis based on prior being positive \\n            odd_offset_2 = (step >= steps[1] - steps[3] >= 0)\\n            # and we had an even crossing offset priorly \\n            even_offset_2 = steps[4] >= steps[2] - steps[0]\\n            # if either odd_offset_1 or even_offset_2 and odd_offset_2 then we had a cross on the odd axis\\n            odd_offset = odd_offset_1 or (even_offset_2 and odd_offset_2)\\n            # if we have a cross on both the even and odd axis, then we have a cross \\n            if even_offset_1 and odd_offset : \\n                return True \\n            # push the current step to the front \\n            steps.appendleft(step)\\n            # remove the last step as you do \\n            steps.pop()\\n        # never crossed never will \\n        return False \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        # make a deque of correct size \\n        steps = collections.deque([0, 0, 0, 0, 0])\\n        # for each step we could take \\n        for step in distance : \\n            # if we have an offset cross on the current even axis \\n            even_offset_1 = (steps[2] >= steps[0] > 0)\\n            # if we have either an instance where we have an offset cross on the odd axis most recent\\n            odd_offset_1 = (step >= steps[1])\\n            # or if now have a cross on the odd axis based on prior being positive \\n            odd_offset_2 = (step >= steps[1] - steps[3] >= 0)\\n            # and we had an even crossing offset priorly \\n            even_offset_2 = steps[4] >= steps[2] - steps[0]\\n            # if either odd_offset_1 or even_offset_2 and odd_offset_2 then we had a cross on the odd axis\\n            odd_offset = odd_offset_1 or (even_offset_2 and odd_offset_2)\\n            # if we have a cross on both the even and odd axis, then we have a cross \\n            if even_offset_1 and odd_offset : \\n                return True \\n            # push the current step to the front \\n            steps.appendleft(step)\\n            # remove the last step as you do \\n            steps.pop()\\n        # never crossed never will \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142346,
                "title": "c-solution-runtime-23-ms-beats-85-94",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n = distance.size();\\n        if(n < 4) return false;\\n        for(int i = 3; i < n; i++){\\n            if(distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3]) return true;\\n            if(i >= 4 && distance[i-1] == distance[i-3] && distance[i] + distance[i-4] >= distance[i-2]) return true;\\n            if(i >= 5 && distance[i-2] >= distance[i-4] && distance[i-1] <= distance[i-3] && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] + distance[i-5] >= distance[i-3]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n = distance.size();\\n        if(n < 4) return false;\\n        for(int i = 3; i < n; i++){\\n            if(distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3]) return true;\\n            if(i >= 4 && distance[i-1] == distance[i-3] && distance[i] + distance[i-4] >= distance[i-2]) return true;\\n            if(i >= 5 && distance[i-2] >= distance[i-4] && distance[i-1] <= distance[i-3] && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] + distance[i-5] >= distance[i-3]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109581,
                "title": "cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n =distance.size();\\n        if(n<4) return false;\\n        distance.insert(distance.begin(),0);\\n       for(int i=3;i<n+1;i++)\\n       {\\n           if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) \\n           return true;\\n           \\n           if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n           }\\n          \\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n =distance.size();\\n        if(n<4) return false;\\n        distance.insert(distance.begin(),0);\\n       for(int i=3;i<n+1;i++)\\n       {\\n           if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) \\n           return true;\\n           \\n           if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n           }\\n          \\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993831,
                "title": "best-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution to this problem involves checking if the path of the person will cross itself. One way to do this is to check if the path intersects any previous lines that it has traced.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in the provided code is to iterate through the list of distances and check for specific conditions that would indicate a self-crossing. These conditions include:\\n\\n- The current distance is greater than or equal to the second to last distance and the previous distance is less than or equal to the third to last distance\\n- The current distance is greater than or equal to the second to last distance, the previous distance is equal to the third to last distance, and the fourth to last distance plus the current distance is greater than or equal to the second to last distance\\n- The current distance is greater than or equal to the second to last distance, the previous distance is less than or equal to the third to last distance, the second to last distance is greater than or equal to the fourth to last distance, and the previous distance plus the fifth to last distance is greater than or equal to the third to last distance\\n\\nIf any of these conditions are met, the function returns True. If the loop completes and none of these conditions are met, the function returns False.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) < 4:\\n            return False\\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) < 4:\\n            return False\\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967081,
                "title": "scala-concise-functional-solution-using-sliding-window",
                "content": "# Intuition\\nSee https://leetcode.com/problems/self-crossing/solutions/79141/another-python/.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nobject Solution {\\n  def isSelfCrossing(distance: Array[Int]): Boolean =\\n    distance.padTo(6, 0).sliding(6).exists { case Array(a, b, c, d, e, f) =>      \\n      d >= b && b > 0 && (a >= c || (a >= c - e && c - e >= 0 && f >= d - b))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def isSelfCrossing(distance: Array[Int]): Boolean =\\n    distance.padTo(6, 0).sliding(6).exists { case Array(a, b, c, d, e, f) =>      \\n      d >= b && b > 0 && (a >= c || (a >= c - e && c - e >= 0 && f >= d - b))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2939683,
                "title": "simple-c-solution",
                "content": "```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n\\nfor(int i=3;i<distanceSize;i++)\\n{\\nif(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\nif(i>=4 && distance[i-1]==distance[i-3] && distance[i]+distance[i-4]>=distance[i-2])\\n{\\n    return true;\\n}\\nif(i>=5 && distance[i-2]-distance[i-4]>=0 && distance[i]>=distance[i-2]-distance[i-4] && distance[i-1]>=distance[i-3]-distance[i-5] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\n}\\nreturn false;\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n\\nfor(int i=3;i<distanceSize;i++)\\n{\\nif(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\nif(i>=4 && distance[i-1]==distance[i-3] && distance[i]+distance[i-4]>=distance[i-2])\\n{\\n    return true;\\n}\\nif(i>=5 && distance[i-2]-distance[i-4]>=0 && distance[i]>=distance[i-2]-distance[i-4] && distance[i-1]>=distance[i-3]-distance[i-5] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\n}\\nreturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2936939,
                "title": "supplement-to-kuangyuan-s-0ms-solution-with-proof-of-correctness",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is the same as @KuangYuan\\'s 0ms solution. It is the best solution I have seen so far. However, the original answer does not contain a proof to its correctness, which I did here.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if (distance.length <= 3) {\\n            return false;\\n        }\\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i - 2] <= distance[i] + distance[i - 4]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 3] >= distance[i - 1] && distance[i - 1] >= distance[i - 3] - distance[i - 5]\\n                    && distance[i - 2] >= distance[i - 4]\\n                    && distance[i - 2] <= distance[i - 4] + distance[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Proof of Correctness\\nWe use seg[i] to represents the i-th segment, and prove that when we check if seg[i+1] crosses any previous segments, we only need to check seg[i-2] and seg[i-4].\\n\\nFor vertical segments, seg[i].x is the x coordinate. seg[i].y1/y2 is the smaller/larger y coordinate. For horizontal segments, we use seg[i].y and seg[i].x1/x2 respectively.\\n\\nWLOG, assume we are looking at segment i, which goes to the north. And segments 0 to i does not have cross or end meets. Now we consider conditions that could make seg[i+1] cross any previous segment, and prove that for seg[i+1], we only need to check seg[i-2] and seg[i-4] for crossing.\\n\\nBecause seg[i-1] goes to the east, and seg[i-3] goes to the west, we know seg[i-2].x < seg[i].x, and seg[i-2].x < seg[i-4].x. So there are just two cases regarding seg[i-4] and seg[i].\\n\\nCase 1: seg[i].x < seg[i-4].x ( seg[i] is between seg[i-4] and seg[i-2] ):\\nIn this case, we prove that any vertical segment seg[i-2j], j>1 will not overlap with the rectangle formed by seg[i-2],seg[i-1], seg[i], and seg[i+1]. We prove by contradiction. If there is some seg[i-2j] overlaps with the rectangle, look at the largest such j and let i-2j =k. We know seg[k] must go north because there\\'s no self crossing before i, and the only opening of the rectangle (seg[i+1]) is at the north. And because seg[k] is the largest k going out of the rectangle, later segments cannot go back into the rectangle. Use induction we could easily show that without self-crossing, for all i > k we have seg[i].x < seg[k].x. This is contradict to the fact that seg[k].x < seg[i].x < seg[i-4].x, where k < i-4, and complete the proof that there is no vertical segment cross with seg[i+1] between seg[i-2] and seg[i]. As such, seg[i+1] can only cross seg[i-2] when it goes to west.\\n\\nCase 2: seg[i].x > seg[i-4].x:\\nIn this case, we discuss the situation in two subcases.\\n\\nFirst, if seg[i-4].x1 <= seg[i].x2, there will be no vertical edges between seg[i-4] and seg[i] that can potentially cross seg[i+1]. Second, if seg[i-4].x1 > seg[i].x2, there will be no vertical edges between seg[i-2] and seg[i] that can potentially cross seg[i+1]. The process is the same as above (contradiction and induction). So in this case, seg[i+1] can only cross seg[i-4] or seg[i-2].\\n\\nThis shows that in all cases, seg[i+1] can only cross with seg[i-2] and seg[i-4], and complete the cross proof. The proof for end meet is obvious so I will skip here.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if (distance.length <= 3) {\\n            return false;\\n        }\\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i - 2] <= distance[i] + distance[i - 4]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 3] >= distance[i - 1] && distance[i - 1] >= distance[i - 3] - distance[i - 5]\\n                    && distance[i - 2] >= distance[i - 4]\\n                    && distance[i - 2] <= distance[i - 4] + distance[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928748,
                "title": "don-t-do-this",
                "content": "```\\n#include <vector>\\n#include <iostream>\\n\\n// #define DEBUG\\n\\nusing namespace std;\\n\\nstatic inline void print_xys(int* xs, int* ys) {\\n    for (int i = 0; i < 7; i++) {\\n        cout << \"xy[\" << i << \"] = \" << xs[i] << \", \" << ys[i] << \"\\\\n\";\\n    }\\n    cout << \"\\\\n\";\\n}\\n\\nstatic inline void update_xys(int* xs, int* ys, vector<int>& moves, int move) {\\n    assert(move < moves.size());\\n    for (int i = 0; i < 6; i++) {\\n        xs[i] = xs[i+1];\\n        ys[i] = ys[i+1];\\n    }\\n    xs[6] = (move % 2 == 0) ? xs[5] : ((move % 4 == 1) ? xs[5] - moves[move] : xs[5] + moves[move]);\\n    ys[6] = (move % 2 == 1) ? ys[5] : ((move % 4 == 0) ? ys[5] + moves[move] : ys[5] - moves[move]);\\n}\\n\\nstatic inline bool is_self_crossing(vector<int>& moves) {\\n    // Store the past 5 x\\'s and y\\'s including the current one at\\n    // xs[4], ys[4] (and the transitions from x[i], y[i] to x[i+1], y[i+1])\\n    // corresponds to move[j] where in the beginning j = 0, but then it will\\n    // be shifted by one each time\\n    int xs[7];\\n    int ys[7];\\n    // Before any move\\n    xs[0] = 0;\\n    ys[0] = 0;\\n\\n    if (moves.size() <= 3) return false;\\n    assert(moves.size() >= 4);\\n    // Move 1\\n    xs[1] = xs[0];\\n    ys[1] = ys[0] + moves[0];\\n    // Move 2\\n    xs[2] = xs[1] - moves[1];\\n    ys[2] = ys[1];\\n    // Move 3\\n    xs[3] = xs[2];\\n    ys[3] = ys[2] - moves[2];\\n    // Move 4\\n    xs[4] = xs[3] + moves[3];\\n    ys[4] = ys[3];\\n    \\n    assert(xs[0] == xs[1] && xs[1] > xs[2] && xs[2] == xs[3] && xs[3] < xs[4]);\\n    // assert(ys[0] < ys[1] && ys[1] == ys[2] && ys[2] > ys[3] && ys[3] == ys[4]);\\n\\n    // In four moves you can only end by touching crossing the first line\\n    bool crossed_1st_line = 0 <= ys[4] && 0 <= xs[4];\\n    if (moves.size() == 4 || crossed_1st_line) return crossed_1st_line;\\n\\n    assert(moves.size() >= 5);\\n    xs[5] = xs[4];\\n    ys[5] = ys[4] + moves[4];\\n\\n    // In five moves you can only end by touching teh 2nd line from the bottom\\n    // or crosssing the second line\\n    bool touched_1st_line_tip_or_crossed_2nd = (xs[5] == 0 && ys[5] >= 0) || (xs[5] < 0 && ys[5] > ys[1]);\\n    if (moves.size() == 5 || touched_1st_line_tip_or_crossed_2nd) return touched_1st_line_tip_or_crossed_2nd;\\n    \\n    assert(moves.size() >= 6);\\n    xs[6] = xs[5] - moves[5];\\n    ys[6] = ys[5];\\n    // In six moves you can only end by touching the first line or the third\\n    bool touched_1st_line_or_crossed_3rd = (xs[0] <= xs[5] && xs[6] <= xs[0] && ys[0] <= ys[6] && ys[6] <= ys[1]) || (xs[6] <= xs[2] && ys[6] <= ys[2]);\\n    if (moves.size() == 6 || touched_1st_line_or_crossed_3rd) return touched_1st_line_or_crossed_3rd;\\n    // At this point, depending on whether we are above or below zero, we have to change our update\\n    // based on whether we coming into the rectangle we just drew or outside/around it (hitting a wall)\\n    // We can always tell those last two horizontal segments (image we went down) and we know also if we are\\n    // outside or inside from our relative position so we can tell if we are crossing one of them. Because of that\\n    // quirk, we start to use the last part of the xys\\n    assert(moves.size() >= 7);\\n    for (int move = 6; move < moves.size(); move++) {\\n        update_xys(xs, ys, moves, move);\\n        #ifdef DEBUG\\n        print_xys(xs, ys);\\n        #endif\\n        // as is our last direction of movement, while bs is perpendicular\\n        int *as = xs, *bs = ys;                  // Default Left/Right Move\\n        if (move % 2 == 0) { as = ys; bs = xs; } // Up/Down Move\\n        int front_start = min(bs[0], bs[1]), front_end = max(bs[0], bs[1]);\\n        int back_start = min(bs[2], bs[3]), back_end = max(bs[2], bs[3]);\\n        bool crossed_front = (as[5] <= as[0] && as[6] >= as[0]) || (as[6] >= as[0] && as[6] <= as[0]);\\n        bool crossed_back = (as[5] <= as[2] && as[6] >= as[2]) || (as[5] >= as[2] && as[6] <= as[2]);\\n\\n        // If you crossed the front wall or back wall then we crossed (front wall only possible if you\\'re outside)\\n        if (front_start <= bs[6] && bs[6] <= front_end && crossed_front) return true;\\n        if (back_start <= bs[6] && bs[6] <= back_end && crossed_back) return true;\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& moves) { return is_self_crossing(moves); }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <iostream>\\n\\n// #define DEBUG\\n\\nusing namespace std;\\n\\nstatic inline void print_xys(int* xs, int* ys) {\\n    for (int i = 0; i < 7; i++) {\\n        cout << \"xy[\" << i << \"] = \" << xs[i] << \", \" << ys[i] << \"\\\\n\";\\n    }\\n    cout << \"\\\\n\";\\n}\\n\\nstatic inline void update_xys(int* xs, int* ys, vector<int>& moves, int move) {\\n    assert(move < moves.size());\\n    for (int i = 0; i < 6; i++) {\\n        xs[i] = xs[i+1];\\n        ys[i] = ys[i+1];\\n    }\\n    xs[6] = (move % 2 == 0) ? xs[5] : ((move % 4 == 1) ? xs[5] - moves[move] : xs[5] + moves[move]);\\n    ys[6] = (move % 2 == 1) ? ys[5] : ((move % 4 == 0) ? ys[5] + moves[move] : ys[5] - moves[move]);\\n}\\n\\nstatic inline bool is_self_crossing(vector<int>& moves) {\\n    // Store the past 5 x\\'s and y\\'s including the current one at\\n    // xs[4], ys[4] (and the transitions from x[i], y[i] to x[i+1], y[i+1])\\n    // corresponds to move[j] where in the beginning j = 0, but then it will\\n    // be shifted by one each time\\n    int xs[7];\\n    int ys[7];\\n    // Before any move\\n    xs[0] = 0;\\n    ys[0] = 0;\\n\\n    if (moves.size() <= 3) return false;\\n    assert(moves.size() >= 4);\\n    // Move 1\\n    xs[1] = xs[0];\\n    ys[1] = ys[0] + moves[0];\\n    // Move 2\\n    xs[2] = xs[1] - moves[1];\\n    ys[2] = ys[1];\\n    // Move 3\\n    xs[3] = xs[2];\\n    ys[3] = ys[2] - moves[2];\\n    // Move 4\\n    xs[4] = xs[3] + moves[3];\\n    ys[4] = ys[3];\\n    \\n    assert(xs[0] == xs[1] && xs[1] > xs[2] && xs[2] == xs[3] && xs[3] < xs[4]);\\n    // assert(ys[0] < ys[1] && ys[1] == ys[2] && ys[2] > ys[3] && ys[3] == ys[4]);\\n\\n    // In four moves you can only end by touching crossing the first line\\n    bool crossed_1st_line = 0 <= ys[4] && 0 <= xs[4];\\n    if (moves.size() == 4 || crossed_1st_line) return crossed_1st_line;\\n\\n    assert(moves.size() >= 5);\\n    xs[5] = xs[4];\\n    ys[5] = ys[4] + moves[4];\\n\\n    // In five moves you can only end by touching teh 2nd line from the bottom\\n    // or crosssing the second line\\n    bool touched_1st_line_tip_or_crossed_2nd = (xs[5] == 0 && ys[5] >= 0) || (xs[5] < 0 && ys[5] > ys[1]);\\n    if (moves.size() == 5 || touched_1st_line_tip_or_crossed_2nd) return touched_1st_line_tip_or_crossed_2nd;\\n    \\n    assert(moves.size() >= 6);\\n    xs[6] = xs[5] - moves[5];\\n    ys[6] = ys[5];\\n    // In six moves you can only end by touching the first line or the third\\n    bool touched_1st_line_or_crossed_3rd = (xs[0] <= xs[5] && xs[6] <= xs[0] && ys[0] <= ys[6] && ys[6] <= ys[1]) || (xs[6] <= xs[2] && ys[6] <= ys[2]);\\n    if (moves.size() == 6 || touched_1st_line_or_crossed_3rd) return touched_1st_line_or_crossed_3rd;\\n    // At this point, depending on whether we are above or below zero, we have to change our update\\n    // based on whether we coming into the rectangle we just drew or outside/around it (hitting a wall)\\n    // We can always tell those last two horizontal segments (image we went down) and we know also if we are\\n    // outside or inside from our relative position so we can tell if we are crossing one of them. Because of that\\n    // quirk, we start to use the last part of the xys\\n    assert(moves.size() >= 7);\\n    for (int move = 6; move < moves.size(); move++) {\\n        update_xys(xs, ys, moves, move);\\n        #ifdef DEBUG\\n        print_xys(xs, ys);\\n        #endif\\n        // as is our last direction of movement, while bs is perpendicular\\n        int *as = xs, *bs = ys;                  // Default Left/Right Move\\n        if (move % 2 == 0) { as = ys; bs = xs; } // Up/Down Move\\n        int front_start = min(bs[0], bs[1]), front_end = max(bs[0], bs[1]);\\n        int back_start = min(bs[2], bs[3]), back_end = max(bs[2], bs[3]);\\n        bool crossed_front = (as[5] <= as[0] && as[6] >= as[0]) || (as[6] >= as[0] && as[6] <= as[0]);\\n        bool crossed_back = (as[5] <= as[2] && as[6] >= as[2]) || (as[5] >= as[2] && as[6] <= as[2]);\\n\\n        // If you crossed the front wall or back wall then we crossed (front wall only possible if you\\'re outside)\\n        if (front_start <= bs[6] && bs[6] <= front_end && crossed_front) return true;\\n        if (back_start <= bs[6] && bs[6] <= back_end && crossed_back) return true;\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& moves) { return is_self_crossing(moves); }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834715,
                "title": "just-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_self_crossing(distance: Vec<i32>) -> bool {\\n        let mut b = 0;\\n        let mut c = 0;\\n        let mut d = 0;\\n        let mut e = 0;\\n        let mut f = 0;\\n        for a in distance.iter() {\\n            if (d >= b && b > 0) && (*a >= c || ((*a >= c - e) && c - e >= 0) && (f >= d - b)) {\\n                return true;\\n            }\\n            f = e;\\n            e = d;\\n            d = c;\\n            c = b;\\n            b = *a;\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_self_crossing(distance: Vec<i32>) -> bool {\\n        let mut b = 0;\\n        let mut c = 0;\\n        let mut d = 0;\\n        let mut e = 0;\\n        let mut f = 0;\\n        for a in distance.iter() {\\n            if (d >= b && b > 0) && (*a >= c || ((*a >= c - e) && c - e >= 0) && (f >= d - b)) {\\n                return true;\\n            }\\n            f = e;\\n            e = d;\\n            d = c;\\n            c = b;\\n            b = *a;\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2824421,
                "title": "swift-136-ms",
                "content": "```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n        let n = distance.count\\n        guard n > 3 else { return false }\\n        var i = 2\\n        while i < n - 1 {\\n            if distance[i] <= distance[i - 2] { break }\\n            i += 1\\n        }\\n        if i == n - 1 { return false }\\n        let minusPrev = (i >= 4 ? distance[i - 4] : 0) >= distance[i - 2] - distance[i]\\n        let limit = distance[i - 1] - (i > 2 && minusPrev ? distance[i - 3] : 0)\\n        if distance[i + 1] >= limit { return true }\\n        i += 2\\n        while i < n {\\n            if distance[i] >= distance[i - 2] { return true }\\n            i += 1\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n        let n = distance.count\\n        guard n > 3 else { return false }\\n        var i = 2\\n        while i < n - 1 {\\n            if distance[i] <= distance[i - 2] { break }\\n            i += 1\\n        }\\n        if i == n - 1 { return false }\\n        let minusPrev = (i >= 4 ? distance[i - 4] : 0) >= distance[i - 2] - distance[i]\\n        let limit = distance[i - 1] - (i > 2 && minusPrev ? distance[i - 3] : 0)\\n        if distance[i + 1] >= limit { return true }\\n        i += 2\\n        while i < n {\\n            if distance[i] >= distance[i - 2] { return true }\\n            i += 1\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666372,
                "title": "i-m-not-even-programmer-just-learn",
                "content": "I can`t write some great algorithms like other, but I break through with simple abstraction and geometry)))))\\nNot even Last\\n\\n```\\nclass Solution {\\n    enum Direction{\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n    public boolean isSelfCrossing(int[] distance) {\\n        int mostLeftLine = 0;\\n        int mostRightLine = 0;\\n        int highestLine = 0;\\n        int lowestLine = 0;\\n        LinkedList<Point> pointsList = new LinkedList<>();\\n        Point p = new Point(0, 0);\\n        pointsList.add(p);\\n        LinkedList<LineV> verticalLines = new LinkedList<>();\\n        LinkedList<LineH> horisontalLines = new LinkedList<>();\\n\\n        Direction d = Direction.NORTH;\\n        for (int el :distance){\\n            \\n            switch (d){\\n                case NORTH:\\n                    pointsList.add(p = new Point(p.X, p.Y+el));\\n                    d = Direction.WEST;\\n                    break;\\n                case WEST:\\n                    pointsList.add(p = new Point(p.X-el, p.Y));\\n                    d = Direction.SOUTH;\\n                    break;\\n                case SOUTH:\\n                    pointsList.add(p = new Point(p.X, p.Y-el));\\n                    d = Direction.EAST;\\n                    break;\\n                case EAST:\\n                    pointsList.add(p = new Point(p.X+el, p.Y));\\n                    d = Direction.NORTH;\\n                    break;\\n            }\\n        }\\n\\n        boolean isVertial = true;\\n        while(pointsList.size()>1){\\n            if (isVertial){\\n                LineV v = new LineV(pointsList.removeFirst(), pointsList.getFirst());\\n                if (horisontalLines.size()>1){\\n                    if(v.X > mostRightLine){\\n                        mostRightLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    if(v.X < mostLeftLine){\\n                        mostLeftLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    for(LineH h : horisontalLines){\\n                        if (v.isCrossing(h))\\n                            return true;\\n                    }    \\n                }\\n                verticalLines.add(v);\\n                isVertial = !isVertial;\\n            }\\n            else{\\n                LineH h = new LineH(pointsList.removeFirst(), pointsList.getFirst());\\n                if (h.Y > highestLine){\\n                    highestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (h.Y < lowestLine){\\n                    lowestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (verticalLines.size()>1){\\n                   for(LineV v : verticalLines){\\n                        if (h.isCrossing(v))\\n                            return true;\\n                    } \\n                }\\n                horisontalLines.add(h);\\n                isVertial = !isVertial;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\nclass LineV{\\n    int minY;\\n    int maxY;\\n    int X;\\n    Point start;\\n    Point end;\\n    \\n    LineV(Point s, Point e){\\n        X=s.X;\\n        start = s;\\n        end = e;\\n        minY = Math.min(s.Y, e.Y);\\n        maxY = Math.max(s.Y, e.Y);\\n    }\\n    boolean isCrossing(LineH horisontalLine){\\n        if (end.Y == 0 && X == 0)\\n            return true;\\n        if (horisontalLine.end.Y == start.Y)\\n            return false;\\n        if (X<=horisontalLine.maxX && X>=horisontalLine.minX && horisontalLine.Y <=maxY && horisontalLine.Y>=minY)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass LineH{\\n    int minX;\\n    int maxX;\\n    int Y;\\n    Point start;\\n    Point end;\\n    \\n    LineH(Point s, Point e){\\n        Y = s.Y;\\n        start = s;\\n        end = e;\\n        minX = Math.min(s.X, e.X);\\n        maxX = Math.max(s.X, e.X);\\n    }\\n    boolean isCrossing(LineV vertialLine){\\n        if (vertialLine.end.Y == start.Y)\\n            return false;\\n        if (Y>=vertialLine.minY && Y<=vertialLine.maxY && minX <= vertialLine.X && maxX >= vertialLine.X)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass Point{\\n    int X;\\n    int Y;\\n    \\n    public Point(int x, int y){\\n        X=x;\\n        Y=y;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    enum Direction{\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n    public boolean isSelfCrossing(int[] distance) {\\n        int mostLeftLine = 0;\\n        int mostRightLine = 0;\\n        int highestLine = 0;\\n        int lowestLine = 0;\\n        LinkedList<Point> pointsList = new LinkedList<>();\\n        Point p = new Point(0, 0);\\n        pointsList.add(p);\\n        LinkedList<LineV> verticalLines = new LinkedList<>();\\n        LinkedList<LineH> horisontalLines = new LinkedList<>();\\n\\n        Direction d = Direction.NORTH;\\n        for (int el :distance){\\n            \\n            switch (d){\\n                case NORTH:\\n                    pointsList.add(p = new Point(p.X, p.Y+el));\\n                    d = Direction.WEST;\\n                    break;\\n                case WEST:\\n                    pointsList.add(p = new Point(p.X-el, p.Y));\\n                    d = Direction.SOUTH;\\n                    break;\\n                case SOUTH:\\n                    pointsList.add(p = new Point(p.X, p.Y-el));\\n                    d = Direction.EAST;\\n                    break;\\n                case EAST:\\n                    pointsList.add(p = new Point(p.X+el, p.Y));\\n                    d = Direction.NORTH;\\n                    break;\\n            }\\n        }\\n\\n        boolean isVertial = true;\\n        while(pointsList.size()>1){\\n            if (isVertial){\\n                LineV v = new LineV(pointsList.removeFirst(), pointsList.getFirst());\\n                if (horisontalLines.size()>1){\\n                    if(v.X > mostRightLine){\\n                        mostRightLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    if(v.X < mostLeftLine){\\n                        mostLeftLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    for(LineH h : horisontalLines){\\n                        if (v.isCrossing(h))\\n                            return true;\\n                    }    \\n                }\\n                verticalLines.add(v);\\n                isVertial = !isVertial;\\n            }\\n            else{\\n                LineH h = new LineH(pointsList.removeFirst(), pointsList.getFirst());\\n                if (h.Y > highestLine){\\n                    highestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (h.Y < lowestLine){\\n                    lowestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (verticalLines.size()>1){\\n                   for(LineV v : verticalLines){\\n                        if (h.isCrossing(v))\\n                            return true;\\n                    } \\n                }\\n                horisontalLines.add(h);\\n                isVertial = !isVertial;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\nclass LineV{\\n    int minY;\\n    int maxY;\\n    int X;\\n    Point start;\\n    Point end;\\n    \\n    LineV(Point s, Point e){\\n        X=s.X;\\n        start = s;\\n        end = e;\\n        minY = Math.min(s.Y, e.Y);\\n        maxY = Math.max(s.Y, e.Y);\\n    }\\n    boolean isCrossing(LineH horisontalLine){\\n        if (end.Y == 0 && X == 0)\\n            return true;\\n        if (horisontalLine.end.Y == start.Y)\\n            return false;\\n        if (X<=horisontalLine.maxX && X>=horisontalLine.minX && horisontalLine.Y <=maxY && horisontalLine.Y>=minY)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass LineH{\\n    int minX;\\n    int maxX;\\n    int Y;\\n    Point start;\\n    Point end;\\n    \\n    LineH(Point s, Point e){\\n        Y = s.Y;\\n        start = s;\\n        end = e;\\n        minX = Math.min(s.X, e.X);\\n        maxX = Math.max(s.X, e.X);\\n    }\\n    boolean isCrossing(LineV vertialLine){\\n        if (vertialLine.end.Y == start.Y)\\n            return false;\\n        if (Y>=vertialLine.minY && Y<=vertialLine.maxY && minX <= vertialLine.X && maxX >= vertialLine.X)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass Point{\\n    int X;\\n    int Y;\\n    \\n    public Point(int x, int y){\\n        X=x;\\n        Y=y;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650215,
                "title": "c-searching-in-stl-deque-last-4edges-except-immediate-last-and-very-last-point",
                "content": "```\\n#define mp make_pair\\nclass Solution {\\nprivate:\\n    bool isCross(deque<pair<int, pair<int, int>>> &xpath, int x, int ymin, int ymax){\\n        //cout<<x<<\":\"<<ymin << \",\" << ymax<<endl;\\n        if(xpath.size()<=1) return false;\\n        for (auto it = xpath.cbegin();it!=xpath.cend()-1;it++) {\\n            //cout<<*it.first<<\",[\"<<*it.second.first << \",\" << *it.second.second<<\"]\"<<endl;\\n            if ((*it).first > ymax)\\n                continue;\\n            if (ymin > (*it).first)\\n                continue;\\n            if((*it).second.first <= x && x <= (*it).second.second)\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        deque<pair<int, pair<int, int>>> xpath,ypath;\\n        //<x-position<y_low,y_high>> | xpath= vertical lines | ypath=horizontal lines\\n        int x=0,y=0;\\n        for(int i=0; i<distance.size(); i++){\\n            switch(i%4){\\n                case 0:{\\n                    if(isCross(xpath,x,y,y+distance[i])) return true;\\n                    ypath.push_back(mp(x, mp(y, y + distance[i])));\\n                    y += distance[i];\\n                    break;\\n                }\\n                case 1:{\\n                    if(isCross(ypath,y,x-distance[i],x)) return true;\\n                    xpath.push_back(mp(y, mp(x - distance[i], x)));\\n                    x -= distance[i];\\n                    break;\\n                }\\n                case 2:{\\n                    if(isCross(xpath,x,y-distance[i],y)) return true;\\n                    ypath.push_back(mp(x, mp(y - distance[i], y)));\\n                    y -= distance[i];\\n                    break;\\n                }\\n                default:{\\n                    if(isCross(ypath,y,x,x+distance[i])) return true;\\n                    xpath.push_back(mp(y, mp(x, x + distance[i])));\\n                    x += distance[i];\\n                    break;\\n                }\\n            }\\n            while(xpath.size()>3) xpath.erase(xpath.begin());\\n            while(ypath.size()>3) ypath.erase(ypath.begin());\\n        }\\n        if(distance.size()%2!=0){\\n            if (isCross(ypath,y,x,x))\\n                return true;\\n        } else {\\n            if (isCross(xpath,x,y,y))\\n                return true;\\n        }\\n        //cout<<\"x-paths\"<<endl; for(auto i:xpath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        //cout<<\"y-paths\"<<endl; for(auto i:ypath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\n#define mp make_pair\\nclass Solution {\\nprivate:\\n    bool isCross(deque<pair<int, pair<int, int>>> &xpath, int x, int ymin, int ymax){\\n        //cout<<x<<\":\"<<ymin << \",\" << ymax<<endl;\\n        if(xpath.size()<=1) return false;\\n        for (auto it = xpath.cbegin();it!=xpath.cend()-1;it++) {\\n            //cout<<*it.first<<\",[\"<<*it.second.first << \",\" << *it.second.second<<\"]\"<<endl;\\n            if ((*it).first > ymax)\\n                continue;\\n            if (ymin > (*it).first)\\n                continue;\\n            if((*it).second.first <= x && x <= (*it).second.second)\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        deque<pair<int, pair<int, int>>> xpath,ypath;\\n        //<x-position<y_low,y_high>> | xpath= vertical lines | ypath=horizontal lines\\n        int x=0,y=0;\\n        for(int i=0; i<distance.size(); i++){\\n            switch(i%4){\\n                case 0:{\\n                    if(isCross(xpath,x,y,y+distance[i])) return true;\\n                    ypath.push_back(mp(x, mp(y, y + distance[i])));\\n                    y += distance[i];\\n                    break;\\n                }\\n                case 1:{\\n                    if(isCross(ypath,y,x-distance[i],x)) return true;\\n                    xpath.push_back(mp(y, mp(x - distance[i], x)));\\n                    x -= distance[i];\\n                    break;\\n                }\\n                case 2:{\\n                    if(isCross(xpath,x,y-distance[i],y)) return true;\\n                    ypath.push_back(mp(x, mp(y - distance[i], y)));\\n                    y -= distance[i];\\n                    break;\\n                }\\n                default:{\\n                    if(isCross(ypath,y,x,x+distance[i])) return true;\\n                    xpath.push_back(mp(y, mp(x, x + distance[i])));\\n                    x += distance[i];\\n                    break;\\n                }\\n            }\\n            while(xpath.size()>3) xpath.erase(xpath.begin());\\n            while(ypath.size()>3) ypath.erase(ypath.begin());\\n        }\\n        if(distance.size()%2!=0){\\n            if (isCross(ypath,y,x,x))\\n                return true;\\n        } else {\\n            if (isCross(xpath,x,y,y))\\n                return true;\\n        }\\n        //cout<<\"x-paths\"<<endl; for(auto i:xpath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        //cout<<\"y-paths\"<<endl; for(auto i:ypath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2496230,
                "title": "c-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    if a line segment is horizontal, we push (a, b, x, 0) to visited,\\n    representing the line from (a,b) to (a+x,b).\\n    \\n    if a line segment is vertical, we push (c, d, 0, y) to visited,\\n    representing the line from (c,d) to (c,d+y).\\n    \\n    we make sure that x and y are positive regardless of the direction of the line segment\\n    */\\n    \\n    /*\\n    A horizontal line segment (a,b,x,0) intersects a vertical line segment (c,d,0,y) if \\n              (c,d+y)\\n                ^\\n                |\\n                |    \\n    (a,b) --------------> (a+x,b)\\n                |\\n                |\\n               (c,d)\\n    \\n    (1) a <= c <= a+x\\n    (2) d <= b <= d+y\\n    */\\n\\n    /*\\n    A horizontal line segment (a,b,x,0) intersects another horizontal line segment \\n    (c,d,t,0) if \\n    \\n    (1) b==d; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) a <= c <= a+x\\n    (2b) c <= a <= c+t\\n    (2c) a <= c <= c+t <= a+x\\n    (2d) c <= a <= a+x <= c+t\\n    */\\n    \\n    /*\\n    A vertical line segment (a,b,0,y) intersects another vertical line segment \\n    (c,d,0,t) if \\n    \\n    (1) a==c; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) b <= d <= b+y\\n    (2b) d <= b <= d+t\\n    (2c) b <= d <= d+t <= b+y\\n    (2d) d <= b <= b+y <= d+t\\n    */\\n    \\n    std::vector<std::vector<int>> visited;\\n    \\n    int x=0, y=0; //current position (x,y)\\n    \\n    void print(std::vector<int> v){\\n        for (int x: v){\\n            std::cout<<x<<\", \";\\n        }\\n        std::cout<<\"\\\\n\";\\n    }\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        std::vector<int> curr, temp;\\n        \\n        if (len<=3) return false;\\n        \\n        for (int i=0; i<len; i++){\\n            if (i%4==0){\\n                visited.push_back(std::vector<int>{x, y, 0, distance[i]});\\n                y += distance[i];\\n            \\n            }else if (i%4==1){\\n                visited.push_back(std::vector<int>{x-distance[i], y, distance[i], 0});\\n                x -= distance[i];\\n                \\n            }else if (i%4==2){\\n                visited.push_back(std::vector<int>{x, y-distance[i], 0, distance[i]});\\n                y -= distance[i];\\n            \\n            }else if (i%4==3){\\n                visited.push_back(std::vector<int>{x, y, distance[i], 0});\\n                x += distance[i];\\n            }\\n             \\n            curr = visited.back();\\n            \\n            if (i>=3){\\n                //check if the current line segment intersects visited[i-3]\\n                temp = visited[i-3];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=4){\\n                //check if the current line segment intersects visited[i-4]\\n                temp = visited[i-4];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2])\\n                        return true;\\n                    if (curr[1]==temp[1] && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] \\n                        && temp[0]+temp[2]<=curr[0]+curr[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && temp[0]<=curr[0]\\n                        && curr[0]+curr[2]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[0]==temp[0] && curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && curr[1]<=temp[1]\\n                        && temp[1]+temp[3]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1]\\n                        && curr[1]+curr[3]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=5){\\n                //check if the current line segment intersects visited[i-5]\\n                temp = visited[i-5];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    if a line segment is horizontal, we push (a, b, x, 0) to visited,\\n    representing the line from (a,b) to (a+x,b).\\n    \\n    if a line segment is vertical, we push (c, d, 0, y) to visited,\\n    representing the line from (c,d) to (c,d+y).\\n    \\n    we make sure that x and y are positive regardless of the direction of the line segment\\n    */\\n    \\n    /*\\n    A horizontal line segment (a,b,x,0) intersects a vertical line segment (c,d,0,y) if \\n              (c,d+y)\\n                ^\\n                |\\n                |    \\n    (a,b) --------------> (a+x,b)\\n                |\\n                |\\n               (c,d)\\n    \\n    (1) a <= c <= a+x\\n    (2) d <= b <= d+y\\n    */\\n\\n    /*\\n    A horizontal line segment (a,b,x,0) intersects another horizontal line segment \\n    (c,d,t,0) if \\n    \\n    (1) b==d; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) a <= c <= a+x\\n    (2b) c <= a <= c+t\\n    (2c) a <= c <= c+t <= a+x\\n    (2d) c <= a <= a+x <= c+t\\n    */\\n    \\n    /*\\n    A vertical line segment (a,b,0,y) intersects another vertical line segment \\n    (c,d,0,t) if \\n    \\n    (1) a==c; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) b <= d <= b+y\\n    (2b) d <= b <= d+t\\n    (2c) b <= d <= d+t <= b+y\\n    (2d) d <= b <= b+y <= d+t\\n    */\\n    \\n    std::vector<std::vector<int>> visited;\\n    \\n    int x=0, y=0; //current position (x,y)\\n    \\n    void print(std::vector<int> v){\\n        for (int x: v){\\n            std::cout<<x<<\", \";\\n        }\\n        std::cout<<\"\\\\n\";\\n    }\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        std::vector<int> curr, temp;\\n        \\n        if (len<=3) return false;\\n        \\n        for (int i=0; i<len; i++){\\n            if (i%4==0){\\n                visited.push_back(std::vector<int>{x, y, 0, distance[i]});\\n                y += distance[i];\\n            \\n            }else if (i%4==1){\\n                visited.push_back(std::vector<int>{x-distance[i], y, distance[i], 0});\\n                x -= distance[i];\\n                \\n            }else if (i%4==2){\\n                visited.push_back(std::vector<int>{x, y-distance[i], 0, distance[i]});\\n                y -= distance[i];\\n            \\n            }else if (i%4==3){\\n                visited.push_back(std::vector<int>{x, y, distance[i], 0});\\n                x += distance[i];\\n            }\\n             \\n            curr = visited.back();\\n            \\n            if (i>=3){\\n                //check if the current line segment intersects visited[i-3]\\n                temp = visited[i-3];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=4){\\n                //check if the current line segment intersects visited[i-4]\\n                temp = visited[i-4];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2])\\n                        return true;\\n                    if (curr[1]==temp[1] && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] \\n                        && temp[0]+temp[2]<=curr[0]+curr[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && temp[0]<=curr[0]\\n                        && curr[0]+curr[2]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[0]==temp[0] && curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && curr[1]<=temp[1]\\n                        && temp[1]+temp[3]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1]\\n                        && curr[1]+curr[3]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=5){\\n                //check if the current line segment intersects visited[i-5]\\n                temp = visited[i-5];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454062,
                "title": "ruby-solution",
                "content": "Thanks to [@KuangYuan](https://leetcode.com/KuangYuan/) for sharing [the approach](https://leetcode.com/problems/self-crossing/discuss/79131/Java-Oms-with-explanation).\\n\\n```\\n# @param {Integer[]} distance\\n# @return {Boolean}\\ndef is_self_crossing(distance)\\n  return false if distance.size < 4\\n\\n  return true if check_four_element(*distance[-4...])\\n\\n  return false if distance.size == 4\\n\\n  return true if check_five_element(*distance[-5...])\\n\\n  distance.each_cons(6) do |long_pair|\\n    if check_six_element(*long_pair)\\n      return true \\n    end\\n  end\\n\\n  false\\nend\\n\\ndef check_four_element(x1, x2, x3, x4)\\n  x1 >= x3 && x4 >= x2\\nend\\n\\ndef check_five_element(x1, x2, x3, x4, x5)\\n  (x1 + x5) >= x3 && x4 == x2 || check_four_element(x1, x2, x3, x4)\\nend\\n\\ndef check_six_element(x1, x2, x3, x4, x5, x6 )\\n  ((x1 + x5) >= x3 && x3 >= x5 && (x6 + x2) >= x4 && x4 >= x2) || check_five_element(x1, x2, x3, x4, x5)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} distance\\n# @return {Boolean}\\ndef is_self_crossing(distance)\\n  return false if distance.size < 4\\n\\n  return true if check_four_element(*distance[-4...])\\n\\n  return false if distance.size == 4\\n\\n  return true if check_five_element(*distance[-5...])\\n\\n  distance.each_cons(6) do |long_pair|\\n    if check_six_element(*long_pair)\\n      return true \\n    end\\n  end\\n\\n  false\\nend\\n\\ndef check_four_element(x1, x2, x3, x4)\\n  x1 >= x3 && x4 >= x2\\nend\\n\\ndef check_five_element(x1, x2, x3, x4, x5)\\n  (x1 + x5) >= x3 && x4 == x2 || check_four_element(x1, x2, x3, x4)\\nend\\n\\ndef check_six_element(x1, x2, x3, x4, x5, x6 )\\n  ((x1 + x5) >= x3 && x3 >= x5 && (x6 + x2) >= x4 && x4 >= x2) || check_five_element(x1, x2, x3, x4, x5)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2261111,
                "title": "time-memory-o-n-simple-typescript-solution",
                "content": "I referred to [this answer post by StefanPochmann](https://leetcode.com/problems/self-crossing/discuss/79141/Another-python...). The figure below is also from the post. I am posting this because I could not find Typescript code on the discussion thread and I thought the Python code on the original post is a little difficult to understand for the people who are not familiar with Python (like me).\\n\\n### Idea\\n\\nThere are two cases (Case 1 and Case 2) for self-crossing. We only need to check if any of these cases appears in any consecutive 6 line drawings. \\nSince the lines are drawn in anti-clockwise and the cases can be defined by relative length and positions of lines, we do not need to consider the absolute coordinates nor orientation of the lines while checking this; we can just assume `a` starts at (0, 0) and moves towards North.\\n\\n```\\nCase 1                         Case 2\\n            b                              b\\n   +----------------+             +----------------+\\n   |                |             |                |\\n   |                |             |                | a\\n c |                |           c |                |\\n   |                | a           |                |    f\\n   +----------->    |             |                | <----+\\n            d       |             |                |      | e\\n                    |             |                       |\\n                                  +-----------------------+\\n                                               d\\n```\\n\\n### Complexity\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\nwhere `n=distance.length`\\n\\n```typescript\\nfunction isSelfCrossing(distance: number[]): boolean {\\n    // omit the line at i=distance.length because it is always self-crossing.\\n    for (let i=0; i<distance.length-1; i+=1) {\\n        const a = distance[i]\\n        const b = distance[i+1] ?? 0\\n        const c = distance[i+2] ?? 0\\n        const d = distance[i+3] ?? 0\\n        const e = distance[i+4] ?? 0\\n        const f = distance[i+5] ?? 0\\n\\t\\t// Case 1\\n        if (c <= a && b <= d) {\\n            return true\\n        }\\n\\t\\t// Case 2\\n        if (a < c && c <= a + e && e <= c && b <= d && d <= b + f) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nCase 1                         Case 2\\n            b                              b\\n   +----------------+             +----------------+\\n   |                |             |                |\\n   |                |             |                | a\\n c |                |           c |                |\\n   |                | a           |                |    f\\n   +----------->    |             |                | <----+\\n            d       |             |                |      | e\\n                    |             |                       |\\n                                  +-----------------------+\\n                                               d\\n```\n```typescript\\nfunction isSelfCrossing(distance: number[]): boolean {\\n    // omit the line at i=distance.length because it is always self-crossing.\\n    for (let i=0; i<distance.length-1; i+=1) {\\n        const a = distance[i]\\n        const b = distance[i+1] ?? 0\\n        const c = distance[i+2] ?? 0\\n        const d = distance[i+3] ?? 0\\n        const e = distance[i+4] ?? 0\\n        const f = distance[i+5] ?? 0\\n\\t\\t// Case 1\\n        if (c <= a && b <= d) {\\n            return true\\n        }\\n\\t\\t// Case 2\\n        if (a < c && c <= a + e && e <= c && b <= d && d <= b + f) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249979,
                "title": "simple-api",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        n = len(x)\\n        if n < 4: return False\\n        for i in range(3, n):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]: return True\\n            if i >= 4 and x[i-1]==x[i-3] and x[i]+x[i-4]>=x[i-2]: return True\\n            if i >= 5 and 0<=x[i-2]-x[i-4]<=x[i] and 0<=x[i-3]-x[i-1]<=x[i-5]: return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        n = len(x)\\n        if n < 4: return False\\n        for i in range(3, n):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]: return True\\n            if i >= 4 and x[i-1]==x[i-3] and x[i]+x[i-4]>=x[i-2]: return True\\n            if i >= 5 and 0<=x[i-2]-x[i-4]<=x[i] and 0<=x[i-3]-x[i-1]<=x[i-5]: return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246654,
                "title": "c-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& d) {\\n        int n = d.size();\\n        if (n <3) return false;\\n        int i;\\n        if (d[0] <= d[2] && d[1]<=0) return true;\\n\\n        for (i=3; i<min(n,4); i++)\\n         if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n\\n        if (n>=5)\\n        {\\n            i = 4;\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3]  &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n        for (i=5; i<n; i++)\\n        {\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3] - d[i - 5] &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n       return false;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& d) {\\n        int n = d.size();\\n        if (n <3) return false;\\n        int i;\\n        if (d[0] <= d[2] && d[1]<=0) return true;\\n\\n        for (i=3; i<min(n,4); i++)\\n         if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n\\n        if (n>=5)\\n        {\\n            i = 4;\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3]  &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n        for (i=5; i<n; i++)\\n        {\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3] - d[i - 5] &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n       return false;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950384,
                "title": "python-very-simple-code-to-understand-self-crossing-problem",
                "content": "Here is the solution for self crossing:\\n \\n        x = distance\\n        for i in range(3,len(x)):  # must have length to intersect\\n            if x[i-3]>=x[i-1] and x[i]>=x[i-2]:  # length of 3rd should be greater than 1st \\n\\t\\t\\t\\t\\treturn True\\n\\n            if i>=4:\\n                if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                    return True\\n\\n            if i>=5:\\n                if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                    return True\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is the solution for self crossing:\\n \\n        x = distance\\n        for i in range(3,len(x)):  # must have length to intersect\\n            if x[i-3]>=x[i-1] and x[i]>=x[i-2]:  # length of 3rd should be greater than 1st \\n\\t\\t\\t\\t\\treturn True\\n\\n            if i>=4:\\n                if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                    return True\\n\\n            if i>=5:\\n                if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                    return True\\n\\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 1912766,
                "title": "python-explained-with-picture",
                "content": "Three cases: (Picture attached at bottom)\\n1.  i crosses i+3\\n2.  i crosses i+4 (actually \"encountering\")\\n3.  i crosses i+5\\n\\nTo be honest, I don\\'t know what\\'s the point of this topic.\\nIt\\'s hard to take all the cases into consideration, in fact, I submitted three wrong answers and used the test cases to modify my code. Not benefiting from this problem.\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        for i in range(len(distance)-2):\\n            # i cross i + 3\\n            if distance[i] >= distance[i+2] and i + 3 < len(distance) and distance[i+3] >= distance[i+1]:\\n                return True\\n            # i encounter i + 4\\n            elif i + 4 < len(distance) and distance[i+1] == distance[i+3] and distance[i] + distance[i+4] == distance[i+2]:\\n                return True\\n            # i cross i + 5\\n            elif i + 5 < len(distance) and 0 <= distance[i+3] - distance[i+1] <= distance[i+5] <= distance[i+3] and 0 <= distance[i+2] - distance[i] <= distance[i+4] <= distance[i+2]:\\n                return True\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/0b73046e-b642-4da3-81c2-95728905df10_1649054587.614495.jpeg)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        for i in range(len(distance)-2):\\n            # i cross i + 3\\n            if distance[i] >= distance[i+2] and i + 3 < len(distance) and distance[i+3] >= distance[i+1]:\\n                return True\\n            # i encounter i + 4\\n            elif i + 4 < len(distance) and distance[i+1] == distance[i+3] and distance[i] + distance[i+4] == distance[i+2]:\\n                return True\\n            # i cross i + 5\\n            elif i + 5 < len(distance) and 0 <= distance[i+3] - distance[i+1] <= distance[i+5] <= distance[i+3] and 0 <= distance[i+2] - distance[i] <= distance[i+4] <= distance[i+2]:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817146,
                "title": "python-3-rules-to-solve-them-tests-all",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, d: List[int]) -> bool:        \\n        for i in range(3, len(d)):\\n            if d[i-3] >= d[i-1] and d[i] >= d[i-2]:  return True \\n            \\n            if i > 3:\\n                if d[i-3] == d[i-1] and d[i] + d[i-4] >= d[i-2]:  return True \\n            \\n            if i > 4:\\n                if d[i] + d[i-4] >= d[i-2] and d[i-3] >= d[i-1] and d[i-5] + d[i-1] >= d[i-3] and d[i-2] >  d[i-4] and d[i-3] > d[i-1]:  return True \\n                \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, d: List[int]) -> bool:        \\n        for i in range(3, len(d)):\\n            if d[i-3] >= d[i-1] and d[i] >= d[i-2]:  return True \\n            \\n            if i > 3:\\n                if d[i-3] == d[i-1] and d[i] + d[i-4] >= d[i-2]:  return True \\n            \\n            if i > 4:\\n                if d[i] + d[i-4] >= d[i-2] and d[i-3] >= d[i-1] and d[i-5] + d[i-1] >= d[i-3] and d[i-2] >  d[i-4] and d[i-3] > d[i-1]:  return True \\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416714,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<=3) return false;\\n        distance.insert(distance.begin(), 0);\\n        int x1, x2, y1, y2;\\n        for(int i=3; i<distance.size(); i++)\\n        {\\n            //check line -3\\n            x1=distance[i-2], y1=distance[i-1], y2=distance[i-1]-distance[i-3];\\n            if(y2<=0 && x1<=distance[i]) return true;\\n            if(i>=5) // check line -5\\n            {\\n                x2=distance[i-2]-distance[i-4];\\n                y1=y2+distance[i-5];\\n                if(y2<=0 && y1>=0 && x2<=distance[i] && x2>=0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<=3) return false;\\n        distance.insert(distance.begin(), 0);\\n        int x1, x2, y1, y2;\\n        for(int i=3; i<distance.size(); i++)\\n        {\\n            //check line -3\\n            x1=distance[i-2], y1=distance[i-1], y2=distance[i-1]-distance[i-3];\\n            if(y2<=0 && x1<=distance[i]) return true;\\n            if(i>=5) // check line -5\\n            {\\n                x2=distance[i-2]-distance[i-4];\\n                y1=y2+distance[i-5];\\n                if(y2<=0 && y1>=0 && x2<=distance[i] && x2>=0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306737,
                "title": "golang-faster-than-100-memory-less-than-100",
                "content": "```go\\nfunc isSelfCrossing(distance []int) bool {\\n\\tdistance = append([]int{0, 0, 0, 0}, distance...)\\n\\tn := len(distance)\\n\\ti := 4\\n\\tfor i < n && distance[i] > distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\tif i == n {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif distance[i] >= distance[i-2]-distance[i-4] {\\n\\t\\tdistance[i-1] -= distance[i-3]\\n\\t}\\n\\ti = i + 1\\n\\tfor i < n && distance[i] < distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\treturn i != n\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc isSelfCrossing(distance []int) bool {\\n\\tdistance = append([]int{0, 0, 0, 0}, distance...)\\n\\tn := len(distance)\\n\\ti := 4\\n\\tfor i < n && distance[i] > distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\tif i == n {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif distance[i] >= distance[i-2]-distance[i-4] {\\n\\t\\tdistance[i-1] -= distance[i-3]\\n\\t}\\n\\ti = i + 1\\n\\tfor i < n && distance[i] < distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\treturn i != n\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1227441,
                "title": "why-does-the-question-not-specify-that-touching-counts-as-crossing",
                "content": "Or that a line can cross over a line parallel to itself? Is this really a cross != intersect thing?\\n\\nDecent question but it\\'s frustrating for someone who spent a longggg time cobbling together an ugly implementation.",
                "solutionTags": [],
                "code": "Or that a line can cross over a line parallel to itself? Is this really a cross != intersect thing?\\n\\nDecent question but it\\'s frustrating for someone who spent a longggg time cobbling together an ugly implementation.",
                "codeTag": "Unknown"
            },
            {
                "id": 1209866,
                "title": "c-one-pass-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4)\\n            return false;\\n        set <pair<int,int>> s;\\n        int pos_x=0,pos_y=0;\\n        pair<int,int> p;\\n        p.first=0;\\n        p.second=0;\\n        s.insert(p);\\n        for(int i=0;i<distance.size();i++)\\n        {\\n            if(i%4==0)\\n            {\\n                for(int j=pos_y+1;j<=pos_y+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==1)\\n            {\\n                for(int j=pos_x-1;j>=pos_x-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==2)\\n            {\\n                for(int j=pos_y-1;j>=pos_y-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==3)\\n            {\\n                for(int j=pos_x+1;j<=pos_x+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\nstatic const int _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4)\\n            return false;\\n        set <pair<int,int>> s;\\n        int pos_x=0,pos_y=0;\\n        pair<int,int> p;\\n        p.first=0;\\n        p.second=0;\\n        s.insert(p);\\n        for(int i=0;i<distance.size();i++)\\n        {\\n            if(i%4==0)\\n            {\\n                for(int j=pos_y+1;j<=pos_y+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==1)\\n            {\\n                for(int j=pos_x-1;j>=pos_x-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==2)\\n            {\\n                for(int j=pos_y-1;j>=pos_y-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==3)\\n            {\\n                for(int j=pos_x+1;j<=pos_x+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\nstatic const int _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1177976,
                "title": "readable-python-solution",
                "content": "Other solutions include a well reasoned explanation as to why an intersection must ocurr within the last 6 lines leading to the intersection. This solution uses that fact:\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        def intersects(*args):\\n            def range_intersection(r1, r2):\\n                return range(max(r1.start, r2.start), min(r1.stop, r2.stop))\\n            l1, l2 = sorted(args, key=lambda line: len(line[0])) # Vertical line first\\n\\n            return range_intersection(l1[0], l2[0]) and range_intersection(l1[1], l2[1])\\n\\n        N = (0, -1)\\n        W = (-1, 0)\\n        S = (0, 1)\\n        E = (1, 0)\\n        dirs = itertools.cycle([N,W,S,E])\\n        pos = (0, 0)\\n        lines = []\\n\\n        for dx, dy in ((dist*dir[0], dist*dir[1]) for dist, dir in zip(distance, dirs)):\\n            x_line = [pos[0], pos[0] + dx]\\n            y_line = [pos[1], pos[1] + dy]\\n            current_line = (\\n                    range(min(x_line), max(x_line) + 1),\\n                    range(min(y_line), max(y_line) + 1),\\n                )\\n\\n            if any(intersects(current_line, line) for line in lines[-5:-1]):\\n                return True\\n            lines.append(current_line)\\n            pos = pos[0] + dx, pos[1] + dy\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        def intersects(*args):\\n            def range_intersection(r1, r2):\\n                return range(max(r1.start, r2.start), min(r1.stop, r2.stop))\\n            l1, l2 = sorted(args, key=lambda line: len(line[0])) # Vertical line first\\n\\n            return range_intersection(l1[0], l2[0]) and range_intersection(l1[1], l2[1])\\n\\n        N = (0, -1)\\n        W = (-1, 0)\\n        S = (0, 1)\\n        E = (1, 0)\\n        dirs = itertools.cycle([N,W,S,E])\\n        pos = (0, 0)\\n        lines = []\\n\\n        for dx, dy in ((dist*dir[0], dist*dir[1]) for dist, dir in zip(distance, dirs)):\\n            x_line = [pos[0], pos[0] + dx]\\n            y_line = [pos[1], pos[1] + dy]\\n            current_line = (\\n                    range(min(x_line), max(x_line) + 1),\\n                    range(min(y_line), max(y_line) + 1),\\n                )\\n\\n            if any(intersects(current_line, line) for line in lines[-5:-1]):\\n                return True\\n            lines.append(current_line)\\n            pos = pos[0] + dx, pos[1] + dy\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156017,
                "title": "python-using-dict-and-tuples",
                "content": "Seems like a relativly straight forward solution so I wanted to share.\\n\\n\\'\\'\\'\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:    \\n        path = {}\\n        current_position = [0,0]\\n        path[tuple(current_position)] = True\\n        \\n        # Visualize the path as squares on a checker board\\n        # Add the coordinates of each square visted as a tuple to a hashtable(dict)\\n        for index, steps in enumerate(distance):\\n            \\n            # Mod index to determine the cardinal direction\\n            # step through the squares adding the coordinates along the way.\\n            if ((index + 1) % 4 == 1):\\n                for step in range(steps):\\n                    current_position[1]+= 1\\n                    # Check if square has already been added to path\\n                    # If it has then you have crossed\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n            if ((index + 1) % 4 == 2):\\n                for step in range(steps):\\n                    current_position[0]-= 1\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n            if ((index + 1) % 4 == 3):\\n                for step in range(steps):\\n                    current_position[1]-= 1\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n            if ((index + 1) % 4 == 0):\\n                for step in range(steps):\\n                    current_position[0]+= 1\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n        \\n        return False\\n        \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:    \\n        path = {}",
                "codeTag": "Java"
            },
            {
                "id": 1149356,
                "title": "python-brute-force-it-works",
                "content": "I couldn\\'t figure out what tricks can be applied and, therefore, decided to do it in brute force, which finally pass. Hooray!\\n\\nThe idea is simple. When we draw a vertical line, there are two possible cases of crossover (1) we hit another horizontal line (2) we hit another vertical line. The scenario 2 just means we had two line segments overlap. The two crossover cases for horizontal lines can be easily deducted using the above idea. \\n\\nHere is the code\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        horizontal = []  # (y, left, right, idx)\\n        vertical = []  # (x, top, down, idx)\\n\\n        cur_x, cur_y = 0, 0\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n\\n        # special binary search\\n        def binary_search(arr, low, high):\\n            # search lower bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] < low:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            lower = r\\n\\n            # search upper bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] > high:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            return lower, r\\n\\n        for i in range(len(distance)):\\n            phase = i % 4\\n            dx, dy = direction[phase]\\n            next_x, next_y = cur_x + dx * distance[i], cur_y + dy * distance[i]\\n\\n            if phase & 1:\\n                # check intersection with vertical lines\\n                start_idx, end_idx = binary_search(vertical, min(cur_x, next_x), max(cur_x, next_x))\\n\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][3] != i - 1 and vertical[j][1] <= cur_y <= vertical[j][2]:\\n                        return True\\n\\n                # case 2: touch vertical lines\\n                start_idx, end_idx = binary_search(horizontal, cur_y, cur_y + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if horizontal[j][1] <= cur_x <= horizontal[j][2] or horizontal[j][1] <= next_x <= horizontal[j][2]:\\n                        return True\\n\\n                # insert current line into horizontal  O(log n )\\n                e = [cur_y, min(cur_x, next_x), max(cur_x, next_x), i]\\n                horizontal.insert(bisect_left(horizontal, e), e)\\n            else:\\n                # check intersection with horizontal lines\\n                start_idx, end_idx = binary_search(horizontal, min(cur_y, next_y), max(cur_y, next_y))\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):\\n                    if horizontal[j][3] != i - 1 and horizontal[j][1] <= cur_x <= horizontal[j][2]:\\n                        return True\\n\\n                # case 2: touch verticle lines\\n                start_idx, end_idx = binary_search(vertical, cur_x, cur_x + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][1] <= cur_y <= vertical[j][2] or vertical[j][1] <= next_y <= vertical[j][2]:\\n                        return True\\n\\n                # insert current line into vertical\\n                e = [cur_x, min(cur_y, next_y), max(cur_y, next_y), i]\\n                vertical.insert(bisect_left(vertical, e), e)\\n\\n            cur_x = next_x\\n            cur_y = next_y\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        horizontal = []  # (y, left, right, idx)\\n        vertical = []  # (x, top, down, idx)\\n\\n        cur_x, cur_y = 0, 0\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n\\n        # special binary search\\n        def binary_search(arr, low, high):\\n            # search lower bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] < low:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            lower = r\\n\\n            # search upper bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] > high:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            return lower, r\\n\\n        for i in range(len(distance)):\\n            phase = i % 4\\n            dx, dy = direction[phase]\\n            next_x, next_y = cur_x + dx * distance[i], cur_y + dy * distance[i]\\n\\n            if phase & 1:\\n                # check intersection with vertical lines\\n                start_idx, end_idx = binary_search(vertical, min(cur_x, next_x), max(cur_x, next_x))\\n\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][3] != i - 1 and vertical[j][1] <= cur_y <= vertical[j][2]:\\n                        return True\\n\\n                # case 2: touch vertical lines\\n                start_idx, end_idx = binary_search(horizontal, cur_y, cur_y + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if horizontal[j][1] <= cur_x <= horizontal[j][2] or horizontal[j][1] <= next_x <= horizontal[j][2]:\\n                        return True\\n\\n                # insert current line into horizontal  O(log n )\\n                e = [cur_y, min(cur_x, next_x), max(cur_x, next_x), i]\\n                horizontal.insert(bisect_left(horizontal, e), e)\\n            else:\\n                # check intersection with horizontal lines\\n                start_idx, end_idx = binary_search(horizontal, min(cur_y, next_y), max(cur_y, next_y))\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):\\n                    if horizontal[j][3] != i - 1 and horizontal[j][1] <= cur_x <= horizontal[j][2]:\\n                        return True\\n\\n                # case 2: touch verticle lines\\n                start_idx, end_idx = binary_search(vertical, cur_x, cur_x + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][1] <= cur_y <= vertical[j][2] or vertical[j][1] <= next_y <= vertical[j][2]:\\n                        return True\\n\\n                # insert current line into vertical\\n                e = [cur_x, min(cur_y, next_y), max(cur_y, next_y), i]\\n                vertical.insert(bisect_left(vertical, e), e)\\n\\n            cur_x = next_x\\n            cur_y = next_y\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088170,
                "title": "c-intersect-line-solutions",
                "content": "```\\nstruct pt {\\n\\tint x, y;\\n};\\nint area (pt a, pt b, pt c) {\\n\\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n}\\n \\n bool intersect_1 (int a, int b, int c, int d) {\\n\\tif (a > b)  swap (a, b);\\n\\tif (c > d)  swap (c, d);\\n\\treturn max(a,c) <= min(b,d);\\n}\\n \\nbool intersect (pt a, pt b, pt c, pt d) {\\n\\treturn intersect_1 (a.x, b.x, c.x, d.x)\\n\\t\\t&& intersect_1 (a.y, b.y, c.y, d.y)\\n\\t\\t&& area(a,b,c) * area(a,b,d) <= 0\\n\\t\\t&& area(c,d,a) * area(c,d,b) <= 0;\\n}\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n\\tvector<pt> points;\\n\\tpt p({0,0});\\n\\tpoints.push_back(p);\\n\\t\\n\\tint offsetX = 0;\\n\\tint offsetY = 0;\\n\\tchar wise = 0;\\n\\tfor(int i = 0;i < x.size();i++)\\n\\t{\\n\\t\\tpt p;\\n\\t\\tp.x = offsetX +(i%2 ? (wise == 0 || wise ==3 ? 1 : -1)*x[i] : 0);\\n\\t\\tp.y = offsetY + (i % 2 ? 0  : (wise == 0 || wise ==3 ? 1 : -1)*x[i]);\\n\\t\\toffsetX = p.x;\\n\\t\\toffsetY = p.y;\\n\\t\\tpoints.push_back(p);\\n\\t\\twise++;\\n\\t\\tif(wise == 4) wise = 0;\\n\\t}\\n\\tif(points.size() < 5) return false;\\n\\tfor(int i = 0; i < points.size()-4;i++)\\n\\t{\\n\\t\\tfor(auto j = i+3 ;j < points.size()-1;j++)\\n\\t\\t{\\n\\t\\tif (intersect(points[i],points[i+1],points[j],points[j+1])) return true;\\t\\n\\t\\t}\\n\\t}\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct pt {\\n\\tint x, y;\\n};\\nint area (pt a, pt b, pt c) {\\n\\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n}\\n \\n bool intersect_1 (int a, int b, int c, int d) {\\n\\tif (a > b)  swap (a, b);\\n\\tif (c > d)  swap (c, d);\\n\\treturn max(a,c) <= min(b,d);\\n}\\n \\nbool intersect (pt a, pt b, pt c, pt d) {\\n\\treturn intersect_1 (a.x, b.x, c.x, d.x)\\n\\t\\t&& intersect_1 (a.y, b.y, c.y, d.y)\\n\\t\\t&& area(a,b,c) * area(a,b,d) <= 0\\n\\t\\t&& area(c,d,a) * area(c,d,b) <= 0;\\n}\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n\\tvector<pt> points;\\n\\tpt p({0,0});\\n\\tpoints.push_back(p);\\n\\t\\n\\tint offsetX = 0;\\n\\tint offsetY = 0;\\n\\tchar wise = 0;\\n\\tfor(int i = 0;i < x.size();i++)\\n\\t{\\n\\t\\tpt p;\\n\\t\\tp.x = offsetX +(i%2 ? (wise == 0 || wise ==3 ? 1 : -1)*x[i] : 0);\\n\\t\\tp.y = offsetY + (i % 2 ? 0  : (wise == 0 || wise ==3 ? 1 : -1)*x[i]);\\n\\t\\toffsetX = p.x;\\n\\t\\toffsetY = p.y;\\n\\t\\tpoints.push_back(p);\\n\\t\\twise++;\\n\\t\\tif(wise == 4) wise = 0;\\n\\t}\\n\\tif(points.size() < 5) return false;\\n\\tfor(int i = 0; i < points.size()-4;i++)\\n\\t{\\n\\t\\tfor(auto j = i+3 ;j < points.size()-1;j++)\\n\\t\\t{\\n\\t\\tif (intersect(points[i],points[i+1],points[j],points[j+1])) return true;\\t\\n\\t\\t}\\n\\t}\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082000,
                "title": "has-anyone-ever-considered-what-will-happen-if-the-element-in-array-could-be-0-or-negative",
                "content": "Found it will be interesting if the pre condition changed.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1039547,
                "title": "python3-check-against-last-o-1-segments",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        dirs = {0:(0,+1), 1:(-1,0), 2:(0,-1), 3:(+1,0)}\\n        def move(y, z, i):\\n            dy, dz = dirs[i % 4]\\n            ny, nz = y + dy * x[i], z + dz * x[i]\\n            return y, z, ny, nz        \\n        def add(seg):\\n            cache.append(seg)\\n            return seg[2], seg[3]\\n        def crosses(a, b):\\n            if a[1] == a[3] and b[1] != b[3]:\\n                return min(b[1], b[3]) <= a[1] <= max(b[1], b[3]) and \\\\\\n                       min(a[0], a[2]) <= b[0] <= max(a[0], a[2])\\n            else:\\n                return (a[2], a[3]) in ((b[0], b[1]), (b[2], b[3]))\\n        cache = deque()        \\n        y, z = 0, 0\\n        for i in range(len(x)):\\n            seg = move(y, z, i)\\n            for j in range(len(cache)-1):\\n                if crosses(seg, cache[j]) or crosses(cache[j], seg):\\n                    return True\\n            y, z = add(seg)\\n            if len(cache) > 5:\\n                cache.popleft()\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        dirs = {0:(0,+1), 1:(-1,0), 2:(0,-1), 3:(+1,0)}\\n        def move(y, z, i):\\n            dy, dz = dirs[i % 4]\\n            ny, nz = y + dy * x[i], z + dz * x[i]\\n            return y, z, ny, nz        \\n        def add(seg):\\n            cache.append(seg)\\n            return seg[2], seg[3]\\n        def crosses(a, b):\\n            if a[1] == a[3] and b[1] != b[3]:\\n                return min(b[1], b[3]) <= a[1] <= max(b[1], b[3]) and \\\\\\n                       min(a[0], a[2]) <= b[0] <= max(a[0], a[2])\\n            else:\\n                return (a[2], a[3]) in ((b[0], b[1]), (b[2], b[3]))\\n        cache = deque()        \\n        y, z = 0, 0\\n        for i in range(len(x)):\\n            seg = move(y, z, i)\\n            for j in range(len(cache)-1):\\n                if crosses(seg, cache[j]) or crosses(cache[j], seg):\\n                    return True\\n            y, z = add(seg)\\n            if len(cache) > 5:\\n                cache.popleft()\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033787,
                "title": "c-check-whether-the-current-segment-intersects-the-last-8-segments",
                "content": "```\\n    struct PLine {\\n        PLine(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2) {}\\n        PLine(): x1(0), y1(0), x2(0), y2(0){}\\n        int x1, y1, x2, y2;\\n    };\\n    \\n    void printPt(const PLine& pt) {\\n        printf(\"{(%d,%d),(%d,%d)}\", pt.x1, pt.y1, pt.x2, pt.y2); \\n    }\\n    \\n    bool isBetween(int x, int a, int b) {\\n        return x >= min(a, b) && x <= max(a, b);\\n    }\\n    \\n    bool intersects(const PLine& l1, const PLine& l2) {\\n        if (l1.x1 == l1.x2 && l2.x1 == l2.x2) {\\n            return l1.x1 == l2.x1 && (isBetween(l1.y1, l2.y1, l2.y2) || isBetween(l1.y2, l2.y1, l2.y2));\\n        } else if (l1.y1 == l1.y2 && l2.y1 == l2.y2) {\\n            return l1.y1 == l2.y1 && (isBetween(l1.x1, l2.x1, l2.x2) || isBetween(l1.x2, l2.x1, l2.x2)); \\n        }\\n        \\n        int x_i;\\n        int y_i;\\n        \\n        if (l1.x1 == l1.x2) {\\n            if ((l2.y1 >= min(l1.y1, l1.y2) && l2.y1 <= max(l1.y1, l1.y2)) && \\n                (l1.x1 >= min(l2.x1, l2.x2) && l1.x1 <= max(l2.x1, l2.x2))) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            return intersects(l2, l1); \\n        }\\n    }\\n    bool isSelfCrossing(vector<int>& x) {\\n        vector<PLine> seen(8); \\n        \\n\\n        int num = 0;\\n        int curr = 0;\\n        array<int, 5> dirs{0, 1, 0, -1, 0};\\n        int dir = 0;\\n        PLine p;\\n        PLine lastPt;\\n        for (int i = 0; i < x.size(); ++i) {\\n            p.x1 = p.x2;\\n            p.y1 = p.y2;\\n            p.x2 += dirs[dir] * x[i];\\n            p.y2 += dirs[dir + 1] * x[i];\\n            dir = (dir + 1) % 4;\\n            for (int z = 0; z < num; ++z) {\\n                if (intersects(p, seen[z])) {\\n                    return true;\\n                }\\n            }\\n            \\n            if (i != 0) {\\n                seen[curr] = lastPt;\\n                curr = (curr + 1) % 8;\\n                num = min(8, num + 1); \\n            }\\n            lastPt = p;\\n        }\\n        return false;\\n        \\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n    struct PLine {\\n        PLine(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2) {}\\n        PLine(): x1(0), y1(0), x2(0), y2(0){}\\n        int x1, y1, x2, y2;\\n    };\\n    \\n    void printPt(const PLine& pt) {\\n        printf(\"{(%d,%d),(%d,%d)}\", pt.x1, pt.y1, pt.x2, pt.y2); \\n    }\\n    \\n    bool isBetween(int x, int a, int b) {\\n        return x >= min(a, b) && x <= max(a, b);\\n    }\\n    \\n    bool intersects(const PLine& l1, const PLine& l2) {\\n        if (l1.x1 == l1.x2 && l2.x1 == l2.x2) {\\n            return l1.x1 == l2.x1 && (isBetween(l1.y1, l2.y1, l2.y2) || isBetween(l1.y2, l2.y1, l2.y2));\\n        } else if (l1.y1 == l1.y2 && l2.y1 == l2.y2) {\\n            return l1.y1 == l2.y1 && (isBetween(l1.x1, l2.x1, l2.x2) || isBetween(l1.x2, l2.x1, l2.x2)); \\n        }\\n        \\n        int x_i;\\n        int y_i;\\n        \\n        if (l1.x1 == l1.x2) {\\n            if ((l2.y1 >= min(l1.y1, l1.y2) && l2.y1 <= max(l1.y1, l1.y2)) && \\n                (l1.x1 >= min(l2.x1, l2.x2) && l1.x1 <= max(l2.x1, l2.x2))) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            return intersects(l2, l1); \\n        }\\n    }\\n    bool isSelfCrossing(vector<int>& x) {\\n        vector<PLine> seen(8); \\n        \\n\\n        int num = 0;\\n        int curr = 0;\\n        array<int, 5> dirs{0, 1, 0, -1, 0};\\n        int dir = 0;\\n        PLine p;\\n        PLine lastPt;\\n        for (int i = 0; i < x.size(); ++i) {\\n            p.x1 = p.x2;\\n            p.y1 = p.y2;\\n            p.x2 += dirs[dir] * x[i];\\n            p.y2 += dirs[dir + 1] * x[i];\\n            dir = (dir + 1) % 4;\\n            for (int z = 0; z < num; ++z) {\\n                if (intersects(p, seen[z])) {\\n                    return true;\\n                }\\n            }\\n            \\n            if (i != 0) {\\n                seen[curr] = lastPt;\\n                curr = (curr + 1) % 8;\\n                num = min(8, num + 1); \\n            }\\n            lastPt = p;\\n        }\\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 994851,
                "title": "java-3-scenarios",
                "content": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i=0; i<x.length; i++){\\n            if(i>=3 && x[i-1]<=x[i-3] && x[i]>=x[i-2])\\n                return true;\\n            if(i>3 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n                return true;\\n            if(i>4 && x[i-2]>=x[i-4] && x[i]+x[i-4]>=x[i-2] && x[i-1] <= x[i-3] && x[i-1]+x[i-5]>=x[i-3])\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i=0; i<x.length; i++){\\n            if(i>=3 && x[i-1]<=x[i-3] && x[i]>=x[i-2])\\n                return true;\\n            if(i>3 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n                return true;\\n            if(i>4 && x[i-2]>=x[i-4] && x[i]+x[i-4]>=x[i-2] && x[i-1] <= x[i-3] && x[i-1]+x[i-5]>=x[i-3])\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 989934,
                "title": "five-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        for (int i = 3; i < x.size(); i++)\\n            if (x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]\\n               ||(i >= 5 && x[i-2] - x[i] <= x[i-4] && x[i-2] >= x[i-4] && x[i-3] - x[i-1] <= x[i-5] && x[i-1] <= x[i-3])\\n               ||(i >= 4 && x[i] + x[i - 4] == x[i - 2] && x[i - 1] == x[i - 3])) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        for (int i = 3; i < x.size(); i++)\\n            if (x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]\\n               ||(i >= 5 && x[i-2] - x[i] <= x[i-4] && x[i-2] >= x[i-4] && x[i-3] - x[i-1] <= x[i-5] && x[i-1] <= x[i-3])\\n               ||(i >= 4 && x[i] + x[i - 4] == x[i - 2] && x[i - 1] == x[i - 3])) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951164,
                "title": "simply-maintain-last-8-segments",
                "content": "\\n```\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        \\n        \\n        # Idea is to maintain last 8 segments. if current segment intersects any of last 8 segments return True! \\n        # WHy ? You can check by drawing different shapes. \\n        \\n        \\n        last_eigth = []\\n        \\n        def check (last_eight, dir, first, second, per_cord):\\n            for i in range (0, len(last_eight)-1):\\n                opo_dir = ((last_eight[i][0] == \\'X\\' and dir == \\'Y\\') or \\n                            (last_eight[i][0] == \\'Y\\' and dir == \\'X\\'))\\n                                \\n                if (opo_dir and  \\n                    last_eight[i][1] <= per_cord <= last_eight[i][2] and\\n                    first <= last_eight[i][3] <= second):\\n                    return True\\n                \\n                if (not opo_dir and last_eight[i][3] == per_cord and \\n                   \\n                   (( first <= last_eight[i][1] <= second) or \\n                    (last_eight[i][1] <= first <= last_eight[i][2]))\\n                   \\n                   ):\\n                    return True\\n                \\n                \\n            return False\\n            \\n        \\n        dir = 0 \\n        x, y = 0,0\\n        for change in arr:\\n            if dir == 0: \\n                if check (last_eigth, \\'Y\\', y, y+change, x): return True \\n                last_eigth.append((\\'Y\\', y, y+change, x))\\n                x, y = x, y+change\\n            if dir == 1:\\n                if check (last_eigth, \\'X\\', x-change, x, y): return True \\n                last_eigth.append((\\'X\\', x-change, x, y))\\n                x, y = x - change, y\\n            if dir == 2:\\n                if check (last_eigth, \\'Y\\', y-change, y, x): return True \\n                last_eigth.append((\\'Y\\', y-change, y, x))\\n                x, y = x, y-change\\n            if dir == 3:\\n                if check (last_eigth, \\'X\\', x, x+change, y): return True \\n                last_eigth.append((\\'X\\', x, x+change, y))\\n                x, y = x + change, y\\n            \\n            if len(last_eigth)> 8: last_eigth.pop(0)\\n            \\n                \\n            dir += 1\\n            dir %= 4 \\n            \\n        return False",
                "solutionTags": [],
                "code": "\\n```\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        \\n        \\n        # Idea is to maintain last 8 segments. if current segment intersects any of last 8 segments return True! \\n        # WHy ? You can check by drawing different shapes. \\n        \\n        \\n        last_eigth = []\\n        \\n        def check (last_eight, dir, first, second, per_cord):\\n            for i in range (0, len(last_eight)-1):\\n                opo_dir = ((last_eight[i][0] == \\'X\\' and dir == \\'Y\\') or \\n                            (last_eight[i][0] == \\'Y\\' and dir == \\'X\\'))\\n                                \\n                if (opo_dir and  \\n                    last_eight[i][1] <= per_cord <= last_eight[i][2] and\\n                    first <= last_eight[i][3] <= second):\\n                    return True\\n                \\n                if (not opo_dir and last_eight[i][3] == per_cord and \\n                   \\n                   (( first <= last_eight[i][1] <= second) or \\n                    (last_eight[i][1] <= first <= last_eight[i][2]))\\n                   \\n                   ):\\n                    return True\\n                \\n                \\n            return False\\n            \\n        \\n        dir = 0 \\n        x, y = 0,0\\n        for change in arr:\\n            if dir == 0: \\n                if check (last_eigth, \\'Y\\', y, y+change, x): return True \\n                last_eigth.append((\\'Y\\', y, y+change, x))\\n                x, y = x, y+change\\n            if dir == 1:\\n                if check (last_eigth, \\'X\\', x-change, x, y): return True \\n                last_eigth.append((\\'X\\', x-change, x, y))\\n                x, y = x - change, y\\n            if dir == 2:\\n                if check (last_eigth, \\'Y\\', y-change, y, x): return True \\n                last_eigth.append((\\'Y\\', y-change, y, x))\\n                x, y = x, y-change\\n            if dir == 3:\\n                if check (last_eigth, \\'X\\', x, x+change, y): return True \\n                last_eigth.append((\\'X\\', x, x+change, y))\\n                x, y = x + change, y\\n            \\n            if len(last_eigth)> 8: last_eigth.pop(0)\\n            \\n                \\n            dir += 1\\n            dir %= 4 \\n            \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 921812,
                "title": "python-o-n-time-and-constant-space-expressive-and-easily-understandable",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def isBetween(x, a, b):\\n            return a <= x and x <= b\\n    \\n        def doIntersectSameOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n\\n            orient = int(a[0][0] == a[1][0])\\n            \\n            if a[0][(orient + 1) % 2] != b[0][(orient + 1) % 2]:\\n                    return False\\n                \\n            return (isBetween(a[0][orient], b[0][orient], b[1][orient]) or isBetween(a[1][orient], b[0][orient], b[1][orient])) or (a[0][orient] < b[0][orient] and b[1][orient] < a[1][orient])\\n\\n        def doIntersectOppositeOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n            \\n            v = None\\n            h = None\\n\\n            # identify horizontal and vertical segment\\n            if a[0][1] == a[1][1]:\\n                h = a\\n                v = b\\n            else:\\n                h = b\\n                v = a\\n\\n            if h[0][0] > h[1][0]:\\n                h = (h[1], h[0])\\n    \\n            if v[0][1] > v[1][1]:\\n                v = (v[1], v[0])\\n            \\n            if v[0][0] < h[0][0] or v[0][0] > h[1][0]:\\n                return False\\n            \\n\\t\\t\\tif isBetween(h[0][1], v[0][1], v[1][1]):\\n                return True\\n            \\n            return False\\n        #  [top, left, bottom, right]\\n        borders = [None, None, None, None]\\n        \\n        head = (0, 0)\\n        #  [up, left, down, right]\\n        directions = ((0, 1), (-1, 0), (0, -1), (1, 0))\\n        last_movement = None\\n        for move, magnitude in enumerate(x):\\n            direction_code = move % 4\\n            direction = directions[direction_code]\\n            new_head = (head[0] + magnitude * direction[0], head[1] + magnitude * direction[1])\\n            movement = (head, new_head)\\n            bordersWithSameOrientation = []\\n\\n            if direction_code in [1, 3]:\\n                bordersWithSameOrientation = [0, 2]\\n            else:\\n                bordersWithSameOrientation = [1, 3]\\n\\n            for border in range(4):\\n                crossing = False\\n                if border in bordersWithSameOrientation:\\n                    crossing = doIntersectSameOrientation(movement, borders[border])\\n                else:\\n                    crossing = doIntersectOppositeOrientation(movement, borders[border])\\n                \\n                if crossing:\\n                    return True\\n            \\n            borders[(move + 2) % 4] = last_movement\\n            head = new_head\\n            last_movement = movement\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def isBetween(x, a, b):\\n            return a <= x and x <= b\\n    \\n        def doIntersectSameOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n\\n            orient = int(a[0][0] == a[1][0])\\n            \\n            if a[0][(orient + 1) % 2] != b[0][(orient + 1) % 2]:\\n                    return False\\n                \\n            return (isBetween(a[0][orient], b[0][orient], b[1][orient]) or isBetween(a[1][orient], b[0][orient], b[1][orient])) or (a[0][orient] < b[0][orient] and b[1][orient] < a[1][orient])\\n\\n        def doIntersectOppositeOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n            \\n            v = None\\n            h = None\\n\\n            # identify horizontal and vertical segment\\n            if a[0][1] == a[1][1]:\\n                h = a\\n                v = b\\n            else:\\n                h = b\\n                v = a\\n\\n            if h[0][0] > h[1][0]:\\n                h = (h[1], h[0])\\n    \\n            if v[0][1] > v[1][1]:\\n                v = (v[1], v[0])\\n            \\n            if v[0][0] < h[0][0] or v[0][0] > h[1][0]:\\n                return False\\n            \\n\\t\\t\\tif isBetween(h[0][1], v[0][1], v[1][1]):\\n                return True\\n            \\n            return False\\n        #  [top, left, bottom, right]\\n        borders = [None, None, None, None]\\n        \\n        head = (0, 0)\\n        #  [up, left, down, right]\\n        directions = ((0, 1), (-1, 0), (0, -1), (1, 0))\\n        last_movement = None\\n        for move, magnitude in enumerate(x):\\n            direction_code = move % 4\\n            direction = directions[direction_code]\\n            new_head = (head[0] + magnitude * direction[0], head[1] + magnitude * direction[1])\\n            movement = (head, new_head)\\n            bordersWithSameOrientation = []\\n\\n            if direction_code in [1, 3]:\\n                bordersWithSameOrientation = [0, 2]\\n            else:\\n                bordersWithSameOrientation = [1, 3]\\n\\n            for border in range(4):\\n                crossing = False\\n                if border in bordersWithSameOrientation:\\n                    crossing = doIntersectSameOrientation(movement, borders[border])\\n                else:\\n                    crossing = doIntersectOppositeOrientation(movement, borders[border])\\n                \\n                if crossing:\\n                    return True\\n            \\n            borders[(move + 2) % 4] = last_movement\\n            head = new_head\\n            last_movement = movement\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906557,
                "title": "a-python-method-using-dic-set-tedious-but-work",
                "content": "\\'\\'\\'\\n\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        row, col = defaultdict(set), defaultdict(set)\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        start, step = (0, 0), 0\\n        for move in x:\\n            end = (start[0] + move*direction[step%4][0], start[1] + move*direction[step%4][1])           \\n            cross = 0\\n            if end[0] == start[0]:\\n                rang = set(range(min(end[1], start[1]), max(end[1], start[1])+1))\\n                if end[0] in col and end[1] in col[end[0]]: return True\\n                col[end[0]] |= rang \\n                for line in row:\\n                    if line != start[1] and line in rang and end[0] in row[line]: return True\\n            else:\\n                rang = set(range(min(end[0], start[0]), max(end[0], start[0])+1))\\n                if end[1]in row and end[0] in row[end[1]]: return True\\n                row[end[1]] |= rang\\n                for line in col:\\n                    if line != start[0] and line in rang and end[1] in col[line]: return True\\n            step, start = step + 1, end\\n            \\n        return False",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        row, col = defaultdict(set), defaultdict(set)\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        start, step = (0, 0), 0\\n        for move in x:\\n            end = (start[0] + move*direction[step%4][0], start[1] + move*direction[step%4][1])           \\n            cross = 0\\n            if end[0] == start[0]:\\n                rang = set(range(min(end[1], start[1]), max(end[1], start[1])+1))\\n                if end[0] in col and end[1] in col[end[0]]: return True\\n                col[end[0]] |= rang \\n                for line in row:\\n                    if line != start[1] and line in rang and end[0] in row[line]: return True\\n            else:\\n                rang = set(range(min(end[0], start[0]), max(end[0], start[0])+1))\\n                if end[1]in row and end[0] in row[end[1]]: return True\\n                row[end[1]] |= rang\\n                for line in col:\\n                    if line != start[0] and line in rang and end[1] in col[line]: return True\\n            step, start = step + 1, end\\n            \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 879727,
                "title": "easy-c-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int n = x.size();\\n        if(n < 4)return false;\\n        for(int i = 3; i < n; i++){\\n            if(x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            if(i >= 4){\\n                if(x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2])return true;\\n            }\\n            if(i >= 5){\\n                if(x[i - 2] >= x[i - 4] && x[i - 3] >= x[i - 1] && x[i - 1] >= x[i - 3] - x[i - 5] && x[i] >= x[i - 2] - x[i - 4])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int n = x.size();\\n        if(n < 4)return false;\\n        for(int i = 3; i < n; i++){\\n            if(x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            if(i >= 4){\\n                if(x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2])return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 831328,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def extend(self, x):\\n        if len(x) < 3: return len(x)\\n        for i in range(2, len(x)):\\n            if x[i] > x[i - 2]: continue\\n            return i\\n        return len(x)\\n        \\n    def shrink(self, x):\\n        if len(x) < 4: return False\\n        for i in range(3, len(x)):\\n            if x[i] < x[i - 2]: continue\\n            return True\\n        return False\\n            \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        r1 = self.extend(x)\\n        if r1 == len(x): return False\\n        t = x[r1 - 2]\\n        if r1 - 4 >= 0: t -= x[r1 - 4]\\n        tm = x[r1 - 1]\\n        if x[r1] >= t and r1 - 3 >= 0: tm -= x[r1 - 3]\\n        return self.shrink([x[r1 - 2]] + [tm] + x[r1:])\\n```\\n```\\nRuntime: 32 ms, faster than 79.63% of Python3 online submissions.\\nMemory Usage: 13.9 MB, less than 32.72% of Python3 online submissions.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def extend(self, x):\\n        if len(x) < 3: return len(x)\\n        for i in range(2, len(x)):\\n            if x[i] > x[i - 2]: continue\\n            return i\\n        return len(x)\\n        \\n    def shrink(self, x):\\n        if len(x) < 4: return False\\n        for i in range(3, len(x)):\\n            if x[i] < x[i - 2]: continue\\n            return True\\n        return False\\n            \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        r1 = self.extend(x)\\n        if r1 == len(x): return False\\n        t = x[r1 - 2]\\n        if r1 - 4 >= 0: t -= x[r1 - 4]\\n        tm = x[r1 - 1]\\n        if x[r1] >= t and r1 - 3 >= 0: tm -= x[r1 - 3]\\n        return self.shrink([x[r1 - 2]] + [tm] + x[r1:])\\n```\n```\\nRuntime: 32 ms, faster than 79.63% of Python3 online submissions.\\nMemory Usage: 13.9 MB, less than 32.72% of Python3 online submissions.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746248,
                "title": "javascript-simple-solution",
                "content": "```\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712894,
                "title": "my-personal-notes-with-illustration-bilingual",
                "content": "I think this is a tedious question. I cannot come up with any solution, and this one is from Huifeng Guan, who made a video carefully explained how this solution works. If you are familiar with Mandarin, I recommend you can directly [watch the video](https://www.youtube.com/watch?v=W7MyjXDE5xg).\\n\\u6211\\u81EA\\u5DF1\\u8BA4\\u4E3A\\u8FD9\\u662F\\u4E00\\u4E2A\\u5F88\\u65E0\\u804A\\u7684\\u95EE\\u9898\\u3002\\u8FD9\\u4E2A\\u7B54\\u6848\\u6765\\u81EA\\u4E00\\u4F4DYouTuber\\u3002\\u5982\\u679C\\u4F60\\u719F\\u6089\\u666E\\u901A\\u8BDD\\uFF0C\\u53EF\\u4EE5\\u76F4\\u63A5\\u53C2\\u770B\\u4ED6\\u7684\\u89C6\\u9891\\u8BB2\\u89E3\\u3002\\n\\nIf not, you may also refer to my notes which I think summarised well.  \\n\\u5982\\u679C\\u4F60\\u4E0D\\u4F1A\\u666E\\u901A\\u8BDD\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u53C2\\u770B\\u6211\\u7684\\u7B14\\u8BB0\\uFF08\\u6211\\u89C9\\u5F97\\u81EA\\u5DF1\\u505A\\u7684\\u5F88\\u68D2\\uFF09\\n\\nThere are three possible cases for the line-growing.\\n\\u7EBF\\u6761\\u589E\\u957F\\u53EF\\u80FD\\u6709\\u4E09\\u79CD\\u65B9\\u5F0F\\uFF1A\\n\\n* Expand: becoming larger and larger \\u8D8A\\u6765\\u8D8A\\u5927\\n* Shrink: becoming smaller and smaller \\u8D8A\\u6765\\u8D8A\\u5C0F\\n* Expand and then shrink \\u5148\\u53D8\\u5927\\uFF0C\\u518D\\u53D8\\u5C0F\\n\\nThe third one consists of two sub-cases.\\n\\u7B2C\\u4E09\\u79CD\\u4ECD\\u7136\\u6709\\u4E24\\u79CD\\u5B50\\u65B9\\u5F0F\\n\\nThe illustration has adequately addressed all, and it is much more efficient and expressive than my English writing. \\n\\u6211\\u89C9\\u5F97\\u6211\\u7684\\u63D2\\u56FE\\u6BD4\\u6211\\u7684\\u4E8C\\u6D41\\u5B50\\u82F1\\u8BED\\u6709\\u8BF4\\u670D\\u529B\\u591A\\u4E86\\u3002\\n\\n![image](https://assets.leetcode.com/users/images/da6bd1fc-975d-4f0c-afe7-2fdccc5ed2a4_1593514496.2712069.png)\\n![image](https://assets.leetcode.com/users/images/f0ad1127-be28-4ef6-83ef-1552437884c2_1593514508.2953768.png)\\n\\n**Appendix.**\\nThis is my code based on this solution:\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x == null || x.length <= 3) {\\n            return false;\\n        }\\n        \\n        int[] edges = new int[x.length + 4];\\n        edges[0] = edges[1] = edges[2] = edges[3] = 0;\\n        for(int i = 0; i < x.length; i++) {\\n            edges[i + 4] = x[i];\\n        }\\n        \\n        int i = 4;\\n        int n = edges.length;\\n        \\n        while(i < n && edges[i] > edges[i - 2]){\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        if(edges[i] >= edges[i-2] - edges[i-4]){\\n            edges[i-1] = edges[i-1] - edges[i-3];\\n        }\\n        \\n        i++;\\n        \\n        while(i < n && edges[i] < edges[i - 2]) {\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x == null || x.length <= 3) {\\n            return false;\\n        }\\n        \\n        int[] edges = new int[x.length + 4];\\n        edges[0] = edges[1] = edges[2] = edges[3] = 0;\\n        for(int i = 0; i < x.length; i++) {\\n            edges[i + 4] = x[i];\\n        }\\n        \\n        int i = 4;\\n        int n = edges.length;\\n        \\n        while(i < n && edges[i] > edges[i - 2]){\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        if(edges[i] >= edges[i-2] - edges[i-4]){\\n            edges[i-1] = edges[i-1] - edges[i-3];\\n        }\\n        \\n        i++;\\n        \\n        while(i < n && edges[i] < edges[i - 2]) {\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710582,
                "title": "python3-complex-number-solution-self-crossing",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def intersect(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real\\n            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real\\n        \\n        def overlap(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real\\n            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag\\n                \\n        uv = complex(0, 1)\\n        p = complex(0, 0)\\n        segments = deque()\\n        for s in x:\\n            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))\\n            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):\\n                    return True\\n            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):\\n                    return True\\n            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):\\n                    return True\\n            if len(segments) == 6:\\n                segments.popleft()\\n            p = np\\n            uv *= complex(0, 1)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def intersect(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real\\n            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real\\n        \\n        def overlap(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real\\n            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag\\n                \\n        uv = complex(0, 1)\\n        p = complex(0, 0)\\n        segments = deque()\\n        for s in x:\\n            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))\\n            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):\\n                    return True\\n            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):\\n                    return True\\n            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):\\n                    return True\\n            if len(segments) == 6:\\n                segments.popleft()\\n            p = np\\n            uv *= complex(0, 1)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651583,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n        size_t i=2;\\n        int a=0;\\n        if (x.size()<4) return 0;\\n        while(x[i]>x[i-2]){\\n            if(++i==x.size()-1) return 0;   \\n        }\\n        if (++i>4){\\n            if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];   \\n        }\\n        if (i>3){\\n            if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;  \\n        } \\n        if (x[i]>=(x[i-2]-a)) return 1;\\n        while (++i<x.size()){\\n            if(x[i]>=x[i-2]) return 1;   \\n        }\\n        return 0;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n        size_t i=2;\\n        int a=0;\\n        if (x.size()<4) return 0;\\n        while(x[i]>x[i-2]){\\n            if(++i==x.size()-1) return 0;   \\n        }\\n        if (++i>4){\\n            if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];   \\n        }\\n        if (i>3){\\n            if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;  \\n        } \\n        if (x[i]>=(x[i-2]-a)) return 1;\\n        while (++i<x.size()){\\n            if(x[i]>=x[i-2]) return 1;   \\n        }\\n        return 0;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616427,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n    size_t i=2;\\n    int a=0;\\n    if (x.size()<4) return 0;\\n    while(x[i]>x[i-2])\\n        if(++i==x.size()-1) return 0;\\n        if (++i>4) \\n              if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];\\n        if (i>3) \\n              if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;\\n        if (x[i]>=(x[i-2]-a)) return 1;\\n      while (++i<x.size())\\n          if(x[i]>=x[i-2]) return 1;\\n    return 0;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n    size_t i=2;\\n    int a=0;\\n    if (x.size()<4) return 0;\\n    while(x[i]>x[i-2])\\n        if(++i==x.size()-1) return 0;\\n        if (++i>4) \\n              if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];\\n        if (i>3) \\n              if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;\\n        if (x[i]>=(x[i-2]-a)) return 1;\\n      while (++i<x.size())\\n          if(x[i]>=x[i-2]) return 1;\\n    return 0;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557119,
                "title": "c-solution-0ms-run-time-o-n-2-at-worst",
                "content": "Starts at data index 2. As long as each value is larger than the value two steps earlier, there will never be any crossing. When there is a value smaller than two steps prior though, everything change. From now on, as soon as a value is larger than the one two steps earlier, there is a crossing. (The three lines of code between the loops checks for the two special cases in the transistion: that the first value after leaving the loop hits the line created by the value five steps prior, either from the side or by hitting it from straight behind.)\\n```\\n bool isSelfCrossing(vector<int>& x) {\\n  size_t i=2;int a=0;if(x.size()<4)return 0;\\n  while(x[i]>x[i-2])if(++i==x.size()-1)return 0;\\n  if(++i>4)if(x[i-1]>=(x[i-3]-x[i-5]))a=x[i-4];\\n  if(i>3)if(x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2])return 1;\\n  if(x[i]>=(x[i-2]-a))return 1;\\n  while(++i<x.size())if(x[i]>=x[i-2])return 1;\\n  return 0;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\n bool isSelfCrossing(vector<int>& x) {\\n  size_t i=2;int a=0;if(x.size()<4)return 0;\\n  while(x[i]>x[i-2])if(++i==x.size()-1)return 0;\\n  if(++i>4)if(x[i-1]>=(x[i-3]-x[i-5]))a=x[i-4];\\n  if(i>3)if(x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2])return 1;\\n  if(x[i]>=(x[i-2]-a))return 1;\\n  while(++i<x.size())if(x[i]>=x[i-2])return 1;\\n  return 0;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534229,
                "title": "python3-solution-and-only-one-line-line-3",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.isSelfCrossing = lambda x, position=(0, 0), way=[(0, 0)], num=0: (self.isSelfCrossing(x=x, position=(position[0], position[1] + x[num]), way=way + [(position[0], position[1] + i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 0 else (self.isSelfCrossing(x=x, position=(position[0] - x[num], position[1]), way=way + [(position[0] - i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 1 else (self.isSelfCrossing(x=x, position=(position[0], position[1] - x[num]), way=way + [(position[0], position[1] - i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 2 else (self.isSelfCrossing(x=x, position=(position[0] + x[num], position[1]), way=way + [(position[0] + i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 3 else -1)))) if num < len(x) else (True if True in [True if way.count(i) >= 2 else False for i in way] else False)\\n\\n\\na = Solution()\\nprint(a.isSelfCrossing([2, 1, 1, 2]))\\nprint(a.isSelfCrossing([1, 2, 3, 4]))\\nprint(a.isSelfCrossing([1, 1, 1, 1]))\\nprint(a.isSelfCrossing([2, 2, 3, 3, 2, 3]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.isSelfCrossing = lambda x, position=(0, 0), way=[(0, 0)], num=0: (self.isSelfCrossing(x=x, position=(position[0], position[1] + x[num]), way=way + [(position[0], position[1] + i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 0 else (self.isSelfCrossing(x=x, position=(position[0] - x[num], position[1]), way=way + [(position[0] - i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 1 else (self.isSelfCrossing(x=x, position=(position[0], position[1] - x[num]), way=way + [(position[0], position[1] - i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 2 else (self.isSelfCrossing(x=x, position=(position[0] + x[num], position[1]), way=way + [(position[0] + i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 3 else -1)))) if num < len(x) else (True if True in [True if way.count(i) >= 2 else False for i in way] else False)\\n\\n\\na = Solution()\\nprint(a.isSelfCrossing([2, 1, 1, 2]))\\nprint(a.isSelfCrossing([1, 2, 3, 4]))\\nprint(a.isSelfCrossing([1, 1, 1, 1]))\\nprint(a.isSelfCrossing([2, 2, 3, 3, 2, 3]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521098,
                "title": "inward-and-outward",
                "content": "```\\npublic boolean isSelfCrossing(int[] x) {\\n        int i = 2;\\n        int l = x.length;\\n        if (l <= 3) return false;\\n        while (i < l && x[i] > x[i - 2]){\\n            i++;\\n        }\\n        if(i >= l) return false;\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4] )\\n             || (i == 3 && x[i] == x[i - 2])){\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while(i < l){\\n            if (x[i] >= x[i - 2]) return true;\\n            i++;\\n        }\\n        return false;            \\n    }\\n```\\nref: https://leetcode.com/problems/self-crossing/discuss/79168/Simple-Java-Solution",
                "solutionTags": [],
                "code": "```\\npublic boolean isSelfCrossing(int[] x) {\\n        int i = 2;\\n        int l = x.length;\\n        if (l <= 3) return false;\\n        while (i < l && x[i] > x[i - 2]){\\n            i++;\\n        }\\n        if(i >= l) return false;\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4] )\\n             || (i == 3 && x[i] == x[i - 2])){\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while(i < l){\\n            if (x[i] >= x[i - 2]) return true;\\n            i++;\\n        }\\n        return false;            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519892,
                "title": "python-solution-with-that-checks-whether-the-last-segment-intersect-some-of-the-last-10-segments",
                "content": "I think this solution is easier to understand and still the same complexity.\\n```\\nfrom typing import *\\nfrom collections import deque\\n\\ndef onLine(x1, y1, x2, y2, x3, y3):\\n    return (x2 <= max(x1, x3) and x2 >= min(x1, x3) and\\n            y2 <= max(y1, y3) and y2 >= min(y1, y3))\\n\\ndef orientation(x1, y1, x2, y2, x3, y3):\\n    val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2)\\n    if val > 0: return 1\\n    elif val < 0: return 2\\n    else: return 0\\n\\ndef intersect(seg1, seg2):\\n    x11, y11, x12, y12 = seg1\\n    x21, y21, x22, y22 = seg2\\n    o1 = orientation(x11, y11, x12, y12, x21, y21)\\n    o2 = orientation(x11, y11, x12, y12, x22, y22)\\n    o3 = orientation(x21, y21, x22, y22, x11, y11)\\n    o4 = orientation(x21, y21, x22, y22, x12, y12)\\n    if o1 != o2 and o3 != o4:\\n        return True\\n    # p1 , q1 and p2 are colinear and p2 lies on segment p1q1 \\n    if o1 == 0 and onLine(x11, y11, x21, y21, x12, y12): \\n        return True\\n    # p1 , q1 and q2 are colinear and q2 lies on segment p1q1 \\n    if o2 == 0 and onLine(x11, y11, x22, y22, x12, y12): \\n        return True\\n    # p2 , q2 and p1 are colinear and p1 lies on segment p2q2 \\n    if o3 == 0 and onLine(x21, y21, x11, y11, x22, y22): \\n        return True\\n    # p2 , q2 and q1 are colinear and q1 lies on segment p2q2 \\n    if o4 == 0 and onLine(x21, y21, x12, y12, x22, y22): \\n        return True\\n    # If none of the cases \\n    return False\\n\\ndef solve(A):\\n    last10 = deque()\\n    dir = 0\\n    curx, cury = 0, 0\\n    for i in A:\\n        if dir == 0:\\n            newx, newy = curx, cury + i\\n        elif dir == 1:\\n            newx, newy = curx - i, cury\\n        elif dir == 2:\\n            newx, newy = curx, cury - i\\n        else:\\n            newx, newy = curx + i, cury\\n        dir = (dir + 1) % 4\\n        curSeg = (curx, cury, newx, newy)\\n        for segIdx, seg in enumerate(last10):\\n            if segIdx == len(last10) - 1:\\n                break\\n            if intersect(curSeg, seg):\\n                print(curSeg, seg)\\n                return True\\n        last10.append(curSeg)\\n        if len(last10) > 10:\\n            last10.popleft()\\n        curx, cury = newx, newy\\n    return False\\n\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        return solve(A)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import *\\nfrom collections import deque\\n\\ndef onLine(x1, y1, x2, y2, x3, y3):\\n    return (x2 <= max(x1, x3) and x2 >= min(x1, x3) and\\n            y2 <= max(y1, y3) and y2 >= min(y1, y3))\\n\\ndef orientation(x1, y1, x2, y2, x3, y3):\\n    val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2)\\n    if val > 0: return 1\\n    elif val < 0: return 2\\n    else: return 0\\n\\ndef intersect(seg1, seg2):\\n    x11, y11, x12, y12 = seg1\\n    x21, y21, x22, y22 = seg2\\n    o1 = orientation(x11, y11, x12, y12, x21, y21)\\n    o2 = orientation(x11, y11, x12, y12, x22, y22)\\n    o3 = orientation(x21, y21, x22, y22, x11, y11)\\n    o4 = orientation(x21, y21, x22, y22, x12, y12)\\n    if o1 != o2 and o3 != o4:\\n        return True\\n    # p1 , q1 and p2 are colinear and p2 lies on segment p1q1 \\n    if o1 == 0 and onLine(x11, y11, x21, y21, x12, y12): \\n        return True\\n    # p1 , q1 and q2 are colinear and q2 lies on segment p1q1 \\n    if o2 == 0 and onLine(x11, y11, x22, y22, x12, y12): \\n        return True\\n    # p2 , q2 and p1 are colinear and p1 lies on segment p2q2 \\n    if o3 == 0 and onLine(x21, y21, x11, y11, x22, y22): \\n        return True\\n    # p2 , q2 and q1 are colinear and q1 lies on segment p2q2 \\n    if o4 == 0 and onLine(x21, y21, x12, y12, x22, y22): \\n        return True\\n    # If none of the cases \\n    return False\\n\\ndef solve(A):\\n    last10 = deque()\\n    dir = 0\\n    curx, cury = 0, 0\\n    for i in A:\\n        if dir == 0:\\n            newx, newy = curx, cury + i\\n        elif dir == 1:\\n            newx, newy = curx - i, cury\\n        elif dir == 2:\\n            newx, newy = curx, cury - i\\n        else:\\n            newx, newy = curx + i, cury\\n        dir = (dir + 1) % 4\\n        curSeg = (curx, cury, newx, newy)\\n        for segIdx, seg in enumerate(last10):\\n            if segIdx == len(last10) - 1:\\n                break\\n            if intersect(curSeg, seg):\\n                print(curSeg, seg)\\n                return True\\n        last10.append(curSeg)\\n        if len(last10) > 10:\\n            last10.popleft()\\n        curx, cury = newx, newy\\n    return False\\n\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        return solve(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513866,
                "title": "easy-idea-of-the-problem",
                "content": "Suppose you keep adding edges, e1,e2,e3,...ek. If ek intersected the curve, then it intersects one of the last 8 edges which is e(k-1),e(k-2),...e(k-8). So, you need to keep track of only last 8 edges (O(1) memory). \\n\\nWhy this is true? It seems intuitive try drawing some curves, and you will see that it covers itself as a shell either outwards or inwards and thus previous edges will get unreacheable.",
                "solutionTags": [],
                "code": "Suppose you keep adding edges, e1,e2,e3,...ek. If ek intersected the curve, then it intersects one of the last 8 edges which is e(k-1),e(k-2),...e(k-8). So, you need to keep track of only last 8 edges (O(1) memory). \\n\\nWhy this is true? It seems intuitive try drawing some curves, and you will see that it covers itself as a shell either outwards or inwards and thus previous edges will get unreacheable.",
                "codeTag": "Unknown"
            },
            {
                "id": 505882,
                "title": "another-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Point\\n    {\\n        Point() = default;\\n        Point(int x, int y)\\n        : x(x), y(y) {}\\n        \\n        Point operator+(const Point& other)\\n        {\\n            return Point(x + other.x, y + other.y);\\n        }\\n        \\n        Point operator*(int other)\\n        {\\n            return Point(x * other, y * other);\\n        }\\n        \\n        int x = 0;\\n        int y = 0;\\n    };\\n    \\n    struct Line\\n    {\\n        Line() = default;\\n        Line(const Point& p1, const Point& p2)\\n        : valid(true), p1(p1), p2(p2) {}\\n                \\n        bool valid = false;\\n        Point p1;\\n        Point p2;\\n    };\\n            \\n    bool isIntersecting(const Line& line1, const Line& line2)\\n    {\\n        // Use separating axes theorem to detect intersection.\\n        // Since lines can only be horizontal or vertical they\\n        // can be treated as AABBs.\\n        \\n        Point line2p1, line2p2;\\n        if (line2.p1.x < line2.p2.x) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.x < line2p1.x) && (line1.p2.x < line2p1.x)) ||\\n            ((line1.p1.x > line2p2.x) && (line1.p2.x > line2p2.x))) {\\n            return false;\\n        }\\n        \\n        if (line2.p1.y < line2.p2.y) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.y < line2p1.y) && (line1.p2.y < line2p1.y)) ||\\n            ((line1.p1.y > line2p2.y) && (line1.p2.y > line2p2.y))) {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n                    \\n    bool isSelfCrossing(vector<int>& x) {\\n        Point dirVec[4] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        Line bounds[4][2]; // Whenever we move we can only collide with max 2 lines\\n        \\n        Point cur(0, 0);\\n        int dir = 0;\\n        \\n        int prevDir = 0;\\n        Line prevCurLine;\\n        \\n        Line zeroLine(Point(0,0), Point(0,0));\\n        \\n        for (auto len : x) {\\n            Point next = cur + dirVec[dir] * len;\\n            Line curLine(cur, next);\\n            \\n            for (int i = 0; i < 2; ++i) {\\n                if (bounds[dir][i].valid && isIntersecting(bounds[dir][i], curLine)) {\\n                    return true;\\n                }\\n            }            \\n            \\n            if (prevCurLine.valid) {\\n                if (isIntersecting(zeroLine, curLine)) {\\n                    // We need to explicitly check for (0, 0) collision\\n                    // since there\\'s no previous line leading to that point.\\n                    return true;\\n                }\\n                \\n                // Tricky part is that we should update\\n                // our bounds with a delay of 1 step. Just draw it\\n                // on a piece of paper to see why.\\n                switch (prevDir) {\\n                case 0: // up\\n                        bounds[1][0] = prevCurLine;\\n                        bounds[3][0] = prevCurLine;\\n                        break;\\n                case 1: // left\\n                        bounds[0][0] = prevCurLine;\\n                        bounds[2][0] = prevCurLine;\\n                        break;\\n                case 2: // down\\n                        bounds[1][1] = prevCurLine;\\n                        bounds[3][1] = prevCurLine;\\n                        break;\\n                case 3: // right            \\n                        bounds[0][1] = prevCurLine;\\n                        bounds[2][1] = prevCurLine;\\n                        break;\\n                }\\n            }\\n            \\n            prevCurLine = curLine;\\n            prevDir = dir;\\n            \\n            dir = (dir + 1) % 4;\\n            cur = next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Point\\n    {\\n        Point() = default;\\n        Point(int x, int y)\\n        : x(x), y(y) {}\\n        \\n        Point operator+(const Point& other)\\n        {\\n            return Point(x + other.x, y + other.y);\\n        }\\n        \\n        Point operator*(int other)\\n        {\\n            return Point(x * other, y * other);\\n        }\\n        \\n        int x = 0;\\n        int y = 0;\\n    };\\n    \\n    struct Line\\n    {\\n        Line() = default;\\n        Line(const Point& p1, const Point& p2)\\n        : valid(true), p1(p1), p2(p2) {}\\n                \\n        bool valid = false;\\n        Point p1;\\n        Point p2;\\n    };\\n            \\n    bool isIntersecting(const Line& line1, const Line& line2)\\n    {\\n        // Use separating axes theorem to detect intersection.\\n        // Since lines can only be horizontal or vertical they\\n        // can be treated as AABBs.\\n        \\n        Point line2p1, line2p2;\\n        if (line2.p1.x < line2.p2.x) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.x < line2p1.x) && (line1.p2.x < line2p1.x)) ||\\n            ((line1.p1.x > line2p2.x) && (line1.p2.x > line2p2.x))) {\\n            return false;\\n        }\\n        \\n        if (line2.p1.y < line2.p2.y) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.y < line2p1.y) && (line1.p2.y < line2p1.y)) ||\\n            ((line1.p1.y > line2p2.y) && (line1.p2.y > line2p2.y))) {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n                    \\n    bool isSelfCrossing(vector<int>& x) {\\n        Point dirVec[4] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        Line bounds[4][2]; // Whenever we move we can only collide with max 2 lines\\n        \\n        Point cur(0, 0);\\n        int dir = 0;\\n        \\n        int prevDir = 0;\\n        Line prevCurLine;\\n        \\n        Line zeroLine(Point(0,0), Point(0,0));\\n        \\n        for (auto len : x) {\\n            Point next = cur + dirVec[dir] * len;\\n            Line curLine(cur, next);\\n            \\n            for (int i = 0; i < 2; ++i) {\\n                if (bounds[dir][i].valid && isIntersecting(bounds[dir][i], curLine)) {\\n                    return true;\\n                }\\n            }            \\n            \\n            if (prevCurLine.valid) {\\n                if (isIntersecting(zeroLine, curLine)) {\\n                    // We need to explicitly check for (0, 0) collision\\n                    // since there\\'s no previous line leading to that point.\\n                    return true;\\n                }\\n                \\n                // Tricky part is that we should update\\n                // our bounds with a delay of 1 step. Just draw it\\n                // on a piece of paper to see why.\\n                switch (prevDir) {\\n                case 0: // up\\n                        bounds[1][0] = prevCurLine;\\n                        bounds[3][0] = prevCurLine;\\n                        break;\\n                case 1: // left\\n                        bounds[0][0] = prevCurLine;\\n                        bounds[2][0] = prevCurLine;\\n                        break;\\n                case 2: // down\\n                        bounds[1][1] = prevCurLine;\\n                        bounds[3][1] = prevCurLine;\\n                        break;\\n                case 3: // right            \\n                        bounds[0][1] = prevCurLine;\\n                        bounds[2][1] = prevCurLine;\\n                        break;\\n                }\\n            }\\n            \\n            prevCurLine = curLine;\\n            prevDir = dir;\\n            \\n            dir = (dir + 1) % 4;\\n            cur = next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418080,
                "title": "java-solution-faster-then-100-and-uses-less-memory-then-100",
                "content": "\\n\\nclass Solution {\\n    \\n\\tpublic boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4) return false;\\n\\n\\t\\tfor(int i =3 ; i < x.length ; i++){\\n\\t\\t\\tif(x[i-1] <= x[i-3] && x[i] >= x[i-2])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif( i > 4 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3]-x[i-5] && x[i-1] <= x[i-3]  && x[i-2] >= x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(i > 3 && x[i-1] == x[i-3] && x[i] >= x[i-2]-x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n}\\n\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4) return false;\\n\\n\\t\\tfor(int i =3 ; i < x.length ; i++){\\n\\t\\t\\tif(x[i-1] <= x[i-3] && x[i] >= x[i-2])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif( i > 4 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3]-x[i-5] && x[i-1] <= x[i-3]  && x[i-2] >= x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(i > 3 && x[i-1] == x[i-3] && x[i] >= x[i-2]-x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 388029,
                "title": "python3-dp",
                "content": "```\\n\\n\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        m=len(x)\\n        if m<4:\\n            return False\\n        bo=False\\n        def dfs(i):\\n            nonlocal bo,x,m\\n            if bo:\\n                return \\n            if i+3>=m:\\n                return \\n            if x[i]>=x[i+2] and x[i+3]>=x[i+1]:\\n                bo=True\\n                return\\n            elif x[i+3]<x[i+1]:\\n                dfs(i+1)\\n                return\\n            else: \\n                # 0<2 and 3>=1\\n                if i+4>m-1:\\n                    return\\n                if x[i+1]==x[i+3]:\\n                    if x[i+2]-x[i]<=x[i+4]:\\n                        bo=True\\n                    else:\\n                        dfs(i+1)\\n                        return \\n                else:\\n                    if x[i+2]-x[i]>x[i+4]:\\n                        dfs(i+1)\\n                    elif x[i+4]>x[2]:\\n                        dfs(i+1)\\n                    else:\\n                        if i+5>m-1:\\n                            return\\n                        if x[i+5]>=x[i+3]-x[i+1]:\\n                            bo=True\\n                        else:\\n                            dfs(i+1)\\n        dfs(0)\\n        return bo\\n",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        m=len(x)\\n        if m<4:\\n            return False\\n        bo=False\\n        def dfs(i):\\n            nonlocal bo,x,m\\n            if bo:\\n                return \\n            if i+3>=m:\\n                return \\n            if x[i]>=x[i+2] and x[i+3]>=x[i+1]:\\n                bo=True\\n                return\\n            elif x[i+3]<x[i+1]:\\n                dfs(i+1)\\n                return\\n            else: \\n                # 0<2 and 3>=1\\n                if i+4>m-1:\\n                    return\\n                if x[i+1]==x[i+3]:\\n                    if x[i+2]-x[i]<=x[i+4]:\\n                        bo=True\\n                    else:\\n                        dfs(i+1)\\n                        return \\n                else:\\n                    if x[i+2]-x[i]>x[i+4]:\\n                        dfs(i+1)\\n                    elif x[i+4]>x[2]:\\n                        dfs(i+1)\\n                    else:\\n                        if i+5>m-1:\\n                            return\\n                        if x[i+5]>=x[i+3]-x[i+1]:\\n                            bo=True\\n                        else:\\n                            dfs(i+1)\\n        dfs(0)\\n        return bo\\n",
                "codeTag": "Java"
            },
            {
                "id": 386087,
                "title": "python-simple-case-easy-to-read",
                "content": "Catch the three different shapes\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(x) < 4:\\n            return False\\n       \\n        for pos in range(3, len(x)):\\n            if x[pos - 1] <= x[pos - 3] and x[pos] >= x[pos - 2]:  # general case\\n                return True\\n            if pos >= 4 and x[pos - 1] == x[pos - 3] and x[pos] + x[pos - 4] == x[pos - 2]:  # connected rectangle\\n                return True\\n            # connected L-shape\\n            if pos >= 5 and x[pos-1] <= x[pos-3] and x[pos-3] <= x[pos-1] + x[pos-5] and x[pos] + x[pos-4] >= x[pos-2] and x[pos-4] <= x[pos-2]:\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(x) < 4:\\n            return False\\n       \\n        for pos in range(3, len(x)):\\n            if x[pos - 1] <= x[pos - 3] and x[pos] >= x[pos - 2]:  # general case\\n                return True\\n            if pos >= 4 and x[pos - 1] == x[pos - 3] and x[pos] + x[pos - 4] == x[pos - 2]:  # connected rectangle\\n                return True\\n            # connected L-shape\\n            if pos >= 5 and x[pos-1] <= x[pos-3] and x[pos-3] <= x[pos-1] + x[pos-5] and x[pos] + x[pos-4] >= x[pos-2] and x[pos-4] <= x[pos-2]:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343852,
                "title": "lol-java-implementation-as-a-fsm",
                "content": "I ended up enumerating the 7 possible states we could be in, and used the next number in the array to drive to the next state.  Kinda ridiculous.\\n\\n```\\nclass Solution {\\n    private class Point {\\n        public int x;\\n        public int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        public int segmentLength(Point other) {\\n            return other.x == this.x ? Math.abs(other.y - this.y) :\\n                                       Math.abs(other.x - this.x);\\n        }\\n        private Point copyAndAdjustPoint(int i, int amount) {\\n            Point copy = new Point(this.x, this.y);\\n            switch(i % 4) {\\n                case 0:\\n                    copy.y += amount;\\n                    break;\\n                case 1:\\n                    copy.x -= amount;\\n                    break;\\n                case 2:\\n                    copy.y -= amount;\\n                    break;\\n                case 3:\\n                    copy.x += amount;\\n                    break;\\n            }\\n            return copy;\\n        }\\n    }\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        LinkedList<Point> points = new LinkedList<Point>();\\n        int state = 0;\\n        Point curPoint = new Point(0,0);\\n        points.add(curPoint);\\n        \\n        for(int i = 0; i < x.length; i++) {\\n            curPoint = curPoint.copyAndAdjustPoint(i, x[i]);\\n            points.add(curPoint);\\n            switch(state) {\\n                case 0:\\n                    state = 1;\\n                    break;\\n                case 1:\\n                    state = 2;\\n                    break;\\n                case 2:\\n                    if(points.get(3).segmentLength(points.get(2)) > points.get(1).segmentLength(points.get(0))) {\\n                        state = 4;\\n                    } else {\\n                        state = 3;\\n                    }\\n                    break;\\n                case 3:\\n                    if(points.get(4).segmentLength(points.get(3)) >= points.get(2).segmentLength(points.get(1))) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n                case 4:\\n                    if(points.get(4).segmentLength(points.get(3)) < points.get(2).segmentLength(points.get(1))) {\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else {\\n                        state = 5;\\n                    }\\n                    break;\\n                case 5:\\n                    int l1 = points.get(5).segmentLength(points.get(4));\\n                    int l2 = points.get(3).segmentLength(points.get(2));\\n                    int l3 = points.get(1).segmentLength(points.get(0));\\n                    if(l1 + l3 < l2) {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else if(l1 + l3 > l2) {\\n                        if(l1 > l2) {\\n                            points.removeFirst();\\n                        } else {\\n                            state = 6;\\n                        }\\n                    }\\n                    break;\\n                case 6:\\n                    l1 = points.get(6).segmentLength(points.get(5));\\n                    l2 = points.get(4).segmentLength(points.get(3));\\n                    l3 = points.get(2).segmentLength(points.get(1));\\n                    if(l1 + l3 >= l2) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n            }\\n            Point start = points.peekFirst();\\n            Point end = points.peekLast();\\n            if(start.x == end.x && start.y == end.y) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class Point {\\n        public int x;\\n        public int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        public int segmentLength(Point other) {\\n            return other.x == this.x ? Math.abs(other.y - this.y) :\\n                                       Math.abs(other.x - this.x);\\n        }\\n        private Point copyAndAdjustPoint(int i, int amount) {\\n            Point copy = new Point(this.x, this.y);\\n            switch(i % 4) {\\n                case 0:\\n                    copy.y += amount;\\n                    break;\\n                case 1:\\n                    copy.x -= amount;\\n                    break;\\n                case 2:\\n                    copy.y -= amount;\\n                    break;\\n                case 3:\\n                    copy.x += amount;\\n                    break;\\n            }\\n            return copy;\\n        }\\n    }\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        LinkedList<Point> points = new LinkedList<Point>();\\n        int state = 0;\\n        Point curPoint = new Point(0,0);\\n        points.add(curPoint);\\n        \\n        for(int i = 0; i < x.length; i++) {\\n            curPoint = curPoint.copyAndAdjustPoint(i, x[i]);\\n            points.add(curPoint);\\n            switch(state) {\\n                case 0:\\n                    state = 1;\\n                    break;\\n                case 1:\\n                    state = 2;\\n                    break;\\n                case 2:\\n                    if(points.get(3).segmentLength(points.get(2)) > points.get(1).segmentLength(points.get(0))) {\\n                        state = 4;\\n                    } else {\\n                        state = 3;\\n                    }\\n                    break;\\n                case 3:\\n                    if(points.get(4).segmentLength(points.get(3)) >= points.get(2).segmentLength(points.get(1))) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n                case 4:\\n                    if(points.get(4).segmentLength(points.get(3)) < points.get(2).segmentLength(points.get(1))) {\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else {\\n                        state = 5;\\n                    }\\n                    break;\\n                case 5:\\n                    int l1 = points.get(5).segmentLength(points.get(4));\\n                    int l2 = points.get(3).segmentLength(points.get(2));\\n                    int l3 = points.get(1).segmentLength(points.get(0));\\n                    if(l1 + l3 < l2) {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else if(l1 + l3 > l2) {\\n                        if(l1 > l2) {\\n                            points.removeFirst();\\n                        } else {\\n                            state = 6;\\n                        }\\n                    }\\n                    break;\\n                case 6:\\n                    l1 = points.get(6).segmentLength(points.get(5));\\n                    l2 = points.get(4).segmentLength(points.get(3));\\n                    l3 = points.get(2).segmentLength(points.get(1));\\n                    if(l1 + l3 >= l2) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n            }\\n            Point start = points.peekFirst();\\n            Point end = points.peekLast();\\n            if(start.x == end.x && start.y == end.y) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311307,
                "title": "golang-with-thought-process",
                "content": "There are many self crossing scenarios. However, there are only three general categories without self crossing, namely, spiral in, spiral out, spiral out ---> spiral in. \\n\\nI use a boolean variable spiralIn to indicate if it becomes the spiral-in case. Once it becomes the spiral-in case it is very easy to test for self crossing: the only way to avoid self crossing is to keep reducing the lenghth of the parrellel edges. \\n\\nThe tricky part is when it changes from spiral-out to spiral-in, sometimes we need to adjust x[i - 1] (but not always)\\n\\nAlso, I tested for 0s in the array. If there is a 0, it must be self crossing.\\n\\n```\\nfunc isSelfCrossing(x []int) bool {\\n    if len(x) < 4 {\\n        return false\\n    }    \\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    if x[3] >= x[1] && x[2] <= x[0] {\\n        return true\\n    }\\n\\t\\n    spiralIn := x[3] < x[1]\\n    for i := 4; i < len(x); i ++ {\\n        if spiralIn {\\n            if x[i] >= x[i - 2] {\\n                return true\\n            }\\n        } else {\\n            if x[i] <= x[i - 2] {\\n                spiralIn = true\\n                if x[i] + x[i - 4] >= x[i - 2] {  //this is the condition when one needs to adjust the length of x[i - 1]\\n                    x[i - 1] = x[i - 1] - x[i - 3]\\n                }\\n            }\\n        }\\n    }\\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSelfCrossing(x []int) bool {\\n    if len(x) < 4 {\\n        return false\\n    }    \\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    if x[3] >= x[1] && x[2] <= x[0] {\\n        return true\\n    }\\n\\t\\n    spiralIn := x[3] < x[1]\\n    for i := 4; i < len(x); i ++ {\\n        if spiralIn {\\n            if x[i] >= x[i - 2] {\\n                return true\\n            }\\n        } else {\\n            if x[i] <= x[i - 2] {\\n                spiralIn = true\\n                if x[i] + x[i - 4] >= x[i - 2] {  //this is the condition when one needs to adjust the length of x[i - 1]\\n                    x[i - 1] = x[i - 1] - x[i - 3]\\n                }\\n            }\\n        }\\n    }\\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278190,
                "title": "java-o-1-o-n-solution-of-simulation",
                "content": "Need a proper proof for the algorithm, specifically, why we only need to track last 6 points. 6 is a number I come up with by intuition.\\n\\n```\\nclass Solution {\\n    int[] p = new int[2];\\n    int[] tr = new int[12]; // track last 6 points \\n    int nmove = 0;\\n    int tracked = 0;\\n    \\n    public boolean isSelfCrossing(int[] x) {\\n        track(p);\\n        \\n        for (int i = 0; i < x.length; i++) {\\n            if (move(x[i])) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    // 0: up\\n    // 1: left\\n    // 2: down\\n    // 3: right\\n    boolean move(int d) {\\n        nmove = nmove % 4;\\n                \\n        if (nmove == 0) { // up\\n            if (crossUp(d)) {\\n                return true;\\n            }\\n            p[1] += d;\\n            \\n        } else if (nmove == 1) { // left\\n            if (crossLeft(d)) {\\n                return true;\\n            }\\n            p[0] -= d;\\n            \\n        } else if (nmove == 2) { // down\\n            if (crossDown(d)) {\\n                return true;\\n            }\\n            p[1] -= d;            \\n            \\n        } else { // right\\n            if (crossRight(d)) {\\n                return true;\\n            }\\n            p[0] += d;            \\n        }\\n        \\n        nmove++;\\n        track(p);\\n        return false;\\n    }\\n    \\n    boolean crossUp(int d) {\\n        if (tracked < 5) {\\n            return false;\\n        }\\n        if (tracked == 5) {\\n            if (p[0] == tr[0]) {\\n                return p[1] + d >= tr[1];\\n            } else {\\n                return crossH(d, tr[2], tr[3], tr[4]);\\n            }\\n        }\\n        return crossH(d, tr[0], tr[1], tr[2]) ||\\n               crossH(d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossLeft(int d) {\\n        if (tracked < 6) {\\n            return false;            \\n        }\\n        return crossV(-d, tr[1], tr[2], tr[3]) ||\\n               crossV(-d, tr[5], tr[6], tr[7]);\\n    }\\n    \\n    boolean crossDown(int d) {\\n        if (tracked < 6) {\\n            return false;\\n        }\\n        return crossH(-d, tr[0], tr[1], tr[2]) || \\n               crossH(-d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossRight(int d) {        \\n        if (tracked == 4) {\\n            return crossV(d, tr[1], tr[2], tr[3]);\\n        }\\n        return crossV(d, tr[1], tr[2], tr[3]) ||\\n               crossV(d, tr[5], tr[6], tr[7]);\\n    }\\n\\n    // check if the move will cross the horizontal line segment \\n    // represented as x1, y1, x2\\n    boolean crossH(int d, int x1, int y1, int x2) {\\n        int xmin = Math.min(x1, x2);        \\n        int xmax = Math.max(x1, x2);\\n         // out of the span of the segment; it can never touch it;        \\n        if (p[0] < xmin || p[0] > xmax) {\\n            return false;\\n        }\\n        // cross after move\\n        if ((p[1]-y1) * (p[1]+d-y1) > 0) { \\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n\\n    boolean crossV(int d, int y1, int x1, int y2) {\\n        int ymin = Math.min(y1, y2);\\n        int ymax = Math.max(y1, y2);\\n        if (p[1] < ymin || p[1] > ymax) {\\n            return false;\\n        }\\n        if ((p[0]-x1) * (p[0]+d-x1) > 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    // push the point to the end of `tr`\\n    void track(int[] p) {\\n        if (tracked >= 6) {\\n            for (int i = 0; i < 10; i++) {\\n                tr[i] = tr[i+2];            \\n            }            \\n            tr[10] = p[0];\\n            tr[11] = p[1];\\n        } else {\\n            tr[tracked*2] = p[0];\\n            tr[tracked*2+1] = p[1];\\n        }\\n        tracked++;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] p = new int[2];\\n    int[] tr = new int[12]; // track last 6 points \\n    int nmove = 0;\\n    int tracked = 0;\\n    \\n    public boolean isSelfCrossing(int[] x) {\\n        track(p);\\n        \\n        for (int i = 0; i < x.length; i++) {\\n            if (move(x[i])) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    // 0: up\\n    // 1: left\\n    // 2: down\\n    // 3: right\\n    boolean move(int d) {\\n        nmove = nmove % 4;\\n                \\n        if (nmove == 0) { // up\\n            if (crossUp(d)) {\\n                return true;\\n            }\\n            p[1] += d;\\n            \\n        } else if (nmove == 1) { // left\\n            if (crossLeft(d)) {\\n                return true;\\n            }\\n            p[0] -= d;\\n            \\n        } else if (nmove == 2) { // down\\n            if (crossDown(d)) {\\n                return true;\\n            }\\n            p[1] -= d;            \\n            \\n        } else { // right\\n            if (crossRight(d)) {\\n                return true;\\n            }\\n            p[0] += d;            \\n        }\\n        \\n        nmove++;\\n        track(p);\\n        return false;\\n    }\\n    \\n    boolean crossUp(int d) {\\n        if (tracked < 5) {\\n            return false;\\n        }\\n        if (tracked == 5) {\\n            if (p[0] == tr[0]) {\\n                return p[1] + d >= tr[1];\\n            } else {\\n                return crossH(d, tr[2], tr[3], tr[4]);\\n            }\\n        }\\n        return crossH(d, tr[0], tr[1], tr[2]) ||\\n               crossH(d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossLeft(int d) {\\n        if (tracked < 6) {\\n            return false;            \\n        }\\n        return crossV(-d, tr[1], tr[2], tr[3]) ||\\n               crossV(-d, tr[5], tr[6], tr[7]);\\n    }\\n    \\n    boolean crossDown(int d) {\\n        if (tracked < 6) {\\n            return false;\\n        }\\n        return crossH(-d, tr[0], tr[1], tr[2]) || \\n               crossH(-d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossRight(int d) {        \\n        if (tracked == 4) {\\n            return crossV(d, tr[1], tr[2], tr[3]);\\n        }\\n        return crossV(d, tr[1], tr[2], tr[3]) ||\\n               crossV(d, tr[5], tr[6], tr[7]);\\n    }\\n\\n    // check if the move will cross the horizontal line segment \\n    // represented as x1, y1, x2\\n    boolean crossH(int d, int x1, int y1, int x2) {\\n        int xmin = Math.min(x1, x2);        \\n        int xmax = Math.max(x1, x2);\\n         // out of the span of the segment; it can never touch it;        \\n        if (p[0] < xmin || p[0] > xmax) {\\n            return false;\\n        }\\n        // cross after move\\n        if ((p[1]-y1) * (p[1]+d-y1) > 0) { \\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n\\n    boolean crossV(int d, int y1, int x1, int y2) {\\n        int ymin = Math.min(y1, y2);\\n        int ymax = Math.max(y1, y2);\\n        if (p[1] < ymin || p[1] > ymax) {\\n            return false;\\n        }\\n        if ((p[0]-x1) * (p[0]+d-x1) > 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    // push the point to the end of `tr`\\n    void track(int[] p) {\\n        if (tracked >= 6) {\\n            for (int i = 0; i < 10; i++) {\\n                tr[i] = tr[i+2];            \\n            }            \\n            tr[10] = p[0];\\n            tr[11] = p[1];\\n        } else {\\n            tr[tracked*2] = p[0];\\n            tr[tracked*2+1] = p[1];\\n        }\\n        tracked++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198282,
                "title": "c-solution-with-diagram",
                "content": "Although, not as short as some of the other answers here...\\n\\n```\\nclass Solution {\\npublic:\\n    struct State {\\n        int lh;\\n        int tw;\\n        int rh;\\n        int bw;\\n    };\\n\\n    bool isSelfCrossing(vector<int>& x) {\\n        //               tw                                    tw\\n        // .    *-----------------*              .    *-----------------*\\n        // .    |                 | rh           .    |                 |\\n        // .    |                 |              .    |                 |\\n        // 5    |        cx *-----* ry           5    |                 |\\n        // 4 lh |              bw         OR     4 lh |                 | rh\\n        // 3    |                                3    |                 |\\n        // 2    |                                2    |                 |\\n        // 1    *----->* nx                      1    *----->* nx       |\\n        //    (1,1)                                 (1,1)               * ry\\n        //                                                                bw=1\\n        //      12345...                              12345...\\n        //\\n        // All lengths are inclusive of the endpoints.\\n\\n        if (x.size() < 3) {\\n            return false;\\n        }\\n\\n        State s = {x[2] + 1, x[1] + 1, x[0] + 1, 1};\\n\\n        for (size_t i = 3; i < x.size(); i++) {\\n            const int nx = 1 + x[i];\\n            const int cx = s.tw - s.bw + 1;\\n            const int ry = s.lh - s.rh + 1;\\n\\n            if ((nx >= s.tw) && (ry <= 1)) {\\n                return true;\\n            }\\n\\n            // Rotate clockwise.\\n            State t;\\n            t.lh = nx;\\n            if (nx <= s.tw) {\\n                if (nx < cx) {\\n                    t.tw = s.lh;\\n                }\\n                else {\\n                    t.tw = ry;\\n                }\\n                t.rh = nx;\\n                t.bw = 1;\\n            }\\n            else {\\n                t.tw = s.lh;\\n                t.rh = s.tw;\\n                t.bw = s.rh;\\n            }\\n            s = t;\\n\\n            // cout << \"lh = \" << s.lh << \"; tw = \" << s.tw << \"; rh = \" << s.rh << \"; bw = \" << s.bw << endl;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct State {\\n        int lh;\\n        int tw;\\n        int rh;\\n        int bw;\\n    };\\n\\n    bool isSelfCrossing(vector<int>& x) {\\n        //               tw                                    tw\\n        // .    *-----------------*              .    *-----------------*\\n        // .    |                 | rh           .    |                 |\\n        // .    |                 |              .    |                 |\\n        // 5    |        cx *-----* ry           5    |                 |\\n        // 4 lh |              bw         OR     4 lh |                 | rh\\n        // 3    |                                3    |                 |\\n        // 2    |                                2    |                 |\\n        // 1    *----->* nx                      1    *----->* nx       |\\n        //    (1,1)                                 (1,1)               * ry\\n        //                                                                bw=1\\n        //      12345...                              12345...\\n        //\\n        // All lengths are inclusive of the endpoints.\\n\\n        if (x.size() < 3) {\\n            return false;\\n        }\\n\\n        State s = {x[2] + 1, x[1] + 1, x[0] + 1, 1};\\n\\n        for (size_t i = 3; i < x.size(); i++) {\\n            const int nx = 1 + x[i];\\n            const int cx = s.tw - s.bw + 1;\\n            const int ry = s.lh - s.rh + 1;\\n\\n            if ((nx >= s.tw) && (ry <= 1)) {\\n                return true;\\n            }\\n\\n            // Rotate clockwise.\\n            State t;\\n            t.lh = nx;\\n            if (nx <= s.tw) {\\n                if (nx < cx) {\\n                    t.tw = s.lh;\\n                }\\n                else {\\n                    t.tw = ry;\\n                }\\n                t.rh = nx;\\n                t.bw = 1;\\n            }\\n            else {\\n                t.tw = s.lh;\\n                t.rh = s.tw;\\n                t.bw = s.rh;\\n            }\\n            s = t;\\n\\n            // cout << \"lh = \" << s.lh << \"; tw = \" << s.tw << \"; rh = \" << s.rh << \"; bw = \" << s.bw << endl;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 193400,
                "title": "py3-think-of-it-like-a-matrix-and-you-are-traversing-it-will-be-simple",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, paths):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        directions = [(-1,0), (0, -1), (1, 0), (0, 1)]\\n        \\n        visited = set([(0,0)])\\n        position = (0, 0)\\n        for inx, path in enumerate(paths):\\n            position_x, position_y = position\\n            for i in range(path):\\n                position_x += directions[inx % 4][0]\\n                position_y += directions[inx % 4][1]\\n                if (position_x, position_y) not in visited: \\n                    visited.add((position_x, position_y))\\n                else:\\n                    return True\\n            position = (position_x, position_y)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, paths):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        directions = [(-1,0), (0, -1), (1, 0), (0, 1)]\\n        \\n        visited = set([(0,0)])\\n        position = (0, 0)\\n        for inx, path in enumerate(paths):\\n            position_x, position_y = position\\n            for i in range(path):\\n                position_x += directions[inx % 4][0]\\n                position_y += directions[inx % 4][1]\\n                if (position_x, position_y) not in visited: \\n                    visited.add((position_x, position_y))\\n                else:\\n                    return True\\n            position = (position_x, position_y)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138854,
                "title": "c-recursion-solution",
                "content": "Getting idea from discussion, rewrite in recursion style.\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 4) return false;\\n        return helper(x[0], x[1], x[2], x[3], x, 3);\\n    }\\n    \\n    bool helper(int a, int b, int c, int d, vector<int>& x, int cur) {\\n        if (cur == x.size()) return false;\\n        if (a >= c && d >= b) return true;\\n        if (cur + 1 < x.size() && b == d && c - a <= x[cur+1]) return true;\\n        if (cur + 2 < x.size() && d >= b && c >= x[cur+1] &&  x[cur+1] >= c - a && x[cur+2] >= d - b) return true;\\n        return helper(b, c, d, x[cur+1], x, cur+1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 4) return false;\\n        return helper(x[0], x[1], x[2], x[3], x, 3);\\n    }\\n    \\n    bool helper(int a, int b, int c, int d, vector<int>& x, int cur) {\\n        if (cur == x.size()) return false;\\n        if (a >= c && d >= b) return true;\\n        if (cur + 1 < x.size() && b == d && c - a <= x[cur+1]) return true;\\n        if (cur + 2 < x.size() && d >= b && c >= x[cur+1] &&  x[cur+1] >= c - a && x[cur+2] >= d - b) return true;\\n        return helper(b, c, d, x[cur+1], x, cur+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115984,
                "title": "readable-44ms-o-n-time-and-o-1-space-python-solution",
                "content": "We retain at most the last 5 line segments and check current run -3 and -5'th line segments (which are orthogonal) to the current segment for intersection and the current run -4'th line segment for co-incidence. The logic here being, if the path is self crossing (given the square spiral nature of the motion) the crossing should be realized by the current segment and at most the current run -5'th segment at the earliest.\n```\nclass Segment(object):\n    def __init__(self, x0, y0, x1, y1):\n        self.x0 = min(x0, x1)\n        self.y0 = min(y0, y1)\n        self.x1 = max(x0, x1)\n        self.y1 = max(y0, y1)\n\n\n    def isIntersecting(self, segment2:'Segment'):\n        delta_x = self.x1 - self.x0\n        delta_y = self.y1 - self.y0\n\n        delta_x_2 = segment2.x1 - segment2.x0\n        delta_y_2 = segment2.y1 - segment2.y0\n\n        if delta_x*delta_x_2 + delta_y*delta_y_2 == 0:\n            #orthogonality satisfied\n            if delta_x != 0 and delta_y_2 != 0:\n                if self.x0 <= segment2.x0 <= self.x1 and segment2.y0 <= self.y0 <= segment2.y1:\n                    return True\n            if delta_y != 0 and delta_x_2 != 0:\n                if self.y0 <= segment2.y0 <= self.y1 and segment2.x0 <= self.x0 <= segment2.x1:\n                    return True\n        else:\n            #Co-incidence perhaps?\n            if delta_x == 0:\n                if (self.y0 <= segment2.y0 <= self.y1 or self.y0 <= segment2.y1 <= self.y1) and self.x0 == segment2.x0:\n                    return True\n            elif delta_y == 0:\n                if (self.x0 <= segment2.x0 <= self.x1 or self.x0 <= segment2.x1 <= self.x1) and self.y0 == segment2.y0:\n                    return True\n        return False\n\nclass Solution:\n    def isSelfCrossing(self, x):\n        \"\"\"\n        :type x: List[int]\n        :rtype: bool\n        \"\"\"\n        cur_x = 0\n        cur_y = 0\n        l = len(x)\n        q = {}\n\n\n        if l >= 4:\n            if l==4:\n                if x[0] >= x[2] and x[3] >= x[1]:\n                    return True\n            else:\n                for m in range(0, l):\n                    rolling_index = m % 4\n                    if rolling_index == 0:\n                        # Checking for cross-over at North movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y+x[m])\n                        cur_y += x[m]\n                    elif rolling_index == 1:\n                        # Checking for crossing at West movement\n                        seg = Segment(cur_x, cur_y, cur_x - x[m], cur_y)\n                        cur_x -= x[m]\n                    elif rolling_index == 2:\n                        # Checking for crossing at South movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y - x[m])\n                        cur_y -= x[m]\n                    else:\n                        # Checking for crossing at East movement\n                        seg = Segment(cur_x, cur_y, cur_x + x[m], cur_y)\n                        cur_x += x[m]\n\n                    if m - 5 in q:\n                        if q[m - 5].isIntersecting(seg):\n                            return True\n                    if m - 4 in q:\n                        if q[m - 4].isIntersecting(seg):\n                            return True\n                    if m - 3 in q:\n                        if q[m - 3].isIntersecting(seg):\n                            return True\n                    q[m] = seg\n                    if m >= 5:\n                        del q[m-5]\n        return False\n```",
                "solutionTags": [],
                "code": "```\nclass Segment(object):\n    def __init__(self, x0, y0, x1, y1):\n        self.x0 = min(x0, x1)\n        self.y0 = min(y0, y1)\n        self.x1 = max(x0, x1)\n        self.y1 = max(y0, y1)\n\n\n    def isIntersecting(self, segment2:'Segment'):\n        delta_x = self.x1 - self.x0\n        delta_y = self.y1 - self.y0\n\n        delta_x_2 = segment2.x1 - segment2.x0\n        delta_y_2 = segment2.y1 - segment2.y0\n\n        if delta_x*delta_x_2 + delta_y*delta_y_2 == 0:\n            #orthogonality satisfied\n            if delta_x != 0 and delta_y_2 != 0:\n                if self.x0 <= segment2.x0 <= self.x1 and segment2.y0 <= self.y0 <= segment2.y1:\n                    return True\n            if delta_y != 0 and delta_x_2 != 0:\n                if self.y0 <= segment2.y0 <= self.y1 and segment2.x0 <= self.x0 <= segment2.x1:\n                    return True\n        else:\n            #Co-incidence perhaps?\n            if delta_x == 0:\n                if (self.y0 <= segment2.y0 <= self.y1 or self.y0 <= segment2.y1 <= self.y1) and self.x0 == segment2.x0:\n                    return True\n            elif delta_y == 0:\n                if (self.x0 <= segment2.x0 <= self.x1 or self.x0 <= segment2.x1 <= self.x1) and self.y0 == segment2.y0:\n                    return True\n        return False\n\nclass Solution:\n    def isSelfCrossing(self, x):\n        \"\"\"\n        :type x: List[int]\n        :rtype: bool\n        \"\"\"\n        cur_x = 0\n        cur_y = 0\n        l = len(x)\n        q = {}\n\n\n        if l >= 4:\n            if l==4:\n                if x[0] >= x[2] and x[3] >= x[1]:\n                    return True\n            else:\n                for m in range(0, l):\n                    rolling_index = m % 4\n                    if rolling_index == 0:\n                        # Checking for cross-over at North movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y+x[m])\n                        cur_y += x[m]\n                    elif rolling_index == 1:\n                        # Checking for crossing at West movement\n                        seg = Segment(cur_x, cur_y, cur_x - x[m], cur_y)\n                        cur_x -= x[m]\n                    elif rolling_index == 2:\n                        # Checking for crossing at South movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y - x[m])\n                        cur_y -= x[m]\n                    else:\n                        # Checking for crossing at East movement\n                        seg = Segment(cur_x, cur_y, cur_x + x[m], cur_y)\n                        cur_x += x[m]\n\n                    if m - 5 in q:\n                        if q[m - 5].isIntersecting(seg):\n                            return True\n                    if m - 4 in q:\n                        if q[m - 4].isIntersecting(seg):\n                            return True\n                    if m - 3 in q:\n                        if q[m - 3].isIntersecting(seg):\n                            return True\n                    q[m] = seg\n                    if m >= 5:\n                        del q[m-5]\n        return False\n```",
                "codeTag": "Java"
            },
            {
                "id": 111766,
                "title": "swift-solution-check-inside-or-outside-the-spiral",
                "content": "When route is inside spiral , just check distance in this direction. If it's outsite the spiral need to check whether change the status flag.\\n\\n```\\nfunc isSelfCrossing(_ x: [Int]) -> Bool {\\n        if x.count < 4 { return false }\\n        var isOuter = x[2] > x[0]\\n        var previous = [Int]()\\n        for i in 0..<4 {\\n            previous.append(x[i])\\n        }\\n        previous[3] = 0\\n        for i in 3..<x.count {\\n            if isOuter == false {\\n                if x[i] >= previous[(i - 2) % 4] { \\n                    return true \\n                }\\n                previous[i % 4] = x[i]\\n            } else {\\n                if x[i] > previous[(i - 2) % 4] {\\n                    previous[i % 4] = x[i]\\n                    continue \\n                } else {\\n                    isOuter = false\\n                  // should update the previous path length, because now, the route is inside the spiral \\n                    if previous[(i - 1) % 4] > previous[(i - 3) % 4] && ( x[i] >= previous[(i - 2) % 4] - previous[i % 4]\\n                                                                         && x[i] <= previous[(i - 2) % 4]) {\\n                        previous[(i - 1) % 4] -= previous[(i - 3) % 4]\\n                    }\\n                }\\n            }\\n            previous[i % 4] = x[i]\\n        }\\n        return false\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSelfCrossing(_ x: [Int]) -> Bool {\\n        if x.count < 4 { return false }\\n        var isOuter = x[2] > x[0]\\n        var previous = [Int]()\\n        for i in 0..<4 {\\n            previous.append(x[i])\\n        }\\n        previous[3] = 0\\n        for i in 3..<x.count {\\n            if isOuter == false {\\n                if x[i] >= previous[(i - 2) % 4] { \\n                    return true \\n                }\\n                previous[i % 4] = x[i]\\n            } else {\\n                if x[i] > previous[(i - 2) % 4] {\\n                    previous[i % 4] = x[i]\\n                    continue \\n                } else {\\n                    isOuter = false\\n                  // should update the previous path length, because now, the route is inside the spiral \\n                    if previous[(i - 1) % 4] > previous[(i - 3) % 4] && ( x[i] >= previous[(i - 2) % 4] - previous[i % 4]\\n                                                                         && x[i] <= previous[(i - 2) % 4]) {\\n                        previous[(i - 1) % 4] -= previous[(i - 3) % 4]\\n                    }\\n                }\\n            }\\n            previous[i % 4] = x[i]\\n        }\\n        return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79132,
                "title": "python-solution",
                "content": "**Algorithm**\\nIf there are less than 4 elements, then there is no chance to cross, return False.\\nWe then compare the second and fourth edges (l1 and l3).\\n**If l1 < l3 (grow outwards)**\\nFor each edge i starting from index 0, if each x[i] < x[i+2], we keep adding i until n-2 is reached. However, if in the middle of it, we find x[i] >= x[i+2], we need to consider a special case where x[i+2] + x[i-2] >= x[i] and x[i+3] + x[i-1] >= x[i+1]. \\nIf this case does not happen, we simply start recursion from current i, which will address the case of first growing outwards, then growing inwards.\\n**If l1 > l3 (grow inwards)**\\nFor each edge i starting from index 1, if x[i] > x[i+2], we keep increase i until n-2 is reached. If anything else happens, we break. So if last i < n-2, we say there is crossing, otherwise, there is no crossing.\\n**If l1 == l3 (boundary case)**\\nThere are three cases.\\nIf x[i] >= x[i+2], then there is crossing.\\nIf x[i] < x[i+2], we need to increase i by 2, then consider:\\n1)\\ti+2 is greater than n-1; no crossing\\n2)\\tx[i+2] + x[i-2] >= x[i]; crossing\\n\\n**Code**\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(x)\\n        if n < 4:\\n            return False\\n        \\n        if x[1] < x[3]:\\n            i = 0\\n            while i < n-2:\\n                if x[i] < x[i+2]:\\n                    i += 1\\n                else:\\n                    if x[i+2] + x[i-2] >= x[i] and x[i+3] + x[i-1] >= x[i+1]:\\n                        break\\n                    return self.isSelfCrossing(x[i::])\\n        elif x[1] > x[3]:\\n            i = 1\\n            while i < n-2:\\n                if x[i] > x[i+2]:\\n                    i += 1\\n                else:\\n                    break\\n        else:\\n            i = 0\\n            while i < n-2:\\n                if x[i] >= x[i+2]:\\n                    break\\n                else:\\n                    i += 2\\n                    if i + 2 > n-1:\\n                        return False\\n                    if x[i+2] + x[i-2] >= x[i]:\\n                        break\\n        if i >= n-2:\\n            return False\\n        else:\\n            return True \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(x)\\n        if n < 4:\\n            return False\\n        \\n        if x[1] < x[3]:\\n            i = 0\\n            while i < n-2:\\n                if x[i] < x[i+2]:\\n                    i += 1\\n                else:\\n                    if x[i+2] + x[i-2] >= x[i] and x[i+3] + x[i-1] >= x[i+1]:\\n                        break\\n                    return self.isSelfCrossing(x[i::])\\n        elif x[1] > x[3]:\\n            i = 1\\n            while i < n-2:\\n                if x[i] > x[i+2]:\\n                    i += 1\\n                else:\\n                    break\\n        else:\\n            i = 0\\n            while i < n-2:\\n                if x[i] >= x[i+2]:\\n                    break\\n                else:\\n                    i += 2\\n                    if i + 2 > n-1:\\n                        return False\\n                    if x[i+2] + x[i-2] >= x[i]:\\n                        break\\n        if i >= n-2:\\n            return False\\n        else:\\n            return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 79138,
                "title": "a-slow-but-easy-to-understand-solution",
                "content": "follow the path and save the seen integral points. if seen again then it's self crossing.\\n\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        seen={(0,0)}\\n        a,b=0,0\\n        ds=[[0,1],[-1,0],[0,-1],[1,0]]\\n        for i in xrange(len(x)):\\n            da,db=ds[i%4]\\n            for _ in xrange(x[i]):\\n                a,b=a+da,b+db\\n                if (a,b) in seen:\\n                    return True\\n                seen.add((a,b))\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        seen={(0,0)}\\n        a,b=0,0\\n        ds=[[0,1],[-1,0],[0,-1],[1,0]]\\n        for i in xrange(len(x)):\\n            da,db=ds[i%4]\\n            for _ in xrange(x[i]):\\n                a,b=a+da,b+db\\n                if (a,b) in seen:\\n                    return True\\n                seen.add((a,b))\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79139,
                "title": "c-simple-solution",
                "content": "```\\nbool isSelfCrossing(int* x, int xSize)\\n{\\n    int i = 2, j = 0;\\n    \\n    while(i < xSize && x[i] > x[j])\\n    {\\n        i++;\\n        j++;\\n    }\\n    \\n    j = i + 1;\\n    \\n    if(j >= xSize) return false;\\n    \\n    if(x[i] < x[i - 2] - (i > 3 ? x[i - 4] : 0) ? x[j] < x[i - 1]\\n         : x[j] < x[i - 1] - (i > 2 ? x[i - 3] : 0))\\n    {\\n        j++;\\n        \\n        while(j < xSize && x[i] > x[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        \\n        return j < xSize;\\n    }\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSelfCrossing(int* x, int xSize)\\n{\\n    int i = 2, j = 0;\\n    \\n    while(i < xSize && x[i] > x[j])\\n    {\\n        i++;\\n        j++;\\n    }\\n    \\n    j = i + 1;\\n    \\n    if(j >= xSize) return false;\\n    \\n    if(x[i] < x[i - 2] - (i > 3 ? x[i - 4] : 0) ? x[j] < x[i - 1]\\n         : x[j] < x[i - 1] - (i > 2 ? x[i - 3] : 0))\\n    {\\n        j++;\\n        \\n        while(j < xSize && x[i] > x[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        \\n        return j < xSize;\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79143,
                "title": "ambiguous-definition-of-self-crossing",
                "content": "If case `[1,2,2,2,1]` is considered as self-crossing, why case `[2,0,3,0]` is not?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 79144,
                "title": "java-solution",
                "content": "```\\n\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length < 4) return false;\\n        boolean mode = x[2] > x[0];\\n        for (int i = 3; i < x.length; i++) {\\n            if (!mode && x[i] >= x[i - 2]) return true;\\n            else if (mode && x[i] <= x[i - 2]) {\\n                int l = (i >= 4) ? x[i - 4] : 0;\\n                if (x[i] + l >= x[i - 2])\\n                    x[i - 1] -= x[i - 3];\\n                mode = false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length < 4) return false;\\n        boolean mode = x[2] > x[0];\\n        for (int i = 3; i < x.length; i++) {\\n            if (!mode && x[i] >= x[i - 2]) return true;\\n            else if (mode && x[i] <= x[i - 2]) {\\n                int l = (i >= 4) ? x[i - 4] : 0;\\n                if (x[i] + l >= x[i - 2])\\n                    x[i - 1] -= x[i - 3];\\n                mode = false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79145,
                "title": "python-solution",
                "content": "Not the best solution, there are [better](https://discuss.leetcode.com/topic/38014/java-oms-with-explanation) :P \\n```\\nclass Solution(object):\\n    def isBetween(self, t, a, b):\\n        return (a <= t and t <= b) or (b <= t and t <= a)\\n        \\n    def isSelfCrossing(self, x):\\n        dir, d = [1,-1,-1,1], 0\\n        prev, prevDist = collections.deque([0 for i in range(3)]), 0\\n        for dist in x:\\n            coord = prev[1] + prevDist\\n            prevDist = dist*dir[d%4]\\n            prev.appendleft(coord)\\n            d += 1\\n            if len(prev) < 7:\\n                continue\\n            # Check for intersection\\n            if self.isBetween(coord, prev[2], prev[4]) and self.isBetween(prev[3], prev[1], prev[1]+prevDist):\\n                return True\\n            if self.isBetween(coord, prev[4], prev[6]) and self.isBetween(prev[5], prev[1], prev[1]+prevDist):\\n                return True\\n            prev.pop()\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isBetween(self, t, a, b):\\n        return (a <= t and t <= b) or (b <= t and t <= a)\\n        \\n    def isSelfCrossing(self, x):\\n        dir, d = [1,-1,-1,1], 0\\n        prev, prevDist = collections.deque([0 for i in range(3)]), 0\\n        for dist in x:\\n            coord = prev[1] + prevDist\\n            prevDist = dist*dir[d%4]\\n            prev.appendleft(coord)\\n            d += 1\\n            if len(prev) < 7:\\n                continue\\n            # Check for intersection\\n            if self.isBetween(coord, prev[2], prev[4]) and self.isBetween(prev[3], prev[1], prev[1]+prevDist):\\n                return True\\n            if self.isBetween(coord, prev[4], prev[6]) and self.isBetween(prev[5], prev[1], prev[1]+prevDist):\\n                return True\\n            prev.pop()\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79147,
                "title": "my-plain-java-solution-slow-but-very-easy-to-understand",
                "content": "```\\npublic boolean isSelfCrossing(int[] x) {\\n    \\t        List<int[]> all = new ArrayList<int[]> ();\\n    \\t        \\n    \\t        int[] prev = {0, 0};\\n    \\t        for (int i = 0; i < x.length; i++) {\\n    \\t        \\tint mod = i % 4;\\n    \\t        \\tint[] line = new int[4];\\n    \\t        \\tline[0] = prev[0];\\n    \\t        \\tline[1] = prev[1];\\n    \\t        \\tswitch( mod) {\\n    \\t        \\tcase 0:\\n    \\t        \\t\\tprev[1] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 1: \\n    \\t        \\t\\tprev[0] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 2:\\n    \\t        \\t\\tprev[1] += x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 3: \\n    \\t        \\t\\tprev[0] += x[i];\\n    \\t        \\t\\tbreak;    \\t        \\t\\n    \\t        \\t}\\n    \\t        \\t\\n    \\t        \\tline[2] = prev[0];\\n    \\t        \\tline[3] = prev[1];\\n    \\t        \\t\\n    \\t        \\tif (i > 2) {\\n    \\t        \\t\\tfor (int j = all.size() -3;  j >= 0; j -= 1) {\\n    \\t        \\t\\t\\tif (isCrossing(line, all.get(j))) return true;\\n    \\t        \\t\\t}\\n    \\t        \\t}\\n    \\t        \\tall.add(line);\\n    \\t        }\\n    \\t        \\n    \\t        return false;\\n    \\t    }\\n    \\t    \\n    \\t    boolean isCrossing(int[] line1, int[] line2) {\\n    \\t    \\tint[] v = (line1[0] == line1[2]) ? line1 : line2;\\n    \\t    \\tint[] h = (v == line1) ? line2 : line1;\\n    \\t    \\t\\n    \\t    \\treturn ((v[0] >= h[0] && v[0] <= h[2]) || (v[0] >= h[2] && v[0] <= h[0])) && ((h[1] >= v[1] && h[1] <= v[3]) || (h[1] >= v[3] && h[1] <= v[1]));\\n    \\t    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isSelfCrossing(int[] x) {\\n    \\t        List<int[]> all = new ArrayList<int[]> ();\\n    \\t        \\n    \\t        int[] prev = {0, 0};\\n    \\t        for (int i = 0; i < x.length; i++) {\\n    \\t        \\tint mod = i % 4;\\n    \\t        \\tint[] line = new int[4];\\n    \\t        \\tline[0] = prev[0];\\n    \\t        \\tline[1] = prev[1];\\n    \\t        \\tswitch( mod) {\\n    \\t        \\tcase 0:\\n    \\t        \\t\\tprev[1] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 1: \\n    \\t        \\t\\tprev[0] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 2:\\n    \\t        \\t\\tprev[1] += x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 3: \\n    \\t        \\t\\tprev[0] += x[i];\\n    \\t        \\t\\tbreak;    \\t        \\t\\n    \\t        \\t}\\n    \\t        \\t\\n    \\t        \\tline[2] = prev[0];\\n    \\t        \\tline[3] = prev[1];\\n    \\t        \\t\\n    \\t        \\tif (i > 2) {\\n    \\t        \\t\\tfor (int j = all.size() -3;  j >= 0; j -= 1) {\\n    \\t        \\t\\t\\tif (isCrossing(line, all.get(j))) return true;\\n    \\t        \\t\\t}\\n    \\t        \\t}\\n    \\t        \\tall.add(line);\\n    \\t        }\\n    \\t        \\n    \\t        return false;\\n    \\t    }\\n    \\t    \\n    \\t    boolean isCrossing(int[] line1, int[] line2) {\\n    \\t    \\tint[] v = (line1[0] == line1[2]) ? line1 : line2;\\n    \\t    \\tint[] h = (v == line1) ? line2 : line1;\\n    \\t    \\t\\n    \\t    \\treturn ((v[0] >= h[0] && v[0] <= h[2]) || (v[0] >= h[2] && v[0] <= h[0])) && ((h[1] >= v[1] && h[1] <= v[3]) || (h[1] >= v[3] && h[1] <= v[1]));\\n    \\t    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79148,
                "title": "javascript-closure-usage",
                "content": "Instead store every visited point, I store the line in closure:\\n\\n```js\\n\\nvar isSelfCrossing = function(x) {\\n    var cached = new Array(x.length);\\n    var diff_list = [[0, -1], [-1, 0], [0, 1], [1, 0]]\\n    \\n    function gen_func(start, end){\\n        var maxX = Math.max(start[0], end[0])\\n        var minX = Math.min(start[0], end[0])\\n        var maxY = Math.max(start[1], end[1])\\n        var minY = Math.min(start[1], end[1])\\n        return function(pos1, pos2){\\n            for(var x=Math.min(pos1[0], pos2[0]); x <=Math.max(pos1[0], pos2[0]); x++){\\n                for(var y=Math.min(pos1[1], pos2[1]); y<= Math.max(pos1[1], pos2[1]); y++ ){\\n                    if(x == pos1[0] && y == pos1[1]) {continue;}\\n                    if (x >= minX && x <= maxX && y >= minY &&  y <= maxY){\\n                        return true\\n                    }\\n                }\\n            }\\n            \\n            return false\\n        }\\n    }\\n    var start = [0, 0]\\n    for(var i=0; i<x.length; i++){\\n        var diff = diff_list[i%4];\\n        var end = [start[0]+x[i]*diff[0], start[1]+x[i]*diff[1]]\\n        for(var indexf=0;indexf<i; indexf++){\\n            if(cached[indexf](start, end)){\\n                return true\\n            }\\n        }\\n        cached[i] = gen_func(start,end)\\n        start = end\\n    }\\n    return false\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n\\nvar isSelfCrossing = function(x) {\\n    var cached = new Array(x.length);\\n    var diff_list = [[0, -1], [-1, 0], [0, 1], [1, 0]]\\n    \\n    function gen_func(start, end){\\n        var maxX = Math.max(start[0], end[0])\\n        var minX = Math.min(start[0], end[0])\\n        var maxY = Math.max(start[1], end[1])\\n        var minY = Math.min(start[1], end[1])\\n        return function(pos1, pos2){\\n            for(var x=Math.min(pos1[0], pos2[0]); x <=Math.max(pos1[0], pos2[0]); x++){\\n                for(var y=Math.min(pos1[1], pos2[1]); y<= Math.max(pos1[1], pos2[1]); y++ ){\\n                    if(x == pos1[0] && y == pos1[1]) {continue;}\\n                    if (x >= minX && x <= maxX && y >= minY &&  y <= maxY){\\n                        return true\\n                    }\\n                }\\n            }\\n            \\n            return false\\n        }\\n    }\\n    var start = [0, 0]\\n    for(var i=0; i<x.length; i++){\\n        var diff = diff_list[i%4];\\n        var end = [start[0]+x[i]*diff[0], start[1]+x[i]*diff[1]]\\n        for(var indexf=0;indexf<i; indexf++){\\n            if(cached[indexf](start, end)){\\n                return true\\n            }\\n        }\\n        cached[i] = gen_func(start,end)\\n        start = end\\n    }\\n    return false\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79149,
                "title": "longest-c-solution-0ms-with-test-case",
                "content": "```\\n#include <iostream>\\n#include <cstring>\\n#include <cstdint>\\n#include <limits>\\n#include <vector>\\n#include <algorithm>\\n\\n#ifdef RUN_TEST\\n#   define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file\\n#   include \"catch.hpp\"\\n#else\\n#   define NDEBUG   // remove assert() call\\n#endif\\n#include <cassert>\\n\\n\\n// https://leetcode.com/problems/self-crossing/\\n\\n\\nusing namespace std;\\n\\n\\nenum Direction {\\n    UP = 0,\\n    LEFT = 1,\\n    DOWN = 2,\\n    RIGHT = 3\\n};\\n\\nstruct Pos {\\n    int x = 0;\\n    int y = 0;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n        int xlen = x.size();\\n        int box[4];\\n        bool outter = true;\\n        Pos cur;\\n        Pos prev;\\n\\n        for (int i = 0; i < xlen ; i++) {\\n            int dir = i % 4;\\n\\n            prev = cur;\\n            if (dir == UP) {\\n                cur.y += x[i];\\n            } else if (dir == LEFT) {\\n                cur.x -= x[i];\\n            } else if (dir == DOWN) {\\n                cur.y -= x[i];\\n            } else {    // dir == RIGHT\\n                cur.x += x[i];\\n            }\\n\\n            if (i == 0) {\\n                ;\\n            } else if (i == 1) {\\n                ;\\n            } else if (i == 2) {\\n                if (cur.y >= 0) {\\n                    // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                    // \\u2502   \\u2502\\n                    //     \\u2502\\n                    outter = false;\\n                }\\n            } else if (i == 3) {\\n                if (outter) {\\n                    if (cur.x > 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = 0;\\n                        box[DOWN] = 0;\\n                        box[UP] = x[0];\\n                    } else if (cur.x == 0) {\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = 0;\\n                    } else {    // cur.x < 0\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                } else {    // inner\\n                    if (cur.x >= 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2502\\u2500\\n                        //     \\u2502\\n                        return true;\\n                    } else {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500  \\u2502\\n                        //     \\u2502\\n                        box[RIGHT] = cur.x;\\n                        box[LEFT] = prev.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                }\\n            } else {\\n                if (outter) {\\n                    if (dir == UP) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502 \\u2551\\n                        // \\u2502     \\u2551\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u255c\\n                        if (cur.y > box[UP]) {\\n                            box[DOWN] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y >= box[DOWN]) {\\n                                box[LEFT] = box[RIGHT];\\n                            }\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                            box[DOWN] = prev.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x < box[LEFT]) {\\n                            box[RIGHT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x <= box[RIGHT]) {\\n                                box[DOWN] = box[UP];\\n                            }\\n                            box[LEFT] = cur.x;\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = prev.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y < box[DOWN]) {\\n                            box[UP] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y <= box[UP]) {\\n                                box[RIGHT] = box[LEFT];\\n                            }\\n                            box[DOWN] = cur.y;\\n                            box[LEFT] = cur.x;\\n                            box[UP] = prev.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x > box[RIGHT]) {\\n                            box[LEFT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x >= box[LEFT]) {\\n                                box[UP] = box[DOWN];\\n                            }\\n                            box[LEFT] = prev.x;\\n                            box[DOWN] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                } else {    // inner\\n                    if (dir == UP) {\\n                        if (cur.y >= box[UP]) {\\n                            return true;\\n                        } else {\\n                            box[UP] = cur.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x <= box[LEFT]) {\\n                            return true;\\n                        } else {\\n                            box[LEFT] = cur.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y <= box[DOWN]) {\\n                            return true;\\n                        } else {\\n                            box[DOWN] = cur.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x >= box[RIGHT]) {\\n                            return true;\\n                        } else {\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n#ifdef RUN_TEST\\nTEST_CASE(\"335. Self Crossing\") {\\n    Solution s;\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 1, 1 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 2, 3, 4, 5 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 1, 1 }) == true);\\n\\n    CHECK(s.isSelfCrossing({}) == false);\\n    CHECK(s.isSelfCrossing({ 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 2 }) == true);\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 2 }) == false);\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 3 }) == true);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 4, 3, 3, 2, 2, 1, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 7, 5 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 7, 6 }) == true);\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <iostream>\\n#include <cstring>\\n#include <cstdint>\\n#include <limits>\\n#include <vector>\\n#include <algorithm>\\n\\n#ifdef RUN_TEST\\n#   define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file\\n#   include \"catch.hpp\"\\n#else\\n#   define NDEBUG   // remove assert() call\\n#endif\\n#include <cassert>\\n\\n\\n// https://leetcode.com/problems/self-crossing/\\n\\n\\nusing namespace std;\\n\\n\\nenum Direction {\\n    UP = 0,\\n    LEFT = 1,\\n    DOWN = 2,\\n    RIGHT = 3\\n};\\n\\nstruct Pos {\\n    int x = 0;\\n    int y = 0;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n        int xlen = x.size();\\n        int box[4];\\n        bool outter = true;\\n        Pos cur;\\n        Pos prev;\\n\\n        for (int i = 0; i < xlen ; i++) {\\n            int dir = i % 4;\\n\\n            prev = cur;\\n            if (dir == UP) {\\n                cur.y += x[i];\\n            } else if (dir == LEFT) {\\n                cur.x -= x[i];\\n            } else if (dir == DOWN) {\\n                cur.y -= x[i];\\n            } else {    // dir == RIGHT\\n                cur.x += x[i];\\n            }\\n\\n            if (i == 0) {\\n                ;\\n            } else if (i == 1) {\\n                ;\\n            } else if (i == 2) {\\n                if (cur.y >= 0) {\\n                    // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                    // \\u2502   \\u2502\\n                    //     \\u2502\\n                    outter = false;\\n                }\\n            } else if (i == 3) {\\n                if (outter) {\\n                    if (cur.x > 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = 0;\\n                        box[DOWN] = 0;\\n                        box[UP] = x[0];\\n                    } else if (cur.x == 0) {\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = 0;\\n                    } else {    // cur.x < 0\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                } else {    // inner\\n                    if (cur.x >= 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2502\\u2500\\n                        //     \\u2502\\n                        return true;\\n                    } else {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500  \\u2502\\n                        //     \\u2502\\n                        box[RIGHT] = cur.x;\\n                        box[LEFT] = prev.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                }\\n            } else {\\n                if (outter) {\\n                    if (dir == UP) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502 \\u2551\\n                        // \\u2502     \\u2551\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u255c\\n                        if (cur.y > box[UP]) {\\n                            box[DOWN] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y >= box[DOWN]) {\\n                                box[LEFT] = box[RIGHT];\\n                            }\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                            box[DOWN] = prev.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x < box[LEFT]) {\\n                            box[RIGHT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x <= box[RIGHT]) {\\n                                box[DOWN] = box[UP];\\n                            }\\n                            box[LEFT] = cur.x;\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = prev.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y < box[DOWN]) {\\n                            box[UP] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y <= box[UP]) {\\n                                box[RIGHT] = box[LEFT];\\n                            }\\n                            box[DOWN] = cur.y;\\n                            box[LEFT] = cur.x;\\n                            box[UP] = prev.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x > box[RIGHT]) {\\n                            box[LEFT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x >= box[LEFT]) {\\n                                box[UP] = box[DOWN];\\n                            }\\n                            box[LEFT] = prev.x;\\n                            box[DOWN] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                } else {    // inner\\n                    if (dir == UP) {\\n                        if (cur.y >= box[UP]) {\\n                            return true;\\n                        } else {\\n                            box[UP] = cur.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x <= box[LEFT]) {\\n                            return true;\\n                        } else {\\n                            box[LEFT] = cur.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y <= box[DOWN]) {\\n                            return true;\\n                        } else {\\n                            box[DOWN] = cur.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x >= box[RIGHT]) {\\n                            return true;\\n                        } else {\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n#ifdef RUN_TEST\\nTEST_CASE(\"335. Self Crossing\") {\\n    Solution s;\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 1, 1 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 2, 3, 4, 5 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 1, 1 }) == true);\\n\\n    CHECK(s.isSelfCrossing({}) == false);\\n    CHECK(s.isSelfCrossing({ 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 2 }) == true);\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 2 }) == false);\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 3 }) == true);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 4, 3, 3, 2, 2, 1, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 7, 5 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 7, 6 }) == true);\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 79150,
                "title": "simple-c-0ms-soln-w-explanation",
                "content": "````\\n// There can be an inward spiral OR an outward spiral which may or may not be followed by an inward spiral\\n// So the sequence with either be all decreasing OR increasing and then decreasing (only one hill)\\n            \\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() <= 3) return false;\\n        int i=2;\\n        \\n        // Check if it starts in desending order\\n        if (x[2] < x[0]){\\n            // Confirm rest all are in decending order as well\\n            for(i=3; i < x.size(); i++){\\n                if (x[i] >= x[i-2]) return true;\\n            }\\n            // If not then there is a overlap\\n            return false;\\n        }\\n        \\n        // Look for the place/hill (if any) where it becomes non-asending\\n        while(++i < x.size()) if (x[i] <= x[i-2]) break;\\n        \\n        // If not found, then there is no overlap\\n        if (i >= x.size()) return false;\\n\\n\\n        // Else make sure the following two conditions are not met, at that point\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |  ------------>|\\n        // |     ^\\n        // |     |\\n        // v---->|\\n        if (i-4 >= 0 && (x[i-4] + x[i] >= x[i-2]) && (x[i+1] >= x[i-1] - x[i-3])) return true;\\n\\n\\n\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               \\n        // |     \\n        // v--------------->\\n        if (i-3 == 0 && x[i] == x[i-2] && (x[i-1] == x[i-3] || (i+1 < x.size() && x[i+1] + x[i-3] >= x[i-1]))) return true;\\n        \\n        // Confirm rest are in decending order, another hill => overlap\\n        while(++i < x.size()) if (x[i] >= x[i-2]) return true;\\n        return false;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\n// There can be an inward spiral OR an outward spiral which may or may not be followed by an inward spiral\\n// So the sequence with either be all decreasing OR increasing and then decreasing (only one hill)\\n            \\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() <= 3) return false;\\n        int i=2;\\n        \\n        // Check if it starts in desending order\\n        if (x[2] < x[0]){\\n            // Confirm rest all are in decending order as well\\n            for(i=3; i < x.size(); i++){\\n                if (x[i] >= x[i-2]) return true;\\n            }\\n            // If not then there is a overlap\\n            return false;\\n        }\\n        \\n        // Look for the place/hill (if any) where it becomes non-asending\\n        while(++i < x.size()) if (x[i] <= x[i-2]) break;\\n        \\n        // If not found, then there is no overlap\\n        if (i >= x.size()) return false;\\n\\n\\n        // Else make sure the following two conditions are not met, at that point\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |  ------------>|\\n        // |     ^\\n        // |     |\\n        // v---->|\\n        if (i-4 >= 0 && (x[i-4] + x[i] >= x[i-2]) && (x[i+1] >= x[i-1] - x[i-3])) return true;\\n\\n\\n\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               \\n        // |     \\n        // v--------------->\\n        if (i-3 == 0 && x[i] == x[i-2] && (x[i-1] == x[i-3] || (i+1 < x.size() && x[i+1] + x[i-3] >= x[i-1]))) return true;\\n        \\n        // Confirm rest are in decending order, another hill => overlap\\n        while(++i < x.size()) if (x[i] >= x[i-2]) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79153,
                "title": "c-code-0ms-one-pass-algorithm-with-o-1-extra-space",
                "content": "thx for @district10 \\n```\\nthere is only 3 cases of self crossing\\n//  1) 4 lines\\n//         #       \\n//       <---[2]----+        [2]: second failure\\n//         |        |\\n//         |       [1]       [1]: first  failure\\n//         |        |\\n//         +--------+\\n//  2) 5 lines;\\n//         +-------+\\n//         |       |\\n//         |       #\\n//         |\\n//         |       ^\\n//         |       |\\n//         +-------+\\n//  2) 6 lines\\n//      +----+\\n//      |    |\\n//      |  <----[2]----^     [2]: second failure\\n//      |    #         |\\n//      |             [1]    [1]: first  failure\\n//      |              |\\n//      +--------------+\\n\\nbool isSelfCrossing(int* x, int xSize) {\\n    for (int i=3; i<xSize; ++i) {\\n        if (/*(i>=3) && */(x[i]>=x[i-2]) && (x[i-1]<=x[i-3])) return true;   // 4 lines\\n        else if ((i>=4) && (x[i-1]==x[i-3]) && ((x[i]+x[i-4])>=x[i-2])) return true; // 5 lines\\n        else if ((i>=5) && (x[i-2]>x[i-4]) && (x[i-3]>x[i-5]) && (x[i]+x[i-4]>=x[i-2]) && (x[i-1]<=x[i-3])&&(x[i-1]+x[i-5]>=x[i-3])) return true;  // 6 lines\\n    }\\n    return false;\\n}```",
                "solutionTags": [],
                "code": "```\\nthere is only 3 cases of self crossing\\n//  1) 4 lines\\n//         #       \\n//       <---[2]----+        [2]: second failure\\n//         |        |\\n//         |       [1]       [1]: first  failure\\n//         |        |\\n//         +--------+\\n//  2) 5 lines;\\n//         +-------+\\n//         |       |\\n//         |       #\\n//         |\\n//         |       ^\\n//         |       |\\n//         +-------+\\n//  2) 6 lines\\n//      +----+\\n//      |    |\\n//      |  <----[2]----^     [2]: second failure\\n//      |    #         |\\n//      |             [1]    [1]: first  failure\\n//      |              |\\n//      +--------------+\\n\\nbool isSelfCrossing(int* x, int xSize) {\\n    for (int i=3; i<xSize; ++i) {\\n        if (/*(i>=3) && */(x[i]>=x[i-2]) && (x[i-1]<=x[i-3])) return true;   // 4 lines\\n        else if ((i>=4) && (x[i-1]==x[i-3]) && ((x[i]+x[i-4])>=x[i-2])) return true; // 5 lines\\n        else if ((i>=5) && (x[i-2]>x[i-4]) && (x[i-3]>x[i-5]) && (x[i]+x[i-4]>=x[i-2]) && (x[i-1]<=x[i-3])&&(x[i-1]+x[i-5]>=x[i-3])) return true;  // 6 lines\\n    }\\n    return false;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 79154,
                "title": "straight-forward-dumb-simulation-solution-0ms-o-1-space",
                "content": "Test cases are too small, so I did a pure simulation implementation and still got 0 ms result. Not as brilliant as the pattern finding solution but still it works.\\n\\nLet's consider each movement, since the movements always happen in counter-clockwise sequence, so we can only look at one direction and apply accordingly to other directions.\\n\\nIf we want to move upwards (NORTH), we will be able to cross either the previous \"SOUTH\" line drawn by the last eastward movement or the previous \"NORTH\" border line drawn by the last westward movement. All we need to do is to determine the potential crossing line before each move. In order words, we can expand the following pseudo code into the final solution.\\n\\nfor x in X[1 .. n]\\n  move point\\n  if point hit potential line: return true\\n  update potential line for the next move\\n\\nImplementation in C++ (quite long):\\n\\n```\\nenum dir_t\\n{\\n    NORTH = 0,\\n    WEST = 1,\\n    SOUTH = 2,\\n    EAST = 3\\n};\\n\\ndir_t next_dir(dir_t d)\\n{\\n    switch(d)\\n    {\\n        case NORTH: return WEST;\\n        case WEST : return SOUTH;\\n        case SOUTH: return EAST;\\n        case EAST : return NORTH;\\n    }\\n    \\n    return NORTH;\\n}\\n\\nstruct point_t\\n{\\n    int x;\\n    int y;\\n    \\n    point_t() : x(0), y(0) {}\\n    point_t(int a, int b) : x(a), y(b) {}\\n    \\n    bool operator <= (const point_t& p) const\\n    {\\n        return this->x < p.x || (this->x == p.x && this->y <= p.y);\\n    }\\n    \\n};\\n\\nostream& operator << (ostream& os, const point_t& p)\\n{\\n    return os << \"[\" << p.x << \",\" << p.y << \"]\";\\n}\\n\\ntypedef pair<point_t, point_t> line_t;\\n\\nostream& operator << (ostream& os, const line_t& l)\\n{\\n    if(l.first <= l.second)\\n        return os << \"{\" << l.first << \",\" << l.second << \"}\";\\n    else\\n        return os << \"{INV}\";\\n}\\n\\nbool is_line_valid(line_t& l)\\n{\\n    return l.first <= l.second;\\n}\\n\\nvoid make_line_invalid(line_t& l)\\n{\\n    l.first.x = 0; l.first.y = 0;\\n    l.second.x = -1; l.second.y = -1;\\n}\\n\\ntypedef vector<line_t> border_t;\\n\\npoint_t move_point(point_t& s, dir_t d, int l)\\n{\\n    point_t p(s);\\n    switch(d)\\n    {\\n        case NORTH: p.y += l; return p;\\n        case WEST : p.x -= l; return p;\\n        case SOUTH: p.y -= l; return p;\\n        case EAST : p.x += l; return p;\\n    }\\n    \\n    return p;\\n}\\n\\nbool can_hit(point_t& e, dir_t d, border_t& border)\\n{\\n    if(is_line_valid(border[d]))\\n    {\\n        switch(d)\\n        {\\n            case NORTH: return e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x && e.y >= border[NORTH].first.y;\\n            case WEST : return e.y >= border[WEST ].first.y && e.y <= border[WEST ].second.y && e.x <= border[WEST ].first.x;\\n            case SOUTH: return e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x && e.y <= border[SOUTH].first.y;\\n            case EAST : return e.y >= border[EAST ].first.y && e.y <= border[EAST ].second.y && e.x >= border[EAST ].first.x;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\nvoid update_border(point_t& s, point_t& e, dir_t d, border_t& border)\\n{\\n    dir_t nd = next_dir(d);\\n    \\n    switch(nd)\\n    {\\n        case NORTH:\\n        {\\n            if(is_line_valid(border[SOUTH]) && e.y < border[SOUTH].first.y)\\n            {\\n                if(e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x)\\n                    border[NORTH] = border[SOUTH];\\n            }\\n            \\n            border[SOUTH].first = s;\\n            border[SOUTH].second = e;\\n            break;\\n        }\\n        case WEST:\\n        {\\n            if(is_line_valid(border[EAST]) && e.x > border[EAST].first.x)\\n            {\\n                if(e.y >= border[EAST].first.y && e.y <= border[EAST].second.y)\\n                    border[WEST] = border[EAST];\\n            }\\n            \\n            border[EAST].first = s;\\n            border[EAST].second = e;\\n            break;\\n        }\\n        case SOUTH:\\n        {\\n            if(is_line_valid(border[NORTH]) && e.y > border[NORTH].first.y)\\n            {\\n                if(e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x)\\n                    border[SOUTH] = border[NORTH];\\n            }\\n            \\n            border[NORTH].first = e;\\n            border[NORTH].second = s;\\n            break;\\n        }\\n        case EAST:\\n        {\\n            if(is_line_valid(border[WEST]) && e.x < border[WEST].first.x)\\n            {\\n                if(e.y >= border[WEST].first.y && e.y <= border[WEST].second.y)\\n                    border[EAST] = border[WEST];\\n            }\\n            \\n            border[WEST].first = e;\\n            border[WEST].second = s;\\n            break;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int i, N = x.size();\\n        \\n        dir_t d = NORTH;\\n        point_t s(0,0);\\n        border_t border(4);\\n        \\n        for(i = 0; i < 4; ++i) make_line_invalid(border[i]);\\n        \\n        border[SOUTH].first = s;\\n        border[SOUTH].second = s;\\n        \\n        for(i = 0; i < N; ++i)\\n        {\\n            point_t e = move_point(s, d, x[i]);\\n            \\n            if(can_hit(e, d, border)) return true;\\n            \\n            update_border(s, e, d, border);\\n            \\n            // cout << \"e: \" << e << endl;\\n            \\n            // cout << \"N: \" << border[NORTH] << endl;\\n            // cout << \"W: \" << border[WEST ] << endl;\\n            // cout << \"S: \" << border[SOUTH] << endl;\\n            // cout << \"E: \" << border[EAST ] << endl;\\n            // cout << endl;\\n            \\n            s = e;\\n            d = next_dir(d);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nenum dir_t\\n{\\n    NORTH = 0,\\n    WEST = 1,\\n    SOUTH = 2,\\n    EAST = 3\\n};\\n\\ndir_t next_dir(dir_t d)\\n{\\n    switch(d)\\n    {\\n        case NORTH: return WEST;\\n        case WEST : return SOUTH;\\n        case SOUTH: return EAST;\\n        case EAST : return NORTH;\\n    }\\n    \\n    return NORTH;\\n}\\n\\nstruct point_t\\n{\\n    int x;\\n    int y;\\n    \\n    point_t() : x(0), y(0) {}\\n    point_t(int a, int b) : x(a), y(b) {}\\n    \\n    bool operator <= (const point_t& p) const\\n    {\\n        return this->x < p.x || (this->x == p.x && this->y <= p.y);\\n    }\\n    \\n};\\n\\nostream& operator << (ostream& os, const point_t& p)\\n{\\n    return os << \"[\" << p.x << \",\" << p.y << \"]\";\\n}\\n\\ntypedef pair<point_t, point_t> line_t;\\n\\nostream& operator << (ostream& os, const line_t& l)\\n{\\n    if(l.first <= l.second)\\n        return os << \"{\" << l.first << \",\" << l.second << \"}\";\\n    else\\n        return os << \"{INV}\";\\n}\\n\\nbool is_line_valid(line_t& l)\\n{\\n    return l.first <= l.second;\\n}\\n\\nvoid make_line_invalid(line_t& l)\\n{\\n    l.first.x = 0; l.first.y = 0;\\n    l.second.x = -1; l.second.y = -1;\\n}\\n\\ntypedef vector<line_t> border_t;\\n\\npoint_t move_point(point_t& s, dir_t d, int l)\\n{\\n    point_t p(s);\\n    switch(d)\\n    {\\n        case NORTH: p.y += l; return p;\\n        case WEST : p.x -= l; return p;\\n        case SOUTH: p.y -= l; return p;\\n        case EAST : p.x += l; return p;\\n    }\\n    \\n    return p;\\n}\\n\\nbool can_hit(point_t& e, dir_t d, border_t& border)\\n{\\n    if(is_line_valid(border[d]))\\n    {\\n        switch(d)\\n        {\\n            case NORTH: return e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x && e.y >= border[NORTH].first.y;\\n            case WEST : return e.y >= border[WEST ].first.y && e.y <= border[WEST ].second.y && e.x <= border[WEST ].first.x;\\n            case SOUTH: return e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x && e.y <= border[SOUTH].first.y;\\n            case EAST : return e.y >= border[EAST ].first.y && e.y <= border[EAST ].second.y && e.x >= border[EAST ].first.x;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\nvoid update_border(point_t& s, point_t& e, dir_t d, border_t& border)\\n{\\n    dir_t nd = next_dir(d);\\n    \\n    switch(nd)\\n    {\\n        case NORTH:\\n        {\\n            if(is_line_valid(border[SOUTH]) && e.y < border[SOUTH].first.y)\\n            {\\n                if(e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x)\\n                    border[NORTH] = border[SOUTH];\\n            }\\n            \\n            border[SOUTH].first = s;\\n            border[SOUTH].second = e;\\n            break;\\n        }\\n        case WEST:\\n        {\\n            if(is_line_valid(border[EAST]) && e.x > border[EAST].first.x)\\n            {\\n                if(e.y >= border[EAST].first.y && e.y <= border[EAST].second.y)\\n                    border[WEST] = border[EAST];\\n            }\\n            \\n            border[EAST].first = s;\\n            border[EAST].second = e;\\n            break;\\n        }\\n        case SOUTH:\\n        {\\n            if(is_line_valid(border[NORTH]) && e.y > border[NORTH].first.y)\\n            {\\n                if(e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x)\\n                    border[SOUTH] = border[NORTH];\\n            }\\n            \\n            border[NORTH].first = e;\\n            border[NORTH].second = s;\\n            break;\\n        }\\n        case EAST:\\n        {\\n            if(is_line_valid(border[WEST]) && e.x < border[WEST].first.x)\\n            {\\n                if(e.y >= border[WEST].first.y && e.y <= border[WEST].second.y)\\n                    border[EAST] = border[WEST];\\n            }\\n            \\n            border[WEST].first = e;\\n            border[WEST].second = s;\\n            break;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int i, N = x.size();\\n        \\n        dir_t d = NORTH;\\n        point_t s(0,0);\\n        border_t border(4);\\n        \\n        for(i = 0; i < 4; ++i) make_line_invalid(border[i]);\\n        \\n        border[SOUTH].first = s;\\n        border[SOUTH].second = s;\\n        \\n        for(i = 0; i < N; ++i)\\n        {\\n            point_t e = move_point(s, d, x[i]);\\n            \\n            if(can_hit(e, d, border)) return true;\\n            \\n            update_border(s, e, d, border);\\n            \\n            // cout << \"e: \" << e << endl;\\n            \\n            // cout << \"N: \" << border[NORTH] << endl;\\n            // cout << \"W: \" << border[WEST ] << endl;\\n            // cout << \"S: \" << border[SOUTH] << endl;\\n            // cout << \"E: \" << border[EAST ] << endl;\\n            // cout << endl;\\n            \\n            s = e;\\n            d = next_dir(d);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 79151,
                "title": "java-solution-easy-2d-euclidean-map-solution",
                "content": "The idea is to use a Hashset of 2d Point (x,y) and insert each traversed point into the Set, once an already traversed point is reached, return true (cycle), otherwise return false.\\n\\npublic class SelfCrossing {\\n\\n\\t\\n\\t public static boolean isSelfCrossing(int[] x) {\\n\\t\\t if (x == null || x.length < 4) {\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t        \\n\\t\\t int direction = 1; // start North\\n\\t\\t int moves = 0;\\n\\t\\t int cX = 0;\\n\\t\\t int cY = 0;\\n\\t\\t Set<Point2D> pointSets = new HashSet<>();\\n\\t\\t pointSets.add(new Point2D(0,0)); // origin\\n\\t\\t Point2D p = null;\\n\\n\\t\\t for (int i = 0; i < x.length; i++) {\\n\\t\\t\\tmoves = x[i];\\n\\t\\t\\twhile (moves > 0) {\\n\\t\\t\\t\\tif (direction == 1) {\\n\\t\\t\\t\\t\\tcY++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 2) {\\n\\t\\t\\t\\t\\tcX--;\\n\\t\\t\\t\\t}\\t\\t\\n\\t\\t\\t\\telse if (direction == 3) {\\n\\t\\t\\t\\t\\tcY--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 4) {\\n\\t\\t\\t\\t\\tcX++;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tp = new Point2D(cX, cY);\\n\\t\\t\\t\\tif (pointSets.contains(p)) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpointSets.add(p);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t\\tmoves--;\\n\\t\\t\\t}\\n\\t\\t\\tif (direction == 4) {\\n\\t\\t\\t\\tdirection = 0;\\n\\t\\t\\t}\\t\\n\\t\\t\\tdirection++;\\n\\t\\t }\\t \\t   \\n\\t\\t return false;\\n\\t }\\n}\\n\\nclass Point2D {\\n\\tint x;\\n\\tint y;\\n\\tpublic Point2D(int x, int y) {\\n\\t\\tsuper();\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n\\t@Override\\n\\tpublic int hashCode() {\\n\\t\\tfinal int prime = 31;\\n\\t\\tint result = 1;\\n\\t\\tresult = prime * result + x;\\n\\t\\tresult = prime * result + y;\\n\\t\\treturn result;\\n\\t}\\n\\t@Override\\n\\tpublic boolean equals(Object obj) {\\n\\t\\tif (this == obj)\\n\\t\\t\\treturn true;\\n\\t\\tif (obj == null)\\n\\t\\t\\treturn false;\\n\\t\\tif (getClass() != obj.getClass())\\n\\t\\t\\treturn false;\\n\\t\\tPoint2D other = (Point2D) obj;\\n\\t\\tif (x != other.x)\\n\\t\\t\\treturn false;\\n\\t\\tif (y != other.y)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "The idea is to use a Hashset of 2d Point (x,y) and insert each traversed point into the Set, once an already traversed point is reached, return true (cycle), otherwise return false.\\n\\npublic class SelfCrossing {\\n\\n\\t\\n\\t public static boolean isSelfCrossing(int[] x) {\\n\\t\\t if (x == null || x.length < 4) {\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t        \\n\\t\\t int direction = 1; // start North\\n\\t\\t int moves = 0;\\n\\t\\t int cX = 0;\\n\\t\\t int cY = 0;\\n\\t\\t Set<Point2D> pointSets = new HashSet<>();\\n\\t\\t pointSets.add(new Point2D(0,0)); // origin\\n\\t\\t Point2D p = null;\\n\\n\\t\\t for (int i = 0; i < x.length; i++) {\\n\\t\\t\\tmoves = x[i];\\n\\t\\t\\twhile (moves > 0) {\\n\\t\\t\\t\\tif (direction == 1) {\\n\\t\\t\\t\\t\\tcY++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 2) {\\n\\t\\t\\t\\t\\tcX--;\\n\\t\\t\\t\\t}\\t\\t\\n\\t\\t\\t\\telse if (direction == 3) {\\n\\t\\t\\t\\t\\tcY--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 4) {\\n\\t\\t\\t\\t\\tcX++;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tp = new Point2D(cX, cY);\\n\\t\\t\\t\\tif (pointSets.contains(p)) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpointSets.add(p);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t\\tmoves--;\\n\\t\\t\\t}\\n\\t\\t\\tif (direction == 4) {\\n\\t\\t\\t\\tdirection = 0;\\n\\t\\t\\t}\\t\\n\\t\\t\\tdirection++;\\n\\t\\t }\\t \\t   \\n\\t\\t return false;\\n\\t }\\n}\\n\\nclass Point2D {\\n\\tint x;\\n\\tint y;\\n\\tpublic Point2D(int x, int y) {\\n\\t\\tsuper();\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n\\t@Override\\n\\tpublic int hashCode() {\\n\\t\\tfinal int prime = 31;\\n\\t\\tint result = 1;\\n\\t\\tresult = prime * result + x;\\n\\t\\tresult = prime * result + y;\\n\\t\\treturn result;\\n\\t}\\n\\t@Override\\n\\tpublic boolean equals(Object obj) {\\n\\t\\tif (this == obj)\\n\\t\\t\\treturn true;\\n\\t\\tif (obj == null)\\n\\t\\t\\treturn false;\\n\\t\\tif (getClass() != obj.getClass())\\n\\t\\t\\treturn false;\\n\\t\\tPoint2D other = (Point2D) obj;\\n\\t\\tif (x != other.x)\\n\\t\\t\\treturn false;\\n\\t\\tif (y != other.y)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 79155,
                "title": "java-solution-long-and-easy-to-understand",
                "content": "Identify two possible modes: 1. Area is expanding, and 2. Area is shrinking. We need to identify the current mode.\\n\\nFor shrinking mode, let current index be i, then if x[i] < x[i-2], x[i] is safe. \\nFor expanding mode, it is more complicated. For index i, there are 3 possible situations:\\n\\u3000\\u3000\\u3000\\u30001. x[i] > x[i-2]: still expanding mode, safe\\n\\u3000\\u3000\\u3000\\u30002. x[i] < x[i-2] - x[i-4]: switch to shrink mode, but safe\\n\\u3000\\u3000\\u3000\\u30003. x[i] >= x[i-2] - x[i-4]: switch to shrink mode, but possibly not safe, we need further determine, see the code and draw a figure.\\n\\n```public class Solution {\\n    public boolean isSelfCrossingExpand(int[] x, int start){\\n        for (int i=start;i<x.length;i++){\\n            if (x[i] > x[i-2]){\\n                continue;\\n            } else {\\n                // becomes shrink mode\\n                int bar = (i>=4) ? x[i-4] : 0;                 // handle corner case here.\\n                if (x[i] <= x[i-2] && x[i] >= (x[i-2] - bar)){\\n                    if ( i+1 == x.length){\\n                        return false;\\n                    }\\n                    if (x[i+1] >= (x[i-1] - x[i-3])){\\n                        return true;\\n                    }\\n                    return isSelfCrossingShrink(x,i+2);\\n                } else {\\n                    return isSelfCrossingShrink(x,i+1);\\n                }\\n            }        \\n        }\\n        return false;\\n    }\\n\\n    public boolean isSelfCrossingShrink(int[] x, int start){\\n        for (int i=start; i<x.length;i++){\\n            if (x[i] >= x[i-2])\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length<=3) return false;\\n\\n        if (x[2] <= x[0]) return isSelfCrossingShrink(x,3);        \\n        return isSelfCrossingExpand(x,3);\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSelfCrossingExpand(int[] x, int start){\\n        for (int i=start;i<x.length;i++){\\n            if (x[i] > x[i-2]){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79156,
                "title": "simple-recursion-java",
                "content": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x == null || x.length <= 3) {\\n            return false;\\n        }\\n        return _first(x, 0);\\n    }\\n    \\n    private boolean _first(int[] x, int index) {\\n        return index >= x.length - 3 ? false : _second(x, index + 1, x[index]);\\n    }\\n    \\n    private boolean _second(int[] x, int index, int first) {\\n        return index >= x.length - 2 ? false : _third(x, index + 1, first, x[index]);\\n    }\\n    \\n    private boolean _third(int[] x, int index, int first, int second) {\\n        if (index >= x.length - 1) {\\n            return false;\\n        }\\n        if (x[index] <= first) {\\n            return _decrease(x, index + 1, second, x[index]);\\n        } else {\\n            return _fourth(x, index + 1, first, second, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fourth(int[] x, int index, int first, int second, int third) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < second) {\\n            return _decrease(x, index + 1, third, x[index]);\\n        } else if (x[index] == second) {\\n            return _decrease(x, index + 1, third - first, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, first, second, third, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fifth(int[] x, int index, int first, int second, int third, int fourth) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < third - first) {\\n            return _decrease(x, index + 1, fourth, x[index]);\\n        } else if (x[index] <= third) {\\n            return _decrease(x, index + 1, fourth - second, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, second, third, fourth, x[index]);\\n        }\\n    }\\n    \\n    private boolean _decrease(int[] x, int index, int prevprev, int prev) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] >= prevprev) {\\n            return true;\\n        }\\n        return _decrease(x, index + 1, prev, x[index]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x == null || x.length <= 3) {\\n            return false;\\n        }\\n        return _first(x, 0);\\n    }\\n    \\n    private boolean _first(int[] x, int index) {\\n        return index >= x.length - 3 ? false : _second(x, index + 1, x[index]);\\n    }\\n    \\n    private boolean _second(int[] x, int index, int first) {\\n        return index >= x.length - 2 ? false : _third(x, index + 1, first, x[index]);\\n    }\\n    \\n    private boolean _third(int[] x, int index, int first, int second) {\\n        if (index >= x.length - 1) {\\n            return false;\\n        }\\n        if (x[index] <= first) {\\n            return _decrease(x, index + 1, second, x[index]);\\n        } else {\\n            return _fourth(x, index + 1, first, second, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fourth(int[] x, int index, int first, int second, int third) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < second) {\\n            return _decrease(x, index + 1, third, x[index]);\\n        } else if (x[index] == second) {\\n            return _decrease(x, index + 1, third - first, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, first, second, third, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fifth(int[] x, int index, int first, int second, int third, int fourth) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < third - first) {\\n            return _decrease(x, index + 1, fourth, x[index]);\\n        } else if (x[index] <= third) {\\n            return _decrease(x, index + 1, fourth - second, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, second, third, fourth, x[index]);\\n        }\\n    }\\n    \\n    private boolean _decrease(int[] x, int index, int prevprev, int prev) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] >= prevprev) {\\n            return true;\\n        }\\n        return _decrease(x, index + 1, prev, x[index]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1841091,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1776395,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571599,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571601,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2048068,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2033583,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1876347,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759615,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest Plus Sign",
        "question_content": "<p>You are given an integer <code>n</code>. You have an <code>n x n</code> binary grid <code>grid</code> with all values initially <code>1</code>&#39;s except for some indices given in the array <code>mines</code>. The <code>i<sup>th</sup></code> element of the array <code>mines</code> is defined as <code>mines[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> where <code>grid[x<sub>i</sub>][y<sub>i</sub>] == 0</code>.</p>\n\n<p>Return <em>the order of the largest <strong>axis-aligned</strong> plus sign of </em>1<em>&#39;s contained in </em><code>grid</code>. If there is none, return <code>0</code>.</p>\n\n<p>An <strong>axis-aligned plus sign</strong> of <code>1</code>&#39;s of order <code>k</code> has some center <code>grid[r][c] == 1</code> along with four arms of length <code>k - 1</code> going up, down, left, and right, and made of <code>1</code>&#39;s. Note that there could be <code>0</code>&#39;s or <code>1</code>&#39;s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for <code>1</code>&#39;s.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg\" style=\"width: 404px; height: 405px;\" />\n<pre>\n<strong>Input:</strong> n = 5, mines = [[4,2]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg\" style=\"width: 84px; height: 85px;\" />\n<pre>\n<strong>Input:</strong> n = 1, mines = [[0,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no plus sign, so return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mines.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt; n</code></li>\n\t<li>All the pairs <code>(x<sub>i</sub>, y<sub>i</sub>)</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 113314,
                "title": "java-c-python-o-n-2-solution-using-only-one-grid-matrix",
                "content": "**Algorithms**: For each position `(i, j)` of the `grid` matrix, we try to extend in each of the four directions (left, right, up, down) as long as possible, then take the minimum length of `1`\\'s out of the four directions as the order of the largest axis-aligned plus sign centered at position `(i, j)`.\\n\\n---\\n\\n**Optimizations**: Normally we would need a total of five matrices to make the above idea work -- one matrix for the `grid` itself and four more matrices for each of the four directions. However, these five matrices can be combined into one using two simple tricks:\\n\\n1. For each position `(i, j)`, we are only concerned with the minimum length of `1`\\'s out of the four directions. This implies we may combine the four matrices into one by only keeping track of the minimum length.\\n\\n2. For each position `(i, j)`, the order of the largest axis-aligned plus sign centered at it will be `0` if and only if `grid[i][j] == 0`. This implies we may further combine the `grid` matrix with the one obtained above.\\n\\n---\\n\\n**Implementations**:\\n\\n1. Create an `N-by-N` matrix `grid`, with all elements initialized with value `N`.\\n2. Reset those elements to `0` whose positions are in the `mines` list.\\n3. For each position `(i, j)`, find the maximum length of `1`\\'s in each of the four directions and set `grid[i][j]` to the minimum of these four lengths. Note that there is a simple recurrence relation relating the maximum length of `1`\\'s at current position with previous position for each of the four directions (labeled as `l`, `r`, `u`, `d`).\\n4. Loop through the `grid` matrix and choose the maximum element which will be the largest axis-aligned plus sign of `1`\\'s contained in the grid.\\n\\n---\\n\\n**Solutions**: Here is a list of solutions for Java/C++/Python based on the above ideas. All solutions run at `O(N^2)` time with `O(N^2)` extra space. Further optimizations are possible such as keeping track of the maximum plus sign currently available and terminating as early as possible if no larger plus sign can be found for current row/column.\\n\\n**Note**: For those of you who got confused by the logic within the first nested for-loop, refer to [andier\\'s comment](https://leetcode.com/problems/largest-plus-sign/discuss/113314/JavaC++Python-O(N2)-solution-using-only-one-grid-matrix/114381) and [my comment](https://leetcode.com/problems/largest-plus-sign/discuss/113314/JavaC++Python-O(N2)-solution-using-only-one-grid-matrix/114382) below for a more clear explanation.\\n\\n**Java solution:**\\n\\n```\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n    int[][] grid = new int[N][N];\\n        \\n    for (int i = 0; i < N; i++) {\\n        Arrays.fill(grid[i], N);\\n    }\\n        \\n    for (int[] m : mines) {\\n        grid[m[0]][m[1]] = 0;\\n    }\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0, k = N - 1, l = 0, r = 0, u = 0, d = 0; j < N; j++, k--) {\\n            grid[i][j] = Math.min(grid[i][j], l = (grid[i][j] == 0 ? 0 : l + 1));  // left direction\\n            grid[i][k] = Math.min(grid[i][k], r = (grid[i][k] == 0 ? 0 : r + 1));  // right direction\\n            grid[j][i] = Math.min(grid[j][i], u = (grid[j][i] == 0 ? 0 : u + 1));  // up direction\\n            grid[k][i] = Math.min(grid[k][i], d = (grid[k][i] == 0 ? 0 : d + 1));  // down direction\\n        }\\n    }\\n        \\n    int res = 0;\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0; j < N; j++) {\\n            res = Math.max(res, grid[i][j]);\\n        }\\n    }\\n        \\n    return res;\\n}\\n```\\n\\n<br>\\n\\n**C++ solution:**\\n\\n```\\nint orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n    vector<vector<int>> grid(N, vector<int>(N, N));\\n        \\n    for (auto& m : mines) {\\n        grid[m[0]][m[1]] = 0;\\n    }\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0, k = N - 1, l = 0, r = 0, u = 0, d = 0; j < N; j++, k--) {\\n            grid[i][j] = min(grid[i][j], l = (grid[i][j] == 0 ? 0 : l + 1));\\n            grid[i][k] = min(grid[i][k], r = (grid[i][k] == 0 ? 0 : r + 1));\\n            grid[j][i] = min(grid[j][i], u = (grid[j][i] == 0 ? 0 : u + 1));\\n            grid[k][i] = min(grid[k][i], d = (grid[k][i] == 0 ? 0 : d + 1));\\n        }\\n    }\\n        \\n    int res = 0;\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0; j < N; j++) {\\n            res = max(res, grid[i][j]);\\n        }\\n    }\\n        \\n    return res;\\n}\\n```\\n\\n<br>\\n\\n**Python solution:**\\n\\n```\\ndef orderOfLargestPlusSign(self, N, mines):\\n    \"\"\"\\n    :type N: int\\n    :type mines: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    grid = [[N] * N for i in range(N)]\\n        \\n    for m in mines:\\n        grid[m[0]][m[1]] = 0\\n            \\n    for i in range(N):\\n        l, r, u, d = 0, 0, 0, 0\\n            \\n        for j, k in zip(range(N), reversed(range(N))):\\n            l = l + 1 if grid[i][j] != 0 else 0\\n            if l < grid[i][j]:\\n                grid[i][j] = l\\n            \\n            r = r + 1 if grid[i][k] != 0 else 0\\n            if r < grid[i][k]:\\n                grid[i][k] = r\\n\\n            u = u + 1 if grid[j][i] != 0 else 0\\n            if u < grid[j][i]:\\n                grid[j][i] = u\\n                \\n            d = d + 1 if grid[k][i] != 0 else 0\\n            if d < grid[k][i]:\\n                grid[k][i] = d\\n        \\n    res = 0\\n        \\n    for i in range(N):\\n        for j in range(N):\\n            if res < grid[i][j]:\\n                res = grid[i][j]\\n                \\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n    int[][] grid = new int[N][N];\\n        \\n    for (int i = 0; i < N; i++) {\\n        Arrays.fill(grid[i], N);\\n    }\\n        \\n    for (int[] m : mines) {\\n        grid[m[0]][m[1]] = 0;\\n    }\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0, k = N - 1, l = 0, r = 0, u = 0, d = 0; j < N; j++, k--) {\\n            grid[i][j] = Math.min(grid[i][j], l = (grid[i][j] == 0 ? 0 : l + 1));  // left direction\\n            grid[i][k] = Math.min(grid[i][k], r = (grid[i][k] == 0 ? 0 : r + 1));  // right direction\\n            grid[j][i] = Math.min(grid[j][i], u = (grid[j][i] == 0 ? 0 : u + 1));  // up direction\\n            grid[k][i] = Math.min(grid[k][i], d = (grid[k][i] == 0 ? 0 : d + 1));  // down direction\\n        }\\n    }\\n        \\n    int res = 0;\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0; j < N; j++) {\\n            res = Math.max(res, grid[i][j]);\\n        }\\n    }\\n        \\n    return res;\\n}\\n```\n```\\nint orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n    vector<vector<int>> grid(N, vector<int>(N, N));\\n        \\n    for (auto& m : mines) {\\n        grid[m[0]][m[1]] = 0;\\n    }\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0, k = N - 1, l = 0, r = 0, u = 0, d = 0; j < N; j++, k--) {\\n            grid[i][j] = min(grid[i][j], l = (grid[i][j] == 0 ? 0 : l + 1));\\n            grid[i][k] = min(grid[i][k], r = (grid[i][k] == 0 ? 0 : r + 1));\\n            grid[j][i] = min(grid[j][i], u = (grid[j][i] == 0 ? 0 : u + 1));\\n            grid[k][i] = min(grid[k][i], d = (grid[k][i] == 0 ? 0 : d + 1));\\n        }\\n    }\\n        \\n    int res = 0;\\n        \\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0; j < N; j++) {\\n            res = max(res, grid[i][j]);\\n        }\\n    }\\n        \\n    return res;\\n}\\n```\n```\\ndef orderOfLargestPlusSign(self, N, mines):\\n    \"\"\"\\n    :type N: int\\n    :type mines: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    grid = [[N] * N for i in range(N)]\\n        \\n    for m in mines:\\n        grid[m[0]][m[1]] = 0\\n            \\n    for i in range(N):\\n        l, r, u, d = 0, 0, 0, 0\\n            \\n        for j, k in zip(range(N), reversed(range(N))):\\n            l = l + 1 if grid[i][j] != 0 else 0\\n            if l < grid[i][j]:\\n                grid[i][j] = l\\n            \\n            r = r + 1 if grid[i][k] != 0 else 0\\n            if r < grid[i][k]:\\n                grid[i][k] = r\\n\\n            u = u + 1 if grid[j][i] != 0 else 0\\n            if u < grid[j][i]:\\n                grid[j][i] = u\\n                \\n            d = d + 1 if grid[k][i] != 0 else 0\\n            if d < grid[k][i]:\\n                grid[k][i] = d\\n        \\n    res = 0\\n        \\n    for i in range(N):\\n        for j in range(N):\\n            if res < grid[i][j]:\\n                res = grid[i][j]\\n                \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1453636,
                "title": "intuitive-explained-with-image-short-and-clean-c",
                "content": "**Step 1:** Create n x n matrix having all values 1 and assign the mines values as 0.\\n**Step 2:** Create another 4 matrix (say lef, rig, top, bot).\\n* ``` lef``` means left and ```lef[i][j]``` will represent no of continious block in left having values 1\\n\\t\\t```lef[ 3 ][ 2 ] = 3```\\n\\t\\t![image](https://assets.leetcode.com/users/images/0471bc00-e5e8-40e0-a166-beb0c62452a7_1631176416.7804954.png) \\n\\n* ``` rig``` means right and ```rig[i][j]``` will represent no of continious block in right having values 1\\n\\t\\t```rig[ 3 ] [ 2 ] = 2```\\n\\t\\t![image](https://assets.leetcode.com/users/images/db6685de-3044-4151-b786-231e391a0720_1631176553.0291495.png)\\n\\n* ``` top``` means top and ```top[i][j]``` will represent no of continious block in top having values 1\\n\\t\\t```top[ 3 ] [ 2 ] = 4```\\n\\t\\t![image](https://assets.leetcode.com/users/images/c1ed5229-65bb-46b0-a9fb-ea44fa621caa_1631176680.5248642.png)\\n\\n* ``` bot``` means bottom and ```bot[i][j]``` will represent no of continious block in bottom having values 1\\n\\t\\t```bot[ 3 ] [ 2 ] = 3```\\n\\t\\t![image](https://assets.leetcode.com/users/images/4caacd49-6037-44c8-9a81-fe9f101b413e_1631176732.806423.png)\\n\\n**Step 3:** Fill the above four matrix \\n* If values inside a cell is equal to 0, means that cell can not be center of the plus sign, so just ignore those cells.\\n* If values inside a cell is equal to 1, so value of this cell will be 1 more that other adjacent cells in different direction of corresponding matrix.\\n* **Note:** For matrix ```bot```, ```rig``` we need the value of the cells from the bottom cell and right cell. But as we are moving ``` i = 0 to n```, ```j = 0 to n``` means from left to right and top to bottom so those cells are not filled yet. So we have to fill these two matrix from right to left and bottom to top. And in order to so, we just have to change the index ``` x = n - 1 - i```, ```y = n - 1 - j```.\\n\\n**Step 4:** For each index check what is maximum size of \"+\" symbol we can find. \\nTo create  \"+\" from a given index we have to choose all fours arms of equal length. So by selecting minimum of all the four arms we can get \"+\" sign of maximum size from that index.\\n\\n```min({3, 2, 4, 3}) = 2```\\n![image](https://assets.leetcode.com/users/images/5c5511f0-ea03-4906-a6f9-cf7f976dee31_1631177082.7194176.png)\\n\\n**Code:** \\n```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n\\n    vector<vector<int>> mat(n, vector<int>(n, 1));\\n    for(auto it : mines)\\n    {\\n        int x = it[0] ;\\n        int y = it[1] ;\\n        mat[x][y] = 0;\\n    }\\n\\n    vector<vector<int>> lef, rig, top, bot;\\n    lef = rig = top = bot = mat;\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            int x = n - i - 1;\\n            int y = n - j - 1;\\n            if( (i>0)   && top[i][j] ) top[i][j] += top[i-1][j];\\n            if( (j>0)   && lef[i][j] ) lef[i][j] += lef[i][j-1];\\n            if( (x<n-1) && bot[x][y] ) bot[x][y] += bot[x+1][y];\\n            if( (y<n-1) && rig[x][y] ) rig[x][y] += rig[x][y+1];\\n        }\\n    }\\n\\n    int ans = 0;\\n    for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n            ans = max(ans, min({lef[i][j], rig[i][j], top[i][j], bot[i][j]}));\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` lef```\n```lef[i][j]```\n```lef[ 3 ][ 2 ] = 3```\n``` rig```\n```rig[i][j]```\n```rig[ 3 ] [ 2 ] = 2```\n``` top```\n```top[i][j]```\n```top[ 3 ] [ 2 ] = 4```\n``` bot```\n```bot[i][j]```\n```bot[ 3 ] [ 2 ] = 3```\n```bot```\n```rig```\n``` i = 0 to n```\n```j = 0 to n```\n``` x = n - 1 - i```\n```y = n - 1 - j```\n```min({3, 2, 4, 3}) = 2```\n```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n\\n    vector<vector<int>> mat(n, vector<int>(n, 1));\\n    for(auto it : mines)\\n    {\\n        int x = it[0] ;\\n        int y = it[1] ;\\n        mat[x][y] = 0;\\n    }\\n\\n    vector<vector<int>> lef, rig, top, bot;\\n    lef = rig = top = bot = mat;\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            int x = n - i - 1;\\n            int y = n - j - 1;\\n            if( (i>0)   && top[i][j] ) top[i][j] += top[i-1][j];\\n            if( (j>0)   && lef[i][j] ) lef[i][j] += lef[i][j-1];\\n            if( (x<n-1) && bot[x][y] ) bot[x][y] += bot[x+1][y];\\n            if( (y<n-1) && rig[x][y] ) rig[x][y] += rig[x][y+1];\\n        }\\n    }\\n\\n    int ans = 0;\\n    for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n            ans = max(ans, min({lef[i][j], rig[i][j], top[i][j], bot[i][j]}));\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454848,
                "title": "c-easy-top-down-dp-clean-concise",
                "content": "**Idea**\\n- Try all possible pair of `(r, c)` in range `[0..n-1]` as the center of the **axis-aligned plus sign**.\\n\\t- Get the length of 4 arms: RIGHT, DOWN, LEFT, UP\\n\\t- The size of **plus-sign** is the minimum between 4 arms.\\n- Choose the sign with have the maximum size.\\n- **HOW to get the length of 4 arms efficient?**\\n\\t- We can use **Dynamic Programming** to calculate the maximum size of 4 arms start with pos `(r, c)` in 4 directions: RIGHT, DOWN, LEFT, UP.\\n\\t- Let `dp(r, c, d)` is the longest arm start at cell `r, c` and extend in direction `d`. If we define `DIR = [0, 1, 0, -1, 0]`, then:\\n\\t\\t- `d = 0` means RIGHT direction, corresponding to `(r + DIR[0], c + DIR[1])`\\n\\t\\t- `d = 1` means DOWN direction, corresponding to `(r + DIR[1], c + DIR[2])`\\n\\t\\t- `d = 2` means LEFT direction, corresponding to `(r + DIR[2], c + DIR[3])`\\n\\t\\t- `d = 3` means TOP direction, corresponding to `(r + DIR[3], c + DIR[4])`\\n\\t- Base case: If `(r, c)` is out of bound or `grid[r][c] is a mined cell` then `dp(r, c, d) = 0`.\\n\\t- Transition state: `dp(r, c, d) = dp(r + DIR[i], c + DIR[i+1], d) + 1`.\\n```c++\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<bool>> isMine(n, vector<bool>(n, false));\\n        for (auto& pos: mines) isMine[pos[0]][pos[1]] = true;\\n        int ans = 0;\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int plusSignSize = dpMaxArm(n, isMine, r, c, 0);\\n                for (int d = 1; d < 4; ++d)\\n                    plusSignSize = min(plusSignSize, dpMaxArm(n, isMine, r, c, d));\\n                ans = max(ans, plusSignSize);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int DIR[5] = {0, 1, 0, -1, 0};\\n    int memo[500][500][4] = {};\\n    int dpMaxArm(int n, vector<vector<bool>>& isMine, int r, int c, int d) {\\n        if (r < 0 or r >= n or c < 0 or c >= n or isMine[r][c]) return 0;\\n        if (memo[r][c][d] != 0) return memo[r][c][d];\\n        return memo[r][c][d] = dpMaxArm(n, isMine, r + DIR[d], c + DIR[d+1], d) + 1;\\n    }\\n};\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 500` is the side size of the square grid.\\n- Space: `O(N^2)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<bool>> isMine(n, vector<bool>(n, false));\\n        for (auto& pos: mines) isMine[pos[0]][pos[1]] = true;\\n        int ans = 0;\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int plusSignSize = dpMaxArm(n, isMine, r, c, 0);\\n                for (int d = 1; d < 4; ++d)\\n                    plusSignSize = min(plusSignSize, dpMaxArm(n, isMine, r, c, d));\\n                ans = max(ans, plusSignSize);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int DIR[5] = {0, 1, 0, -1, 0};\\n    int memo[500][500][4] = {};\\n    int dpMaxArm(int n, vector<vector<bool>>& isMine, int r, int c, int d) {\\n        if (r < 0 or r >= n or c < 0 or c >= n or isMine[r][c]) return 0;\\n        if (memo[r][c][d] != 0) return memo[r][c][d];\\n        return memo[r][c][d] = dpMaxArm(n, isMine, r + DIR[d], c + DIR[d+1], d) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146531,
                "title": "java-simple-dp-solution-using-one-matrix-easy-to-undersatnd",
                "content": "```\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][]M = new int[N][N];\\n        for(int[]arr : M){\\n            Arrays.fill(arr, 1);\\n        }\\n        for(int[]arr : mines){\\n            M[arr[0]][arr[1]] = 0;\\n        }\\n        for(int i = 0; i < N; i++){\\n            int count = 0;   //left\\n            for (int j = 0; j < N; j++) {\\n                if (M[i][j] != 0) {\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = count;\\n            }\\n            count = 0; //right\\n            for(int j = N - 1; j >= 0; j--){\\n                if (M[i][j] != 0){\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = Math.min(M[i][j], count);\\n            }\\n        }\\n        int result = 0;\\n        for(int j = 0; j < N; j++){\\n            int count = 0;\\n            for(int i = 0; i < N; i++){ //up\\n                if(M[i][j] != 0){\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = Math.min(M[i][j], count);\\n            }\\n            count = 0; //down\\n            for(int i = N-1; i >=0; i--){\\n                if(M[i][j] != 0){\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = Math.min(M[i][j], count);\\n                result = Math.max(result, M[i][j]);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][]M = new int[N][N];\\n        for(int[]arr : M){\\n            Arrays.fill(arr, 1);\\n        }\\n        for(int[]arr : mines){\\n            M[arr[0]][arr[1]] = 0;\\n        }\\n        for(int i = 0; i < N; i++){\\n            int count = 0;   //left\\n            for (int j = 0; j < N; j++) {\\n                if (M[i][j] != 0) {\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = count;\\n            }\\n            count = 0; //right\\n            for(int j = N - 1; j >= 0; j--){\\n                if (M[i][j] != 0){\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = Math.min(M[i][j], count);\\n            }\\n        }\\n        int result = 0;\\n        for(int j = 0; j < N; j++){\\n            int count = 0;\\n            for(int i = 0; i < N; i++){ //up\\n                if(M[i][j] != 0){\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = Math.min(M[i][j], count);\\n            }\\n            count = 0; //down\\n            for(int i = N-1; i >=0; i--){\\n                if(M[i][j] != 0){\\n                    count++;\\n                } else {\\n                    count = 0;\\n                }\\n                M[i][j] = Math.min(M[i][j], count);\\n                result = Math.max(result, M[i][j]);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113319,
                "title": "python-250ms-solution",
                "content": "```\\nfrom bisect import bisect_right\\n\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        rows = [[-1, N] for _ in xrange(N)]\\n        cols = [[-1, N] for _ in xrange(N)]\\n        for r, c in mines:\\n            rows[r].append(c)\\n            cols[c].append(r)\\n        for i in xrange(N):\\n            rows[i].sort()\\n            cols[i].sort()\\n        mxp = 0\\n        for r in xrange(N):\\n            for i in xrange(len(rows[r])-1):\\n                left_b = rows[r][i]\\n                right_b = rows[r][i+1]\\n                for c in xrange(left_b+mxp+1, right_b-mxp):\\n                    idx = bisect_right(cols[c], r)-1\\n                    up_b = cols[c][idx]\\n                    down_b = cols[c][idx+1]\\n                    mxp = max(mxp, min(c-left_b, right_b-c, r-up_b, down_b-r))\\n        return mxp\\n     ```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_right\\n\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        rows = [[-1, N] for _ in xrange(N)]\\n        cols = [[-1, N] for _ in xrange(N)]\\n        for r, c in mines:\\n            rows[r].append(c)\\n            cols[c].append(r)\\n        for i in xrange(N):\\n            rows[i].sort()\\n            cols[i].sort()\\n        mxp = 0\\n        for r in xrange(N):\\n            for i in xrange(len(rows[r])-1):\\n                left_b = rows[r][i]\\n                right_b = rows[r][i+1]\\n                for c in xrange(left_b+mxp+1, right_b-mxp):\\n                    idx = bisect_right(cols[c], r)-1\\n                    up_b = cols[c][idx]\\n                    down_b = cols[c][idx+1]\\n                    mxp = max(mxp, min(c-left_b, right_b-c, r-up_b, down_b-r))\\n        return mxp\\n     ```",
                "codeTag": "Java"
            },
            {
                "id": 1453664,
                "title": "python-short-but-not-very-fast-dp-explained",
                "content": "Classical grid `dp`, where for each cell we need to find biggest number of continuous ones in for directions: up, down, left, right. We need to traverse our grid in `4` different directions and for this I use couple of tricks to make code shorter (notice though that it becomes slower, though complexity is still `O(n^2)`.\\n\\n1. We create `(N+2)x(N+2)` grid where we add zero padding of size `1` in each direction.\\n2. To traverse in direct or opposite direction we use `range(1,N+1)[::(-dx>=0)*2-1]`. Notice that if `dx = 1`, we have `1, ..., N+1` and if we have `dx = -1`, then range is `(N+1, ..., 1)`. Similar logic for `dy`.\\n\\n#### Complexity\\nTime complexity is `O(n^2)`, however with quite big constant: we have `4` directions and also a lot of time spend for creating of empty dp array and finding maximum: so, it is like `O(12n^2)` in all. Space complexity is `O(4n^2)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N, mines):\\n        grid = {tuple([x+1, y+1]) for x, y in mines}\\n        dp = [[[0] * 4 for _ in range(N+2)] for _ in range(N+2)]\\n        \\n        for dx, dy, dr in [(-1,0,0),(1,0,1),(0,-1,2),(0,1,3)]:\\n            for x in range(1,N+1)[::(-dx>=0)*2-1]:\\n                for y in range(1,N+1)[::(-dy>=0)*2-1]:\\n                    if (y, x) not in grid:\\n                        dp[y][x][dr] = dp[y+dy][x+dx][dr] + 1\\n                                                \\n        return max(min(q) for p in dp for q in p) \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N, mines):\\n        grid = {tuple([x+1, y+1]) for x, y in mines}\\n        dp = [[[0] * 4 for _ in range(N+2)] for _ in range(N+2)]\\n        \\n        for dx, dy, dr in [(-1,0,0),(1,0,1),(0,-1,2),(0,1,3)]:\\n            for x in range(1,N+1)[::(-dx>=0)*2-1]:\\n                for y in range(1,N+1)[::(-dy>=0)*2-1]:\\n                    if (y, x) not in grid:\\n                        dp[y][x][dr] = dp[y+dy][x+dx][dr] + 1\\n                                                \\n        return max(min(q) for p in dp for q in p) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 615586,
                "title": "figure-illustration-of-dp-process",
                "content": "Illustration with figure:\\n\\nLet\\'s begin with an example: \\nN = 3;\\nmines = {{0, 1}, {2,1}}\\nWith the above information, you can easily get the input matrix: grid\\n![image](https://assets.leetcode.com/users/codedayday/image_1588718965.png)\\n\\nBy searching along 4 directions, you will get 4 sub matrix.\\nBy combining them, you can get final dp, from which you can search matrix value as returned answer.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(N, vector<int>(N, N));\\n        for(auto& e: mines)  dp[e[0]][e[1]] = 0;\\n        for(int i = 0; i < N; i++)\\n            for(int j = 0, k = N - 1, u = 0, d = 0, l = 0, r =0; j < N; j++,k--){\\n                dp[i][j] = min(dp[i][j], l = dp[i][j]  ?  l + 1 : 0 ); // from left, Note1\\n                dp[j][i] = min(dp[j][i], u = dp[j][i] ?  u + 1 : 0); // from up/top\\n                dp[i][k] = min(dp[i][k], r = dp[i][k] ? r + 1 : 0); // from right\\n                dp[k][i] = min(dp[k][i], d = dp[k][i]? d + 1 : 0); // from down/bottom\\n            }\\n        \\n        int ans = 0;\\n        //for(auto& row: dp) for(auto e: row) ans = max(ans, e); //ok\\n        for(int i = 0; i < N * N; i++) ans = max(ans, dp[i / N] [i % N]);\\n        return ans;\\n    }\\n};\\nNote1:\\ndp[i][j]: how many continous 1 are in the immediate left of location [i,j]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(N, vector<int>(N, N));\\n        for(auto& e: mines)  dp[e[0]][e[1]] = 0;\\n        for(int i = 0; i < N; i++)\\n            for(int j = 0, k = N - 1, u = 0, d = 0, l = 0, r =0; j < N; j++,k--){\\n                dp[i][j] = min(dp[i][j], l = dp[i][j]  ?  l + 1 : 0 ); // from left, Note1\\n                dp[j][i] = min(dp[j][i], u = dp[j][i] ?  u + 1 : 0); // from up/top\\n                dp[i][k] = min(dp[i][k], r = dp[i][k] ? r + 1 : 0); // from right\\n                dp[k][i] = min(dp[k][i], d = dp[k][i]? d + 1 : 0); // from down/bottom\\n            }\\n        \\n        int ans = 0;\\n        //for(auto& row: dp) for(auto e: row) ans = max(ans, e); //ok\\n        for(int i = 0; i < N * N; i++) ans = max(ans, dp[i / N] [i % N]);\\n        return ans;\\n    }\\n};\\nNote1:\\ndp[i][j]: how many continous 1 are in the immediate left of location [i,j]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091541,
                "title": "c-faster-than-100-time-o-n-2-dp",
                "content": "In this approach, firstly we will find largest continuous of 1s for upper and left side\\nafter this we will find largest continuous of 1s for lower and right side\\nafter getting largest value for all direction for every index we will select min value from all direction so we will get largest \\'+\\' sign for every index \\n\\nhere, dp[][][0] for store largest value from upper side\\n\\t\\t dp[][][1] for store largest value from left side\\n\\t\\t dp[][][2] for store largest value from lower side\\n\\t\\t dp[][][3] for store largest value from right side\\n\\t\\t \\nand array v[N][N] is for showing 1s and 0s postion in the array\\t\\t \\n\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int ans=0,s,i,j,k;\\n        int dp[N+2][N+2][4],v[N][N]; // v[N][N] for showing 0 and 1 position and dp[][][] for getting largest value \\n        for(i=0;i<N;i++)for(j=0;j<N;j++)v[i][j]=1;\\n        for(i=0;i<mines.size();i++)v[mines[i][0]][mines[i][1]]=0;\\n        memset(dp,0,sizeof dp);\\n        \\n\\t\\t//first we store largest value from top left to bottom right\\n        for(i=0;i<N;i++){\\n            for(j=0;j<N;j++){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][0]=dp[i][j+1][0]+1;  //dp[][][0] for store largest value from upper side\\n                    dp[i+1][j+1][1]=dp[i+1][j][1]+1; //dp[][][1] for store largest value from left side\\n                }\\n            }\\n        }\\n        \\n\\t\\t// we store largest value from bottom right to top left\\n        for(i=N-1;i>=0;i--){\\n            for(j=N-1;j>=0;j--){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][2]=dp[i+2][j+1][2]+1;  //dp[][][2] for store largest value from lower side\\n                    dp[i+1][j+1][3]=dp[i+1][j+2][3]+1;  //dp[][][3] for store largest value from right side\\n                }\\n            }\\n        }\\n        for(i=1;i<=N;i++){\\n            for(j=1;j<=N;j++){\\n                s=min(dp[i][j][0],min(dp[i][j][1],min(dp[i][j][2],dp[i][j][3])));  // now we will select min value from all direction .. hence we will get largest \\'+\\' sign for index (i,j)\\n                ans=max(ans,s);\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```\\n\\nIf you like this approach then pls Thumbs Up :)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int ans=0,s,i,j,k;\\n        int dp[N+2][N+2][4],v[N][N]; // v[N][N] for showing 0 and 1 position and dp[][][] for getting largest value \\n        for(i=0;i<N;i++)for(j=0;j<N;j++)v[i][j]=1;\\n        for(i=0;i<mines.size();i++)v[mines[i][0]][mines[i][1]]=0;\\n        memset(dp,0,sizeof dp);\\n        \\n\\t\\t//first we store largest value from top left to bottom right\\n        for(i=0;i<N;i++){\\n            for(j=0;j<N;j++){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][0]=dp[i][j+1][0]+1;  //dp[][][0] for store largest value from upper side\\n                    dp[i+1][j+1][1]=dp[i+1][j][1]+1; //dp[][][1] for store largest value from left side\\n                }\\n            }\\n        }\\n        \\n\\t\\t// we store largest value from bottom right to top left\\n        for(i=N-1;i>=0;i--){\\n            for(j=N-1;j>=0;j--){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][2]=dp[i+2][j+1][2]+1;  //dp[][][2] for store largest value from lower side\\n                    dp[i+1][j+1][3]=dp[i+1][j+2][3]+1;  //dp[][][3] for store largest value from right side\\n                }\\n            }\\n        }\\n        for(i=1;i<=N;i++){\\n            for(j=1;j<=N;j++){\\n                s=min(dp[i][j][0],min(dp[i][j][1],min(dp[i][j][2],dp[i][j][3])));  // now we will select min value from all direction .. hence we will get largest \\'+\\' sign for index (i,j)\\n                ans=max(ans,s);\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149089,
                "title": "python-6-lines-o-n-mines-with-explanation-easy-to-understand",
                "content": "`g[x][y]` is the largest plus sign allowed centered at position (x, y). When no mines are presented, it is only limited by the boundary and should be something similar to\\n```\\n1 1 1 1 1\\n1 2 2 2 1\\n1 2 3 2 1\\n1 2 2 2 1\\n1 1 1 1 1\\n```\\nEach mine would affect the row and column it is at, causing the value of `g[x][y]` to be no larger than the distance between (x, y) and the mine.\\n```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        g = [[min(i, N-1-i, j, N-1-j) + 1 for j in range(N)] for i in range(N)]\\n        for (x, y) in mines:\\n            for i in range(N):\\n                g[i][y] = min(g[i][y], abs(i - x))\\n                g[x][i] = min(g[x][i], abs(i - y))\\n        return max([max(row) for row in g])\\n```",
                "solutionTags": [],
                "code": "```\\n1 1 1 1 1\\n1 2 2 2 1\\n1 2 3 2 1\\n1 2 2 2 1\\n1 1 1 1 1\\n```\n```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        g = [[min(i, N-1-i, j, N-1-j) + 1 for j in range(N)] for i in range(N)]\\n        for (x, y) in mines:\\n            for i in range(N):\\n                g[i][y] = min(g[i][y], abs(i - x))\\n                g[x][i] = min(g[x][i], abs(i - y))\\n        return max([max(row) for row in g])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113333,
                "title": "my-simple-o-n-2-time-and-o-n-2-space-accepted-solution-150ms",
                "content": "Created 4 matrices for storing largest streak of ones on left, right top and bottom. Finally, take the min of all four directions. \\nThe maximum of these minimums is the answer.\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] matrix = new int[N][N];\\n        for(int[] mat:matrix){\\n            Arrays.fill(mat, 1);\\n        }\\n        for(int[] mine: mines){\\n            matrix[mine[0]][mine[1]] = 0;\\n        }\\n        int ans = 0;\\n        if(mines.length<N*N) ans = 1;\\n        int[][] left = new int[N][N];\\n        int[][] right = new int[N][N];\\n        int[][] top = new int[N][N];\\n        int[][] bottom = new int[N][N];\\n        \\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                if(matrix[i][j]==1){ \\n                    top[i][j] = (i-1>=0)?top[i-1][j]+1:1;\\n                    left[i][j] = (j-1>=0)?left[i][j-1]+1:1;\\n                }\\n            }    \\n        }\\n        \\n        \\n        for(int i=N-1;i>=0;i--){\\n            for(int j=N-1;j>=0;j--){\\n                if(matrix[i][j]==1){ \\n                    bottom[i][j] = (i+1<N)?bottom[i+1][j]+1:1;\\n                    right[i][j] = (j+1<N)?right[i][j+1]+1:1;\\n                }\\n                \\n                ans = Math.max(ans, Math.min(Math.min(left[i][j],bottom[i][j]), Math.min(right[i][j],top[i][j])));\\n            }    \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] matrix = new int[N][N];\\n        for(int[] mat:matrix){\\n            Arrays.fill(mat, 1);\\n        }\\n        for(int[] mine: mines){\\n            matrix[mine[0]][mine[1]] = 0;\\n        }\\n        int ans = 0;\\n        if(mines.length<N*N) ans = 1;\\n        int[][] left = new int[N][N];\\n        int[][] right = new int[N][N];\\n        int[][] top = new int[N][N];\\n        int[][] bottom = new int[N][N];\\n        \\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                if(matrix[i][j]==1){ \\n                    top[i][j] = (i-1>=0)?top[i-1][j]+1:1;\\n                    left[i][j] = (j-1>=0)?left[i][j-1]+1:1;\\n                }\\n            }    \\n        }\\n        \\n        \\n        for(int i=N-1;i>=0;i--){\\n            for(int j=N-1;j>=0;j--){\\n                if(matrix[i][j]==1){ \\n                    bottom[i][j] = (i+1<N)?bottom[i+1][j]+1:1;\\n                    right[i][j] = (j+1<N)?right[i][j+1]+1:1;\\n                }\\n                \\n                ans = Math.max(ans, Math.min(Math.min(left[i][j],bottom[i][j]), Math.min(right[i][j],top[i][j])));\\n            }    \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453639,
                "title": "c-simple-dynamic-programming-solution-with-explanation",
                "content": "**Idea:**\\nFirst, we create the matrix of 1\\'s and 0\\'s.\\nThen, we fill the DP matrix the following way:\\nWe iterate through the matrix in four ways - left tp right, right to left, top to bottom, bottom to top.\\nWe fill the maximum length of contiguous 1\\'s.\\nWe store in the dp matrix the minimum of all directions.\\n=> \\nAfter `fillDP`, we have a matrix where each position has the largest plus sign centered in that cell.\\n```\\nclass Solution {\\npublic:\\n    void fillDP(vector<vector<int>>& dp, vector<vector<int>>& mat, int n) {\\n        int down, right, up, left;\\n        \\n        for (int i = 0; i < n; i++) {\\n            down = 0, right = 0;\\n            \\n            for (int j = 0; j < n; j++) {\\n                right = mat[i][j] ? right+1 : 0;\\n                dp[i][j] = min(dp[i][j], right);\\n                \\n                down = mat[j][i] ? down+1 : 0;\\n                dp[j][i] = min(dp[j][i], down);\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            up = 0, left = 0;\\n            for (int j = n-1; j >= 0; j--) {\\n                left = mat[i][j] ? left+1 : 0;\\n                dp[i][j] = min(dp[i][j], left);\\n                \\n                up = mat[j][i] ? up+1 : 0;\\n                dp[j][i] = min(dp[j][i], up);\\n            }\\n        }\\n    }\\n    \\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(n, vector<int>(n, INT_MAX));\\n        vector<vector<int>> mat(n, vector<int>(n, 1));\\n        \\n        for (auto mine : mines)\\n            mat[mine[0]][mine[1]] = 0;\\n        \\n        fillDP(dp, mat, n);\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fillDP(vector<vector<int>>& dp, vector<vector<int>>& mat, int n) {\\n        int down, right, up, left;\\n        \\n        for (int i = 0; i < n; i++) {\\n            down = 0, right = 0;\\n            \\n            for (int j = 0; j < n; j++) {\\n                right = mat[i][j] ? right+1 : 0;\\n                dp[i][j] = min(dp[i][j], right);\\n                \\n                down = mat[j][i] ? down+1 : 0;\\n                dp[j][i] = min(dp[j][i], down);\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            up = 0, left = 0;\\n            for (int j = n-1; j >= 0; j--) {\\n                left = mat[i][j] ? left+1 : 0;\\n                dp[i][j] = min(dp[i][j], left);\\n                \\n                up = mat[j][i] ? up+1 : 0;\\n                dp[j][i] = min(dp[j][i], up);\\n            }\\n        }\\n    }\\n    \\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(n, vector<int>(n, INT_MAX));\\n        vector<vector<int>> mat(n, vector<int>(n, 1));\\n        \\n        for (auto mine : mines)\\n            mat[mine[0]][mine[1]] = 0;\\n        \\n        fillDP(dp, mat, n);\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113323,
                "title": "easy-to-understand-java-solution",
                "content": "```\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] grid = new int[N][N];\\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            Arrays.fill(grid[i], 1);\\n        }\\n        \\n        for (int[] m : mines) {\\n            grid[m[0]][m[1]] = 0;\\n        }\\n        \\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                if(grid[i][j] == 1){\\n                    int count = 1;\\n                    int dir = 1;\\n                    while(j-dir >= 0 && j+dir < N  && i-dir >= 0 && i+dir < N  && \\n                         grid[i][j-dir] == 1 && grid[i][j+dir] == 1 && \\n                         grid[i-dir][j] == 1 && grid[i+dir][j] == 1){\\n                        count++;\\n                        dir++;    \\n                    }\\n                    ans = Math.max(count, ans);\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] grid = new int[N][N];\\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            Arrays.fill(grid[i], 1);\\n        }\\n        \\n        for (int[] m : mines) {\\n            grid[m[0]][m[1]] = 0;\\n        }\\n        \\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                if(grid[i][j] == 1){\\n                    int count = 1;\\n                    int dir = 1;\\n                    while(j-dir >= 0 && j+dir < N  && i-dir >= 0 && i+dir < N  && \\n                         grid[i][j-dir] == 1 && grid[i][j+dir] == 1 && \\n                         grid[i-dir][j] == 1 && grid[i+dir][j] == 1){\\n                        count++;\\n                        dir++;    \\n                    }\\n                    ans = Math.max(count, ans);\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385654,
                "title": "easiest-c-solution-dp-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int ans=0;\\n\\t\\t// just walk from every direction one by one to each cell and store the min. contiguous valid 1\\'s length of every direction\\n        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));\\n        vector<vector<int>> mat(n,vector<int>(n,1));\\n        for(int i=0; i<mines.size(); i++) mat[mines[i][0]][mines[i][1]]=0;\\n        for(int i=0; i<n; i++) {\\n             int c=0;\\n             for(int j=0; j<n; j++) {    // walk right to each pos \\n                   mat[i][j]?c++:c=0; \\n                   dp[i][j]=min(dp[i][j],c);\\n             }\\n        }\\n        for(int i=0; i<n; i++) {\\n            int c=0;\\n            for(int j=n-1; j>=0; j--) {   // walk left to each pos\\n                   mat[i][j]?c++:c=0; \\n                   dp[i][j]=min(dp[i][j],c);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            int c=0;\\n            for(int j=0; j<n; j++) {\\n                  mat[j][i]?c++:c=0;     // walk down to each pos\\n                  dp[j][i]=min(dp[j][i],c);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            int c=0;\\n            for(int j=n-1; j>=0; j--) {  // walk up to each pos \\n                  mat[j][i]?c++:c=0;\\n                  dp[j][i]=min(c,dp[j][i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                ans=max(ans,dp[i][j]);  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int ans=0;\\n\\t\\t// just walk from every direction one by one to each cell and store the min. contiguous valid 1\\'s length of every direction\\n        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));\\n        vector<vector<int>> mat(n,vector<int>(n,1));\\n        for(int i=0; i<mines.size(); i++) mat[mines[i][0]][mines[i][1]]=0;\\n        for(int i=0; i<n; i++) {\\n             int c=0;\\n             for(int j=0; j<n; j++) {    // walk right to each pos \\n                   mat[i][j]?c++:c=0; \\n                   dp[i][j]=min(dp[i][j],c);\\n             }\\n        }\\n        for(int i=0; i<n; i++) {\\n            int c=0;\\n            for(int j=n-1; j>=0; j--) {   // walk left to each pos\\n                   mat[i][j]?c++:c=0; \\n                   dp[i][j]=min(dp[i][j],c);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            int c=0;\\n            for(int j=0; j<n; j++) {\\n                  mat[j][i]?c++:c=0;     // walk down to each pos\\n                  dp[j][i]=min(dp[j][i],c);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            int c=0;\\n            for(int j=n-1; j>=0; j--) {  // walk up to each pos \\n                  mat[j][i]?c++:c=0;\\n                  dp[j][i]=min(c,dp[j][i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                ans=max(ans,dp[i][j]);  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454430,
                "title": "largest-plus-sign-dp-w-o-n-2-approach-c-java",
                "content": "**IDEA**\\n\\n* Create the matrix of `1` and `0`.\\n* Then, fill the DP matrix the following way:\\n\\t* Iterate through the matrix in four ways - `left to right`, `right to left`, `top to bottom`, `bottom to top`.\\n\\t* Store in the `vectors for directions` the **maximum length of contiguous** `1`.\\n* Hence we have a matrix where each position has the largest plus sign centered in that cell.\\n* The maximum length from either directions will be our answer \\n\\n**SOLUTION**\\n`IN C++`\\n```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n    vector<vector<int>> mat(n, vector<int>(n, 1)) ;\\n    for(auto it : mines)\\n    {\\n        int x = it[0] ;\\n        int y = it[1] ;\\n        mat[x][y] = 0 ;\\n    }\\n    vector<vector<int>> lef, rig, top, bot ;\\n    lef = rig = top = bot = mat ;\\n    for(int i=0; i < n ; i++)\\n    {\\n        for(int j = 0 ; j < n ; j++)\\n        {\\n            int x = n - i - 1 ;\\n            int y = n - j - 1 ;\\n            if(i > 0   && top[i][j]) \\n\\t\\t\\t\\ttop[i][j] += top[i-1][j];\\n            if(j > 0 && lef[i][j]) \\n\\t\\t\\t\\tlef[i][j] += lef[i][j-1];\\n            if(x < n-1 && bot[x][y]) \\n\\t\\t\\t\\tbot[x][y] += bot[x+1][y];\\n            if(y < n-1 && rig[x][y]) \\n\\t\\t\\t\\trig[x][y] += rig[x][y+1];\\n        }\\n    }\\n    int ans = 0;\\n    for(int i = 0 ; i < n ; i++)\\n        for(int j = 0 ; j < n ; j++)\\n            ans = max(ans, min({lef[i][j], rig[i][j], top[i][j], bot[i][j]}));\\n\\t\\t\\t\\n    return ans;\\n}\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {        \\n        boolean[][] mat = new boolean[n][n] ;\\n        for(int[] pos:mines){\\n            mat[pos[0]][pos[1]] = true;\\n        }\\n        int[][] left = new int[n][n];\\n        int[][] right = new int[n][n];\\n        int[][] up = new int[n][n];\\n        int[][] down = new int[n][n];\\n        int ans = 0;\\n        // For Left and Up only\\n        for(int i = 0 ; i < n ; i++){ \\n            for(int j = 0 ; j < n ; j++){\\n                left[i][j] = mat[i][j]?0:1+(j==0?0:left[i][j-1]);\\n                up[i][j] = mat[i][j]?0:1+(i==0?0:up[i-1][j]);\\n            }\\n        }\\n        // For Right and Down and simoultaneously get answer\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            for(int j = n - 1 ; j >= 0 ; j--){\\n                right[i][j] = mat[i][j]?0:1+(j==n-1?0:right[i][j+1]);\\n                down[i][j] = mat[i][j]?0:1+(i==n-1?0:down[i+1][j]);\\n                int x = Math.min(Math.min(left[i][j],up[i][j]),Math.min(right[i][j],down[i][j]));\\n                ans = Math.max(ans, x);\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n**TIME COMPLEXITY - O(N^2)**\\n**SPACE COMPLEXITY - O(N^2)**",
                "solutionTags": [],
                "code": "```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n    vector<vector<int>> mat(n, vector<int>(n, 1)) ;\\n    for(auto it : mines)\\n    {\\n        int x = it[0] ;\\n        int y = it[1] ;\\n        mat[x][y] = 0 ;\\n    }\\n    vector<vector<int>> lef, rig, top, bot ;\\n    lef = rig = top = bot = mat ;\\n    for(int i=0; i < n ; i++)\\n    {\\n        for(int j = 0 ; j < n ; j++)\\n        {\\n            int x = n - i - 1 ;\\n            int y = n - j - 1 ;\\n            if(i > 0   && top[i][j]) \\n\\t\\t\\t\\ttop[i][j] += top[i-1][j];\\n            if(j > 0 && lef[i][j]) \\n\\t\\t\\t\\tlef[i][j] += lef[i][j-1];\\n            if(x < n-1 && bot[x][y]) \\n\\t\\t\\t\\tbot[x][y] += bot[x+1][y];\\n            if(y < n-1 && rig[x][y]) \\n\\t\\t\\t\\trig[x][y] += rig[x][y+1];\\n        }\\n    }\\n    int ans = 0;\\n    for(int i = 0 ; i < n ; i++)\\n        for(int j = 0 ; j < n ; j++)\\n            ans = max(ans, min({lef[i][j], rig[i][j], top[i][j], bot[i][j]}));\\n\\t\\t\\t\\n    return ans;\\n}\\n```\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {        \\n        boolean[][] mat = new boolean[n][n] ;\\n        for(int[] pos:mines){\\n            mat[pos[0]][pos[1]] = true;\\n        }\\n        int[][] left = new int[n][n];\\n        int[][] right = new int[n][n];\\n        int[][] up = new int[n][n];\\n        int[][] down = new int[n][n];\\n        int ans = 0;\\n        // For Left and Up only\\n        for(int i = 0 ; i < n ; i++){ \\n            for(int j = 0 ; j < n ; j++){\\n                left[i][j] = mat[i][j]?0:1+(j==0?0:left[i][j-1]);\\n                up[i][j] = mat[i][j]?0:1+(i==0?0:up[i-1][j]);\\n            }\\n        }\\n        // For Right and Down and simoultaneously get answer\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            for(int j = n - 1 ; j >= 0 ; j--){\\n                right[i][j] = mat[i][j]?0:1+(j==n-1?0:right[i][j+1]);\\n                down[i][j] = mat[i][j]?0:1+(i==n-1?0:down[i+1][j]);\\n                int x = Math.min(Math.min(left[i][j],up[i][j]),Math.min(right[i][j],down[i][j]));\\n                ans = Math.max(ans, x);\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143607,
                "title": "python-straightforward-simple-self-explanatory-ac-solution",
                "content": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N, mines):\\n        #up, left, down, right\\n        dp, res, mines = [[[0, 0, 0, 0] for j in range(N)] for i in range(N)], 0, {(i, j) for i, j in mines}\\n        for i in range(N):\\n            for j in range(N):\\n                if (i, j) not in mines:\\n                    try:\\n                        dp[i][j][0] = dp[i - 1][j][0] + 1\\n                    except:\\n                        dp[i][j][0] = 1\\n                    try:\\n                        dp[i][j][1] = dp[i][j - 1][1] + 1\\n                    except:\\n                        dp[i][j][1] = 1\\n        for i in range(N - 1, -1, -1):\\n            for j in range(N - 1, -1, -1):\\n                if (i, j) not in mines:\\n                    try:\\n                        dp[i][j][2] = dp[i + 1][j][2] + 1\\n                    except:\\n                        dp[i][j][2] = 1\\n                    try:\\n                        dp[i][j][3] = dp[i][j + 1][3] + 1\\n                    except:\\n                        dp[i][j][3] = 1\\n                    res = max(res, min(dp[i][j]))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N, mines):\\n        #up, left, down, right\\n        dp, res, mines = [[[0, 0, 0, 0] for j in range(N)] for i in range(N)], 0, {(i, j) for i, j in mines}\\n        for i in range(N):\\n            for j in range(N):\\n                if (i, j) not in mines:\\n                    try:\\n                        dp[i][j][0] = dp[i - 1][j][0] + 1\\n                    except:\\n                        dp[i][j][0] = 1\\n                    try:\\n                        dp[i][j][1] = dp[i][j - 1][1] + 1\\n                    except:\\n                        dp[i][j][1] = 1\\n        for i in range(N - 1, -1, -1):\\n            for j in range(N - 1, -1, -1):\\n                if (i, j) not in mines:\\n                    try:\\n                        dp[i][j][2] = dp[i + 1][j][2] + 1\\n                    except:\\n                        dp[i][j][2] = 1\\n                    try:\\n                        dp[i][j][3] = dp[i][j + 1][3] + 1\\n                    except:\\n                        dp[i][j][3] = 1\\n                    res = max(res, min(dp[i][j]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113350,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Use prefix sums to track the length of continuous 1s from all four cardinal directions: up, down, left, right.  Then perform a scan of the board cell\\'s `i`, `j` to find and return the maximum of each cell\\'s minimum length of continuous 1s of all four cardinal directions as the `best` answer.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun orderOfLargestPlusSign(N: Int, X: Array<IntArray>): Int {\\n        var A = Array<IntArray>(N) { IntArray(N) { 1 } }\\n        for ((i, j) in X)\\n            A[i][j] = 0\\n        var (U, D, L, R) = Array(4) { A.map{ it.copyOf() } }\\n        for (i in 1 until N - 1) {\\n            for (j in 1 until N - 1) {\\n                var u = N - 1 - i\\n                var v = N - 1 - j\\n                if (A[i][j] == 1) {\\n                    U[i][j] = 1 + U[i - 1][j]\\n                    L[i][j] = 1 + L[i][j - 1]\\n                }\\n                if (A[u][v] == 1) {\\n                    D[u][v] = 1 + D[u + 1][v]\\n                    R[u][v] = 1 + R[u][v + 1]\\n                }\\n            }\\n        }\\n        return Array(N){ IntArray(N){ it } }.mapIndexed{ i, row -> row.map{ j -> listOf(U[i][j], D[i][j], L[i][j], R[i][j]).min()!! }.max()!! }.max()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet orderOfLargestPlusSign = (N, X, best = 0) => {\\n    let A = [...Array(N)].map(_ => Array(N).fill(1));\\n    for (let [i, j] of X)\\n        A[i][j] = 0;\\n    let [U, D, L, R] = [...Array(4)].map(_ => A.map(row => [...row]));\\n    for (let i = 1; i < N - 1; ++i) {\\n        for (let j = 1; j < N - 1; ++j) {\\n            let u = N - 1 - i,\\n                v = N - 1 - j;\\n            if (A[i][j]) {\\n                U[i][j] = 1 + U[i - 1][j];\\n                L[i][j] = 1 + L[i][j - 1];\\n            }\\n            if (A[u][v]) {\\n                D[u][v] = 1 + D[u + 1][v];\\n                R[u][v] = 1 + R[u][v + 1];\\n            }\\n        }\\n    }\\n    return Math.max(...[...Array(N).keys()].map(i => Math.max(...[...Array(N).keys()].map(j => Math.min(U[i][j], D[i][j], L[i][j], R[i][j])))));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, X: List[List[int]], best = 0) -> int:\\n        A = [N * [1] for _ in range(N)]\\n        for i, j in X:\\n            A[i][j] = 0\\n        U, D, L, R = [[row[:] for row in A] for _ in range(4)]\\n        for i in range(1, N - 1):\\n            for j in range(1, N - 1):\\n                u = N - 1 - i\\n                v = N - 1 - j\\n                if A[i][j]:\\n                    U[i][j] = 1 + U[i - 1][j]\\n                    L[i][j] = 1 + L[i][j - 1]\\n                if A[u][v]:\\n                    D[u][v] = 1 + D[u + 1][v]\\n                    R[u][v] = 1 + R[u][v + 1]\\n        return max(min(U[i][j], D[i][j], L[i][j], R[i][j]) for j in range(N) for i in range(N))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int orderOfLargestPlusSign(int N, VVI& X, int best = 0) {\\n        VVI A(N, VI(N, 1));\\n        for (auto& x: X) {\\n            auto [i, j] = tie(x[0], x[1]);\\n            A[i][j] = 0;\\n        }\\n        VVI U{ A }, D{ A }, L{ A }, R{ A };\\n        for (auto i{ 1 }; i < N - 1; ++i) {\\n            for (auto j{ 1 }; j < N - 1; ++j) {\\n                auto u = N - 1 - i,\\n                     v = N - 1 - j;\\n                if (A[i][j]) {\\n                    U[i][j] = 1 + U[i - 1][j];\\n                    L[i][j] = 1 + L[i][j - 1];\\n                }\\n                if (A[u][v]) {\\n                    D[u][v] = 1 + D[u + 1][v];\\n                    R[u][v] = 1 + R[u][v + 1];\\n                }\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                best = max(best, min({ U[i][j], D[i][j], L[i][j], R[i][j] }));\\n        return best;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun orderOfLargestPlusSign(N: Int, X: Array<IntArray>): Int {\\n        var A = Array<IntArray>(N) { IntArray(N) { 1 } }\\n        for ((i, j) in X)\\n            A[i][j] = 0\\n        var (U, D, L, R) = Array(4) { A.map{ it.copyOf() } }\\n        for (i in 1 until N - 1) {\\n            for (j in 1 until N - 1) {\\n                var u = N - 1 - i\\n                var v = N - 1 - j\\n                if (A[i][j] == 1) {\\n                    U[i][j] = 1 + U[i - 1][j]\\n                    L[i][j] = 1 + L[i][j - 1]\\n                }\\n                if (A[u][v] == 1) {\\n                    D[u][v] = 1 + D[u + 1][v]\\n                    R[u][v] = 1 + R[u][v + 1]\\n                }\\n            }\\n        }\\n        return Array(N){ IntArray(N){ it } }.mapIndexed{ i, row -> row.map{ j -> listOf(U[i][j], D[i][j], L[i][j], R[i][j]).min()!! }.max()!! }.max()!!\\n    }\\n}\\n```\n```\\nlet orderOfLargestPlusSign = (N, X, best = 0) => {\\n    let A = [...Array(N)].map(_ => Array(N).fill(1));\\n    for (let [i, j] of X)\\n        A[i][j] = 0;\\n    let [U, D, L, R] = [...Array(4)].map(_ => A.map(row => [...row]));\\n    for (let i = 1; i < N - 1; ++i) {\\n        for (let j = 1; j < N - 1; ++j) {\\n            let u = N - 1 - i,\\n                v = N - 1 - j;\\n            if (A[i][j]) {\\n                U[i][j] = 1 + U[i - 1][j];\\n                L[i][j] = 1 + L[i][j - 1];\\n            }\\n            if (A[u][v]) {\\n                D[u][v] = 1 + D[u + 1][v];\\n                R[u][v] = 1 + R[u][v + 1];\\n            }\\n        }\\n    }\\n    return Math.max(...[...Array(N).keys()].map(i => Math.max(...[...Array(N).keys()].map(j => Math.min(U[i][j], D[i][j], L[i][j], R[i][j])))));\\n};\\n```\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, X: List[List[int]], best = 0) -> int:\\n        A = [N * [1] for _ in range(N)]\\n        for i, j in X:\\n            A[i][j] = 0\\n        U, D, L, R = [[row[:] for row in A] for _ in range(4)]\\n        for i in range(1, N - 1):\\n            for j in range(1, N - 1):\\n                u = N - 1 - i\\n                v = N - 1 - j\\n                if A[i][j]:\\n                    U[i][j] = 1 + U[i - 1][j]\\n                    L[i][j] = 1 + L[i][j - 1]\\n                if A[u][v]:\\n                    D[u][v] = 1 + D[u + 1][v]\\n                    R[u][v] = 1 + R[u][v + 1]\\n        return max(min(U[i][j], D[i][j], L[i][j], R[i][j]) for j in range(N) for i in range(N))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int orderOfLargestPlusSign(int N, VVI& X, int best = 0) {\\n        VVI A(N, VI(N, 1));\\n        for (auto& x: X) {\\n            auto [i, j] = tie(x[0], x[1]);\\n            A[i][j] = 0;\\n        }\\n        VVI U{ A }, D{ A }, L{ A }, R{ A };\\n        for (auto i{ 1 }; i < N - 1; ++i) {\\n            for (auto j{ 1 }; j < N - 1; ++j) {\\n                auto u = N - 1 - i,\\n                     v = N - 1 - j;\\n                if (A[i][j]) {\\n                    U[i][j] = 1 + U[i - 1][j];\\n                    L[i][j] = 1 + L[i][j - 1];\\n                }\\n                if (A[u][v]) {\\n                    D[u][v] = 1 + D[u + 1][v];\\n                    R[u][v] = 1 + R[u][v + 1];\\n                }\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                best = max(best, min({ U[i][j], D[i][j], L[i][j], R[i][j] }));\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454859,
                "title": "c-dp-solution-intuition-explained",
                "content": "**Intution and Thought Process :**\\n\\n* Idea is to store the length of longest consecutive 1\\'s in all four directions. \\n* For this we need to have 4 seperate matrix that stores the length for **left, right, up, down.**\\n* And then for every 1\\'s in the grid, we need to find the minimum of left, right, up, and down. That will be the order of plus. \\n# Code : \\n```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n     \\n\\tvector<vector<int>> grid(n, vector<int>(n, 1));\\n\\tint orderOfPlus = 0;\\n\\tfor(auto& mine : mines)\\n\\t{\\n\\t\\tgrid[mine[0]][mine[1]] = 0;\\n\\t}\\n\\n\\t// UP and LEFT\\n\\tvector<vector<int>> up(n, vector<int>(n, 0));\\n\\tvector<vector<int>> left(n, vector<int>(n, 0));\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tup[i][j] = 1;\\n\\t\\t\\t\\tleft[i][j] = 1;\\n\\t\\t\\t\\tif(i > 0) up[i][j] = 1 + up[i-1][j];\\n\\t\\t\\t\\tif(j > 0) left[i][j] = 1 + left[i][j-1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// DOWN and RIGHT\\n\\tvector<vector<int>> down(n, vector<int>(n, 0));\\n\\tvector<vector<int>> right(n, vector<int>(n, 0));\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t{\\n\\t\\tfor(int j=n-1; j>=0; j--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdown[i][j] = 1;\\n\\t\\t\\t\\tright[i][j] = 1;\\n\\t\\t\\t\\tif(i<n-1) down[i][j] = 1 + down[i+1][j];\\n\\t\\t\\t\\tif(j<n-1) right[i][j] = 1 + right[i][j+1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Find min in all 4 directions\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tint order = min({up[i][j], left[i][j], down[i][j], right[i][j]});\\n\\t\\t\\t\\torderOfPlus = max(orderOfPlus, order);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn (orderOfPlus);\\n}\\n```\\n**Time : O(N^2)**\\n**Space :  O(N^2) **\\n\\n**Follow UP :**\\n* Here, we can do some more optimizations. Like, instead of taking 4 different matrix for each direction, we can take a single DP matrix. \\n* Also, instead of computing separately for *UP, LEFT* and *DOWN, RIGHT*, we can put them into one nested loop.\\n\\n*If you liked the solution do give it an upvote :)*",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n     \\n\\tvector<vector<int>> grid(n, vector<int>(n, 1));\\n\\tint orderOfPlus = 0;\\n\\tfor(auto& mine : mines)\\n\\t{\\n\\t\\tgrid[mine[0]][mine[1]] = 0;\\n\\t}\\n\\n\\t// UP and LEFT\\n\\tvector<vector<int>> up(n, vector<int>(n, 0));\\n\\tvector<vector<int>> left(n, vector<int>(n, 0));\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tup[i][j] = 1;\\n\\t\\t\\t\\tleft[i][j] = 1;\\n\\t\\t\\t\\tif(i > 0) up[i][j] = 1 + up[i-1][j];\\n\\t\\t\\t\\tif(j > 0) left[i][j] = 1 + left[i][j-1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// DOWN and RIGHT\\n\\tvector<vector<int>> down(n, vector<int>(n, 0));\\n\\tvector<vector<int>> right(n, vector<int>(n, 0));\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t{\\n\\t\\tfor(int j=n-1; j>=0; j--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdown[i][j] = 1;\\n\\t\\t\\t\\tright[i][j] = 1;\\n\\t\\t\\t\\tif(i<n-1) down[i][j] = 1 + down[i+1][j];\\n\\t\\t\\t\\tif(j<n-1) right[i][j] = 1 + right[i][j+1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Find min in all 4 directions\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tint order = min({up[i][j], left[i][j], down[i][j], right[i][j]});\\n\\t\\t\\t\\torderOfPlus = max(orderOfPlus, order);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn (orderOfPlus);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426178,
                "title": "python-dp",
                "content": "Just keep a check of nos of consecutive 1s in left and top in first loop\\nRight and down in second loop,and take min of all 4 directions,thats it !!!!\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        m=len(mines)\\n        if m==n*n: return 0\\n        seen=set()\\n        for i,j in mines:\\n            seen.add((i,j))\\n        ans=1\\n        #(left,up,right,down)\\n        dp=[[[0,0,0,0] for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if (i,j) not in seen:\\n                    dp[i][j][0]=(dp[i][j-1][0]+1) if j-1>=0 else 1\\n                    dp[i][j][1]=(dp[i-1][j][1]+1) if i-1>=0 else 1\\n        for i in range(n-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if (i,j) not in seen:\\n                    dp[i][j][2]=(dp[i][j+1][2]+1) if j+1<n else 1\\n                    dp[i][j][3]=(dp[i+1][j][3]+1) if i+1<n else 1\\n                ans=max(ans,min(dp[i][j]))\\n        return ans\\n                    \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        m=len(mines)\\n        if m==n*n: return 0\\n        seen=set()\\n        for i,j in mines:\\n            seen.add((i,j))\\n        ans=1\\n        #(left,up,right,down)\\n        dp=[[[0,0,0,0] for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if (i,j) not in seen:\\n                    dp[i][j][0]=(dp[i][j-1][0]+1) if j-1>=0 else 1\\n                    dp[i][j][1]=(dp[i-1][j][1]+1) if i-1>=0 else 1\\n        for i in range(n-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if (i,j) not in seen:\\n                    dp[i][j][2]=(dp[i][j+1][2]+1) if j+1<n else 1\\n                    dp[i][j][3]=(dp[i+1][j][3]+1) if i+1<n else 1\\n                ans=max(ans,min(dp[i][j]))\\n        return ans\\n                    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833937,
                "title": "python-3-dp-bomb-enemy-explanations",
                "content": "Code is long, but trust me, they are super easy to understand.\\n\\n### Intuition\\n- Brutal force will definitely fail given N can be up to 500 and brutal force is a `O(N^3)` solution; need to think of something else\\n- For a `+` sign, there are 4 directions, up/down/left/right\\n\\t- If we just check 1 direction in each iteration, and store the value somewhere, then we can reuse the value since it\\'s a matrix (we can have previous/next row or column\\'s values).\\n\\t- So we check 4 directions separately, then the time complexity is `O(N^2) * constant = O(N^2)`\\n- A `+` should have 4 directions same number of `1`s\\n\\t- meaning we need to take the minimum of 4 directions\\n- Finally, iterate over one more time to find the max\\n\\n### Explanation\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mat = [[1]*N for _ in range(N)]\\n        for x, y in mines: mat[x][y] = 0                   # create matrix with mine\\n            \\n        up = [[0]*N for _ in range(N)]                     # count 1s above mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    up[i][j] = 1\\n                    if i > 0: up[i][j] += up[i-1][j] \\n                \\n        down = [[0]*N for _ in range(N)]                   # count 1s below mat[i][j] if mat[i][j] is 1\\n        for i in range(N-1, -1, -1):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    down[i][j] = 1\\n                    if i < N-1: down[i][j] += down[i+1][j] \\n                    \\n        left = [[0]*N for _ in range(N)]                   # count 1s on the left side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]:\\n                    left[i][j] = 1\\n                    if j > 0: left[i][j] += left[i][j-1]\\n                    \\n        right = [[0]*N for _ in range(N)]                  # count 1s on the right side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N-1, -1, -1):\\n                if mat[i][j]:\\n                    right[i][j] = 1\\n                    if j < N-1: right[i][j] += right[i][j+1]\\n         \\n\\t\\t# find the largest + sign by using cached directions information\\n        return max(min([up[i][j], down[i][j], left[i][j], right[i][j]]) for i in range(N) for j in range(N))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mat = [[1]*N for _ in range(N)]\\n        for x, y in mines: mat[x][y] = 0                   # create matrix with mine\\n            \\n        up = [[0]*N for _ in range(N)]                     # count 1s above mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    up[i][j] = 1\\n                    if i > 0: up[i][j] += up[i-1][j] \\n                \\n        down = [[0]*N for _ in range(N)]                   # count 1s below mat[i][j] if mat[i][j] is 1\\n        for i in range(N-1, -1, -1):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    down[i][j] = 1\\n                    if i < N-1: down[i][j] += down[i+1][j] \\n                    \\n        left = [[0]*N for _ in range(N)]                   # count 1s on the left side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]:\\n                    left[i][j] = 1\\n                    if j > 0: left[i][j] += left[i][j-1]\\n                    \\n        right = [[0]*N for _ in range(N)]                  # count 1s on the right side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N-1, -1, -1):\\n                if mat[i][j]:\\n                    right[i][j] = 1\\n                    if j < N-1: right[i][j] += right[i][j+1]\\n         \\n\\t\\t# find the largest + sign by using cached directions information\\n        return max(min([up[i][j], down[i][j], left[i][j], right[i][j]]) for i in range(N) for j in range(N))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113334,
                "title": "c-o-n-3-solution-226ms-with-explanation",
                "content": "For this problem, I first think of the related problem finding largest square, and I tried DP as DP can give O(n^2) time complexity. They way I do it is use a dp[N][N][4] to record each 1s consecutive 1s in 4 directions and they can be abrupt by 0. However, my code fails at last test case because of memory. Obviously, there is a tradeoff in space and time.\\n\\nIn order to pass I take advantage of having limited 0s on last test case and generated the following O(N^3) solution, the general idea is do bfs (I actually update everything on row and col) and update grid every time we meet a 0. There could be total N^2 0s and update board takes additional N so it's N^3.\\n\\nTo make things easier, I initialize the board with rules to take in count of boarder. \\n\\n```\\nint orderOfLargestPlusSign(int N, vector<vector<int>>& mines)\\n{\\n    vector<vector<int>> grid(N,vector<int>(N,N));\\n    \\n    for(int i =0; i < N; i++)\\n        for(int j =0; j< N; j++)\\n        {\\n            grid[i][j] = min(i-0+1,j-0+1);\\n            grid[i][j] = min(grid[i][j],N-i);\\n            grid[i][j] = min(grid[i][j],N-j);\\n        }\\n    \\n    for(auto v : mines)\\n    {\\n        int i = v[0];\\n        int j = v[1];\\n        \\n        for(int ii =0; ii< N;ii++)\\n            grid[ii][j] = min(grid[ii][j],abs(ii-i));\\n        \\n        for(int jj =0; jj< N;jj++)\\n            grid[i][jj] = min(grid[i][jj],abs(jj-j));\\n    }\\n    \\n    \\n    int result =0;\\n    \\n    for(int i =0; i < N; i++)\\n        for(int j =0; j< N; j++)\\n            result = max(result,grid[i][j]);\\n\\n    return result;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nint orderOfLargestPlusSign(int N, vector<vector<int>>& mines)\\n{\\n    vector<vector<int>> grid(N,vector<int>(N,N));\\n    \\n    for(int i =0; i < N; i++)\\n        for(int j =0; j< N; j++)\\n        {\\n            grid[i][j] = min(i-0+1,j-0+1);\\n            grid[i][j] = min(grid[i][j],N-i);\\n            grid[i][j] = min(grid[i][j],N-j);\\n        }\\n    \\n    for(auto v : mines)\\n    {\\n        int i = v[0];\\n        int j = v[1];\\n        \\n        for(int ii =0; ii< N;ii++)\\n            grid[ii][j] = min(grid[ii][j],abs(ii-i));\\n        \\n        for(int jj =0; jj< N;jj++)\\n            grid[i][jj] = min(grid[i][jj],abs(jj-j));\\n    }\\n    \\n    \\n    int result =0;\\n    \\n    for(int i =0; i < N; i++)\\n        for(int j =0; j< N; j++)\\n            result = max(result,grid[i][j]);\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1633127,
                "title": "nice-o-n-2-solution",
                "content": "class Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        vector< vector< int >>DP( n, vector< int >( n, 1));\\n                                                            \\n        for( auto x:mines )\\n            DP[ x[0] ][ x[1] ] = 0;\\n        \\n        vector< vector< int >>left = DP, top = DP, right = DP, bottom =DP;  \\n        \\n        for( int i=0 ; i<n ; i++ ){\\n            \\n            for( int j=0 ; j<n ; j++ ){\\n                \\n                if( DP[ i ][ j ] ){\\n                    \\n                    if( j>0 )\\n                        left[ i ][ j ] = 1 + left[ i ][ j-1 ];\\n                    else\\n                        left[ i ][ j ] = 1;\\n                    \\n                    if( i>0 )\\n                        top[ i ][ j ] = 1 + top[ i-1 ][ j ];\\n                    else\\n                        top[ i ][ j ] = 1;\\n                }\\n            }\\n        }\\n        \\n        int maxm = 0;\\n        \\n        for( int i=n-1 ; i>=0 ; i-- ){\\n            \\n            for( int j=n-1 ; j>=0 ; j-- ){\\n                \\n                if( DP[ i ][ j ] ){\\n                    \\n                    if( j<(n-1) )\\n                        right[ i ][ j ] = 1 + right[ i ][ j+1 ];\\n                    else\\n                        right[ i ][ j ] = 1;\\n                    \\n                    if( i<(n-1) )\\n                        bottom[ i ][ j ] = 1 + bottom[ i+1 ][ j ];\\n                    else\\n                        bottom[ i ][ j ] = 1;\\n                }\\n                \\n                int k = min({ left[i][j] , right[i][j] , top[i][j] , bottom[i][j] });\\n                \\n                maxm = max( k, maxm );\\n            }\\n        }\\n        \\n        return maxm;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        vector< vector< int >>DP( n, vector< int >( n, 1));\\n                                                            \\n        for( auto x:mines )\\n            DP[ x[0] ][ x[1] ] = 0;\\n        \\n        vector< vector< int >>left = DP, top = DP, right = DP, bottom =DP;  \\n        \\n        for( int i=0 ; i<n ; i++ ){\\n            \\n            for( int j=0 ; j<n ; j++ ){\\n                \\n                if( DP[ i ][ j ] ){\\n                    \\n                    if( j>0 )\\n                        left[ i ][ j ] = 1 + left[ i ][ j-1 ];\\n                    else\\n                        left[ i ][ j ] = 1;\\n                    \\n                    if( i>0 )\\n                        top[ i ][ j ] = 1 + top[ i-1 ][ j ];\\n                    else\\n                        top[ i ][ j ] = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1454847,
                "title": "java-solution-using-dfs",
                "content": "The idea is very similar to doing a DFS only a slight variation that the distace keeps on increasing if a certain condition is satisfied. Once left, right, top, and bottom are met then we have to increase the distance by 1 and see if it satisfies the plus sign. If the condition is not met we simply break from the loop ans maximise our answer. Refer to the code for implementation. Do upvote id it was helpful!!!\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] arr = new int[n][n];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                arr[i][j] = 1;\\n            }\\n        }\\n        for(int[] i : mines){\\n            int x = i[0];\\n            int y = i[1];\\n            arr[x][y] = 0;\\n        }\\n        // for(int i = 0 ; i < n ; i++){\\n        //     for(int  j = 0 ; j < n ; j++){\\n        //         System.out.print(arr[i][j] +\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(arr[i][j] == 1)\\n                {\\n                   int order = 1;\\n                    while(true){\\n                       // System.out.println(order);\\n                        if(!isValid(i - order , j , n , arr))\\n                            break;\\n                        if(!isValid(i + order , j , n , arr))\\n                            break;\\n                        if(!isValid(i , j - order , n , arr))\\n                            break;\\n                        if(!isValid(i , j + order , n , arr))\\n                            break;\\n                         \\n                        order++;\\n                        \\n                    }\\n                    ans = Math.max(ans , order);\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int i  , int j , int n , int[][] arr){\\n        if(i < 0 || j < 0 || i > n - 1 || j > n - 1)\\n            return false;\\n        if(arr[i][j] != 1)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] arr = new int[n][n];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                arr[i][j] = 1;\\n            }\\n        }\\n        for(int[] i : mines){\\n            int x = i[0];\\n            int y = i[1];\\n            arr[x][y] = 0;\\n        }\\n        // for(int i = 0 ; i < n ; i++){\\n        //     for(int  j = 0 ; j < n ; j++){\\n        //         System.out.print(arr[i][j] +\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(arr[i][j] == 1)\\n                {\\n                   int order = 1;\\n                    while(true){\\n                       // System.out.println(order);\\n                        if(!isValid(i - order , j , n , arr))\\n                            break;\\n                        if(!isValid(i + order , j , n , arr))\\n                            break;\\n                        if(!isValid(i , j - order , n , arr))\\n                            break;\\n                        if(!isValid(i , j + order , n , arr))\\n                            break;\\n                         \\n                        order++;\\n                        \\n                    }\\n                    ans = Math.max(ans , order);\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int i  , int j , int n , int[][] arr){\\n        if(i < 0 || j < 0 || i > n - 1 || j > n - 1)\\n            return false;\\n        if(arr[i][j] != 1)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454020,
                "title": "c-easy-solution-dp-dfs",
                "content": "In this particular post at first we look at the raw code which is essentially the same as the shorter version. This will help us understand the code better. \\n\\n**Algorithm**\\n\\nFor each (cardinal) direction, and for each coordinate (r, c) let\\'s compute the count of that coordinate: the longest line of \\'1\\'s starting from (r, c) and going in that direction. With dynamic programming, it is either 0 if **grid[r][c]** is zero, else it is 1 plus the count of the coordinate in the same direction. For example, if the direction is left and we have a row like 01110110, the corresponding count values are 01230120, and the integers are either 1 more than their successor, or 0. For each square, we want **grid[r][c]** to end up being the minimum of the 4 possible counts. At the end, we take the maximum value in dp.\\n\\n\\nTime Complexity: *O(N^2)*, as the work we do under two nested for loops is O(1)O(1).\\nSpace Complexity: *O(N^2)*, the size of grid.\\n\\n![image](https://assets.leetcode.com/users/images/e361ae4a-9f95-46ba-8f3a-af5564aedebf_1631196300.6386557.png)\\n\\n\\n**C++ DP Raw Version**\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>grid(n,vector<int>(n,n));\\n        \\n        for(auto m:mines){\\n            grid[m[0]][m[1]]=0;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            for(int j=0,left=0;j<n;j++){\\n                if(grid[i][j]==0)left=0;\\n                else left+=1;\\n                grid[i][j]=min(grid[i][j],left);\\n            }\\n            \\n        \\n            for(int k=n-1,right=0;k>=0;k--){\\n                if(grid[i][k]==0)right=0;\\n                else right+=1;\\n                grid[i][k]=min(grid[i][k],right);\\n            }\\n            \\n            \\n            for(int j=0,top=0;j<n;j++){\\n                if(grid[j][i]==0)top=0;\\n                else top+=1;\\n                grid[j][i]=min(grid[j][i],top);\\n            }\\n             \\n            for(int k=n-1,bottom=0;k>=0;k--){\\n                if(grid[k][i]==0)bottom=0;\\n                else bottom+=1;\\n                grid[k][i]=min(grid[k][i],bottom);\\n            }\\n            \\n            }\\n            \\n            int mxorder=0;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    mxorder=max(mxorder,grid[i][j]);\\n                }\\n            }\\n        \\n        return mxorder;\\n        }\\n    };\\n```\\n\\n\\n**C++ DP Shortened Version**\\n```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n    vector<vector<int>> grid(n, vector<int>(n, n));\\n        \\n    for (auto& m : mines) {\\n        grid[m[0]][m[1]] = 0;\\n    }\\n        \\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0, k = n - 1, left = 0, right= 0, top = 0, bottom = 0; j < n; j++, k--) {\\n            grid[i][j] = min(grid[i][j], left = (grid[i][j] == 0 ? 0 : left + 1));\\n            grid[i][k] = min(grid[i][k], right = (grid[i][k] == 0 ? 0 : right + 1));\\n            grid[j][i] = min(grid[j][i], top = (grid[j][i] == 0 ? 0 : top + 1));\\n            grid[k][i] = min(grid[k][i], bottom = (grid[k][i] == 0 ? 0 : bottom + 1));\\n        }\\n    }\\n        \\n    int mxorder = 0;\\n        \\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            mxorder = max(mxorder, grid[i][j]);\\n        }\\n    }\\n        \\n    return mxorder;\\n}\\n```\\n\\n**C++ DFS Version (TLE on some cases)**\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(N, vector<int>(N, 1));\\n        for(auto &p: mines){\\n            grid[p[0]][p[1]] = 0;\\n        }\\n        \\n        auto all_ones = [&](int i, int j, int k){\\n            if(i - k < 0 || i + k >= N || j - k < 0 || j + k >= N)\\n                return false;\\n            return grid[i - k][j] && grid[i + k][j] && grid[i][j - k] && grid[i][j + k];\\n        };\\n        int K = 0;\\n        for(int i = 0; i < N; ++i){\\n            for(int j = 0; j < N; ++j){\\n                if(grid[i][j] == 1){\\n                    int k = 1;\\n                    while(all_ones(i, j, k))\\n                        ++k;\\n                    K = max(k, K);\\n                }\\n            }\\n        }\\n        return K;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>grid(n,vector<int>(n,n));\\n        \\n        for(auto m:mines){\\n            grid[m[0]][m[1]]=0;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            for(int j=0,left=0;j<n;j++){\\n                if(grid[i][j]==0)left=0;\\n                else left+=1;\\n                grid[i][j]=min(grid[i][j],left);\\n            }\\n            \\n        \\n            for(int k=n-1,right=0;k>=0;k--){\\n                if(grid[i][k]==0)right=0;\\n                else right+=1;\\n                grid[i][k]=min(grid[i][k],right);\\n            }\\n            \\n            \\n            for(int j=0,top=0;j<n;j++){\\n                if(grid[j][i]==0)top=0;\\n                else top+=1;\\n                grid[j][i]=min(grid[j][i],top);\\n            }\\n             \\n            for(int k=n-1,bottom=0;k>=0;k--){\\n                if(grid[k][i]==0)bottom=0;\\n                else bottom+=1;\\n                grid[k][i]=min(grid[k][i],bottom);\\n            }\\n            \\n            }\\n            \\n            int mxorder=0;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    mxorder=max(mxorder,grid[i][j]);\\n                }\\n            }\\n        \\n        return mxorder;\\n        }\\n    };\\n```\n```\\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n    vector<vector<int>> grid(n, vector<int>(n, n));\\n        \\n    for (auto& m : mines) {\\n        grid[m[0]][m[1]] = 0;\\n    }\\n        \\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0, k = n - 1, left = 0, right= 0, top = 0, bottom = 0; j < n; j++, k--) {\\n            grid[i][j] = min(grid[i][j], left = (grid[i][j] == 0 ? 0 : left + 1));\\n            grid[i][k] = min(grid[i][k], right = (grid[i][k] == 0 ? 0 : right + 1));\\n            grid[j][i] = min(grid[j][i], top = (grid[j][i] == 0 ? 0 : top + 1));\\n            grid[k][i] = min(grid[k][i], bottom = (grid[k][i] == 0 ? 0 : bottom + 1));\\n        }\\n    }\\n        \\n    int mxorder = 0;\\n        \\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            mxorder = max(mxorder, grid[i][j]);\\n        }\\n    }\\n        \\n    return mxorder;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(N, vector<int>(N, 1));\\n        for(auto &p: mines){\\n            grid[p[0]][p[1]] = 0;\\n        }\\n        \\n        auto all_ones = [&](int i, int j, int k){\\n            if(i - k < 0 || i + k >= N || j - k < 0 || j + k >= N)\\n                return false;\\n            return grid[i - k][j] && grid[i + k][j] && grid[i][j - k] && grid[i][j + k];\\n        };\\n        int K = 0;\\n        for(int i = 0; i < N; ++i){\\n            for(int j = 0; j < N; ++j){\\n                if(grid[i][j] == 1){\\n                    int k = 1;\\n                    while(all_ones(i, j, k))\\n                        ++k;\\n                    K = max(k, K);\\n                }\\n            }\\n        }\\n        return K;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276884,
                "title": "different-take-sorting-mines-to-eliminate-searches-beats-100-java-by-a-wide-margin",
                "content": "Admittedly this version takes more storage than the solutions that cleverly use a single 2D array to store the minimum results of 4 simultaneous scans for the longest legs in each of 4 directions, but it represents a more direct way to compute the \"longest legs\" than a scan.\\n\\nMy concept was to store the longest horizontal and vertical cross-sections rather than separate up/down/left/right legs.  This is done by first creating sorted lists of mines on each row and column.  Then we can visit every pair of mines and fill the space between them concentrically from the mines towards the center between them with increasing values.  This involves 3 steps:\\n\\n**Step 1 - sorting mines**\\nI create 2 arrays of PriorityQueues to sort the mines. This is probably overkill for most mine setups as it will be fairly sparse, but it simplified the code.\\n\\n**Step 2 - filling in h/v crossbar sizes**\\nIt would be more space efficient to do this in the same grid for each direction, but that would mean either initializing both grids to \"N\" and then doing a \"min()\" operation as we fill the grids first by row and then by col, or letting the first pass fill them using assignment and then the second pass needing to do the \"min()\" operation on every fill.  It simplified the code somewhat to simply fill 2 separate grids from the 2 separate lists of sorted mines and then do a final pass finding the minimum intersections between the two.  Note that the row grid is oriented as you would expect ```grid[r][c]```, but the columns grid is transposed, as in ```grid[c][r]```. This allows both grids to be constructed by the same shared code for simplicity.\\n\\nThe filling operations are done by reading out the sorted list of mines on every row (or column) and then filling concentrically between each pair of mines.  The first mine is also filled from the left/top edge and the last mine also fills to the right/bottom edge using the same concentric fill.\\n\\nA concentric fill is starting at both ends and fillling a 1 first, then moving both ends towards each other and filling with higher and higher numbers until the ends meet in the middle. In this case, the endpoints are specified as exclusive indices so the \"bumping the ends towards each other\" happens before the increasing distance is stored.\\n\\n**Step 3 - min/maxing the cross sizes**\\nThe last step simply involves iterating over the two grids, comparing the longest horizontal and vertical crossbars possible at any given position and returning the largest such cross.\\n\\n**Complexity**\\nThis has a very similar O(N^2) complexity to most solutions with the only distinction being that inserting the mines into the PriorityQueues could potentially increase the work for very unfortunately constructed lists of mines.  There is one pass over the mines to insert them into the 2 queue lists.  Then there are N^2 passes over each of the ```byrows``` and ```bycols``` grids, and finally there is one last N^2 pass over the pair of grids looking for a min/max.\\n\\nThe total running time is much shorter than the shortest recorded Java solutions, though, and it\\'s not clear why this is in general, but I can speculate how it might be this way due to the way the test cases might be constructed.\\n\\nFirst, the insertion of the mine coordinates into the PriorityQueues could perform poorly if there are a lot of mines and/or the mines come in out of order, but I\\'m guessing the test cases are focused more on the scan for cross pieces than on the processing of the mines so there are probably a lot of examples with a large ```N``` value, but a small number or a sparse distribution of mines.\\n\\nSecond, many of the solutions scan in 4 directions for the shortest arm of the cross.  That means there are 4 N^2 scans that happen in the end, but my solution only uses 3 of them (1 for constructing ```byrows```, 1 for constructing ```bycols```, and 1 for iterating and min/maxing). Also, many of those will do min() operations at each grid location because they are accumulating the minimum leg for each of 4 directions.  That technique results in 4xN^2 calls to a ```min()``` function. My solution avoids nearly all of those mins by directly constructing the distance to the nearest mine in both left/right at the same time and both up/down at the same time with no need to call a ```min()``` function.  It does use a single call to ```min()``` per grid element in the final scan, though.  All in all, this solution reduces 4N^2 scans with 4N^2 calls to ```min()``` down to 3N^2 scans and N^2 calls to ```min()```.\\n\\n**Possible optimizations**\\nOne optimization could be to use the same grid for the lengths of the longest horizontal and vertical crossbars.  This could be done by either preinitializing the grid to all values of N and then to use ```min()``` operations as it is filled - increasing the compute time by requiring another pass of ```min()``` calls, but removing one of the grid storage spaces.\\n\\nA similar optimization would reduce the amount of shared code by having the first pass that fills the grid with the horizontal crossbar lengths do a direct assignment rather than a ```min()``` operation and then having a very similar piece of code handle the second pass for the vertical crossbar lengths, but do a ```min()``` operation as it fills in the values.  This should not increase the time complexity because we eventually do that ```min()``` operation in the final pass anyway, but it would mean a bit of code duplication.\\n\\n```\\n    void insert(PriorityQueue<Integer> vals[], int r, int c) {\\n        PriorityQueue<Integer> row = vals[r];\\n        if (row == null) {\\n            vals[r] = row = new PriorityQueue<>();\\n        }\\n        row.add(c);\\n    }\\n    void fill(int row[], int c0, int c1) {\\n        int i = 0;\\n        while (++c0 <= --c1) {\\n            row[c0] = row[c1] = ++i;\\n        }\\n    }\\n    int[][] toGrid(PriorityQueue<Integer> list[]) {\\n        int N = list.length;\\n        int grid[][] = new int[N][N];\\n        for (int r = 0; r < N; r++) {\\n            int prev = -1;\\n            if (list[r] != null) {\\n                for (int c : list[r]) {\\n                    fill(grid[r], prev, c);\\n                    prev = c;\\n                }\\n            }\\n            fill(grid[r], prev, N);\\n        }\\n        return grid;\\n    }\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        PriorityQueue<Integer> rows[] = new PriorityQueue[N];\\n        PriorityQueue<Integer> cols[] = new PriorityQueue[N];\\n        for (int mine[] : mines) {\\n            insert(rows, mine[0], mine[1]);\\n            insert(cols, mine[1], mine[0]);\\n        }\\n        int byrows[][] = toGrid(rows);\\n        int bycols[][] = toGrid(cols);\\n        int biggest = 0;\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                int order = Math.min(byrows[r][c], bycols[c][r]);\\n                if (biggest < order) biggest = order;\\n            }\\n        }\\n        return biggest;\\n    }\\n```",
                "solutionTags": [],
                "code": "```grid[r][c]```\n```grid[c][r]```\n```byrows```\n```bycols```\n```N```\n```byrows```\n```bycols```\n```min()```\n```min()```\n```min()```\n```min()```\n```min()```\n```min()```\n```min()```\n```min()```\n```min()```\n```min()```\n```\\n    void insert(PriorityQueue<Integer> vals[], int r, int c) {\\n        PriorityQueue<Integer> row = vals[r];\\n        if (row == null) {\\n            vals[r] = row = new PriorityQueue<>();\\n        }\\n        row.add(c);\\n    }\\n    void fill(int row[], int c0, int c1) {\\n        int i = 0;\\n        while (++c0 <= --c1) {\\n            row[c0] = row[c1] = ++i;\\n        }\\n    }\\n    int[][] toGrid(PriorityQueue<Integer> list[]) {\\n        int N = list.length;\\n        int grid[][] = new int[N][N];\\n        for (int r = 0; r < N; r++) {\\n            int prev = -1;\\n            if (list[r] != null) {\\n                for (int c : list[r]) {\\n                    fill(grid[r], prev, c);\\n                    prev = c;\\n                }\\n            }\\n            fill(grid[r], prev, N);\\n        }\\n        return grid;\\n    }\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        PriorityQueue<Integer> rows[] = new PriorityQueue[N];\\n        PriorityQueue<Integer> cols[] = new PriorityQueue[N];\\n        for (int mine[] : mines) {\\n            insert(rows, mine[0], mine[1]);\\n            insert(cols, mine[1], mine[0]);\\n        }\\n        int byrows[][] = toGrid(rows);\\n        int bycols[][] = toGrid(cols);\\n        int biggest = 0;\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                int order = Math.min(byrows[r][c], bycols[c][r]);\\n                if (biggest < order) biggest = order;\\n            }\\n        }\\n        return biggest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2638309,
                "title": "c-simple-time-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n,vector<int>(n,1));\\n        for(auto &i: mines){\\n            grid[i[0]][i[1]] = 0;\\n        }\\n        vector<vector<int>> left,right,top,bottom;\\n        left = vector<vector<int>>(n,vector<int>(n,0));\\n        right = vector<vector<int>>(n,vector<int>(n,0));\\n        top = vector<vector<int>>(n,vector<int>(n,0));\\n        bottom = vector<vector<int>>(n,vector<int>(n,0));\\n        int i,j;\\n        // for(auto &i: grid){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                if(j==0){\\n                    left[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    left[i][j] = left[i][j-1]+1;\\n                }\\n               // cout<<left[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        //cout<<endl;\\n        for(i = 0; i < n; i++){\\n            for(j = n-1; j >= 0; j--){\\n                if(j==n-1){\\n                    right[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    right[i][j] =1+ right[i][j+1];\\n                }\\n                \\n               // cout<<right[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }//cout<<endl;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                if(i==0){\\n                    top[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    top[i][j] +=1+ top[i-1][j];\\n                }\\n               // cout<<top[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }//cout<<endl;\\n        for(i = n-1; i >= 0; i--){\\n            for(j = 0; j < n; j++){\\n                if(i==n-1){\\n                    bottom[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    bottom[i][j] +=1+ bottom[i+1][j];\\n                }\\n                // cout<<bottom[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                ans = max(ans,min(min(left[i][j],right[i][j]),min(top[i][j],bottom[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n,vector<int>(n,1));\\n        for(auto &i: mines){\\n            grid[i[0]][i[1]] = 0;\\n        }\\n        vector<vector<int>> left,right,top,bottom;\\n        left = vector<vector<int>>(n,vector<int>(n,0));\\n        right = vector<vector<int>>(n,vector<int>(n,0));\\n        top = vector<vector<int>>(n,vector<int>(n,0));\\n        bottom = vector<vector<int>>(n,vector<int>(n,0));\\n        int i,j;\\n        // for(auto &i: grid){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                if(j==0){\\n                    left[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    left[i][j] = left[i][j-1]+1;\\n                }\\n               // cout<<left[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        //cout<<endl;\\n        for(i = 0; i < n; i++){\\n            for(j = n-1; j >= 0; j--){\\n                if(j==n-1){\\n                    right[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    right[i][j] =1+ right[i][j+1];\\n                }\\n                \\n               // cout<<right[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }//cout<<endl;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                if(i==0){\\n                    top[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    top[i][j] +=1+ top[i-1][j];\\n                }\\n               // cout<<top[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }//cout<<endl;\\n        for(i = n-1; i >= 0; i--){\\n            for(j = 0; j < n; j++){\\n                if(i==n-1){\\n                    bottom[i][j] = (grid[i][j]);\\n                }else if(grid[i][j]){\\n                    bottom[i][j] +=1+ bottom[i+1][j];\\n                }\\n                // cout<<bottom[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                ans = max(ans,min(min(left[i][j],right[i][j]),min(top[i][j],bottom[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1820407,
                "title": "c-easy-understandable-code-with-comments-o-n-2",
                "content": "**Brute Force approach**\\n- In  the brute approach we can try each cell(r,c) as potential plus center then expand left, right, bottom, top and among then compute minimum distance. \\n- Brute force approach will be inefficient having T.C. O(n^3)\\n\\n**Dynamic Programming**\\n- In this approach we take a dp matrix.\\n- here we count continuos 1s in four directions and store minimum in dp\\n\\n<hr>\\n\\n**Please Upvote. Thanks:)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void computeOrderOfPlus(vector<vector<int>>& grid, vector<vector<int>>& dp, int n){\\n        \\n        int leftToRight = 0, topToBottom = 0, rightToBottom = 0, bottomToTop = 0;\\n        \\n        for(int i=0; i<n; ++i){\\n            leftToRight = 0, topToBottom = 0; // reset value becuase we restarting counting for each row\\n            for(int j=0; j<n; ++j){\\n                // calcualte continuous 1s present left to current cell until zero\\n                leftToRight = grid[i][j] ? leftToRight+1 : 0;\\n                dp[i][j] = min(dp[i][j], leftToRight);\\n                \\n                // calcualte continuous 1s present top till current cell until zero\\n                topToBottom = grid[j][i] ? topToBottom+1 : 0; // here cell ( j, i ) because we compute top to bottom.\\n                dp[j][i] = min(dp[j][i], topToBottom);\\n            }\\n        }\\n        \\n        for(int i=0; i<n; ++i){\\n            rightToBottom = 0, bottomToTop = 0;\\n            for(int j=n-1; j>=0; --j){\\n                // calcualte continuous 1s present right to current cell\\n                rightToBottom = grid[i][j] ? rightToBottom+1 : 0;\\n                dp[i][j] = min(dp[i][j], rightToBottom);\\n                \\n                // calcualte continuous 1s present bottom till current cell\\n                bottomToTop = grid[j][i] ? bottomToTop+1 : 0; // here cell ( j, i ) because we compute bottom to top\\n                dp[j][i] = min(dp[j][i], bottomToTop); \\n            }\\n        }\\n    }\\n    \\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n, vector<int>(n, 1));//prefill with 1s\\n        vector<vector<int>> dp(n, vector<int>(n, INT_MAX));// initialize with max value so later will update with minimum left, right, top, bottom distance\\n        \\n        for(auto mine: mines){\\n            grid[mine.at(0)][mine.at(1)] = 0; // fill grid with zero\\n        }\\n        \\n        computeOrderOfPlus(grid, dp, n);\\n        // fillDP(dp, grid, n);\\n        \\n        int res = 0;\\n        // get the maximum value from dp matrix\\n        for(auto row: dp){\\n            for(auto ele : row){\\n                res = max(res, ele);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void computeOrderOfPlus(vector<vector<int>>& grid, vector<vector<int>>& dp, int n){\\n        \\n        int leftToRight = 0, topToBottom = 0, rightToBottom = 0, bottomToTop = 0;\\n        \\n        for(int i=0; i<n; ++i){\\n            leftToRight = 0, topToBottom = 0; // reset value becuase we restarting counting for each row\\n            for(int j=0; j<n; ++j){\\n                // calcualte continuous 1s present left to current cell until zero\\n                leftToRight = grid[i][j] ? leftToRight+1 : 0;\\n                dp[i][j] = min(dp[i][j], leftToRight);\\n                \\n                // calcualte continuous 1s present top till current cell until zero\\n                topToBottom = grid[j][i] ? topToBottom+1 : 0; // here cell ( j, i ) because we compute top to bottom.\\n                dp[j][i] = min(dp[j][i], topToBottom);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1455027,
                "title": "c-4-approaches-just-like-how-an-interview-goes",
                "content": "See the HINGLISH explanation on my LinkedIn page : https://www.linkedin.com/groups/12559380/\\n\\n```\\n//Approach-0 (Brute Force - Naive approach which comes to our mind instantly) O(n^3)\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> t(n, vector<int>(n, 1));\\n        \\n        for(vector<int>& vec : mines) {\\n            t[vec[0]][vec[1]] = 0;\\n        }\\n        \\n        int maxC = 0;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n\\t\\t\\t\\t//As soon as you see one, find 1 to its left, right, top and bottom\\n                if(t[i][j] == 1) {\\n                    int k = j+1;\\n                    int right = 0, left = 0, up = 0, down = 0;\\n                    while(k < n && t[i][k] == 1) {\\n                        k++;\\n                        right++;\\n                    }\\n                    \\n                    k = j-1;\\n                    while(k >= 0 && t[i][k] == 1) {\\n                        k--;\\n                        left++;\\n                    }\\n                    \\n                    k = i-1;\\n                    while(k >= 0 && t[k][j] == 1) {\\n                        k--;\\n                        up++;\\n                    }\\n                    \\n                    k = i+1;\\n                    while(k < n && t[k][j] == 1) {\\n                        k++;\\n                        down++;\\n                    }\\n                    \\n                    int minL = min({left, right, up, down});\\n                    maxC = max(maxC, minL+1);\\n                }\\n            }\\n        }\\n        return maxC;\\n    }\\n};\\n```\\n\\n```\\n//Approach-1 (Improving your brute force) O(n^3)\\n/Approach-1 (Brute Force : O(n^3))\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        if(n*n == mines.size())\\n            return 0;\\n        \\n        int t[n][n];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                t[i][j] = 1;\\n            }\\n        }\\n        \\n        for(vector<int>& vec : mines)\\n            t[vec[0]][vec[1]] = 0;\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(t[i][j] == 0) continue;\\n                \\n                //Taking [i][j] as center try to expand it (up, down, left, right)\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tup = i-expand\\n\\t\\t\\t\\t\\tdown = i + expand\\n\\t\\t\\t\\t\\tleft = j - expand\\n\\t\\t\\t\\t\\tright = j + expand\\n\\t\\t\\t\\t*/\\n                int expand = 0;\\n                while(true) {\\n                    expand++;\\n                    if(i - expand < 0 || j - expand < 0 || i + expand >= n || j + expand >= n)\\n                        break;\\n                    \\n                    if(t[i-expand][j] == 0 || t[i][j-expand] == 0 || t[i+expand][j] == 0 || t[i][j+expand] == 0)\\n                        break;\\n                }\\n                \\n                ans = max(ans, expand);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Dynamic Programming, Time : O(n^2), Space : O(n^2))\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> t(n, vector<int>(n, 1));\\n        for(vector<int>& vec : mines) {\\n            t[vec[0]][vec[1]] = 0;\\n        }\\n        \\n        int ans = 0;\\n        vector<vector<int>> left, right, top, bottom;\\n        /*\\n            left[i][j]  = count of 1s in the left direction of t[i][j]\\n            right[i][j] = count of 1s in the right direction of t[i][j]\\n            so on..\\n        */\\n        left = right = top = bottom = t;\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i > 0 && top[i][j]) top[i][j] += top[i-1][j];\\n                if(j > 0 && left[i][j])  left[i][j]  += left[i][j-1];\\n                \\n                /*\\n                    You can write a seperate loop for filling right and bottom\\n                    Because in right and bottom you will have to traverse from\\n                    bottom right to top\\n                    BUT, you can manipulate the index here only to achieve that\\n                */\\n                \\n                /*\\n                    As i moves from top to down, j moves from left to right\\n                    \\n                    n-i-1 will move from bottom to up\\n                    n-j-1 will move from right to left\\n                */\\n                int x = n-i-1;\\n                int y = n-j-1;\\n                if(x < n-1 && bottom[x][y]) bottom[x][y] += bottom[x+1][y];\\n                if(y < n-1 && right[x][y])  right[x][y]   += right[x][y+1];\\n            }\\n        }\\n        \\n        /*\\n            Now, for any i and j, we need to find the minimum of its (left, right, bottom and up)\\n            And among all those minimum, we need to find the maximum\\n        */\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int minL = min({left[i][j], right[i][j], top[i][j], bottom[i][j]});\\n                ans = max(ans, minL);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Dynamic Programming, Time : O(n^2), Space : O(n^2)\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        if(n*n == mines.size())\\n            return 0;\\n        \\n        int t[n][n];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                t[i][j] = n;\\n            }\\n        }\\n        \\n        for(vector<int>& vec : mines)\\n            t[vec[0]][vec[1]] = 0;\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            //t[][] will be updated to minimum of its left, right, up and down (count of 1s)\\n            \\n            //Look for longest streak of 1 at its left\\n            int left = 0;\\n            for(int j = 0; j < n; j++) {\\n                left = t[i][j] == 0 ? 0 : left+1;\\n                t[i][j] = min(t[i][j], left);\\n            }\\n            \\n            //Look for longest streak of 1 at its right\\n            int right = 0;\\n            for(int j = n-1; j>=0; j--) {\\n                right = t[i][j] == 0 ? 0 : right+1;\\n                t[i][j] = min(t[i][j], right);\\n            }\\n            \\n            //Look for longest streak of 1 at its up\\n            int up = 0;\\n            for(int k = 0; k < n; k++) {\\n                up = t[k][i] == 0 ? 0 : up+1;\\n                t[k][i] = min(t[k][i], up);\\n            }\\n            \\n            //Look for longest streak of 1 at its down\\n            int down = 0;\\n            for(int k = n-1; k >= 0; k--) {\\n                down = t[k][i] == 0 ? 0 : down+1;\\n                t[k][i] = min(t[k][i], down);\\n            }\\n        }\\n        \\n        //Finally, find the max one\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans = max(ans, t[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-0 (Brute Force - Naive approach which comes to our mind instantly) O(n^3)\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> t(n, vector<int>(n, 1));\\n        \\n        for(vector<int>& vec : mines) {\\n            t[vec[0]][vec[1]] = 0;\\n        }\\n        \\n        int maxC = 0;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n\\t\\t\\t\\t//As soon as you see one, find 1 to its left, right, top and bottom\\n                if(t[i][j] == 1) {\\n                    int k = j+1;\\n                    int right = 0, left = 0, up = 0, down = 0;\\n                    while(k < n && t[i][k] == 1) {\\n                        k++;\\n                        right++;\\n                    }\\n                    \\n                    k = j-1;\\n                    while(k >= 0 && t[i][k] == 1) {\\n                        k--;\\n                        left++;\\n                    }\\n                    \\n                    k = i-1;\\n                    while(k >= 0 && t[k][j] == 1) {\\n                        k--;\\n                        up++;\\n                    }\\n                    \\n                    k = i+1;\\n                    while(k < n && t[k][j] == 1) {\\n                        k++;\\n                        down++;\\n                    }\\n                    \\n                    int minL = min({left, right, up, down});\\n                    maxC = max(maxC, minL+1);\\n                }\\n            }\\n        }\\n        return maxC;\\n    }\\n};\\n```\n```\\n//Approach-1 (Improving your brute force) O(n^3)\\n/Approach-1 (Brute Force : O(n^3))\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        if(n*n == mines.size())\\n            return 0;\\n        \\n        int t[n][n];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                t[i][j] = 1;\\n            }\\n        }\\n        \\n        for(vector<int>& vec : mines)\\n            t[vec[0]][vec[1]] = 0;\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(t[i][j] == 0) continue;\\n                \\n                //Taking [i][j] as center try to expand it (up, down, left, right)\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tup = i-expand\\n\\t\\t\\t\\t\\tdown = i + expand\\n\\t\\t\\t\\t\\tleft = j - expand\\n\\t\\t\\t\\t\\tright = j + expand\\n\\t\\t\\t\\t*/\\n                int expand = 0;\\n                while(true) {\\n                    expand++;\\n                    if(i - expand < 0 || j - expand < 0 || i + expand >= n || j + expand >= n)\\n                        break;\\n                    \\n                    if(t[i-expand][j] == 0 || t[i][j-expand] == 0 || t[i+expand][j] == 0 || t[i][j+expand] == 0)\\n                        break;\\n                }\\n                \\n                ans = max(ans, expand);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Approach-2 (Dynamic Programming, Time : O(n^2), Space : O(n^2))\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> t(n, vector<int>(n, 1));\\n        for(vector<int>& vec : mines) {\\n            t[vec[0]][vec[1]] = 0;\\n        }\\n        \\n        int ans = 0;\\n        vector<vector<int>> left, right, top, bottom;\\n        /*\\n            left[i][j]  = count of 1s in the left direction of t[i][j]\\n            right[i][j] = count of 1s in the right direction of t[i][j]\\n            so on..\\n        */\\n        left = right = top = bottom = t;\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i > 0 && top[i][j]) top[i][j] += top[i-1][j];\\n                if(j > 0 && left[i][j])  left[i][j]  += left[i][j-1];\\n                \\n                /*\\n                    You can write a seperate loop for filling right and bottom\\n                    Because in right and bottom you will have to traverse from\\n                    bottom right to top\\n                    BUT, you can manipulate the index here only to achieve that\\n                */\\n                \\n                /*\\n                    As i moves from top to down, j moves from left to right\\n                    \\n                    n-i-1 will move from bottom to up\\n                    n-j-1 will move from right to left\\n                */\\n                int x = n-i-1;\\n                int y = n-j-1;\\n                if(x < n-1 && bottom[x][y]) bottom[x][y] += bottom[x+1][y];\\n                if(y < n-1 && right[x][y])  right[x][y]   += right[x][y+1];\\n            }\\n        }\\n        \\n        /*\\n            Now, for any i and j, we need to find the minimum of its (left, right, bottom and up)\\n            And among all those minimum, we need to find the maximum\\n        */\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int minL = min({left[i][j], right[i][j], top[i][j], bottom[i][j]});\\n                ans = max(ans, minL);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n//Approach-3 (Dynamic Programming, Time : O(n^2), Space : O(n^2)\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        if(n*n == mines.size())\\n            return 0;\\n        \\n        int t[n][n];\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                t[i][j] = n;\\n            }\\n        }\\n        \\n        for(vector<int>& vec : mines)\\n            t[vec[0]][vec[1]] = 0;\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            //t[][] will be updated to minimum of its left, right, up and down (count of 1s)\\n            \\n            //Look for longest streak of 1 at its left\\n            int left = 0;\\n            for(int j = 0; j < n; j++) {\\n                left = t[i][j] == 0 ? 0 : left+1;\\n                t[i][j] = min(t[i][j], left);\\n            }\\n            \\n            //Look for longest streak of 1 at its right\\n            int right = 0;\\n            for(int j = n-1; j>=0; j--) {\\n                right = t[i][j] == 0 ? 0 : right+1;\\n                t[i][j] = min(t[i][j], right);\\n            }\\n            \\n            //Look for longest streak of 1 at its up\\n            int up = 0;\\n            for(int k = 0; k < n; k++) {\\n                up = t[k][i] == 0 ? 0 : up+1;\\n                t[k][i] = min(t[k][i], up);\\n            }\\n            \\n            //Look for longest streak of 1 at its down\\n            int down = 0;\\n            for(int k = n-1; k >= 0; k--) {\\n                down = t[k][i] == 0 ? 0 : down+1;\\n                t[k][i] = min(t[k][i], down);\\n            }\\n        }\\n        \\n        //Finally, find the max one\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans = max(ans, t[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454150,
                "title": "question-about-largest-plus-sign",
                "content": "Hi, I am trying to solve the problem. \\nOne of my submission says I have a wrong expected answer. \\n\\nThe input is \\n```\\n2\\n[[0,0],[0,1],[1,0]]\\n```\\nThe expected answer is `1` \\n\\nI don\\'t understand how this is possible. \\nHow can you have a plus sign with lengths and widths 2? \\n\\nSomeone please explain this to me.\\n\\n![image](https://assets.leetcode.com/users/images/3cd1bab8-ba22-47ce-925b-37170fd5dddb_1631215104.788658.png)\\n\\nAnswer: \\n\\nAfter testing and trying for a while, my understanding is that: \\n` 1 <= mines <= 5000` \\nSo when `n = 1` `mines = 1` , meaning max order = `0` \\nBut when `n = 2` the order can be `1`, which leaves with the center and nothing else. \\n\\nBut how is this a plus sign though... \\nIt\\'s just one dot. \\nI argue that `n >=3` in order for a plus sign to exist. \\nCorrect me if I\\'m wrong.",
                "solutionTags": [],
                "code": "```\\n2\\n[[0,0],[0,1],[1,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454145,
                "title": "simple-code-dp-o-n-2-time-space-python",
                "content": "Naive Approach will go to every index, run while loop to top,bottom,left,right and find count of one for each. Minimum of those count gives largest size of + for that index. Then , we need to maximize the answer. \\n\\nRead the comments above each for loop to know its functionality. This is Dp approach that runs in O(N^2) Time complexity and O(N^2) Space complexity.\\n\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        \\n        #creating matrix\\n        mine=[[1]*n for i in range(n)]\\n        for i in mines:\\n            mine[i[0]][i[1]]=0\\n        mines=mine\\n        \\n        x=[[[0,0,0,0] for k in range(n)] for i in range(n)]\\n        #top,bottom,left,right\\n        \\n        # initializing top and left of (0,0)th element\\n        if(mines[0][0]==1):\\n            x[0][0]=[1,0,1,0]\\n            \\n        answer=0\\n        \\n        # initializing top and left of 1st row elements\\n        for i in range(1,n):\\n            if(mines[0][i]==1):\\n                x[0][i][2]=x[0][i-1][2]+1\\n                x[0][i][0]=1\\n                answer=1\\n        \\n        # initializing top and left of 1st column elements\\n        for i in range(1,n):\\n            if(mines[i][0]==1):\\n                x[i][0][0]=x[i-1][0][0]+1\\n                x[i][0][2]=1\\n                answer=1\\n               \\n        # initializing bottom and right of (-1,-1)th element\\n        # increment instead of [0,1,0,1] coz it may fail for matrix size n=1\\n        if(mines[-1][-1]==1):\\n            x[-1][-1][1]+=1\\n            x[-1][-1][3]+=1\\n            answer=1\\n            \\n        # initializing bottom and right of last row elements\\n        for i in range(n-2,-1,-1):\\n            if(mines[-1][i]==1):\\n                x[-1][i][3]=x[-1][i+1][3]+1\\n                x[-1][i][1]=1\\n                answer=1\\n              \\n        # initializing bottom and right of last column elements\\n        for i in range(n-2,-1,-1):\\n            if(mines[i][-1]==1):\\n                x[i][-1][1]=x[i+1][-1][1]+1\\n                x[i][-1][3]=1\\n                answer=1\\n                \\n        # updating top and left of last n-1 row elements in top-down approach\\n        for i in range(1,n):\\n            for j in range(1,n):\\n                if(mines[i][j]==1):\\n                    x[i][j][0]=x[i-1][j][0]+1\\n                    answer=1\\n                if(mines[i][j]==1):\\n                    x[i][j][2]=x[i][j-1][2]+1\\n                    answer=1\\n        \\n        # updating bottom and right of first n-1 row elements in bottom up approach\\n        for i in range(n-2,-1,-1):\\n            for j in range(n-2,-1,-1):\\n                if(mines[i][j]==1):\\n                    x[i][j][1]=x[i+1][j][1]+1\\n                if(mines[i][j]==1):\\n                    x[i][j][3]=x[i][j+1][3]+1\\n                answer=max(answer,min(x[i][j]))\\n            \\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        \\n        #creating matrix\\n        mine=[[1]*n for i in range(n)]\\n        for i in mines:\\n            mine[i[0]][i[1]]=0\\n        mines=mine\\n        \\n        x=[[[0,0,0,0] for k in range(n)] for i in range(n)]\\n        #top,bottom,left,right\\n        \\n        # initializing top and left of (0,0)th element\\n        if(mines[0][0]==1):\\n            x[0][0]=[1,0,1,0]\\n            \\n        answer=0\\n        \\n        # initializing top and left of 1st row elements\\n        for i in range(1,n):\\n            if(mines[0][i]==1):\\n                x[0][i][2]=x[0][i-1][2]+1\\n                x[0][i][0]=1\\n                answer=1\\n        \\n        # initializing top and left of 1st column elements\\n        for i in range(1,n):\\n            if(mines[i][0]==1):\\n                x[i][0][0]=x[i-1][0][0]+1\\n                x[i][0][2]=1\\n                answer=1\\n               \\n        # initializing bottom and right of (-1,-1)th element\\n        # increment instead of [0,1,0,1] coz it may fail for matrix size n=1\\n        if(mines[-1][-1]==1):\\n            x[-1][-1][1]+=1\\n            x[-1][-1][3]+=1\\n            answer=1\\n            \\n        # initializing bottom and right of last row elements\\n        for i in range(n-2,-1,-1):\\n            if(mines[-1][i]==1):\\n                x[-1][i][3]=x[-1][i+1][3]+1\\n                x[-1][i][1]=1\\n                answer=1\\n              \\n        # initializing bottom and right of last column elements\\n        for i in range(n-2,-1,-1):\\n            if(mines[i][-1]==1):\\n                x[i][-1][1]=x[i+1][-1][1]+1\\n                x[i][-1][3]=1\\n                answer=1\\n                \\n        # updating top and left of last n-1 row elements in top-down approach\\n        for i in range(1,n):\\n            for j in range(1,n):\\n                if(mines[i][j]==1):\\n                    x[i][j][0]=x[i-1][j][0]+1\\n                    answer=1\\n                if(mines[i][j]==1):\\n                    x[i][j][2]=x[i][j-1][2]+1\\n                    answer=1\\n        \\n        # updating bottom and right of first n-1 row elements in bottom up approach\\n        for i in range(n-2,-1,-1):\\n            for j in range(n-2,-1,-1):\\n                if(mines[i][j]==1):\\n                    x[i][j][1]=x[i+1][j][1]+1\\n                if(mines[i][j]==1):\\n                    x[i][j][3]=x[i][j+1][3]+1\\n                answer=max(answer,min(x[i][j]))\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453956,
                "title": "my-solution-java-easy-accepted-time-space-o-n-2",
                "content": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n        return method1(n,mines);\\n        \\n    }\\n    \\n    private int method1(int n,int[][] mines){\\n        \\n        int[][] mat = new int[n][n];\\n        for(int[] arr:mat){\\n            Arrays.fill(arr,1);\\n        }\\n        for(int[] mine:mines){\\n            mat[mine[0]][mine[1]]=0;\\n        }\\n        \\n        int maxOrder=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(mat[i][j]==1){\\n                    int order=1;\\n                    \\n                    while(true){\\n                        int left = j-order;\\n                        int right = j+order;\\n                        int top = i-order;\\n                        int down = i+order;\\n                        \\n                        if(left<0||right>=n||top<0||down>=n||\\n                           mat[i][right]==0||mat[i][left]==0||mat[top][j]==0||mat[down][j]==0){\\n                            break;\\n                        }\\n                        order++;\\n                        \\n                    }\\n                    \\n                    maxOrder = Math.max(maxOrder,order);\\n                }\\n            }\\n        }\\n        return maxOrder;\\n        \\n        \\n    }\\n}\\n```\\n**do upvote, if you like my approach**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n        return method1(n,mines);\\n        \\n    }\\n    \\n    private int method1(int n,int[][] mines){\\n        \\n        int[][] mat = new int[n][n];\\n        for(int[] arr:mat){\\n            Arrays.fill(arr,1);\\n        }\\n        for(int[] mine:mines){\\n            mat[mine[0]][mine[1]]=0;\\n        }\\n        \\n        int maxOrder=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(mat[i][j]==1){\\n                    int order=1;\\n                    \\n                    while(true){\\n                        int left = j-order;\\n                        int right = j+order;\\n                        int top = i-order;\\n                        int down = i+order;\\n                        \\n                        if(left<0||right>=n||top<0||down>=n||\\n                           mat[i][right]==0||mat[i][left]==0||mat[top][j]==0||mat[down][j]==0){\\n                            break;\\n                        }\\n                        order++;\\n                        \\n                    }\\n                    \\n                    maxOrder = Math.max(maxOrder,order);\\n                }\\n            }\\n        }\\n        return maxOrder;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146999,
                "title": "c-dp-solution",
                "content": "Same implementation as given in solution. Just in C++\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        set<int> banned;\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        for(int i=0;i<mines.size();i++) {\\n            banned.insert(mines[i][0]*n + mines[i][1]);\\n        }\\n        int ans=0,count=0;\\n\\n        for(int i=0;i<n;i++) {\\n            count =0;\\n            for(int j=0;j<n;j++) {\\n                count = (banned.find(i*n+j)!=banned.end()) ? 0 : count+1;\\n                dp[i][j] = count;\\n            }\\n            count =0;\\n            for(int j=n-1;j>=0;j--) {\\n                count = (banned.find(i*n+j) != banned.end()) ? 0 : count+1;\\n                dp[i][j] = min(dp[i][j] , count);\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            count=0;\\n            for(int i=0;i<n;i++) {\\n                count = (banned.find(i*n+j)!=banned.end()) ? 0 : count+1;\\n                dp[i][j] = min(dp[i][j],count);\\n            }\\n            count=0;\\n             for(int i=n-1;i>=0;i--) {\\n                count = (banned.find(i*n+j) != banned.end()) ? 0 : count+1;\\n                dp[i][j] = min(dp[i][j] , count);\\n                ans = max(ans , dp[i][j])  ; \\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        set<int> banned;\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        for(int i=0;i<mines.size();i++) {\\n            banned.insert(mines[i][0]*n + mines[i][1]);\\n        }\\n        int ans=0,count=0;\\n\\n        for(int i=0;i<n;i++) {\\n            count =0;\\n            for(int j=0;j<n;j++) {\\n                count = (banned.find(i*n+j)!=banned.end()) ? 0 : count+1;\\n                dp[i][j] = count;\\n            }\\n            count =0;\\n            for(int j=n-1;j>=0;j--) {\\n                count = (banned.find(i*n+j) != banned.end()) ? 0 : count+1;\\n                dp[i][j] = min(dp[i][j] , count);\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            count=0;\\n            for(int i=0;i<n;i++) {\\n                count = (banned.find(i*n+j)!=banned.end()) ? 0 : count+1;\\n                dp[i][j] = min(dp[i][j],count);\\n            }\\n            count=0;\\n             for(int i=n-1;i>=0;i--) {\\n                count = (banned.find(i*n+j) != banned.end()) ? 0 : count+1;\\n                dp[i][j] = min(dp[i][j] , count);\\n                ans = max(ans , dp[i][j])  ; \\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393943,
                "title": "compact-solution-in-python-3-nine-lines",
                "content": "_Compact Version:_\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, M: List[List[int]]) -> int:\\n    \\tDP, M, R, T, m = [[math.inf]*N for i in range(N)], {tuple(m) for m in M}, list(range(N)), (0,1), 0\\n    \\tfor k,i in itertools.product(T,R):\\n    \\t\\tfor _ in T:\\n    \\t\\t\\tc, I, _ = 0, i, R.reverse()\\n    \\t\\t\\tfor j in R:\\n    \\t\\t\\t\\tif k: i,j = j,i\\n    \\t\\t\\t\\tc = 0 if (i,j) in M else c + 1\\n    \\t\\t\\t\\tDP[i][j], i = min(DP[i][j],c), I\\n    \\treturn max(max(i) for i in DP)\\n\\t\\t\\n\\n```\\n_Long Version:_\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, M: List[List[int]]) -> int:\\n    \\tDP, M, m = [[0]*N for i in range(N)], {tuple(m) for m in M}, 0\\n    \\tfor i in range(N):\\n    \\t\\tc = 0\\n    \\t\\tfor j in range(N):\\n    \\t\\t\\tc = 0 if (i,j) in M else c + 1\\n    \\t\\t\\tDP[i][j] = c\\n    \\t\\tc = 0\\n    \\t\\tfor j in range(N-1,-1,-1):\\n    \\t\\t\\tc = 0 if (i,j) in M else c + 1\\n    \\t\\t\\tDP[i][j] = min(DP[i][j],c)  \\t\\t\\t\\n    \\tfor j in range(N):\\n    \\t\\tc = 0\\n    \\t\\tfor i in range(N):\\n    \\t\\t\\tc = 0 if (i,j) in M else c + 1\\n    \\t\\t\\tDP[i][j] = min(DP[i][j],c)\\n    \\t\\tc = 0\\n    \\t\\tfor i in range(N-1,-1,-1):\\n    \\t\\t\\tc = 0 if (i,j) in M else c + 1\\n    \\t\\t\\tm = max(m,min(DP[i][j],c))\\n    \\treturn m\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, M: List[List[int]]) -> int:\\n    \\tDP, M, R, T, m = [[math.inf]*N for i in range(N)], {tuple(m) for m in M}, list(range(N)), (0,1), 0\\n    \\tfor k,i in itertools.product(T,R):\\n    \\t\\tfor _ in T:\\n    \\t\\t\\tc, I, _ = 0, i, R.reverse()\\n    \\t\\t\\tfor j in R:\\n    \\t\\t\\t\\tif k: i,j = j,i\\n    \\t\\t\\t\\tc = 0 if (i,j) in M else c + 1\\n    \\t\\t\\t\\tDP[i][j], i = min(DP[i][j],c), I\\n    \\treturn max(max(i) for i in DP)\\n\\t\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170945,
                "title": "c-clean-code-using-4-matrices",
                "content": "```C++\\nclass Solution {\\npublic:\\n  int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n    vector<vector<int>> grid(N,vector<int> (N,1));\\n    vector<vector<int>> left(N,vector<int> (N,1)), right(N,vector<int> (N,1)), up(N,vector<int> (N,1)), down(N,vector<int> (N,1));\\n\\n    int ans = 0;\\n    for(auto& mine:mines) grid[mine.front()][mine.back()] = 0;\\n    for(int i = 0; i < N; i++){\\n      for(int j = 0; j < N; j++)\\n        if(j == 0) left[i][j] = grid[i][j];\\n        else left[i][j] = grid[i][j] == 0 ?0: left[i][j-1] + 1;\\n      for(int j = N - 1; j >= 0; j--)\\n        if(j == N -1) right[i][j] = grid[i][j];\\n        else right[i][j] = grid[i][j] == 0 ?0: right[i][j+1] + 1;\\n    }\\n    for(int j = 0; j < N; j++){\\n      for(int i = 0; i < N; i++)\\n        if( i == 0) up[i][j] = grid[i][j];\\n        else up[i][j] = grid[i][j] == 0? 0: up[i - 1][j] + 1;\\n      for(int i = N-1; i >=0; i--)\\n        if(i == N - 1) down[i][j] = grid[i][j];\\n        else down[i][j] = grid[i][j] == 0? 0: down[i+1][j] + 1;\\n    }\\n    for(int i = 0; i < N; i++)\\n      for(int j = 0; j < N; j++)\\n        grid[i][j] =min( min(up[i][j], down[i][j]), min(left[i][j],right[i][j]));\\n\\n\\n    for(int i = 0; i < N; i++)\\n      for(int j = 0; j < N; j++)\\n        ans = max(ans, grid[i][j]);\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n  int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n    vector<vector<int>> grid(N,vector<int> (N,1));\\n    vector<vector<int>> left(N,vector<int> (N,1)), right(N,vector<int> (N,1)), up(N,vector<int> (N,1)), down(N,vector<int> (N,1));\\n\\n    int ans = 0;\\n    for(auto& mine:mines) grid[mine.front()][mine.back()] = 0;\\n    for(int i = 0; i < N; i++){\\n      for(int j = 0; j < N; j++)\\n        if(j == 0) left[i][j] = grid[i][j];\\n        else left[i][j] = grid[i][j] == 0 ?0: left[i][j-1] + 1;\\n      for(int j = N - 1; j >= 0; j--)\\n        if(j == N -1) right[i][j] = grid[i][j];\\n        else right[i][j] = grid[i][j] == 0 ?0: right[i][j+1] + 1;\\n    }\\n    for(int j = 0; j < N; j++){\\n      for(int i = 0; i < N; i++)\\n        if( i == 0) up[i][j] = grid[i][j];\\n        else up[i][j] = grid[i][j] == 0? 0: up[i - 1][j] + 1;\\n      for(int i = N-1; i >=0; i--)\\n        if(i == N - 1) down[i][j] = grid[i][j];\\n        else down[i][j] = grid[i][j] == 0? 0: down[i+1][j] + 1;\\n    }\\n    for(int i = 0; i < N; i++)\\n      for(int j = 0; j < N; j++)\\n        grid[i][j] =min( min(up[i][j], down[i][j]), min(left[i][j],right[i][j]));\\n\\n\\n    for(int i = 0; i < N; i++)\\n      for(int j = 0; j < N; j++)\\n        ans = max(ans, grid[i][j]);\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113312,
                "title": "python-tle-dp-straighforward-approach-o-n-2",
                "content": "Not sure, if there is a better way, but Python was giving TLE, for the straighforward DP approach\\n\\n```\\n    def orderOfLargestPlusSign(self, N, mines):\\n        if N == 1: return 0 if mines else 1\\n        info = [[[0] * 4 for _ in range(N)] for _ in range(N)]\\n        res = 0\\n        s = {(mine[0], mine[1]) for mine in mines}\\n        \\n        for x in range(N):\\n            for y in range(N):\\n                if (x,y) not in s:\\n                    info[x][y][0], info[x][y][1] = 1, 1\\n                    if x-1 >= 0: info[x][y][0] = info[x-1][y][0] + 1 # UP\\n                    if y-1 >= 0: info[x][y][1] = info[x][y-1][1] + 1 # LEFT\\n\\n        for x in range(N-1, -1, -1):\\n            for y in range(N-1, -1, -1):\\n                if (x, y) not in s:\\n                    info[x][y][2], info[x][y][3] = 1, 1\\n                    if x+1 < N: info[x][y][2] = info[x+1][y][2] + 1 # DOWN\\n                    if y+1 < N: info[x][y][3] = info[x][y+1][3] + 1 # RIGHT\\n\\n                    temp = []\\n                    temp.append(info[x - 1][y][0] if x - 1 >= 0 else 0)\\n                    temp.append(info[x][y - 1][1] if y - 1 >= 0 else 0)\\n                    temp.append(info[x + 1][y][2] if x + 1 < N else 0)\\n                    temp.append(info[x][y + 1][3] if y + 1 < N else 0)\\n\\n                    res = max([min(temp) + 1, res])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def orderOfLargestPlusSign(self, N, mines):\\n        if N == 1: return 0 if mines else 1\\n        info = [[[0] * 4 for _ in range(N)] for _ in range(N)]\\n        res = 0\\n        s = {(mine[0], mine[1]) for mine in mines}\\n        \\n        for x in range(N):\\n            for y in range(N):\\n                if (x,y) not in s:\\n                    info[x][y][0], info[x][y][1] = 1, 1\\n                    if x-1 >= 0: info[x][y][0] = info[x-1][y][0] + 1 # UP\\n                    if y-1 >= 0: info[x][y][1] = info[x][y-1][1] + 1 # LEFT\\n\\n        for x in range(N-1, -1, -1):\\n            for y in range(N-1, -1, -1):\\n                if (x, y) not in s:\\n                    info[x][y][2], info[x][y][3] = 1, 1\\n                    if x+1 < N: info[x][y][2] = info[x+1][y][2] + 1 # DOWN\\n                    if y+1 < N: info[x][y][3] = info[x][y+1][3] + 1 # RIGHT\\n\\n                    temp = []\\n                    temp.append(info[x - 1][y][0] if x - 1 >= 0 else 0)\\n                    temp.append(info[x][y - 1][1] if y - 1 >= 0 else 0)\\n                    temp.append(info[x + 1][y][2] if x + 1 < N else 0)\\n                    temp.append(info[x][y + 1][3] if y + 1 < N else 0)\\n\\n                    res = max([min(temp) + 1, res])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2544232,
                "title": "c-simple-and-concise-dp",
                "content": "TC: O(3 * (N^2)) ---> ~= O(N^2)\\nSC: O(4 * (N^2)) ---> ~= O(N^2)\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& arr) {\\n        \\n        vector<vector<int>>nums(n,vector<int>(n,1));\\n        for(auto &it:arr){\\n            nums[it[0]][it[1]]=0;\\n        }\\n        vector<vector<int>>left=nums,right=nums,up=nums,down=nums;\\n        \\n        //up + left\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[i][j]==1){\\n                    up[i][j]+=   (i-1<0 ? 0 : up[i-1][j]);\\n                    left[i][j]+= (j-1<0 ? 0 :left[i][j-1]);\\n                }   \\n            }\\n        }\\n        \\n        //right + down \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(nums[i][j]==1){\\n                    right[i][j]+= (j+1>=n ? 0 : right[i][j+1]);\\n                    down[i][j]+=  (i+1>=n ? 0 : down[i+1][j]);\\n                }\\n            }\\n        }        \\n        \\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int area= \\n                    min({left[i][j],right[i][j],up[i][j],down[i][j]});\\n                maxi=max(maxi,area);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& arr) {\\n        \\n        vector<vector<int>>nums(n,vector<int>(n,1));\\n        for(auto &it:arr){\\n            nums[it[0]][it[1]]=0;\\n        }\\n        vector<vector<int>>left=nums,right=nums,up=nums,down=nums;\\n        \\n        //up + left\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[i][j]==1){\\n                    up[i][j]+=   (i-1<0 ? 0 : up[i-1][j]);\\n                    left[i][j]+= (j-1<0 ? 0 :left[i][j-1]);\\n                }   \\n            }\\n        }\\n        \\n        //right + down \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(nums[i][j]==1){\\n                    right[i][j]+= (j+1>=n ? 0 : right[i][j+1]);\\n                    down[i][j]+=  (i+1>=n ? 0 : down[i+1][j]);\\n                }\\n            }\\n        }        \\n        \\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int area= \\n                    min({left[i][j],right[i][j],up[i][j],down[i][j]});\\n                maxi=max(maxi,area);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544198,
                "title": "c-simple-approach-dp-tc-o-4-n-2",
                "content": "TC: O(5 * O(N^2)) ---> ~= O(N^2)\\nSC: O(4 * (N^2))  ---->  ~- O(N^2)\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& arr) {\\n        \\n        vector<vector<int>>nums(n,vector<int>(n,1));\\n        for(auto it:arr){\\n            nums[it[0]][it[1]]=0;\\n        }\\n        vector<vector<int>>left=nums,right=nums,up=nums,down=nums;\\n        \\n        //up\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++)\\n                if(up[i][j]==1)\\n                    up[i][j]+=up[i-1][j];\\n        }\\n        //left\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(left[i][j]==1)\\n                    left[i][j]+=left[i][j-1];\\n            }\\n        }\\n        //right\\n        //down\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(down[i][j]==1)\\n                    down[i][j]+=down[i+1][j];\\n            }\\n        }\\n        //right\\n        for(int i=0;i<n;i++){\\n            for(int j=n-2;j>=0;j--){\\n                if(right[i][j]==1)\\n                    right[i][j]+=right[i][j+1];\\n            }\\n        }\\n        \\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int area= \\n                    min({left[i][j],right[i][j],up[i][j],down[i][j]});\\n                maxi=max(maxi,area);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& arr) {\\n        \\n        vector<vector<int>>nums(n,vector<int>(n,1));\\n        for(auto it:arr){\\n            nums[it[0]][it[1]]=0;\\n        }\\n        vector<vector<int>>left=nums,right=nums,up=nums,down=nums;\\n        \\n        //up\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++)\\n                if(up[i][j]==1)\\n                    up[i][j]+=up[i-1][j];\\n        }\\n        //left\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(left[i][j]==1)\\n                    left[i][j]+=left[i][j-1];\\n            }\\n        }\\n        //right\\n        //down\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(down[i][j]==1)\\n                    down[i][j]+=down[i+1][j];\\n            }\\n        }\\n        //right\\n        for(int i=0;i<n;i++){\\n            for(int j=n-2;j>=0;j--){\\n                if(right[i][j]==1)\\n                    right[i][j]+=right[i][j+1];\\n            }\\n        }\\n        \\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int area= \\n                    min({left[i][j],right[i][j],up[i][j],down[i][j]});\\n                maxi=max(maxi,area);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516501,
                "title": "c-recursion-memoization-grid-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int dp[501][501][4];\\n    int solve(int i,int j,int k,vector<vector<int>> &grid){\\n        int n = grid.size();\\n        if(dp[i][j][k]!=-1) return dp[i][j][k];\\n        int ni=i+dir[k][0];\\n        int nj = j+dir[k][1];\\n        if(ni<0||nj<0||ni>=n||nj>=n||grid[ni][nj]==0)\\n            return 0;\\n        return dp[i][j][k]=1+solve(ni,nj,k,grid);\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n,vector<int>(n,1));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<mines.size();i++)\\n            grid[mines[i][0]][mines[i][1]]=0;\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    ans=max(ans,1+min({solve(i,j,0,grid),solve(i,j,1,grid),solve(i,j,2,grid),solve(i,j,3,grid)})); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int dp[501][501][4];\\n    int solve(int i,int j,int k,vector<vector<int>> &grid){\\n        int n = grid.size();\\n        if(dp[i][j][k]!=-1) return dp[i][j][k];\\n        int ni=i+dir[k][0];\\n        int nj = j+dir[k][1];\\n        if(ni<0||nj<0||ni>=n||nj>=n||grid[ni][nj]==0)\\n            return 0;\\n        return dp[i][j][k]=1+solve(ni,nj,k,grid);\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n,vector<int>(n,1));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<mines.size();i++)\\n            grid[mines[i][0]][mines[i][1]]=0;\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    ans=max(ans,1+min({solve(i,j,0,grid),solve(i,j,1,grid),solve(i,j,2,grid),solve(i,j,3,grid)})); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780422,
                "title": "most-easy-to-understand-solution",
                "content": "int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        \\n         vector<vector<int>> a(n,vector<int>(n,1));\\n        int i;\\n        \\n        for(auto& x:mines)\\n        {\\n             a[x[0]][x[1]]=0;\\n            \\n        }\\n           \\n        vector<vector<int>> left=a;\\n        vector<vector<int>> right=a;\\n        vector<vector<int>> up=a;\\n        vector<vector<int>> down=a;\\n        int m=n;\\n        for(int i=0;i<n;i++)\\n        {\\n             for(int j=1;j<n;j++)\\n             {\\n                 if(left[i][j]==1)\\n                 {\\n                     left[i][j] = left[i][j-1]+1;\\n                 }\\n                 \\n             }\\n        }\\n       \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                if(right[i][j]==1)\\n                {\\n                    right[i][j]= right[i][j+1]+1;\\n                }\\n                \\n            }\\n        }\\n         \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(up[i][j]==1)\\n                {\\n                    up[i][j] = up[i-1][j]+1;\\n                }\\n                \\n            }\\n        }\\n         \\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(down[i][j]==1)\\n                {\\n                    down[i][j] = down[i+1][j]+1;\\n                }\\n                \\n            }\\n        }\\n         \\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=max(ans,min({left[i][j],right[i][j],down[i][j],up[i][j]}));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        \\n         vector<vector<int>> a(n,vector<int>(n,1));\\n        int i;\\n        \\n        for(auto& x:mines)\\n        {\\n             a[x[0]][x[1]]=0;\\n            \\n        }\\n           \\n        vector<vector<int>> left=a;\\n        vector<vector<int>> right=a;\\n        vector<vector<int>> up=a;\\n        vector<vector<int>> down=a;\\n        int m=n;\\n        for(int i=0;i<n;i++)\\n        {\\n             for(int j=1;j<n;j++)\\n             {\\n                 if(left[i][j]==1)\\n                 {\\n                     left[i][j] = left[i][j-1]+1;\\n                 }\\n                 \\n             }\\n        }\\n       \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                if(right[i][j]==1)\\n                {\\n                    right[i][j]= right[i][j+1]+1;\\n                }\\n                \\n            }\\n        }\\n         \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(up[i][j]==1)\\n                {\\n                    up[i][j] = up[i-1][j]+1;\\n                }\\n                \\n            }\\n        }\\n         \\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(down[i][j]==1)\\n                {\\n                    down[i][j] = down[i+1][j]+1;\\n                }\\n                \\n            }\\n        }\\n         \\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=max(ans,min({left[i][j],right[i][j],down[i][j],up[i][j]}));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1459085,
                "title": "java-easy-dp",
                "content": "```\\n// For each cell, store number of consecutive 1\\'s in each direction: up, down, left and right\\nclass Cell {\\n    int val, up, down, left, right;\\n    Cell(int val) {\\n        this.up = this.down = this.left = this.right = this.val = val;\\n    }\\n    int getPlusSize() {\\n        return Math.min(up, Math.min(down, Math.min(left, right)));\\n    }\\n}\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        Cell[][] mat = new Cell[n][n];\\n        for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) mat[i][j] = new Cell(1);\\n        for(int[] mine: mines) mat[mine[0]][mine[1]] = new Cell(0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(mat[i][j].val == 1) {\\n                    if(i > 0) mat[i][j].left += mat[i-1][j].left;\\n                    if(j > 0) mat[i][j].up += mat[i][j-1].up;\\n                }\\n            }\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                if(mat[i][j].val == 1) {\\n                    if(i+1 < n) mat[i][j].right += mat[i+1][j].right;\\n                    if(j+1 < n) mat[i][j].down += mat[i][j+1].down;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++) for(int j = 0; j < n; j++)\\n            ans = Math.max(ans, mat[i][j].getPlusSize());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// For each cell, store number of consecutive 1\\'s in each direction: up, down, left and right\\nclass Cell {\\n    int val, up, down, left, right;\\n    Cell(int val) {\\n        this.up = this.down = this.left = this.right = this.val = val;\\n    }\\n    int getPlusSize() {\\n        return Math.min(up, Math.min(down, Math.min(left, right)));\\n    }\\n}\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        Cell[][] mat = new Cell[n][n];\\n        for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) mat[i][j] = new Cell(1);\\n        for(int[] mine: mines) mat[mine[0]][mine[1]] = new Cell(0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(mat[i][j].val == 1) {\\n                    if(i > 0) mat[i][j].left += mat[i-1][j].left;\\n                    if(j > 0) mat[i][j].up += mat[i][j-1].up;\\n                }\\n            }\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                if(mat[i][j].val == 1) {\\n                    if(i+1 < n) mat[i][j].right += mat[i+1][j].right;\\n                    if(j+1 < n) mat[i][j].down += mat[i][j+1].down;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++) for(int j = 0; j < n; j++)\\n            ans = Math.max(ans, mat[i][j].getPlusSize());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455030,
                "title": "java-pure-brute-approach",
                "content": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n    \\tif(n*n==mines.length)\\n    \\t\\treturn 0;\\n        \\n    \\tif(n<3)\\n            return 1;\\n    \\t\\n    \\tint arr[][]=new int[n][n];\\n    \\t\\n    \\tint i,j,k;\\n    \\t\\n    \\tfor(i=0;i<n;i++)\\n    \\t\\tArrays.fill(arr[i], 1);\\n    \\t\\n    \\tfor(i=0;i<mines.length;i++)\\n    \\t\\tarr[mines[i][0]][mines[i][1]]=0;\\n    \\t\\n        int tm=n;\\n        if(tm%2==0)\\n            tm--;\\n    \\t\\t\\n    \\tfor(i=tm;i>=3;i-=2)\\n    \\t{\\n    \\t\\tfor(j=0;j<=n-i;j++)\\n    \\t\\t{\\n    \\t\\t\\tfor(k=i/2;k<n-i/2;k++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t int l,m;\\n    \\t\\t\\t\\t //checking the vertical 1\\'s of plus sign\\n    \\t\\t\\t\\t for(l=0;l<i;l++)\\n    \\t\\t\\t\\t {\\n    \\t\\t\\t\\t\\t if(arr[l+j][k]!=1)\\n    \\t\\t\\t\\t\\t\\t break;\\n    \\t\\t\\t\\t }\\n    \\t\\t\\t\\t if(l<i)\\n                        continue;\\n    \\t\\t\\t\\t //checking the horizontal 1\\'s of plus sign\\n    \\t\\t\\t\\t for(m=0;m<i;m++)\\n    \\t\\t\\t\\t {\\n    \\t\\t\\t\\t\\t if(arr[j+i/2][k-i/2+m]!=1)\\n    \\t\\t\\t\\t\\t\\t break;\\n    \\t\\t\\t\\t }\\n    \\t\\t\\t\\t if(m==i)\\n                         return i/2+1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n\\t    return 1;\\n    }\\n}\\n```\\nAny Questions?\\nPlease do upvote:))",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n    \\tif(n*n==mines.length)\\n    \\t\\treturn 0;\\n        \\n    \\tif(n<3)\\n            return 1;\\n    \\t\\n    \\tint arr[][]=new int[n][n];\\n    \\t\\n    \\tint i,j,k;\\n    \\t\\n    \\tfor(i=0;i<n;i++)\\n    \\t\\tArrays.fill(arr[i], 1);\\n    \\t\\n    \\tfor(i=0;i<mines.length;i++)\\n    \\t\\tarr[mines[i][0]][mines[i][1]]=0;\\n    \\t\\n        int tm=n;\\n        if(tm%2==0)\\n            tm--;\\n    \\t\\t\\n    \\tfor(i=tm;i>=3;i-=2)\\n    \\t{\\n    \\t\\tfor(j=0;j<=n-i;j++)\\n    \\t\\t{\\n    \\t\\t\\tfor(k=i/2;k<n-i/2;k++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t int l,m;\\n    \\t\\t\\t\\t //checking the vertical 1\\'s of plus sign\\n    \\t\\t\\t\\t for(l=0;l<i;l++)\\n    \\t\\t\\t\\t {\\n    \\t\\t\\t\\t\\t if(arr[l+j][k]!=1)\\n    \\t\\t\\t\\t\\t\\t break;\\n    \\t\\t\\t\\t }\\n    \\t\\t\\t\\t if(l<i)\\n                        continue;\\n    \\t\\t\\t\\t //checking the horizontal 1\\'s of plus sign\\n    \\t\\t\\t\\t for(m=0;m<i;m++)\\n    \\t\\t\\t\\t {\\n    \\t\\t\\t\\t\\t if(arr[j+i/2][k-i/2+m]!=1)\\n    \\t\\t\\t\\t\\t\\t break;\\n    \\t\\t\\t\\t }\\n    \\t\\t\\t\\t if(m==i)\\n                         return i/2+1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n\\t    return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915912,
                "title": "python-nothing-fancy-3-steps",
                "content": "```html5\\n<b>Time Complexity: O(N<sup>2</sup>)\\nSpace Complexity: O(N<sup>2</sup>)</b>\\n```\\n\\n1. Make a binary **grid** where 1s represent spaces that can be used to make a plus sign and 0s are mines.  \\n\\n2. Make 4 helper grids **left, right, up,** and **down**.  \\nleft[i][j] says how many 1s there are to the **left** of location (i, j)\\nLikewise right[i][j] says how many 1s there are to the **right** of location (i, j).  \\nSame for **up** and **down**.  \\n\\n3. The largest plus sign you can make at location (i, j) is the mininum of **left[i][j], right[i][j], up[i][j],** and **down[i][j]**.  \\nIterate over all the locations on the grid and return the size of the maximum plus sign you can make.  \\n\\n<br>\\n\\n```python\\ndef orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n\\n\\tgrid = [[1 for _ in range(N)] for _ in range(N)]\\n\\tfor i, j in mines:\\n\\t\\tgrid[i][j] = 0\\n\\n\\tleft = [[0 for _ in range(N)] for _ in range(N)]\\n\\tright = [[0 for _ in range(N)] for _ in range(N)]\\n\\tup = [[0 for _ in range(N)] for _ in range(N)]\\n\\tdown = [[0 for _ in range(N)] for _ in range(N)]\\n\\n\\t# Construct left and right\\n\\tfor i in range(N):\\n\\t\\tcount = 0\\n\\t\\tfor j in range(N):\\n\\t\\t\\tleft[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t\\tcount = 0\\n\\t\\tfor j in range(N-1, -1, -1):\\n\\t\\t\\tright[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t# Construct up and down\\n\\tfor j in range(N):\\n\\t\\tcount = 0\\n\\t\\tfor i in range(N):\\n\\t\\t\\tdown[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t\\tcount = 0\\n\\t\\tfor i in range(N-1, -1, -1):\\n\\t\\t\\tup[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t# Find the largest Plus Sign\\n\\tres = 0\\n\\tfor i in range(N):\\n\\t\\tfor j in range(N):\\n\\t\\t\\tif grid[i][j]:\\n\\t\\t\\t\\tsize = min(left[i][j], right[i][j], down[i][j], up[i][j])\\n\\t\\t\\t\\tres = max(res, size + 1)\\n\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(N<sup>2</sup>)\\nSpace Complexity: O(N<sup>2</sup>)</b>\\n```\n```python\\ndef orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n\\n\\tgrid = [[1 for _ in range(N)] for _ in range(N)]\\n\\tfor i, j in mines:\\n\\t\\tgrid[i][j] = 0\\n\\n\\tleft = [[0 for _ in range(N)] for _ in range(N)]\\n\\tright = [[0 for _ in range(N)] for _ in range(N)]\\n\\tup = [[0 for _ in range(N)] for _ in range(N)]\\n\\tdown = [[0 for _ in range(N)] for _ in range(N)]\\n\\n\\t# Construct left and right\\n\\tfor i in range(N):\\n\\t\\tcount = 0\\n\\t\\tfor j in range(N):\\n\\t\\t\\tleft[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t\\tcount = 0\\n\\t\\tfor j in range(N-1, -1, -1):\\n\\t\\t\\tright[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t# Construct up and down\\n\\tfor j in range(N):\\n\\t\\tcount = 0\\n\\t\\tfor i in range(N):\\n\\t\\t\\tdown[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t\\tcount = 0\\n\\t\\tfor i in range(N-1, -1, -1):\\n\\t\\t\\tup[i][j] = count\\n\\t\\t\\tcount = count + 1 if grid[i][j] else 0\\n\\n\\t# Find the largest Plus Sign\\n\\tres = 0\\n\\tfor i in range(N):\\n\\t\\tfor j in range(N):\\n\\t\\t\\tif grid[i][j]:\\n\\t\\t\\t\\tsize = min(left[i][j], right[i][j], down[i][j], up[i][j])\\n\\t\\t\\t\\tres = max(res, size + 1)\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 790009,
                "title": "c-easy-to-understand-95-space-95-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int temp[N][N];\\n        for(int i=0;i<N;i++)\\n        {\\n            for(int j=0;j<N;j++)\\n                temp[i][j]=N;\\n        }\\n        for(auto i:mines)temp[i[0]][i[1]]=0;\\n        \\n        for(int i=0;i<N;i++)\\n        {\\n            for(int j=0,k=N-1,u=0,d=0,l=0,r=0;j<N;j++,k--)\\n            {\\n                temp[i][j]=min(temp[i][j],u=(temp[i][j]==0?0:u+1));\\n                temp[i][k]=min(temp[i][k],d=(temp[i][k]==0?0:d+1));\\n                temp[j][i]=min(temp[j][i],l=(temp[j][i]==0?0:l+1));\\n                temp[k][i]=min(temp[k][i],r=(temp[k][i]==0?0:r+1));\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<N;i++)\\n        {\\n            for(int j=0;j<N;j++)\\n                res=max(res,temp[i][j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int temp[N][N];\\n        for(int i=0;i<N;i++)\\n        {\\n            for(int j=0;j<N;j++)\\n                temp[i][j]=N;\\n        }\\n        for(auto i:mines)temp[i[0]][i[1]]=0;\\n        \\n        for(int i=0;i<N;i++)\\n        {\\n            for(int j=0,k=N-1,u=0,d=0,l=0,r=0;j<N;j++,k--)\\n            {\\n                temp[i][j]=min(temp[i][j],u=(temp[i][j]==0?0:u+1));\\n                temp[i][k]=min(temp[i][k],d=(temp[i][k]==0?0:d+1));\\n                temp[j][i]=min(temp[j][i],l=(temp[j][i]==0?0:l+1));\\n                temp[k][i]=min(temp[k][i],r=(temp[k][i]==0?0:r+1));\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<N;i++)\\n        {\\n            for(int j=0;j<N;j++)\\n                res=max(res,temp[i][j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113331,
                "title": "java-dfs-easy-to-understand",
                "content": "\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        boolean[][] matrix = new boolean[N][N];\\n        for (int i = 0; i < N; i++){\\n            for (int j = 0; j < N; j++){\\n                matrix[i][j] = true;\\n            }\\n        }\\n        for (int[] mine: mines){\\n            matrix[mine[0]][mine[1]] = false;\\n        }\\n        int max = 0;\\n        for (int i = 0; i < N; i++){\\n            for (int j = 0; j < N; j++){\\n                if (i < max || j < max || i > N-max-1 || j > N-max-1)\\n                    continue;\\n                int tmp = explore(matrix, i, j, N);\\n                max = Math.max(tmp, max);\\n            }\\n        }\\n        return max;\\n    }\\n    private int explore(boolean[][] matrix, int i, int j, int N){\\n        if (!matrix[i][j])\\n            return 0;\\n        int order = 1;\\n        while ((i-order>=0) && (j-order>=0) && (i+order<N) && (j+order<N) && (matrix[i-order][j]) && (matrix[i+order][j]) && (matrix[i][j-order]) && (matrix[i][j+order])){\\n            order++;\\n        }\\n        return order;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        boolean[][] matrix = new boolean[N][N];\\n        for (int i = 0; i < N; i++){\\n            for (int j = 0; j < N; j++){\\n                matrix[i][j] = true;\\n            }\\n        }\\n        for (int[] mine: mines){\\n            matrix[mine[0]][mine[1]] = false;\\n        }\\n        int max = 0;\\n        for (int i = 0; i < N; i++){\\n            for (int j = 0; j < N; j++){\\n                if (i < max || j < max || i > N-max-1 || j > N-max-1)\\n                    continue;\\n                int tmp = explore(matrix, i, j, N);\\n                max = Math.max(tmp, max);\\n            }\\n        }\\n        return max;\\n    }\\n    private int explore(boolean[][] matrix, int i, int j, int N){\\n        if (!matrix[i][j])\\n            return 0;\\n        int order = 1;\\n        while ((i-order>=0) && (j-order>=0) && (i+order<N) && (j+order<N) && (matrix[i-order][j]) && (matrix[i+order][j]) && (matrix[i][j-order]) && (matrix[i][j+order])){\\n            order++;\\n        }\\n        return order;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 113341,
                "title": "c-o-n-2-logn-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int len = 0;\\n        vector<set<int>> row(N), col(N);\\n        for (auto &v : mines) {\\n            row[v[0]].emplace(v[1]);\\n            col[v[1]].emplace(v[0]);\\n        }\\n\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                int row_len = maxlen(row[r], c, N); // max length of row\\n                int col_len = maxlen(col[c], r, N); // max length of col\\n                len = max(len, min(row_len, col_len));\\n            }\\n        }\\n        return (len + 1) / 2;\\n    }\\n\\n    int maxlen(set<int>& s, int mid, int N) {\\n        auto it = s.lower_bound(mid);\\n        if (it != s.end() && *it == mid) return 0; // (i, j) is 0\\n        int end = it == s.end() ? N - 1 : *it - 1;\\n        int begin = it == s.begin() ? 0 : *(--it) + 1;\\n        int len = 2 * min(mid - begin, end - mid) + 1;\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int len = 0;\\n        vector<set<int>> row(N), col(N);\\n        for (auto &v : mines) {\\n            row[v[0]].emplace(v[1]);\\n            col[v[1]].emplace(v[0]);\\n        }\\n\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                int row_len = maxlen(row[r], c, N); // max length of row\\n                int col_len = maxlen(col[c], r, N); // max length of col\\n                len = max(len, min(row_len, col_len));\\n            }\\n        }\\n        return (len + 1) / 2;\\n    }\\n\\n    int maxlen(set<int>& s, int mid, int N) {\\n        auto it = s.lower_bound(mid);\\n        if (it != s.end() && *it == mid) return 0; // (i, j) is 0\\n        int end = it == s.end() ? N - 1 : *it - 1;\\n        int begin = it == s.begin() ? 0 : *(--it) + 1;\\n        int len = 2 * min(mid - begin, end - mid) + 1;\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975631,
                "title": "c-easy-to-understand-prefix-sum-approach",
                "content": "\\nThis is not the fastest solution but it is very easy to understand and come up during an actual interview. Pls feel free to optimise this solution!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> up(n, vector<int>(n, 0)), down(n, vector<int>(n, 0)), left(n, vector<int>(n, 0)), right(n, vector<int>(n, 0));\\n\\n        unordered_map<int, unordered_map<int,int>> mp;\\n        for(auto &p : mines)\\n            mp[p[0]][p[1]]++;\\n\\n//below code that includes 4 double loops are used for storing prefix sum of 1\\'s in left, right,up and down direction.\\n        for(int j = 0; j < n; j++){\\n            for(int i = 0; i < n; i++){\\n                if(mp[i].find(j) != mp[i].end())\\n                    up[i][j] = 0;\\n                else if(i == 0)\\n                    up[i][j] = 1;\\n                else\\n                    up[i][j] = 1 + up[i - 1][j];\\n            }\\n        }\\n\\n        for(int j = 0; j < n; j++){\\n            for(int i = n - 1; i >= 0; i--){\\n                if(mp[i].find(j) != mp[i].end())\\n                    down[i][j] = 0;\\n                else if(i == n - 1)\\n                    down[i][j] = 1;\\n                else\\n                    down[i][j] = 1 + down[i + 1][j];\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(mp[i].find(j) != mp[i].end())\\n                    left[i][j] = 0;\\n                else if(j == 0)\\n                    left[i][j] = 1;\\n                else\\n                    left[i][j] = 1 + left[i][j - 1];\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = n - 1; j >= 0; j--){\\n                if(mp[i].find(j) != mp[i].end())\\n                    right[i][j] = 0;\\n                else if(j == n - 1)\\n                    right[i][j] = 1;\\n                else\\n                    right[i][j] = 1 + right[i][j + 1];\\n            }\\n        }\\n\\n\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                // cout<<left[i][j]<<\" \"<<right[i][j]<<\" \"<<up[i][j]<<\" \"<<down[i][j]<<endl;\\n                res = max(res, min(left[i][j], min(right[i][j], min(up[i][j], down[i][j]))));\\n                //the \\'order\\' of plus sign will be the minimum of prefix sums from the four sides.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> up(n, vector<int>(n, 0)), down(n, vector<int>(n, 0)), left(n, vector<int>(n, 0)), right(n, vector<int>(n, 0));\\n\\n        unordered_map<int, unordered_map<int,int>> mp;\\n        for(auto &p : mines)\\n            mp[p[0]][p[1]]++;\\n\\n//below code that includes 4 double loops are used for storing prefix sum of 1\\'s in left, right,up and down direction.\\n        for(int j = 0; j < n; j++){\\n            for(int i = 0; i < n; i++){\\n                if(mp[i].find(j) != mp[i].end())\\n                    up[i][j] = 0;\\n                else if(i == 0)\\n                    up[i][j] = 1;\\n                else\\n                    up[i][j] = 1 + up[i - 1][j];\\n            }\\n        }\\n\\n        for(int j = 0; j < n; j++){\\n            for(int i = n - 1; i >= 0; i--){\\n                if(mp[i].find(j) != mp[i].end())\\n                    down[i][j] = 0;\\n                else if(i == n - 1)\\n                    down[i][j] = 1;\\n                else\\n                    down[i][j] = 1 + down[i + 1][j];\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(mp[i].find(j) != mp[i].end())\\n                    left[i][j] = 0;\\n                else if(j == 0)\\n                    left[i][j] = 1;\\n                else\\n                    left[i][j] = 1 + left[i][j - 1];\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = n - 1; j >= 0; j--){\\n                if(mp[i].find(j) != mp[i].end())\\n                    right[i][j] = 0;\\n                else if(j == n - 1)\\n                    right[i][j] = 1;\\n                else\\n                    right[i][j] = 1 + right[i][j + 1];\\n            }\\n        }\\n\\n\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                // cout<<left[i][j]<<\" \"<<right[i][j]<<\" \"<<up[i][j]<<\" \"<<down[i][j]<<endl;\\n                res = max(res, min(left[i][j], min(right[i][j], min(up[i][j], down[i][j]))));\\n                //the \\'order\\' of plus sign will be the minimum of prefix sums from the four sides.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3458894,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int ans=0,s,i,j,k;\\n        int dp[N+2][N+2][4],v[N][N];\\n        for(i=0;i<N;i++)for(j=0;j<N;j++)v[i][j]=1;\\n        for(i=0;i<mines.size();i++)v[mines[i][0]][mines[i][1]]=0;\\n        memset(dp,0,sizeof dp);\\n        \\n        for(i=0;i<N;i++){\\n            for(j=0;j<N;j++){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][0]=dp[i][j+1][0]+1;\\n                    dp[i+1][j+1][1]=dp[i+1][j][1]+1;\\n                }\\n            }\\n        }\\n        for(i=N-1;i>=0;i--){\\n            for(j=N-1;j>=0;j--){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][2]=dp[i+2][j+1][2]+1;\\n                    dp[i+1][j+1][3]=dp[i+1][j+2][3]+1;\\n                }\\n            }\\n        }\\n        for(i=1;i<=N;i++){\\n            for(j=1;j<=N;j++){\\n                s=min(dp[i][j][0],min(dp[i][j][1],min(dp[i][j][2],dp[i][j][3])));\\n                ans=max(ans,s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        rows = [[-1, N] for _ in range(N)]\\n        cols = [[-1, N] for _ in range(N)]\\n        for r, c in mines:\\n            rows[r].append(c)\\n            cols[c].append(r)\\n        for i in range(N):\\n            rows[i].sort()\\n            cols[i].sort()\\n        mxp = 0\\n        for r in range(N):\\n            for i in range(len(rows[r]) - 1):\\n                left_b = rows[r][i]\\n                right_b = rows[r][i+1]\\n                for c in range(left_b + mxp + 1, right_b - mxp):\\n                    idx = bisect_right(cols[c], r) - 1\\n                    up_b = cols[c][idx]\\n                    down_b = cols[c][idx + 1]\\n                    mxp = max(mxp, min(c - left_b, right_b - c, r - up_b, down_b - r))\\n        return mxp\\n```\\n\\n```Java []\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] dp = new int[n][n];\\n        for(int[] mine : mines) {\\n            int row = mine[0], col = mine[1];\\n            dp[row][col] = -1;\\n        }\\n        for(int row = 0; row < n; row++) {\\n            int count = 0;\\n            for(int col = 0; col < n; col++) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] =  count;\\n                }\\n            }\\n            count = 0;\\n            for(int col = n - 1; col >= 0; col--) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] = Math.min(dp[row][col], count);\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for(int col = 0; col < n; col++) {\\n            int count = 0;\\n            for(int row = 0; row < n; row++) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] = Math.min(dp[row][col], count);\\n                }\\n            }\\n            count = 0;\\n            for(int row = n - 1; row >= 0; row--) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] = Math.min(dp[row][col], count);\\n                }\\n                max = Math.max(max, dp[row][col]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int ans=0,s,i,j,k;\\n        int dp[N+2][N+2][4],v[N][N];\\n        for(i=0;i<N;i++)for(j=0;j<N;j++)v[i][j]=1;\\n        for(i=0;i<mines.size();i++)v[mines[i][0]][mines[i][1]]=0;\\n        memset(dp,0,sizeof dp);\\n        \\n        for(i=0;i<N;i++){\\n            for(j=0;j<N;j++){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][0]=dp[i][j+1][0]+1;\\n                    dp[i+1][j+1][1]=dp[i+1][j][1]+1;\\n                }\\n            }\\n        }\\n        for(i=N-1;i>=0;i--){\\n            for(j=N-1;j>=0;j--){\\n                if(v[i][j]==1){\\n                    dp[i+1][j+1][2]=dp[i+2][j+1][2]+1;\\n                    dp[i+1][j+1][3]=dp[i+1][j+2][3]+1;\\n                }\\n            }\\n        }\\n        for(i=1;i<=N;i++){\\n            for(j=1;j<=N;j++){\\n                s=min(dp[i][j][0],min(dp[i][j][1],min(dp[i][j][2],dp[i][j][3])));\\n                ans=max(ans,s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        rows = [[-1, N] for _ in range(N)]\\n        cols = [[-1, N] for _ in range(N)]\\n        for r, c in mines:\\n            rows[r].append(c)\\n            cols[c].append(r)\\n        for i in range(N):\\n            rows[i].sort()\\n            cols[i].sort()\\n        mxp = 0\\n        for r in range(N):\\n            for i in range(len(rows[r]) - 1):\\n                left_b = rows[r][i]\\n                right_b = rows[r][i+1]\\n                for c in range(left_b + mxp + 1, right_b - mxp):\\n                    idx = bisect_right(cols[c], r) - 1\\n                    up_b = cols[c][idx]\\n                    down_b = cols[c][idx + 1]\\n                    mxp = max(mxp, min(c - left_b, right_b - c, r - up_b, down_b - r))\\n        return mxp\\n```\n```Java []\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] dp = new int[n][n];\\n        for(int[] mine : mines) {\\n            int row = mine[0], col = mine[1];\\n            dp[row][col] = -1;\\n        }\\n        for(int row = 0; row < n; row++) {\\n            int count = 0;\\n            for(int col = 0; col < n; col++) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] =  count;\\n                }\\n            }\\n            count = 0;\\n            for(int col = n - 1; col >= 0; col--) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] = Math.min(dp[row][col], count);\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for(int col = 0; col < n; col++) {\\n            int count = 0;\\n            for(int row = 0; row < n; row++) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] = Math.min(dp[row][col], count);\\n                }\\n            }\\n            count = 0;\\n            for(int row = n - 1; row >= 0; row--) {\\n                if(dp[row][col] == -1) {\\n                    count = 0;\\n                } else {\\n                    count += 1;\\n                    dp[row][col] = Math.min(dp[row][col], count);\\n                }\\n                max = Math.max(max, dp[row][col]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866530,
                "title": "c-dp-memoization-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[500][500][4];\\n    int dir[5]={0,1,0,-1,0};\\n    int solve(vector<vector<int>> &grid,int n,int r,int c,int d)\\n    {\\n        if(r<0||c<0||r>=n||c>=n||grid[r][c]==0)\\n            return 0;\\n        if(dp[r][c][d]!=-1)\\n            return dp[r][c][d];\\n        return dp[r][c][d]=1+solve(grid,n,r+dir[d],c+dir[d+1],d);\\n        \\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<int>> grid(n,vector<int>(n,1));\\n        for(auto &v:mines)\\n        {\\n            grid[v[0]][v[1]]=0;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int plus=solve(grid,n,i,j,0);\\n                for(int d=1;d<4;d++)\\n                {\\n                    plus=min(plus,solve(grid,n,i,j,d));\\n                    \\n                }\\n                ans=max(plus,ans);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[500][500][4];\\n    int dir[5]={0,1,0,-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2839141,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n, mines):\\n        dp, ans = [[0]*n for _ in range(n)], 0\\n        banned = {tuple(mine) for mine in mines}\\n\\n        for i in range(n):\\n            count = 0\\n            for j in range(n):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = count\\n\\n            count = 0\\n            for j in range(n-1,-1,-1):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = min(dp[i][j],count)\\n\\n\\n        for j in range(n):\\n            count = 0\\n            for i in range(n):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = min(dp[i][j],count)\\n\\n            count = 0\\n            for i in range(n-1,-1,-1):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = min(dp[i][j],count)\\n                ans = max(ans,dp[i][j])\\n\\n        return ans\\n\\n\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n, mines):\\n        dp, ans = [[0]*n for _ in range(n)], 0\\n        banned = {tuple(mine) for mine in mines}\\n\\n        for i in range(n):\\n            count = 0\\n            for j in range(n):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = count\\n\\n            count = 0\\n            for j in range(n-1,-1,-1):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = min(dp[i][j],count)\\n\\n\\n        for j in range(n):\\n            count = 0\\n            for i in range(n):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = min(dp[i][j],count)\\n\\n            count = 0\\n            for i in range(n-1,-1,-1):\\n                count = count + 1 if (i,j) not in banned else 0\\n                dp[i][j] = min(dp[i][j],count)\\n                ans = max(ans,dp[i][j])\\n\\n        return ans\\n\\n\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330951,
                "title": "c-dp-easy-faster-only-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        //jai shri ram\\n        int ans=0;\\n        vector<bool>block(25*int(1e4)+1,0);\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(auto x:mines){\\n            int a=x[0],b=x[1];\\n            block[a*n+b]=true;\\n        }\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else {\\n                    sum+=1;\\n                }\\n                dp[i][j]=sum;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int j=n-1;j>=0;j--){\\n            int sum=0;\\n            for(int i=n-1;i>=0;i--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int sum=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        //jai shri ram\\n        int ans=0;\\n        vector<bool>block(25*int(1e4)+1,0);\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(auto x:mines){\\n            int a=x[0],b=x[1];\\n            block[a*n+b]=true;\\n        }\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else {\\n                    sum+=1;\\n                }\\n                dp[i][j]=sum;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int j=n-1;j>=0;j--){\\n            int sum=0;\\n            for(int i=n-1;i>=0;i--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int sum=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285414,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Dynamic Programming***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        vector<vector<int>> grid(n, vector<int> (n, 1));\\n        \\n        for(auto v : mines)\\n        {\\n            int x = v[0];\\n            \\n            int y = v[1];\\n            \\n            grid[x][y] = 0;\\n        }\\n        \\n        // precalculate for left consecutive one\\'s\\n        \\n        vector<vector<int>> left(n, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == 0)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        left[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        left[i][j] = left[i][j - 1] + 1;\\n                    }\\n                    else\\n                    {\\n                        left[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // precalculate for right consecutive one\\'s\\n        \\n        vector<vector<int>> right(n, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(j == n - 1)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        right[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        right[i][j] = right[i][j + 1] + 1;\\n                    }\\n                    else\\n                    {\\n                        right[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // precalculate for top consecutive one\\'s\\n        \\n        vector<vector<int>> top(n, vector<int> (n, 0));\\n        \\n        for(int j = 0; j < n; j++)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(i == 0)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        top[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        top[i][j] = top[i - 1][j] + 1;\\n                    }\\n                    else\\n                    {\\n                        top[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // precalculate for bottom consecutive one\\'s\\n        \\n        vector<vector<int>> bottom(n, vector<int> (n, 0));\\n        \\n        for(int j = 0; j < n; j++)\\n        {\\n            for(int i = n - 1; i >= 0; i--)\\n            {\\n                if(i == n - 1)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        bottom[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        bottom[i][j] = bottom[i + 1][j] + 1;\\n                    }\\n                    else\\n                    {\\n                        bottom[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // calculate maxi\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int left_co = left[i][j];\\n                    \\n                    int right_co = right[i][j];\\n                    \\n                    int top_co = top[i][j];\\n                    \\n                    int bottom_co = bottom[i][j];\\n                \\n                    int curr = min({top_co, bottom_co, left_co, right_co});\\n                    \\n                    maxi = max(maxi, curr);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        vector<vector<int>> grid(n, vector<int> (n, 1));\\n        \\n        for(auto v : mines)\\n        {\\n            int x = v[0];\\n            \\n            int y = v[1];\\n            \\n            grid[x][y] = 0;\\n        }\\n        \\n        // precalculate for left consecutive one\\'s\\n        \\n        vector<vector<int>> left(n, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == 0)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        left[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        left[i][j] = left[i][j - 1] + 1;\\n                    }\\n                    else\\n                    {\\n                        left[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // precalculate for right consecutive one\\'s\\n        \\n        vector<vector<int>> right(n, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(j == n - 1)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        right[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        right[i][j] = right[i][j + 1] + 1;\\n                    }\\n                    else\\n                    {\\n                        right[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // precalculate for top consecutive one\\'s\\n        \\n        vector<vector<int>> top(n, vector<int> (n, 0));\\n        \\n        for(int j = 0; j < n; j++)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(i == 0)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        top[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        top[i][j] = top[i - 1][j] + 1;\\n                    }\\n                    else\\n                    {\\n                        top[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // precalculate for bottom consecutive one\\'s\\n        \\n        vector<vector<int>> bottom(n, vector<int> (n, 0));\\n        \\n        for(int j = 0; j < n; j++)\\n        {\\n            for(int i = n - 1; i >= 0; i--)\\n            {\\n                if(i == n - 1)\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        bottom[i][j] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j])\\n                    {\\n                        bottom[i][j] = bottom[i + 1][j] + 1;\\n                    }\\n                    else\\n                    {\\n                        bottom[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // calculate maxi\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int left_co = left[i][j];\\n                    \\n                    int right_co = right[i][j];\\n                    \\n                    int top_co = top[i][j];\\n                    \\n                    int bottom_co = bottom[i][j];\\n                \\n                    int curr = min({top_co, bottom_co, left_co, right_co});\\n                    \\n                    maxi = max(maxi, curr);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039544,
                "title": "javascript-solution-detailed-annotated",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} mines\\n * @return {number}\\n */\\nvar orderOfLargestPlusSign = function(n, mines) {\\n    // create n * n as a table, and each grid fill the maximum number\\n    const t = new Array(n).fill(0).map(() => new Array(n).fill(n));\\n\\n    // insert `0` to the grid in table according the position in mines\\n    mines.forEach(a => t[a[0]][a[1]] = 0);\\n\\n    // loop each rows and cols\\n    // - for rows: calculate non-zero grid from left to right\\n    // - for cols: calculate non-zero grid from top to bottom\\n    // - when the loop is completed, all of non-zero values will be calculated by four directions\\n    // - and these grids value will be updated by comparing. then we can obtain the minimum value of the four directions caculation, which is the maximum of the grid\\n    for (let i = 0; i < n; i++) {\\n        // save the maximum value of non-zeros with for directions\\n        let [l, r, u, d] = [0, 0, 0, 0];\\n\\n        // l: left,  loop row i from left to right\\n        // r: right, loop row i from right to left\\n        // u: up,    loop col i from top to bottom\\n        // d: down,  loop col i from bottom to top\\n        for (let j = 0, k = n - 1; j < n; j++, k--) {\\n            // if the value is `0`, then set variable to `0`, and indicates it\\'s broken\\n            l = t[i][j] && l + 1;\\n            r = t[i][k] && r + 1;\\n            u = t[j][i] && u + 1;\\n            d = t[k][i] && d + 1;\\n\\n            // if current value is less than origin value\\n            // one possibility: the origin value is default\\n            // another possibility: the length of non-zero in a centain direction is langer than in the current direction, which the minimum value we need\\n            if (l < t[i][j]) t[i][j] = l;\\n            if (r < t[i][k]) t[i][k] = r;\\n            if (u < t[j][i]) t[j][i] = u;\\n            if (d < t[k][i]) t[k][i] = d;\\n        }\\n    }\\n\\n    // return maximum value be saved by all cells\\n    return Math.max(...t.map(v => Math.max(...v)));\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} mines\\n * @return {number}\\n */\\nvar orderOfLargestPlusSign = function(n, mines) {\\n    // create n * n as a table, and each grid fill the maximum number\\n    const t = new Array(n).fill(0).map(() => new Array(n).fill(n));\\n\\n    // insert `0` to the grid in table according the position in mines\\n    mines.forEach(a => t[a[0]][a[1]] = 0);\\n\\n    // loop each rows and cols\\n    // - for rows: calculate non-zero grid from left to right\\n    // - for cols: calculate non-zero grid from top to bottom\\n    // - when the loop is completed, all of non-zero values will be calculated by four directions\\n    // - and these grids value will be updated by comparing. then we can obtain the minimum value of the four directions caculation, which is the maximum of the grid\\n    for (let i = 0; i < n; i++) {\\n        // save the maximum value of non-zeros with for directions\\n        let [l, r, u, d] = [0, 0, 0, 0];\\n\\n        // l: left,  loop row i from left to right\\n        // r: right, loop row i from right to left\\n        // u: up,    loop col i from top to bottom\\n        // d: down,  loop col i from bottom to top\\n        for (let j = 0, k = n - 1; j < n; j++, k--) {\\n            // if the value is `0`, then set variable to `0`, and indicates it\\'s broken\\n            l = t[i][j] && l + 1;\\n            r = t[i][k] && r + 1;\\n            u = t[j][i] && u + 1;\\n            d = t[k][i] && d + 1;\\n\\n            // if current value is less than origin value\\n            // one possibility: the origin value is default\\n            // another possibility: the length of non-zero in a centain direction is langer than in the current direction, which the minimum value we need\\n            if (l < t[i][j]) t[i][j] = l;\\n            if (r < t[i][k]) t[i][k] = r;\\n            if (u < t[j][i]) t[j][i] = u;\\n            if (d < t[k][i]) t[k][i] = d;\\n        }\\n    }\\n\\n    // return maximum value be saved by all cells\\n    return Math.max(...t.map(v => Math.max(...v)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981638,
                "title": "java-o-n-2-time-and-space",
                "content": "```\\n\\nclass Solution {\\n    int[][] hori; int[][] verti; \\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        hori = new int[n][n]; \\n        verti = new int[n][n]; \\n        int[][] grid = new int[n][n]; \\n        for (int i = 0; i < n; i++){Arrays.fill(grid[i], 1); }\\n        for (int i = 0; i < mines.length; i++){\\n            grid[mines[i][0]][mines[i][1]] = 0; \\n        }\\n        for (int i = 0; i < n; i++){\\n            hori[i][0] = grid[i][0]; \\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            verti[0][i] = grid[0][i]; \\n        }\\n        for (int i = 0; i < n; i++){\\n            for (int j = 1; j < n; j++){\\n               if (grid[i][j] == 1)\\n                hori[i][j] = hori[i][j- 1] + grid[i][j]; \\n                 else hori[i][j] = 0; \\n\\n             }\\n                   }\\n        \\n        for (int j = 0; j < n; j++){\\n            for (int i = 1; i < n; i++){\\n                if (grid[i][j] == 1)\\n                verti[i][j] = verti[i - 1][j] + grid[i][j];\\n                else verti[i][j] = 0; \\n             }\\n        }\\n        \\n        for (int k = n ; k > 0; k--){\\n            boolean holdstrue = false;\\n            for (int i = 0; i < n; i++){\\n                for (int j = 0; j < n; j++){\\n                    if (hori[i][j] >= 2*k - 1){\\n                        int center = j - (k) + 1; \\n                        if (i + k - 1 < n && center >= 0 && verti[i + k - 1][center] >= 2*k - 1 && verti[i][center] >= k - 1){\\n                            holdstrue = true; \\n                            System.out.println(i + \" \" + j); \\n                            System.out.println(i + \" \" + center);\\n                            return k; \\n                            \\n                        }\\n                    }\\n                }\\n                if (holdstrue) break;\\n            }\\n            if (holdstrue) return k; \\n        }\\n        if (mines.length < n*n)return 1; \\n        return 0; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int[][] hori; int[][] verti; \\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        hori = new int[n][n]; \\n        verti = new int[n][n]; \\n        int[][] grid = new int[n][n]; \\n        for (int i = 0; i < n; i++){Arrays.fill(grid[i], 1); }\\n        for (int i = 0; i < mines.length; i++){\\n            grid[mines[i][0]][mines[i][1]] = 0; \\n        }\\n        for (int i = 0; i < n; i++){\\n            hori[i][0] = grid[i][0]; \\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            verti[0][i] = grid[0][i]; \\n        }\\n        for (int i = 0; i < n; i++){\\n            for (int j = 1; j < n; j++){\\n               if (grid[i][j] == 1)\\n                hori[i][j] = hori[i][j- 1] + grid[i][j]; \\n                 else hori[i][j] = 0; \\n\\n             }\\n                   }\\n        \\n        for (int j = 0; j < n; j++){\\n            for (int i = 1; i < n; i++){\\n                if (grid[i][j] == 1)\\n                verti[i][j] = verti[i - 1][j] + grid[i][j];\\n                else verti[i][j] = 0; \\n             }\\n        }\\n        \\n        for (int k = n ; k > 0; k--){\\n            boolean holdstrue = false;\\n            for (int i = 0; i < n; i++){\\n                for (int j = 0; j < n; j++){\\n                    if (hori[i][j] >= 2*k - 1){\\n                        int center = j - (k) + 1; \\n                        if (i + k - 1 < n && center >= 0 && verti[i + k - 1][center] >= 2*k - 1 && verti[i][center] >= k - 1){\\n                            holdstrue = true; \\n                            System.out.println(i + \" \" + j); \\n                            System.out.println(i + \" \" + center);\\n                            return k; \\n                            \\n                        }\\n                    }\\n                }\\n                if (holdstrue) break;\\n            }\\n            if (holdstrue) return k; \\n        }\\n        if (mines.length < n*n)return 1; \\n        return 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881891,
                "title": "c-easy-to-understand-simple-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n     vector<vector<int> > v(n,vector<int>(n,1));\\n     for(auto &it:mines)\\n     {\\n         v[it[0]][it[1]]=0;\\n     }\\n      vector<vector<int> > top,bottom,left,right;\\n      top=left=right=bottom=v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               int x,y;\\n                x=n-1-i;\\n                y=n-1-j;\\n               if(j>0&&left[i][j])\\n               left[i][j]=left[i][j]+left[i][j-1];\\n               if(i>0&&top[i][j])\\n               top[i][j]+=top[i-1][j];\\n               if(x<n-1&&bottom[x][y])\\n               bottom[x][y]+=bottom[x+1][y];\\n               if(y<n-1&&right[x][y])\\n               right[x][y]+=right[x][y+1];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans=max(ans,min(top[i][j],min(bottom[i][j],min(left[i][j],right[i][j]))));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n     vector<vector<int> > v(n,vector<int>(n,1));\\n     for(auto &it:mines)\\n     {\\n         v[it[0]][it[1]]=0;\\n     }\\n      vector<vector<int> > top,bottom,left,right;\\n      top=left=right=bottom=v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               int x,y;\\n                x=n-1-i;\\n                y=n-1-j;\\n               if(j>0&&left[i][j])\\n               left[i][j]=left[i][j]+left[i][j-1];\\n               if(i>0&&top[i][j])\\n               top[i][j]+=top[i-1][j];\\n               if(x<n-1&&bottom[x][y])\\n               bottom[x][y]+=bottom[x+1][y];\\n               if(y<n-1&&right[x][y])\\n               right[x][y]+=right[x][y+1];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans=max(ans,min(top[i][j],min(bottom[i][j],min(left[i][j],right[i][j]))));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708638,
                "title": "approach-1-pair-type-2d-vector-approach-2-simple-2d-dp",
                "content": "```\\nstruct Cell{\\n    int ver;\\n    int hori;\\n};\\n\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int res=0;\\n        vector<vector<int>> arr(N,vector<int>(N,1));\\n        for(auto pair: mines){\\n            int x=pair[0];\\n            int y=pair[1];\\n            arr[x][y]=0;\\n        }\\n        vector<vector<Cell>> dp(N,vector<Cell>(N,{0,0}));\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                if(arr[i][j]==1){\\n                    res=1;\\n                    if(i==0 && j==0){\\n                        dp[i][j].hori=1;\\n                        dp[i][j].ver=1;\\n                    }\\n                    else if(i==0){\\n                        dp[i][j].hori=dp[i][j-1].hori+1;\\n                        dp[i][j].ver=1;\\n                    }\\n                    else if(j==0){\\n                        dp[i][j].ver=dp[i-1][j].ver+1;\\n                        dp[i][j].hori=1;\\n                    }\\n                    else{\\n                        dp[i][j].hori=dp[i][j-1].hori+1;\\n                        dp[i][j].ver=dp[i-1][j].ver+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=N-2;i>0;i--){\\n            for(int j=N-2;j>0;j--){\\n                if(dp[i][j].ver==0 || dp[i][j].hori==0 || dp[i][j].hori==1 || dp[i][j].ver==1){\\n                    continue;\\n                }\\n                int mn=min(dp[i][j].ver,dp[i][j].hori);\\n                int side=mn;\\n                while(side>0){\\n                    if(side+i-1>=N || side+j-1>=N){\\n                        side--;\\n                        continue;\\n                    }\\n                    if(dp[i][j+side-1].hori>=side && dp[i+side-1][j].ver>=side){\\n                        break;\\n                    }\\n                    side--;\\n                }\\n                res=max(res,side);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));\\n        vector<vector<int>> mat(n,vector<int>(n,1));\\n        for(auto pair: mines){\\n            int x=pair[0];\\n            int y=pair[1];\\n            mat[x][y]=0;\\n        } \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<n;j++){  //moving left->right\\n                mat[i][j]==1 ? count++ : count=0;\\n                dp[i][j]=min(dp[i][j],count);\\n            }\\n            count=0;\\n            for(int j=n-1;j>=0;j--){ //moving right->left\\n                mat[i][j]==1 ? count++ : count=0;\\n                dp[i][j]=min(dp[i][j],count);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<n;j++){  //moving top->bottom\\n                mat[j][i]==1 ? count++ : count=0;\\n                dp[j][i]=min(dp[j][i],count);\\n            }\\n            count=0;\\n            for(int j=n-1;j>=0;j--){ //moving bottom->top\\n                mat[j][i]==1 ? count++ : count=0;\\n                dp[j][i]=min(dp[j][i],count);\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            res=max(res,*max_element(dp[i].begin(),dp[i].end()));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstruct Cell{\\n    int ver;\\n    int hori;\\n};\\n\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        int res=0;\\n        vector<vector<int>> arr(N,vector<int>(N,1));\\n        for(auto pair: mines){\\n            int x=pair[0];\\n            int y=pair[1];\\n            arr[x][y]=0;\\n        }\\n        vector<vector<Cell>> dp(N,vector<Cell>(N,{0,0}));\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                if(arr[i][j]==1){\\n                    res=1;\\n                    if(i==0 && j==0){\\n                        dp[i][j].hori=1;\\n                        dp[i][j].ver=1;\\n                    }\\n                    else if(i==0){\\n                        dp[i][j].hori=dp[i][j-1].hori+1;\\n                        dp[i][j].ver=1;\\n                    }\\n                    else if(j==0){\\n                        dp[i][j].ver=dp[i-1][j].ver+1;\\n                        dp[i][j].hori=1;\\n                    }\\n                    else{\\n                        dp[i][j].hori=dp[i][j-1].hori+1;\\n                        dp[i][j].ver=dp[i-1][j].ver+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=N-2;i>0;i--){\\n            for(int j=N-2;j>0;j--){\\n                if(dp[i][j].ver==0 || dp[i][j].hori==0 || dp[i][j].hori==1 || dp[i][j].ver==1){\\n                    continue;\\n                }\\n                int mn=min(dp[i][j].ver,dp[i][j].hori);\\n                int side=mn;\\n                while(side>0){\\n                    if(side+i-1>=N || side+j-1>=N){\\n                        side--;\\n                        continue;\\n                    }\\n                    if(dp[i][j+side-1].hori>=side && dp[i+side-1][j].ver>=side){\\n                        break;\\n                    }\\n                    side--;\\n                }\\n                res=max(res,side);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));\\n        vector<vector<int>> mat(n,vector<int>(n,1));\\n        for(auto pair: mines){\\n            int x=pair[0];\\n            int y=pair[1];\\n            mat[x][y]=0;\\n        } \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<n;j++){  //moving left->right\\n                mat[i][j]==1 ? count++ : count=0;\\n                dp[i][j]=min(dp[i][j],count);\\n            }\\n            count=0;\\n            for(int j=n-1;j>=0;j--){ //moving right->left\\n                mat[i][j]==1 ? count++ : count=0;\\n                dp[i][j]=min(dp[i][j],count);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<n;j++){  //moving top->bottom\\n                mat[j][i]==1 ? count++ : count=0;\\n                dp[j][i]=min(dp[j][i],count);\\n            }\\n            count=0;\\n            for(int j=n-1;j>=0;j--){ //moving bottom->top\\n                mat[j][i]==1 ? count++ : count=0;\\n                dp[j][i]=min(dp[j][i],count);\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            res=max(res,*max_element(dp[i].begin(),dp[i].end()));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611901,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimum (int a, int b, int c, int d) {\\n       // cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\\n        int ans = min(a,b);\\n        ans = min(ans, c);\\n        ans = min(ans, d);\\n        return ans;\\n    }\\n    \\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n, vector<int> (n, 1));\\n        vector<vector<int>> left(n, vector<int> (n, 0));\\n        vector<vector<int>> right(n, vector<int> (n, 0));\\n        vector<vector<int>> up(n, vector<int> (n, 0));\\n        vector<vector<int>> down(n, vector<int> (n, 0));\\n        bool seen = false;\\n        \\n        for (auto m : mines) {\\n            int x = m[0];\\n            int y = m[1];\\n            grid[x][y] = 0;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j]) {\\n                    seen = true;\\n                    if (i == 0) up[i][j] = 1;\\n                    else up[i][j] = 1+up[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n             for (int j = 0; j < n; j++) {\\n                if (grid[i][j]) {\\n                    seen = true;\\n                    if (i == n-1) down[i][j] = 1;\\n                    else down[i][j] = 1+down[i+1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (grid[i][j]) {\\n                    if (j == 0) left[i][j] = 1;\\n                    else left[i][j] = 1+left[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            for (int i = 0; i < n; i++) {\\n                if (grid[i][j]) {\\n                    seen = true;\\n                    if (j == n-1) right[i][j] = 1;\\n                    else right[i][j] = 1+right[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                //if (grid[i][j]) {\\n                    ans = max(ans, minimum(up[i][j], left[i][j], right[i][j], down[i][j]));\\n                //}\\n            }\\n        }\\n        \\n        if (ans == 0 && seen) ans = 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimum (int a, int b, int c, int d) {\\n       // cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\\n        int ans = min(a,b);\\n        ans = min(ans, c);\\n        ans = min(ans, d);\\n        return ans;\\n    }\\n    \\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n, vector<int> (n, 1));\\n        vector<vector<int>> left(n, vector<int> (n, 0));\\n        vector<vector<int>> right(n, vector<int> (n, 0));\\n        vector<vector<int>> up(n, vector<int> (n, 0));\\n        vector<vector<int>> down(n, vector<int> (n, 0));\\n        bool seen = false;\\n        \\n        for (auto m : mines) {\\n            int x = m[0];\\n            int y = m[1];\\n            grid[x][y] = 0;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j]) {\\n                    seen = true;\\n                    if (i == 0) up[i][j] = 1;\\n                    else up[i][j] = 1+up[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n             for (int j = 0; j < n; j++) {\\n                if (grid[i][j]) {\\n                    seen = true;\\n                    if (i == n-1) down[i][j] = 1;\\n                    else down[i][j] = 1+down[i+1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (grid[i][j]) {\\n                    if (j == 0) left[i][j] = 1;\\n                    else left[i][j] = 1+left[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            for (int i = 0; i < n; i++) {\\n                if (grid[i][j]) {\\n                    seen = true;\\n                    if (j == n-1) right[i][j] = 1;\\n                    else right[i][j] = 1+right[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                //if (grid[i][j]) {\\n                    ans = max(ans, minimum(up[i][j], left[i][j], right[i][j], down[i][j]));\\n                //}\\n            }\\n        }\\n        \\n        if (ans == 0 && seen) ans = 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1461303,
                "title": "python3-most-simple-implementation",
                "content": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        grid = [[1 for j in range(n)] for i in range(n)]\\n        for r,c in mines: grid[r][c] = 0\\n            \\n        left = [[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            count = 0\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                left[i][j] = count\\n                \\n                    \\n        right = [[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            count = 0\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                right[i][j] = count\\n                \\n                    \\n        \\n        up = [[0 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            count = 0\\n            for i in range(n):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                up[i][j] = count\\n                \\n                    \\n        down = [[0 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            count = 0\\n            for i in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                down[i][j] = count\\n                \\n           \\n        max_plus = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    curr_plus = min(left[i][j],right[i][j],up[i][j],down[i][j])\\n                    max_plus = max(max_plus, curr_plus)\\n        \\n        return max_plus\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        grid = [[1 for j in range(n)] for i in range(n)]\\n        for r,c in mines: grid[r][c] = 0\\n            \\n        left = [[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            count = 0\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                left[i][j] = count\\n                \\n                    \\n        right = [[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            count = 0\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                right[i][j] = count\\n                \\n                    \\n        \\n        up = [[0 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            count = 0\\n            for i in range(n):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                up[i][j] = count\\n                \\n                    \\n        down = [[0 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            count = 0\\n            for i in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    count += 1\\n                else: \\n                    count = 0\\n                down[i][j] = count\\n                \\n           \\n        max_plus = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    curr_plus = min(left[i][j],right[i][j],up[i][j],down[i][j])\\n                    max_plus = max(max_plus, curr_plus)\\n        \\n        return max_plus\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455232,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(n, vector<int>(n, 1));\\n        unordered_set<int> mineSet;\\n        for(auto& e: mines) mineSet.insert(e[0]*n + e[1]);\\n        int ans = 0;\\n        for(int j = 0; j < n; j++){ \\n            for(int i = 0, cnt = 0; i < n; i++){      \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = cnt;\\n            }\\n            \\n            for(int i = n - 1, cnt = 0; i >= 0; i--){ \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = min(dp[i][j], cnt);\\n            }            \\n        }\\n        \\n        for(int i = 0; i < n; i++){ \\n            for(int j = 0, cnt = 0; j < n; j++){      \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = min(dp[i][j], cnt);\\n            }\\n            \\n            for(int j = n - 1, cnt = 0; j >= 0; j--){ \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = min(dp[i][j], cnt);\\n                ans = max(ans, dp[i][j]);\\n            }            \\n        }        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(n, vector<int>(n, 1));\\n        unordered_set<int> mineSet;\\n        for(auto& e: mines) mineSet.insert(e[0]*n + e[1]);\\n        int ans = 0;\\n        for(int j = 0; j < n; j++){ \\n            for(int i = 0, cnt = 0; i < n; i++){      \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = cnt;\\n            }\\n            \\n            for(int i = n - 1, cnt = 0; i >= 0; i--){ \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = min(dp[i][j], cnt);\\n            }            \\n        }\\n        \\n        for(int i = 0; i < n; i++){ \\n            for(int j = 0, cnt = 0; j < n; j++){      \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = min(dp[i][j], cnt);\\n            }\\n            \\n            for(int j = n - 1, cnt = 0; j >= 0; j--){ \\n                cnt = mineSet.count(i*n+j) ? 0 : cnt + 1;\\n                dp[i][j] = min(dp[i][j], cnt);\\n                ans = max(ans, dp[i][j]);\\n            }            \\n        }        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455167,
                "title": "python-dynamic-programming-explained",
                "content": "**Intuition:**\\nWe can convert this to 4 pieces of one dimensional array problem\\nLet\\'s say we have ```A = [1, 1, 1, 1, 0, 1, 1, 1, 1]```\\nWe will solve the left side 1st.\\nFor each index ```i (0 <= i < len(A))```, we need to find how many consecutive ones are present in the left side from the current index.\\n\\n```\\ni = 0\\nA = [1]\\n```\\nThere\\'s no left side, hence ```dp[0] = 1```\\n\\n\\n```\\ni = 1\\nA = [1, 1]\\n\\t\\t^\\n```\\nThere is a \"1\" to the left of current index, hence ```dp[1] = dp[0] + 1 = 1+1 = 2```\\n\\n\\n```\\ni = 2\\nA = [1, 1, 1]\\n\\t\\t   ^\\n```\\nThere is a \"1\" to the left of current index, hence ```dp[2] = dp[1] + 1 = 2+1 = 3```\\n\\n\\n```\\ni = 3\\nA = [1, 1, 1, 0]\\n              ^\\n```\\t\\t\\t\\t\\nSince current index has value as 0, it cannot be extended to left (or any direction), hence dp[3] = 0\\n\\n\\n\\nAnd so on.. So the dp formula for left side is ```dp[i] = dp[i-1] + 1 if d[i] == 1```\\n\\nSimilary, we can formulate for right, up and down\\n\\nAs the problem is a matrix (2-D), we will have to add another loop to find the dp values for each row\\nand dp array has to be 2-D.\\n\\nFor up and down, we will consider columns as rows and the column values should be in i loop and rows in j loop.\\n\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n\\n        grid     = [ [1]*n for _ in range(n) ]\\n        left_dp  = [ [1]*n for _ in range(n) ]\\n        right_dp = [ [1]*n for _ in range(n) ]\\n        down_dp  = [ [1]*n for _ in range(n) ]\\n        up_dp    = [ [1]*n for _ in range(n) ]\\n        \\n        for i, j in mines:\\n            grid[i][j] = left_dp[i][j] = right_dp[i][j] = down_dp[i][j] = up_dp[i][j] = 0\\n        \\n        for i in range(n):\\n            \\n            for j in range(1, n):\\n                if left_dp[i][j] and left_dp[i][j-1] > 0:\\n                    left_dp[i][j] = left_dp[i][j-1] + 1\\n            \\n            for j in range(n-2, -1, -1):\\n                if right_dp[i][j] and right_dp[i][j+1] > 0:\\n                    right_dp[i][j] = right_dp[i][j+1] + 1\\n \\n\\n        for j in range(n):\\n            \\n            for i in range(1, n):\\n                if up_dp[i][j] and up_dp[i-1][j] > 0:\\n                    up_dp[i][j] = up_dp[i-1][j] + 1\\n                    \\n            for i in range(n-2, -1, -1):\\n                if down_dp[i][j] and down_dp[i+1][j] > 0:\\n                    down_dp[i][j] = down_dp[i+1][j] + 1\\n                        \\n        res = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    res = max(res, min(left_dp[i][j], right_dp[i][j], up_dp[i][j], down_dp[i][j]))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```A = [1, 1, 1, 1, 0, 1, 1, 1, 1]```\n```i (0 <= i < len(A))```\n```\\ni = 0\\nA = [1]\\n```\n```dp[0] = 1```\n```\\ni = 1\\nA = [1, 1]\\n\\t\\t^\\n```\n```dp[1] = dp[0] + 1 = 1+1 = 2```\n```\\ni = 2\\nA = [1, 1, 1]\\n\\t\\t   ^\\n```\n```dp[2] = dp[1] + 1 = 2+1 = 3```\n```\\ni = 3\\nA = [1, 1, 1, 0]\\n              ^\\n```\n```dp[i] = dp[i-1] + 1 if d[i] == 1```\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n\\n        grid     = [ [1]*n for _ in range(n) ]\\n        left_dp  = [ [1]*n for _ in range(n) ]\\n        right_dp = [ [1]*n for _ in range(n) ]\\n        down_dp  = [ [1]*n for _ in range(n) ]\\n        up_dp    = [ [1]*n for _ in range(n) ]\\n        \\n        for i, j in mines:\\n            grid[i][j] = left_dp[i][j] = right_dp[i][j] = down_dp[i][j] = up_dp[i][j] = 0\\n        \\n        for i in range(n):\\n            \\n            for j in range(1, n):\\n                if left_dp[i][j] and left_dp[i][j-1] > 0:\\n                    left_dp[i][j] = left_dp[i][j-1] + 1\\n            \\n            for j in range(n-2, -1, -1):\\n                if right_dp[i][j] and right_dp[i][j+1] > 0:\\n                    right_dp[i][j] = right_dp[i][j+1] + 1\\n \\n\\n        for j in range(n):\\n            \\n            for i in range(1, n):\\n                if up_dp[i][j] and up_dp[i-1][j] > 0:\\n                    up_dp[i][j] = up_dp[i-1][j] + 1\\n                    \\n            for i in range(n-2, -1, -1):\\n                if down_dp[i][j] and down_dp[i+1][j] > 0:\\n                    down_dp[i][j] = down_dp[i+1][j] + 1\\n                        \\n        res = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    res = max(res, min(left_dp[i][j], right_dp[i][j], up_dp[i][j], down_dp[i][j]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455150,
                "title": "c-dp-solution",
                "content": "- time: O(N^2)\\n- space: O(N^2)\\n```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n        // build the grid\\n        int[,] grid = new int[n,n];\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                grid[i,j] = 1;\\n            }\\n        }\\n        \\n        foreach(var mine in mines)\\n        {\\n            grid[mine[0],mine[1]] = 0;\\n        }\\n        \\n        // build the dp array. dp[i,j]: minimal length of the four arms starting from (i,j)\\n        int[,] dp = new int[n,n];\\n        for(int row = 0; row < n; row++)\\n        {\\n            // left -> right\\n            int maxLength = 0;\\n            for(int col = 0; col < n; col++)\\n            {\\n                maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                dp[row,col] = maxLength;\\n            }\\n            \\n            // right -> left\\n            maxLength = 0;\\n            {\\n                for(int col = n - 1; col >= 0; col--)\\n                {\\n                    maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                    dp[row,col] = Math.Min(dp[row,col], maxLength);\\n                }\\n            }\\n        }\\n        \\n        for(int col = 0; col < n; col++)\\n        {\\n            // up -> down\\n            int maxLength = 0;\\n            for(int row = 0; row < n; row++)\\n            {\\n                maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                dp[row,col] = Math.Min(dp[row,col], maxLength);\\n            }\\n            \\n            // down -> up\\n            maxLength = 0;\\n            for(int row = n - 1; row >= 0; row--)\\n            {\\n                maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                dp[row,col] = Math.Min(dp[row,col], maxLength);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                res = Math.Max(res, dp[i,j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n        // build the grid\\n        int[,] grid = new int[n,n];\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                grid[i,j] = 1;\\n            }\\n        }\\n        \\n        foreach(var mine in mines)\\n        {\\n            grid[mine[0],mine[1]] = 0;\\n        }\\n        \\n        // build the dp array. dp[i,j]: minimal length of the four arms starting from (i,j)\\n        int[,] dp = new int[n,n];\\n        for(int row = 0; row < n; row++)\\n        {\\n            // left -> right\\n            int maxLength = 0;\\n            for(int col = 0; col < n; col++)\\n            {\\n                maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                dp[row,col] = maxLength;\\n            }\\n            \\n            // right -> left\\n            maxLength = 0;\\n            {\\n                for(int col = n - 1; col >= 0; col--)\\n                {\\n                    maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                    dp[row,col] = Math.Min(dp[row,col], maxLength);\\n                }\\n            }\\n        }\\n        \\n        for(int col = 0; col < n; col++)\\n        {\\n            // up -> down\\n            int maxLength = 0;\\n            for(int row = 0; row < n; row++)\\n            {\\n                maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                dp[row,col] = Math.Min(dp[row,col], maxLength);\\n            }\\n            \\n            // down -> up\\n            maxLength = 0;\\n            for(int row = n - 1; row >= 0; row--)\\n            {\\n                maxLength = grid[row,col] == 0? 0 : maxLength + 1;\\n                dp[row,col] = Math.Min(dp[row,col], maxLength);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                res = Math.Max(res, dp[i,j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454872,
                "title": "easy-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>matrix (n,vector<int>(n,n));\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            for(int j=0 ; j<n ; j++) {\\n                matrix[i][j] = 1 ;\\n            }\\n        }\\n        for(auto mine : mines) {\\n            matrix[mine[0]][mine[1]] = 0 ;\\n        }\\n        \\n        vector<vector<int>>left (n,vector<int>(n,n));\\n        vector<vector<int>>right (n,vector<int>(n,n));\\n        vector<vector<int>>top (n,vector<int>(n,n));\\n        vector<vector<int>>bottom (n,vector<int>(n,n));\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            for(int j=0 ; j<n ; j++) {\\n                if(matrix[i][j] == 0) {\\n                    left[i][j] = 0 ;\\n                    top[i][j] = 0 ;\\n                } else {\\n                    if(i==0) {\\n                        top[i][j] = 1 ;\\n                    } else {\\n                        top[i][j] = top[i-1][j] + 1 ;\\n                    }\\n                    if(j==0) {\\n                        left[i][j] = 1 ;\\n                    } else {\\n                        left[i][j] = left[i][j-1] + 1 ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1 ; i>=0 ; i--) {\\n            for(int j=n-1 ; j>=0 ; j--) {\\n                if(matrix[i][j] == 0) {\\n                    right[i][j] = 0 ;\\n                    bottom[i][j] = 0 ;\\n                } else {\\n                    if(i==n-1) {\\n                        right[i][j] = 1 ;\\n                    } else {\\n                        right[i][j] = right[i+1][j] + 1 ;\\n                    }\\n                    if(j==n-1) {\\n                        bottom[i][j] = 1 ;\\n                    } else {\\n                        bottom[i][j] = bottom[i][j+1] + 1 ;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = INT_MIN ;\\n        for(int i=0 ; i<n ; i++) {\\n            for(int j=0 ; j<n ; j++) {\\n                ans = max(ans, min(min(left[i][j],bottom[i][j]),min(right[i][j],top[i][j]))) ;\\n            }\\n        }\\n        return ans ;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>matrix (n,vector<int>(n,n));\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            for(int j=0 ; j<n ; j++) {\\n                matrix[i][j] = 1 ;\\n            }\\n        }\\n        for(auto mine : mines) {\\n            matrix[mine[0]][mine[1]] = 0 ;\\n        }\\n        \\n        vector<vector<int>>left (n,vector<int>(n,n));\\n        vector<vector<int>>right (n,vector<int>(n,n));\\n        vector<vector<int>>top (n,vector<int>(n,n));\\n        vector<vector<int>>bottom (n,vector<int>(n,n));\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            for(int j=0 ; j<n ; j++) {\\n                if(matrix[i][j] == 0) {\\n                    left[i][j] = 0 ;\\n                    top[i][j] = 0 ;\\n                } else {\\n                    if(i==0) {\\n                        top[i][j] = 1 ;\\n                    } else {\\n                        top[i][j] = top[i-1][j] + 1 ;\\n                    }\\n                    if(j==0) {\\n                        left[i][j] = 1 ;\\n                    } else {\\n                        left[i][j] = left[i][j-1] + 1 ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1 ; i>=0 ; i--) {\\n            for(int j=n-1 ; j>=0 ; j--) {\\n                if(matrix[i][j] == 0) {\\n                    right[i][j] = 0 ;\\n                    bottom[i][j] = 0 ;\\n                } else {\\n                    if(i==n-1) {\\n                        right[i][j] = 1 ;\\n                    } else {\\n                        right[i][j] = right[i+1][j] + 1 ;\\n                    }\\n                    if(j==n-1) {\\n                        bottom[i][j] = 1 ;\\n                    } else {\\n                        bottom[i][j] = bottom[i][j+1] + 1 ;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = INT_MIN ;\\n        for(int i=0 ; i<n ; i++) {\\n            for(int j=0 ; j<n ; j++) {\\n                ans = max(ans, min(min(left[i][j],bottom[i][j]),min(right[i][j],top[i][j]))) ;\\n            }\\n        }\\n        return ans ;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454422,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        lookup = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        grid = [[1 for _ in range(n)] for _ in range(n)]\\n        for x, y in mines:\\n            grid[x][y] = 0\\n\\n        largestPlusSignOrder = 0\\n\\n        # Iterate forward then backward\\n        for x in range(n):\\n            plusSign = 0\\n            for y in range(n):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = plusSign\\n            plusSign = 0\\n            for y in range(n - 1, -1, -1):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = min(lookup[x][y], plusSign)\\n\\n        # Iterate downward then upward\\n        for y in range(n):\\n            plusSign = 0\\n            for x in range(n):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = min(lookup[x][y], plusSign)\\n            plusSign = 0\\n            for x in range(n - 1, -1, -1):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = min(lookup[x][y], plusSign)\\n                largestPlusSignOrder = max(largestPlusSignOrder, lookup[x][y])\\n\\n        return largestPlusSignOrder\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        lookup = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        grid = [[1 for _ in range(n)] for _ in range(n)]\\n        for x, y in mines:\\n            grid[x][y] = 0\\n\\n        largestPlusSignOrder = 0\\n\\n        # Iterate forward then backward\\n        for x in range(n):\\n            plusSign = 0\\n            for y in range(n):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = plusSign\\n            plusSign = 0\\n            for y in range(n - 1, -1, -1):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = min(lookup[x][y], plusSign)\\n\\n        # Iterate downward then upward\\n        for y in range(n):\\n            plusSign = 0\\n            for x in range(n):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = min(lookup[x][y], plusSign)\\n            plusSign = 0\\n            for x in range(n - 1, -1, -1):\\n                if grid[x][y] == 1:\\n                    plusSign += 1\\n                else:\\n                    plusSign = 0\\n                lookup[x][y] = min(lookup[x][y], plusSign)\\n                largestPlusSignOrder = max(largestPlusSignOrder, lookup[x][y])\\n\\n        return largestPlusSignOrder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454246,
                "title": "run-code-and-submit-giving-different-verdicts",
                "content": "This solution is getting accepted.\\n```\\nclass Solution {\\npublic:\\n    int grid[500][500];\\n    int ans[500][500][4];\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                grid[i][j]= 1;\\n            }\\n        }\\n        for(auto e: mines)\\n        {\\n            grid[e[0]][e[1]]= 0;\\n        }\\n        if(mines.size() == n*n)\\n        {\\n            return 0;\\n        }\\n        vector<pair<int, int>> moves= {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 2; ind < 4; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i= n-1; i >= 0; i--)\\n        {\\n            for(int j= n-1; j >= 0; j--)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 0; ind < 2; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ret= 0;\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                int temp= 1e9;\\n                for(int ind= 0; ind < 4; ind++)\\n                {\\n                    temp= min(temp, ans[i][j][ind]);\\n                }\\n                ret= max(ret, temp);\\n            }\\n        }\\n        return (ret+1);\\n    }\\n};\\n```\\nBut this is giving wrong answer.\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int grid[500][500];\\n        int ans[500][500][4];\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                grid[i][j]= 1;\\n            }\\n        }\\n        for(auto e: mines)\\n        {\\n            grid[e[0]][e[1]]= 0;\\n        }\\n        if(mines.size() == n*n)\\n        {\\n            return 0;\\n        }\\n        vector<pair<int, int>> moves= {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 2; ind < 4; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i= n-1; i >= 0; i--)\\n        {\\n            for(int j= n-1; j >= 0; j--)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 0; ind < 2; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ret= 0;\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                int temp= 1e9;\\n                for(int ind= 0; ind < 4; ind++)\\n                {\\n                    temp= min(temp, ans[i][j][ind]);\\n                }\\n                ret= max(ret, temp);\\n            }\\n        }\\n        return (ret+1);\\n    }\\n};\\n```\\nThe only difference between the two codes is that the two arrays(grid, ans) have been moved inside the function in the second code.\\nI get wrong answer when I submit but running the code for that failing case gives correct answer. This does not have any global values which might not be updated, so I am not able to understand why the first one works but the second one doesn\\'t. Can someone please explain what is happening.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int grid[500][500];\\n    int ans[500][500][4];\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                grid[i][j]= 1;\\n            }\\n        }\\n        for(auto e: mines)\\n        {\\n            grid[e[0]][e[1]]= 0;\\n        }\\n        if(mines.size() == n*n)\\n        {\\n            return 0;\\n        }\\n        vector<pair<int, int>> moves= {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 2; ind < 4; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i= n-1; i >= 0; i--)\\n        {\\n            for(int j= n-1; j >= 0; j--)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 0; ind < 2; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ret= 0;\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                int temp= 1e9;\\n                for(int ind= 0; ind < 4; ind++)\\n                {\\n                    temp= min(temp, ans[i][j][ind]);\\n                }\\n                ret= max(ret, temp);\\n            }\\n        }\\n        return (ret+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int grid[500][500];\\n        int ans[500][500][4];\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                grid[i][j]= 1;\\n            }\\n        }\\n        for(auto e: mines)\\n        {\\n            grid[e[0]][e[1]]= 0;\\n        }\\n        if(mines.size() == n*n)\\n        {\\n            return 0;\\n        }\\n        vector<pair<int, int>> moves= {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 2; ind < 4; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i= n-1; i >= 0; i--)\\n        {\\n            for(int j= n-1; j >= 0; j--)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int ind= 0; ind < 2; ind++)\\n                    {\\n                        ans[i][j][ind]= 0;\\n                        int x1= moves[ind].first;\\n                        int y1= moves[ind].second;\\n                        if((i+x1 < 0) || (i+x1 >= n) || (j+y1 < 0) || (j+y1 >= n))\\n                        {\\n                            continue;\\n                        }\\n                        if(grid[i+x1][j+y1])\\n                        {\\n                            ans[i][j][ind]= ans[i+x1][j+y1][ind]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ret= 0;\\n        for(int i= 0; i < n; i++)\\n        {\\n            for(int j= 0; j < n; j++)\\n            {\\n                int temp= 1e9;\\n                for(int ind= 0; ind < 4; ind++)\\n                {\\n                    temp= min(temp, ans[i][j][ind]);\\n                }\\n                ret= max(ret, temp);\\n            }\\n        }\\n        return (ret+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454000,
                "title": "largest-plus-sign-c-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<set<int>> rows(n, {-1, n});\\n        vector<set<int>> cols(n, {-1, n});\\n        \\n        for(auto &p : mines) {\\n            rows[p[1]].insert(p[0]);\\n            cols[p[0]].insert(p[1]);\\n        }\\n        \\n        int max_p = 0;\\n        for(int r = 0; r < n; ++r) {\\n            for(int c = 0; c < n; ++c) {\\n                auto hl = rows[r].upper_bound(c);\\n                auto hr = hl--;\\n                int h = min(c - *hl, *hr - c);\\n                \\n                auto vl = cols[c].upper_bound(r);\\n                auto vr = vl--;\\n                int v = min(r - *vl, *vr - r);\\n                \\n                max_p = max(max_p, min(h, v));\\n            }\\n        }\\n        \\n        return max_p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<set<int>> rows(n, {-1, n});\\n        vector<set<int>> cols(n, {-1, n});\\n        \\n        for(auto &p : mines) {\\n            rows[p[1]].insert(p[0]);\\n            cols[p[0]].insert(p[1]);\\n        }\\n        \\n        int max_p = 0;\\n        for(int r = 0; r < n; ++r) {\\n            for(int c = 0; c < n; ++c) {\\n                auto hl = rows[r].upper_bound(c);\\n                auto hr = hl--;\\n                int h = min(c - *hl, *hr - c);\\n                \\n                auto vl = cols[c].upper_bound(r);\\n                auto vr = vl--;\\n                int v = min(r - *vl, *vr - r);\\n                \\n                max_p = max(max_p, min(h, v));\\n            }\\n        }\\n        \\n        return max_p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453952,
                "title": "kotlin-o-n-2-solution",
                "content": "```\\nfun orderOfLargestPlusSign(n: Int, mines: Array<IntArray>): Int {\\n        \\n        // Setup initial state\\n        // This matrix stores minimum vertical and horizontal pathes to zero\\n        val minPathes = Array<Array<IntArray>>(n) {\\n            Array<IntArray>(n) { intArrayOf(Int.MAX_VALUE - 2, Int.MAX_VALUE - 2) }\\n        }\\n        \\n        // Place zeroes to the matrix\\n        for (mine in mines) {\\n            minPathes[mine[0]][mine[1]][0] = 0\\n            minPathes[mine[0]][mine[1]][1] = 0\\n        }\\n        \\n        // Walk through the grid forward from left to right and from top to bottom.\\n        // For each cell set minimum left path and minimum top path.\\n        // So if we at cell (1, 2) we would look up at cell (0, 2) and left\\n        // at cell (1, 1) to find out minimum top and left pathes to zero\\n        for (i in 0 until n) {\\n            for (j in 0 until n) {\\n                // Find out top path to zero which is top path of the top cell + 1, \\n                // or 1 if there is no top cell\\n                val topPath = if (i > 0) minPathes[i - 1][j][0] + 1 else 1\\n                \\n                // Same for the left path\\n                val leftPath = if(j > 0) minPathes[i][j - 1][1] + 1 else 1\\n                \\n                // Now set minimum top and left pathes for current cell\\n                minPathes[i][j][0] = minOf(minPathes[i][j][0], topPath)\\n                minPathes[i][j][1] = minOf(minPathes[i][j][1], leftPath)\\n            }\\n        }\\n        \\n        var maxPath = 0\\n        \\n        // Now walk back through grid from right to left and from bottom to top.\\n        // Here we will find minimum right and bottom pathes to zeroes for each cell.\\n        // And as we already know left and top pathes, we can actually calculate maximum\\n        // vertical and horizontal pathes to zero and find out maximal plus sign order for\\n        // current cell. We track maximum plus sign order walking through the grid \\n        // and return this value after all\\n        for (i in n - 1 downTo 0) {\\n            for (j in n - 1 downTo 0) {\\n                val bottomPath = if (i < n - 1) minPathes[i + 1][j][0] + 1 else 1\\n                val rightPath = if (j < n - 1) minPathes[i][j + 1][1] + 1 else 1\\n                \\n                minPathes[i][j][0] = minOf(minPathes[i][j][0], bottomPath)\\n                minPathes[i][j][1] = minOf(minPathes[i][j][1], rightPath)\\n                maxPath = maxOf(minPathes[i][j].min() ?: 0, maxPath)\\n            }\\n        }\\n\\n        return maxPath\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun orderOfLargestPlusSign(n: Int, mines: Array<IntArray>): Int {\\n        \\n        // Setup initial state\\n        // This matrix stores minimum vertical and horizontal pathes to zero\\n        val minPathes = Array<Array<IntArray>>(n) {\\n            Array<IntArray>(n) { intArrayOf(Int.MAX_VALUE - 2, Int.MAX_VALUE - 2) }\\n        }\\n        \\n        // Place zeroes to the matrix\\n        for (mine in mines) {\\n            minPathes[mine[0]][mine[1]][0] = 0\\n            minPathes[mine[0]][mine[1]][1] = 0\\n        }\\n        \\n        // Walk through the grid forward from left to right and from top to bottom.\\n        // For each cell set minimum left path and minimum top path.\\n        // So if we at cell (1, 2) we would look up at cell (0, 2) and left\\n        // at cell (1, 1) to find out minimum top and left pathes to zero\\n        for (i in 0 until n) {\\n            for (j in 0 until n) {\\n                // Find out top path to zero which is top path of the top cell + 1, \\n                // or 1 if there is no top cell\\n                val topPath = if (i > 0) minPathes[i - 1][j][0] + 1 else 1\\n                \\n                // Same for the left path\\n                val leftPath = if(j > 0) minPathes[i][j - 1][1] + 1 else 1\\n                \\n                // Now set minimum top and left pathes for current cell\\n                minPathes[i][j][0] = minOf(minPathes[i][j][0], topPath)\\n                minPathes[i][j][1] = minOf(minPathes[i][j][1], leftPath)\\n            }\\n        }\\n        \\n        var maxPath = 0\\n        \\n        // Now walk back through grid from right to left and from bottom to top.\\n        // Here we will find minimum right and bottom pathes to zeroes for each cell.\\n        // And as we already know left and top pathes, we can actually calculate maximum\\n        // vertical and horizontal pathes to zero and find out maximal plus sign order for\\n        // current cell. We track maximum plus sign order walking through the grid \\n        // and return this value after all\\n        for (i in n - 1 downTo 0) {\\n            for (j in n - 1 downTo 0) {\\n                val bottomPath = if (i < n - 1) minPathes[i + 1][j][0] + 1 else 1\\n                val rightPath = if (j < n - 1) minPathes[i][j + 1][1] + 1 else 1\\n                \\n                minPathes[i][j][0] = minOf(minPathes[i][j][0], bottomPath)\\n                minPathes[i][j][1] = minOf(minPathes[i][j][1], rightPath)\\n                maxPath = maxOf(minPathes[i][j].min() ?: 0, maxPath)\\n            }\\n        }\\n\\n        return maxPath\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447650,
                "title": "normal-approach-not-dp",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} mines\\n * @return {number}\\n */\\nvar orderOfLargestPlusSign = function(n, mines) {\\n    const row = n; column = n\\n    const matrix = Array.from(Array(n), () => Array(n).fill(1))\\n    for(let [x,y] of mines) {\\n        // console.log(x, y)\\n        matrix[x][y] = 0\\n    }\\n    let max = 1, flag = false\\n    for(let i = 0; i < n; i++) {\\n        for(let j = 0; j < n; j++) {\\n            if(matrix[i][j] === 1){\\n                max = callCheck(1, max, matrix, i, j)\\n                flag = true\\n            }\\n        }\\n    }\\n    \\n    return flag ? max : 0\\n};\\n\\nconst callCheck = (k, max, matrix, i, j) => {\\n    if(i-k < 0 || i+k >= matrix.length || j-k < 0 || j+k >= matrix.length || (matrix[i][j-k] === 0 || matrix[i][j+k] === 0 || matrix[i-k][j] === 0 || matrix[i+k][j] === 0))\\n        return max\\n    k++\\n    max = Math.max(max, k)\\n    return callCheck(k, max, matrix, i, j)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} mines\\n * @return {number}\\n */\\nvar orderOfLargestPlusSign = function(n, mines) {\\n    const row = n; column = n\\n    const matrix = Array.from(Array(n), () => Array(n).fill(1))\\n    for(let [x,y] of mines) {\\n        // console.log(x, y)\\n        matrix[x][y] = 0\\n    }\\n    let max = 1, flag = false\\n    for(let i = 0; i < n; i++) {\\n        for(let j = 0; j < n; j++) {\\n            if(matrix[i][j] === 1){\\n                max = callCheck(1, max, matrix, i, j)\\n                flag = true\\n            }\\n        }\\n    }\\n    \\n    return flag ? max : 0\\n};\\n\\nconst callCheck = (k, max, matrix, i, j) => {\\n    if(i-k < 0 || i+k >= matrix.length || j-k < 0 || j+k >= matrix.length || (matrix[i][j-k] === 0 || matrix[i][j+k] === 0 || matrix[i-k][j] === 0 || matrix[i+k][j] === 0))\\n        return max\\n    k++\\n    max = Math.max(max, k)\\n    return callCheck(k, max, matrix, i, j)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339195,
                "title": "java-fast-solution-iterating-matrix-only-once",
                "content": "You can calculate all the left,right,top,bottom in one matrix iteration.\\n\\nFirst init the grid as -2 to know we havent visited it yet. \\nand keep the mines as -1 to make sure all the mines are marked ( eliminates the use of set and O(logn) factor for every iteration)\\n\\nif not visited then put the value as it is\\nif visted then use the min of the left,right,top,bottom value or exisitng value\\n\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n        \\n        int dp[][] = new int[n][n];\\n        \\n        if(mines.length == dp.length*dp.length)\\n            return 0;\\n        \\n        for(int i=0;i<dp.length;i++)\\n            for(int j=0;j<dp.length;j++)\\n                dp[i][j] = -2;\\n        \\n        for(int i=0;i<mines.length;i++){\\n            dp[mines[i][0]][mines[i][1]] = -1;\\n        }\\n        \\n        \\n        \\n        int left = 0;\\n        int right =0;\\n        int top = 0;\\n        int bottom = 0;\\n        \\n        for(int i=0;i<dp.length;i++){\\n            \\n            for(int j=0;j<dp.length;j++) {\\n                \\n                if(dp[i][j] == -1) {\\n                    left=0;\\n                }\\n                else {\\n                    \\n                    if(dp[i][j] == -2)\\n                        dp[i][j] = left;\\n                    else\\n                    dp[i][j] = Math.min(dp[i][j],left);\\n                    \\n                    left++;\\n                }\\n                \\n                if(dp[i][dp.length-j-1] == -1)\\n                {\\n                    right = 0;\\n                }else\\n                {\\n                    if(dp[i][dp.length-j-1] == -2)\\n                        dp[i][dp.length-j-1] = right;\\n                    else\\n                    dp[i][dp.length-j-1] = Math.min(dp[i][dp.length-j-1],right);\\n                    \\n                    right++;\\n                }\\n                \\n                \\n                if(dp[j][i] == -1)\\n                {\\n                    top = 0;\\n                }else\\n                {\\n                    if(dp[j][i] == -2)\\n                        dp[j][i] = top;\\n                    else\\n                    dp[j][i] = Math.min(dp[j][i],top);\\n                    \\n                    top++;\\n                }\\n                \\n                \\n                if(dp[dp.length-j-1][i] == -1)\\n                {\\n                    bottom = 0;\\n                }else\\n                {\\n                    if(dp[dp.length-j-1][i] == -2)\\n                        dp[dp.length-j-1][i] = bottom;\\n                    else\\n                    dp[dp.length-j-1][i] = Math.min(dp[dp.length-j-1][i],bottom);\\n                    \\n                    bottom++;\\n                }\\n                \\n\\n            }\\n            \\n            left=0;\\n            right=0;\\n            bottom=0;\\n            top=0;\\n        }\\n        int max=0;\\n        for(int i=0;i<dp.length;i++) {\\n            \\n            for(int j=0;j<dp.length;j++) {\\n                \\n            if(max<dp[i][j])\\n                max = dp[i][j];\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return max+1;\\n        \\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        \\n        \\n        int dp[][] = new int[n][n];\\n        \\n        if(mines.length == dp.length*dp.length)\\n            return 0;\\n        \\n        for(int i=0;i<dp.length;i++)\\n            for(int j=0;j<dp.length;j++)\\n                dp[i][j] = -2;\\n        \\n        for(int i=0;i<mines.length;i++){\\n            dp[mines[i][0]][mines[i][1]] = -1;\\n        }\\n        \\n        \\n        \\n        int left = 0;\\n        int right =0;\\n        int top = 0;\\n        int bottom = 0;\\n        \\n        for(int i=0;i<dp.length;i++){\\n            \\n            for(int j=0;j<dp.length;j++) {\\n                \\n                if(dp[i][j] == -1) {\\n                    left=0;\\n                }\\n                else {\\n                    \\n                    if(dp[i][j] == -2)\\n                        dp[i][j] = left;\\n                    else\\n                    dp[i][j] = Math.min(dp[i][j],left);\\n                    \\n                    left++;\\n                }\\n                \\n                if(dp[i][dp.length-j-1] == -1)\\n                {\\n                    right = 0;\\n                }else\\n                {\\n                    if(dp[i][dp.length-j-1] == -2)\\n                        dp[i][dp.length-j-1] = right;\\n                    else\\n                    dp[i][dp.length-j-1] = Math.min(dp[i][dp.length-j-1],right);\\n                    \\n                    right++;\\n                }\\n                \\n                \\n                if(dp[j][i] == -1)\\n                {\\n                    top = 0;\\n                }else\\n                {\\n                    if(dp[j][i] == -2)\\n                        dp[j][i] = top;\\n                    else\\n                    dp[j][i] = Math.min(dp[j][i],top);\\n                    \\n                    top++;\\n                }\\n                \\n                \\n                if(dp[dp.length-j-1][i] == -1)\\n                {\\n                    bottom = 0;\\n                }else\\n                {\\n                    if(dp[dp.length-j-1][i] == -2)\\n                        dp[dp.length-j-1][i] = bottom;\\n                    else\\n                    dp[dp.length-j-1][i] = Math.min(dp[dp.length-j-1][i],bottom);\\n                    \\n                    bottom++;\\n                }\\n                \\n\\n            }\\n            \\n            left=0;\\n            right=0;\\n            bottom=0;\\n            top=0;\\n        }\\n        int max=0;\\n        for(int i=0;i<dp.length;i++) {\\n            \\n            for(int j=0;j<dp.length;j++) {\\n                \\n            if(max<dp[i][j])\\n                max = dp[i][j];\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return max+1;\\n        \\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1311920,
                "title": "c-binary-search-dp-170ms-solution",
                "content": "What we do here is check whether a plus sign of order **k** could be found or not.\\nIf it is possible  then we search in the right half of the binary search else in the left half.\\n\\nNow, to check if a plus sign of order k could be found or not on every valid index check whether the range sum of length **k** from that index in every four directions is **k** or not.\\n\\nFor finding the range sum we can use prefix sums for both column\\'s and row\\'s.\\n\\nBiggest Plus sign could be of size **ceil(n / 2)** so the search space is between **1** and **ceil(n / 2)**\\n\\nTime Complexity: **O(n^2 * log(n))**\\nSpace Complexity: **O(n^2)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mat, row, col;\\n    int n;\\n    bool good(int k) {\\n        for(int i = k - 1; i < n - k + 1; ++i) {\\n            for(int j = k - 1; j < n - k + 1; ++j) {\\n                bool flag = 1;\\n\\t\\t\\t    //in the right direction\\n                flag &= row[i][j + k] - row[i][j] == k;\\n\\t\\t\\t\\t//in the left direction\\n                flag &= row[i][j + 1] - row[i][j - k + 1] == k;\\n\\t\\t\\t\\t// in downward direction\\n                flag &= col[j][i + k] - col[j][i] == k;\\n\\t\\t\\t\\t// in the upward direction\\n                flag &= col[j][i + 1] - col[j][i - k + 1] == k;\\n                if(flag) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& a) {\\n        this->n = n;\\n        mat.resize(n, vector<int> (n, 1));\\n        row.resize(n, vector<int> (n + 1, 0));\\n        col.resize(n, vector<int> (n + 1, 0));\\n        \\n        for(auto x: a) mat[x[0]][x[1]] = 0;\\n        \\n\\t\\t// Calculating the prefix sum\\'s for both row\\'s and column\\'s\\n        for(int j = 0; j < n; ++j) \\n            for(int i = 0; i < n; ++i) \\n                row[i][j + 1] = row[i][j] + mat[i][j];\\n                col[j][i + 1] = col[j][i] + mat[i][j];\\n        \\n        int lo = 1, hi = n - n / 2, best = 0;\\n        while(lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if(good(mid)) {\\n\\t\\t\\t\\t//if plus sign of order mid is found\\n\\t\\t\\t\\t// then set the ans to mid and search in the right half\\n                best = mid;\\n                lo = mid + 1;\\n            } else {\\n\\t\\t\\t\\t//if the plus sign could not be found search in the left half\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mat, row, col;\\n    int n;\\n    bool good(int k) {\\n        for(int i = k - 1; i < n - k + 1; ++i) {\\n            for(int j = k - 1; j < n - k + 1; ++j) {\\n                bool flag = 1;\\n\\t\\t\\t    //in the right direction\\n                flag &= row[i][j + k] - row[i][j] == k;\\n\\t\\t\\t\\t//in the left direction\\n                flag &= row[i][j + 1] - row[i][j - k + 1] == k;\\n\\t\\t\\t\\t// in downward direction\\n                flag &= col[j][i + k] - col[j][i] == k;\\n\\t\\t\\t\\t// in the upward direction\\n                flag &= col[j][i + 1] - col[j][i - k + 1] == k;\\n                if(flag) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& a) {\\n        this->n = n;\\n        mat.resize(n, vector<int> (n, 1));\\n        row.resize(n, vector<int> (n + 1, 0));\\n        col.resize(n, vector<int> (n + 1, 0));\\n        \\n        for(auto x: a) mat[x[0]][x[1]] = 0;\\n        \\n\\t\\t// Calculating the prefix sum\\'s for both row\\'s and column\\'s\\n        for(int j = 0; j < n; ++j) \\n            for(int i = 0; i < n; ++i) \\n                row[i][j + 1] = row[i][j] + mat[i][j];\\n                col[j][i + 1] = col[j][i] + mat[i][j];\\n        \\n        int lo = 1, hi = n - n / 2, best = 0;\\n        while(lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if(good(mid)) {\\n\\t\\t\\t\\t//if plus sign of order mid is found\\n\\t\\t\\t\\t// then set the ans to mid and search in the right half\\n                best = mid;\\n                lo = mid + 1;\\n            } else {\\n\\t\\t\\t\\t//if the plus sign could not be found search in the left half\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182253,
                "title": "c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> a(N, vector<int> (N, 1));\\n        for(vector<int>& p : mines) {\\n            a[p[0]][p[1]] = 0;\\n        }\\n        pair<int, int> dp[N][N];\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < N; j++) {\\n                if(a[i][j] == 1) {\\n                    dp[i][j].first = (i == 0 ? 0 : dp[i- 1][j].first) + 1;\\n                    dp[i][j].second = (j == 0 ? 0 : dp[i][j - 1].second) + 1;\\n                }\\n                else {\\n                    dp[i][j] = {0, 0};\\n                }\\n                \\n            }\\n        }\\n        pair<int, int> dp1[N][N];\\n        for(int i = N - 1; i >= 0; i--) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                if(a[i][j] == 1) {\\n                    dp1[i][j].first = (i == N - 1 ? 0 : dp1[i + 1][j].first) + 1;\\n                    dp1[i][j].second = (j == N - 1 ? 0 : dp1[i][j + 1].second) + 1;\\n                }\\n                else {\\n                    dp1[i][j] = {0, 0};\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < N; j++) {\\n                if(a[i][j] == 1) {\\n                    int m = min({(i == 0 ? 0 : dp[i - 1][j].first), (j == 0 ? 0 : dp[i][j - 1].second), (i == N - 1 ? 0 : dp1[i + 1][j].first), (j == N - 1 ? 0 : dp1[i][j + 1].second)});\\n                    ans = max(ans, m + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> a(N, vector<int> (N, 1));\\n        for(vector<int>& p : mines) {\\n            a[p[0]][p[1]] = 0;\\n        }\\n        pair<int, int> dp[N][N];\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < N; j++) {\\n                if(a[i][j] == 1) {\\n                    dp[i][j].first = (i == 0 ? 0 : dp[i- 1][j].first) + 1;\\n                    dp[i][j].second = (j == 0 ? 0 : dp[i][j - 1].second) + 1;\\n                }\\n                else {\\n                    dp[i][j] = {0, 0};\\n                }\\n                \\n            }\\n        }\\n        pair<int, int> dp1[N][N];\\n        for(int i = N - 1; i >= 0; i--) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                if(a[i][j] == 1) {\\n                    dp1[i][j].first = (i == N - 1 ? 0 : dp1[i + 1][j].first) + 1;\\n                    dp1[i][j].second = (j == N - 1 ? 0 : dp1[i][j + 1].second) + 1;\\n                }\\n                else {\\n                    dp1[i][j] = {0, 0};\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < N; j++) {\\n                if(a[i][j] == 1) {\\n                    int m = min({(i == 0 ? 0 : dp[i - 1][j].first), (j == 0 ? 0 : dp[i][j - 1].second), (i == N - 1 ? 0 : dp1[i + 1][j].first), (j == N - 1 ? 0 : dp1[i][j + 1].second)});\\n                    ans = max(ans, m + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148535,
                "title": "c-prefix-and-suffix-sum-with-3d-dp-array",
                "content": "This solution is inspired from :\\nhttps://leetcode.com/problems/largest-plus-sign/discuss/1091541/C%2B%2B-oror-Faster-than-100-oror-Time-O(N2)-oror-DP-oror\\n\\n\\n\\n\\n````\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n      \\n        int dp[1000][1000][4] , arr[1000][1000] ;\\n        int n = N , ans = 0;\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=0;i<n;++i){                    //prepare array of  1\\'s\\n            for(int j=0;j<n;++j){\\n                arr[i][j] = 1;\\n            }\\n        }\\n        \\n        for(auto it : mines){                    //mark given points as  0\\'s\\n            arr[it[0]][it[1]] = 0;\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                if(arr[i][j]){\\n                    dp[i+1][j+1][0] = dp[i+1][j][0] + 1;    //left prefix sum\\n                    dp[i+1][j+1][1] = dp[i][j+1][1] + 1;    //top  prefix sum\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                if(arr[i][j]){\\n                    dp[i+1][j+1][2] = dp[i+2][j+1][2] + 1;  //down suffix sum\\n                    dp[i+1][j+1][3] = dp[i+1][j+2][3] + 1;  //right suffix sum\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;++i){                              //find the max ans\\n            for(int j=1;j<=n;++j){\\n                int mini = INT_MAX;\\n                for(int k=0;k<4;++k){\\n                   mini = min(mini,dp[i][j][k]);\\n                }\\n                ans = max(ans,mini);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n````\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n      \\n        int dp[1000][1000][4] , arr[1000][1000] ;\\n        int n = N , ans = 0;\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=0;i<n;++i){                    //prepare array of  1\\'s\\n            for(int j=0;j<n;++j){\\n                arr[i][j] = 1;\\n            }\\n        }\\n        \\n        for(auto it : mines){                    //mark given points as  0\\'s\\n            arr[it[0]][it[1]] = 0;\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                if(arr[i][j]){\\n                    dp[i+1][j+1][0] = dp[i+1][j][0] + 1;    //left prefix sum\\n                    dp[i+1][j+1][1] = dp[i][j+1][1] + 1;    //top  prefix sum\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                if(arr[i][j]){\\n                    dp[i+1][j+1][2] = dp[i+2][j+1][2] + 1;  //down suffix sum\\n                    dp[i+1][j+1][3] = dp[i+1][j+2][3] + 1;  //right suffix sum\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;++i){                              //find the max ans\\n            for(int j=1;j<=n;++j){\\n                int mini = INT_MAX;\\n                for(int k=0;k<4;++k){\\n                   mini = min(mini,dp[i][j][k]);\\n                }\\n                ans = max(ans,mini);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049864,
                "title": "c-binary-search-time-o-n-n-log-n-space-o-1",
                "content": "class Solution {\\npublic:\\n    \\n    bool check(vector<vector<bool>> &mat, int n, int k)\\n    {\\n        for(int row = k-1; row + k <= n; row++)\\n        for(int col = k-1; col + k <= n; col++)\\n        {\\n            if(!mat[row][col])\\n                continue;\\n            \\n            bool flag = true;\\n            \\n            for(int r = row-k+1; r <= row + k -1; r++)\\n                if(!mat[r][col])\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n        \\n            \\n            if(!flag) continue;\\n            \\n            for(int c = col-k+1; c<= col + k - 1; c++)\\n                if(!mat[row][c])\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n            \\n            if(flag)\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines)\\n    {\\n        if(mines.size() == n * n)\\n            return 0;\\n        \\n        vector<vector<bool>> mat(n, vector<bool>(n,true));\\n        \\n        for(vector<int> &v : mines)\\n            mat[v[0]][v[1]] = false;\\n        \\n\\t\\t// binary search on value of k\\n        int l = 1, r = ceil(double(n) / 2.0);\\n        \\n        while(l < r)\\n        {\\n            int mid = l + ((r - l + 1) >> 1);\\n            \\n\\t\\t\\t// check if there exist \\'plus sign\\' of order mid\\n            if(check(mat,n,mid))\\n                l = mid;\\n            \\n            else r = mid - 1;\\n        }\\n       \\n        return l;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(vector<vector<bool>> &mat, int n, int k)\\n    {\\n        for(int row = k-1; row + k <= n; row++)\\n        for(int col = k-1; col + k <= n; col++)\\n        {\\n            if(!mat[row][col])\\n                continue;\\n            \\n            bool flag = true;\\n            \\n            for(int r = row-k+1; r <= row + k -1; r++)\\n                if(!mat[r][col])\\n                {\\n                    flag = false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1049125,
                "title": "java-simple-solution-with-explanation-faster-than-80-with-time-and-space",
                "content": "Explanation:\\n   1.for every index we will store all four value(left,right,up,down).\\n   2.to improve time complexity we will calculate index(i,j) values usign stored value of other indexed.\\n\\nJAVA CODE IS:\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n      int grid[][][]=new int[N][N][4];\\n        for(int k=0;k<=3;k++){\\n            for(int a[] : mines)\\n                grid[a[0]][a[1]][k]=-1;\\n        }\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                grid[i][j][0]=grid[i][j][0]==-1 ? 0 : j-1<0 ? 1 : grid[i][j-1][0]+1; \\n               grid[i][j][1]=grid[i][j][1]==-1 ? 0 : i-1<0 ? 1 : 1+grid[i-1][j][1];  \\n            }\\n        }\\n          for(int i=N-1;i>=0;i--){\\n            for(int j=N-1;j>=0;j--){\\n                grid[i][j][2]=grid[i][j][2]==-1 ? 0 : j+1>=N ? 1 : 1+grid[i][j+1][2]; \\n               grid[i][j][3]=grid[i][j][3]==-1 ? 0 : i+1>=N ? 1 : 1+grid[i+1][j][3];  \\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++)\\n                ans=Math.max(ans,Math.min(grid[i][j][0],Math.min(grid[i][j][1],Math.min(grid[i][j][2],grid[i][j][3]))));\\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime: O(m*4)+O(n*n)+O(n*n)+O(n*n)=O(n^2) means quadratic.\\nSpace: O(n*n*4)=O(n*n)\\n***PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU ***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n      int grid[][][]=new int[N][N][4];\\n        for(int k=0;k<=3;k++){\\n            for(int a[] : mines)\\n                grid[a[0]][a[1]][k]=-1;\\n        }\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                grid[i][j][0]=grid[i][j][0]==-1 ? 0 : j-1<0 ? 1 : grid[i][j-1][0]+1; \\n               grid[i][j][1]=grid[i][j][1]==-1 ? 0 : i-1<0 ? 1 : 1+grid[i-1][j][1];  \\n            }\\n        }\\n          for(int i=N-1;i>=0;i--){\\n            for(int j=N-1;j>=0;j--){\\n                grid[i][j][2]=grid[i][j][2]==-1 ? 0 : j+1>=N ? 1 : 1+grid[i][j+1][2]; \\n               grid[i][j][3]=grid[i][j][3]==-1 ? 0 : i+1>=N ? 1 : 1+grid[i+1][j][3];  \\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++)\\n                ans=Math.max(ans,Math.min(grid[i][j][0],Math.min(grid[i][j][1],Math.min(grid[i][j][2],grid[i][j][3]))));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007714,
                "title": "python-o-n-2-log-m-solution",
                "content": "Worse solution than the dynamic programming one, but passes the tests.\\nI create 2 lists of y coordinates of bombs along x axis and x coordinates along y axis, sort them\\nand find the nearest bombs coordinates using binary search, then take the minimum of the 4 distances. Thought that while it\\'s clearly worse, it\\'s an interesting alternative.\\n\\n```\\n\\n\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        self.N = N\\n        res = 0\\n        x, y = {}, {}\\n        xy = {}\\n        for i in range(N):\\n            x[i] = [-1,N]\\n            y[i] = [-1,N]\\n        for mine in mines:\\n            mine_x = mine[0]\\n            mine_y = mine[1]\\n            x[mine_x].append(mine_y)\\n            y[mine_y].append(mine_x)\\n            xy[(mine_x, mine_y)] = True\\n        \\n        for k in range(N):\\n            x[k] = sorted(x[k])\\n            y[k] = sorted(y[k])\\n        print(x)\\n        \\n        coords = (-1,-1)\\n        for i in range(N):\\n            for j in range(N):\\n                if (i,j) not in xy:\\n                    r = min(search(x[i], j), search(y[j], i))\\n                    if r>res:\\n                        res = r\\n                        coords = (i,j)\\n        print(coords)\\n        return res\\n                \\n                \\ndef search(mines, val):\\n    l, r = 0, len(mines)-1\\n    while l<=r:\\n        m = (l+r)//2\\n        if mines[m] > val:\\n            v1 = mines[m]\\n            r = m - 1\\n        else:\\n            l = m + 1\\n    l, r = 0, len(mines)-1\\n    while l<=r:\\n        m = (l+r)//2\\n        if mines[m] < val:\\n            v2 = mines[m]\\n            l = m + 1\\n        else:\\n            r = m - 1\\n    return min(val-v2, v1-val)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        self.N = N\\n        res = 0\\n        x, y = {}, {}\\n        xy = {}\\n        for i in range(N):\\n            x[i] = [-1,N]\\n            y[i] = [-1,N]\\n        for mine in mines:\\n            mine_x = mine[0]\\n            mine_y = mine[1]\\n            x[mine_x].append(mine_y)\\n            y[mine_y].append(mine_x)\\n            xy[(mine_x, mine_y)] = True\\n        \\n        for k in range(N):\\n            x[k] = sorted(x[k])\\n            y[k] = sorted(y[k])\\n        print(x)\\n        \\n        coords = (-1,-1)\\n        for i in range(N):\\n            for j in range(N):\\n                if (i,j) not in xy:\\n                    r = min(search(x[i], j), search(y[j], i))\\n                    if r>res:\\n                        res = r\\n                        coords = (i,j)\\n        print(coords)\\n        return res\\n                \\n                \\ndef search(mines, val):\\n    l, r = 0, len(mines)-1\\n    while l<=r:\\n        m = (l+r)//2\\n        if mines[m] > val:\\n            v1 = mines[m]\\n            r = m - 1\\n        else:\\n            l = m + 1\\n    l, r = 0, len(mines)-1\\n    while l<=r:\\n        m = (l+r)//2\\n        if mines[m] < val:\\n            v2 = mines[m]\\n            l = m + 1\\n        else:\\n            r = m - 1\\n    return min(val-v2, v1-val)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954996,
                "title": "python-intuitive-dp-solution",
                "content": "**Intuition** :- The main idea is to find the length of four wingspans at each point. We can do that using the wingspans of the adjacent elements, so we can utilize something like a dp for this. The wingspan for that point would be the mininum span value of all 4 direction spans and the final answer would be the maximum of all wingspan values(at each point). \\n\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        mines_dict = {(mine[0], mine[1]): True for mine in mines}\\n        dp = {}\\n        ans = 0\\n\\t\\t\\n\\t\\t# left and right wingspan calculation\\n        for row in range(n):\\n            cnt = 0\\n            for col in range(n):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n            cnt = 0\\n            for col in range(n-1, -1, -1):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n                \\n        \\n\\t\\t# top and down wingspan calculation\\n        for col in range(n):\\n            cnt = 0\\n            for row in range(n):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n            cnt = 0\\n            for row in range(n-1, -1, -1):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# final answer would be the maximum wingspan at any point.\\n                ans = max(ans, dp[row, col])\\n        return ans\\n            \\n    \\n    def update_dp(self, dp, mines_dict, row, col, cnt):\\n        if (row, col) not in mines_dict:\\n            cnt += 1\\n            dp[row, col] = min(cnt, dp[row, col]) if (row, col) in dp else cnt\\n        else:\\n            cnt = 0\\n            dp[row, col] = 0\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        mines_dict = {(mine[0], mine[1]): True for mine in mines}\\n        dp = {}\\n        ans = 0\\n\\t\\t\\n\\t\\t# left and right wingspan calculation\\n        for row in range(n):\\n            cnt = 0\\n            for col in range(n):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n            cnt = 0\\n            for col in range(n-1, -1, -1):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n                \\n        \\n\\t\\t# top and down wingspan calculation\\n        for col in range(n):\\n            cnt = 0\\n            for row in range(n):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n            cnt = 0\\n            for row in range(n-1, -1, -1):\\n                cnt = self.update_dp(dp, mines_dict, row, col, cnt)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# final answer would be the maximum wingspan at any point.\\n                ans = max(ans, dp[row, col])\\n        return ans\\n            \\n    \\n    def update_dp(self, dp, mines_dict, row, col, cnt):\\n        if (row, col) not in mines_dict:\\n            cnt += 1\\n            dp[row, col] = min(cnt, dp[row, col]) if (row, col) in dp else cnt\\n        else:\\n            cnt = 0\\n            dp[row, col] = 0\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946068,
                "title": "javascript-brute-force-and-dp",
                "content": "reference:\\nhttps://leetcode.com/problems/largest-plus-sign/discuss/113350/C%2B%2B-simple-brute-force-easy-to-understand-with-detailed-explanation\\nhttps://leetcode.com/problems/largest-plus-sign/discuss/113314/JavaC%2B%2BPython-O(N2)-solution-using-only-one-grid-matrix\\n```\\n////////////////////////////// Brute force 492ms --- 50% fast //////////////////////////////\\nconst orderOfLargestPlusSign = (N, mines) => {\\n    let res = 0;\\n    let data = initialize2DArrayNew(N, N);\\n    for (const m of mines) {\\n        data[m[0]][m[1]] = 0;\\n    }\\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            let step = 0;\\n            while (ok(data, N, i, j, step)) {\\n                step++;\\n            }\\n            res = Math.max(res, step);\\n        }\\n    }\\n    return res;\\n};\\n\\nconst ok = (data, N, x, y, step) => {\\n    if (x - step < 0 || y - step < 0 || x + step >= N || y + step >= N) return false;\\n    return data[x - step][y] && data[x + step][y] && data[x][y - step] && data[x][y + step];\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(1);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n\\n////////////////////////////// DP 180ms --- 100% fast //////////////////////////////\\nconst orderOfLargestPlusSign = (N, mines) => {\\n    let res = 0;\\n    let dp = [];\\n    for (let i = 0; i < N; i++) {\\n        dp.push(new Array(N).fill(N));\\n    }\\n    for (const m of mines) {\\n        dp[m[0]][m[1]] = 0;\\n    }\\n    for (let i = 0; i < N; i++) {\\n        let l = r = u = d = 0;\\n        for (let j = 0, k = N - 1; j < N; j++, k--) {\\n            dp[i][j] = Math.min(dp[i][j], l = (dp[i][j] == 0 ? 0 : l + 1));\\n            dp[j][i] = Math.min(dp[j][i], u = (dp[j][i] == 0 ? 0 : u + 1));\\n            dp[i][k] = Math.min(dp[i][k], r = (dp[i][k] == 0 ? 0 : r + 1));\\n            dp[k][i] = Math.min(dp[k][i], d = (dp[k][i] == 0 ? 0 : d + 1));\\n        }\\n    }\\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            res = Math.max(res, dp[i][j]);\\n        }\\n    }\\n    return res;\\n};\\n\\n////////////////////////////// DP another version 188ms --- 100% fast //////////////////////////////\\nconst orderOfLargestPlusSign = (N, mines) => {\\n    let res = 0;\\n    let dp = [];\\n    for (let i = 0; i < N; i++) {\\n        dp.push(new Array(N).fill(N));\\n    }\\n    for (const m of mines) {\\n        dp[m[0]][m[1]] = 0;\\n    }\\n    for (let i = 0; i < N; i++) {\\n        let l = r = u = d = 0;\\n        for (let j = 0, k = N - 1; j < N; j++, k--) {\\n            dp[i][j] = Math.min(dp[i][j], l = (dp[i][j] == 0 ? 0 : l + 1));\\n            dp[j][i] = Math.min(dp[j][i], u = (dp[j][i] == 0 ? 0 : u + 1));\\n            dp[i][k] = Math.min(dp[i][k], r = (dp[i][k] == 0 ? 0 : r + 1));\\n            dp[k][i] = Math.min(dp[k][i], d = (dp[k][i] == 0 ? 0 : d + 1));\\n        }\\n    }\\n    for (let k = 0; k < N * N; ++k) res = Math.max(res, dp[Math.floor(k / N)][k % N]);  // difference\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n////////////////////////////// Brute force 492ms --- 50% fast //////////////////////////////\\nconst orderOfLargestPlusSign = (N, mines) => {\\n    let res = 0;\\n    let data = initialize2DArrayNew(N, N);\\n    for (const m of mines) {\\n        data[m[0]][m[1]] = 0;\\n    }\\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            let step = 0;\\n            while (ok(data, N, i, j, step)) {\\n                step++;\\n            }\\n            res = Math.max(res, step);\\n        }\\n    }\\n    return res;\\n};\\n\\nconst ok = (data, N, x, y, step) => {\\n    if (x - step < 0 || y - step < 0 || x + step >= N || y + step >= N) return false;\\n    return data[x - step][y] && data[x + step][y] && data[x][y - step] && data[x][y + step];\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(1);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n\\n////////////////////////////// DP 180ms --- 100% fast //////////////////////////////\\nconst orderOfLargestPlusSign = (N, mines) => {\\n    let res = 0;\\n    let dp = [];\\n    for (let i = 0; i < N; i++) {\\n        dp.push(new Array(N).fill(N));\\n    }\\n    for (const m of mines) {\\n        dp[m[0]][m[1]] = 0;\\n    }\\n    for (let i = 0; i < N; i++) {\\n        let l = r = u = d = 0;\\n        for (let j = 0, k = N - 1; j < N; j++, k--) {\\n            dp[i][j] = Math.min(dp[i][j], l = (dp[i][j] == 0 ? 0 : l + 1));\\n            dp[j][i] = Math.min(dp[j][i], u = (dp[j][i] == 0 ? 0 : u + 1));\\n            dp[i][k] = Math.min(dp[i][k], r = (dp[i][k] == 0 ? 0 : r + 1));\\n            dp[k][i] = Math.min(dp[k][i], d = (dp[k][i] == 0 ? 0 : d + 1));\\n        }\\n    }\\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            res = Math.max(res, dp[i][j]);\\n        }\\n    }\\n    return res;\\n};\\n\\n////////////////////////////// DP another version 188ms --- 100% fast //////////////////////////////\\nconst orderOfLargestPlusSign = (N, mines) => {\\n    let res = 0;\\n    let dp = [];\\n    for (let i = 0; i < N; i++) {\\n        dp.push(new Array(N).fill(N));\\n    }\\n    for (const m of mines) {\\n        dp[m[0]][m[1]] = 0;\\n    }\\n    for (let i = 0; i < N; i++) {\\n        let l = r = u = d = 0;\\n        for (let j = 0, k = N - 1; j < N; j++, k--) {\\n            dp[i][j] = Math.min(dp[i][j], l = (dp[i][j] == 0 ? 0 : l + 1));\\n            dp[j][i] = Math.min(dp[j][i], u = (dp[j][i] == 0 ? 0 : u + 1));\\n            dp[i][k] = Math.min(dp[i][k], r = (dp[i][k] == 0 ? 0 : r + 1));\\n            dp[k][i] = Math.min(dp[k][i], d = (dp[k][i] == 0 ? 0 : d + 1));\\n        }\\n    }\\n    for (let k = 0; k < N * N; ++k) res = Math.max(res, dp[Math.floor(k / N)][k % N]);  // difference\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 922673,
                "title": "python3-dp",
                "content": "\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mines = {(x, y) for x, y in mines} # O(1) lookup \\n        \\n        top = [[0]*N for _ in range(N)]\\n        left = [[0]*N for _ in range(N)]\\n        for i in range(N):\\n            for j in range(N): \\n                if (i, j) in mines: continue \\n                top[i][j] = 1 + top[i-1][j] if i > 0 else 1\\n                left[i][j] = 1 + left[i][j-1] if j > 0 else 1\\n        \\n        right = [[0]*N for _ in range(N)]\\n        bottom = [[0]*N for _ in range(N)]\\n        for i in reversed(range(N)):\\n            for j in reversed(range(N)): \\n                if (i, j) in mines: continue \\n                right[i][j] = 1 + right[i][j+1] if j+1 < N else 1\\n                bottom[i][j] = 1 + bottom[i+1][j] if i+1 < N else 1\\n        \\n        return max(min(top[i][j], left[i][j], right[i][j], bottom[i][j]) for i in range(N) for j in range(N))\\n```\\n\\nA more concise but less comprehensive implementation is given below \\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        dp = [[n] * n for _ in range(n)]\\n        for i, j in mines: dp[i][j] = 0\\n        \\n        for i in range(n):\\n            ll = dd = rr = uu = 0 \\n            for j in range(n): \\n                dp[i][j] = min(dp[i][j], ll := ll+1 if dp[i][j] else 0)\\n                dp[j][i] = min(dp[j][i], dd := dd+1 if dp[j][i] else 0)\\n                dp[i][~j] = min(dp[i][~j], rr := rr+1 if dp[i][~j] else 0)\\n                dp[~j][i] = min(dp[~j][i], uu := uu+1 if dp[~j][i] else 0)\\n                    \\n        return max(map(max, dp))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mines = {(x, y) for x, y in mines} # O(1) lookup \\n        \\n        top = [[0]*N for _ in range(N)]\\n        left = [[0]*N for _ in range(N)]\\n        for i in range(N):\\n            for j in range(N): \\n                if (i, j) in mines: continue \\n                top[i][j] = 1 + top[i-1][j] if i > 0 else 1\\n                left[i][j] = 1 + left[i][j-1] if j > 0 else 1\\n        \\n        right = [[0]*N for _ in range(N)]\\n        bottom = [[0]*N for _ in range(N)]\\n        for i in reversed(range(N)):\\n            for j in reversed(range(N)): \\n                if (i, j) in mines: continue \\n                right[i][j] = 1 + right[i][j+1] if j+1 < N else 1\\n                bottom[i][j] = 1 + bottom[i+1][j] if i+1 < N else 1\\n        \\n        return max(min(top[i][j], left[i][j], right[i][j], bottom[i][j]) for i in range(N) for j in range(N))\\n```\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        dp = [[n] * n for _ in range(n)]\\n        for i, j in mines: dp[i][j] = 0\\n        \\n        for i in range(n):\\n            ll = dd = rr = uu = 0 \\n            for j in range(n): \\n                dp[i][j] = min(dp[i][j], ll := ll+1 if dp[i][j] else 0)\\n                dp[j][i] = min(dp[j][i], dd := dd+1 if dp[j][i] else 0)\\n                dp[i][~j] = min(dp[i][~j], rr := rr+1 if dp[i][~j] else 0)\\n                dp[~j][i] = min(dp[~j][i], uu := uu+1 if dp[~j][i] else 0)\\n                    \\n        return max(map(max, dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800269,
                "title": "easy-dfs-solution-using-boolean-grid-and-caching-with-full-explanation",
                "content": "**Idea:**\\n* Form a boolean matrix, indicating the positions of mines : `matrix`\\n* Form a Data class which has 4 integer values, representating number of consecutive 1s in up, left, down and right directions\\n* Form a matrix of Data type which will maintain cached values of number of 1s in all four directions for that particular position: `cache`\\n* Start doing DFS for every position and fill out 4 values if not already filled out.\\n* While doing DFS, keep the `cache` updated, so that one value for one cell is not calculated again through recursion.\\n* After DFS completes, iterate over `cache` matrix, where we have number of consecutive `1`s in all 4 directions from that position, determine the largest square possible to form with that cell in the center, and maintain the max size of largest square in these loops.\\n\\n```\\nclass Solution {\\n    private enum Direction {\\n        UP, LEFT, DOWN, RIGHT;\\n    }\\n    \\n    private class Data {\\n        int left, right, up, down;\\n        Data(int left, int right, int up, int down) {\\n            this.left = left;\\n            this.right = right;\\n            this.up = up;\\n            this.down = down;\\n        }\\n    }\\n    \\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        boolean[][] matrix = new boolean[N][N];\\n        for (int[] mine : mines) {\\n            matrix[mine[0]][mine[1]] = true;\\n        }\\n        \\n        Data[][] cache = new Data[N][N];\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (!matrix[i][j]) {\\n                    dfs(matrix, cache, i, j);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (!matrix[i][j]) {\\n                    Data cur = cache[i][j];\\n                    ans = Math.max(ans,\\n                                  Math.min(cur.up, Math.min(cur.left, Math.min(cur.down, cur.right))));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    private void dfs(boolean[][] mines, Data[][] cache, int x, int y) {\\n        if (cache[x][y] == null) {\\n            cache[x][y] = new Data(-1, -1, -1, -1);\\n        }\\n        Data cur = cache[x][y];\\n        cur.up = helper(mines, cache, x, y, Direction.UP);\\n        cur.left = helper(mines, cache, x, y, Direction.LEFT);\\n        cur.down = helper(mines, cache, x, y, Direction.DOWN);\\n        cur.right = helper(mines, cache, x, y, Direction.RIGHT);\\n    }\\n    \\n    private int helper(boolean[][] mines, Data[][] cache, int x, int y, Direction dir) {\\n        if (!isValid(mines, x, y) || mines[x][y]) {\\n            return 0;\\n            \\n        } \\n        \\n        if (cache[x][y] == null) {\\n            cache[x][y] = new Data(-1, -1, -1, -1);\\n        }\\n        Data cur = cache[x][y];\\n        \\n        if (dir == Direction.UP) {\\n            if (cur.up == -1) {\\n                cur.up = 1 + helper(mines, cache, x-1, y, dir);\\n            }\\n            return cur.up;\\n            \\n        } else if (dir == Direction.LEFT) {\\n            if (cur.left == -1) {\\n                cur.left = 1 + helper(mines, cache, x, y-1, dir);\\n            }\\n            return cur.left;\\n            \\n        } else if (dir == Direction.DOWN) {\\n            if (cur.down == -1) {\\n                cur.down = 1 + helper(mines, cache, x + 1, y, dir);\\n            }\\n            return cur.down;\\n            \\n        } else if (dir == Direction.RIGHT) {\\n            if (cur.right == -1) {\\n                cur.right = 1 + helper(mines, cache, x, y+1, dir);\\n            }\\n            return cur.right;\\n        }\\n        \\n        return -1; // should not reach here\\n    }\\n    \\n    private boolean isValid(boolean[][] mines, int x, int y) {\\n        return x >= 0 && x < mines.length && y >= 0 && y < mines[0].length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private enum Direction {\\n        UP, LEFT, DOWN, RIGHT;\\n    }\\n    \\n    private class Data {\\n        int left, right, up, down;\\n        Data(int left, int right, int up, int down) {\\n            this.left = left;\\n            this.right = right;\\n            this.up = up;\\n            this.down = down;\\n        }\\n    }\\n    \\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\\n        boolean[][] matrix = new boolean[N][N];\\n        for (int[] mine : mines) {\\n            matrix[mine[0]][mine[1]] = true;\\n        }\\n        \\n        Data[][] cache = new Data[N][N];\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (!matrix[i][j]) {\\n                    dfs(matrix, cache, i, j);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (!matrix[i][j]) {\\n                    Data cur = cache[i][j];\\n                    ans = Math.max(ans,\\n                                  Math.min(cur.up, Math.min(cur.left, Math.min(cur.down, cur.right))));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    private void dfs(boolean[][] mines, Data[][] cache, int x, int y) {\\n        if (cache[x][y] == null) {\\n            cache[x][y] = new Data(-1, -1, -1, -1);\\n        }\\n        Data cur = cache[x][y];\\n        cur.up = helper(mines, cache, x, y, Direction.UP);\\n        cur.left = helper(mines, cache, x, y, Direction.LEFT);\\n        cur.down = helper(mines, cache, x, y, Direction.DOWN);\\n        cur.right = helper(mines, cache, x, y, Direction.RIGHT);\\n    }\\n    \\n    private int helper(boolean[][] mines, Data[][] cache, int x, int y, Direction dir) {\\n        if (!isValid(mines, x, y) || mines[x][y]) {\\n            return 0;\\n            \\n        } \\n        \\n        if (cache[x][y] == null) {\\n            cache[x][y] = new Data(-1, -1, -1, -1);\\n        }\\n        Data cur = cache[x][y];\\n        \\n        if (dir == Direction.UP) {\\n            if (cur.up == -1) {\\n                cur.up = 1 + helper(mines, cache, x-1, y, dir);\\n            }\\n            return cur.up;\\n            \\n        } else if (dir == Direction.LEFT) {\\n            if (cur.left == -1) {\\n                cur.left = 1 + helper(mines, cache, x, y-1, dir);\\n            }\\n            return cur.left;\\n            \\n        } else if (dir == Direction.DOWN) {\\n            if (cur.down == -1) {\\n                cur.down = 1 + helper(mines, cache, x + 1, y, dir);\\n            }\\n            return cur.down;\\n            \\n        } else if (dir == Direction.RIGHT) {\\n            if (cur.right == -1) {\\n                cur.right = 1 + helper(mines, cache, x, y+1, dir);\\n            }\\n            return cur.right;\\n        }\\n        \\n        return -1; // should not reach here\\n    }\\n    \\n    private boolean isValid(boolean[][] mines, int x, int y) {\\n        return x >= 0 && x < mines.length && y >= 0 && y < mines[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544057,
                "title": "python-dp",
                "content": "```Python\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mines = set(tuple(i) for i in mines)\\n        dp = [[[0,0,0,0] for i in range(N+2)] for j in range(N+2)]\\n        for i in range(1,N+1):\\n            for j in range(1,N+1):\\n                if (i-1, j-1) not in mines:\\n                    dp[i][j][0] = dp[i][j-1][0] + 1\\n                    dp[i][j][1] = dp[i-1][j][1] + 1\\n        for i in range(N,0,-1):\\n            for j in range(N,0,-1):\\n                if (i-1, j-1) not in mines:\\n                    dp[i][j][2] = dp[i][j+1][2] + 1\\n                    dp[i][j][3] = dp[i+1][j][3] + 1     \\n        return max(min(j) for i in dp for j in i)\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mines = set(tuple(i) for i in mines)\\n        dp = [[[0,0,0,0] for i in range(N+2)] for j in range(N+2)]\\n        for i in range(1,N+1):\\n            for j in range(1,N+1):\\n                if (i-1, j-1) not in mines:\\n                    dp[i][j][0] = dp[i][j-1][0] + 1\\n                    dp[i][j][1] = dp[i-1][j][1] + 1\\n        for i in range(N,0,-1):\\n            for j in range(N,0,-1):\\n                if (i-1, j-1) not in mines:\\n                    dp[i][j][2] = dp[i][j+1][2] + 1\\n                    dp[i][j][3] = dp[i+1][j][3] + 1     \\n        return max(min(j) for i in dp for j in i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418108,
                "title": "easy-solution-using-dp-time-o-n-2-space-o-n-2-in-c-java",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& v) {\\n        vector<vector<int>>dp(n,vector<int>(n,1));\\n        for(int i=0;i<v.size();i++)\\n        {\\n            dp[v[i][0]][v[i][1]]=0;\\n        }\\n        //Now we have our matrix of 0\\'s and 1\\'s\\n        //Now what we will do is create 4 vectors to keep track of each direction having continous ones.\\n        vector<vector<int>>left(n,vector<int>(n,0));\\n        vector<vector<int>>right(n,vector<int>(n,0));\\n        vector<vector<int>>top(n,vector<int>(n,0));\\n        vector<vector<int>>down(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==0)\\n                {\\n                    left[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    left[i][j]=left[i][j-1]+1;\\n                else\\n                    left[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(j==n-1)\\n                {\\n                    right[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    right[i][j]=right[i][j+1]+1;\\n                else\\n                    right[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0)\\n                {\\n                    top[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    top[i][j]=top[i-1][j]+1;\\n                else\\n                    top[i][j]=0;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==n-1)\\n                {\\n                    down[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    down[i][j]=down[i+1][j]+1;\\n                else\\n                    down[i][j]=0;\\n            }\\n        }\\n        int order=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int curr=min(left[i][j],min(right[i][j],min(top[i][j],down[i][j])));\\n                order=max(order,curr);\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] v) {\\n        int[][] arr=new int[n][n];\\n        int[][] left=new int[n][n];\\n        int[][] right=new int[n][n];\\n        int[][] up=new int[n][n];\\n        int[][] down=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                arr[i][j]=1;\\n                up[i][j]=0;\\n                left[i][j]=0;\\n                right[i][j]=0;\\n                down[i][j]=0;\\n            }\\n        }\\n        if(v.length>0)\\n        {\\n        for(int i=0;i<v.length;i++)\\n        {\\n            arr[v[i][0]][v[i][1]]=0;\\n        }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(j==0)\\n                    {\\n                       left[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        left[i][j]=left[i][j-1]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(j==n-1)\\n                    {\\n                       right[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        right[i][j]=right[i][j+1]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(i==0)\\n                    {\\n                       up[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        up[i][j]=up[i-1][j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(i==n-1)\\n                    {\\n                       down[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        down[i][j]=down[i+1][j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                  ans=Math.max(ans,Math.min(left[i][j],Math.min(right[i][j],Math.min(up[i][j],down[i][j]))));  \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& v) {\\n        vector<vector<int>>dp(n,vector<int>(n,1));\\n        for(int i=0;i<v.size();i++)\\n        {\\n            dp[v[i][0]][v[i][1]]=0;\\n        }\\n        //Now we have our matrix of 0\\'s and 1\\'s\\n        //Now what we will do is create 4 vectors to keep track of each direction having continous ones.\\n        vector<vector<int>>left(n,vector<int>(n,0));\\n        vector<vector<int>>right(n,vector<int>(n,0));\\n        vector<vector<int>>top(n,vector<int>(n,0));\\n        vector<vector<int>>down(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==0)\\n                {\\n                    left[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    left[i][j]=left[i][j-1]+1;\\n                else\\n                    left[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(j==n-1)\\n                {\\n                    right[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    right[i][j]=right[i][j+1]+1;\\n                else\\n                    right[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0)\\n                {\\n                    top[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    top[i][j]=top[i-1][j]+1;\\n                else\\n                    top[i][j]=0;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==n-1)\\n                {\\n                    down[i][j]=dp[i][j];\\n                }\\n               else if(dp[i][j]==1)\\n                    down[i][j]=down[i+1][j]+1;\\n                else\\n                    down[i][j]=0;\\n            }\\n        }\\n        int order=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int curr=min(left[i][j],min(right[i][j],min(top[i][j],down[i][j])));\\n                order=max(order,curr);\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] v) {\\n        int[][] arr=new int[n][n];\\n        int[][] left=new int[n][n];\\n        int[][] right=new int[n][n];\\n        int[][] up=new int[n][n];\\n        int[][] down=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                arr[i][j]=1;\\n                up[i][j]=0;\\n                left[i][j]=0;\\n                right[i][j]=0;\\n                down[i][j]=0;\\n            }\\n        }\\n        if(v.length>0)\\n        {\\n        for(int i=0;i<v.length;i++)\\n        {\\n            arr[v[i][0]][v[i][1]]=0;\\n        }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(j==0)\\n                    {\\n                       left[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        left[i][j]=left[i][j-1]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(j==n-1)\\n                    {\\n                       right[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        right[i][j]=right[i][j+1]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(i==0)\\n                    {\\n                       up[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        up[i][j]=up[i-1][j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                    if(i==n-1)\\n                    {\\n                       down[i][j]=arr[i][j]; \\n                    }\\n                    else \\n                    {\\n                        down[i][j]=down[i+1][j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i][j]==1)\\n                {\\n                  ans=Math.max(ans,Math.min(left[i][j],Math.min(right[i][j],Math.min(up[i][j],down[i][j]))));  \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 368078,
                "title": "java-dp",
                "content": "```\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] grid = new int[N][N];\\n        for(int i = 0; i < mines.length; i++){\\n            grid[mines[i][0]][mines[i][1]] = 1; \\n        }\\n        int[][] left = new int[N][N];\\n        int[][] right = new int[N][N];\\n        int[][] up = new int[N][N];\\n        int[][] down = new int[N][N];\\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                if(j == 0){\\n                    if(grid[i][j] == 0){\\n                        left[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        left[i][j] = 0;\\n                    }else{\\n                        left[i][j] = 1 + left[i][j - 1];\\n                    }\\n                }\\n                \\n                if(i == 0){\\n                    if(grid[i][j] == 0){\\n                        up[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        up[i][j] = 0;\\n                    }else{\\n                        up[i][j] = 1 + up[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = N - 1; i >= 0; i--){\\n            for(int j = N - 1; j >= 0; j--){\\n                if(j == N - 1){\\n                    if(grid[i][j] == 0){\\n                        right[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        right[i][j] = 0;\\n                    }else{\\n                        right[i][j] = 1 + right[i][j + 1];\\n                    }\\n                }\\n                \\n                if(i == N - 1){\\n                    if(grid[i][j] == 0){\\n                        down[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        down[i][j] = 0;\\n                    }else{\\n                        down[i][j] = 1 + down[i + 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                int min = Math.min(up[i][j], down[i][j]);\\n                min = Math.min(min, Math.min(left[i][j], right[i][j]));\\n                max = Math.max(min, max);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] grid = new int[N][N];\\n        for(int i = 0; i < mines.length; i++){\\n            grid[mines[i][0]][mines[i][1]] = 1; \\n        }\\n        int[][] left = new int[N][N];\\n        int[][] right = new int[N][N];\\n        int[][] up = new int[N][N];\\n        int[][] down = new int[N][N];\\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                if(j == 0){\\n                    if(grid[i][j] == 0){\\n                        left[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        left[i][j] = 0;\\n                    }else{\\n                        left[i][j] = 1 + left[i][j - 1];\\n                    }\\n                }\\n                \\n                if(i == 0){\\n                    if(grid[i][j] == 0){\\n                        up[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        up[i][j] = 0;\\n                    }else{\\n                        up[i][j] = 1 + up[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = N - 1; i >= 0; i--){\\n            for(int j = N - 1; j >= 0; j--){\\n                if(j == N - 1){\\n                    if(grid[i][j] == 0){\\n                        right[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        right[i][j] = 0;\\n                    }else{\\n                        right[i][j] = 1 + right[i][j + 1];\\n                    }\\n                }\\n                \\n                if(i == N - 1){\\n                    if(grid[i][j] == 0){\\n                        down[i][j] = 1;\\n                    }\\n                }else{\\n                    if(grid[i][j] == 1){\\n                        down[i][j] = 0;\\n                    }else{\\n                        down[i][j] = 1 + down[i + 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                int min = Math.min(up[i][j], down[i][j]);\\n                min = Math.min(min, Math.min(left[i][j], right[i][j]));\\n                max = Math.max(min, max);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 367524,
                "title": "python-2d-dp-n3-to-n2-binary-search",
                "content": "intuition of binary search\\ntransfer the mines map into\\nrow [[-1,N], [-1,2,N],[-1,3,7,N]...]\\ncolomn\\nwhich means that in row 2,we have 2 mines on [2,3] and [2,7]\\nso if we are considering the length of one arm of a plus sign at [2,5]\\nit should be (7-3)/2 horizontally\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        maxOrder = 0\\n        zeros = set((i,j) for i,j in mines)\\n        dp = [[0]*N for _ in range(N)]\\n        for i in range(N):\\n            # ->\\n            count = 0\\n            for j in range(N):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = count\\n            # <-\\n            count = 0\\n            for j in range(N-1,-1,-1):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = min(dp[i][j],count)\\n        for j in range(N):\\n            # ^\\n            count = 0\\n            for i in range(N):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = min(dp[i][j],count)\\n            # v\\n            count = 0\\n            for i in range(N-1,-1,-1):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = min(dp[i][j],count)\\n                maxOrder = max(dp[i][j],maxOrder)\\n                if maxOrder == (N+1)//2:\\n                    return maxOrder\\n        return maxOrder\\n                    \\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        maxOrder = 0\\n        zeros = set((i,j) for i,j in mines)\\n        dp = [[0]*N for _ in range(N)]\\n        for i in range(N):\\n            # ->\\n            count = 0\\n            for j in range(N):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = count\\n            # <-\\n            count = 0\\n            for j in range(N-1,-1,-1):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = min(dp[i][j],count)\\n        for j in range(N):\\n            # ^\\n            count = 0\\n            for i in range(N):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = min(dp[i][j],count)\\n            # v\\n            count = 0\\n            for i in range(N-1,-1,-1):\\n                count = 0 if (i,j) in zeros else count + 1\\n                dp[i][j] = min(dp[i][j],count)\\n                maxOrder = max(dp[i][j],maxOrder)\\n                if maxOrder == (N+1)//2:\\n                    return maxOrder\\n        return maxOrder\\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 287820,
                "title": "easy-to-understand-o-2n-2",
                "content": "First matrix iteration is to calculate the order distance of left and top.\\nThen second one is to calculate bottom and right.\\nMinimum of these value is the order of each cell.\\nSo find the maximum value of all cells\\n\\n\\n\\tint orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n\\n        int state[N][N];\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < N; j++)\\n                state[i][j] = 0;\\n\\n        for (auto v: mines)\\n            state[v[0]][v[1]] = -1;\\n\\n        int width;\\n        vector<int> height(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            width = 0;\\n            for (int j = 0; j < N; j++) {\\n                if (state[i][j] == -1) {\\n                    width = height[j] = 0;\\n                    continue;\\n                }\\n                width++;\\n                height[j]++;\\n                state[i][j] = min(width, height[j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < N; i++)\\n            height[i] = 0;\\n        int mx = 0;\\n        for (int i = N-1; i >= 0; i--) {\\n            width = 0;\\n            for (int j = N-1; j >= 0; j--) {\\n                if (state[i][j] == -1) {\\n                    width = height[j] = 0;\\n                    continue;\\n                }\\n                width++;\\n                height[j]++;\\n                state[i][j] = min(state[i][j], min(width, height[j]));\\n                if (state[i][j] > mx)\\n                    mx = state[i][j];\\n            }\\n        }\\n\\n        return mx;\\n    }\\n",
                "solutionTags": [],
                "code": "First matrix iteration is to calculate the order distance of left and top.\\nThen second one is to calculate bottom and right.\\nMinimum of these value is the order of each cell.\\nSo find the maximum value of all cells\\n\\n\\n\\tint orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n\\n        int state[N][N];\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < N; j++)\\n                state[i][j] = 0;\\n\\n        for (auto v: mines)\\n            state[v[0]][v[1]] = -1;\\n\\n        int width;\\n        vector<int> height(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            width = 0;\\n            for (int j = 0; j < N; j++) {\\n                if (state[i][j] == -1) {\\n                    width = height[j] = 0;\\n                    continue;\\n                }\\n                width++;\\n                height[j]++;\\n                state[i][j] = min(width, height[j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < N; i++)\\n            height[i] = 0;\\n        int mx = 0;\\n        for (int i = N-1; i >= 0; i--) {\\n            width = 0;\\n            for (int j = N-1; j >= 0; j--) {\\n                if (state[i][j] == -1) {\\n                    width = height[j] = 0;\\n                    continue;\\n                }\\n                width++;\\n                height[j]++;\\n                state[i][j] = min(state[i][j], min(width, height[j]));\\n                if (state[i][j] > mx)\\n                    mx = state[i][j];\\n            }\\n        }\\n\\n        return mx;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 260364,
                "title": "python-linear-binary-search",
                "content": "The high level idea is, we test each grid as a plus sign\\'s center and check its arm\\'s length. Since we need to find out the longest arms so we start from 0 and keep updating the maximum length.\\n\\nTo check a center\\'s arms length, if the center is (x, y) and l, r ,t, d are left, right, top, bottom boundaries determined by mines\\' location, than arm\\'s length is min(x-l, r-x, y-t, d-y).\\n\\nTherefore, we can record mines\\'s row and col indices in **rows** and **cols**.\\nE.g. rows = [[-1,N],[-1,1,N],[-1,2,N]]. 0th element is [-1,N] means there is no mine in 0th row. -1 and N are set as boundary pivots. 1st element is [-1,1,N] means there is one mine in the 1st row at (1,1). \\n\\nIn such way, we search row by row. In yth row, we know the column index of a mine as row[i]. And we just search center\\'s x between row[i]+arms and row[i+1]-arms as there are two mines at (row[i],y), (row[i+1],y). These two mines set left boundary **l** and right boundary **r**.\\n\\nFor each center\\'x, we know the mines\\' row index in cols[x]. And we also know the center is at row y, so we can use binary search here to find the closest mines in xth column from center(x, y) and these two mines set top boundary **t** and bottom boundary **d**.\\n```\\n\\t    row[i](l)   row[i+1](r)\\n             ----------- bisect(cols[x],y)-1(t)\\n\\t\\t\\t | center  |\\nyth row  ----|----x----|----\\n\\t\\t\\t |         |\\n             ----------- bisect(cols[x],y)(d)\\n```\\nAnd as we growing arm\\'s size, we are narrowing down the linear search space for x. But in worst case, it still costs N^2 for linear search so total time complexity is O(N^2 * logN).\\n```\\ndef orderOfLargestPlusSign(N, mines):\\n\\trows, cols, sz = [[-1,N] for _ in range(N)], [[-1,N] for _ in range(N)], 0\\n\\tfor r, c in mines:\\n\\t\\tbisect.insort(rows[r], c)\\n\\t\\tbisect.insort(cols[c], r)\\n\\tfor y, row in enumerate(rows):\\n\\t\\tfor i in range(len(row)-1):\\n\\t\\t\\tl, r = row[i], row[i+1]\\n\\t\\t\\tfor x in range(l+sz+1, r-sz):\\n\\t\\t\\t\\tj = bisect.bisect(cols[x], y)\\n\\t\\t\\t\\tt, b = cols[x][j-1], cols[x][j]\\n\\t\\t\\t\\tsz = max(sz, min(x-l, r-x, y-t, b-y))\\n\\treturn sz\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    row[i](l)   row[i+1](r)\\n             ----------- bisect(cols[x],y)-1(t)\\n\\t\\t\\t | center  |\\nyth row  ----|----x----|----\\n\\t\\t\\t |         |\\n             ----------- bisect(cols[x],y)(d)\\n```\n```\\ndef orderOfLargestPlusSign(N, mines):\\n\\trows, cols, sz = [[-1,N] for _ in range(N)], [[-1,N] for _ in range(N)], 0\\n\\tfor r, c in mines:\\n\\t\\tbisect.insort(rows[r], c)\\n\\t\\tbisect.insort(cols[c], r)\\n\\tfor y, row in enumerate(rows):\\n\\t\\tfor i in range(len(row)-1):\\n\\t\\t\\tl, r = row[i], row[i+1]\\n\\t\\t\\tfor x in range(l+sz+1, r-sz):\\n\\t\\t\\t\\tj = bisect.bisect(cols[x], y)\\n\\t\\t\\t\\tt, b = cols[x][j-1], cols[x][j]\\n\\t\\t\\t\\tsz = max(sz, min(x-l, r-x, y-t, b-y))\\n\\treturn sz\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 241042,
                "title": "dp-method-only-o-n-2",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> graph(N,vector<int>(N,1));\\n        vector<vector<int>>    dp(N,vector<int>(N,0));\\n        int cnt = 0;\\n        int res = 0;\\n        for(auto mine: mines)\\n        {\\n            graph[mine[0]][mine[1]] = 0;\\n        }\\n        \\n        //up\\n        for(int j = 0;j<N;j++)\\n        {\\n            cnt = 0;\\n            for(int i = 0;i<N;i++)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = cnt;\\n            }\\n        }\\n        //down\\n        for(int j = 0;j<N;j++)\\n        {\\n            cnt = 0;\\n            for(int i = N-1;i>=0;i--)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = min(cnt,dp[i][j]);\\n            }\\n        }\\n        //right\\n        for(int i = 0;i<N;i++)\\n        {\\n            cnt = 0;\\n            for(int j = 0;j<N;j++)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = min(cnt,dp[i][j]);\\n            }\\n        }\\n        //left\\n        for(int i = 0;i<N;i++)\\n        {\\n            cnt =0;\\n            for(int j = N-1;j>=0;j--)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = min(cnt,dp[i][j]);\\n                res = max(dp[i][j],res);\\n            }\\n            \\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> graph(N,vector<int>(N,1));\\n        vector<vector<int>>    dp(N,vector<int>(N,0));\\n        int cnt = 0;\\n        int res = 0;\\n        for(auto mine: mines)\\n        {\\n            graph[mine[0]][mine[1]] = 0;\\n        }\\n        \\n        //up\\n        for(int j = 0;j<N;j++)\\n        {\\n            cnt = 0;\\n            for(int i = 0;i<N;i++)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = cnt;\\n            }\\n        }\\n        //down\\n        for(int j = 0;j<N;j++)\\n        {\\n            cnt = 0;\\n            for(int i = N-1;i>=0;i--)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = min(cnt,dp[i][j]);\\n            }\\n        }\\n        //right\\n        for(int i = 0;i<N;i++)\\n        {\\n            cnt = 0;\\n            for(int j = 0;j<N;j++)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = min(cnt,dp[i][j]);\\n            }\\n        }\\n        //left\\n        for(int i = 0;i<N;i++)\\n        {\\n            cnt =0;\\n            for(int j = N-1;j>=0;j--)\\n            {\\n                cnt = graph[i][j]?cnt+1:0;\\n                dp[i][j] = min(cnt,dp[i][j]);\\n                res = max(dp[i][j],res);\\n            }\\n            \\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162991,
                "title": "66ms-easy-to-understand-java-solution-o-n-2-two-pass",
                "content": "In the solution we just need one 2d array **grid[N][N]**.\\n\\nThe basic idea is to record the min length of 4 directions, for example:\\n```\\t\\t\\t\\t\\t\\t\\n            1\\n            1\\n      1  grid[i][j]  1  1  1  1\\n            1\\n```\\nThe value of grid[i][j] should be 2 (because **grid[i][j]** it self is also considered 1).\\n\\nThen we iterator the grid twice.\\nThe first pass is from left to right, top to bottom so that we can get the the min(left, top) for each element;\\nThe second pass is from right to left , bottom to top so that we can get the min(right, bottom) for each element;\\n\\nThen we can get the min value of 4 direction and find the max.\\n\\nJava Code:\\n```java\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] grid = new int[N][N];\\n        for (int i = 0; i < N; i++) {\\n            Arrays.fill(grid[i], 1);\\n        }\\n        for (int[] mine: mines) {\\n            grid[mine[0]][mine[1]] = 0;\\n        }\\n        int[] pre = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            int count = 0;\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] != 0) {\\n                    grid[i][j] = Math.min(++count, ++pre[j]);\\n                } else {\\n                    count = 0;\\n                    pre[j] = 0;\\n                }\\n            }\\n        }\\n        Arrays.fill(pre, 0);\\n        int max = 0;\\n        for (int i = N - 1; i >= 0; i--) {\\n            int count = 0;\\n            for (int j = N - 1; j >= 0; j--) {\\n                if (grid[i][j] != 0) {\\n                    grid[i][j] = Math.min(grid[i][j], Math.min(++count, ++pre[j]));\\n                } else {\\n                    count = 0;\\n                    pre[j] = 0;\\n                }\\n                max = Math.max(max, grid[i][j]);\\n            }\\n        }\\n        return max;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\t\\t\\t\\t\\t\\t\\n            1\\n            1\\n      1  grid[i][j]  1  1  1  1\\n            1\\n```\n```java\\npublic int orderOfLargestPlusSign(int N, int[][] mines) {\\n        int[][] grid = new int[N][N];\\n        for (int i = 0; i < N; i++) {\\n            Arrays.fill(grid[i], 1);\\n        }\\n        for (int[] mine: mines) {\\n            grid[mine[0]][mine[1]] = 0;\\n        }\\n        int[] pre = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            int count = 0;\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] != 0) {\\n                    grid[i][j] = Math.min(++count, ++pre[j]);\\n                } else {\\n                    count = 0;\\n                    pre[j] = 0;\\n                }\\n            }\\n        }\\n        Arrays.fill(pre, 0);\\n        int max = 0;\\n        for (int i = N - 1; i >= 0; i--) {\\n            int count = 0;\\n            for (int j = N - 1; j >= 0; j--) {\\n                if (grid[i][j] != 0) {\\n                    grid[i][j] = Math.min(grid[i][j], Math.min(++count, ++pre[j]));\\n                } else {\\n                    count = 0;\\n                    pre[j] = 0;\\n                }\\n                max = Math.max(max, grid[i][j]);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150316,
                "title": "c-2-easy-to-understand-readable-solutions-explanation-brute-force-then-optimize-accepted",
                "content": "**Solution 1: Brute Force** \\nTime Complexity: **O(N^3)**\\n```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int N, int[,] mines) {        \\n        int[,] grid = new int[N,N];\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < N; j++)\\n                grid[i, j] = 1;\\n        int minesCount = mines.GetLength(0);\\n        for (int i = 0; i < minesCount; i++)\\n            grid[mines[i, 0], mines[i, 1]] = 0;\\n        int maxOrder = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                if (grid[i, j] == 1)\\n                {\\n                    int currOrder = 0;\\n                    int dir = 0;\\n                    while (i - dir >= 0 && i + dir < N && j - dir >= 0 && j + dir < N)\\n                    {\\n                        if (grid[i, j - dir] == 1 && grid[i, j + dir] == 1 && grid[i - dir, j] == 1 && grid[i + dir, j] == 1)\\n                        {\\n                            currOrder++;\\n                            dir++;\\n                        }\\n                        else\\n                            break;\\n                    }\\n                    maxOrder = Math.Max(maxOrder, currOrder);\\n                }\\n            }\\n        }\\n        return maxOrder;\\n    }\\n}\\n```\\n**Solution 2**: \\n* The idea is to maintain four auxiliary matrices **left[,]**, **right[,]**, **top[,]** and **bottom[,]** to store consecutive 1\\u2019s in every direction. \\n* The largest + would be formed by a cell of input matrix that has **maximum** value by considering **minimum** of (**left[i, j], right[i, j], top[i, j], bottom[i, j]**)\\nTime Complexity: **O(N^2)**\\n```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int N, int[,] mines) {        \\n        int[,] grid = new int[N, N];\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < N; j++)\\n                grid[i, j] = 1;\\n        int minesCount = mines.GetLength(0);\\n        for (int i = 0; i < minesCount; i++)\\n            grid[mines[i, 0], mines[i, 1]] = 0;\\n        int[,] left = new int[N, N];\\n        int[,] right = new int[N, N];\\n        int[,] top = new int[N, N];\\n        int[,] bottom = new int[N, N];\\n        for (int i = 0; i < N; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                if (grid[i, j] == 1)\\n                {\\n                    top[i, j] = (i - 1 >= 0) ? top[i - 1, j] + 1 : 1;\\n                    left[i, j] = (j - 1 >= 0) ? left[i, j - 1] + 1 : 1;\\n                }\\n                else\\n                {\\n                    left[i, j] = 0;\\n                    top[i, j] = 0;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = N-1; i >=0; i--)\\n        {\\n            for (int j = N-1; j >=0; j--)\\n            {\\n                if (grid[i, j] == 1)\\n                {\\n                    bottom[i, j] = (i + 1 < N) ? bottom[i + 1, j] + 1 : 1;\\n                    right[i, j] = (j + 1 < N) ? right[i, j + 1] + 1 : 1;\\n                }\\n                else\\n                {\\n                    bottom[i, j] = 0;\\n                    right[i, j] = 0;\\n                }\\n                ans = Math.Max(ans, Math.Min(Math.Min(left[i,j], bottom[i,j]), Math.Min(right[i,j], top[i,j])));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int N, int[,] mines) {        \\n        int[,] grid = new int[N,N];\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < N; j++)\\n                grid[i, j] = 1;\\n        int minesCount = mines.GetLength(0);\\n        for (int i = 0; i < minesCount; i++)\\n            grid[mines[i, 0], mines[i, 1]] = 0;\\n        int maxOrder = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                if (grid[i, j] == 1)\\n                {\\n                    int currOrder = 0;\\n                    int dir = 0;\\n                    while (i - dir >= 0 && i + dir < N && j - dir >= 0 && j + dir < N)\\n                    {\\n                        if (grid[i, j - dir] == 1 && grid[i, j + dir] == 1 && grid[i - dir, j] == 1 && grid[i + dir, j] == 1)\\n                        {\\n                            currOrder++;\\n                            dir++;\\n                        }\\n                        else\\n                            break;\\n                    }\\n                    maxOrder = Math.Max(maxOrder, currOrder);\\n                }\\n            }\\n        }\\n        return maxOrder;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int N, int[,] mines) {        \\n        int[,] grid = new int[N, N];\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < N; j++)\\n                grid[i, j] = 1;\\n        int minesCount = mines.GetLength(0);\\n        for (int i = 0; i < minesCount; i++)\\n            grid[mines[i, 0], mines[i, 1]] = 0;\\n        int[,] left = new int[N, N];\\n        int[,] right = new int[N, N];\\n        int[,] top = new int[N, N];\\n        int[,] bottom = new int[N, N];\\n        for (int i = 0; i < N; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                if (grid[i, j] == 1)\\n                {\\n                    top[i, j] = (i - 1 >= 0) ? top[i - 1, j] + 1 : 1;\\n                    left[i, j] = (j - 1 >= 0) ? left[i, j - 1] + 1 : 1;\\n                }\\n                else\\n                {\\n                    left[i, j] = 0;\\n                    top[i, j] = 0;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = N-1; i >=0; i--)\\n        {\\n            for (int j = N-1; j >=0; j--)\\n            {\\n                if (grid[i, j] == 1)\\n                {\\n                    bottom[i, j] = (i + 1 < N) ? bottom[i + 1, j] + 1 : 1;\\n                    right[i, j] = (j + 1 < N) ? right[i, j + 1] + 1 : 1;\\n                }\\n                else\\n                {\\n                    bottom[i, j] = 0;\\n                    right[i, j] = 0;\\n                }\\n                ans = Math.Max(ans, Math.Min(Math.Min(left[i,j], bottom[i,j]), Math.Min(right[i,j], top[i,j])));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117395,
                "title": "stupid-but-simple-solution",
                "content": "Calculate matrices in all 4 directions, then just take the minimum.\n```\nclass Solution(object):\n    def orderOfLargestPlusSign(self, N, mines):\n        \"\"\"\n        :type N: int\n        :type mines: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ismine = {(mine[0],mine[1]):True for mine in mines}\n        up = [[0 for j in xrange(N)] for i in xrange(N)]\n        down = [[0 for j in xrange(N)] for i in xrange(N)]\n        left = [[0 for j in xrange(N)] for i in xrange(N)]\n        right = [[0 for j in xrange(N)] for i in xrange(N)]\n        \n        for j in xrange(N):\n            for i in xrange(N-1,-1,-1):\n                if (i,j) in ismine:\n                    up[i][j]=0\n                else:\n                    if i+1<N:\n                        up[i][j]=up[i+1][j]+1\n                    else:\n                        up[i][j]=1\n        for j in xrange(N):\n            for i in xrange(0,N):\n                if (i,j) in ismine:\n                    down[i][j]=0\n                else:\n                    if i-1>=0:\n                        down[i][j]=down[i-1][j]+1\n                    else:\n                        down[i][j]=1\n        for i in xrange(N):\n            for j in xrange(N-1,-1,-1):\n                if (i,j) in ismine:\n                    left[i][j]=0\n                else:\n                    if j+1<N:\n                        left[i][j]=left[i][j+1]+1\n                    else:\n                        left[i][j]=1\n        for i in xrange(N):\n            for j in xrange(N):\n                if (i,j) in ismine:\n                    right[i][j]=0\n                else:\n                    if j-1>=0:\n                        right[i][j]=right[i][j-1]+1\n                    else:\n                        right[i][j]=1\n        # print right\n        global_max = 0\n        for i in xrange(N):\n            for j in xrange(N):\n                global_max = max(global_max, min(up[i][j],down[i][j],left[i][j],right[i][j]))\n        return global_max\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def orderOfLargestPlusSign(self, N, mines):\n        \"\"\"\n        :type N: int\n        :type mines: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ismine = {(mine[0],mine[1]):True for mine in mines}\n        up = [[0 for j in xrange(N)] for i in xrange(N)]\n        down = [[0 for j in xrange(N)] for i in xrange(N)]\n        left = [[0 for j in xrange(N)] for i in xrange(N)]\n        right = [[0 for j in xrange(N)] for i in xrange(N)]\n        \n        for j in xrange(N):\n            for i in xrange(N-1,-1,-1):\n                if (i,j) in ismine:\n                    up[i][j]=0\n                else:\n                    if i+1<N:\n                        up[i][j]=up[i+1][j]+1\n                    else:\n                        up[i][j]=1\n        for j in xrange(N):\n            for i in xrange(0,N):\n                if (i,j) in ismine:\n                    down[i][j]=0\n                else:\n                    if i-1>=0:\n                        down[i][j]=down[i-1][j]+1\n                    else:\n                        down[i][j]=1\n        for i in xrange(N):\n            for j in xrange(N-1,-1,-1):\n                if (i,j) in ismine:\n                    left[i][j]=0\n                else:\n                    if j+1<N:\n                        left[i][j]=left[i][j+1]+1\n                    else:\n                        left[i][j]=1\n        for i in xrange(N):\n            for j in xrange(N):\n                if (i,j) in ismine:\n                    right[i][j]=0\n                else:\n                    if j-1>=0:\n                        right[i][j]=right[i][j-1]+1\n                    else:\n                        right[i][j]=1\n        # print right\n        global_max = 0\n        for i in xrange(N):\n            for j in xrange(N):\n                global_max = max(global_max, min(up[i][j],down[i][j],left[i][j],right[i][j]))\n        return global_max\n```",
                "codeTag": "Java"
            },
            {
                "id": 113947,
                "title": "python-dp-code-optimized-explanation-in-detail-accepted",
                "content": "The straightforward approach. The following code did some optimization, and it was accepted.\\n\\nTwo keys:\\n1. convert mines from list to dictionary\\n2. use try/except instead of if/else to deal with matrix boundary issue. \\n\\n```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # Methods to reduce computational time:\\n        # 1. convert mines from list to dictionary. O(n^3) to O(n^2)\\n        # 2. use try/except instead of if else to deal with matrix boundary\\n        \\n        L  = [[0 for x in range(N)] for y in range(N)] #L[i][j]: number of continuous 1 from L[i][j] towards its left, L[i][j] included. \\n        R  = [[0 for x in range(N)] for y in range(N)] #Right\\n        U  = [[0 for x in range(N)] for y in range(N)] #Up\\n        D  = [[0 for x in range(N)] for y in range(N)] #Down\\n \\n        dicMines = {(mine[0], mine[1]) for mine in mines} # convert mines from list to dictionary\\n        \\n        # calcuate L and D in O(n^2) time\\n        for i in range(N):\\n            for j in range(N):\\n                if (i,j) not in dicMines:\\n                    # use try/except instead of if/else to reduce time, if/else method is presented below as well\\n                    try: L[i][j] = L[i][j-1] + 1\\n                    except Exception: L[i][j] = 1\\n                    try: D[i][j] = D[i-1][j] + 1\\n                    except Exception: D[i][j] = 1\\n                        \\n                    #if/else method presented for reference\\n                    #L[i][j] = L[i][j-1] + 1 if j > 0 else 1\\n                    #D[i][j] = D[i-1][j] + 1 if i > 0 else 1\\n                  \\n        # calcuate R and U in O(n^2) time\\n        for i in range (N-1, -1, -1):\\n            for j in range(N-1, -1, -1):\\n                if (i,j) not in dicMines:\\n                    try: R[i][j] = R[i][j+1] + 1\\n                    except Exception: R[i][j] = 1\\n                    try: U[i][j] = U[i+1][j] + 1\\n                    except Exception: U[i][j] = 1\\n\\n                    #R[i][j] = R[i][j+1] + 1 if j < N-1 else 1\\n                    #U[i][j] = U[i+1][j] + 1 if i < N-1 else 1\\n        MaxK = 0\\n        MaxK = max(min(L[i][j], R[i][j], U[i][j], D[i][j]) for i in range(N) for j in range(N))\\n        return (MaxK)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # Methods to reduce computational time:\\n        # 1. convert mines from list to dictionary. O(n^3) to O(n^2)\\n        # 2. use try/except instead of if else to deal with matrix boundary\\n        \\n        L  = [[0 for x in range(N)] for y in range(N)] #L[i][j]: number of continuous 1 from L[i][j] towards its left, L[i][j] included. \\n        R  = [[0 for x in range(N)] for y in range(N)] #Right\\n        U  = [[0 for x in range(N)] for y in range(N)] #Up\\n        D  = [[0 for x in range(N)] for y in range(N)] #Down\\n \\n        dicMines = {(mine[0], mine[1]) for mine in mines} # convert mines from list to dictionary\\n        \\n        # calcuate L and D in O(n^2) time\\n        for i in range(N):\\n            for j in range(N):\\n                if (i,j) not in dicMines:\\n                    # use try/except instead of if/else to reduce time, if/else method is presented below as well\\n                    try: L[i][j] = L[i][j-1] + 1\\n                    except Exception: L[i][j] = 1\\n                    try: D[i][j] = D[i-1][j] + 1\\n                    except Exception: D[i][j] = 1\\n                        \\n                    #if/else method presented for reference\\n                    #L[i][j] = L[i][j-1] + 1 if j > 0 else 1\\n                    #D[i][j] = D[i-1][j] + 1 if i > 0 else 1\\n                  \\n        # calcuate R and U in O(n^2) time\\n        for i in range (N-1, -1, -1):\\n            for j in range(N-1, -1, -1):\\n                if (i,j) not in dicMines:\\n                    try: R[i][j] = R[i][j+1] + 1\\n                    except Exception: R[i][j] = 1\\n                    try: U[i][j] = U[i+1][j] + 1\\n                    except Exception: U[i][j] = 1\\n\\n                    #R[i][j] = R[i][j+1] + 1 if j < N-1 else 1\\n                    #U[i][j] = U[i+1][j] + 1 if i < N-1 else 1\\n        MaxK = 0\\n        MaxK = max(min(L[i][j], R[i][j], U[i][j], D[i][j]) for i in range(N) for j in range(N))\\n        return (MaxK)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113343,
                "title": "python-ac-and-the-trick-to-avoid-tle",
                "content": "I guess many python people also suffered from the TLE.\\n\\nHere is my code that just passed. It is not the best. But I just want to jump out to let those python guys know this may be what the judge is expecting: avoid looking at those points that can not be better than known best \"plus length\".\\n\\nPlease pay attention to this two lines in my code below. This makes my solution from TLE to AC:\\n```\\nif N-j<=maxmin or N-i<=maxmin:\\n    continue\\n```\\n\\nThe main thing that makes it from TLE to AC is that: when we move to area where the max plus length(which is my ```maxmin``` below) is already larger than the distance it can reach the boundary(```N-j``` or ```N-i```), either right boundary or lower boundary, we need to drop those to reduce unnecessary work, because there is no point to keep moving right or keep moving down.\\n\\n```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        if not N: return 0\\n        if len(mines)==N*N: return 0\\n        self.mmset = []\\n        for i in range(N):\\n            self.mmset.append([True for j in range(N)])\\n        for p in mines:\\n            self.mmset[p[0]][p[1]] = False\\n            \\n        maxmin = 0\\n        # using rolling arrays to achieve DP.\\n        # the 4 elements tuple means length of 1s for [North, West, South, East].\\n        oldline = [[0,0,0,0] for _ in range(N)]\\n        for i in range(N):\\n            newline = [[0,0,0,0] for _ in range(N)]\\n            for j in range(0, N):\\n                if not self.mmset[i][j]:\\n                    continue\\n                if N-j<=maxmin or N-i<=maxmin:\\n                    continue\\n                newline[j][0] = oldline[j][0] + 1\\n                \\n                if j==0:\\n                    newline[j][1] = 1\\n                else:\\n                    newline[j][1] = newline[j-1][1]+1\\n                \\n                if oldline[j][2]==0:\\n                    for newi in xrange(i,N):\\n                        if self.mmset[newi][j]:\\n                            newline[j][2]+=1\\n                        else:\\n                            break\\n                else:\\n                    newline[j][2] = oldline[j][2]-1\\n                \\n                if j==0 or newline[j-1][3]==0:\\n                    for newj in xrange(j, N):\\n                        if self.mmset[i][newj]:\\n                            newline[j][3] += 1\\n                        else:\\n                            break\\n                else:\\n                    newline[j][3] = newline[j-1][3]-1\\n                \\n                maxmin = max(min(newline[j]), maxmin)\\n                \\n            oldline = newline\\n        return maxmin\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nif N-j<=maxmin or N-i<=maxmin:\\n    continue\\n```\n```maxmin```\n```N-j```\n```N-i```\n```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        if not N: return 0\\n        if len(mines)==N*N: return 0\\n        self.mmset = []\\n        for i in range(N):\\n            self.mmset.append([True for j in range(N)])\\n        for p in mines:\\n            self.mmset[p[0]][p[1]] = False\\n            \\n        maxmin = 0\\n        # using rolling arrays to achieve DP.\\n        # the 4 elements tuple means length of 1s for [North, West, South, East].\\n        oldline = [[0,0,0,0] for _ in range(N)]\\n        for i in range(N):\\n            newline = [[0,0,0,0] for _ in range(N)]\\n            for j in range(0, N):\\n                if not self.mmset[i][j]:\\n                    continue\\n                if N-j<=maxmin or N-i<=maxmin:\\n                    continue\\n                newline[j][0] = oldline[j][0] + 1\\n                \\n                if j==0:\\n                    newline[j][1] = 1\\n                else:\\n                    newline[j][1] = newline[j-1][1]+1\\n                \\n                if oldline[j][2]==0:\\n                    for newi in xrange(i,N):\\n                        if self.mmset[newi][j]:\\n                            newline[j][2]+=1\\n                        else:\\n                            break\\n                else:\\n                    newline[j][2] = oldline[j][2]-1\\n                \\n                if j==0 or newline[j-1][3]==0:\\n                    for newj in xrange(j, N):\\n                        if self.mmset[i][newj]:\\n                            newline[j][3] += 1\\n                        else:\\n                            break\\n                else:\\n                    newline[j][3] = newline[j-1][3]-1\\n                \\n                maxmin = max(min(newline[j]), maxmin)\\n                \\n            oldline = newline\\n        return maxmin\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 113326,
                "title": "o-n-2-python-solution-tle-on-2-test-cases",
                "content": "I read the note about stricter C/C++ time limit, so I wrote an N^2 python solution. Why was this rejected?\\n\\nMinor optimizations won't change the order O(N^2).\\n\\n\\n```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        left=[[0]*N for __ in xrange(N)]\\n        right=[[0]*N for __ in xrange(N)]\\n        up=[[0]*N for __ in xrange(N)]\\n        down=[[0]*N for __ in xrange(N)]\\n\\n        g=[[1]*N for __ in xrange(N)]\\n\\n        for (r, c) in mines:\\n            g[r][c]=0\\n\\n        for r in xrange(N):\\n            last=None\\n            for c in xrange(N):\\n                if g[r][c]:\\n                    last=last or c\\n                    left[r][c]=last\\n                else:\\n                    last=None\\n\\n            last=None\\n            for c in xrange(N-1, -1, -1):\\n                if g[r][c]:\\n                    last=last or c\\n                    right[r][c]=last\\n                else:\\n                    last=None\\n            \\n        for c in xrange(N):\\n            last=None\\n            for r in xrange(N):\\n                if g[r][c]:\\n                    last=last or c\\n                    up[r][c]=last\\n                else:\\n                    last=None\\n\\n            last=None\\n            for r in xrange(N-1, -1, -1):\\n                if g[r][c]:\\n                    last=last or c\\n                    down[r][c]=last\\n                else:\\n                    last=None\\n\\n        mx=0\\n        for r in xrange(N):\\n            for c in xrange(N):\\n                if g[r][c]:\\n                    horz=min(right[r][c]-c,c-left[r][c])+1\\n                    vert=min(down[r][c]-r,r-up[r][c])+1\\n                    val=min(horz, vert)\\n                    mx=max(val, mx)\\n            \\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def orderOfLargestPlusSign(self, N, mines):\\n        \"\"\"\\n        :type N: int\\n        :type mines: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        left=[[0]*N for __ in xrange(N)]\\n        right=[[0]*N for __ in xrange(N)]\\n        up=[[0]*N for __ in xrange(N)]\\n        down=[[0]*N for __ in xrange(N)]\\n\\n        g=[[1]*N for __ in xrange(N)]\\n\\n        for (r, c) in mines:\\n            g[r][c]=0\\n\\n        for r in xrange(N):\\n            last=None\\n            for c in xrange(N):\\n                if g[r][c]:\\n                    last=last or c\\n                    left[r][c]=last\\n                else:\\n                    last=None\\n\\n            last=None\\n            for c in xrange(N-1, -1, -1):\\n                if g[r][c]:\\n                    last=last or c\\n                    right[r][c]=last\\n                else:\\n                    last=None\\n            \\n        for c in xrange(N):\\n            last=None\\n            for r in xrange(N):\\n                if g[r][c]:\\n                    last=last or c\\n                    up[r][c]=last\\n                else:\\n                    last=None\\n\\n            last=None\\n            for r in xrange(N-1, -1, -1):\\n                if g[r][c]:\\n                    last=last or c\\n                    down[r][c]=last\\n                else:\\n                    last=None\\n\\n        mx=0\\n        for r in xrange(N):\\n            for c in xrange(N):\\n                if g[r][c]:\\n                    horz=min(right[r][c]-c,c-left[r][c])+1\\n                    vert=min(down[r][c]-r,r-up[r][c])+1\\n                    val=min(horz, vert)\\n                    mx=max(val, mx)\\n            \\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101031,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int directionArray[5] = {0,1,0,-1,0};\\n    int dp[500][500][4];\\n    int n;\\n    int solve(int x,int y,vector<vector<int>>& arr,int direction){\\n        if(x < 0 || y < 0 || x >= n || y >= n || arr[x][y] == 0)\\n            return 0;\\n        if(dp[x][y][direction] != -1)\\n            return dp[x][y][direction];\\n        return dp[x][y][direction] = 1 + solve(x+directionArray[direction],y+directionArray[direction+1],arr,direction);\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        this->n = n;\\n        vector<vector<int>>arr(n,vector<int>(n,1));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i = 0;i<mines.size();i++){\\n            arr[mines[i][0]][mines[i][1]] = 0;\\n        }\\n        int ans = 0;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < n;j++){\\n                int mini = INT_MAX;\\n                for(int k = 0;k < 4;k++)\\n                    mini = min(mini,solve(i,j,arr,k));\\n                ans = max(mini,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int directionArray[5] = {0,1,0,-1,0};\\n    int dp[500][500][4];\\n    int n;\\n    int solve(int x,int y,vector<vector<int>>& arr,int direction){\\n        if(x < 0 || y < 0 || x >= n || y >= n || arr[x][y] == 0)\\n            return 0;\\n        if(dp[x][y][direction] != -1)\\n            return dp[x][y][direction];\\n        return dp[x][y][direction] = 1 + solve(x+directionArray[direction],y+directionArray[direction+1],arr,direction);\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        this->n = n;\\n        vector<vector<int>>arr(n,vector<int>(n,1));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i = 0;i<mines.size();i++){\\n            arr[mines[i][0]][mines[i][1]] = 0;\\n        }\\n        int ans = 0;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < n;j++){\\n                int mini = INT_MAX;\\n                for(int k = 0;k < 4;k++)\\n                    mini = min(mini,solve(i,j,arr,k));\\n                ans = max(mini,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097386,
                "title": "python-two-concise-loops-tc-o-n-2-sc-o-n-2",
                "content": "\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        mine_set = set([(x, y) for x, y in mines])\\n        row = lambda: [defaultdict(int) for _ in range(n)]\\n        dp = [row() for _ in range(n)]\\n        t, b, l, rt = \\'t\\', \\'b\\', \\'l\\', \\'r\\'\\n        res = 0\\n\\n        for r in range(n):\\n            for c in range(n):\\n                if (r, c) in mine_set:\\n                    continue\\n\\n                dp[r][c][t] = 1 if r == 0 else 1 + dp[r - 1][c][t]\\n                dp[r][c][l] = 1 if c == 0 else 1 + dp[r][c - 1][l]\\n\\n        for r in range(n - 1, -1, -1):\\n            for c in range(n - 1, -1, -1):\\n                    if (r, c) in mine_set:\\n                        continue\\n\\n                    dp[r][c][b] = 1 if r == n - 1 else 1 + dp[r + 1][c][b]\\n                    dp[r][c][rt] = 1 if c == n - 1 else 1 + dp[r][c + 1][rt]\\n\\n                    res = max(res, min(dp[r][c][t], dp[r][c][b], dp[r][c][l], dp[r][c][rt]))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        mine_set = set([(x, y) for x, y in mines])\\n        row = lambda: [defaultdict(int) for _ in range(n)]\\n        dp = [row() for _ in range(n)]\\n        t, b, l, rt = \\'t\\', \\'b\\', \\'l\\', \\'r\\'\\n        res = 0\\n\\n        for r in range(n):\\n            for c in range(n):\\n                if (r, c) in mine_set:\\n                    continue\\n\\n                dp[r][c][t] = 1 if r == 0 else 1 + dp[r - 1][c][t]\\n                dp[r][c][l] = 1 if c == 0 else 1 + dp[r][c - 1][l]\\n\\n        for r in range(n - 1, -1, -1):\\n            for c in range(n - 1, -1, -1):\\n                    if (r, c) in mine_set:\\n                        continue\\n\\n                    dp[r][c][b] = 1 if r == n - 1 else 1 + dp[r + 1][c][b]\\n                    dp[r][c][rt] = 1 if c == n - 1 else 1 + dp[r][c + 1][rt]\\n\\n                    res = max(res, min(dp[r][c][t], dp[r][c][b], dp[r][c][l], dp[r][c][rt]))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077521,
                "title": "prefix-sum-java-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    public static int horL[][];\\n    public static int horR[][];\\n    public static int verU[][];\\n    public static int verD[][];\\n\\n    public static int m;\\n    public static int n;\\n\\n    public int orderOfLargestPlusSign(int len, int[][] arr) {\\n\\n        int mines[][] = new int[len][len];\\n\\n        for(int i=0; i<len; i++){\\n            Arrays.fill(mines[i], 1);\\n        }\\n\\n        for(int i=0; i<arr.length; i++){\\n            mines[arr[i][0]][arr[i][1]] = 0;\\n        }\\n\\n        m = mines.length;\\n        n = mines[0].length;\\n\\n        horL = new int[m][n];\\n        horR = new int[m][n];\\n        verU = new int[m][n];\\n        verD = new int[m][n];\\n\\n        for(int i=0; i<m; i++){\\n\\n            int hL = 0;\\n            int hR = 0;\\n\\n            int s = 0;\\n            int e = n - 1;\\n\\n            while(s < n && e >= 0){\\n                hL = mines[i][s] == 0 ? 0 : hL + 1;\\n                hR = mines[i][e] == 0 ? 0 : hR + 1;\\n\\n                horL[i][s++] = hL;\\n                horR[i][e--] = hR;\\n            }\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n\\n            int vU = 0;\\n            int vD = 0;\\n\\n            int s = 0;\\n            int e = m - 1;\\n\\n            while(s < m && e >= 0){\\n                vU = mines[s][i] == 0 ? 0 : vU + 1;\\n                vD = mines[e][i] == 0 ? 0 : vD + 1;\\n\\n                verU[s++][i] = vU;\\n                verD[e--][i] = vD;\\n            }\\n\\n        }\\n\\n        // for(int i=0; i<m; i++){\\n        //     System.out.println(Arrays.toString(horL[i]));\\n        // }\\n\\n        int res = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n\\n                int horTemp = Math.min(horL[i][j], horR[i][j]);\\n                int verTemp = Math.min(verU[i][j], verD[i][j]);\\n\\n                res = Math.max(res, Math.min(horTemp, verTemp));\\n\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int horL[][];\\n    public static int horR[][];\\n    public static int verU[][];\\n    public static int verD[][];\\n\\n    public static int m;\\n    public static int n;\\n\\n    public int orderOfLargestPlusSign(int len, int[][] arr) {\\n\\n        int mines[][] = new int[len][len];\\n\\n        for(int i=0; i<len; i++){\\n            Arrays.fill(mines[i], 1);\\n        }\\n\\n        for(int i=0; i<arr.length; i++){\\n            mines[arr[i][0]][arr[i][1]] = 0;\\n        }\\n\\n        m = mines.length;\\n        n = mines[0].length;\\n\\n        horL = new int[m][n];\\n        horR = new int[m][n];\\n        verU = new int[m][n];\\n        verD = new int[m][n];\\n\\n        for(int i=0; i<m; i++){\\n\\n            int hL = 0;\\n            int hR = 0;\\n\\n            int s = 0;\\n            int e = n - 1;\\n\\n            while(s < n && e >= 0){\\n                hL = mines[i][s] == 0 ? 0 : hL + 1;\\n                hR = mines[i][e] == 0 ? 0 : hR + 1;\\n\\n                horL[i][s++] = hL;\\n                horR[i][e--] = hR;\\n            }\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n\\n            int vU = 0;\\n            int vD = 0;\\n\\n            int s = 0;\\n            int e = m - 1;\\n\\n            while(s < m && e >= 0){\\n                vU = mines[s][i] == 0 ? 0 : vU + 1;\\n                vD = mines[e][i] == 0 ? 0 : vD + 1;\\n\\n                verU[s++][i] = vU;\\n                verD[e--][i] = vD;\\n            }\\n\\n        }\\n\\n        // for(int i=0; i<m; i++){\\n        //     System.out.println(Arrays.toString(horL[i]));\\n        // }\\n\\n        int res = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n\\n                int horTemp = Math.min(horL[i][j], horR[i][j]);\\n                int verTemp = Math.min(verU[i][j], verD[i][j]);\\n\\n                res = Math.max(res, Math.min(horTemp, verTemp));\\n\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056715,
                "title": "764-largest-plus-sign",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize four 2D arrays left, right, up, and down of the same size as the grid, initially filled with zeros.\\n\\nTraverse the grid to compute the length of left arms:\\n\\nFor each cell with value 1, increment a counter and store it in the corresponding cell of the left array. If the cell has a value of 0, reset the counter to 0.\\nTraverse the grid to compute the length of right arms:\\n\\nSimilar to step 2 but traverse each row from right to left to compute the right array.\\nTraverse the grid to compute the length of up arms:\\n\\nFor each cell with value 1, increment a counter and store it in the corresponding cell of the up array. If the cell has a value of 0, reset the counter to 0.\\nTraverse the grid to compute the length of down arms:\\n\\nSimilar to step 4 but traverse each column from bottom to top to compute the down array.\\nFor each cell in the grid with a value of 1:\\n\\nCalculate the order of the plus sign by taking the minimum value among the lengths of the four arms (left, right, up, down).\\nUpdate the maximum order if the current order is larger.\\nAfter traversing the entire grid, return the maximum order as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>up(n, vector<int>(n));\\n         vector<vector<int>>down(n, vector<int>(n));\\n          vector<vector<int>>left(n, vector<int>(n));\\n           vector<vector<int>>right(n, vector<int>(n));\\n           vector<vector<int>>v(n, vector<int>(n,1));\\n           int maxi=0;\\n           for(int i=0; i<mines.size(); i++)\\n           {\\n               v[mines[i][0]][mines[i][1]]=0;\\n           }\\n           int count=0;\\n           for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=0; j<n; j++)\\n               {\\n                   if(v[i][j]==1)\\n                   {\\n                       count++;\\n                       left[i][j]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n             for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=n-1; j>=0; j--)\\n               {\\n                   if(v[i][j]==1)\\n                   {\\n                       count++;\\n                       right[i][j]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n  for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=0; j<n; j++)\\n               {\\n                   if(v[j][i]==1)\\n                   {\\n                       count++;\\n                       up[j][i]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n\\n\\n  for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=n-1; j>=0; j--)\\n               {\\n                   if(v[j][i]==1)\\n                   {\\n                       count++;\\n                       down[j][i]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n           for(int i=0; i<n; i++)\\n           {\\n               for(int j=0; j<n; j++)\\n               {\\n                      if(v[i][j]==1)\\n                      {\\n                          int order=min({ left[i][j] , right[i][j] , up[i][j] , down[i][j]});\\n                          maxi=max(maxi,order);\\n                      }\\n               }\\n           }\\n      return maxi;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>up(n, vector<int>(n));\\n         vector<vector<int>>down(n, vector<int>(n));\\n          vector<vector<int>>left(n, vector<int>(n));\\n           vector<vector<int>>right(n, vector<int>(n));\\n           vector<vector<int>>v(n, vector<int>(n,1));\\n           int maxi=0;\\n           for(int i=0; i<mines.size(); i++)\\n           {\\n               v[mines[i][0]][mines[i][1]]=0;\\n           }\\n           int count=0;\\n           for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=0; j<n; j++)\\n               {\\n                   if(v[i][j]==1)\\n                   {\\n                       count++;\\n                       left[i][j]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n             for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=n-1; j>=0; j--)\\n               {\\n                   if(v[i][j]==1)\\n                   {\\n                       count++;\\n                       right[i][j]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n  for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=0; j<n; j++)\\n               {\\n                   if(v[j][i]==1)\\n                   {\\n                       count++;\\n                       up[j][i]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n\\n\\n  for(int i=0; i<n; i++)\\n           {\\n             count=0;\\n\\n               for(int j=n-1; j>=0; j--)\\n               {\\n                   if(v[j][i]==1)\\n                   {\\n                       count++;\\n                       down[j][i]=count;\\n                   }\\n                   else count=0;\\n               }\\n           }\\n\\n\\n\\n           for(int i=0; i<n; i++)\\n           {\\n               for(int j=0; j<n; j++)\\n               {\\n                      if(v[i][j]==1)\\n                      {\\n                          int order=min({ left[i][j] , right[i][j] , up[i][j] , down[i][j]});\\n                          maxi=max(maxi,order);\\n                      }\\n               }\\n           }\\n      return maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979225,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // 0, 1, 2, 3\\n\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] grid = new int[n][n];\\n        for (int[] g: grid) {\\n            Arrays.fill(g, 1);\\n        }\\n        for (int[] m: mines) {\\n            grid[m[0]][m[1]] = 0;\\n        }\\n        int[][][] dp = new int[n][n][4]; // 0: up, 1:right, 2:down, 3:left\\n\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int minstep = Integer.MAX_VALUE;\\n                for (int[] d: dirs) {\\n\\n                    int step = 0;\\n                    int x = i;\\n                    int y = j;\\n\\n                    while (x >= 0 && x < n && y >= 0 && y < n && grid[x][y] == 1) {\\n                        step++;\\n                        x += d[0];\\n                        y += d[1];   \\n                    }\\n                    minstep = Math.min(minstep, step);\\n                }\\n\\n                if (minstep <= 1) continue; \\n                res = Math.max(minstep, res);\\n            }   \\n        }\\n        boolean hasone = mines.length < n * n ? true : false;\\n\\n        return res < 0 ? (hasone == true ? 1 : 0) : res;\\n    }\\n\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        //jai shri ram\\n        int ans=0;\\n        vector<bool>block(25*int(1e4)+1,0);\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(auto x:mines){\\n            int a=x[0],b=x[1];\\n            block[a*n+b]=true;\\n        }\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else {\\n                    sum+=1;\\n                }\\n                dp[i][j]=sum;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int j=n-1;j>=0;j--){\\n            int sum=0;\\n            for(int i=n-1;i>=0;i--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int sum=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n\\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // 0, 1, 2, 3\\n\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] grid = new int[n][n];\\n        for (int[] g: grid) {\\n            Arrays.fill(g, 1);\\n        }\\n        for (int[] m: mines) {\\n            grid[m[0]][m[1]] = 0;\\n        }\\n        int[][][] dp = new int[n][n][4]; // 0: up, 1:right, 2:down, 3:left\\n\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int minstep = Integer.MAX_VALUE;\\n                for (int[] d: dirs) {\\n\\n                    int step = 0;\\n                    int x = i;\\n                    int y = j;\\n\\n                    while (x >= 0 && x < n && y >= 0 && y < n && grid[x][y] == 1) {\\n                        step++;\\n                        x += d[0];\\n                        y += d[1];   \\n                    }\\n                    minstep = Math.min(minstep, step);\\n                }\\n\\n                if (minstep <= 1) continue; \\n                res = Math.max(minstep, res);\\n            }   \\n        }\\n        boolean hasone = mines.length < n * n ? true : false;\\n\\n        return res < 0 ? (hasone == true ? 1 : 0) : res;\\n    }\\n\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        //jai shri ram\\n        int ans=0;\\n        vector<bool>block(25*int(1e4)+1,0);\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(auto x:mines){\\n            int a=x[0],b=x[1];\\n            block[a*n+b]=true;\\n        }\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else {\\n                    sum+=1;\\n                }\\n                dp[i][j]=sum;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int j=n-1;j>=0;j--){\\n            int sum=0;\\n            for(int i=n-1;i>=0;i--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int sum=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(block[i*n+j]){\\n                    sum=0;\\n                }else sum+=1;\\n                dp[i][j]=min(dp[i][j],sum);\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973758,
                "title": "minimum-distance-dp-explained-python3",
                "content": "# Intuition\\n\\nIf we know the minimum distance to either an edge or mine in the x direction for each cell and also the minimum distance to either an edge or mine in the y direction for each cell, we can solve the problem!\\n\\nWe can find these values using DP!\\n\\nSee the commented code below.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```python\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        # dp_x is minimum distance to mine or edge in x direction\\n        # dp_y is minimum distance to mine or edge in y direction\\n        # find the x,y with max of min of both \\n        dp_x = [[sys.maxsize] * (n + 2) for _ in range(n + 2)] # use -1 and n (assume mine exists at edge cells), so use n + 2\\n        dp_y = [row[:] for row in dp_x] # copy of dp_x\\n        for row in range(n): # set mines at edges of rows\\n            for col in [n, n+1]:\\n                dp_x[row][col] = 0\\n                dp_y[row][col] = 0\\n        for row in [n, n+1]: # set mines at edges of cols\\n            dp_x[row] = [0] * (n + 2)\\n            dp_y[row] = [0] * (n + 2)\\n        for row, col in mines: # init mines\\n            dp_x[row][col] = 0\\n            dp_y[row][col] = 0 \\n        for row in dp_x: # dp going right\\n            for col in range(n):\\n                row[col] = min(row[col], row[col - 1] + 1)\\n        for row in dp_x: # dp going left\\n            for col in range(n - 1, -1, -1):\\n                row[col] = min(row[col], row[col + 1] + 1)\\n        for col in range(n): # dp going down\\n            for row in range(n):\\n                dp_y[row][col] = min(dp_y[row][col], dp_y[row - 1][col] + 1)\\n        for col in range(n): # dp going up\\n            for row in range(n - 1, -1, -1):\\n                dp_y[row][col] = min(dp_y[row][col], dp_y[row + 1][col] + 1)\\n        max_plus = 0\\n        for row in range(n):\\n            for col in range(n):\\n                max_plus = max(max_plus, min(dp_x[row][col], dp_y[row][col]))\\n        return max_plus\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        # dp_x is minimum distance to mine or edge in x direction\\n        # dp_y is minimum distance to mine or edge in y direction\\n        # find the x,y with max of min of both \\n        dp_x = [[sys.maxsize] * (n + 2) for _ in range(n + 2)] # use -1 and n (assume mine exists at edge cells), so use n + 2\\n        dp_y = [row[:] for row in dp_x] # copy of dp_x\\n        for row in range(n): # set mines at edges of rows\\n            for col in [n, n+1]:\\n                dp_x[row][col] = 0\\n                dp_y[row][col] = 0\\n        for row in [n, n+1]: # set mines at edges of cols\\n            dp_x[row] = [0] * (n + 2)\\n            dp_y[row] = [0] * (n + 2)\\n        for row, col in mines: # init mines\\n            dp_x[row][col] = 0\\n            dp_y[row][col] = 0 \\n        for row in dp_x: # dp going right\\n            for col in range(n):\\n                row[col] = min(row[col], row[col - 1] + 1)\\n        for row in dp_x: # dp going left\\n            for col in range(n - 1, -1, -1):\\n                row[col] = min(row[col], row[col + 1] + 1)\\n        for col in range(n): # dp going down\\n            for row in range(n):\\n                dp_y[row][col] = min(dp_y[row][col], dp_y[row - 1][col] + 1)\\n        for col in range(n): # dp going up\\n            for row in range(n - 1, -1, -1):\\n                dp_y[row][col] = min(dp_y[row][col], dp_y[row + 1][col] + 1)\\n        max_plus = 0\\n        for row in range(n):\\n            for col in range(n):\\n                max_plus = max(max_plus, min(dp_x[row][col], dp_y[row][col]))\\n        return max_plus\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949074,
                "title": "extra-memory-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  int orderOfLargestPlusSign(int n, vector<vector<int>>& a) {\\n    vector<vector<int>> mines(n, vector<int>(n, 1));\\n    for(int i = 0; i < a.size(); i++)  {\\n      mines[a[i][0]][a[i][1]] = 0;\\n    }\\n    vector<vector<int>> left(n, vector<int>(n));\\n    for(int i = 0; i < n; i++)  {\\n      int len = 0;\\n      for(int j = 0; j < n; j++)  {\\n        len = (mines[i][j] == 1 ? len + 1 : 0);\\n        left[i][j] = len;\\n      }\\n    }\\n    vector<vector<int>> right(n, vector<int>(n));\\n    for(int i = n - 1; i >= 0; i--) {\\n      int len = 0;\\n      for(int j = n - 1; j >= 0; j--) {\\n        len = (mines[i][j] == 1 ? len + 1 : 0);\\n        right[i][j] = len;\\n      }\\n    }\\n    vector<vector<int>> up(n, vector<int>(n));\\n    for(int i = 0; i < n; i++)  {\\n      int len = 0;\\n      for(int j = 0; j < n; j++)  {\\n        len = (mines[j][i] == 1 ? len + 1 : 0);\\n        up[j][i] = len;\\n      }\\n    }\\n    vector<vector<int>> down(n, vector<int>(n));\\n    for(int i = 0; i < n; i++)  {\\n      int len = 0;\\n      for(int j = n - 1; j >= 0; j--)  {\\n        len = (mines[j][i] == 1 ? len + 1 : 0);\\n        down[j][i] = len;\\n      }\\n    }\\n    int maxLen = 0;\\n    for(int i = 0; i < n; i++)  {\\n      for(int j = 0; j < n; j++)  {\\n        maxLen = max(maxLen, min({right[i][j], left[i][j], up[i][j], down[i][j]}));\\n      }\\n    }\\n    return maxLen;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int orderOfLargestPlusSign(int n, vector<vector<int>>& a) {\\n    vector<vector<int>> mines(n, vector<int>(n, 1));\\n    for(int i = 0; i < a.size(); i++)  {\\n      mines[a[i][0]][a[i][1]] = 0;\\n    }\\n    vector<vector<int>> left(n, vector<int>(n));\\n    for(int i = 0; i < n; i++)  {\\n      int len = 0;\\n      for(int j = 0; j < n; j++)  {\\n        len = (mines[i][j] == 1 ? len + 1 : 0);\\n        left[i][j] = len;\\n      }\\n    }\\n    vector<vector<int>> right(n, vector<int>(n));\\n    for(int i = n - 1; i >= 0; i--) {\\n      int len = 0;\\n      for(int j = n - 1; j >= 0; j--) {\\n        len = (mines[i][j] == 1 ? len + 1 : 0);\\n        right[i][j] = len;\\n      }\\n    }\\n    vector<vector<int>> up(n, vector<int>(n));\\n    for(int i = 0; i < n; i++)  {\\n      int len = 0;\\n      for(int j = 0; j < n; j++)  {\\n        len = (mines[j][i] == 1 ? len + 1 : 0);\\n        up[j][i] = len;\\n      }\\n    }\\n    vector<vector<int>> down(n, vector<int>(n));\\n    for(int i = 0; i < n; i++)  {\\n      int len = 0;\\n      for(int j = n - 1; j >= 0; j--)  {\\n        len = (mines[j][i] == 1 ? len + 1 : 0);\\n        down[j][i] = len;\\n      }\\n    }\\n    int maxLen = 0;\\n    for(int i = 0; i < n; i++)  {\\n      for(int j = 0; j < n; j++)  {\\n        maxLen = max(maxLen, min({right[i][j], left[i][j], up[i][j], down[i][j]}));\\n      }\\n    }\\n    return maxLen;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947815,
                "title": "dp-with-space-optim-in-single-pass-using-nested-loops-with-in-place-matrix-updates-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n\\n        # we initialize the matrix with MAX possible size of the plus sign\\n        matrix = [[n] * n for _ in range(n)]\\n        for row, col in mines:\\n            matrix[row][col] = 0\\n\\n        for row in range(n):\\n            right_length = 0\\n            down_length = 0\\n            left_length = 0\\n            up_length = 0\\n\\n            for col in range(n):\\n\\n                # we use col / ~col to calculate the number of \\'1\\'s in each horizontal direction\\n                matrix[row][col] = min(matrix[row][col], right_length := right_length + 1 if matrix[row][col] else 0)\\n                matrix[row][~col] = min(matrix[row][~col], left_length := left_length + 1 if matrix[row][~col] else 0)\\n\\n                # we \"swap\" col and row to avoid an extra loop as this is an \\'n x n\\' matrix ==> no problem\\n                matrix[col][row] = min(matrix[col][row], down_length := down_length + 1 if matrix[col][row] else 0)\\n                matrix[~col][row] = min(matrix[~col][row], up_length := up_length + 1 if matrix[~col][row] else 0)\\n\\n        # we us MAP to feed each row of the matrix into the MAX function and then calculate the MAX of those results\\n        return max(map(max, matrix))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n\\n        # we initialize the matrix with MAX possible size of the plus sign\\n        matrix = [[n] * n for _ in range(n)]\\n        for row, col in mines:\\n            matrix[row][col] = 0\\n\\n        for row in range(n):\\n            right_length = 0\\n            down_length = 0\\n            left_length = 0\\n            up_length = 0\\n\\n            for col in range(n):\\n\\n                # we use col / ~col to calculate the number of \\'1\\'s in each horizontal direction\\n                matrix[row][col] = min(matrix[row][col], right_length := right_length + 1 if matrix[row][col] else 0)\\n                matrix[row][~col] = min(matrix[row][~col], left_length := left_length + 1 if matrix[row][~col] else 0)\\n\\n                # we \"swap\" col and row to avoid an extra loop as this is an \\'n x n\\' matrix ==> no problem\\n                matrix[col][row] = min(matrix[col][row], down_length := down_length + 1 if matrix[col][row] else 0)\\n                matrix[~col][row] = min(matrix[~col][row], up_length := up_length + 1 if matrix[~col][row] else 0)\\n\\n        # we us MAP to feed each row of the matrix into the MAX function and then calculate the MAX of those results\\n        return max(map(max, matrix))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931080,
                "title": "c-prefix-brute-force-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> l(n,vector<int> (n,0)),r=l,u=l,d=l;\\n        vector<vector<int>> m(n,vector<int> (n,1));\\n\\n        for(auto i : mines)\\n        m[i[0]][i[1]]=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[i][j]==0) c=0;\\n                else c++;\\n                l[i][j]=c;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(m[i][j]==0) c=0;\\n                else c++;\\n                r[i][j]=c;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[j][i]==0) c=0;\\n                else c++;\\n                u[j][i]=c;\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(m[j][i]==0) c=0;\\n                else c++;\\n                d[j][i]=c;\\n            }\\n        }\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                a=max(a,min({l[i][j],r[i][j],u[i][j],d[i][j]}));\\n\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> l(n,vector<int> (n,0)),r=l,u=l,d=l;\\n        vector<vector<int>> m(n,vector<int> (n,1));\\n\\n        for(auto i : mines)\\n        m[i[0]][i[1]]=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[i][j]==0) c=0;\\n                else c++;\\n                l[i][j]=c;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(m[i][j]==0) c=0;\\n                else c++;\\n                r[i][j]=c;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[j][i]==0) c=0;\\n                else c++;\\n                u[j][i]=c;\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(m[j][i]==0) c=0;\\n                else c++;\\n                d[j][i]=c;\\n            }\\n        }\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                a=max(a,min({l[i][j],r[i][j],u[i][j],d[i][j]}));\\n\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878991,
                "title": "brute-force-solution-in-go",
                "content": "# Intuition\\nI often like to think of how I would approach a problem if I was asked to do it on paper.\\n\\n# Approach\\nIterate over the entire board, calculating the order for a plus sign at each cell. Once we have this list, we return the maximum from it.\\n\\nThis is a stupid approach, but it\\'s fast enough to meet the time constraints, and it\\'s easy to understand.\\n\\n# Complexity\\nLet\\'s call the size of the board $$n$$, which is a bit confusing because its size is the square of the `n` variable.\\n\\n- Time complexity:\\nWe iterate over the board, so that brings us up to $$O(n)$$ complexity. But for each cell, we could iterate as many times as $$\\\\frac{\\\\sqrt{n}}{2}-1$$ to check its neighbors. So, dropping the constants, this leads us to a total complexity of $$O(n^\\\\frac{3}{2})$$.\\n\\n- Space complexity:\\nWe never store more than the size of the board, which is $$O(n^2)$$.\\n\\n# Code\\n```\\n// Returns the largest value from a slice of integers\\nfunc maxInt(plus_sizes ...int) int {\\n  var max int\\n  for _, x := range plus_sizes {\\n    if x > max {\\n      max = x\\n    }\\n  }\\n  return max\\n}\\n\\n// Returns the size of the plus sign at board[i][j]\\nfunc getPlusSize(board [][]bool, i int, j int) int {\\n  // If the cell is a bomb, this plus size is actually zero\\n  if board[i][j] {\\n    return 0\\n  }\\n\\n  // The smallest plus sign is simply a single cell surrounded by bombs,\\n  // so we initialize k to its order, which is 1\\n  k := 1\\n\\n  // The nasty conditional here simply checks whether:\\n  // 1) The cells we\\'re about to look at are within bounds\\n  // 2) The values on all four sides are not bombs\\n  for i-k >= 0 && i+k < len(board) && j-k >= 0 && j+k < len(board) && !(board[i-k][j] || board[i+k][j] || board[i][j-k] || board[i][j+k]) {\\n    // Simply increase k as we extend the plus sign\\n    k++\\n  }\\n\\n  // And k is the final order\\n  return k\\n}\\n\\nfunc orderOfLargestPlusSign(n int, mines [][]int) int {\\n  // Initialize the board with false values\\n  board := make([][]bool, n)\\n  for i := range board {\\n    board[i] = make([]bool, n)\\n  }\\n\\n  // Place the mines on the board by flipping those cells to true\\n  for _, mine := range mines {\\n    board[mine[0]][mine[1]] = true\\n  }\\n\\n  // Generate the list of the sizes of every plus sign on the board\\n  var plus_sizes []int\\n  for i := 0; i < n; i++ {\\n    for j := 0; j < n; j++ {\\n      if !board[i][j] {\\n        plus_sizes = append(plus_sizes, getPlusSize(board, i, j))\\n      }\\n    }\\n  }\\n\\n  // Now return the largest one\\n  return maxInt(plus_sizes...)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Returns the largest value from a slice of integers\\nfunc maxInt(plus_sizes ...int) int {\\n  var max int\\n  for _, x := range plus_sizes {\\n    if x > max {\\n      max = x\\n    }\\n  }\\n  return max\\n}\\n\\n// Returns the size of the plus sign at board[i][j]\\nfunc getPlusSize(board [][]bool, i int, j int) int {\\n  // If the cell is a bomb, this plus size is actually zero\\n  if board[i][j] {\\n    return 0\\n  }\\n\\n  // The smallest plus sign is simply a single cell surrounded by bombs,\\n  // so we initialize k to its order, which is 1\\n  k := 1\\n\\n  // The nasty conditional here simply checks whether:\\n  // 1) The cells we\\'re about to look at are within bounds\\n  // 2) The values on all four sides are not bombs\\n  for i-k >= 0 && i+k < len(board) && j-k >= 0 && j+k < len(board) && !(board[i-k][j] || board[i+k][j] || board[i][j-k] || board[i][j+k]) {\\n    // Simply increase k as we extend the plus sign\\n    k++\\n  }\\n\\n  // And k is the final order\\n  return k\\n}\\n\\nfunc orderOfLargestPlusSign(n int, mines [][]int) int {\\n  // Initialize the board with false values\\n  board := make([][]bool, n)\\n  for i := range board {\\n    board[i] = make([]bool, n)\\n  }\\n\\n  // Place the mines on the board by flipping those cells to true\\n  for _, mine := range mines {\\n    board[mine[0]][mine[1]] = true\\n  }\\n\\n  // Generate the list of the sizes of every plus sign on the board\\n  var plus_sizes []int\\n  for i := 0; i < n; i++ {\\n    for j := 0; j < n; j++ {\\n      if !board[i][j] {\\n        plus_sizes = append(plus_sizes, getPlusSize(board, i, j))\\n      }\\n    }\\n  }\\n\\n  // Now return the largest one\\n  return maxInt(plus_sizes...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813031,
                "title": "easy-to-understand-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> ver(n,vector<int>(n,1e9));\\n        vector<vector<int>> hor(n,vector<int>(n,1e9));\\n        vector<vector<int>> mine(n,vector<int>(n,1));\\n        for(auto p : mines) mine[p[0]][p[1]] = 0;\\n        int mx = 0;\\n        for(int i = 0; i<n; i++){\\n            ver[0][i] = mine[0][i];\\n            hor[i][0] = mine[i][0];\\n            ver[n-1][i] = mine[n-1][i];\\n            hor[i][n-1] = mine[i][n-1];\\n        }\\n        \\n        for(int i = 1; i<n-1; i++){\\n            for(int j = 1; j<n-1; j++){\\n                ver[i][j] = min(ver[i][j],mine[i][j]*(1+ver[i-1][j]));\\n                hor[j][i] = min(hor[j][i],mine[j][i]*(1+hor[j][i-1]));\\n                ver[n-i-1][j] = min(ver[n-i-1][j],mine[n-i-1][j]*(1+ver[n-i][j]));\\n                hor[j][n-i-1] = min(hor[j][n-i-1],mine[j][n-i-1]*(1+hor[j][n-i]));\\n            }\\n        }\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                int temp = min(hor[i][j],ver[i][j]);\\n                mx = max(mx,temp);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> ver(n,vector<int>(n,1e9));\\n        vector<vector<int>> hor(n,vector<int>(n,1e9));\\n        vector<vector<int>> mine(n,vector<int>(n,1));\\n        for(auto p : mines) mine[p[0]][p[1]] = 0;\\n        int mx = 0;\\n        for(int i = 0; i<n; i++){\\n            ver[0][i] = mine[0][i];\\n            hor[i][0] = mine[i][0];\\n            ver[n-1][i] = mine[n-1][i];\\n            hor[i][n-1] = mine[i][n-1];\\n        }\\n        \\n        for(int i = 1; i<n-1; i++){\\n            for(int j = 1; j<n-1; j++){\\n                ver[i][j] = min(ver[i][j],mine[i][j]*(1+ver[i-1][j]));\\n                hor[j][i] = min(hor[j][i],mine[j][i]*(1+hor[j][i-1]));\\n                ver[n-i-1][j] = min(ver[n-i-1][j],mine[n-i-1][j]*(1+ver[n-i][j]));\\n                hor[j][n-i-1] = min(hor[j][n-i-1],mine[j][n-i-1]*(1+hor[j][n-i]));\\n            }\\n        }\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                int temp = min(hor[i][j],ver[i][j]);\\n                mx = max(mx,temp);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738407,
                "title": "largest-plus-sign",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} mines\\n * @return {number}\\n */\\nvar orderOfLargestPlusSign = function(n, mines) {\\n     const grid = Array.from({ length: n }, () => Array(n).fill(1));\\n  for (const [x, y] of mines) {\\n    grid[x][y] = 0;\\n  }\\n  \\n  // Create matrices to store the left, right, up, and down counts of consecutive 1\\'s\\n  const left = Array.from({ length: n }, () => Array(n).fill(0));\\n  const right = Array.from({ length: n }, () => Array(n).fill(0));\\n  const up = Array.from({ length: n }, () => Array(n).fill(0));\\n  const down = Array.from({ length: n }, () => Array(n).fill(0));\\n\\n  // Calculate left and up counts\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        left[i][j] = (j > 0) ? left[i][j - 1] + 1 : 1;\\n        up[i][j] = (i > 0) ? up[i - 1][j] + 1 : 1;\\n      }\\n    }\\n  }\\n\\n  // Calculate right and down counts\\n  for (let i = n - 1; i >= 0; i--) {\\n    for (let j = n - 1; j >= 0; j--) {\\n      if (grid[i][j] === 1) {\\n        right[i][j] = (j < n - 1) ? right[i][j + 1] + 1 : 1;\\n        down[i][j] = (i < n - 1) ? down[i + 1][j] + 1 : 1;\\n      }\\n    }\\n  }\\n\\n  let maxOrder = 0;\\n\\n  // Find the maximum order of plus sign\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        const order = Math.min(left[i][j], right[i][j], up[i][j], down[i][j]);\\n        maxOrder = Math.max(maxOrder, order);\\n      }\\n    }\\n  }\\n\\n  return maxOrder;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} mines\\n * @return {number}\\n */\\nvar orderOfLargestPlusSign = function(n, mines) {\\n     const grid = Array.from({ length: n }, () => Array(n).fill(1));\\n  for (const [x, y] of mines) {\\n    grid[x][y] = 0;\\n  }\\n  \\n  // Create matrices to store the left, right, up, and down counts of consecutive 1\\'s\\n  const left = Array.from({ length: n }, () => Array(n).fill(0));\\n  const right = Array.from({ length: n }, () => Array(n).fill(0));\\n  const up = Array.from({ length: n }, () => Array(n).fill(0));\\n  const down = Array.from({ length: n }, () => Array(n).fill(0));\\n\\n  // Calculate left and up counts\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        left[i][j] = (j > 0) ? left[i][j - 1] + 1 : 1;\\n        up[i][j] = (i > 0) ? up[i - 1][j] + 1 : 1;\\n      }\\n    }\\n  }\\n\\n  // Calculate right and down counts\\n  for (let i = n - 1; i >= 0; i--) {\\n    for (let j = n - 1; j >= 0; j--) {\\n      if (grid[i][j] === 1) {\\n        right[i][j] = (j < n - 1) ? right[i][j + 1] + 1 : 1;\\n        down[i][j] = (i < n - 1) ? down[i + 1][j] + 1 : 1;\\n      }\\n    }\\n  }\\n\\n  let maxOrder = 0;\\n\\n  // Find the maximum order of plus sign\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        const order = Math.min(left[i][j], right[i][j], up[i][j], down[i][j]);\\n        maxOrder = Math.max(maxOrder, order);\\n      }\\n    }\\n  }\\n\\n  return maxOrder;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3727186,
                "title": "c-iterative-solution-easy-method",
                "content": "\\n# Approach\\nFirst for each cell, find out the longest left , up  , down and right length which has 1s continuously.\\n\\nNow just iterate through the grid and update the max var as\\n`mx = max(mx, min{upij, dwij, ltij, rtij})`\\nsubscript i denotes ijth cell\\n\\n# Complexity\\n- Time complexity:$$O(5N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(5N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        // int n = n;\\n\\n        vector<vector<int>> m1(n+1, vector<int>(n+1,1));\\n        vector<vector<int>> up(n+1, vector<int>(n+1, 0));\\n        vector<vector<int>> dw(n+1, vector<int>(n+1, 0));\\n        vector<vector<int>> lt(n+1, vector<int>(n+1, 0));\\n        vector<vector<int>> rt(n+1, vector<int>(n+1, 0));\\n        // int mx = 0;\\n\\n        for(int i=0;i<mines.size();i++){\\n            int  x = mines[i][0];\\n            int y = mines[i][1];\\n            m1[x][y]  = 0;\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout << m1[0][i] << \" \";\\n        // }\\n\\n        for(int i=0;i<n;i++){\\n            if(m1[0][i] == 1)   up[0][i] = 1;\\n            else up[0][i] = 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(m1[i][0] == 1)   lt[i][0] = 1;\\n            else lt[i][0] = 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(m1[n-1][i] == 1)   dw[n-1][i] = 1;\\n            else dw[n-1][i] = 0;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(m1[i][n-1] == 1)   rt[i][n-1] = 1;\\n            else rt[i][n-1] = 0;\\n        }\\n\\n        for(int i=1;i<=n-1;i++){\\n            for(int j =0;j<=n-1;j++){\\n                if(m1[i][j] == 0){\\n                    up[i][j] = 0;\\n                }\\n                else{\\n                    up[i][j] = 1 + up[i-1][j];\\n                }\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j =n-1;j>=0;j--){\\n                if(m1[i][j] == 0){\\n                    dw[i][j] = 0;\\n                }\\n                else{\\n                    dw[i][j] = 1 + dw[i+1][j];\\n                }\\n            }\\n        }\\n\\n\\n        for(int i=1;i<=n-1;i++){\\n            for(int j=0;j<=n-1;j++){\\n                if(m1[j][i] == 0){\\n                    lt[j][i] = 0;\\n\\n                }\\n                else{\\n                    lt[j][i] = 1 + lt[j][i-1];\\n                }\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(m1[j][i] == 0){\\n                    rt[j][i] = 0;\\n\\n                }\\n                else{\\n                    rt[j][i] = 1 + rt[j][i+1];\\n                }\\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                mx = max(mx, min({up[i][j], dw[i][j], lt[i][j], rt[i][j]}));\\n            }\\n        }\\n\\n        //init \\n\\n        return mx;\\n\\n\\n       \\n\\n    }\\n};\\n```\\n\\n\\nPLEASE UPVOTE IF THIS WAS HELPFUL\\n![11.jpg](https://assets.leetcode.com/users/images/b1e31e3d-695b-42ad-a065-7925ebdcfc05_1688645570.3668563.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        // int n = n;\\n\\n        vector<vector<int>> m1(n+1, vector<int>(n+1,1));\\n        vector<vector<int>> up(n+1, vector<int>(n+1, 0));\\n        vector<vector<int>> dw(n+1, vector<int>(n+1, 0));\\n        vector<vector<int>> lt(n+1, vector<int>(n+1, 0));\\n        vector<vector<int>> rt(n+1, vector<int>(n+1, 0));\\n        // int mx = 0;\\n\\n        for(int i=0;i<mines.size();i++){\\n            int  x = mines[i][0];\\n            int y = mines[i][1];\\n            m1[x][y]  = 0;\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout << m1[0][i] << \" \";\\n        // }\\n\\n        for(int i=0;i<n;i++){\\n            if(m1[0][i] == 1)   up[0][i] = 1;\\n            else up[0][i] = 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(m1[i][0] == 1)   lt[i][0] = 1;\\n            else lt[i][0] = 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(m1[n-1][i] == 1)   dw[n-1][i] = 1;\\n            else dw[n-1][i] = 0;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(m1[i][n-1] == 1)   rt[i][n-1] = 1;\\n            else rt[i][n-1] = 0;\\n        }\\n\\n        for(int i=1;i<=n-1;i++){\\n            for(int j =0;j<=n-1;j++){\\n                if(m1[i][j] == 0){\\n                    up[i][j] = 0;\\n                }\\n                else{\\n                    up[i][j] = 1 + up[i-1][j];\\n                }\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j =n-1;j>=0;j--){\\n                if(m1[i][j] == 0){\\n                    dw[i][j] = 0;\\n                }\\n                else{\\n                    dw[i][j] = 1 + dw[i+1][j];\\n                }\\n            }\\n        }\\n\\n\\n        for(int i=1;i<=n-1;i++){\\n            for(int j=0;j<=n-1;j++){\\n                if(m1[j][i] == 0){\\n                    lt[j][i] = 0;\\n\\n                }\\n                else{\\n                    lt[j][i] = 1 + lt[j][i-1];\\n                }\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(m1[j][i] == 0){\\n                    rt[j][i] = 0;\\n\\n                }\\n                else{\\n                    rt[j][i] = 1 + rt[j][i+1];\\n                }\\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                mx = max(mx, min({up[i][j], dw[i][j], lt[i][j], rt[i][j]}));\\n            }\\n        }\\n\\n        //init \\n\\n        return mx;\\n\\n\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3722924,
                "title": "java-13ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // count of 1 from left in same row\\n    private short[][] rowDP;\\n    // count of 1 from up in same column\\n    private short[][] colDP;\\n\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        // `mines` array contains unique points.\\n        // If its length equals n * n, it means all points are zero.\\n        if (mines.length == n * n) {\\n            return 0;\\n        }\\n\\n        rowDP = new short[n][n];\\n        colDP = new short[n][n];\\n\\n        for (int[] points : mines) {\\n            // For zero points, set their value to -1, such the next element will have dp count as 0\\n            rowDP[points[0]][points[1]] = -1;\\n            colDP[points[0]][points[1]] = -1;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (rowDP[i][j] != -1) {\\n                    rowDP[i][j] = (short) (rowDP[i][j - 1] + 1);\\n                    colDP[i][j] = (short) (colDP[i - 1][j] + 1);\\n                }\\n            }\\n        }\\n\\n        int arm = 0;\\n        int low = 1, high = (n - 1) / 2, middle;\\n\\n        // Binary search\\n        while (low <= high) {\\n            middle = (low + high) / 2;\\n            if (search(middle, n)) {\\n                arm = middle;\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n\\n        // order is arm length + 1\\n        return arm + 1;\\n    }\\n\\n    private boolean search(int arm, int n) {\\n        int bound = n - arm;\\n\\n        for (int i = arm; i < bound; i++) {\\n            for (int j = arm; j < bound; j++) {\\n                if (rowDP[i][j] >= arm\\n                    && colDP[i][j] >= arm\\n                    && rowDP[i][j + arm] - rowDP[i][j] >= arm\\n                    && colDP[i + arm][j] - colDP[i][j] >= arm) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    // count of 1 from left in same row\\n    private short[][] rowDP;\\n    // count of 1 from up in same column\\n    private short[][] colDP;\\n\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        // `mines` array contains unique points.\\n        // If its length equals n * n, it means all points are zero.\\n        if (mines.length == n * n) {\\n            return 0;\\n        }\\n\\n        rowDP = new short[n][n];\\n        colDP = new short[n][n];\\n\\n        for (int[] points : mines) {\\n            // For zero points, set their value to -1, such the next element will have dp count as 0\\n            rowDP[points[0]][points[1]] = -1;\\n            colDP[points[0]][points[1]] = -1;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (rowDP[i][j] != -1) {\\n                    rowDP[i][j] = (short) (rowDP[i][j - 1] + 1);\\n                    colDP[i][j] = (short) (colDP[i - 1][j] + 1);\\n                }\\n            }\\n        }\\n\\n        int arm = 0;\\n        int low = 1, high = (n - 1) / 2, middle;\\n\\n        // Binary search\\n        while (low <= high) {\\n            middle = (low + high) / 2;\\n            if (search(middle, n)) {\\n                arm = middle;\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n\\n        // order is arm length + 1\\n        return arm + 1;\\n    }\\n\\n    private boolean search(int arm, int n) {\\n        int bound = n - arm;\\n\\n        for (int i = arm; i < bound; i++) {\\n            for (int j = arm; j < bound; j++) {\\n                if (rowDP[i][j] >= arm\\n                    && colDP[i][j] >= arm\\n                    && rowDP[i][j + arm] - rowDP[i][j] >= arm\\n                    && colDP[i + arm][j] - colDP[i][j] >= arm) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682824,
                "title": "python-prefix-sum-binary-search",
                "content": "```py\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        \\n        row = defaultdict(list)\\n        col = defaultdict(list)\\n        mines.sort()\\n        idx = 0\\n        for i in range(n):\\n            for j in range(n):\\n                \\n                if idx < len(mines) and [i,j] == mines[idx]:\\n                    if len(row[i]) == 0:\\n                        row[i].append(0)\\n                        row[i].append(0)\\n                    else:\\n                        row[i].append(row[i][-1] + 0)\\n                    if len(col[j]) == 0:\\n                        col[j].append(0)\\n                        col[j].append(0)\\n                    else:    \\n                        col[j].append(col[j][-1] + 0)\\n                \\n                    idx +=1\\n                else:\\n                    if len(row[i]) == 0:\\n                        row[i].append(0)\\n                        row[i].append(1)\\n                    else:\\n                        row[i].append(row[i][-1] + 1)\\n                    if len(col[j]) == 0:\\n                        col[j].append(0)\\n                        col[j].append(1)\\n                    else:    \\n                        col[j].append(col[j][-1] + 1)\\n        \\n        \\n        def isGood(target):\\n            \\n            for i in range(target-1, n-target+1):\\n                for j in range(target-1, n-target+1):\\n                    \\n                    #check 4 prefix\\n                    up = abs(col[j][i+1] - col[j][(i+1)-target]) == target\\n                    down = abs(col[j][i] - col[j][i+target]) == target\\n                    left = abs(row[i][j+1] - row[i][(j+1)-target]) == target\\n                    right = abs(row[i][j] - row[i][j+target]) == target\\n                    \\n                    if up and down and left and right:\\n                        return True\\n                    \\n            \\n            return False\\n        \\n        l,r = 1, math.ceil(n/2)\\n        res = 0\\n        while l <= r:\\n            \\n            mid = (l + r) // 2\\n            \\n            if isGood(mid):\\n                res = mid\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n                \\n        \\n        return res\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```py\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        \\n        row = defaultdict(list)\\n        col = defaultdict(list)\\n        mines.sort()\\n        idx = 0\\n        for i in range(n):\\n            for j in range(n):\\n                \\n                if idx < len(mines) and [i,j] == mines[idx]:\\n                    if len(row[i]) == 0:\\n                        row[i].append(0)\\n                        row[i].append(0)\\n                    else:\\n                        row[i].append(row[i][-1] + 0)\\n                    if len(col[j]) == 0:\\n                        col[j].append(0)\\n                        col[j].append(0)\\n                    else:    \\n                        col[j].append(col[j][-1] + 0)\\n                \\n                    idx +=1\\n                else:\\n                    if len(row[i]) == 0:\\n                        row[i].append(0)\\n                        row[i].append(1)\\n                    else:\\n                        row[i].append(row[i][-1] + 1)\\n                    if len(col[j]) == 0:\\n                        col[j].append(0)\\n                        col[j].append(1)\\n                    else:    \\n                        col[j].append(col[j][-1] + 1)\\n        \\n        \\n        def isGood(target):\\n            \\n            for i in range(target-1, n-target+1):\\n                for j in range(target-1, n-target+1):\\n                    \\n                    #check 4 prefix\\n                    up = abs(col[j][i+1] - col[j][(i+1)-target]) == target\\n                    down = abs(col[j][i] - col[j][i+target]) == target\\n                    left = abs(row[i][j+1] - row[i][(j+1)-target]) == target\\n                    right = abs(row[i][j] - row[i][j+target]) == target\\n                    \\n                    if up and down and left and right:\\n                        return True\\n                    \\n            \\n            return False\\n        \\n        l,r = 1, math.ceil(n/2)\\n        res = 0\\n        while l <= r:\\n            \\n            mid = (l + r) // 2\\n            \\n            if isGood(mid):\\n                res = mid\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n                \\n        \\n        return res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3598616,
                "title": "c-dp-o-n-2-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nint max(int a, int b){\\n    return a > b ? a : b;\\n}\\n\\nint min(int a, int b){\\n    return a > b ? b : a;\\n}\\n\\nint orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    // edge case:\\n    if(n * n == minesSize)\\n        return 0;\\n\\n    int mat[n][n][5];\\n    memset(mat, 0, n*n*5*sizeof(int));\\n    for(int i = 0; i < minesSize; i++){\\n        mat[mines[i][0]][mines[i][1]][0] = 1;\\n    }\\n    // base case for dp table\\n    for(int i = 0; i < n; i++){\\n        if(!mat[0][i][0]) //up\\n            mat[0][i][1]++;\\n        if(!mat[i][0][0]) // left\\n            mat[i][0][4]++;\\n        if(!mat[i][n - 1][0]) // right\\n            mat[i][n - 1][2]++;\\n        if(!mat[n - 1][i][0]) // down\\n            mat[n - 1][i][3]++;\\n    }\\n\\n    int k = 1;\\n    for(int r = 1; r < n - 1; r++){\\n        for(int c = 1; c < n - 1; c++){\\n            if(!mat[r][c][0]){\\n                mat[r][c][1] = mat[r][c][4] = 1;\\n                mat[r][c][1] += mat[r - 1][c][1]; //up\\n                mat[r][c][4] += mat[r][c - 1][4]; //left\\n            }\\n        }   \\n    }\\n    for(int r = n - 2; r > 0; r--){\\n        for(int c = n - 2; c > 0; c--){\\n            if(!mat[r][c][0]){\\n                mat[r][c][2] = mat[r][c][3] = 1;\\n                mat[r][c][2] += mat[r][c + 1][2]; // right\\n                mat[r][c][3] += mat[r + 1][c][3]; // down\\n                k = max(k, min(mat[r][c][1], min(mat[r][c][4], min(mat[r][c][2], mat[r][c][3]))));\\n            }\\n        }\\n    }\\n\\n    return k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint max(int a, int b){\\n    return a > b ? a : b;\\n}\\n\\nint min(int a, int b){\\n    return a > b ? b : a;\\n}\\n\\nint orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    // edge case:\\n    if(n * n == minesSize)\\n        return 0;\\n\\n    int mat[n][n][5];\\n    memset(mat, 0, n*n*5*sizeof(int));\\n    for(int i = 0; i < minesSize; i++){\\n        mat[mines[i][0]][mines[i][1]][0] = 1;\\n    }\\n    // base case for dp table\\n    for(int i = 0; i < n; i++){\\n        if(!mat[0][i][0]) //up\\n            mat[0][i][1]++;\\n        if(!mat[i][0][0]) // left\\n            mat[i][0][4]++;\\n        if(!mat[i][n - 1][0]) // right\\n            mat[i][n - 1][2]++;\\n        if(!mat[n - 1][i][0]) // down\\n            mat[n - 1][i][3]++;\\n    }\\n\\n    int k = 1;\\n    for(int r = 1; r < n - 1; r++){\\n        for(int c = 1; c < n - 1; c++){\\n            if(!mat[r][c][0]){\\n                mat[r][c][1] = mat[r][c][4] = 1;\\n                mat[r][c][1] += mat[r - 1][c][1]; //up\\n                mat[r][c][4] += mat[r][c - 1][4]; //left\\n            }\\n        }   \\n    }\\n    for(int r = n - 2; r > 0; r--){\\n        for(int c = n - 2; c > 0; c--){\\n            if(!mat[r][c][0]){\\n                mat[r][c][2] = mat[r][c][3] = 1;\\n                mat[r][c][2] += mat[r][c + 1][2]; // right\\n                mat[r][c][3] += mat[r + 1][c][3]; // down\\n                k = max(k, min(mat[r][c][1], min(mat[r][c][4], min(mat[r][c][2], mat[r][c][3]))));\\n            }\\n        }\\n    }\\n\\n    return k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577481,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> mat(n,vector<int>(n,1));\\n        vector<vector<int>> left(n,vector<int>(n,0));\\n        vector<vector<int>> right(n,vector<int>(n,0));\\n        vector<vector<int>> up(n,vector<int>(n,0));\\n        vector<vector<int>> down(n,vector<int>(n,0));\\n        for(int i=0; i<mines.size(); i++){\\n            mat[mines[i][0]][mines[i][1]] = 0;\\n        }\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    left[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    left[i][j] = cnt;\\n                }\\n            }\\n        }\\n        \\n        for(int j=0; j<n; j++){\\n            int cnt = 0;\\n            for(int i=0; i<n; i++){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    up[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    up[i][j] = cnt;\\n                }\\n            }\\n        }\\n\\n        for(int i=n-1; i>=0; i--){\\n            int cnt = 0;\\n            for(int j=n-1; j>=0; j--){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    right[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    right[i][j] = cnt;\\n                }\\n            }\\n        }\\n        for(int j=0; j<n; j++){\\n            int cnt = 0;\\n            for(int i=n-1; i>=0; i--){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    down[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    down[i][j] = cnt;\\n                }\\n            }\\n        }\\n        bool flag = false;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]==1){\\n                    flag = true;\\n                    int mini = min(left[i][j],min(right[i][j],min(up[i][j],down[i][j])));\\n                    ans = max(ans,mini);\\n                }\\n            }\\n        }\\n        if(flag){\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> mat(n,vector<int>(n,1));\\n        vector<vector<int>> left(n,vector<int>(n,0));\\n        vector<vector<int>> right(n,vector<int>(n,0));\\n        vector<vector<int>> up(n,vector<int>(n,0));\\n        vector<vector<int>> down(n,vector<int>(n,0));\\n        for(int i=0; i<mines.size(); i++){\\n            mat[mines[i][0]][mines[i][1]] = 0;\\n        }\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    left[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    left[i][j] = cnt;\\n                }\\n            }\\n        }\\n        \\n        for(int j=0; j<n; j++){\\n            int cnt = 0;\\n            for(int i=0; i<n; i++){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    up[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    up[i][j] = cnt;\\n                }\\n            }\\n        }\\n\\n        for(int i=n-1; i>=0; i--){\\n            int cnt = 0;\\n            for(int j=n-1; j>=0; j--){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    right[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    right[i][j] = cnt;\\n                }\\n            }\\n        }\\n        for(int j=0; j<n; j++){\\n            int cnt = 0;\\n            for(int i=n-1; i>=0; i--){\\n                if(mat[i][j]==1){\\n                    cnt++;\\n                    down[i][j] = cnt;\\n                }\\n                else{\\n                    cnt = 0;\\n                    down[i][j] = cnt;\\n                }\\n            }\\n        }\\n        bool flag = false;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]==1){\\n                    flag = true;\\n                    int mini = min(left[i][j],min(right[i][j],min(up[i][j],down[i][j])));\\n                    ans = max(ans,mini);\\n                }\\n            }\\n        }\\n        if(flag){\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547317,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        Set<Integer> minesLocations = new HashSet(); \\n        for (int[] mine : mines) minesLocations.add(501*mine[0]+mine[1]);\\n        int max = 0;\\n        int [][][] arms = new int [n][n][4]; // left , up , right ,down\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<n; j++){\\n                if (!minesLocations.contains(501*i+j)){\\n                    if (j==0) arms[i][j][0] = 1;\\n                    else  arms[i][j][0] = 1 + arms[i][j-1][0];\\n                    if (i==0) arms[i][j][1] = 1;\\n                    else arms[i][j][1] = 1 + arms[i-1][j][1];\\n                }\\n            }\\n        }\\n\\n        for (int i=n-1; i>=0; i--){\\n            for (int j=n-1 ; j>=0; j--){\\n                if (!minesLocations.contains(501*i+j)){\\n                    if (j==n-1) arms[i][j][2] = 1;\\n                    else  arms[i][j][2] = 1 + arms[i][j+1][2];\\n                    if (i==n-1) arms[i][j][3] = 1;\\n                    else arms[i][j][3] = 1 + arms[i+1][j][3];\\n\\n                    int curPlus = Math.min(Math.min(Math.min(arms[i][j][0],arms[i][j][1]),arms[i][j][2]),arms[i][j][3]);\\n                    max = Math.max(curPlus,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        Set<Integer> minesLocations = new HashSet(); \\n        for (int[] mine : mines) minesLocations.add(501*mine[0]+mine[1]);\\n        int max = 0;\\n        int [][][] arms = new int [n][n][4]; // left , up , right ,down\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<n; j++){\\n                if (!minesLocations.contains(501*i+j)){\\n                    if (j==0) arms[i][j][0] = 1;\\n                    else  arms[i][j][0] = 1 + arms[i][j-1][0];\\n                    if (i==0) arms[i][j][1] = 1;\\n                    else arms[i][j][1] = 1 + arms[i-1][j][1];\\n                }\\n            }\\n        }\\n\\n        for (int i=n-1; i>=0; i--){\\n            for (int j=n-1 ; j>=0; j--){\\n                if (!minesLocations.contains(501*i+j)){\\n                    if (j==n-1) arms[i][j][2] = 1;\\n                    else  arms[i][j][2] = 1 + arms[i][j+1][2];\\n                    if (i==n-1) arms[i][j][3] = 1;\\n                    else arms[i][j][3] = 1 + arms[i+1][j][3];\\n\\n                    int curPlus = Math.min(Math.min(Math.min(arms[i][j][0],arms[i][j][1]),arms[i][j][2]),arms[i][j][3]);\\n                    max = Math.max(curPlus,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544702,
                "title": "c-recursion-memoization-story",
                "content": "we have selected 4 directions to move from a single point where 1 occurs, from there we move in all 4 directions and then take the minimum number of 1\\'s amongst all the 4 directions,. and for every step it\\'s max it the answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int dp[501][501][4];\\n    int ans(int i,int j,int k,vector<vector<int>> &grid){\\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n        int n=grid.size();\\n        int ni=i+dir[k][0];\\n        int nj=j+dir[k][1];\\n\\n        if(ni<0 || nj<0 || ni>=n || nj>=n || grid[ni][nj]==0)return 0;\\n        return dp[i][j][k]=1+ans(ni,nj,k,grid);\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n,vector<int>(n,1));\\n        for(int i=0;i<mines.size();i++){\\n            grid[mines[i][0]][mines[i][1]]=0;\\n        }\\n        int ans1=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1)\\n                    ans1=max(ans1,1+min({ans(i,j,0,grid),ans(i,j,1,grid),ans(i,j,2,grid),ans(i,j,3,grid)}));\\n            }\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int dp[501][501][4];\\n    int ans(int i,int j,int k,vector<vector<int>> &grid){\\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n        int n=grid.size();\\n        int ni=i+dir[k][0];\\n        int nj=j+dir[k][1];\\n\\n        if(ni<0 || nj<0 || ni>=n || nj>=n || grid[ni][nj]==0)return 0;\\n        return dp[i][j][k]=1+ans(ni,nj,k,grid);\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n,vector<int>(n,1));\\n        for(int i=0;i<mines.size();i++){\\n            grid[mines[i][0]][mines[i][1]]=0;\\n        }\\n        int ans1=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1)\\n                    ans1=max(ans1,1+min({ans(i,j,0,grid),ans(i,j,1,grid),ans(i,j,2,grid),ans(i,j,3,grid)}));\\n            }\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464905,
                "title": "rust-beats-100",
                "content": "# Approach\\n1. For each possible plus center, start with maximum order of `n`\\n2. Find all horizontal segments of `1\\'s` and use them to filter possible sizes of pluses (the order of a sign can\\'t be greater than the distance to the closest `0`, i.e. the endpoint of a segment, containing the center)\\n3. The same for vertical segments\\n4. Return the maximum order\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn fill_mines_grid(n: usize, mines: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut mines_grid: Vec<bool> = vec![];\\n        mines_grid.resize((n * n) as usize, false);\\n        for mine in mines {\\n            mines_grid[(mine[0] * n as i32 + mine[1]) as usize] = true;\\n        }\\n        mines_grid\\n    }\\n\\n    pub fn fill_orders_grid(n: usize) -> Vec<i32> {\\n        let mut orders_grid: Vec<i32> = vec![];\\n        orders_grid.resize(n * n, n as i32);\\n        orders_grid\\n    }\\n\\n    pub fn order_of_largest_plus_sign(n: i32, mines: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mines_grid = Solution::fill_mines_grid(n, mines);\\n        let mut orders_grid = Solution::fill_orders_grid(n);\\n\\n        // for each line:\\n        // - find segments containing only 1s\\n        // - use segment endpoints to filter possible orders of all crosses with centers inside the segment\\n        for y in 0..n {\\n            let mut start = 0;\\n            while start < n {\\n                // find segment containing only 1s\\n                while start < n && mines_grid[y * n + start] {\\n                    orders_grid[y * n + start] = 0;\\n                    start += 1;\\n                }\\n                if start == n {\\n                    break;\\n                }\\n                let mut end = start + 1;\\n                while end < n && !mines_grid[(y * n + end) as usize] {\\n                    end += 1;\\n                }\\n\\n                for x in start..(start + end) / 2 {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((x - start + 1) as i32);\\n                }\\n\\n                for x in (start + end) / 2..end {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((end - x) as i32);\\n                }\\n\\n                start = end;\\n            }\\n        }\\n\\n        // the same for vertical lines\\n        for x in 0..n {\\n            let mut start = 0;\\n            while start < n {\\n                while start < n && mines_grid[(start * n + x) as usize] {\\n                    start += 1;\\n                }\\n                if start == n {\\n                    break;\\n                }\\n                let mut end = start + 1;\\n                while end < n && !mines_grid[(end * n + x) as usize] {\\n                    end += 1;\\n                }\\n\\n                for y in start..(start + end) / 2 {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((y - start + 1) as i32);\\n                }\\n\\n                for y in (start + end) / 2..end {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((end - y) as i32);\\n                }\\n\\n                start = end;\\n            }\\n        }\\n\\n        orders_grid.iter().max().unwrap().clone()\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn fill_mines_grid(n: usize, mines: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut mines_grid: Vec<bool> = vec![];\\n        mines_grid.resize((n * n) as usize, false);\\n        for mine in mines {\\n            mines_grid[(mine[0] * n as i32 + mine[1]) as usize] = true;\\n        }\\n        mines_grid\\n    }\\n\\n    pub fn fill_orders_grid(n: usize) -> Vec<i32> {\\n        let mut orders_grid: Vec<i32> = vec![];\\n        orders_grid.resize(n * n, n as i32);\\n        orders_grid\\n    }\\n\\n    pub fn order_of_largest_plus_sign(n: i32, mines: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mines_grid = Solution::fill_mines_grid(n, mines);\\n        let mut orders_grid = Solution::fill_orders_grid(n);\\n\\n        // for each line:\\n        // - find segments containing only 1s\\n        // - use segment endpoints to filter possible orders of all crosses with centers inside the segment\\n        for y in 0..n {\\n            let mut start = 0;\\n            while start < n {\\n                // find segment containing only 1s\\n                while start < n && mines_grid[y * n + start] {\\n                    orders_grid[y * n + start] = 0;\\n                    start += 1;\\n                }\\n                if start == n {\\n                    break;\\n                }\\n                let mut end = start + 1;\\n                while end < n && !mines_grid[(y * n + end) as usize] {\\n                    end += 1;\\n                }\\n\\n                for x in start..(start + end) / 2 {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((x - start + 1) as i32);\\n                }\\n\\n                for x in (start + end) / 2..end {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((end - x) as i32);\\n                }\\n\\n                start = end;\\n            }\\n        }\\n\\n        // the same for vertical lines\\n        for x in 0..n {\\n            let mut start = 0;\\n            while start < n {\\n                while start < n && mines_grid[(start * n + x) as usize] {\\n                    start += 1;\\n                }\\n                if start == n {\\n                    break;\\n                }\\n                let mut end = start + 1;\\n                while end < n && !mines_grid[(end * n + x) as usize] {\\n                    end += 1;\\n                }\\n\\n                for y in start..(start + end) / 2 {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((y - start + 1) as i32);\\n                }\\n\\n                for y in (start + end) / 2..end {\\n                    let order = &mut orders_grid[(y * n + x) as usize];\\n                    *order = (*order).min((end - y) as i32);\\n                }\\n\\n                start = end;\\n            }\\n        }\\n\\n        orders_grid.iter().max().unwrap().clone()\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3402140,
                "title": "c-faster-than-95-99-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int res = 0;\\n        vector<vector<int>> matrix(n, vector<int>(n, 1));\\n        for (const vector<int>& v : mines) matrix[v[0]][v[1]] = 0;\\n        for (int i = 0; i < n; ++ i) {\\n            int l = -1;\\n            for (int j = 0; j < n; ++ j) {\\n                if (matrix[i][j] == 0) {\\n                    if (j + l < 0) {\\n                        l = j;\\n                        continue;\\n                    }\\n                    int mid = (j + l) / 2;\\n                    for (int k = l + 1; k <= mid; ++ k) matrix[i][k] = k - l;\\n                    for (int k = mid + 1; k < j; ++ k) matrix[i][k] = j - k;\\n                    l = j;\\n                }\\n            }\\n            int mid = (n + l) / 2;\\n            for (int k = l + 1; k <= mid; ++ k) matrix[i][k] = k - l;\\n            for (int k = mid + 1; k < n; ++ k) matrix[i][k] = n - k;\\n        }\\n        for (int i = 0; i < n; ++ i) {\\n            int l = -1;\\n            for (int j = 0; j < n; ++ j) {\\n                if (matrix[j][i] == 0) {\\n                    if (j + l < 0) {\\n                        l = j;\\n                        continue;\\n                    }\\n                    int mid = (j + l) / 2;\\n                    for (int k = l + 1; k <= mid; ++ k) {\\n                        matrix[k][i] = min(k - l, matrix[k][i]);\\n                        res = max(res, matrix[k][i]);\\n                    }\\n                    for (int k = mid + 1; k < j; ++ k) {\\n                        matrix[k][i] = min(j - k, matrix[k][i]);\\n                        res = max(res, matrix[k][i]);\\n                    }\\n                    l = j;\\n                }\\n            }\\n            int mid = (n + l) / 2;\\n            for (int k = l + 1; k <= mid; ++ k) {\\n                matrix[k][i] = min(k - l, matrix[k][i]);\\n                res = max(res, matrix[k][i]);\\n            }\\n            for (int k = mid + 1; k < n; ++ k) {\\n                matrix[k][i] = min(n - k, matrix[k][i]);\\n                res = max(res, matrix[k][i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int res = 0;\\n        vector<vector<int>> matrix(n, vector<int>(n, 1));\\n        for (const vector<int>& v : mines) matrix[v[0]][v[1]] = 0;\\n        for (int i = 0; i < n; ++ i) {\\n            int l = -1;\\n            for (int j = 0; j < n; ++ j) {\\n                if (matrix[i][j] == 0) {\\n                    if (j + l < 0) {\\n                        l = j;\\n                        continue;\\n                    }\\n                    int mid = (j + l) / 2;\\n                    for (int k = l + 1; k <= mid; ++ k) matrix[i][k] = k - l;\\n                    for (int k = mid + 1; k < j; ++ k) matrix[i][k] = j - k;\\n                    l = j;\\n                }\\n            }\\n            int mid = (n + l) / 2;\\n            for (int k = l + 1; k <= mid; ++ k) matrix[i][k] = k - l;\\n            for (int k = mid + 1; k < n; ++ k) matrix[i][k] = n - k;\\n        }\\n        for (int i = 0; i < n; ++ i) {\\n            int l = -1;\\n            for (int j = 0; j < n; ++ j) {\\n                if (matrix[j][i] == 0) {\\n                    if (j + l < 0) {\\n                        l = j;\\n                        continue;\\n                    }\\n                    int mid = (j + l) / 2;\\n                    for (int k = l + 1; k <= mid; ++ k) {\\n                        matrix[k][i] = min(k - l, matrix[k][i]);\\n                        res = max(res, matrix[k][i]);\\n                    }\\n                    for (int k = mid + 1; k < j; ++ k) {\\n                        matrix[k][i] = min(j - k, matrix[k][i]);\\n                        res = max(res, matrix[k][i]);\\n                    }\\n                    l = j;\\n                }\\n            }\\n            int mid = (n + l) / 2;\\n            for (int k = l + 1; k <= mid; ++ k) {\\n                matrix[k][i] = min(k - l, matrix[k][i]);\\n                res = max(res, matrix[k][i]);\\n            }\\n            for (int k = mid + 1; k < n; ++ k) {\\n                matrix[k][i] = min(n - k, matrix[k][i]);\\n                res = max(res, matrix[k][i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373803,
                "title": "python-dp-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\ndp[r][c][0] is length of consecutive 1s from top and end at position (r, c).\\ndp[r][c][1] is length of consecutive 1s from left and end at position (r, c).\\ndp[r][c][2] is length of consecutive 1s from bottom and end at position (r, c).\\ndp[r][c][3] is length of consecutive 1s from right and end at position (r, c).\\nso a for loop is go from left to right and from top to bottom to calculate dp[r][c][0] and dp[r][c][1],\\na for loop is go from right to left and from bottom to top to calculate dp[r][c][2] and dp[r][c][3],\\na for loop is to find length of plus sign.\\ntc is O(n^2), sc is O(^2).\\n\\'\\'\\'\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        zeros = set()\\n        for z in mines:\\n            zeros.add(tuple(z))\\n        dp = [[[0,0,0,0] for _ in range(n)] for _ in range(n)]\\n        for r in range(n):\\n            for c in range(n):\\n                if (r, c) not in zeros:\\n                    dp[r][c][0] = dp[r-1][c][0] + 1 if r-1 >= 0 else 1\\n                    dp[r][c][1] = dp[r][c-1][1] + 1 if c-1 >= 0 else 1\\n        for r in range(n-1, -1, -1):\\n            for c in range(n-1,-1,-1):\\n                if (r, c) not in zeros:\\n                    dp[r][c][2] = dp[r+1][c][2] + 1 if r+1 < n else 1\\n                    dp[r][c][3] = dp[r][c+1][3] + 1 if c+1 < n else 1\\n        ans = 0\\n        for r in range(n):\\n            for c in range(n):\\n                t = min(dp[r][c])\\n                if t > ans: ans = t\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n\\'\\'\\'\\ndp[r][c][0] is length of consecutive 1s from top and end at position (r, c).\\ndp[r][c][1] is length of consecutive 1s from left and end at position (r, c).\\ndp[r][c][2] is length of consecutive 1s from bottom and end at position (r, c).\\ndp[r][c][3] is length of consecutive 1s from right and end at position (r, c).\\nso a for loop is go from left to right and from top to bottom to calculate dp[r][c][0] and dp[r][c][1],\\na for loop is go from right to left and from bottom to top to calculate dp[r][c][2] and dp[r][c][3],\\na for loop is to find length of plus sign.\\ntc is O(n^2), sc is O(^2).\\n\\'\\'\\'\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        zeros = set()\\n        for z in mines:\\n            zeros.add(tuple(z))\\n        dp = [[[0,0,0,0] for _ in range(n)] for _ in range(n)]\\n        for r in range(n):\\n            for c in range(n):\\n                if (r, c) not in zeros:\\n                    dp[r][c][0] = dp[r-1][c][0] + 1 if r-1 >= 0 else 1\\n                    dp[r][c][1] = dp[r][c-1][1] + 1 if c-1 >= 0 else 1\\n        for r in range(n-1, -1, -1):\\n            for c in range(n-1,-1,-1):\\n                if (r, c) not in zeros:\\n                    dp[r][c][2] = dp[r+1][c][2] + 1 if r+1 < n else 1\\n                    dp[r][c][3] = dp[r][c+1][3] + 1 if c+1 < n else 1\\n        ans = 0\\n        for r in range(n):\\n            for c in range(n):\\n                t = min(dp[r][c])\\n                if t > ans: ans = t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198723,
                "title": "java-easy-to-understand",
                "content": "\\n\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n\\n        int[][] grid = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(grid[i], 1);\\n        }\\n        for (int[] mine : mines) {\\n            grid[mine[0]][mine[1]] = 0;\\n        }\\n\\n        int size = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    size = Math.max(size, check(i, j, grid));\\n                }\\n            }\\n        }\\n        return size;\\n    }\\n\\n    public int check(int i, int j, int[][] grid){\\n\\n        int sizeL = 0;\\n        int sizeR = 0;\\n        int sizeU = 0;\\n        int sizeD = 0;\\n\\n        while(i - sizeL >= 0 && grid[i-sizeL][j] == 1){\\n            sizeL++;\\n        }\\n        while(i + sizeR < grid.length && grid[i+sizeR][j] == 1){\\n            sizeR++;\\n        }\\n        while(j - sizeU >= 0 && grid[i][j-sizeU] == 1){\\n            sizeU++;\\n        }\\n        while(j + sizeD < grid[0].length && grid[i][j+sizeD] == 1){\\n            sizeD++;\\n        }\\n\\n        int size = 0;\\n        size = Math.min(Math.min(Math.min(sizeL, sizeR), sizeU), sizeD);\\n\\n        return size;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n\\n        int[][] grid = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(grid[i], 1);\\n        }\\n        for (int[] mine : mines) {\\n            grid[mine[0]][mine[1]] = 0;\\n        }\\n\\n        int size = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    size = Math.max(size, check(i, j, grid));\\n                }\\n            }\\n        }\\n        return size;\\n    }\\n\\n    public int check(int i, int j, int[][] grid){\\n\\n        int sizeL = 0;\\n        int sizeR = 0;\\n        int sizeU = 0;\\n        int sizeD = 0;\\n\\n        while(i - sizeL >= 0 && grid[i-sizeL][j] == 1){\\n            sizeL++;\\n        }\\n        while(i + sizeR < grid.length && grid[i+sizeR][j] == 1){\\n            sizeR++;\\n        }\\n        while(j - sizeU >= 0 && grid[i][j-sizeU] == 1){\\n            sizeU++;\\n        }\\n        while(j + sizeD < grid[0].length && grid[i][j+sizeD] == 1){\\n            sizeD++;\\n        }\\n\\n        int size = 0;\\n        size = Math.min(Math.min(Math.min(sizeL, sizeR), sizeU), sizeD);\\n\\n        return size;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127192,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n         vector<vector<int>>v(n,vector<int>(n,1));\\n        for (int i=0;i<mines.size();i++)\\n        {\\n          v[mines[i][0]][mines[i][1]]=0;\\n        }\\n        vector<vector<int>>L(n,vector<int>(n));\\n         vector<vector<int>>R(n,vector<int>(n));\\n          vector<vector<int>>U(n,vector<int>(n));\\n           vector<vector<int>>D(n,vector<int>(n));\\n           for (int i=0;i<n;i++)\\n           {\\n               int cnt=0;\\n               for (int j=0;j<n;j++)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       L[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       L[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           for (int i=0;i<n;i++)\\n           {\\n               int cnt=0;\\n               for (int j=n-1;j>=0;j--)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       R[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       R[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           for (int j=0;j<n;j++)\\n           {\\n               int cnt=0;\\n               for (int i=0;i<n;i++)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       U[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       U[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           for (int j=0;j<n;j++)\\n           {\\n               int cnt=0;\\n               for (int i=n-1;i>=0;i--)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       D[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       D[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           int ans=0;\\n           int res=0;\\n           for (int i=0;i<n;i++)\\n           {\\n               for (int j=0;j<n;j++)\\n               {\\n                ans=min(L[i][j],R[i][j]);\\n                ans=min(ans,U[i][j]);\\n                ans=min(ans,D[i][j]);\\n                 res=max(res,ans);\\n               }\\n           }\\n           return res;\\n          \\n    }\\n};\\n\\n\\n// class Solution {\\n// public:\\n//   vector<pair<int,int>>directions={{1,0},{-1,0},{0,1},{0,-1}};\\n//   int rec(int n,int row,int col,vector<vector<int>>&v,vector<vector<int>>&dp)\\n//   {\\n//       if (row<0 || col<0 || row>=n || col>=n) return 0;\\n//       if (v[row][col]==0) return 0;\\n//       if (dp[row][col]!=-1) return dp[row][col];\\n//     //   int delii[4]={0,0,-1,1};\\n//     //   int deljj[4]={-1,1,0,0};\\n//       int mn=0;\\n//       for (auto it:directions)\\n//       {\\n//           int c=1;\\n//            c=1+rec(n,row+it.first,col+it.second,v,dp);\\n//           mn=min(mn,c);\\n//       }\\n//       return dp[row][col]=mn;\\n//   }\\n//     int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) \\n//     {\\n//         vector<vector<int>>v(n+1,vector<int>(n+1,1));\\n//         vector<vector<int>>dp(n,vector<int>(n,-1));\\n//         for (int i=0;i<mines.size();i++)\\n//         {\\n//           v[mines[i][0]][mines[i][1]]=0;\\n//         }\\n\\n//         int ans=0;\\n//         for (int i=0;i<n;i++)\\n//         {\\n//             for (int j=0;j<n;j++)\\n//             {\\n//                 cout<<v[i][j]<<\" \";\\n//               ans=max(ans,rec(n,i,j,v,dp));\\n//             }\\n//             cout<<endl;\\n//         }\\n//         return ans;\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n         vector<vector<int>>v(n,vector<int>(n,1));\\n        for (int i=0;i<mines.size();i++)\\n        {\\n          v[mines[i][0]][mines[i][1]]=0;\\n        }\\n        vector<vector<int>>L(n,vector<int>(n));\\n         vector<vector<int>>R(n,vector<int>(n));\\n          vector<vector<int>>U(n,vector<int>(n));\\n           vector<vector<int>>D(n,vector<int>(n));\\n           for (int i=0;i<n;i++)\\n           {\\n               int cnt=0;\\n               for (int j=0;j<n;j++)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       L[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       L[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           for (int i=0;i<n;i++)\\n           {\\n               int cnt=0;\\n               for (int j=n-1;j>=0;j--)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       R[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       R[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           for (int j=0;j<n;j++)\\n           {\\n               int cnt=0;\\n               for (int i=0;i<n;i++)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       U[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       U[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           for (int j=0;j<n;j++)\\n           {\\n               int cnt=0;\\n               for (int i=n-1;i>=0;i--)\\n               {\\n                   if (v[i][j]==1)\\n                   {\\n                       cnt++;\\n                       D[i][j]=cnt;\\n                   }\\n                   else {\\n                       cnt=0;\\n                       D[i][j]=cnt;\\n                   }\\n               }\\n           }\\n           int ans=0;\\n           int res=0;\\n           for (int i=0;i<n;i++)\\n           {\\n               for (int j=0;j<n;j++)\\n               {\\n                ans=min(L[i][j],R[i][j]);\\n                ans=min(ans,U[i][j]);\\n                ans=min(ans,D[i][j]);\\n                 res=max(res,ans);\\n               }\\n           }\\n           return res;\\n          \\n    }\\n};\\n\\n\\n// class Solution {\\n// public:\\n//   vector<pair<int,int>>directions={{1,0},{-1,0},{0,1},{0,-1}};\\n//   int rec(int n,int row,int col,vector<vector<int>>&v,vector<vector<int>>&dp)\\n//   {\\n//       if (row<0 || col<0 || row>=n || col>=n) return 0;\\n//       if (v[row][col]==0) return 0;\\n//       if (dp[row][col]!=-1) return dp[row][col];\\n//     //   int delii[4]={0,0,-1,1};\\n//     //   int deljj[4]={-1,1,0,0};\\n//       int mn=0;\\n//       for (auto it:directions)\\n//       {\\n//           int c=1;\\n//            c=1+rec(n,row+it.first,col+it.second,v,dp);\\n//           mn=min(mn,c);\\n//       }\\n//       return dp[row][col]=mn;\\n//   }\\n//     int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) \\n//     {\\n//         vector<vector<int>>v(n+1,vector<int>(n+1,1));\\n//         vector<vector<int>>dp(n,vector<int>(n,-1));\\n//         for (int i=0;i<mines.size();i++)\\n//         {\\n//           v[mines[i][0]][mines[i][1]]=0;\\n//         }\\n\\n//         int ans=0;\\n//         for (int i=0;i<n;i++)\\n//         {\\n//             for (int j=0;j<n;j++)\\n//             {\\n//                 cout<<v[i][j]<<\" \";\\n//               ans=max(ans,rec(n,i,j,v,dp));\\n//             }\\n//             cout<<endl;\\n//         }\\n//         return ans;\\n//     }\\n// };\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3068386,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        vector<vector<int>>DP(n , vector<int>(n , 1));\\n        for(auto x:mines) DP[x[0]][x[1]] = 0;\\n        vector<vector<int>>lhs = DP , top = DP , rhs = DP , bottom = DP;\\n        for(int i = 0 ; i<n ; i++){\\n\\n            for(int j=0 ; j<n ; j++){\\n\\n                if(DP[i][j]){\\n\\n                    if(j>0) lhs[i][j] = 1+lhs[i][j-1];\\n                    else lhs[i][j] = 1;\\n                    if(i>0) top[i][j] = 1+top[i-1][j];\\n                    else top[i][j] = 1;\\n                }\\n            }\\n        }\\n        int maxx = 0;\\n        for(int i = n-1 ; i>=0 ; i--){\\n\\n            for(int j=n-1 ; j>=0 ; j--){\\n\\n                if(DP[i][j]){\\n\\n                    if(j<(n-1)) rhs[i][j] = 1+rhs[i][j+1];\\n                    else rhs[i][j] = 1;\\n                    if(i<(n-1)) bottom[i][j] = 1+bottom[i+1][j];\\n                    else bottom[i][j] = 1;\\n                }\\n                int k = min({lhs[i][j] , rhs[i][j] , top[i][j] , bottom[i][j]});\\n                maxx = max(k , maxx);\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        \\n        vector<vector<int>>DP(n , vector<int>(n , 1));\\n        for(auto x:mines) DP[x[0]][x[1]] = 0;\\n        vector<vector<int>>lhs = DP , top = DP , rhs = DP , bottom = DP;\\n        for(int i = 0 ; i<n ; i++){\\n\\n            for(int j=0 ; j<n ; j++){\\n\\n                if(DP[i][j]){\\n\\n                    if(j>0) lhs[i][j] = 1+lhs[i][j-1];\\n                    else lhs[i][j] = 1;\\n                    if(i>0) top[i][j] = 1+top[i-1][j];\\n                    else top[i][j] = 1;\\n                }\\n            }\\n        }\\n        int maxx = 0;\\n        for(int i = n-1 ; i>=0 ; i--){\\n\\n            for(int j=n-1 ; j>=0 ; j--){\\n\\n                if(DP[i][j]){\\n\\n                    if(j<(n-1)) rhs[i][j] = 1+rhs[i][j+1];\\n                    else rhs[i][j] = 1;\\n                    if(i<(n-1)) bottom[i][j] = 1+bottom[i+1][j];\\n                    else bottom[i][j] = 1;\\n                }\\n                int k = min({lhs[i][j] , rhs[i][j] , top[i][j] , bottom[i][j]});\\n                maxx = max(k , maxx);\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058432,
                "title": "python-dp-bottom-up-solution",
                "content": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        memo = set()\\n        res = 0\\n        mat = [[0 for j in range(n)] for i in range(n)]\\n\\n        for (r,c) in mines:memo.add((r,c))\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if (i,j) in memo: continue\\n                mat[i][j] = 1\\n                res = 1\\n                \\n        up = [[mat[i][j] for j in range(n)] for i in range(n)]\\n        down = [[mat[i][j] for j in range(n)] for i in range(n)]\\n        right = [[mat[i][j] for j in range(n)] for i in range(n)]\\n        left = [[mat[i][j] for j in range(n)] for i in range(n)]\\n\\n        for i in range(n):\\n            for j in range(1,n):\\n                if (i,j) in memo: continue \\n                right[i][j] += right[i][j-1]\\n\\n        for i in range(n):\\n            for j in range(n-2,-1,-1):\\n                if (i,j) in memo: continue\\n                left[i][j] += left[i][j+1]\\n\\n        for j in range(n):\\n            for i in range(1,n):\\n                if (i,j) in memo: continue \\n                down[i][j] += down[i-1][j]\\n\\n        for j in range(n):\\n            for i in range(n-2,-1,-1):\\n                if (i,j) in memo: continue \\n                up[i][j] += up[i+1][j]\\n\\n        for i in range(1,n-1):\\n            for j in range(1,n-1):\\n                if (i,j) in memo: continue\\n                cur = min(right[i][j-1], left[i][j+1],down[i-1][j], up[i+1][j])\\n                res = max(res,cur+1)\\n        \\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        memo = set()\\n        res = 0\\n        mat = [[0 for j in range(n)] for i in range(n)]\\n\\n        for (r,c) in mines:memo.add((r,c))\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if (i,j) in memo: continue\\n                mat[i][j] = 1\\n                res = 1\\n                \\n        up = [[mat[i][j] for j in range(n)] for i in range(n)]\\n        down = [[mat[i][j] for j in range(n)] for i in range(n)]\\n        right = [[mat[i][j] for j in range(n)] for i in range(n)]\\n        left = [[mat[i][j] for j in range(n)] for i in range(n)]\\n\\n        for i in range(n):\\n            for j in range(1,n):\\n                if (i,j) in memo: continue \\n                right[i][j] += right[i][j-1]\\n\\n        for i in range(n):\\n            for j in range(n-2,-1,-1):\\n                if (i,j) in memo: continue\\n                left[i][j] += left[i][j+1]\\n\\n        for j in range(n):\\n            for i in range(1,n):\\n                if (i,j) in memo: continue \\n                down[i][j] += down[i-1][j]\\n\\n        for j in range(n):\\n            for i in range(n-2,-1,-1):\\n                if (i,j) in memo: continue \\n                up[i][j] += up[i+1][j]\\n\\n        for i in range(1,n-1):\\n            for j in range(1,n-1):\\n                if (i,j) in memo: continue\\n                cur = min(right[i][j-1], left[i][j+1],down[i-1][j], up[i+1][j])\\n                res = max(res,cur+1)\\n        \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935717,
                "title": "python3-concise-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mat = [[1]*N for _ in range(N)]\\n        for x, y in mines: mat[x][y] = 0                   # create matrix with mine\\n            \\n        up = [[0]*N for _ in range(N)]                     # count 1s above mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    up[i][j] = 1\\n                    if i > 0: up[i][j] += up[i-1][j] \\n                \\n        down = [[0]*N for _ in range(N)]                   # count 1s below mat[i][j] if mat[i][j] is 1\\n        for i in range(N-1, -1, -1):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    down[i][j] = 1\\n                    if i < N-1: down[i][j] += down[i+1][j] \\n                    \\n        left = [[0]*N for _ in range(N)]                   # count 1s on the left side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]:\\n                    left[i][j] = 1\\n                    if j > 0: left[i][j] += left[i][j-1]\\n                    \\n        right = [[0]*N for _ in range(N)]                  # count 1s on the right side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N-1, -1, -1):\\n                if mat[i][j]:\\n                    right[i][j] = 1\\n                    if j < N-1: right[i][j] += right[i][j+1]\\n         \\n\\t\\t# find the largest + sign by using cached directions information\\n        return max(min([up[i][j], down[i][j], left[i][j], right[i][j]]) for i in range(N) for j in range(N))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        mat = [[1]*N for _ in range(N)]\\n        for x, y in mines: mat[x][y] = 0                   # create matrix with mine\\n            \\n        up = [[0]*N for _ in range(N)]                     # count 1s above mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    up[i][j] = 1\\n                    if i > 0: up[i][j] += up[i-1][j] \\n                \\n        down = [[0]*N for _ in range(N)]                   # count 1s below mat[i][j] if mat[i][j] is 1\\n        for i in range(N-1, -1, -1):\\n            for j in range(N):\\n                if mat[i][j]: \\n                    down[i][j] = 1\\n                    if i < N-1: down[i][j] += down[i+1][j] \\n                    \\n        left = [[0]*N for _ in range(N)]                   # count 1s on the left side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N):\\n                if mat[i][j]:\\n                    left[i][j] = 1\\n                    if j > 0: left[i][j] += left[i][j-1]\\n                    \\n        right = [[0]*N for _ in range(N)]                  # count 1s on the right side of mat[i][j] if mat[i][j] is 1\\n        for i in range(N):\\n            for j in range(N-1, -1, -1):\\n                if mat[i][j]:\\n                    right[i][j] = 1\\n                    if j < N-1: right[i][j] += right[i][j+1]\\n         \\n\\t\\t# find the largest + sign by using cached directions information\\n        return max(min([up[i][j], down[i][j], left[i][j], right[i][j]]) for i in range(N) for j in range(N))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912985,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn order_of_largest_plus_sign(n: i32, mines: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mut grid = vec![vec![1; n]; n];\\n        for mine in mines {\\n            grid[mine[0] as usize][mine[1] as usize] = 0;\\n        }\\n\\n        let mut left = vec![vec![0; n]; n];\\n        let mut right = vec![vec![0; n]; n];\\n        let mut up = vec![vec![0; n]; n];\\n        let mut down = vec![vec![0; n]; n];\\n\\n        for i in 0..n {\\n            for j in 0..n {\\n                if grid[i][j] == 1 {\\n                    left[i][j] = if j == 0 { 1 } else { left[i][j - 1] + 1 };\\n                    up[i][j] = if i == 0 { 1 } else { up[i - 1][j] + 1 };\\n                }\\n            }\\n        }\\n\\n        for i in (0..n).rev() {\\n            for j in (0..n).rev() {\\n                if grid[i][j] == 1 {\\n                    right[i][j] = if j == n - 1 { 1 } else { right[i][j + 1] + 1 };\\n                    down[i][j] = if i == n - 1 { 1 } else { down[i + 1][j] + 1 };\\n                }\\n            }\\n        }\\n\\n        let mut ans = 0;\\n        for i in 0..n {\\n            for j in 0..n {\\n                let len = std::cmp::min(left[i][j], std::cmp::min(right[i][j], std::cmp::min(up[i][j], down[i][j])));\\n                ans = std::cmp::max(ans, len);\\n            }\\n        }\\n\\n        ans as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn order_of_largest_plus_sign(n: i32, mines: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mut grid = vec![vec![1; n]; n];\\n        for mine in mines {\\n            grid[mine[0] as usize][mine[1] as usize] = 0;\\n        }\\n\\n        let mut left = vec![vec![0; n]; n];\\n        let mut right = vec![vec![0; n]; n];\\n        let mut up = vec![vec![0; n]; n];\\n        let mut down = vec![vec![0; n]; n];\\n\\n        for i in 0..n {\\n            for j in 0..n {\\n                if grid[i][j] == 1 {\\n                    left[i][j] = if j == 0 { 1 } else { left[i][j - 1] + 1 };\\n                    up[i][j] = if i == 0 { 1 } else { up[i - 1][j] + 1 };\\n                }\\n            }\\n        }\\n\\n        for i in (0..n).rev() {\\n            for j in (0..n).rev() {\\n                if grid[i][j] == 1 {\\n                    right[i][j] = if j == n - 1 { 1 } else { right[i][j + 1] + 1 };\\n                    down[i][j] = if i == n - 1 { 1 } else { down[i + 1][j] + 1 };\\n                }\\n            }\\n        }\\n\\n        let mut ans = 0;\\n        for i in 0..n {\\n            for j in 0..n {\\n                let len = std::cmp::min(left[i][j], std::cmp::min(right[i][j], std::cmp::min(up[i][j], down[i][j])));\\n                ans = std::cmp::max(ans, len);\\n            }\\n        }\\n\\n        ans as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2894987,
                "title": "java-bfs-from-the-center-and-if-possible-exit-early-o-n-3-yet-faster-than-official-solutions",
                "content": "# Code\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] matrix = new int[n][n];\\n        boolean[][] seen = new boolean[n][n];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(matrix[i], 1);\\n        }\\n        for (int[] mine : mines) {\\n            matrix[mine[0]][mine[1]] = 0;\\n        }\\n        int maxPlusLength = 0;\\n        int[] delta = {0, -1, 0, 1, -1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 1, -1};\\n        Queue<int[]> q = new LinkedList<>();\\n        int r = n / 2, c = n / 2;\\n        int maxPossible = n / 2;\\n        q.offer(new int[] {r, c});\\n        seen[r][c] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] loc = q.poll();\\n                int row = loc[0], col = loc[1];\\n                for (int d = 0; d < delta.length; d += 2) {\\n                    int nrow = row + delta[d], ncol = col + delta[d + 1];\\n                    if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= n || seen[nrow][ncol]) continue;\\n                    q.offer(new int[]{nrow, ncol});\\n                    seen[nrow][ncol] = true;\\n                }\\n                if (matrix[row][col] != 0) {\\n                    maxPlusLength = Math.max(maxPlusLength, getMaxLengthPlusSign(n, row, col, matrix));\\n                }\\n                if (maxPlusLength > maxPossible) return maxPlusLength; //early exit\\n            }\\n            maxPossible--;\\n        }\\n        return maxPlusLength;\\n    }\\n\\n    private int getMaxLengthPlusSign(int n, int r, int c, int[][] matrix) {\\n        int leftArmLength = 0, rightArmLength = 0, topArmLength = 0, bottomArmLength = 0;\\n        for (int col = c; col >= 0; col--) {\\n            if (matrix[r][col] == 0) break;\\n            leftArmLength++;\\n        }\\n        for (int col = c; col < n; col++) {\\n            if (matrix[r][col] == 0) break;\\n            rightArmLength++;\\n        }\\n        for (int row = r; row >= 0; row--) {\\n            if (matrix[row][c] == 0) break;\\n            topArmLength++;\\n        }\\n        for (int row = r; row < n; row++) {\\n            if (matrix[row][c] == 0) break;\\n            bottomArmLength++;\\n        }\\n        int maxPlusLength = Math.min(leftArmLength, rightArmLength);\\n        maxPlusLength = Math.min(maxPlusLength, topArmLength);\\n        maxPlusLength = Math.min(maxPlusLength, bottomArmLength);\\n        return maxPlusLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] matrix = new int[n][n];\\n        boolean[][] seen = new boolean[n][n];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(matrix[i], 1);\\n        }\\n        for (int[] mine : mines) {\\n            matrix[mine[0]][mine[1]] = 0;\\n        }\\n        int maxPlusLength = 0;\\n        int[] delta = {0, -1, 0, 1, -1, 0, 1, 0, -1, -1, -1, 1, 1, 1, 1, -1};\\n        Queue<int[]> q = new LinkedList<>();\\n        int r = n / 2, c = n / 2;\\n        int maxPossible = n / 2;\\n        q.offer(new int[] {r, c});\\n        seen[r][c] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] loc = q.poll();\\n                int row = loc[0], col = loc[1];\\n                for (int d = 0; d < delta.length; d += 2) {\\n                    int nrow = row + delta[d], ncol = col + delta[d + 1];\\n                    if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= n || seen[nrow][ncol]) continue;\\n                    q.offer(new int[]{nrow, ncol});\\n                    seen[nrow][ncol] = true;\\n                }\\n                if (matrix[row][col] != 0) {\\n                    maxPlusLength = Math.max(maxPlusLength, getMaxLengthPlusSign(n, row, col, matrix));\\n                }\\n                if (maxPlusLength > maxPossible) return maxPlusLength; //early exit\\n            }\\n            maxPossible--;\\n        }\\n        return maxPlusLength;\\n    }\\n\\n    private int getMaxLengthPlusSign(int n, int r, int c, int[][] matrix) {\\n        int leftArmLength = 0, rightArmLength = 0, topArmLength = 0, bottomArmLength = 0;\\n        for (int col = c; col >= 0; col--) {\\n            if (matrix[r][col] == 0) break;\\n            leftArmLength++;\\n        }\\n        for (int col = c; col < n; col++) {\\n            if (matrix[r][col] == 0) break;\\n            rightArmLength++;\\n        }\\n        for (int row = r; row >= 0; row--) {\\n            if (matrix[row][c] == 0) break;\\n            topArmLength++;\\n        }\\n        for (int row = r; row < n; row++) {\\n            if (matrix[row][c] == 0) break;\\n            bottomArmLength++;\\n        }\\n        int maxPlusLength = Math.min(leftArmLength, rightArmLength);\\n        maxPlusLength = Math.min(maxPlusLength, topArmLength);\\n        maxPlusLength = Math.min(maxPlusLength, bottomArmLength);\\n        return maxPlusLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894189,
                "title": "prefix-sum-matrices-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n, vector<int>(n, 1));\\n        \\n        for(int i=0; i<mines.size(); i++){\\n            grid[mines[i][0]][mines[i][1]] = 0;\\n        }\\n\\n        vector<vector<int>> matrix = grid, grid2 = grid;\\n\\n        //left\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] = grid[i][j] == 1 ? grid[i][j-1]+1 : 0;\\n            }\\n        }\\n\\n        // right\\n        for(int i=0; i<n; i++){\\n            grid[i][n-1] = grid[i][n-1] == 0 ? 0 : 1;\\n            for(int j=n-2; j>=0; j--){\\n                grid[i][j] = grid[i][j] == 0 ? 0 : min(grid[i][j+1]+1, grid[i][j]);\\n            }\\n        }\\n\\n        // top to down\\n        for(int j=0; j<n; j++){\\n            for(int i=1; i<n; i++){\\n                grid2[i][j] = grid2[i][j]==0 ? 0 : grid2[i-1][j]+1;\\n            }\\n        }\\n\\n        int ans = INT_MIN;\\n\\n        // bottom up\\n        for(int j=0; j<n; j++){\\n            grid2[n-1][j] = grid2[n-1][j] == 0 ? 0 : 1;\\n            ans = max(ans, min(grid[n-1][j], grid2[n-1][j]));\\n            for(int i=n-2; i>=0; i--){\\n                grid2[i][j] = grid2[i][j] == 0 ? 0 : min(grid2[i+1][j]+1, grid2[i][j]);\\n                ans = max(ans, min(grid[i][j], grid2[i][j]));\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> grid(n, vector<int>(n, 1));\\n        \\n        for(int i=0; i<mines.size(); i++){\\n            grid[mines[i][0]][mines[i][1]] = 0;\\n        }\\n\\n        vector<vector<int>> matrix = grid, grid2 = grid;\\n\\n        //left\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] = grid[i][j] == 1 ? grid[i][j-1]+1 : 0;\\n            }\\n        }\\n\\n        // right\\n        for(int i=0; i<n; i++){\\n            grid[i][n-1] = grid[i][n-1] == 0 ? 0 : 1;\\n            for(int j=n-2; j>=0; j--){\\n                grid[i][j] = grid[i][j] == 0 ? 0 : min(grid[i][j+1]+1, grid[i][j]);\\n            }\\n        }\\n\\n        // top to down\\n        for(int j=0; j<n; j++){\\n            for(int i=1; i<n; i++){\\n                grid2[i][j] = grid2[i][j]==0 ? 0 : grid2[i-1][j]+1;\\n            }\\n        }\\n\\n        int ans = INT_MIN;\\n\\n        // bottom up\\n        for(int j=0; j<n; j++){\\n            grid2[n-1][j] = grid2[n-1][j] == 0 ? 0 : 1;\\n            ans = max(ans, min(grid[n-1][j], grid2[n-1][j]));\\n            for(int i=n-2; i>=0; i--){\\n                grid2[i][j] = grid2[i][j] == 0 ? 0 : min(grid2[i+1][j]+1, grid2[i][j]);\\n                ans = max(ans, min(grid[i][j], grid2[i][j]));\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857821,
                "title": "easy-and-clean-2-solutions-with-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        //Way 1 With 5 matrices\\n        int m = n;\\n        if(mines.length == m*n)\\n        return 0;\\n\\n        int [][] grid = new int[m][n];\\n        int [][] left = new int[m][n];\\n        int [][] right = new int[m][n];\\n        int [][] up = new int[m][n];\\n        int [][] down = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(grid[i], 1);\\n\\n        for(int i = 0; i < mines.length;i++)\\n        grid[mines[i][0]][mines[i][1]] = 0;\\n        //Fill left\\n        for(int i = 0; i < m; i++)\\n        {\\n            left[i][0] = grid[i][0] == 1 ? 1 : 0;\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                left[i][j] = 1 + left[i][j-1];\\n            }\\n        }\\n        //Fill Right\\n        for(int i = 0; i < m; i++)\\n        {\\n            right[i][n-1] = grid[i][n-1] == 1 ? 1 : 0;\\n            for(int j = n-2; j >= 0; j--)\\n            {\\n                if(grid[i][j] == 1)\\n                right[i][j] = 1 + right[i][j+1];\\n            }\\n        }\\n        //Fill Up\\n        for(int i = 0; i < n; i++)\\n        {\\n            up[0][i] = grid[0][i] == 1 ? 1 : 0;\\n            for(int j = 1; j < m; j++)\\n            {\\n                if(grid[j][i] == 1)\\n                up[j][i] = 1 + up[j-1][i];\\n            }\\n        }\\n        //Fill Down\\n        for(int i = 0; i < n; i++)\\n        {\\n            down[m-1][i] = grid[m-1][i] == 1 ? 1 : 0;\\n            for(int j = m-2; j >= 0; j--)\\n            {\\n                if(grid[j][i] == 1)\\n                down[j][i] = 1 + down[j+1][i];\\n            }\\n        }\\n        int k = 1;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                \\n                if(grid[i][j] == 1)\\n                {\\n                    if(i-1 < 0 || i+1>=m || j-1<0 || j+1>=n)\\n                    continue;\\n\\n                    int l = left[i][j-1];\\n                    int r = right[i][j+1];\\n                    int u = up[i-1][j];\\n                    int d = down[i+1][j];\\n                    var min = Math.min(l,Math.min(r,Math.min(u,d)));\\n                    k = Math.max(k, min+1);\\n                }\\n            }\\n        }\\n        return k;\\n\\n        //Way 2 with one matrix\\n        if(mines.length == n*n)\\n        return 0;\\n\\n        int [][] grid = new int[n][n];\\n        for(int i=0;i<n;i++)\\n            Arrays.fill(grid[i], n);\\n\\n        for(int i = 0; i < mines.length;i++)\\n        grid[mines[i][0]][mines[i][1]] = 0;\\n        int max = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for (int j = 0, k = n - 1, l = 0, r = 0, u = 0, d = 0; j < n; j++, k--)\\n            {\\n                grid[i][j] = Math.min(grid[i][j], l = grid[i][j] == 0 ? 0 : l + 1);\\n                grid[i][k] = Math.min(grid[i][k], r = grid[i][k] == 0 ? 0 : r + 1);\\n                grid[j][i] = Math.min(grid[j][i], u = grid[j][i] == 0 ? 0 : u + 1);\\n                grid[k][i] = Math.min(grid[k][i], d = grid[k][i] == 0 ? 0 : d + 1);\\n            }\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            max = Math.max(grid[i][j], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        //Way 1 With 5 matrices\\n        int m = n;\\n        if(mines.length == m*n)\\n        return 0;\\n\\n        int [][] grid = new int[m][n];\\n        int [][] left = new int[m][n];\\n        int [][] right = new int[m][n];\\n        int [][] up = new int[m][n];\\n        int [][] down = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(grid[i], 1);\\n\\n        for(int i = 0; i < mines.length;i++)\\n        grid[mines[i][0]][mines[i][1]] = 0;\\n        //Fill left\\n        for(int i = 0; i < m; i++)\\n        {\\n            left[i][0] = grid[i][0] == 1 ? 1 : 0;\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                left[i][j] = 1 + left[i][j-1];\\n            }\\n        }\\n        //Fill Right\\n        for(int i = 0; i < m; i++)\\n        {\\n            right[i][n-1] = grid[i][n-1] == 1 ? 1 : 0;\\n            for(int j = n-2; j >= 0; j--)\\n            {\\n                if(grid[i][j] == 1)\\n                right[i][j] = 1 + right[i][j+1];\\n            }\\n        }\\n        //Fill Up\\n        for(int i = 0; i < n; i++)\\n        {\\n            up[0][i] = grid[0][i] == 1 ? 1 : 0;\\n            for(int j = 1; j < m; j++)\\n            {\\n                if(grid[j][i] == 1)\\n                up[j][i] = 1 + up[j-1][i];\\n            }\\n        }\\n        //Fill Down\\n        for(int i = 0; i < n; i++)\\n        {\\n            down[m-1][i] = grid[m-1][i] == 1 ? 1 : 0;\\n            for(int j = m-2; j >= 0; j--)\\n            {\\n                if(grid[j][i] == 1)\\n                down[j][i] = 1 + down[j+1][i];\\n            }\\n        }\\n        int k = 1;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                \\n                if(grid[i][j] == 1)\\n                {\\n                    if(i-1 < 0 || i+1>=m || j-1<0 || j+1>=n)\\n                    continue;\\n\\n                    int l = left[i][j-1];\\n                    int r = right[i][j+1];\\n                    int u = up[i-1][j];\\n                    int d = down[i+1][j];\\n                    var min = Math.min(l,Math.min(r,Math.min(u,d)));\\n                    k = Math.max(k, min+1);\\n                }\\n            }\\n        }\\n        return k;\\n\\n        //Way 2 with one matrix\\n        if(mines.length == n*n)\\n        return 0;\\n\\n        int [][] grid = new int[n][n];\\n        for(int i=0;i<n;i++)\\n            Arrays.fill(grid[i], n);\\n\\n        for(int i = 0; i < mines.length;i++)\\n        grid[mines[i][0]][mines[i][1]] = 0;\\n        int max = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for (int j = 0, k = n - 1, l = 0, r = 0, u = 0, d = 0; j < n; j++, k--)\\n            {\\n                grid[i][j] = Math.min(grid[i][j], l = grid[i][j] == 0 ? 0 : l + 1);\\n                grid[i][k] = Math.min(grid[i][k], r = grid[i][k] == 0 ? 0 : r + 1);\\n                grid[j][i] = Math.min(grid[j][i], u = grid[j][i] == 0 ? 0 : u + 1);\\n                grid[k][i] = Math.min(grid[k][i], d = grid[k][i] == 0 ? 0 : d + 1);\\n            }\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            max = Math.max(grid[i][j], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795927,
                "title": "python-solution-dynamic-programming-2d-faster-than-5-time-o-n-2-spac-o-n-2",
                "content": "\\tclass Solution:\\n\\t\\tdef orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n\\t\\t\\tgrid = [[1 for _ in range(n)] for _ in range(n)]\\n\\t\\t\\tnum_items = len(mines)\\n\\t\\t\\tfor i in range(num_items): \\n\\t\\t\\t\\txi, yi = mines[i]\\n\\t\\t\\t\\tgrid[xi][yi] = 0 \\n\\n\\t\\t\\tleft_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\t\\t\\tright_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\t\\t\\tdown_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\t\\t\\tup_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\n\\t\\t\\tfor y in range(n):\\n\\t\\t\\t\\tif grid[y][0] == 1:\\n\\t\\t\\t\\t\\tright_dp[y][0] = 1\\n\\t\\t\\t\\tif grid[y][n-1] == 1:\\n\\t\\t\\t\\t\\tleft_dp[y][n-1] = 1\\n\\n\\t\\t\\tfor x in range(n): \\n\\t\\t\\t\\tif grid[0][x] == 1:\\n\\t\\t\\t\\t\\tup_dp[0][x] = 1\\n\\t\\t\\t\\tif grid[n-1][x] == 1:\\n\\t\\t\\t\\t\\tdown_dp[n-1][x] = 1\\n\\n\\t\\t\\tfor y in range(n):\\n\\t\\t\\t\\tfor x in range(1, n):\\n\\t\\t\\t\\t\\tif grid[y][x] == 1:\\n\\t\\t\\t\\t\\t\\tright_dp[y][x] = right_dp[y][x-1]+1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tright_dp[y][x] = 0 \\n\\n\\t\\t\\t\\tfor x in range(n-2, -1, -1): \\n\\t\\t\\t\\t\\tif grid[y][x] == 1:\\n\\t\\t\\t\\t\\t\\tleft_dp[y][x] = left_dp[y][x+1]+1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tleft_dp[y][x] = 0\\n\\n\\t\\t\\tfor x in range(n): \\n\\t\\t\\t\\tfor y in range(1, n):\\n\\t\\t\\t\\t\\tif grid[y][x] == 1: \\n\\t\\t\\t\\t\\t\\tup_dp[y][x] = up_dp[y-1][x] + 1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tup_dp[y][x] = 0 \\n\\n\\t\\t\\t\\tfor y in range(n-2, -1, -1):\\n\\t\\t\\t\\t\\tif grid[y][x] == 1:\\n\\t\\t\\t\\t\\t\\tdown_dp[y][x] = down_dp[y+1][x] + 1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tdown_dp[y][x] = 0 \\n\\n\\t\\t\\t# print(left_dp)\\n\\t\\t\\t# print(right_dp)\\n\\t\\t\\t# print(up_dp) \\n\\t\\t\\t# print(down_dp)            \\n\\n\\n\\t\\t\\tmax_k = 0\\n\\t\\t\\tdp = [[None for _ in range(n)] for _ in range(n)] \\n\\t\\t\\tfor y in range(n): \\n\\t\\t\\t\\tfor x in range(n): \\n\\t\\t\\t\\t\\tdp[y][x] = min(left_dp[y][x], right_dp[y][x], up_dp[y][x], down_dp[y][x])\\n\\t\\t\\t\\t\\tif dp[y][x] > max_k: \\n\\t\\t\\t\\t\\t\\tmax_k = dp[y][x]\\n\\t\\t\\treturn max_k           \\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n\\t\\t\\tgrid = [[1 for _ in range(n)] for _ in range(n)]\\n\\t\\t\\tnum_items = len(mines)\\n\\t\\t\\tfor i in range(num_items): \\n\\t\\t\\t\\txi, yi = mines[i]\\n\\t\\t\\t\\tgrid[xi][yi] = 0 \\n\\n\\t\\t\\tleft_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\t\\t\\tright_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\t\\t\\tdown_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\t\\t\\tup_dp = [[0 for _ in range(n)] for _ in range(n)]    \\n\\n\\t\\t\\tfor y in range(n):\\n\\t\\t\\t\\tif grid[y][0] == 1:\\n\\t\\t\\t\\t\\tright_dp[y][0] = 1\\n\\t\\t\\t\\tif grid[y][n-1] == 1:\\n\\t\\t\\t\\t\\tleft_dp[y][n-1] = 1\\n\\n\\t\\t\\tfor x in range(n): \\n\\t\\t\\t\\tif grid[0][x] == 1:\\n\\t\\t\\t\\t\\tup_dp[0][x] = 1\\n\\t\\t\\t\\tif grid[n-1][x] == 1:\\n\\t\\t\\t\\t\\tdown_dp[n-1][x] = 1\\n\\n\\t\\t\\tfor y in range(n):\\n\\t\\t\\t\\tfor x in range(1, n):\\n\\t\\t\\t\\t\\tif grid[y][x] == 1:\\n\\t\\t\\t\\t\\t\\tright_dp[y][x] = right_dp[y][x-1]+1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tright_dp[y][x] = 0 \\n\\n\\t\\t\\t\\tfor x in range(n-2, -1, -1): \\n\\t\\t\\t\\t\\tif grid[y][x] == 1:\\n\\t\\t\\t\\t\\t\\tleft_dp[y][x] = left_dp[y][x+1]+1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tleft_dp[y][x] = 0\\n\\n\\t\\t\\tfor x in range(n): \\n\\t\\t\\t\\tfor y in range(1, n):\\n\\t\\t\\t\\t\\tif grid[y][x] == 1: \\n\\t\\t\\t\\t\\t\\tup_dp[y][x] = up_dp[y-1][x] + 1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tup_dp[y][x] = 0 \\n\\n\\t\\t\\t\\tfor y in range(n-2, -1, -1):\\n\\t\\t\\t\\t\\tif grid[y][x] == 1:\\n\\t\\t\\t\\t\\t\\tdown_dp[y][x] = down_dp[y+1][x] + 1\\n\\t\\t\\t\\t\\telif grid[y][x] == 0:\\n\\t\\t\\t\\t\\t\\tdown_dp[y][x] = 0 \\n\\n\\t\\t\\t# print(left_dp)\\n\\t\\t\\t# print(right_dp)\\n\\t\\t\\t# print(up_dp) \\n\\t\\t\\t# print(down_dp)            \\n\\n\\n\\t\\t\\tmax_k = 0\\n\\t\\t\\tdp = [[None for _ in range(n)] for _ in range(n)] \\n\\t\\t\\tfor y in range(n): \\n\\t\\t\\t\\tfor x in range(n): \\n\\t\\t\\t\\t\\tdp[y][x] = min(left_dp[y][x], right_dp[y][x], up_dp[y][x], down_dp[y][x])\\n\\t\\t\\t\\t\\tif dp[y][x] > max_k: \\n\\t\\t\\t\\t\\t\\tmax_k = dp[y][x]\\n\\t\\t\\treturn max_k           \\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2794773,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n\\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // 0, 1, 2, 3\\n\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] grid = new int[n][n];\\n        for (int[] g: grid) {\\n            Arrays.fill(g, 1);\\n        }\\n        for (int[] m: mines) {\\n            grid[m[0]][m[1]] = 0;\\n        }\\n        int[][][] dp = new int[n][n][4]; // 0: up, 1:right, 2:down, 3:left\\n\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int minstep = Integer.MAX_VALUE;\\n                for (int[] d: dirs) {\\n\\n                    int step = 0;\\n                    int x = i;\\n                    int y = j;\\n\\n                    while (x >= 0 && x < n && y >= 0 && y < n && grid[x][y] == 1) {\\n                        step++;\\n                        x += d[0];\\n                        y += d[1];   \\n                    }\\n                    minstep = Math.min(minstep, step);\\n                }\\n\\n                if (minstep <= 1) continue; \\n                res = Math.max(minstep, res);\\n            }   \\n        }\\n        boolean hasone = mines.length < n * n ? true : false;\\n\\n        return res < 0 ? (hasone == true ? 1 : 0) : res;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // 0, 1, 2, 3\\n\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] grid = new int[n][n];\\n        for (int[] g: grid) {\\n            Arrays.fill(g, 1);\\n        }\\n        for (int[] m: mines) {\\n            grid[m[0]][m[1]] = 0;\\n        }\\n        int[][][] dp = new int[n][n][4]; // 0: up, 1:right, 2:down, 3:left\\n\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int minstep = Integer.MAX_VALUE;\\n                for (int[] d: dirs) {\\n\\n                    int step = 0;\\n                    int x = i;\\n                    int y = j;\\n\\n                    while (x >= 0 && x < n && y >= 0 && y < n && grid[x][y] == 1) {\\n                        step++;\\n                        x += d[0];\\n                        y += d[1];   \\n                    }\\n                    minstep = Math.min(minstep, step);\\n                }\\n\\n                if (minstep <= 1) continue; \\n                res = Math.max(minstep, res);\\n            }   \\n        }\\n        boolean hasone = mines.length < n * n ? true : false;\\n\\n        return res < 0 ? (hasone == true ? 1 : 0) : res;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777830,
                "title": "fairly-intuitive-java-solution-with-explanation-and-comments",
                "content": "EG:\\npossibleMax for n = 5: **3** \\nmaxMatrix if all values are assumed 1 for n = 5:\\n**| 1 1 1 1 1 |\\n| 1 2 2 2 1 |\\n| 1 2 3 2 1 |\\n| 1 2 2 2 1 |\\n| 1 1 1 1 1 |**\\n\\nIf mine at **[4, 2]**, after reduction, matrix will look like this:\\n**| 1 1 1 1 1 |\\n| 1 2 2 2 1 |\\n| 1 2 1 2 1 |\\n| 1 1 0 1 1 |\\n| 1 1 1 1 1 |**\\n\\nMax value in matrix: **2**\\n\\n```\\nclass Solution {    \\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] maxMatrix = new int[n][n];\\n        \\n        // Max possible value for matrix of size n\\n        int possibleMax = n % 2 == 0? n/2 : (n + 1);\\n        \\n        int max = 0;\\n        \\n        // Form max possible matrix if everything is 1\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                maxMatrix[i][j] = Math.min(Math.min(i, j), Math.min(n - i - 1, n - j - 1)) + 1;\\n        \\n        // Reduce possible maximums around mines in all 4 directions: \\n        // 1, 2, 3.... radiating outwards but use minimums to take care of effects from other mines and current values\\n        for(int i = 0; i < mines.length; i++){\\n            // Make mine values 0\\n            maxMatrix[mines[i][0]][mines[i][1]] = 0;\\n            int count = 1;\\n            // Reduce everything above\\n            for(int k = mines[i][0] - 1; k > 0; k--)\\n                maxMatrix[k][mines[i][1]] = Math.min(maxMatrix[k][mines[i][1]], count++);\\n            count = 1;\\n            // Reduce everything to the right\\n            for(int k = mines[i][1] + 1; k < n ; k++)\\n                maxMatrix[mines[i][0]][k] = Math.min(maxMatrix[mines[i][0]][k], count++);\\n            count = 1;\\n            // Reduce everything to the left\\n            for(int k = mines[i][1] - 1; k > 0; k--)\\n                maxMatrix[mines[i][0]][k] = Math.min(maxMatrix[mines[i][0]][k], count++);\\n            count = 1;\\n            // Reduce everything below\\n            for(int k = mines[i][0] + 1; k < n; k++)\\n                maxMatrix[k][mines[i][1]] = Math.min(maxMatrix[k][mines[i][1]], count++);\\n        }\\n        \\n        // Find max value\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                max = Math.max(maxMatrix[i][j], max);\\n                if(max == possibleMax)\\n                    return max;\\n            }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] maxMatrix = new int[n][n];\\n        \\n        // Max possible value for matrix of size n\\n        int possibleMax = n % 2 == 0? n/2 : (n + 1);\\n        \\n        int max = 0;\\n        \\n        // Form max possible matrix if everything is 1\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                maxMatrix[i][j] = Math.min(Math.min(i, j), Math.min(n - i - 1, n - j - 1)) + 1;\\n        \\n        // Reduce possible maximums around mines in all 4 directions: \\n        // 1, 2, 3.... radiating outwards but use minimums to take care of effects from other mines and current values\\n        for(int i = 0; i < mines.length; i++){\\n            // Make mine values 0\\n            maxMatrix[mines[i][0]][mines[i][1]] = 0;\\n            int count = 1;\\n            // Reduce everything above\\n            for(int k = mines[i][0] - 1; k > 0; k--)\\n                maxMatrix[k][mines[i][1]] = Math.min(maxMatrix[k][mines[i][1]], count++);\\n            count = 1;\\n            // Reduce everything to the right\\n            for(int k = mines[i][1] + 1; k < n ; k++)\\n                maxMatrix[mines[i][0]][k] = Math.min(maxMatrix[mines[i][0]][k], count++);\\n            count = 1;\\n            // Reduce everything to the left\\n            for(int k = mines[i][1] - 1; k > 0; k--)\\n                maxMatrix[mines[i][0]][k] = Math.min(maxMatrix[mines[i][0]][k], count++);\\n            count = 1;\\n            // Reduce everything below\\n            for(int k = mines[i][0] + 1; k < n; k++)\\n                maxMatrix[k][mines[i][1]] = Math.min(maxMatrix[k][mines[i][1]], count++);\\n        }\\n        \\n        // Find max value\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                max = Math.max(maxMatrix[i][j], max);\\n                if(max == possibleMax)\\n                    return max;\\n            }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776951,
                "title": "recursion-4-wings-4-ways-with-dp-just-another-way",
                "content": "```\\nclass Solution {\\n    static int[][] rMem;\\n    static int[][] bMem;\\n    static int[][] lMem;\\n    static int[][] tMem;\\n        \\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        if(n < 2 && mines.length > 0)\\n            return 0;\\n        \\n        int max = 0;\\n        Boolean[][] isMined = new Boolean[n][n];\\n        rMem = new int[n][n];\\n        lMem = new int[n][n];\\n        tMem = new int[n][n];\\n        bMem = new int[n][n];\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                isMined[i][j] = false;\\n                rMem[i][j] = -1;\\n                bMem[i][j] = -1;\\n                lMem[i][j] = -1;\\n                tMem[i][j] = -1;\\n            }\\n        \\n        for(int i = 0; i < mines.length; i++)\\n            isMined[mines[i][0]][mines[i][1]] = true;\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                if(!isMined[i][j])\\n                    max = Math.max(findPlus(n, isMined, i, j), max);\\n            }\\n        \\n        return max;\\n    }\\n    \\n    static int findPlus(int n, Boolean[][] isMined, int r, int c){\\n        int wingLen = Math.min(\\n                                Math.min(\\n                                    wing(1, n, isMined, r, c), \\n                                    wing(2, n, isMined, r, c)\\n                                ),\\n                                Math.min(\\n                                    wing(3, n, isMined, r, c),\\n                                    wing(4, n, isMined, r, c)\\n                                )\\n                            );\\n        return wingLen;\\n    }\\n    \\n    static int wing(int dir, int n, Boolean[][] isMined, int r, int c){\\n        // Edges\\n        \\n        if(r < 0 || r > n - 1 || c > n - 1 || c < 0 || isMined[r][c])\\n            return 0;\\n        \\n        int row = r;\\n        int col = c;\\n        \\n        switch(dir){\\n            case 1:\\n                if(rMem[r][c] != -1)\\n                    return rMem[r][c];\\n                col++;\\n                break;\\n            case 2:\\n                if(bMem[r][c] != -1)\\n                    return bMem[r][c];\\n                row++;\\n                break;\\n            case 3:\\n                if(lMem[r][c] != -1)\\n                    return lMem[r][c];\\n                col--;\\n                break;\\n            default:\\n                if(tMem[r][c] != -1)\\n                    return tMem[r][c];\\n                row--;\\n                break;\\n        }\\n        \\n        int res = wing(dir, n, isMined, row, col) + 1;\\n        \\n        switch(dir){\\n            case 1:\\n                rMem[r][c] = res;\\n                break;\\n            case 2:\\n                bMem[r][c] = res;\\n                break;\\n            case 3:\\n                lMem[r][c] = res;\\n                break;\\n            default:\\n                tMem[r][c] = res;\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int[][] rMem;\\n    static int[][] bMem;\\n    static int[][] lMem;\\n    static int[][] tMem;\\n        \\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        if(n < 2 && mines.length > 0)\\n            return 0;\\n        \\n        int max = 0;\\n        Boolean[][] isMined = new Boolean[n][n];\\n        rMem = new int[n][n];\\n        lMem = new int[n][n];\\n        tMem = new int[n][n];\\n        bMem = new int[n][n];\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                isMined[i][j] = false;\\n                rMem[i][j] = -1;\\n                bMem[i][j] = -1;\\n                lMem[i][j] = -1;\\n                tMem[i][j] = -1;\\n            }\\n        \\n        for(int i = 0; i < mines.length; i++)\\n            isMined[mines[i][0]][mines[i][1]] = true;\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                if(!isMined[i][j])\\n                    max = Math.max(findPlus(n, isMined, i, j), max);\\n            }\\n        \\n        return max;\\n    }\\n    \\n    static int findPlus(int n, Boolean[][] isMined, int r, int c){\\n        int wingLen = Math.min(\\n                                Math.min(\\n                                    wing(1, n, isMined, r, c), \\n                                    wing(2, n, isMined, r, c)\\n                                ),\\n                                Math.min(\\n                                    wing(3, n, isMined, r, c),\\n                                    wing(4, n, isMined, r, c)\\n                                )\\n                            );\\n        return wingLen;\\n    }\\n    \\n    static int wing(int dir, int n, Boolean[][] isMined, int r, int c){\\n        // Edges\\n        \\n        if(r < 0 || r > n - 1 || c > n - 1 || c < 0 || isMined[r][c])\\n            return 0;\\n        \\n        int row = r;\\n        int col = c;\\n        \\n        switch(dir){\\n            case 1:\\n                if(rMem[r][c] != -1)\\n                    return rMem[r][c];\\n                col++;\\n                break;\\n            case 2:\\n                if(bMem[r][c] != -1)\\n                    return bMem[r][c];\\n                row++;\\n                break;\\n            case 3:\\n                if(lMem[r][c] != -1)\\n                    return lMem[r][c];\\n                col--;\\n                break;\\n            default:\\n                if(tMem[r][c] != -1)\\n                    return tMem[r][c];\\n                row--;\\n                break;\\n        }\\n        \\n        int res = wing(dir, n, isMined, row, col) + 1;\\n        \\n        switch(dir){\\n            case 1:\\n                rMem[r][c] = res;\\n                break;\\n            case 2:\\n                bMem[r][c] = res;\\n                break;\\n            case 3:\\n                lMem[r][c] = res;\\n                break;\\n            default:\\n                tMem[r][c] = res;\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773514,
                "title": "short-and-clean-c-solution-o-n-2-dynamic-programming-94-5-faster",
                "content": "**Cashe the up, down, left, right length of cross using dp**\\n```\\nclass Solution {\\npublic:\\n\\t// to store the mines\\n    int mine[501][501] = {};\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int ans = 0;\\n        for(auto it: mines){\\n            mine[it[0]][it[1]] = 1;\\n        }\\n        int left[501][501]  = {};\\n        int right[501][501] = {};\\n        int up[501][501]    = {};\\n        int down[501][501]  = {};\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            left[i][0] = !mine[i][0];\\n            for(int j=1; j<n; j++){\\n                left[i][j] = !mine[i][j] ? left[i][j-1] + 1 : 0;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            right[i][n-1] = !mine[i][n-1];\\n            for(int j=n-2; j>=0; j--){\\n                right[i][j] = !mine[i][j] ? right[i][j+1] + 1 : 0;\\n            }\\n        }\\n        \\n        \\n        for(int j=0; j<n; j++){\\n            up[0][j] = !mine[0][j];\\n            for(int i=1; i<n; i++){\\n                up[i][j] = !mine[i][j] ? up[i-1][j] + 1 : 0;\\n            }\\n        }\\n        \\n        for(int j=0; j<n; j++){\\n            down[n-1][j] = !mine[n-1][j];\\n            for(int i=n-2; i>=0; i--){\\n                down[i][j] = !mine[i][j] ? down[i+1][j] + 1 : 0;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if( mine[i][j]  == 1)   continue;\\n                int len = left[i][j];\\n                len = min(len, right[i][j]);\\n                len = min(len, up[i][j]);\\n                len = min(len, down[i][j]);\\n\\n                ans = max(ans, len);\\n            }    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// to store the mines\\n    int mine[501][501] = {};\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        int ans = 0;\\n        for(auto it: mines){\\n            mine[it[0]][it[1]] = 1;\\n        }\\n        int left[501][501]  = {};\\n        int right[501][501] = {};\\n        int up[501][501]    = {};\\n        int down[501][501]  = {};\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            left[i][0] = !mine[i][0];\\n            for(int j=1; j<n; j++){\\n                left[i][j] = !mine[i][j] ? left[i][j-1] + 1 : 0;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            right[i][n-1] = !mine[i][n-1];\\n            for(int j=n-2; j>=0; j--){\\n                right[i][j] = !mine[i][j] ? right[i][j+1] + 1 : 0;\\n            }\\n        }\\n        \\n        \\n        for(int j=0; j<n; j++){\\n            up[0][j] = !mine[0][j];\\n            for(int i=1; i<n; i++){\\n                up[i][j] = !mine[i][j] ? up[i-1][j] + 1 : 0;\\n            }\\n        }\\n        \\n        for(int j=0; j<n; j++){\\n            down[n-1][j] = !mine[n-1][j];\\n            for(int i=n-2; i>=0; i--){\\n                down[i][j] = !mine[i][j] ? down[i+1][j] + 1 : 0;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if( mine[i][j]  == 1)   continue;\\n                int len = left[i][j];\\n                len = min(len, right[i][j]);\\n                len = min(len, up[i][j]);\\n                len = min(len, down[i][j]);\\n\\n                ans = max(ans, len);\\n            }    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763756,
                "title": "c-n-2-solution-precomputation",
                "content": "```\\nclass Solution {\\npublic:\\n    void calc(vector<vector<int>>& grid,int f,int g,int i,int j,vector<vector<int>>& res){\\n        int n=grid.size(),sum=0;\\n        while(n--){\\n            if(!grid[i][j]) sum=0,res[i][j]=0;\\n            else{\\n                sum++;\\n                res[i][j]=min(sum,res[i][j]);\\n            }\\n            i+=f;\\n            j+=g;\\n        }\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& n2) {\\n        vector<vector<int>> nums(n,vector<int>(n,1));\\n        for(auto el:n2){\\n            nums[el[0]][el[1]]=0;\\n        }\\n        vector<vector<int>> grid(n,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++) calc(nums,0,1,i,0,grid),calc(nums,1,0,0,i,grid);\\n        for(int i=n-1;i>=0;i--) calc(nums,-1,0,n-1,i,grid),calc(nums,0,-1,i,n-1,grid);\\n        int plus=0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                plus=max(plus,grid[i][j]);\\n            }\\n        }\\n        return plus;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void calc(vector<vector<int>>& grid,int f,int g,int i,int j,vector<vector<int>>& res){\\n        int n=grid.size(),sum=0;\\n        while(n--){\\n            if(!grid[i][j]) sum=0,res[i][j]=0;\\n            else{\\n                sum++;\\n                res[i][j]=min(sum,res[i][j]);\\n            }\\n            i+=f;\\n            j+=g;\\n        }\\n    }\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& n2) {\\n        vector<vector<int>> nums(n,vector<int>(n,1));\\n        for(auto el:n2){\\n            nums[el[0]][el[1]]=0;\\n        }\\n        vector<vector<int>> grid(n,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++) calc(nums,0,1,i,0,grid),calc(nums,1,0,0,i,grid);\\n        for(int i=n-1;i>=0;i--) calc(nums,-1,0,n-1,i,grid),calc(nums,0,-1,i,n-1,grid);\\n        int plus=0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                plus=max(plus,grid[i][j]);\\n            }\\n        }\\n        return plus;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725393,
                "title": "describing-everyone-s-intuition-in-this-code-c-logic",
                "content": "```\\n   int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {        \\n       \\n         //step 0 make the real grid first \\n        vector<vector<int>> arr(n,vector<int>(n,1));\\n        for(auto i:mines)\\n            arr[i[0]][i[1]]=0;\\n        \\n        int m=n;\\n        \\n        //step 1 -> make left to right prefix sum matrix\\n        int LR[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            int preSum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n               if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                LR[i][j]=preSum;\\n            }\\n        }\\n        \\n        //step 2 -> make right to left prefix sum matrix\\n        int RL[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            int preSum=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                RL[i][j]=preSum;\\n            }\\n        }\\n        \\n        //step 3 -> make top to down (TD) prefix sum matrix\\n        int TD[m][n];\\n        for(int j=0;j<n;j++)\\n        {\\n            int preSum=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                 if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                TD[i][j]=preSum;\\n            }\\n        }\\n        \\n        //step 4 -> make down to top(DT) prefix sum matrix\\n        int DT[m][n];\\n        for(int j=0;j<n;j++)\\n        {\\n            int preSum=0;\\n            for(int i=m-1;i>=0;i--)\\n            {\\n                if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                DT[i][j]=preSum;\\n            }\\n        }\\n        \\n//step 5 the min of LR[i][j],RL[i][j],TD[i][j],DT[i][j] would decise ki i,j me sbse zda bda + sign kitne ka bn skta ye btayega . Aise hi har i,j me kro aur max ans nikal\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                    int op1=min(LR[i][j],RL[i][j]);\\n                    int op2=min(TD[i][j],DT[i][j]);\\n                    \\n                    ans=max(ans,min(op1,op2));\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n   int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {        \\n       \\n         //step 0 make the real grid first \\n        vector<vector<int>> arr(n,vector<int>(n,1));\\n        for(auto i:mines)\\n            arr[i[0]][i[1]]=0;\\n        \\n        int m=n;\\n        \\n        //step 1 -> make left to right prefix sum matrix\\n        int LR[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            int preSum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n               if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                LR[i][j]=preSum;\\n            }\\n        }\\n        \\n        //step 2 -> make right to left prefix sum matrix\\n        int RL[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            int preSum=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                RL[i][j]=preSum;\\n            }\\n        }\\n        \\n        //step 3 -> make top to down (TD) prefix sum matrix\\n        int TD[m][n];\\n        for(int j=0;j<n;j++)\\n        {\\n            int preSum=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                 if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                TD[i][j]=preSum;\\n            }\\n        }\\n        \\n        //step 4 -> make down to top(DT) prefix sum matrix\\n        int DT[m][n];\\n        for(int j=0;j<n;j++)\\n        {\\n            int preSum=0;\\n            for(int i=m-1;i>=0;i--)\\n            {\\n                if(arr[i][j]==0)\\n                    preSum=0;\\n                \\n                preSum+=arr[i][j];\\n                DT[i][j]=preSum;\\n            }\\n        }\\n        \\n//step 5 the min of LR[i][j],RL[i][j],TD[i][j],DT[i][j] would decise ki i,j me sbse zda bda + sign kitne ka bn skta ye btayega . Aise hi har i,j me kro aur max ans nikal\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                    int op1=min(LR[i][j],RL[i][j]);\\n                    int op2=min(TD[i][j],DT[i][j]);\\n                    \\n                    ans=max(ans,min(op1,op2));\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2713407,
                "title": "c-faster-than-100",
                "content": "```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] matrix = new int[n][];\\n        for(int i = 0; i < matrix.Length; i++){\\n            matrix[i] = new int[n];\\n        }\\n        \\n        foreach(int[] array in matrix){\\n            Array.Fill(array,1);\\n        }\\n        \\n        foreach(int[] mine in mines){\\n            matrix[mine[0]][mine[1]] = 0;\\n        }\\n        \\n\\t\\tvar ones = new (int left, int up, int right, int down)[n][];\\n        for(int i = 0; i < n ; i++){\\n            ones[i] = new (int, int, int, int)[n];\\n        }\\n        \\n        //fill dp from top left for left and up\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < n; j++){\\n                if(matrix[i][j] == 0){\\n                    ones[i][j].left = 0;\\n                    ones[i][j].up = 0;\\n                    continue;\\n                }\\n               ones[i][j].left = j == 0 ? 1 : ones[i][j-1].left + 1;\\n               ones[i][j].up = i == 0 ? 1 : ones[i-1][j].up + 1;\\n            }\\n        }\\n        \\n        //fill dp from bottom right for down and left\\n        for(int i = n - 1; i >= 0 ; i--){\\n            for(int j = n - 1; j >= 0 ; j--){\\n                if(matrix[i][j] == 0){\\n                    ones[i][j].down = 0;\\n                    ones[i][j].right = 0;   \\n                    continue; \\n                }\\n               ones[i][j].right = j == n - 1 ? 1 : ones[i][j+1].right + 1;\\n               ones[i][j].down = i == n - 1 ? 1 : ones[i+1][j].down + 1;\\n            }\\n        }\\n        \\n        //iterate through all matrix and get best option. max = mathmax(max, minSizeOfAllSides).\\n        int max = 0;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < n; j++){\\n                var temp = ones[i][j];\\n                int min = Math.Min(temp.down, Math.Min(temp.up, Math.Min(temp.left, temp.right)));\\n                max = Math.Max(min, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int OrderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] matrix = new int[n][];\\n        for(int i = 0; i < matrix.Length; i++){\\n            matrix[i] = new int[n];\\n        }\\n        \\n        foreach(int[] array in matrix){\\n            Array.Fill(array,1);\\n        }\\n        \\n        foreach(int[] mine in mines){\\n            matrix[mine[0]][mine[1]] = 0;\\n        }\\n        \\n\\t\\tvar ones = new (int left, int up, int right, int down)[n][];\\n        for(int i = 0; i < n ; i++){\\n            ones[i] = new (int, int, int, int)[n];\\n        }\\n        \\n        //fill dp from top left for left and up\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < n; j++){\\n                if(matrix[i][j] == 0){\\n                    ones[i][j].left = 0;\\n                    ones[i][j].up = 0;\\n                    continue;\\n                }\\n               ones[i][j].left = j == 0 ? 1 : ones[i][j-1].left + 1;\\n               ones[i][j].up = i == 0 ? 1 : ones[i-1][j].up + 1;\\n            }\\n        }\\n        \\n        //fill dp from bottom right for down and left\\n        for(int i = n - 1; i >= 0 ; i--){\\n            for(int j = n - 1; j >= 0 ; j--){\\n                if(matrix[i][j] == 0){\\n                    ones[i][j].down = 0;\\n                    ones[i][j].right = 0;   \\n                    continue; \\n                }\\n               ones[i][j].right = j == n - 1 ? 1 : ones[i][j+1].right + 1;\\n               ones[i][j].down = i == n - 1 ? 1 : ones[i+1][j].down + 1;\\n            }\\n        }\\n        \\n        //iterate through all matrix and get best option. max = mathmax(max, minSizeOfAllSides).\\n        int max = 0;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < n; j++){\\n                var temp = ones[i][j];\\n                int min = Math.Min(temp.down, Math.Min(temp.up, Math.Min(temp.left, temp.right)));\\n                max = Math.Max(min, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705984,
                "title": "c-easy-90-85",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& a) \\n    {\\n        int res=0,temp;\\n        vector<vector<int>> dp(n,vector(n,1));\\n        for(auto k : a)\\n            dp[k[0]][k[1]]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j])\\n                {\\n                    if(i-res>=0&&i+res<n&&j-res>=0&&j+res<n)\\n                    {\\n                        int l=1;\\n                        temp=1;\\n                        while(i+l<n&&j+l<n&&i-l>=0&&j-l>=0&&dp[i][j+l]&&dp[i][j-l]&&dp[i+l][j]&&dp[i-l][j])\\n                        {\\n                            temp++;\\n                            l++;\\n                        }\\n                    }\\n                    res=max(temp,res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& a) \\n    {\\n        int res=0,temp;\\n        vector<vector<int>> dp(n,vector(n,1));\\n        for(auto k : a)\\n            dp[k[0]][k[1]]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j])\\n                {\\n                    if(i-res>=0&&i+res<n&&j-res>=0&&j+res<n)\\n                    {\\n                        int l=1;\\n                        temp=1;\\n                        while(i+l<n&&j+l<n&&i-l>=0&&j-l>=0&&dp[i][j+l]&&dp[i][j-l]&&dp[i+l][j]&&dp[i-l][j])\\n                        {\\n                            temp++;\\n                            l++;\\n                        }\\n                    }\\n                    res=max(temp,res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648025,
                "title": "java-solution-time-o-n-2-72-faster",
                "content": "```\\n\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] grid=new int[n][n];\\n        int[][] dp=new int[n][n];\\n        int[][] top=new int[n][n];\\n        int[][] bottom=new int[n][n];\\n        int[][] left=new int[n][n];\\n        int[][] right=new int[n][n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                grid[i][j]=1;\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<mines.length;i++){\\n            grid[mines[i][0]][mines[i][1]]=0;\\n        }\\n        \\n        for(int i=0,k=n-1;i<n;i++,k--){\\n            for(int j=0,l=n-1;j<n;j++,l--){\\n                if(i==0){\\n                    top[i][j]=grid[i][j];\\n                    \\n                }\\n                else{\\n                    if(grid[i][j]==1){\\n                        top[i][j]=top[i-1][j]+1;\\n                    }\\n                    \\n                }\\n                \\n                if(k==n-1){\\n                    bottom[k][j]=grid[k][j];\\n                }\\n                else{\\n                    if(grid[k][j]==1){\\n                        bottom[k][j]=bottom[k+1][j]+1;\\n                    }\\n                }\\n                \\n                if(j==0){\\n                    left[i][j]=grid[i][j];\\n                }\\n                else{\\n                    if(grid[i][j]==1){\\n                        left[i][j]=left[i][j-1]+1;\\n                    }\\n                }\\n                \\n                if(l==n-1){\\n                    right[i][l]=grid[i][l];\\n                }\\n                else{\\n                    if(grid[i][l]==1){\\n                        right[i][l]=right[i][l+1]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==1){\\n                    if(i==0 || j==0 || i==n-1 || j==n-1){\\n                        dp[i][j]=1;\\n                    }\\n                    else{\\n                        int min=Math.min(top[i-1][j],Math.min(bottom[i+1][j],Math.min(left[i][j-1],right[i][j+1])));\\n                        dp[i][j]=1+min;\\n                    }\\n                    \\n                    if(dp[i][j]>res){\\n                        res=dp[i][j];\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return res;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] grid=new int[n][n];\\n        int[][] dp=new int[n][n];\\n        int[][] top=new int[n][n];\\n        int[][] bottom=new int[n][n];\\n        int[][] left=new int[n][n];\\n        int[][] right=new int[n][n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                grid[i][j]=1;\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<mines.length;i++){\\n            grid[mines[i][0]][mines[i][1]]=0;\\n        }\\n        \\n        for(int i=0,k=n-1;i<n;i++,k--){\\n            for(int j=0,l=n-1;j<n;j++,l--){\\n                if(i==0){\\n                    top[i][j]=grid[i][j];\\n                    \\n                }\\n                else{\\n                    if(grid[i][j]==1){\\n                        top[i][j]=top[i-1][j]+1;\\n                    }\\n                    \\n                }\\n                \\n                if(k==n-1){\\n                    bottom[k][j]=grid[k][j];\\n                }\\n                else{\\n                    if(grid[k][j]==1){\\n                        bottom[k][j]=bottom[k+1][j]+1;\\n                    }\\n                }\\n                \\n                if(j==0){\\n                    left[i][j]=grid[i][j];\\n                }\\n                else{\\n                    if(grid[i][j]==1){\\n                        left[i][j]=left[i][j-1]+1;\\n                    }\\n                }\\n                \\n                if(l==n-1){\\n                    right[i][l]=grid[i][l];\\n                }\\n                else{\\n                    if(grid[i][l]==1){\\n                        right[i][l]=right[i][l+1]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==1){\\n                    if(i==0 || j==0 || i==n-1 || j==n-1){\\n                        dp[i][j]=1;\\n                    }\\n                    else{\\n                        int min=Math.min(top[i-1][j],Math.min(bottom[i+1][j],Math.min(left[i][j-1],right[i][j+1])));\\n                        dp[i][j]=1+min;\\n                    }\\n                    \\n                    if(dp[i][j]>res){\\n                        res=dp[i][j];\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return res;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642826,
                "title": "python-dp-4-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 4 directions array to record the longest plus in each direction\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst define 4 direction arrays\\nthen from top left to bottom right can record the top, left dp array\\nlast from bottom right to top left can record the bottom right dp array and return the min of the 4 directons.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        s, res = set((x, y) for x, y in mines), 0\\n        up, down, left, right = [[[0] * n for i in range(n)] for j in range(4)]\\n        # from top left\\n        for i in range(n):\\n            for j in range(n):\\n                if (i, j) not in s:\\n                    if i == 0 or j == 0:\\n                        up[i][j] = left[i][j] = 1\\n                    else:\\n                        up[i][j] = up[i - 1][j] + 1\\n                        left[i][j] = left[i][j - 1] + 1\\n        # from down right and find the max\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if (i, j) not in s:\\n                    if i == n - 1 or j == n - 1:\\n                        down[i][j] = right[i][j] = 1\\n                    else:\\n                        down[i][j] = down[i + 1][j] + 1\\n                        right[i][j] = right[i][j + 1] + 1\\n                res = max(res, min(up[i][j], left[i][j], down[i][j], right[i][j]))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        s, res = set((x, y) for x, y in mines), 0\\n        up, down, left, right = [[[0] * n for i in range(n)] for j in range(4)]\\n        # from top left\\n        for i in range(n):\\n            for j in range(n):\\n                if (i, j) not in s:\\n                    if i == 0 or j == 0:\\n                        up[i][j] = left[i][j] = 1\\n                    else:\\n                        up[i][j] = up[i - 1][j] + 1\\n                        left[i][j] = left[i][j - 1] + 1\\n        # from down right and find the max\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if (i, j) not in s:\\n                    if i == n - 1 or j == n - 1:\\n                        down[i][j] = right[i][j] = 1\\n                    else:\\n                        down[i][j] = down[i + 1][j] + 1\\n                        right[i][j] = right[i][j + 1] + 1\\n                res = max(res, min(up[i][j], left[i][j], down[i][j], right[i][j]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635673,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(N,vector(N,1));\\n        for(auto ind : mines){\\n            dp[ind[0]][ind[1]]=0;\\n        }\\n        int mx=0;\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                if(dp[i][j]==0){\\n                    continue;\\n                }\\n                if(i-mx>=0 && i+mx<N && j-mx>=0 && j+mx<N ){\\n                    int k=0;\\n                    while(i-k>=0 && i+k<N && j-k>=0 && j+k<N\\n                        && dp[i-k][j]==1\\n                        && dp[i+k][j]==1\\n                        && dp[i][j-k]==1\\n                        && dp[i][j+k]==1){\\n                        k++;\\n                    }\\n                    mx = max(k,mx);\\n                }\\n\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {\\n        vector<vector<int>> dp(N,vector(N,1));\\n        for(auto ind : mines){\\n            dp[ind[0]][ind[1]]=0;\\n        }\\n        int mx=0;\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                if(dp[i][j]==0){\\n                    continue;\\n                }\\n                if(i-mx>=0 && i+mx<N && j-mx>=0 && j+mx<N ){\\n                    int k=0;\\n                    while(i-k>=0 && i+k<N && j-k>=0 && j+k<N\\n                        && dp[i-k][j]==1\\n                        && dp[i+k][j]==1\\n                        && dp[i][j-k]==1\\n                        && dp[i][j+k]==1){\\n                        k++;\\n                    }\\n                    mx = max(k,mx);\\n                }\\n\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623971,
                "title": "o-n-2-time-o-n-2-space-clear-explanation-largest-can-fit-in-all-directions",
                "content": "![image](https://assets.leetcode.com/users/images/cd40cbc1-ec95-48e0-af27-3e2903788ca7_1664130156.3966637.png)\\n\\n\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        \"\"\" O(N^2)TS \"\"\"\\n        grid = [[1] * n for y in range(n)]\\n        for y, x in mines:\\n            grid[y][x] = 0\\n\\n        fn = lambda t: list(itertools.accumulate(t, lambda acc, n: n and acc + 1))\\n        a = list(map(fn, grid))\\n        b = [fn(row[::-1])[::-1] for row in grid]\\n        c = list(zip(*map(fn, zip(*grid))))\\n        d = list(zip(*(fn(row[::-1])[::-1] for row in zip(*grid))))\\n        \\n        return max((min((a[y][x], b[y][x], c[y][x], d[y][x])) for y, x in itertools.product(range(n), repeat=2)), default=0)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/cd40cbc1-ec95-48e0-af27-3e2903788ca7_1664130156.3966637.png)\\n\\n\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        \"\"\" O(N^2)TS \"\"\"\\n        grid = [[1] * n for y in range(n)]\\n        for y, x in mines:\\n            grid[y][x] = 0\\n\\n        fn = lambda t: list(itertools.accumulate(t, lambda acc, n: n and acc + 1))\\n        a = list(map(fn, grid))\\n        b = [fn(row[::-1])[::-1] for row in grid]\\n        c = list(zip(*map(fn, zip(*grid))))\\n        d = list(zip(*(fn(row[::-1])[::-1] for row in zip(*grid))))\\n        \\n        return max((min((a[y][x], b[y][x], c[y][x], d[y][x])) for y, x in itertools.product(range(n), repeat=2)), default=0)",
                "codeTag": "Python3"
            },
            {
                "id": 2607598,
                "title": "python-presum-binary-search",
                "content": "first compute the row-wise and column-wise presum matrix;\\nsecond, use binary search to search the k range.\\n\\n```\\ndef orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        if n==1:\\n            return 1 if not mines else 0\\n        if n==2:\\n            return 0 if len(mines)==4 else 1\\n        ## prefix row/column sum\\n        prs=[[1 for _ in range(n)] for i in range(n)]\\n        for x,y in mines:\\n            prs[x][y]=0\\n        pcs=[[a for a in line] for line in prs]\\n        for r in range(n):\\n            for j in range(1,n):\\n                prs[r][j]+=prs[r][j-1]\\n        for r in range(1,n):\\n            for j in range(n):\\n                pcs[r][j]+=pcs[r-1][j]\\n       \\n        ## verify size k plus exists or not\\n        def checkk(k):\\n            for i in range(k-1,n-k+1):\\n                for j in range(k-1,n-k+1):\\n                    rows=prs[i][j+k-1]\\n                    if n>j-k>=0:\\n                        rows-=prs[i][j-k]\\n                    if rows!=2*k-1:\\n                        continue\\n                    cols=pcs[i+k-1][j]\\n                    if i-k>=0:\\n                        cols-=pcs[i-k][j]\\n                    if cols==2*k-1:\\n                        return True\\n            return False\\n        ##\\n        left=0\\n        right=(n+1)//2\\n        while left<right:\\n            m=(left+right)//2\\n            if checkk(m):\\n                left=m+1\\n            else:\\n                right=m\\n        \\n        return left-1 if not checkk(left) else left\\n",
                "solutionTags": [],
                "code": "first compute the row-wise and column-wise presum matrix;\\nsecond, use binary search to search the k range.\\n\\n```\\ndef orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        if n==1:\\n            return 1 if not mines else 0\\n        if n==2:\\n            return 0 if len(mines)==4 else 1\\n        ## prefix row/column sum\\n        prs=[[1 for _ in range(n)] for i in range(n)]\\n        for x,y in mines:\\n            prs[x][y]=0\\n        pcs=[[a for a in line] for line in prs]\\n        for r in range(n):\\n            for j in range(1,n):\\n                prs[r][j]+=prs[r][j-1]\\n        for r in range(1,n):\\n            for j in range(n):\\n                pcs[r][j]+=pcs[r-1][j]\\n       \\n        ## verify size k plus exists or not\\n        def checkk(k):\\n            for i in range(k-1,n-k+1):\\n                for j in range(k-1,n-k+1):\\n                    rows=prs[i][j+k-1]\\n                    if n>j-k>=0:\\n                        rows-=prs[i][j-k]\\n                    if rows!=2*k-1:\\n                        continue\\n                    cols=pcs[i+k-1][j]\\n                    if i-k>=0:\\n                        cols-=pcs[i-k][j]\\n                    if cols==2*k-1:\\n                        return True\\n            return False\\n        ##\\n        left=0\\n        right=(n+1)//2\\n        while left<right:\\n            m=(left+right)//2\\n            if checkk(m):\\n                left=m+1\\n            else:\\n                right=m\\n        \\n        return left-1 if not checkk(left) else left\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2594776,
                "title": "someone-want-to-explain-how-this-test-case-is-correct",
                "content": "**Input:**\\n`n = 2`\\n`mines = [[0,0],[0,1],[1,0]]`\\n\\n**Your Output:**  `0`\\n**Expected Output:**  `1`\\n\\nThe data from this test case creates the following matrix:\\n```\\n[[0 0]\\n [0 1]]\\n ```\\n \\n Show me the plus sign.  Here is the definition of an `axis-aligned plus sign`:\\n \\n > An `axis-aligned plus sign` of 1\\'s of order k has some center grid[r][c] == 1 along with **four arms** of length k - 1 going up, down, left, and right, and made of 1\\'s\\n \\n In fact, if `n < 3`, it\\'s impossible for there to ever be any solution other than `0`.\\n \\n This is the smallest `axis-aligned plus sign` with the most possible mines where `n = 3`:\\n ```\\n[[0 1 0]\\n  [1 1 1]\\n  [0 1 0]]\\n ```\\n",
                "solutionTags": [],
                "code": "```\\n[[0 0]\\n [0 1]]\\n ```\n```\\n[[0 1 0]\\n  [1 1 1]\\n  [0 1 0]]\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2556637,
                "title": "easy-to-understand-javascript-solution-dp",
                "content": "\\tvar orderOfLargestPlusSign = function(n, mines) {\\n\\t\\tconst dp = Array(n).fill(\\'\\').map(_ => Array(n).fill(n));\\n\\n\\t\\tmines.forEach(([row, col]) => dp[row][col] = 0);\\n\\n\\t\\tfor (let row = 0; row < n; row++) {\\n\\t\\t\\tlet left = top = 0;\\n\\t\\t\\tfor (let col = 0; col < n; col++) {\\n\\t\\t\\t\\tdp[row][col] = Math.min(dp[row][col], left = dp[row][col] ? left + 1 : 0);\\n\\t\\t\\t\\tdp[col][row] = Math.min(dp[col][row], top = dp[col][row] ? top + 1 : 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (let row = 0; row < n; row++) {\\n\\t\\t\\tlet right = bottom = 0;\\n\\t\\t\\tfor (let col = n - 1; col >= 0; col--) {\\n\\t\\t\\t\\tdp[row][col] = Math.min(dp[row][col], right = dp[row][col] ? right + 1 : 0);\\n\\t\\t\\t\\tdp[col][row] = Math.min(dp[col][row], bottom = dp[col][row] ? bottom + 1 : 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn Math.max(...dp.map(col => Math.max(...col)));\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar orderOfLargestPlusSign = function(n, mines) {\\n\\t\\tconst dp = Array(n).fill(\\'\\').map(_ => Array(n).fill(n));\\n\\n\\t\\tmines.forEach(([row, col]) => dp[row][col] = 0);\\n\\n\\t\\tfor (let row = 0; row < n; row++) {\\n\\t\\t\\tlet left = top = 0;\\n\\t\\t\\tfor (let col = 0; col < n; col++) {\\n\\t\\t\\t\\tdp[row][col] = Math.min(dp[row][col], left = dp[row][col] ? left + 1 : 0);\\n\\t\\t\\t\\tdp[col][row] = Math.min(dp[col][row], top = dp[col][row] ? top + 1 : 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (let row = 0; row < n; row++) {\\n\\t\\t\\tlet right = bottom = 0;\\n\\t\\t\\tfor (let col = n - 1; col >= 0; col--) {\\n\\t\\t\\t\\tdp[row][col] = Math.min(dp[row][col], right = dp[row][col] ? right + 1 : 0);\\n\\t\\t\\t\\tdp[col][row] = Math.min(dp[col][row], bottom = dp[col][row] ? bottom + 1 : 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn Math.max(...dp.map(col => Math.max(...col)));\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2552277,
                "title": "simple-dp-approach",
                "content": "**Approach:**\\nFor every cell, let\\'s fill 4 values : up, down, left and right. Firstly we will these 4 values for every cell of grid and in the end, we will pick the minimum of left, down, right, and up height + 1.\\n\\nFor filling any side: we will fill consecutively : \\nfor eg: let\\'s fill the left value for every cell : [1, 1, 1, 0, 1]\\nleft value will goes like  [0, 1, 2, 0, 1]\\nright value will goes like [2, 1, 0, 0, 0]\\n\\nsame goes for up and down\\n```\\n// TC: O(N*N)\\n// SC: O(4*N*N)\\nclass node{\\n    public:\\n    int val = 1, up = 0, down = 0, left = 0, right = 0;\\n    node(){}\\n};\\n\\nclass Solution{\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines){\\n        node grid[n][n];\\n        \\n        // Setting mines : )\\n        for(auto it: mines){\\n            grid[it[0]][it[1]].val = 0;\\n        }\\n        \\n        // Let\\'s fill the left and right values\\n        for(int i = 0; i < n; i++){\\n            // Filling left for every valid cell.\\n            for(int j = 0; j < n; j++){\\n                auto current = grid[i][j];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We will only fill if the current cell is valid means its value is 1\\n                if(current.val){\\n                    // Here we can do + 1 instead of grid[i][j-1].val \\n                    if(j - 1 >= 0 && grid[i][j-1].val) grid[i][j].left = grid[i][j-1].val + grid[i][j-1].left;\\n                }\\n            }\\n\\n            // Filling right for every valid cell.\\n            for(int j = n-1; j >= 0; j--){\\n                auto current = grid[i][j];\\n                \\n                if(current.val){\\n                    if(j + 1 < n && grid[i][j+1].val) grid[i][j].right = grid[i][j+1].val + grid[i][j+1].right;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Let\\'s fill the up and down values\\n        for(int j = 0; j < n; j++){\\n            // Filling the up for every valid cell.\\n            for(int i = 0; i < n; i++){\\n                auto current = grid[i][j];\\n\\t\\t\\t\\t\\n                if(current.val){\\n                    if(i - 1 >= 0 && grid[i-1][j].val) grid[i][j].up = grid[i-1][j].val + grid[i-1][j].up;\\n                }\\n            }\\n            // Filling the down for every valid cell.\\n            for(int i = n-1; i >= 0; i--){\\n                auto current = grid[i][j];\\n\\t\\t\\t\\t\\n                if(current.val){\\n                    if(i + 1 < n && grid[i+1][j].val) grid[i][j].down = grid[i+1][j].val + grid[i+1][j].down;\\n                }\\n            }\\n        }\\n        int maxi = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                auto current = grid[i][j];\\n                if(current.val) maxi = max(maxi, 1 + min({current.left, current.right, current.up, current.down}));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\nDoubts, Queries & Better Approaches are most welcome",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// TC: O(N*N)\\n// SC: O(4*N*N)\\nclass node{\\n    public:\\n    int val = 1, up = 0, down = 0, left = 0, right = 0;\\n    node(){}\\n};\\n\\nclass Solution{\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines){\\n        node grid[n][n];\\n        \\n        // Setting mines : )\\n        for(auto it: mines){\\n            grid[it[0]][it[1]].val = 0;\\n        }\\n        \\n        // Let\\'s fill the left and right values\\n        for(int i = 0; i < n; i++){\\n            // Filling left for every valid cell.\\n            for(int j = 0; j < n; j++){\\n                auto current = grid[i][j];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We will only fill if the current cell is valid means its value is 1\\n                if(current.val){\\n                    // Here we can do + 1 instead of grid[i][j-1].val \\n                    if(j - 1 >= 0 && grid[i][j-1].val) grid[i][j].left = grid[i][j-1].val + grid[i][j-1].left;\\n                }\\n            }\\n\\n            // Filling right for every valid cell.\\n            for(int j = n-1; j >= 0; j--){\\n                auto current = grid[i][j];\\n                \\n                if(current.val){\\n                    if(j + 1 < n && grid[i][j+1].val) grid[i][j].right = grid[i][j+1].val + grid[i][j+1].right;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Let\\'s fill the up and down values\\n        for(int j = 0; j < n; j++){\\n            // Filling the up for every valid cell.\\n            for(int i = 0; i < n; i++){\\n                auto current = grid[i][j];\\n\\t\\t\\t\\t\\n                if(current.val){\\n                    if(i - 1 >= 0 && grid[i-1][j].val) grid[i][j].up = grid[i-1][j].val + grid[i-1][j].up;\\n                }\\n            }\\n            // Filling the down for every valid cell.\\n            for(int i = n-1; i >= 0; i--){\\n                auto current = grid[i][j];\\n\\t\\t\\t\\t\\n                if(current.val){\\n                    if(i + 1 < n && grid[i+1][j].val) grid[i][j].down = grid[i+1][j].val + grid[i+1][j].down;\\n                }\\n            }\\n        }\\n        int maxi = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                auto current = grid[i][j];\\n                if(current.val) maxi = max(maxi, 1 + min({current.left, current.right, current.up, current.down}));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540438,
                "title": "simple-and-beginner-friendly-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{1,1}));\\n        for (auto i:mines)\\n            dp[i[0]][i[1]]={0,0};\\n        int ans;\\n        if (mines.size()< n*n)\\n            ans=1;\\n        \\n        for (int i=1;i<n-1;i++){\\n            for (int j=1;j<n-1;j++){\\n                if (dp[i][j].first ==1)\\n                    dp[i][j].first =dp[i-1][j].first+1;\\n                if (dp[i][j].second ==1)\\n                    dp[i][j].second = dp[i][j-1].second +1;\\n            }\\n        }\\n        for (int i=n-2;i>0;i--){\\n            for (int j=n-2;j>0;j--){\\n                if (dp[i][j].first>0)\\n                    dp[i][j].first = min(dp[i][j].first,dp[i+1][j].first +1);\\n                if (dp[i][j].second>0)\\n                    dp[i][j].second =min(dp[i][j].second, dp[i][j+1].second +1);\\n                ans = max(ans,min(dp[i][j].first,dp[i][j].second));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{1,1}",
                "codeTag": "Java"
            },
            {
                "id": 2503224,
                "title": "javascript-dp-clean-store-minimum-streak-from-all-directions",
                "content": "```\\nfunction orderOfLargestPlusSign(n, mines) {\\n    const dp = [];\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [];\\n        for (let j = 0; j < n; j++) {\\n            dp[i][j] = Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    \\n    for (const [y, x] of mines) {\\n        dp[y][x] = 0;\\n    }\\n    \\n    let streak;\\n    \\n    for (let i = 0; i < n; i++) {\\n        streak = 0;\\n        for (let j = 0; j < n; j++) process(i, j);\\n        \\n        streak = 0;\\n        for (let j = n - 1; j >= 0; j--) process(i, j);\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        streak = 0;\\n        for (let i = 0; i < n; i++) process(i, j);\\n        \\n        streak = 0;\\n        for (let i = n - 1; i >= 0; i--) process(i, j);\\n    }\\n            \\n    function process(i, j) {\\n        streak = dp[i][j] === 0 ? 0 : streak + 1;\\n        if (streak < dp[i][j]) dp[i][j] = streak;\\n    }\\n    \\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (dp[i][j] > max) max = dp[i][j];\\n        }\\n    }\\n    \\n    return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction orderOfLargestPlusSign(n, mines) {\\n    const dp = [];\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [];\\n        for (let j = 0; j < n; j++) {\\n            dp[i][j] = Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    \\n    for (const [y, x] of mines) {\\n        dp[y][x] = 0;\\n    }\\n    \\n    let streak;\\n    \\n    for (let i = 0; i < n; i++) {\\n        streak = 0;\\n        for (let j = 0; j < n; j++) process(i, j);\\n        \\n        streak = 0;\\n        for (let j = n - 1; j >= 0; j--) process(i, j);\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        streak = 0;\\n        for (let i = 0; i < n; i++) process(i, j);\\n        \\n        streak = 0;\\n        for (let i = n - 1; i >= 0; i--) process(i, j);\\n    }\\n            \\n    function process(i, j) {\\n        streak = dp[i][j] === 0 ? 0 : streak + 1;\\n        if (streak < dp[i][j]) dp[i][j] = streak;\\n    }\\n    \\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (dp[i][j] > max) max = dp[i][j];\\n        }\\n    }\\n    \\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2501328,
                "title": "dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        // Create a HashSet for cell having 0 values using formula : n * row + col\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i = 0; i < mines.length; ++i)\\n            set.add(n * mines[i][0] + mines[i][1]);\\n        \\n        // Create a dp and fill it with Max Value\\n        int dp[][] = new int[n][n];\\n        for(int i = 0; i < n; ++i)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        // count represents prefix count and count_rev represents suffix count\\n        int count = 0;\\n        int count_rev = 0;\\n        \\n        \\n        // The intuition is to first iterate over each row and store the length of max possible horizontal line on both side for each cell\\n        for(int row = 0; row < n; ++row) {\\n            count = 0;\\n            count_rev = 0;\\n            for(int col = 0; col < n; ++col) {\\n                count = set.contains(row * n + col) ? 0 : count + 1;\\n                count_rev = set.contains(row * n + n - 1 - col) ? 0 : count_rev + 1;\\n                \\n                dp[row][col] = Math.min(dp[row][col], count);\\n                dp[row][n - 1 - col] = Math.min(dp[row][n - 1 - col], count_rev);\\n\\n            }\\n            \\n        }\\n        \\n        count = 0;\\n        count_rev = 0;\\n        \\n        // Now iterate over each column and store the length of max possible vertical line on both side of each cell\\n        // Also we have max length of horizontal line and we are calculating the max length of vertical line so we can directly find the max length of plus sign for each cell\\n        for(int col = 0; col < n; ++col) {\\n            count = 0;\\n            count_rev = 0;\\n            for(int row = 0; row < n; ++row) {\\n                count = set.contains(row * n + col) ? 0 : count + 1;\\n                count_rev = set.contains((n - 1 - row) * n + col) ? 0 : count_rev + 1;\\n                \\n                dp[row][col] = Math.min(dp[row][col], count);\\n                dp[n - 1 - row][col] = Math.min(dp[n - 1 - row][col], count_rev);\\n            }\\n        }\\n        \\n        // Iterate over the entire dp array and find the max length of plus sign\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            ans = Math.max(ans, Arrays.stream(dp[i]).max().getAsInt());\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        // Create a HashSet for cell having 0 values using formula : n * row + col\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i = 0; i < mines.length; ++i)\\n            set.add(n * mines[i][0] + mines[i][1]);\\n        \\n        // Create a dp and fill it with Max Value\\n        int dp[][] = new int[n][n];\\n        for(int i = 0; i < n; ++i)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        // count represents prefix count and count_rev represents suffix count\\n        int count = 0;\\n        int count_rev = 0;\\n        \\n        \\n        // The intuition is to first iterate over each row and store the length of max possible horizontal line on both side for each cell\\n        for(int row = 0; row < n; ++row) {\\n            count = 0;\\n            count_rev = 0;\\n            for(int col = 0; col < n; ++col) {\\n                count = set.contains(row * n + col) ? 0 : count + 1;\\n                count_rev = set.contains(row * n + n - 1 - col) ? 0 : count_rev + 1;\\n                \\n                dp[row][col] = Math.min(dp[row][col], count);\\n                dp[row][n - 1 - col] = Math.min(dp[row][n - 1 - col], count_rev);\\n\\n            }\\n            \\n        }\\n        \\n        count = 0;\\n        count_rev = 0;\\n        \\n        // Now iterate over each column and store the length of max possible vertical line on both side of each cell\\n        // Also we have max length of horizontal line and we are calculating the max length of vertical line so we can directly find the max length of plus sign for each cell\\n        for(int col = 0; col < n; ++col) {\\n            count = 0;\\n            count_rev = 0;\\n            for(int row = 0; row < n; ++row) {\\n                count = set.contains(row * n + col) ? 0 : count + 1;\\n                count_rev = set.contains((n - 1 - row) * n + col) ? 0 : count_rev + 1;\\n                \\n                dp[row][col] = Math.min(dp[row][col], count);\\n                dp[n - 1 - row][col] = Math.min(dp[n - 1 - row][col], count_rev);\\n            }\\n        }\\n        \\n        // Iterate over the entire dp array and find the max length of plus sign\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            ans = Math.max(ans, Arrays.stream(dp[i]).max().getAsInt());\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488991,
                "title": "c-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> mat(n, vector<int>(n, 1)), blocked(n, vector<int>(n, 0));\\n        for(auto &x: mines){\\n            blocked[x[0]][x[1]] = 1;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(blocked[i][j]) mat[i][j] = 0;\\n            }\\n        }\\n        int dp[n + 1][n + 1][4];\\n        for(int i = 0; i - 1 < n; i++){\\n            for(int j = 0; j - 1 < n; j++){\\n                for(int k = 0; k < 4; k++){\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }\\n        //function calculates that from every point how far can we go in each direction\\n        function<int(int, int, int)> goo = [&](int x, int y, int dir)->int{\\n            int &ans = dp[x][y][dir];\\n            if(ans != -1) return ans;\\n            if(x < 0 || y < 0 || x > n - 1 || y > n - 1 || mat[x][y] == 0) return ans = 0;\\n            if(dir == 0){\\n                if((x - 1) >= 0 && mat[x - 1][y] == 1) return ans = 1 + goo(x - 1, y, dir);\\n                return ans = 0;\\n            }else if(dir == 1){\\n                if((x + 1) <= (n - 1) && mat[x + 1][y] == 1) return ans = 1 + goo(x + 1, y, dir);\\n                return ans = 0;\\n            }else if(dir == 2){\\n                if((y - 1) >= 0 && mat[x][y - 1] == 1) return ans = 1 + goo(x, y - 1, dir);\\n                return ans = 0;\\n            }\\n            if((y + 1) <= (n - 1) && mat[x][y + 1] == 1) return ans = 1 + goo(x, y + 1, dir);\\n            return ans = 0;\\n        };\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                for(int k = 0; k < 4; k++) goo(i, j, k);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(mat[i][j] == 0) continue;\\n                else{\\n                    ans = max(ans, 1 + min({dp[i][j][0], dp[i][j][1], dp[i][j][2], dp[i][j][3]}));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> mat(n, vector<int>(n, 1)), blocked(n, vector<int>(n, 0));\\n        for(auto &x: mines){\\n            blocked[x[0]][x[1]] = 1;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(blocked[i][j]) mat[i][j] = 0;\\n            }\\n        }\\n        int dp[n + 1][n + 1][4];\\n        for(int i = 0; i - 1 < n; i++){\\n            for(int j = 0; j - 1 < n; j++){\\n                for(int k = 0; k < 4; k++){\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }\\n        //function calculates that from every point how far can we go in each direction\\n        function<int(int, int, int)> goo = [&](int x, int y, int dir)->int{\\n            int &ans = dp[x][y][dir];\\n            if(ans != -1) return ans;\\n            if(x < 0 || y < 0 || x > n - 1 || y > n - 1 || mat[x][y] == 0) return ans = 0;\\n            if(dir == 0){\\n                if((x - 1) >= 0 && mat[x - 1][y] == 1) return ans = 1 + goo(x - 1, y, dir);\\n                return ans = 0;\\n            }else if(dir == 1){\\n                if((x + 1) <= (n - 1) && mat[x + 1][y] == 1) return ans = 1 + goo(x + 1, y, dir);\\n                return ans = 0;\\n            }else if(dir == 2){\\n                if((y - 1) >= 0 && mat[x][y - 1] == 1) return ans = 1 + goo(x, y - 1, dir);\\n                return ans = 0;\\n            }\\n            if((y + 1) <= (n - 1) && mat[x][y + 1] == 1) return ans = 1 + goo(x, y + 1, dir);\\n            return ans = 0;\\n        };\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                for(int k = 0; k < 4; k++) goo(i, j, k);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(mat[i][j] == 0) continue;\\n                else{\\n                    ans = max(ans, 1 + min({dp[i][j][0], dp[i][j][1], dp[i][j][2], dp[i][j][3]}));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420985,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n\\t\\tint u[n][n], d[n][n], l[n][n], r[n][n];\\n\\n\\t\\tvector<vector<int>> grid(n, vector<int>(n, 1));\\n\\n\\t\\tfor (auto &e : mines) {\\n\\t\\t\\tgrid[e[0]][e[1]] = 0;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\tif (!grid[i][j]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl[i][j] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = n - 1; j >= 0; --j) {\\n\\t\\t\\t\\tif (!grid[i][j]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tr[i][j] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\tif (!grid[j][i]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[j][i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tu[j][i] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = n - 1; j >= 0; --j) {\\n\\t\\t\\t\\tif (!grid[j][i]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[j][i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\td[j][i] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint ans = INT_MIN;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\tans = max(ans, min(min(u[i][j], d[i][j]), min(l[i][j], r[i][j])));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n\\t\\tint u[n][n], d[n][n], l[n][n], r[n][n];\\n\\n\\t\\tvector<vector<int>> grid(n, vector<int>(n, 1));\\n\\n\\t\\tfor (auto &e : mines) {\\n\\t\\t\\tgrid[e[0]][e[1]] = 0;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\tif (!grid[i][j]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl[i][j] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = n - 1; j >= 0; --j) {\\n\\t\\t\\t\\tif (!grid[i][j]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tr[i][j] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\tif (!grid[j][i]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[j][i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tu[j][i] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = n - 1; j >= 0; --j) {\\n\\t\\t\\t\\tif (!grid[j][i]) sum = 0;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsum += grid[j][i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\td[j][i] = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint ans = INT_MIN;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\tans = max(ans, min(min(u[i][j], d[i][j]), min(l[i][j], r[i][j])));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420231,
                "title": "python-solution-with-accumulate",
                "content": "```\\nclass Solution:\\n  def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n    mat = [[1]*n for _ in range(n)]\\n    for i,j in mines:\\n      mat[i][j] = 0\\n    f = lambda a: list(accumulate(a, lambda x,y: y and x+1))\\n    right = [f(row) for row in mat]\\n    left  = [f(row[::-1])[::-1] for row in mat]\\n    down  = zip(*[f(row) for row in zip(*mat)])\\n    up    = zip(*[f(row[::-1])[::-1] for row in zip(*mat)])\\n    return max(min(cells) for rows in zip(*(up,down,left,right)) for cells in zip(*rows))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n    mat = [[1]*n for _ in range(n)]\\n    for i,j in mines:\\n      mat[i][j] = 0\\n    f = lambda a: list(accumulate(a, lambda x,y: y and x+1))\\n    right = [f(row) for row in mat]\\n    left  = [f(row[::-1])[::-1] for row in mat]\\n    down  = zip(*[f(row) for row in zip(*mat)])\\n    up    = zip(*[f(row[::-1])[::-1] for row in zip(*mat)])\\n    return max(min(cells) for rows in zip(*(up,down,left,right)) for cells in zip(*rows))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380276,
                "title": "python-4-directions-dp",
                "content": "```\\nclass Solution:\\n\\n    def orderOfLargestPlusSign(self, n: int, mines: list[list[int]]) -> int:\\n        matrix = [1] * n\\n        aux = {}\\n        hasOne = False\\n        for i in range(0,n):\\n            matrix[i] = [1] * n\\n        for mine in mines:\\n            matrix[mine[0]][mine[1]] = 0\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                if(matrix[i][j] == 1):\\n                    hasOne = True\\n                if((i,j) not in aux):\\n                    aux[(i,j)] = {\"t\":0,\"l\":0,\"r\":0,\"b\":0}\\n                if(j>0 and matrix[i][j] == 1 and matrix[i][j-1] == 1):\\n                    aux[(i,j)][\"l\"] = aux[(i,j-1)][\"l\"] + 1  \\n                if(i>0 and matrix[i][j] == 1 and matrix[i-1][j] == 1):\\n                    aux[(i,j)][\"t\"] = aux[(i-1,j)][\"t\"] + 1\\n        \\n        maxOrder = 0 \\n        for i in range(n-1,-1,-1):\\n            if(i<maxOrder):\\n                    break\\n            for j in range(n-1,-1,-1):\\n                if(j<maxOrder):\\n                    break\\n                if(j<n-1 and matrix[i][j] == 1 and matrix[i][j+1] == 1):\\n                    aux[(i,j)][\"r\"] = aux[(i,j+1)][\"r\"] + 1  \\n                if(i<n-1 and matrix[i][j] == 1 and matrix[i+1][j]):\\n                    aux[(i,j)][\"b\"] = aux[(i+1,j)][\"b\"] + 1\\n                maxOrder = max(min(aux[(i,j)][\"b\"],aux[(i,j)][\"t\"],aux[(i,j)][\"r\"],aux[(i,j)][\"l\"]),maxOrder)\\n \\n        print(maxOrder+1)\\n        return maxOrder + 1 \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\n    def orderOfLargestPlusSign(self, n: int, mines: list[list[int]]) -> int:\\n        matrix = [1] * n\\n        aux = {}\\n        hasOne = False\\n        for i in range(0,n):\\n            matrix[i] = [1] * n\\n        for mine in mines:\\n            matrix[mine[0]][mine[1]] = 0\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                if(matrix[i][j] == 1):\\n                    hasOne = True\\n                if((i,j) not in aux):\\n                    aux[(i,j)] = {\"t\":0,\"l\":0,\"r\":0,\"b\":0}\\n                if(j>0 and matrix[i][j] == 1 and matrix[i][j-1] == 1):\\n                    aux[(i,j)][\"l\"] = aux[(i,j-1)][\"l\"] + 1  \\n                if(i>0 and matrix[i][j] == 1 and matrix[i-1][j] == 1):\\n                    aux[(i,j)][\"t\"] = aux[(i-1,j)][\"t\"] + 1\\n        \\n        maxOrder = 0 \\n        for i in range(n-1,-1,-1):\\n            if(i<maxOrder):\\n                    break\\n            for j in range(n-1,-1,-1):\\n                if(j<maxOrder):\\n                    break\\n                if(j<n-1 and matrix[i][j] == 1 and matrix[i][j+1] == 1):\\n                    aux[(i,j)][\"r\"] = aux[(i,j+1)][\"r\"] + 1  \\n                if(i<n-1 and matrix[i][j] == 1 and matrix[i+1][j]):\\n                    aux[(i,j)][\"b\"] = aux[(i+1,j)][\"b\"] + 1\\n                maxOrder = max(min(aux[(i,j)][\"b\"],aux[(i,j)][\"t\"],aux[(i,j)][\"r\"],aux[(i,j)][\"l\"]),maxOrder)\\n \\n        print(maxOrder+1)\\n        return maxOrder + 1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375074,
                "title": "easy-intuitive-approach-with-4-2d-arrays-acceptable-solution-easy-to-grab",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>&m) {\\n        vector<vector<vector<int>>>dp(4, vector<vector<int>>(n, vector<int>(n, 0)));\\n        \\n        //Build the Array First-->\\n        vector<vector<int>>mines(n, vector<int>(n, 1));\\n        for(auto &x: m)\\n        {\\n            int x1=x[0], y1=x[1];\\n            mines[x1][y1]=0;\\n        }\\n        \\n        //MAKE FOUR 2D ARRAYS OF (n X n)\\n        \\n        //first array stores contiguous sum from left to right. At cell with value 0, reset the contiguous sum to 0;\\n        //second array stores longest contiguous sum from right to left till 0 is encountered. At cell with value 0, reset..!!\\n        for(int i=0;i<mines.size();i++)\\n        {\\n            for(int j=0;j<mines.size();j++)\\n            {\\n               if(mines[i][j]==0)\\n                    dp[0][i][j]=0;\\n               else dp[0][i][j]=(j-1>=0)?1+dp[0][i][j-1]:1;\\n                \\n               if(mines[i][n-j-1]==0)\\n                    dp[1][i][n-j-1]=0;\\n               else dp[1][i][n-j-1]= (n-j<n)?1+dp[1][i][n-j]:1;\\n            }  \\n        }\\n        \\n        \\n    //Third array stores contiguous sum from top to bottom. At cell with value 0, reset the contiguous sum to 0;\\n    //Fourth array stores contiguous sum from bottom to top. At cell with value 0, reset the contiguous sum to 0;\\n        \\n    for(int j=0;j<mines.size();j++)\\n      {\\n       for(int i=0;i<mines.size();i++)\\n        {\\n                if(mines[i][j]==0)\\n                    dp[2][i][j]=0;\\n                else dp[2][i][j]=i-1>=0?1+dp[2][i-1][j]:1;\\n                \\n                if(mines[n-i-1][j]==0)\\n                    dp[3][n-i-1][j]=0;\\n                else dp[3][n-i-1][j]= (n-i)<n?1+dp[3][n-i][j]:1;\\n        }\\n      }\\n   int ans=0;\\n    \\n    //Finally find the maximum of minimum at each cell value in 2D-arrays. The maximum is answer. \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int rowMin = min(dp[0][i][j], dp[1][i][j]);\\n                int colMin = min(dp[2][i][j], dp[3][i][j]);\\n                int finalMin = min(rowMin, colMin);\\n                ans= max(ans, finalMin);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>&m) {\\n        vector<vector<vector<int>>>dp(4, vector<vector<int>>(n, vector<int>(n, 0)));\\n        \\n        //Build the Array First-->\\n        vector<vector<int>>mines(n, vector<int>(n, 1));\\n        for(auto &x: m)\\n        {\\n            int x1=x[0], y1=x[1];\\n            mines[x1][y1]=0;\\n        }\\n        \\n        //MAKE FOUR 2D ARRAYS OF (n X n)\\n        \\n        //first array stores contiguous sum from left to right. At cell with value 0, reset the contiguous sum to 0;\\n        //second array stores longest contiguous sum from right to left till 0 is encountered. At cell with value 0, reset..!!\\n        for(int i=0;i<mines.size();i++)\\n        {\\n            for(int j=0;j<mines.size();j++)\\n            {\\n               if(mines[i][j]==0)\\n                    dp[0][i][j]=0;\\n               else dp[0][i][j]=(j-1>=0)?1+dp[0][i][j-1]:1;\\n                \\n               if(mines[i][n-j-1]==0)\\n                    dp[1][i][n-j-1]=0;\\n               else dp[1][i][n-j-1]= (n-j<n)?1+dp[1][i][n-j]:1;\\n            }  \\n        }\\n        \\n        \\n    //Third array stores contiguous sum from top to bottom. At cell with value 0, reset the contiguous sum to 0;\\n    //Fourth array stores contiguous sum from bottom to top. At cell with value 0, reset the contiguous sum to 0;\\n        \\n    for(int j=0;j<mines.size();j++)\\n      {\\n       for(int i=0;i<mines.size();i++)\\n        {\\n                if(mines[i][j]==0)\\n                    dp[2][i][j]=0;\\n                else dp[2][i][j]=i-1>=0?1+dp[2][i-1][j]:1;\\n                \\n                if(mines[n-i-1][j]==0)\\n                    dp[3][n-i-1][j]=0;\\n                else dp[3][n-i-1][j]= (n-i)<n?1+dp[3][n-i][j]:1;\\n        }\\n      }\\n   int ans=0;\\n    \\n    //Finally find the maximum of minimum at each cell value in 2D-arrays. The maximum is answer. \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int rowMin = min(dp[0][i][j], dp[1][i][j]);\\n                int colMin = min(dp[2][i][j], dp[3][i][j]);\\n                int finalMin = min(rowMin, colMin);\\n                ans= max(ans, finalMin);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340352,
                "title": "c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> matrix(n+1, vector<int> (n+1,1));\\n        \\n        for(int i = 0; i < mines.size(); i++)\\n            matrix[mines[i][0]][mines[i][1]] = 0;\\n        \\n        vector<vector<int>> left(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s to the left of matrix[i][j]\\n        vector<vector<int>> right(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s to the right of matrix[i][j]\\n        vector<vector<int>> up(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s upward of matrix[i][j]\\n        vector<vector<int>> down(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s downward of matrix[i][j]\\n   \\n\\t   // dp initialisation\\n        for(int i = 0; i < n; i++) {\\n            if(matrix[i][0] == 1)\\n                left[i][0] = 1;\\n            else\\n                left[i][0] = 0;\\n            \\n            if(matrix[i][n-1] == 1)\\n                right[i][n-1] = 1;\\n            else\\n                right[i][n-1] = 0;\\n        }\\n        \\n\\t\\t// dp initialisation\\n        for(int i = 0; i < n; i++) {\\n            if(matrix[0][i] == 1)\\n                up[0][i] = 1;\\n            else\\n                up[0][i] = 0;\\n            \\n            if(matrix[n-1][i] == 1)\\n                down[n-1][i] = 1;\\n            else\\n                down[n-1][i] = 0;\\n        }\\n        \\n\\t\\t// left & right dp calculation\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                if(matrix[i][j] == 1)\\n                    left[i][j] = 1 + left[i][j-1];\\n                else\\n                    left[i][j] = 0;\\n                \\n                if(matrix[i][n-j-1] == 1)\\n                    right[i][n-j-1] = 1 + right[i][n-j];\\n                else\\n                    right[i][n-j-1] = 0;\\n            }\\n        }\\n        \\n\\t\\t// up & down dp calculation\\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] == 1)\\n                    up[i][j] = 1 + up[i-1][j];\\n                else\\n                    up[i][j] = 0;\\n                \\n                if(matrix[n-i-1][j] == 1)\\n                    down[n-i-1][j] = 1 + down[n-i][j];\\n                else\\n                    down[n-i-1][j] = 0;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n\\t\\t// calculating the minimum number of left, right, up, down 1\\'s for every index (i,j) and returning the maximum value of plus sign which can be formed\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ans = max(ans,min(left[i][j],min(right[i][j],min(up[i][j],down[i][j]))));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>> matrix(n+1, vector<int> (n+1,1));\\n        \\n        for(int i = 0; i < mines.size(); i++)\\n            matrix[mines[i][0]][mines[i][1]] = 0;\\n        \\n        vector<vector<int>> left(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s to the left of matrix[i][j]\\n        vector<vector<int>> right(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s to the right of matrix[i][j]\\n        vector<vector<int>> up(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s upward of matrix[i][j]\\n        vector<vector<int>> down(n+1, vector<int>(n+1,0)); // stores maximum number of consecutive 1\\'s downward of matrix[i][j]\\n   \\n\\t   // dp initialisation\\n        for(int i = 0; i < n; i++) {\\n            if(matrix[i][0] == 1)\\n                left[i][0] = 1;\\n            else\\n                left[i][0] = 0;\\n            \\n            if(matrix[i][n-1] == 1)\\n                right[i][n-1] = 1;\\n            else\\n                right[i][n-1] = 0;\\n        }\\n        \\n\\t\\t// dp initialisation\\n        for(int i = 0; i < n; i++) {\\n            if(matrix[0][i] == 1)\\n                up[0][i] = 1;\\n            else\\n                up[0][i] = 0;\\n            \\n            if(matrix[n-1][i] == 1)\\n                down[n-1][i] = 1;\\n            else\\n                down[n-1][i] = 0;\\n        }\\n        \\n\\t\\t// left & right dp calculation\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                if(matrix[i][j] == 1)\\n                    left[i][j] = 1 + left[i][j-1];\\n                else\\n                    left[i][j] = 0;\\n                \\n                if(matrix[i][n-j-1] == 1)\\n                    right[i][n-j-1] = 1 + right[i][n-j];\\n                else\\n                    right[i][n-j-1] = 0;\\n            }\\n        }\\n        \\n\\t\\t// up & down dp calculation\\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] == 1)\\n                    up[i][j] = 1 + up[i-1][j];\\n                else\\n                    up[i][j] = 0;\\n                \\n                if(matrix[n-i-1][j] == 1)\\n                    down[n-i-1][j] = 1 + down[n-i][j];\\n                else\\n                    down[n-i-1][j] = 0;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n\\t\\t// calculating the minimum number of left, right, up, down 1\\'s for every index (i,j) and returning the maximum value of plus sign which can be formed\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ans = max(ans,min(left[i][j],min(right[i][j],min(up[i][j],down[i][j]))));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320218,
                "title": "java-clean-code",
                "content": "\\n\\n\\n\\nclass Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n       \\n        if (n == 0) return 0;\\n        \\n        int[][] grid = new int[n][n];\\n        \\n        // make grid\\n        createGrid(grid, mines, n);\\n        \\n        // do preprocessing of count of of 1 in all four direction\\n        int[][] left = new int[n][n];\\n        int[][] right = new int[n][n];\\n        int[][] up = new int[n][n];\\n        int[][] down = new int[n][n];\\n        \\n        preProcessing(grid, n, left, right, up, down);\\n        \\n        int maxLength = 0;\\n        \\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int currLength = Math.min(left[r][c], Math.min(right[r][c], Math.min(up[r][c], down[r][c])));\\n                maxLength = Math.max(maxLength, currLength);\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n    \\n    private void preProcessing(int[][] grid, int n, int[][] left, int[][] right, int[][] up, int[][] down) {\\n        preProcessLeft(grid, n, left);\\n        preProcessRight(grid, n, right);\\n        preProcessUp(grid, n, up);\\n        preProcessDown(grid, n, down);\\n    }\\n    \\n    private void preProcessLeft(int[][] grid, int n, int[][] left) {\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                 if (grid[r][c] == 0) {\\n                     left[r][c] = 0;\\n                 } else {\\n                     left[r][c] = c == 0 ? 1 : left[r][c - 1] + 1;\\n                 }\\n            }\\n        }\\n    }\\n    \\n    private void preProcessRight(int[][] grid, int n, int[][] right) {\\n        for (int r = 0; r < n; r++) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                 if (grid[r][c] == 0) {\\n                     right[r][c] = 0;\\n                 } else {\\n                     right[r][c] = c == n - 1 ? 1 : right[r][c + 1] + 1;\\n                 }\\n            }\\n        }\\n    }\\n    \\n    private void preProcessUp(int[][] grid, int n, int[][] up) {\\n        for (int c = 0; c < n; c++) {\\n            for (int r = 0; r < n; r++) {\\n                 if (grid[r][c] == 0) {\\n                     up[r][c] = 0;\\n                 } else {\\n                     up[r][c] = (r == 0) ? 1 : up[r - 1][c] + 1;\\n                 }\\n            }\\n        }\\n    }\\n    \\n    private void preProcessDown(int[][] grid, int n, int[][] down) {\\n        for (int c = 0; c < n; c++) {\\n            for (int r = n - 1; r >= 0; r--) {\\n                 if (grid[r][c] == 0) {\\n                     down[r][c] = 0;\\n                 } else {\\n                     down[r][c] = (r == n - 1) ? 1 : down[r + 1][c] + 1;\\n                 }\\n            }\\n        }\\n    }\\n    \\n    private void createGrid(int[][] grid, int[][] mines, int n) {\\n        // mark one\\n        for (int r = 0; r < n; r++) {\\n            Arrays.fill(grid[r], 1);\\n        }\\n        \\n        // mark mines\\n        for (int[] mine : mines) {\\n            int r = mine[0], c = mine[1];\\n            grid[r][c] = 0;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n       \\n        if (n == 0) return 0;\\n        \\n        int[][] grid = new int[n][n];\\n        \\n        // make grid\\n        createGrid(grid, mines, n);\\n        \\n        // do preprocessing of count of of 1 in all four direction\\n        int[][] left = new int[n][n];\\n        int[][] right = new int[n][n];\\n        int[][] up = new int[n][n];\\n        int[][] down = new int[n][n];\\n        \\n        preProcessing(grid, n, left, right, up, down);\\n        \\n        int maxLength = 0;\\n        \\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int currLength = Math.min(left[r][c], Math.min(right[r][c], Math.min(up[r][c], down[r][c])));\\n                maxLength = Math.max(maxLength, currLength);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2308578,
                "title": "python-dp",
                "content": "we have used only four dp array storing maximum number of ones in all direction and then updated in all four direction using a simple loop.\\nFinally we have taken the minimum on a certain shell in all four direction and the maximum of all the shell is required ans.\\n\\n```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        up = [[0 for x in range(n)]for x in range(n)]\\n        down=[[0 for x in range(n)]for x in range(n)]\\n        right=[[0 for x in range(n)]for x in range(n)]\\n        left=[[0 for x in range(n)]for x in range(n)]\\n        temp_mat=[[1 for x in range(n)]for x in range(n)]\\n        for x,y in mines:\\n            temp_mat[x][y]=0\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                if temp_mat[i][j]==1:\\n                    if j-1>=0:\\n                        left[i][j]=left[i][j-1]+1\\n                    else:\\n                        left[i][j]=1\\n                    if i-1>=0:\\n                        up[i][j]=up[i-1][j]+1\\n                    else:\\n                        up[i][j]=1\\n                if temp_mat[n-i-1][n-j-1]==1:\\n                    if i-1>=0:\\n                        down[n-i-1][n-j-1]=down[n-i][n-j-1]+1\\n                    else:\\n                        down[n-i-1][n-j-1]=1\\n                    if j>0:\\n                        right[n-i-1][n-j-1]=right[n-i-1][n-j]+1\\n                    else:\\n                        right[n-i-1][n-j-1]=1\\n        ans=0\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                temp=(min(up[i][j],left[i][j],down[i][j],right[i][j]))\\n                ans=max(temp,ans)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        up = [[0 for x in range(n)]for x in range(n)]\\n        down=[[0 for x in range(n)]for x in range(n)]\\n        right=[[0 for x in range(n)]for x in range(n)]\\n        left=[[0 for x in range(n)]for x in range(n)]\\n        temp_mat=[[1 for x in range(n)]for x in range(n)]\\n        for x,y in mines:\\n            temp_mat[x][y]=0\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                if temp_mat[i][j]==1:\\n                    if j-1>=0:\\n                        left[i][j]=left[i][j-1]+1\\n                    else:\\n                        left[i][j]=1\\n                    if i-1>=0:\\n                        up[i][j]=up[i-1][j]+1\\n                    else:\\n                        up[i][j]=1\\n                if temp_mat[n-i-1][n-j-1]==1:\\n                    if i-1>=0:\\n                        down[n-i-1][n-j-1]=down[n-i][n-j-1]+1\\n                    else:\\n                        down[n-i-1][n-j-1]=1\\n                    if j>0:\\n                        right[n-i-1][n-j-1]=right[n-i-1][n-j]+1\\n                    else:\\n                        right[n-i-1][n-j-1]=1\\n        ans=0\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                temp=(min(up[i][j],left[i][j],down[i][j],right[i][j]))\\n                ans=max(temp,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264703,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>grid(n,vector<int>(n,1));\\n        for(auto it:mines)\\n        {\\n            grid[it[0]][it[1]]=0;\\n        }\\n        vector<vector<int>>top(n,vector<int>(n,0));\\n        vector<vector<int>>bottom(n,vector<int>(n,0));\\n        vector<vector<int>>left(n,vector<int>(n,0));\\n        vector<vector<int>>right(n,vector<int>(n,0));\\n        //left\\n        for(int i=0;i<n;i++)\\n        {\\n            left[i][0]=1?grid[i][0]==1:0;\\n            right[i][n-1]=1?grid[i][n-1]==1:0;\\n            top[0][i]=1?grid[0][i]==1:0;\\n            bottom[n-1][i]=1?grid[n-1][i]==1:0;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[j][i]==1)\\n                    left[j][i]=left[j][i-1]+1;\\n                else\\n                    left[j][i]=0;\\n            }\\n        }\\n        //right\\n    \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[j][i]==1)\\n                    right[j][i]=right[j][i+1]+1;\\n                else\\n                    right[j][i]=0;\\n            }\\n        }\\n        //top\\n        for(int i=1;i<n;i++)\\n        {\\n        for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    top[i][j]=top[i-1][j]+1;\\n                }\\n            else\\n            {\\n                top[i][j]=0;\\n            }\\n            }\\n        }\\n        //bottom\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    bottom[i][j]=bottom[i+1][j]+1;\\n                }\\n                else\\n                {\\n                    bottom[i][j]=0;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans=max(ans,min(min(top[i][j],bottom[i][j]),min(left[i][j],right[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\\n        vector<vector<int>>grid(n,vector<int>(n,1));\\n        for(auto it:mines)\\n        {\\n            grid[it[0]][it[1]]=0;\\n        }\\n        vector<vector<int>>top(n,vector<int>(n,0));\\n        vector<vector<int>>bottom(n,vector<int>(n,0));\\n        vector<vector<int>>left(n,vector<int>(n,0));\\n        vector<vector<int>>right(n,vector<int>(n,0));\\n        //left\\n        for(int i=0;i<n;i++)\\n        {\\n            left[i][0]=1?grid[i][0]==1:0;\\n            right[i][n-1]=1?grid[i][n-1]==1:0;\\n            top[0][i]=1?grid[0][i]==1:0;\\n            bottom[n-1][i]=1?grid[n-1][i]==1:0;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[j][i]==1)\\n                    left[j][i]=left[j][i-1]+1;\\n                else\\n                    left[j][i]=0;\\n            }\\n        }\\n        //right\\n    \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[j][i]==1)\\n                    right[j][i]=right[j][i+1]+1;\\n                else\\n                    right[j][i]=0;\\n            }\\n        }\\n        //top\\n        for(int i=1;i<n;i++)\\n        {\\n        for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    top[i][j]=top[i-1][j]+1;\\n                }\\n            else\\n            {\\n                top[i][j]=0;\\n            }\\n            }\\n        }\\n        //bottom\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    bottom[i][j]=bottom[i+1][j]+1;\\n                }\\n                else\\n                {\\n                    bottom[i][j]=0;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans=max(ans,min(min(top[i][j],bottom[i][j]),min(left[i][j],right[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264639,
                "title": "simple-and-short-dp",
                "content": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        dp = [[N] * N for _ in range(N)]\\n        for r, c in mines:\\n            dp[r][c] = 0\\n        for i in range(N):\\n            l, r, t, b = 0, 0, 0, 0\\n            for j, k in zip(range(N), reversed(range(N))):\\n                l = 0 if dp[i][j] == 0 else l + 1\\n                dp[i][j] = min(dp[i][j], l)\\n                r = 0 if dp[i][k] == 0 else r + 1\\n                dp[i][k] = min(dp[i][k], r)\\n                t = 0 if dp[j][i] == 0 else t + 1\\n                dp[j][i] = min(dp[j][i], t)\\n                b = 0 if dp[k][i] == 0 else b + 1\\n                dp[k][i] = min(dp[k][i], b)\\n        return max(map(max, dp))\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\\n        dp = [[N] * N for _ in range(N)]\\n        for r, c in mines:\\n            dp[r][c] = 0\\n        for i in range(N):\\n            l, r, t, b = 0, 0, 0, 0\\n            for j, k in zip(range(N), reversed(range(N))):\\n                l = 0 if dp[i][j] == 0 else l + 1\\n                dp[i][j] = min(dp[i][j], l)\\n                r = 0 if dp[i][k] == 0 else r + 1\\n                dp[i][k] = min(dp[i][k], r)\\n                t = 0 if dp[j][i] == 0 else t + 1\\n                dp[j][i] = min(dp[j][i], t)\\n                b = 0 if dp[k][i] == 0 else b + 1\\n                dp[k][i] = min(dp[k][i], b)\\n        return max(map(max, dp))\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1935205,
                "content": [
                    {
                        "username": "alnasir7",
                        "content": "My solution passes 56/56 tescases but still get TLE?"
                    },
                    {
                        "username": "hehe666",
                        "content": "I always got TLE on this problem even my solution is O(n^2). Maybe I should try my best to reduce some hiding constants. this is a little annoying for me. \\n\\nI had this kind of experience during solving Leetcode problems before. for example, sometimes, I need to change `max(start, s) < min(end, e)`  to `start < e and s < end` to make my solution from TLE to accepted (beats about 40%)."
                    },
                    {
                        "username": "twsthomas",
                        "content": "If someone has passed all the test cases with phyton, would you mind posting your solution? \\nThank you!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "how come the test `n = 2` with mines `[[0,0]]` gives 1? I thought Plus sign must have at least 3 cells length"
                    },
                    {
                        "username": "its_rahul",
                        "content": "It may have 1, 3, 5..... ig"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me problem statement "
                    }
                ]
            },
            {
                "id": 1571846,
                "content": [
                    {
                        "username": "alnasir7",
                        "content": "My solution passes 56/56 tescases but still get TLE?"
                    },
                    {
                        "username": "hehe666",
                        "content": "I always got TLE on this problem even my solution is O(n^2). Maybe I should try my best to reduce some hiding constants. this is a little annoying for me. \\n\\nI had this kind of experience during solving Leetcode problems before. for example, sometimes, I need to change `max(start, s) < min(end, e)`  to `start < e and s < end` to make my solution from TLE to accepted (beats about 40%)."
                    },
                    {
                        "username": "twsthomas",
                        "content": "If someone has passed all the test cases with phyton, would you mind posting your solution? \\nThank you!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "how come the test `n = 2` with mines `[[0,0]]` gives 1? I thought Plus sign must have at least 3 cells length"
                    },
                    {
                        "username": "its_rahul",
                        "content": "It may have 1, 3, 5..... ig"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me problem statement "
                    }
                ]
            },
            {
                "id": 1569178,
                "content": [
                    {
                        "username": "alnasir7",
                        "content": "My solution passes 56/56 tescases but still get TLE?"
                    },
                    {
                        "username": "hehe666",
                        "content": "I always got TLE on this problem even my solution is O(n^2). Maybe I should try my best to reduce some hiding constants. this is a little annoying for me. \\n\\nI had this kind of experience during solving Leetcode problems before. for example, sometimes, I need to change `max(start, s) < min(end, e)`  to `start < e and s < end` to make my solution from TLE to accepted (beats about 40%)."
                    },
                    {
                        "username": "twsthomas",
                        "content": "If someone has passed all the test cases with phyton, would you mind posting your solution? \\nThank you!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "how come the test `n = 2` with mines `[[0,0]]` gives 1? I thought Plus sign must have at least 3 cells length"
                    },
                    {
                        "username": "its_rahul",
                        "content": "It may have 1, 3, 5..... ig"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me problem statement "
                    }
                ]
            },
            {
                "id": 1848968,
                "content": [
                    {
                        "username": "alnasir7",
                        "content": "My solution passes 56/56 tescases but still get TLE?"
                    },
                    {
                        "username": "hehe666",
                        "content": "I always got TLE on this problem even my solution is O(n^2). Maybe I should try my best to reduce some hiding constants. this is a little annoying for me. \\n\\nI had this kind of experience during solving Leetcode problems before. for example, sometimes, I need to change `max(start, s) < min(end, e)`  to `start < e and s < end` to make my solution from TLE to accepted (beats about 40%)."
                    },
                    {
                        "username": "twsthomas",
                        "content": "If someone has passed all the test cases with phyton, would you mind posting your solution? \\nThank you!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "how come the test `n = 2` with mines `[[0,0]]` gives 1? I thought Plus sign must have at least 3 cells length"
                    },
                    {
                        "username": "its_rahul",
                        "content": "It may have 1, 3, 5..... ig"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me problem statement "
                    }
                ]
            },
            {
                "id": 1781957,
                "content": [
                    {
                        "username": "alnasir7",
                        "content": "My solution passes 56/56 tescases but still get TLE?"
                    },
                    {
                        "username": "hehe666",
                        "content": "I always got TLE on this problem even my solution is O(n^2). Maybe I should try my best to reduce some hiding constants. this is a little annoying for me. \\n\\nI had this kind of experience during solving Leetcode problems before. for example, sometimes, I need to change `max(start, s) < min(end, e)`  to `start < e and s < end` to make my solution from TLE to accepted (beats about 40%)."
                    },
                    {
                        "username": "twsthomas",
                        "content": "If someone has passed all the test cases with phyton, would you mind posting your solution? \\nThank you!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "how come the test `n = 2` with mines `[[0,0]]` gives 1? I thought Plus sign must have at least 3 cells length"
                    },
                    {
                        "username": "its_rahul",
                        "content": "It may have 1, 3, 5..... ig"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me problem statement "
                    }
                ]
            }
        ]
    }
]