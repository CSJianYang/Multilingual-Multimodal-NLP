[
    {
        "title": "Range Sum of BST",
        "question_content": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\n&nbsp;\nExample 1:\n\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15\nOutput: 32\nExplanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\nExample 2:\n\nInput: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\nOutput: 23\nExplanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 2 * 104].\n\t1 <= Node.val <= 105\n\t1 <= low <= high <= 105\n\tAll Node.val are unique.",
        "solutions": [
            {
                "id": 192019,
                "title": "java-python-3-3-similar-recursive-and-1-iterative-methods-w-comment-analysis",
                "content": "Three similar recursive and one iterative methods, choose one you like.\\n\\n**Method 1:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        if (root.val < L) return rangeSumBST(root.right, L, R); // left branch excluded.\\n        if (root.val > R) return rangeSumBST(root.left, L, R); // right branch excluded.\\n        return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); // count in both children.\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        elif root.val > R:\\n            return self.rangeSumBST(root.left, L, R)\\n        return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n```\\nThe following are two more similar recursive codes.\\n\\n**Method 2:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        return (L <= root.val && root.val <= R ? root.val : 0) + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R);\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        return self.rangeSumBST(root.left, L, R) + \\\\\\n                self.rangeSumBST(root.right, L, R) + \\\\\\n                (root.val if L <= root.val <= R else 0)\\n```\\n**Method 3:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) { return 0; }\\n        int sum = 0;\\n        if (root.val > L) { sum += rangeSumBST(root.left, L, R); } // left child is a possible candidate.\\n        if (root.val < R) { sum += rangeSumBST(root.right, L, R); } // right child is a possible candidate.\\n        if (root.val >= L && root.val <= R) { sum += root.val; } // count root in.\\n        return sum;\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        sum = 0\\n        if root.val > L:\\n            sum += self.rangeSumBST(root.left, L, R)\\n        if root.val < R:\\n            sum += self.rangeSumBST(root.right, L, R)\\n        if L <= root.val <= R:\\n            sum += root.val     \\n        return sum\\n```\\n\\n**Method 4: Iterative version**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        stk.push(root);\\n        int sum = 0;\\n        while (!stk.isEmpty()) {\\n            TreeNode n = stk.pop();\\n            if (n == null) { continue; }\\n            if (n.val > L) { stk.push(n.left); } // left child is a possible candidate.\\n            if (n.val < R) { stk.push(n.right); } // right child is a possible candidate.\\n            if (L <= n.val && n.val <= R) { sum += n.val; }\\n        }\\n        return sum;\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        stk, sum = [root], 0\\n        while stk:\\n            node = stk.pop()\\n            if node:\\n                if node.val > L:\\n                    stk.append(node.left)    \\n                if node.val < R:\\n                    stk.append(node.right)\\n                if L <= node.val <= R:\\n                    sum += node.val    \\n        return sum\\n```\\n**Analysis:**\\n\\nAll 4 methods will DFS traverse all nodes in worst case, and if we count in the recursion trace space cost, the complexities are as follows:\\n\\n**Time: O(n), space: O(h)**, where `n` is the number of total nodes, `h` is the height of the tree..",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        if (root.val < L) return rangeSumBST(root.right, L, R); // left branch excluded.\\n        if (root.val > R) return rangeSumBST(root.left, L, R); // right branch excluded.\\n        return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); // count in both children.\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        elif root.val > R:\\n            return self.rangeSumBST(root.left, L, R)\\n        return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        return (L <= root.val && root.val <= R ? root.val : 0) + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R);\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        return self.rangeSumBST(root.left, L, R) + \\\\\\n                self.rangeSumBST(root.right, L, R) + \\\\\\n                (root.val if L <= root.val <= R else 0)\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) { return 0; }\\n        int sum = 0;\\n        if (root.val > L) { sum += rangeSumBST(root.left, L, R); } // left child is a possible candidate.\\n        if (root.val < R) { sum += rangeSumBST(root.right, L, R); } // right child is a possible candidate.\\n        if (root.val >= L && root.val <= R) { sum += root.val; } // count root in.\\n        return sum;\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        sum = 0\\n        if root.val > L:\\n            sum += self.rangeSumBST(root.left, L, R)\\n        if root.val < R:\\n            sum += self.rangeSumBST(root.right, L, R)\\n        if L <= root.val <= R:\\n            sum += root.val     \\n        return sum\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        stk.push(root);\\n        int sum = 0;\\n        while (!stk.isEmpty()) {\\n            TreeNode n = stk.pop();\\n            if (n == null) { continue; }\\n            if (n.val > L) { stk.push(n.left); } // left child is a possible candidate.\\n            if (n.val < R) { stk.push(n.right); } // right child is a possible candidate.\\n            if (L <= n.val && n.val <= R) { sum += n.val; }\\n        }\\n        return sum;\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        stk, sum = [root], 0\\n        while stk:\\n            node = stk.pop()\\n            if node:\\n                if node.val > L:\\n                    stk.append(node.left)    \\n                if node.val < R:\\n                    stk.append(node.right)\\n                if L <= node.val <= R:\\n                    sum += node.val    \\n        return sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205181,
                "title": "java-4-lines-beats-100",
                "content": "```\\n public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        if(root.val > R) return rangeSumBST(root.left, L, R);\\n        if(root.val < L) return rangeSumBST(root.right, L, R);\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        if(root.val > R) return rangeSumBST(root.left, L, R);\\n        if(root.val < L) return rangeSumBST(root.right, L, R);\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 596106,
                "title": "c-easy-explaination-step-by-step-100",
                "content": "```\\n/*I ll be giving as much details as possible as to what s going on in the recursion stack.\\nLets take the binary tree to be [10,5,15,3,7,null,18]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t/\\\\\\n\\t\\t\\t\\t\\t  5  15\\n\\t\\t\\t\\t\\t /\\\\   \\\\\\n\\t\\t\\t       3  7   18\\ndo your inorder traversal as routine\\n                                                                      sum = 0\\n                    |   3      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    we reach the NULL condition of the traversal\\n            as 3 has no left or right nodes a sum of 0 is passed to 3       3    <-\\n                                                                           /  \\\\    \\\\\\n                                                                         NULL  NULL 0\\n           3 is popped out of the stack ans analyzed\\n                    |          |  3\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n            but as 3 < 7 (L)\\n            sum value is not changed                                   sum=0\\n            then 7 is pushed into the stack\\n                    |   7      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n            as 7 has no leaf nodes inorder(root->left) = NULL\\n                                   sum+=7(as 7 is in the range)       sum=7\\n                                   inorder(root->right) = NULL\\n                                   sum=7 is passed to the call stack\\n                    |          |  7\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                Now as both the left and right nodes are visited 5 is analyzed.\\n                inorder(root->left) = 5\\n                But since 5 is not in the range sum value doesnt change.\\n                Now 5 is popped out of the stack.\\n                    |          |   5   \\n                    |          |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    inorder(rot->right)  continues excecution.\\n                    |   18     |  \\n                    |   15     |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n                    18 has no childeren thus sum=7 is passed on to the root.\\n                    18 is not in the range so sum doesnt change.\\n                    this process continues and 15 gets added to the sum giving sum=22\\n                    then 10 gets added  sum=32\\n                    */\\n     int sum=0;\\n    int inorder(TreeNode* root,int L,int R)\\n    {\\n        if(root){\\n        inorder(root->left,L,R);\\n        if(root->val>=L && root->val<=R)\\n            sum+=root->val;\\n        inorder(root->right,L,R);\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root)return 0;\\n        return inorder(root,L,R);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*I ll be giving as much details as possible as to what s going on in the recursion stack.\\nLets take the binary tree to be [10,5,15,3,7,null,18]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t/\\\\\\n\\t\\t\\t\\t\\t  5  15\\n\\t\\t\\t\\t\\t /\\\\   \\\\\\n\\t\\t\\t       3  7   18\\ndo your inorder traversal as routine\\n                                                                      sum = 0\\n                    |   3      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    we reach the NULL condition of the traversal\\n            as 3 has no left or right nodes a sum of 0 is passed to 3       3    <-\\n                                                                           /  \\\\    \\\\\\n                                                                         NULL  NULL 0\\n           3 is popped out of the stack ans analyzed\\n                    |          |  3\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n            but as 3 < 7 (L)\\n            sum value is not changed                                   sum=0\\n            then 7 is pushed into the stack\\n                    |   7      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n            as 7 has no leaf nodes inorder(root->left) = NULL\\n                                   sum+=7(as 7 is in the range)       sum=7\\n                                   inorder(root->right) = NULL\\n                                   sum=7 is passed to the call stack\\n                    |          |  7\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                Now as both the left and right nodes are visited 5 is analyzed.\\n                inorder(root->left) = 5\\n                But since 5 is not in the range sum value doesnt change.\\n                Now 5 is popped out of the stack.\\n                    |          |   5   \\n                    |          |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    inorder(rot->right)  continues excecution.\\n                    |   18     |  \\n                    |   15     |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n                    18 has no childeren thus sum=7 is passed on to the root.\\n                    18 is not in the range so sum doesnt change.\\n                    this process continues and 15 gets added to the sum giving sum=22\\n                    then 10 gets added  sum=32\\n                    */\\n     int sum=0;\\n    int inorder(TreeNode* root,int L,int R)\\n    {\\n        if(root){\\n        inorder(root->left,L,R);\\n        if(root->val>=L && root->val<=R)\\n            sum+=root->val;\\n        inorder(root->right,L,R);\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root)return 0;\\n        return inorder(root,L,R);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936480,
                "title": "python-simple-dfs-explained",
                "content": "One way to solve this problem is just iterate over our tree and for each element check if it is range or not. However here we are given, that out tree is `BST`, that is left subtree is always lesser than node lesser than right subtree. So, let us modify classical `dfs` a bit, where we traverse only nodes we need:\\n\\n1. Check value `node.val` and if it is in our range, add it to global sum.\\n2. We need to visit left subtree only if `node.val > low`, that is if `node.val < low`, it means, that all nodes in left subtree less than `node.val`, that is less than `low` as well.\\n3. Similarly, we visit right subtree only if `node.val < high`.\\n\\n**Complexity**: time complexity is `O(n)`, where `n` is nubmer of nodes in our tree, space complexity potentially `O(n)` as well. We can impove our estimations a bit and say, that time and space is `O(m)`, where `m` is number of nodes in our answer.\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        def dfs(node):\\n            if not node: return\\n            if low <= node.val <= high: self.out += node.val\\n            if node.val > low:  dfs(node.left)\\n            if node.val < high: dfs(node.right)\\n                \\n        self.out = 0\\n        dfs(root)\\n        return self.out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        def dfs(node):\\n            if not node: return\\n            if low <= node.val <= high: self.out += node.val\\n            if node.val > low:  dfs(node.left)\\n            if node.val < high: dfs(node.right)\\n                \\n        self.out = 0\\n        dfs(root)\\n        return self.out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409173,
                "title": "clean-and-fast-94-4-line-python3-code",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if root == None: return 0\\n        if root.val > R: return self.rangeSumBST(root.left,L,R)\\n        if root.val < L: return self.rangeSumBST(root.right,L,R)\\n        return root.val + self.rangeSumBST(root.left,L,R) + self.rangeSumBST(root.right,L,R)      \\n                   \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if root == None: return 0\\n        if root.val > R: return self.rangeSumBST(root.left,L,R)\\n        if root.val < L: return self.rangeSumBST(root.right,L,R)\\n        return root.val + self.rangeSumBST(root.left,L,R) + self.rangeSumBST(root.right,L,R)      \\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628229,
                "title": "c-python-simple-solution-w-explanation-dfs-bfs-w-optimizations-o-1-morris",
                "content": "We are given a BST and range `[L, H]`. We need to return sum of all nodes between this range.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Simple DFS)***\\n\\nWe can perform a simple DFS traversal over the tree and if the current node\\'s value is within the range `[L, H]`, then we will add it to the final sum. The same process can be carried out recursively till whole tree is explored.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        return  (root -> val >= L && root -> val <= H ? root -> val : 0) +  // add root\\'s value if it lies within [L, H]\\n                rangeSumBST(root -> left, L, H) +   // recurse left\\n                rangeSumBST(root -> right, L, H);   // recurse right\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        return  (root.val if root.val >= L and root.val <= H else 0) + \\\\\\n                self.rangeSumBST(root.left, L, H) + \\\\\\n                self.rangeSumBST(root.right, L, H)\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the number of nodes in the given tree\\n***Space Complexity :*** `O(H)`, where `H` is the height of the tree. This is required for recursive stack. In case of skewed tree, this would be `O(N)`, while in case of balanced tree, this would be `O(logN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (BST Optimized DFS)***\\n\\nIn the above solution, we aren\\'t taking the advantage of the fact that our given tree is a BST. We can reduce the search space in some cases by doing conditional recursion. \\n* If the root\\'s value is less than `L`, then it\\'s useless to further recurse the left sub-tree because we know that every node in left sub-tree will be less than `L` as well. **So iterate `root -> left` only when `root -> val > L`**\\n* Similarly, if root\\'s value is greater than `H`, we must not further recurse the right sub-tree. **So iterate `root -> right` only when `root -> val < H`**\\n\\nThe above two conditional checks help prune some recursive branches and thus optimize the solution slightly. Note that the time complexity still remains the same as the range can cover all nodes of BST.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        int ans = root -> val >= L && root -> val <= H ? root -> val : 0;\\n        if(root -> val > L) ans += rangeSumBST(root -> left, L, H);\\n        if(root -> val < H) ans += rangeSumBST(root -> right, L, H);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        ans = root.val if root.val >= L and root.val <= H else 0\\n        if root.val > L: ans += self.rangeSumBST(root.left, L, H)\\n        if root.val < H: ans += self.rangeSumBST(root.right, L, H)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, more specifically, this solution would only iterate the nodes which lie within the range `[L, H]`\\n***Space Complexity :*** `O(H)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BST Optimized BFS)***\\n\\nThe same thing can be done using BFS traversal as well. Similar to above approach, we will only push a left or right child into queue if the root\\'s value is `> L` or `< H` respectively\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* T, int L, int H) {\\n        queue<TreeNode*> q;\\n        q.push(T);\\n        int sum = 0, v;\\n        while(size(q)) {\\n            T = q.front(); q.pop();\\n            v = T -> val;\\n            if(v >= L and v <= H)   sum += v;\\n            if(v > L && T -> left)  q.push(T -> left);\\n            if(v < H && T -> right) q.push(T -> right);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, T, L, H):\\n        q, ans, v = deque([T]), 0, 0\\n        while q:\\n            T = q.popleft()\\n            v = T.val\\n            if v >= L and v <= H:  ans += v\\n            if v > L and T.left:   q.append(T.left)\\n            if v < H and T.right:  q.append(T.right)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(W)`, where `W` is the width of BST. In case of skewed tree, it will be `O(1)` and in case of balanced tree it will be `O(N/2) ~ O(N)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Morris Traversal)***\\n\\nWe can also use the Morris traversal (using the inorder version in this case) to optimze on space. I have also made some modification to prune further searches where we know that required node wont be found. You can read more on morris traversal **[here](https://leetcode.com/problems/binary-tree-inorder-traversal/solution/)** and **[here](https://stackoverflow.com/questions/5502916)**.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // finding predecessor of root\\n                while(pre -> right && pre -> val <= H) pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                pre -> right = root;        // adding temporary link\\n                auto tmp = root;\\n                root = root -> left;                    \\n                tmp -> left = nullptr;      // avoiding inifinte loop\\n            }\\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                if(root -> val < H) root = root -> right;\\n                else break;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThe above version modifies the tree. The following can be used if tree modification is not allowed- \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // find predecessor of root\\n                while(pre -> right && pre -> right != root)  pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                if(!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;                    \\n                }\\n                else {                    \\n                    if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                    pre -> right = nullptr;  // revert the changes - remove temporary link\\n                    root = root -> right;\\n                }\\n            } \\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                root = root -> right;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThe 1st version is optimized to prune redundant search wherever possible, but I guess the 2nd version only prunes left branches. If there\\'s a more optimized version of morris traversal that restores the tree as well, do comment below...\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(1)`, only constant space is being used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        return  (root -> val >= L && root -> val <= H ? root -> val : 0) +  // add root\\'s value if it lies within [L, H]\\n                rangeSumBST(root -> left, L, H) +   // recurse left\\n                rangeSumBST(root -> right, L, H);   // recurse right\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        return  (root.val if root.val >= L and root.val <= H else 0) + \\\\\\n                self.rangeSumBST(root.left, L, H) + \\\\\\n                self.rangeSumBST(root.right, L, H)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        int ans = root -> val >= L && root -> val <= H ? root -> val : 0;\\n        if(root -> val > L) ans += rangeSumBST(root -> left, L, H);\\n        if(root -> val < H) ans += rangeSumBST(root -> right, L, H);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        ans = root.val if root.val >= L and root.val <= H else 0\\n        if root.val > L: ans += self.rangeSumBST(root.left, L, H)\\n        if root.val < H: ans += self.rangeSumBST(root.right, L, H)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* T, int L, int H) {\\n        queue<TreeNode*> q;\\n        q.push(T);\\n        int sum = 0, v;\\n        while(size(q)) {\\n            T = q.front(); q.pop();\\n            v = T -> val;\\n            if(v >= L and v <= H)   sum += v;\\n            if(v > L && T -> left)  q.push(T -> left);\\n            if(v < H && T -> right) q.push(T -> right);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, T, L, H):\\n        q, ans, v = deque([T]), 0, 0\\n        while q:\\n            T = q.popleft()\\n            v = T.val\\n            if v >= L and v <= H:  ans += v\\n            if v > L and T.left:   q.append(T.left)\\n            if v < H and T.right:  q.append(T.right)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // finding predecessor of root\\n                while(pre -> right && pre -> val <= H) pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                pre -> right = root;        // adding temporary link\\n                auto tmp = root;\\n                root = root -> left;                    \\n                tmp -> left = nullptr;      // avoiding inifinte loop\\n            }\\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                if(root -> val < H) root = root -> right;\\n                else break;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // find predecessor of root\\n                while(pre -> right && pre -> right != root)  pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                if(!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;                    \\n                }\\n                else {                    \\n                    if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                    pre -> right = nullptr;  // revert the changes - remove temporary link\\n                    root = root -> right;\\n                }\\n            } \\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                root = root -> right;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127563,
                "title": "0ms-java-solution-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374212,
                "title": "javascript-solution",
                "content": "```\\nvar rangeSumBST = function(root, L, R) {\\n    var sum = 0;\\n    if (root == null) {\\n        return sum;\\n    }\\n\\n    if (root.val > L) {\\n        sum += rangeSumBST(root.left, L, R);\\n    }\\n    if (root.val <= R && root.val >= L) {\\n        sum += root.val;\\n    }\\n    if (root.val < R) {\\n        sum += rangeSumBST(root.right, L, R);    \\n    }    \\n    \\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n    var sum = 0;\\n    if (root == null) {\\n        return sum;\\n    }\\n\\n    if (root.val > L) {\\n        sum += rangeSumBST(root.left, L, R);\\n    }\\n    if (root.val <= R && root.val >= L) {\\n        sum += root.val;\\n    }\\n    if (root.val < R) {\\n        sum += rangeSumBST(root.right, L, R);    \\n    }    \\n    \\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 498058,
                "title": "100-00-fast-in-memory-and-run-time-dfs-recursive-iterative-solution",
                "content": "Compare yourself, as the different ways are below: satisfied? \\nDon\\'t look at runtime, as this may change time to time on each submission. Have a look at optimized approach.\\n\\n-------\\nRuntime: 84 ms, faster than 98.75% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.1 MB, less than 99.09% of C++ online submissions for Range Sum of BST.\\nIf root\\'s value is greater than L then move left, and if it\\'s value if less than R then move right.\\nTime Complexity: **O(N)**, where N is the number of nodes in the tree.\\nSpace Complexity: **O(H)**, where H is the height of the tree. i.e. **O(1)**\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* node = st.top(); st.pop();\\n            if(node->val>=L && node->val<=R) rangeSum+=node->val;\\n            if(node->val > L) {if(node->left) st.push(node->left);}\\n            if(node->val < R) {if(node->right) st.push(node->right);}\\n        }\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n---------------\\nTime Complexity **O(n)** & Space Complexity **O(n)**\\nRuntime: 96 ms, faster than 95.88% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.1 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n        return ((root->val>=L && root->val<=R)? root->val : 0) + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n    }\\n};\\n```\\n\\n---------------\\nRuntime: 80 ms, faster than 92.88% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n    return ((root->val>=L && root->val<=R)? (root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R)) : (root->val<L)? rangeSumBST(root->right,L,R): rangeSumBST(root->left,L,R));\\n    }\\n};\\n```\\n\\n--------------\\nRuntime: 92 ms, faster than 96.85% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 89.09% of C++ online submissions for Range Sum of BST.\\n```\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root, int L, int R, int rangeSum){\\n        if(!root) return 0;\\n        else if(root->val>=L && root->val<=R){\\n            rangeSum+=helper(root->left,L,R,0);\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum + root->val;\\n        }else if(root->val > L){\\n            rangeSum+=helper(root->left,L,R,0);\\n            return rangeSum;\\n        }else if(root->val < R){\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum;\\n        }\\n        return 0;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        std::ios::sync_with_stdio(false);\\n        return helper(root,L,R,0);\\n    }\\n};\\n```\\n\\n-----------------\\nRuntime: 92 ms, faster than 96.92% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 86.36% of C++ online submissions for Range Sum of BST.\\nSolution: **We traverse the tree using a depth first search. If node.val falls outside the range [L, R], (for example node.val < L), then we know that only the right branch could have nodes with value inside [L, R].**\\nTC: **O(n)**, SC: **O(n)**\\n```\\nclass Solution { // dfs\\nprivate:\\n    int rangeSum;\\npublic:\\n    void dfs(TreeNode* root, int L, int R){\\n        if(!root) return;\\n        if(root->val>=L && root->val<=R) rangeSum+=root->val;\\n        if(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        rangeSum = 0;\\n        dfs(root,L,R);\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n----------------------\\nRuntime: 148 ms, faster than 76.44% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 88.18% of C++ online submissions for Range Sum of BST.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int &rangeSum, int L, int R, bool isDone){\\n        if(!root || isDone) return;\\n        dfs(root->left,rangeSum,L,R,false);\\n        if(root->val>=L && root->val<=R){\\n            rangeSum+=root->val;\\n            if(root->val==R) isDone = true;\\n        }\\n        dfs(root->right,rangeSum,L,R,false);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        dfs(root,rangeSum,L,R,false);\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n--------\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* node = st.top(); st.pop();\\n            if(node->val>=L && node->val<=R) rangeSum+=node->val;\\n            if(node->val > L) {if(node->left) st.push(node->left);}\\n            if(node->val < R) {if(node->right) st.push(node->right);}\\n        }\\n        return rangeSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n        return ((root->val>=L && root->val<=R)? root->val : 0) + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n    return ((root->val>=L && root->val<=R)? (root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R)) : (root->val<L)? rangeSumBST(root->right,L,R): rangeSumBST(root->left,L,R));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root, int L, int R, int rangeSum){\\n        if(!root) return 0;\\n        else if(root->val>=L && root->val<=R){\\n            rangeSum+=helper(root->left,L,R,0);\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum + root->val;\\n        }else if(root->val > L){\\n            rangeSum+=helper(root->left,L,R,0);\\n            return rangeSum;\\n        }else if(root->val < R){\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum;\\n        }\\n        return 0;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        std::ios::sync_with_stdio(false);\\n        return helper(root,L,R,0);\\n    }\\n};\\n```\n```\\nclass Solution { // dfs\\nprivate:\\n    int rangeSum;\\npublic:\\n    void dfs(TreeNode* root, int L, int R){\\n        if(!root) return;\\n        if(root->val>=L && root->val<=R) rangeSum+=root->val;\\n        if(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        rangeSum = 0;\\n        dfs(root,L,R);\\n        return rangeSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int &rangeSum, int L, int R, bool isDone){\\n        if(!root || isDone) return;\\n        dfs(root->left,rangeSum,L,R,false);\\n        if(root->val>=L && root->val<=R){\\n            rangeSum+=root->val;\\n            if(root->val==R) isDone = true;\\n        }\\n        dfs(root->right,rangeSum,L,R,false);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        dfs(root,rangeSum,L,R,false);\\n        return rangeSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885368,
                "title": "python3-dfs-one-liner-recursive-iterative-explained",
                "content": "**One-liner**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```\\n\\n**Recursive 1** (more readable)\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root: \\n            return 0\\n        \\n        # When value is less than low, everything on it\\'s left doesn\\'t matter, \\n        # so only return the sum from its right children\\n        if root.val<low: \\n            return self.rangeSumBST(root.right,low,high)\\n        \\n        # Same thing for high.\\n        elif root.val>high: \\n            return self.rangeSumBST(root.left,low,high)\\n        \\n        # The current value is in the range, so return the sum of its left, right and own value\\n        else:\\n            return root.val + self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high)\\n```\\n\\n**Recursive 2**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        def dfs(node):\\n            nonlocal res\\n            if not node: return\\n            \\n            # increase res only when the node value is in the range\\n            if low<=node.val<=high: res += node.val\\n            \\n            # The only time we don\\'t want to go left, is when the nodel value <= low.\\n            # Because it is a BST, and if the current value is aleady <= low, \\n            # there is no more hope!\\n            if node.val>low: dfs(node.left)\\n            \\n            # Same as above, but going right\\n            if node.val<high: dfs(node.right)\\n\\n        dfs(root)\\n        return res\\n```\\n\\n**Iterative** (same idea as Recursive 2)\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        q = [root]\\n        while q:\\n            cur = q.pop()\\n            if cur:\\n                if low <= cur.val <= high:\\n                    res += cur.val\\n                if cur.val > low:\\n                    q.append(cur.left)\\n                if cur.val < high:\\n                    q.append(cur.right)\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root: \\n            return 0\\n        \\n        # When value is less than low, everything on it\\'s left doesn\\'t matter, \\n        # so only return the sum from its right children\\n        if root.val<low: \\n            return self.rangeSumBST(root.right,low,high)\\n        \\n        # Same thing for high.\\n        elif root.val>high: \\n            return self.rangeSumBST(root.left,low,high)\\n        \\n        # The current value is in the range, so return the sum of its left, right and own value\\n        else:\\n            return root.val + self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high)\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        def dfs(node):\\n            nonlocal res\\n            if not node: return\\n            \\n            # increase res only when the node value is in the range\\n            if low<=node.val<=high: res += node.val\\n            \\n            # The only time we don\\'t want to go left, is when the nodel value <= low.\\n            # Because it is a BST, and if the current value is aleady <= low, \\n            # there is no more hope!\\n            if node.val>low: dfs(node.left)\\n            \\n            # Same as above, but going right\\n            if node.val<high: dfs(node.right)\\n\\n        dfs(root)\\n        return res\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        q = [root]\\n        while q:\\n            cur = q.pop()\\n            if cur:\\n                if low <= cur.val <= high:\\n                    res += cur.val\\n                if cur.val > low:\\n                    q.append(cur.left)\\n                if cur.val < high:\\n                    q.append(cur.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251711,
                "title": "cpp-beats-96-better-than-o-n-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n      \\n      if(!root) return 0;\\n      \\n      if(root->val >= L && root->val <= R){\\n        return root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n      }else if(root->val < L){\\n        return rangeSumBST(root->right,L,R);\\n      }else {\\n        return rangeSumBST(root->left,L,R);\\n      }\\n    }\\n  \\n  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n      \\n      if(!root) return 0;\\n      \\n      if(root->val >= L && root->val <= R){\\n        return root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n      }else if(root->val < L){\\n        return rangeSumBST(root->right,L,R);\\n      }else {\\n        return rangeSumBST(root->left,L,R);\\n      }\\n    }\\n  \\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192018,
                "title": "c-2-lines",
                "content": "Just doing regular tree traversal and adding values within [L, R]. Note that in the solution description, we are given BST, however, this solution  works for any binary tree.\\n\\nOf course, we can optimize a bit for the fact that this is BST. I checked the runtime and did not see any difference in the runtime. Both naive and optimized solution gave me 68 ms.\\n```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;\\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;\\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1627913,
                "title": "c-easy-to-solve-detailed-explanation-while-optimizing-approach",
                "content": "**Intuition:**\\nActually the question is pretty straightforward ,Basically the question maker is asking us to  add all the numbers in a BST with a certain range given for numbers like say range is given as  [Low,High]=[2,7] then we need to add all the values in BST with the numbers satisfying this range. So major people who thought of a solution will be either using  recursion ,DFS or BFS.\\n*Now, let\\'s talk about approach*\\n\\n**Algorithm:**\\nIn the following algorithm we will be discussing the solution of dfs approach .\\n1. let` sumofRange` be a variable that will be our final result . After this let\\'s declare a dfs helper function .\\n2. The base case will be when the tree is empty so we return null\\n3. we have to find the` sumofRange` so for that we need to add all the root values which satisfyes the condition that `node values should be more than low and less than high` .If this is true than add it to `sumofRange`\\n4. After this let\\'s dig the depth\\'s of the tree i.e Left childs and Right childs.\\n5. Now just call out the dfs helper function in the main function \\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    int sumofRange;\\n    void dfs(TreeNode* root, int L, int R){\\n\\t\\t//Base case\\n        if(!root) return;\\n\\t\\t//If in range add \\n        if(root->val >= L && root->val <= R) sumofRange += root->val;\\n        //Digging the depths of the tree\\n\\t\\tif(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        sumofRange = 0;\\n        dfs(root,L,R);\\n        return sumofRange;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(n) [n=number of nodes]`*\\n**Space Complexity:** *`O(h) [h=height of tree] [Considering recursive calls]`*\\n\\n\\n**Space Optimized Approach:**\\nAfter exploring some other options, I found that we can actually optimize the space.\\nThe logic is almost same as we discussed in the above approach .The main difference is that we use a stack for storing the data of nodes . So everytime we can just peek and pop the last values that we entered\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int sumofRange(0);\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* node = stack.top(); stack.pop();\\n            if(node->val>=L && node->val<=R) sumofRange+=node->val;\\n            if(node->val > L) {if(node->left) stack.push(node->left);}\\n            if(node->val < R) {if(node->right) stack.push(node->right);}\\n        }\\n        return sumofRange;\\n    }\\n};\\n```\\n\\n**Time Complexity:** *`O(n) [n=number of nodes]`*\\n**Space Complexity:** *`O(h) [h=height of the tree]`*\\n\\n\\n........*continuation from previous posts..\\nTill now in the Discovery of Dr.Cheems Ancient Ruins arc.. A sudden discovery of algorithm created a rift a humans mind who discovered this algos and from where this algo\\'s came. After some investigation they found out that there was certaing identity in ancient time known as Dr.Cheems Doge who was renowed for his intelligence. After inspecting a bit more they found out that at a certain place there was ancient ruins of his lab. The excavation of the ruins happened under a group of 5 great archeologists.A mysterious call came to seize the excavation but they didn\\'t stop. After some excavation the doors started vibrating and changed colors also a mysterious passcode panel came front...\\nTo be continued in the next post*.........\\n\\n**Feel free to comment and upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofRange;\\n    void dfs(TreeNode* root, int L, int R){\\n\\t\\t//Base case\\n        if(!root) return;\\n\\t\\t//If in range add \\n        if(root->val >= L && root->val <= R) sumofRange += root->val;\\n        //Digging the depths of the tree\\n\\t\\tif(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        sumofRange = 0;\\n        dfs(root,L,R);\\n        return sumofRange;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int sumofRange(0);\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* node = stack.top(); stack.pop();\\n            if(node->val>=L && node->val<=R) sumofRange+=node->val;\\n            if(node->val > L) {if(node->left) stack.push(node->left);}\\n            if(node->val < R) {if(node->right) stack.push(node->right);}\\n        }\\n        return sumofRange;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349978,
                "title": "python-use-visualization-help-you-think-about-it",
                "content": "1. L = 7, R = 15, sum=32:\\n```\\n         *10\\n         /  \\\\\\n       *5    *15\\n       / \\\\     \\\\\\n      3   *7    18\\n```\\n\\t  \\n2.  L = 6, R = 10, sum=23 :\\n```\\n\\t            *10\\n               /    \\\\\\n              5      15\\n             / \\\\     / \\\\\\n            3   *7  13  18\\n           /   /\\n         1    *6\\n\\n```\\n```\\nclass Solution(object):\\n    def rangeSumBST(self, root, L, R):\\n        def dfs(node):\\n            if node:\\n                if L<= node.val <= R:\\n                    self.ans += node.val\\n                    #print(node.val)\\n                if node.val>L:\\n                    dfs(node.left)\\n                if node.val<R:\\n                    dfs(node.right)\\n        self.ans = 0\\n        dfs(root)\\n        return self.ans\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n         *10\\n         /  \\\\\\n       *5    *15\\n       / \\\\     \\\\\\n      3   *7    18\\n```\n```\\n\\t            *10\\n               /    \\\\\\n              5      15\\n             / \\\\     / \\\\\\n            3   *7  13  18\\n           /   /\\n         1    *6\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193702,
                "title": "javascript-2-solutions-easy-to-understand-beats-100",
                "content": "1. Sum while recursing through the tree\\n```\\nvar rangeSumBST = function(root, L, R) {\\n    // base case\\n    if(root == null) {\\n        return 0;\\n    }\\n    \\n    if(root.val > R) {\\n        return rangeSumBST(root.left, L, R);\\n    } else if(root.val < L) {\\n        return rangeSumBST(root.right, L, R);\\n    } else {\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n};\\n```\\n\\n2. Do inorder traversal to get all nodes on tree in order, and then sum all values >= L and <=R. This is less efficient than previous solution because we are traversing all nodes, but this can be easier to understand.\\n```\\nvar rangeSumBST = function(root, L, R) {\\n    var arr = [], sum=0;\\n    inorder(root, arr);\\n    \\n    for(var i=0; i<arr.length; i++) {\\n        if(arr[i] >= L && arr[i] <= R) {\\n            sum = sum + arr[i];\\n        }\\n    }\\n    \\n    return sum;\\n};\\n\\nvar inorder = function(root, arr) {\\n    if(root == null) {\\n        return;\\n    }\\n    \\n    inorder(root.left, arr);\\n    arr.push(root.val);\\n    inorder(root.right, arr);\\n \\n    return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n    // base case\\n    if(root == null) {\\n        return 0;\\n    }\\n    \\n    if(root.val > R) {\\n        return rangeSumBST(root.left, L, R);\\n    } else if(root.val < L) {\\n        return rangeSumBST(root.right, L, R);\\n    } else {\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n};\\n```\n```\\nvar rangeSumBST = function(root, L, R) {\\n    var arr = [], sum=0;\\n    inorder(root, arr);\\n    \\n    for(var i=0; i<arr.length; i++) {\\n        if(arr[i] >= L && arr[i] <= R) {\\n            sum = sum + arr[i];\\n        }\\n    }\\n    \\n    return sum;\\n};\\n\\nvar inorder = function(root, arr) {\\n    if(root == null) {\\n        return;\\n    }\\n    \\n    inorder(root.left, arr);\\n    arr.push(root.val);\\n    inorder(root.right, arr);\\n \\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193235,
                "title": "python3-easy-to-understand-inorder-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return self.inorder(root, 0, L, R)\\n            \\n    def inorder(self, root, value, L, R):\\n        if root:\\n            value = self.inorder(root.left, value, L, R)\\n            if root.val >= L and root.val <= R:\\n                value += root.val\\n            value = self.inorder(root.right, value, L, R)\\n        \\n        return value\\n```\\n\\n**UPDATE**\\nWe may optimize this by setting the \\n```\\nif root.val >= L and root.val <= R:\\n``` \\nas\\n```\\nif root.val > R:\\n\\treturn value\\nelif root.val >= L:\\n\\tvalue += root.val\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return self.inorder(root, 0, L, R)\\n            \\n    def inorder(self, root, value, L, R):\\n        if root:\\n            value = self.inorder(root.left, value, L, R)\\n            if root.val >= L and root.val <= R:\\n                value += root.val\\n            value = self.inorder(root.right, value, L, R)\\n        \\n        return value\\n```\n```\\nif root.val >= L and root.val <= R:\\n```\n```\\nif root.val > R:\\n\\treturn value\\nelif root.val >= L:\\n\\tvalue += root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320320,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, L, R) {\\n    // check if value is in the given range\\n    const isInBetween = val => val >= L && val <= R;\\n    // sum the value if it\\'s in the range\\n    const add = (val, sum) => isInBetween(val) ? sum += val : sum;\\n\\t// traverse through the nodes and sum the values in range\\n    const preorder =(root, sum) => {\\n        if (!root) return sum;\\n        return add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\\n    } \\n    return preorder(root, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, L, R) {\\n    // check if value is in the given range\\n    const isInBetween = val => val >= L && val <= R;\\n    // sum the value if it\\'s in the range\\n    const add = (val, sum) => isInBetween(val) ? sum += val : sum;\\n\\t// traverse through the nodes and sum the values in range\\n    const preorder =(root, sum) => {\\n        if (!root) return sum;\\n        return add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\\n    } \\n    return preorder(root, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885382,
                "title": "python-c-java-dfs-bfs-binary-search-explained-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs conditional traversal of a Binary Search Tree. Time complexity is linear: **O(N)**. Space complexity is logarithmic (for a balanced tree): **O(logN)**.\\n****\\n\\n**Comment.** Binary Search Tree (BST) is a type of binary tree for which the left (right) subtree of each node is also a BST with all values being less (greater) than the node\\'s value. This defines a recursive strategy to compute range sums, namely:\\n1. Take node\\'s value if it\\'s in range. \\n2. If node\\'s value is greater than the lower bound then search for valid values in the left subtree.\\n3. If node\\'s value is less than the upper bound then search for valid values in the right subtree.\\n\\n**Python #1.** DFS.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root : return 0\\n        \\n        s = root.val if low <= root.val <= high else 0\\n        if low  <= root.val : s += self.rangeSumBST(root.left,  low, high)\\n        if high >= root.val : s += self.rangeSumBST(root.right, low, high)\\n        \\n        return s\\n```\\n\\n**Python #2.** BFS.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        dq, s = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if low  <= node.val <= high        : s += node.val\\n            if low  <= node.val and node.left  : dq.append(node.left)\\n            if high >= node.val and node.right : dq.append(node.right)\\n        return s\\n```\\n\\nThere is also a more expensive, however, interesting approach. \\n\\n**Python #3.** Collect values in order then binary search.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def inorder(n, v):\\n            if n: inorder(n.left, v), v.append(n.val), inorder(n.right, v)\\n        \\n        vals = []\\n        inorder(root, vals)\\n        \\n        return sum(vals[bisect_left(vals, low) : bisect_right(vals, high)])\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/2RVvrN38/shared\" frameBorder=\"0\" width=\"800\" height=\"260\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** DFS one-liner.\\n```\\nclass Solution:\\n    def rangeSumBST(self, r, l, h):\\n        \\n        return 0 if not r else (l <= r.val <= h) * r.val + \\\\\\n                               self.rangeSumBST(r.right, l, h) + \\\\\\n                               self.rangeSumBST(r.left,  l, h)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root : return 0\\n        \\n        s = root.val if low <= root.val <= high else 0\\n        if low  <= root.val : s += self.rangeSumBST(root.left,  low, high)\\n        if high >= root.val : s += self.rangeSumBST(root.right, low, high)\\n        \\n        return s\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        dq, s = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if low  <= node.val <= high        : s += node.val\\n            if low  <= node.val and node.left  : dq.append(node.left)\\n            if high >= node.val and node.right : dq.append(node.right)\\n        return s\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def inorder(n, v):\\n            if n: inorder(n.left, v), v.append(n.val), inorder(n.right, v)\\n        \\n        vals = []\\n        inorder(root, vals)\\n        \\n        return sum(vals[bisect_left(vals, low) : bisect_right(vals, high)])\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, r, l, h):\\n        \\n        return 0 if not r else (l <= r.val <= h) * r.val + \\\\\\n                               self.rangeSumBST(r.right, l, h) + \\\\\\n                               self.rangeSumBST(r.left,  l, h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703641,
                "title": "python-2-elegant-solutions-recursive-and-iterative",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            if node.val < L: return dfs(node.right)\\n            elif node.val > R: return dfs(node.left)\\n            else: return dfs(node.left) + dfs(node.right) + node.val\\n        return dfs(root)\\n        \\n        ## APPROACH : ITERATIVE ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        stack = [root]\\n        ans = 0\\n        while(stack):\\n            node = stack.pop()\\n            if node:\\n                if L <= node.val <= R: ans += node.val\\n                if L < node.val: stack.append(node.left)\\n                if R > node.val: stack.append(node.right)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            if node.val < L: return dfs(node.right)\\n            elif node.val > R: return dfs(node.left)\\n            else: return dfs(node.left) + dfs(node.right) + node.val\\n        return dfs(root)\\n        \\n        ## APPROACH : ITERATIVE ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        stack = [root]\\n        ans = 0\\n        while(stack):\\n            node = stack.pop()\\n            if node:\\n                if L <= node.val <= R: ans += node.val\\n                if L < node.val: stack.append(node.left)\\n                if R > node.val: stack.append(node.right)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192011,
                "title": "c-recursion",
                "content": "    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root || L > R)\\n            return 0;\\n        \\n        if(root->val < L)\\n            return rangeSumBST(root->right, L, R);\\n        \\n        if(root->val > R)\\n            return rangeSumBST(root->left, L, R);\\n        \\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    }",
                "solutionTags": [],
                "code": "    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root || L > R)\\n            return 0;\\n        \\n        if(root->val < L)\\n            return rangeSumBST(root->right, L, R);\\n        \\n        if(root->val > R)\\n            return rangeSumBST(root->left, L, R);\\n        \\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 480481,
                "title": "simple-recursive-solution-faster-than-96",
                "content": "```\\nconst rangeSumBST = (root, L, R) => {\\n    let sum = 0;\\n    const traverse = (root) => {\\n        if (root.val >= L && root.val <= R) sum += root.val;\\n        if (root.left !== null) traverse(root.left);\\n        if (root.right !== null) traverse(root.right);\\n    }\\n    traverse(root);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst rangeSumBST = (root, L, R) => {\\n    let sum = 0;\\n    const traverse = (root) => {\\n        if (root.val >= L && root.val <= R) sum += root.val;\\n        if (root.left !== null) traverse(root.left);\\n        if (root.right !== null) traverse(root.right);\\n    }\\n    traverse(root);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192148,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        return root and self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) + (L <= root.val <= R) * root.val or 0\\n```\\n* More readable\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        if not root: return 0\\n        l = self.rangeSumBST(root.left, L, R)\\n        r = self.rangeSumBST(root.right, L, R)\\n        return l + r + (L <= root.val <= R) * root.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        return root and self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) + (L <= root.val <= R) * root.val or 0\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        if not root: return 0\\n        l = self.rangeSumBST(root.left, L, R)\\n        r = self.rangeSumBST(root.right, L, R)\\n        return l + r + (L <= root.val <= R) * root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192020,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.val >= L && root.val <= R) {\\n            return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n        } else if (root.val < L) {\\n            return rangeSumBST(root.right, L, R);\\n        } else {\\n            return rangeSumBST(root.left, L, R);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.val >= L && root.val <= R) {\\n            return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n        } else if (root.val < L) {\\n            return rangeSumBST(root.right, L, R);\\n        } else {\\n            return rangeSumBST(root.left, L, R);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097555,
                "title": "simple-easy-to-understand-java-0-ms-faster-than-100-00-using-dfs-clean-code-with-comment",
                "content": "```\\n\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294243,
                "title": "python-beat-90-simple-solution",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val >= L and root.val <= R:\\n            return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        else:\\n            return self.rangeSumBST(root.left, L, R)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val >= L and root.val <= R:\\n            return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        else:\\n            return self.rangeSumBST(root.left, L, R)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628107,
                "title": "java-dfs-bst-specific-0ms-can-merge-into-one-line",
                "content": "Original codes:\\n```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null)\\n        \\treturn 0;\\n        int val = 0, left = 0, right = 0;\\n        if (root.val >= low && root.val <= high)\\n            val = root.val;\\n        if (root.val > low)\\n        \\tleft = rangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n        \\tright = rangeSumBST(root.right, low, high);\\n        return val + left + right;\\n    }\\n```\\nOne line of codes (seperate to multiple lines for easy-understanding):\\n```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n    \\treturn root == null ? 0 :\\n    \\t\\t   (root.val >= low && root.val <= high ? root.val : 0) +\\n    \\t\\t   (root.val > low  ? rangeSumBST(root.left,  low, high) : 0) + \\n    \\t\\t   (root.val < high ? rangeSumBST(root.right, low, high) : 0);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null)\\n        \\treturn 0;\\n        int val = 0, left = 0, right = 0;\\n        if (root.val >= low && root.val <= high)\\n            val = root.val;\\n        if (root.val > low)\\n        \\tleft = rangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n        \\tright = rangeSumBST(root.right, low, high);\\n        return val + left + right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213314,
                "title": "python-3-faster-than-99-54-simple-solution",
                "content": "````\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        if root:\\n            if root.val<low:\\n                return self.rangeSumBST(root.right,low,high)\\n            elif root.val>high:\\n                return self.rangeSumBST(root.left,low,high)\\n            return root.val + self.rangeSumBST(root.left,low,high) + self.rangeSumBST(root.right,low,high)\\n        else:\\n            return 0",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "````\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        if root:\\n            if root.val<low:\\n                return self.rangeSumBST(root.right,low,high)\\n            elif root.val>high:\\n                return self.rangeSumBST(root.left,low,high)\\n            return root.val + self.rangeSumBST(root.left,low,high) + self.rangeSumBST(root.right,low,high)\\n        else:\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 339587,
                "title": "c-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void inorder(TreeNode* root, int L, int R){\\n        if(root->left)inorder(root->left, L, R);\\n        if(root->val>=L && root->val<=R)sum+=root->val;\\n        if(root->right)inorder(root->right, L, R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        \\n        //SOLUCHAN STARTS HERE - DUN DUN DUN DUN \\n        inorder(root, L, R);\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void inorder(TreeNode* root, int L, int R){\\n        if(root->left)inorder(root->left, L, R);\\n        if(root->val>=L && root->val<=R)sum+=root->val;\\n        if(root->right)inorder(root->right, L, R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        \\n        //SOLUCHAN STARTS HERE - DUN DUN DUN DUN \\n        inorder(root, L, R);\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193674,
                "title": "jave-easy-to-understand-2ms-solution-tree-pruning",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        helper(root, L, R);\\n        return sum;\\n    }\\n    \\n    public void helper(TreeNode root, int L, int R){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.val <= R && root.val >= L){\\n            sum += root.val;\\n            helper(root.left, L, R);\\n            helper(root.right, L, R);\\n        }else if(root.val < L){\\n            helper(root.right, L, R); //no need to go left since the left branch must be smaller than L\\n        }else{ //root great than R\\n            helper(root.left, L, R); //no need to go right since the right branch must be larger than R\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        helper(root, L, R);\\n        return sum;\\n    }\\n    \\n    public void helper(TreeNode root, int L, int R){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.val <= R && root.val >= L){\\n            sum += root.val;\\n            helper(root.left, L, R);\\n            helper(root.right, L, R);\\n        }else if(root.val < L){\\n            helper(root.right, L, R); //no need to go left since the left branch must be smaller than L\\n        }else{ //root great than R\\n            helper(root.left, L, R); //no need to go right since the right branch must be larger than R\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580124,
                "title": "javascript-simple-dfs-solution",
                "content": "Runtime: 148 ms, faster than 98.20% of JavaScript online submissions for Range Sum of BST.\\nMemory Usage: 66.8 MB, less than 100.00% of JavaScript online submissions for Range Sum of BST.\\n```\\nfunction rangeSumBST(root, l, r) {\\n  let sum = 0\\n  dfs(root)\\n  return sum\\n  \\n  function dfs(node) {\\n    if (!node) {\\n      return\\n    }\\n    \\n    if (node.val < l) {\\n      dfs(node.right)\\n      return\\n    }\\n    \\n    if (node.val > r) {\\n      dfs(node.left)\\n      return\\n    }\\n\\n    sum += node.val\\n    dfs(node.left)\\n    dfs(node.right)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction rangeSumBST(root, l, r) {\\n  let sum = 0\\n  dfs(root)\\n  return sum\\n  \\n  function dfs(node) {\\n    if (!node) {\\n      return\\n    }\\n    \\n    if (node.val < l) {\\n      dfs(node.right)\\n      return\\n    }\\n    \\n    if (node.val > r) {\\n      dfs(node.left)\\n      return\\n    }\\n\\n    sum += node.val\\n    dfs(node.left)\\n    dfs(node.right)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886115,
                "title": "c-using-preorder-traversal-explained",
                "content": "# Intuition\\nAs we know we need to find the sum between the ranges , so very first thing that comes in our mind is to check all the nodes one by one any try out.... (Using Recursion Do the Traversal)\\n\\n# Approach\\n1. build a rescursive function to call check each node of BST\\n2. if my node current value lies under the given ranges then I\\'ll take that into my sum\\n3. Contuniue calling recursively untill the tree is not finished\\n4. Return the sum between ranges\\n\\n# Complexity\\n- **Time complexity: O(n)**  -> here n is number of nodes\\n\\n- **Space complexity: O(n)**  -> stack space of recursion\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void find(TreeNode* root,int low,int high,int& sum)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n\\n        find(root->left,low,high,sum);\\n        find(root->right,low,high,sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum = 0;\\n        find(root,low,high,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(TreeNode* root,int low,int high,int& sum)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n\\n        find(root->left,low,high,sum);\\n        find(root->right,low,high,sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum = 0;\\n        find(root,low,high,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724024,
                "title": "python-3-300ms-simple-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        s=0\\n        if root.val>=low and root.val<=high:\\n            s=s+root.val\\n        s=s+self.rangeSumBST(root.left,low,high)\\n        s=s+self.rangeSumBST(root.right,low,high)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        s=0\\n        if root.val>=low and root.val<=high:\\n            s=s+root.val\\n        s=s+self.rangeSumBST(root.left,low,high)\\n        s=s+self.rangeSumBST(root.right,low,high)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192579,
                "title": "python-solution",
                "content": "DFS recursive:\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            if L <= root.val <= R:\\n                self.res += root.val\\n            if L <= root.val:\\n                dfs(root.left)\\n            if R >= root.val:\\n                dfs(root.right)\\n        self.res = 0\\n        dfs(root)\\n        return self.res\\n```\\nDFS iterative:\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        stack = [root]\\n        res = 0\\n        while stack:\\n            u = stack.pop()\\n            if L <= u.val <= R:\\n                res += u.val\\n            if u.left and u.val >= L:\\n                stack.append(u.left)\\n            if u.right and u.val <= R:\\n                stack.append(u.right)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            if L <= root.val <= R:\\n                self.res += root.val\\n            if L <= root.val:\\n                dfs(root.left)\\n            if R >= root.val:\\n                dfs(root.right)\\n        self.res = 0\\n        dfs(root)\\n        return self.res\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        stack = [root]\\n        res = 0\\n        while stack:\\n            u = stack.pop()\\n            if L <= u.val <= R:\\n                res += u.val\\n            if u.left and u.val >= L:\\n                stack.append(u.left)\\n            if u.right and u.val <= R:\\n                stack.append(u.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886005,
                "title": "7th-december-daily-challenge-leetcode",
                "content": "# Intuition\\nMy Very First intuition to solve this approach was to traverse the tree in inorder manner, I did that and stored values of each Node in a seperate array and then traversed the array to sum up values following the given constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBut then I made a little change in the Inorder Traversal Algorithm and rather than to store in another array I updated the sums variable(variable storing my answer) at that place and then simply returned the sums variable storing my anser.\\nNote: I defined a class variable sums to store my answer, so that I can update its value in a helper function findSum from inside the function.\\n\\nNote: The findSum function I used is simply a modified version of Inorder Traversal Function\\n\\nVote up if this Helps!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is same as that of inorder traversal, that is O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf we consider the size of the stack for function calls then O(h + 1) and one is added for sums variable, where h is the height of the tree.\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    sums = 0\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        def findSum(root):\\n            if root:\\n                findSum(root.left)\\n                if root.val <= high and root.val >= low:\\n                    self.sums += root.val\\n                findSum(root.right)\\n        findSum(root)\\n        \\n        return self.sums\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    sums = 0\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        def findSum(root):\\n            if root:\\n                findSum(root.left)\\n                if root.val <= high and root.val >= low:\\n                    self.sums += root.val\\n                findSum(root.right)\\n        findSum(root)\\n        \\n        return self.sums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885406,
                "title": "python-3-6-lines-two-versions-w-explanation-t-m-98-92",
                "content": "A binary *search* tree is more than just a binary tree. For each node *node*, every node value in `node`\\'s left tree is less than `node.val`, and every node value in `node`\\'s right tree is greater than `node.val`.\\n\\nHere\\'s the plan:\\n- Traverse the tree recursively or iteratively, and at each node visited, return the sum of all qualifying node values in its two subtrees. However, for any `node`:\\n\\n- If `node.val` is less than `low`, then we know that each value in node\\'s left subtree is also less than `low`; if so, we do not need to traverse *node*\\'s left subtree.\\n- Likewise, If `node.val` is greater than `high`, then we know that each value in `node`\\'s right subtree is also greater than `high`; if so, we do not need to traverse `node`\\'s right subtree.\\n\\nHere is the recursive version\\n\\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        def dfs(node):\\n\\n            if not node: return 0\\n\\n            if node.val <  low: return dfs(node.right)\\n            if node.val > high: return dfs(node.left )\\n            \\n            return dfs(node.left ) + dfs(node.right) + node.val\\n\\n        return dfs(root)\\n```\\n[https://leetcode.com/problems/range-sum-of-bst/submissions/855830563/](http://)\\n\\n\\n\\nI could be wrong, but I think that, worst-case, time is *O*(*N*) and space is *O*(*N*).\\n\\nHere\\'s the iterative version:\\n\\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        ans, stack = 0, deque([root])\\n\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n\\n            if   node.val <  low: stack.append(node.right)\\n            elif node.val > high: stack.append(node.left )\\n            else:\\n                ans+= node.val\\n                stack.append(node.left )\\n                stack.append(node.right)\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        def dfs(node):\\n\\n            if not node: return 0\\n\\n            if node.val <  low: return dfs(node.right)\\n            if node.val > high: return dfs(node.left )\\n            \\n            return dfs(node.left ) + dfs(node.right) + node.val\\n\\n        return dfs(root)\\n```\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        ans, stack = 0, deque([root])\\n\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n\\n            if   node.val <  low: stack.append(node.right)\\n            elif node.val > high: stack.append(node.left )\\n            else:\\n                ans+= node.val\\n                stack.append(node.left )\\n                stack.append(node.right)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548320,
                "title": "c-solution-recursive-6-lines-easy-to-understand",
                "content": "**If the solution helps,please do consider upvoting it.**\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        if(!root)\\n            return 0;\\n       if(root->val>high)\\n           return rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        return root->val +rangeSumBST(root->left,low,high) +rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        if(!root)\\n            return 0;\\n       if(root->val>high)\\n           return rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        return root->val +rangeSumBST(root->left,low,high) +rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535543,
                "title": "java-recursive-and-iterative",
                "content": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0;\\n        if (root.val <= L) return rangeSumBST(root.right, L, R) + (root.val == L ? root.val : 0);\\n        if (root.val >= R) return rangeSumBST(root.left, L, R) + (root.val == R ? root.val : 0);\\n        return rangeSumBST(root.left, L, R) + root.val + rangeSumBST(root.right, L, R);\\n    }\\n```\\n\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> st = new Stack<>();\\n        st.add(root);\\n        int sum = 0;\\n        while (!st.isEmpty()){\\n            TreeNode n = st.pop();\\n            if (n == null) continue;\\n            if (n.val >= L && n.val <= R) sum += n.val;\\n            if (n.val > L) st.push(n.left);\\n            if (n.val < R) st.push(n.right);\\n        }\\n        return sum;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0;\\n        if (root.val <= L) return rangeSumBST(root.right, L, R) + (root.val == L ? root.val : 0);\\n        if (root.val >= R) return rangeSumBST(root.left, L, R) + (root.val == R ? root.val : 0);\\n        return rangeSumBST(root.left, L, R) + root.val + rangeSumBST(root.right, L, R);\\n    }\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> st = new Stack<>();\\n        st.add(root);\\n        int sum = 0;\\n        while (!st.isEmpty()){\\n            TreeNode n = st.pop();\\n            if (n == null) continue;\\n            if (n.val >= L && n.val <= R) sum += n.val;\\n            if (n.val > L) st.push(n.left);\\n            if (n.val < R) st.push(n.right);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480659,
                "title": "c-solution",
                "content": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (!root) {\\n        return 0;\\n    }\\n    if(root->val<L){\\n        return rangeSumBST(root->right, L, R);\\n    }\\n    if(root->val>R){\\n        return rangeSumBST(root->left, L, R);\\n    }\\n    return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (!root) {\\n        return 0;\\n    }\\n    if(root->val<L){\\n        return rangeSumBST(root->right, L, R);\\n    }\\n    if(root->val>R){\\n        return rangeSumBST(root->left, L, R);\\n    }\\n    return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885975,
                "title": "easy-java-solution-using-recursion",
                "content": "\\n\\n```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        rangeSum(root,low,high);\\n        return sum;\\n        \\n    }\\n        \\n    public void rangeSum(TreeNode root,int low,int high){\\n        \\n        if(root != null){\\n           \\n        if(low <= root.val && root.val <= high ){\\n            sum +=root.val;\\n        }\\n        if(low < root.val  )\\n            rangeSum(root.left,low,high);\\n\\n        if(root.val <= high )\\n            rangeSum(root.right,low,high);\\n        \\n        \\n    }\\n        \\n    }\\n}\\n```\\n## \\n## Please Upvote if it helped.\\n## Thanks",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        rangeSum(root,low,high);\\n        return sum;\\n        \\n    }\\n        \\n    public void rangeSum(TreeNode root,int low,int high){\\n        \\n        if(root != null){\\n           \\n        if(low <= root.val && root.val <= high ){\\n            sum +=root.val;\\n        }\\n        if(low < root.val  )\\n            rangeSum(root.left,low,high);\\n\\n        if(root.val <= high )\\n            rangeSum(root.right,low,high);\\n        \\n        \\n    }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885967,
                "title": "c-inorder-traversal-intuitive-approach",
                "content": "# Intuition\\nInorder traversal of BST returns nodes in sorted order.\\n\\n# Approach\\nWhile sorting nodes by using inorder traversal, we sum up all the nodes values lies between the range.\\n\\n# Complexity\\n- Time complexity: O(N) \\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void inorder(TreeNode* node, int &low, int &high, int &sum)\\n    {\\n        if(!node) return;\\n        inorder(node->left, low, high, sum);\\n        if(node->val >= low && node->val <= high) sum += node->val;\\n        inorder(node->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum=0;\\n        inorder(root, low, high, sum);\\n        return sum;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void inorder(TreeNode* node, int &low, int &high, int &sum)\\n    {\\n        if(!node) return;\\n        inorder(node->left, low, high, sum);\\n        if(node->val >= low && node->val <= high) sum += node->val;\\n        inorder(node->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum=0;\\n        inorder(root, low, high, sum);\\n        return sum;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021676,
                "title": "python-easy-explanation-2-methods",
                "content": "```\\nPlatform: leetcode.com\\n938. Range Sum of BST\\nLink: https://leetcode.com/problems/range-sum-of-bst/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 17/1/2021\\nSubmission: https://leetcode.com/submissions/detail/444136335/\\n(Time, Space) Complexity : O(n), O(H)\\n\\nRange sum of BST \\n\\n1.  We can solve this problem using recursion and iteration \\n\\niteration                                  Recursion \\n1. implemented using loops                  1. implemented using function calls \\n2. Defined by the control variable          2. Defined by the parameter value in the stack\\nvalue  \\n3. iteration makes size of Code            3. Recursion decreses the size of code\\nbigger                                      \\n4. Loop ends when control variable          4. Recursion ends when base case are True\\nsatisfy the condition \\n5. Infinite loops uses CPU Cycle            5. Infinite Recursion cause stack overflow at particular point or might crash the system\\n6. Execution is faster                      6. Execution is slower\\n```\\n\\n# Method 01 \\n# Inorder traversal ( Left child , Node , Right child)\\n\\n**Disadvantage of using Inorder traversal method**\\n\\n1. Using this approach we are visiting at each node of the binary tree and we are not utilizing the benefit of binary tree.\\n\\n2. Time: O(n), space: O(h), where n is the number of total nodes, h is the height of the tree.\\n\\n\\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\n\\t\\t# Left \\n        self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node \\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\t\\n\\t\\t# Right\\n        self.inOrderTraversal(root.right, low,high,output)\\n\\n```\\n\\nSo what we do when we search a particular number in a binary tree\\n\\nfirst we check if a number is less then a root, if yes then we search in left subtree else if it\\'s greater then we search in right subtree of root node\\n\\nsame here, we see \\n```\\n1. if low < root :\\n\\t\\t inOrderTraversal( root.left, low, high)\\n\\n2. if High > root :\\n\\t\\t inOrderTraversal( root.right, low, high)     \\n```\\n\\n# Method 02 \\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\t\\n\\t\\t# left \\n        if low<root.val:\\n            self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node\\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\n\\t\\t# RIght \\n        if high>root.val:\\n            self.inOrderTraversal(root.right, low,high,output)\\n```\\n\\n# Method 03 \\n## Same Logic but reduction in line of code\\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        total = 0\\n        if root==None:\\n            return 0\\n        if low <= root.val <= high:\\n            total +=root.val\\n        if low<root.val:\\n            total += self.rangeSumBST(root.left, low,high)\\n        if high>root.val:\\n            total += self.rangeSumBST(root.right, low,high)\\n        \\n        return total \\n```\\n\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nPlatform: leetcode.com\\n938. Range Sum of BST\\nLink: https://leetcode.com/problems/range-sum-of-bst/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 17/1/2021\\nSubmission: https://leetcode.com/submissions/detail/444136335/\\n(Time, Space) Complexity : O(n), O(H)\\n\\nRange sum of BST \\n\\n1.  We can solve this problem using recursion and iteration \\n\\niteration                                  Recursion \\n1. implemented using loops                  1. implemented using function calls \\n2. Defined by the control variable          2. Defined by the parameter value in the stack\\nvalue  \\n3. iteration makes size of Code            3. Recursion decreses the size of code\\nbigger                                      \\n4. Loop ends when control variable          4. Recursion ends when base case are True\\nsatisfy the condition \\n5. Infinite loops uses CPU Cycle            5. Infinite Recursion cause stack overflow at particular point or might crash the system\\n6. Execution is faster                      6. Execution is slower\\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\n\\t\\t# Left \\n        self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node \\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\t\\n\\t\\t# Right\\n        self.inOrderTraversal(root.right, low,high,output)\\n\\n```\n```\\n1. if low < root :\\n\\t\\t inOrderTraversal( root.left, low, high)\\n\\n2. if High > root :\\n\\t\\t inOrderTraversal( root.right, low, high)     \\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\t\\n\\t\\t# left \\n        if low<root.val:\\n            self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node\\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\n\\t\\t# RIght \\n        if high>root.val:\\n            self.inOrderTraversal(root.right, low,high,output)\\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        total = 0\\n        if root==None:\\n            return 0\\n        if low <= root.val <= high:\\n            total +=root.val\\n        if low<root.val:\\n            total += self.rangeSumBST(root.left, low,high)\\n        if high>root.val:\\n            total += self.rangeSumBST(root.right, low,high)\\n        \\n        return total \\n```",
                "codeTag": "Java"
            },
            {
                "id": 939761,
                "title": "java-dfs-bfs-with-explanation",
                "content": "**DFS**\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        int sum = root.val <= high && root.val >= low ? root.val : 0;\\n        int left = 0;\\n        int right = 0;\\n        if(root.left != null){\\n            left = rangeSumBST(root.left,low,high);\\n        } \\n        if(root.right != null){\\n            right = rangeSumBST(root.right, low, high);\\n        }\\n        return sum + left + right;\\n    }\\n}\\n```\\n**BFS**\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root); // add root node\\n        int sum = 0;\\n        while(!q.isEmpty()){\\n            int itr = q.size();\\n            while(itr > 0){\\n                TreeNode dummy = q.poll();\\n                sum += (dummy.val >= low && dummy.val <= high) ? dummy.val : 0;\\n                if(dummy.left != null)\\n                    q.add(dummy.left);\\n                if(dummy.right != null)\\n                    q.add(dummy.right);\\n                itr--;\\n            }\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\\n   \\n**PROBLEM OVERVIEW**\\nWe are essentially tasked with finding the sum of all nodes whose values are between the inclusive range [low,high].\\n\\n**SOLUTION ASSESSMENT**\\nThe first things that come to mind are any tree-traversla algorithms (I have an inclination to utilize DFS or BFS, and I will show both approaches)\\n\\n**PSEUDOCODE RECURSION DFS**\\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n1. If(root == null) return 0;\\n2. sum = node.val if within [low,high] : 0;\\n3. int leftSum = rangeSum(node.left,low,high); //left node\\n4. int rightSum = rangeSum(node.right,low,high); //right node\\n5. return sum + leftSum + rightSum\\n}\\n```\\n\\nThe heart of this solution lies with the recursive calls in lines 3-4. It will essentially visit all the nodes in the left branch and* return the leftSum* and all the right nodes in the branch and return the rightSum. Finally, the answer will be the current node + left + right.\\n\\n**PSUEDOCODE ITERATIVE BFS**\\n```\\n1. if root is null return 0; // corner case\\n2. initialize Queue<TreeNode> q and int sum\\n3. add root to q\\n4. while q is not empty {\\n\\t5. itr = q.size() // this is because the current \"size\" is the # of elements in that row\\n\\t6. while itr > 0\\n\\t\\t7. get node from list and add to answer if sum is in range\\n\\t\\t8. add left and right nodes if they exist\\n}\\n9. return sum\\n```\\nIn the BFS solution, the current Queue of TreeNodes is read in FIFO order, so it maintains an order (not that it matters in this problem). \\nThe key steps lie in 5 and 7-8; for 5 regulates the number of iterations in that particular \"row\" of the tree, which is the current size of the Queue. Line 7-8 add the children of that current row in left -> order.\\n\\n**TIME COMPLEXITY**\\nThe code for both runs in O(n) time complexity because it always visits every node.\\nNOTE: even though BFS solution has nested while loops, they are only called a maximum of n times, where n is the number of nodes in the tree.\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        int sum = root.val <= high && root.val >= low ? root.val : 0;\\n        int left = 0;\\n        int right = 0;\\n        if(root.left != null){\\n            left = rangeSumBST(root.left,low,high);\\n        } \\n        if(root.right != null){\\n            right = rangeSumBST(root.right, low, high);\\n        }\\n        return sum + left + right;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root); // add root node\\n        int sum = 0;\\n        while(!q.isEmpty()){\\n            int itr = q.size();\\n            while(itr > 0){\\n                TreeNode dummy = q.poll();\\n                sum += (dummy.val >= low && dummy.val <= high) ? dummy.val : 0;\\n                if(dummy.left != null)\\n                    q.add(dummy.left);\\n                if(dummy.right != null)\\n                    q.add(dummy.right);\\n                itr--;\\n            }\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n1. If(root == null) return 0;\\n2. sum = node.val if within [low,high] : 0;\\n3. int leftSum = rangeSum(node.left,low,high); //left node\\n4. int rightSum = rangeSum(node.right,low,high); //right node\\n5. return sum + leftSum + rightSum\\n}\\n```\n```\\n1. if root is null return 0; // corner case\\n2. initialize Queue<TreeNode> q and int sum\\n3. add root to q\\n4. while q is not empty {\\n\\t5. itr = q.size() // this is because the current \"size\" is the # of elements in that row\\n\\t6. while itr > 0\\n\\t\\t7. get node from list and add to answer if sum is in range\\n\\t\\t8. add left and right nodes if they exist\\n}\\n9. return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584412,
                "title": "2-javascript-solutions",
                "content": "You need to return sum of values in range of numbers between L and R. Not between nodes of L and R\\n```\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    if(!root) return sum;\\n    if(root.val<=R && root.val>=L)\\n        sum += root.val;\\n    return sum + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n};\\n\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    let stack = [root];\\n    while(stack.length){\\n        let node = stack.pop();\\n        sum+=node.val>=L &&node.val<=R ? node.val : 0;\\n        if(node.left)\\n            stack.push(node.left);\\n        if(node.right)\\n            stack.push(node.right);\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    if(!root) return sum;\\n    if(root.val<=R && root.val>=L)\\n        sum += root.val;\\n    return sum + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n};\\n\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    let stack = [root];\\n    while(stack.length){\\n        let node = stack.pop();\\n        sum+=node.val>=L &&node.val<=R ? node.val : 0;\\n        if(node.left)\\n            stack.push(node.left);\\n        if(node.right)\\n            stack.push(node.right);\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469046,
                "title": "c-easy-fast-and-understandable",
                "content": "```\\nRuntime: 144 ms, faster than 86.30% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int counter = 0;\\n        \\n        rangeSum(root, counter, L, R);\\n        \\n        return counter;\\n    }\\n    \\n    void rangeSum(TreeNode* root, int& counter, int L, int R){\\n        \\n        if(root->val >= L && root->val <= R){\\n            counter += root->val;\\n        }\\n        if(root->left != NULL){\\n            rangeSum(root->left, counter, L, R);\\n        }\\n        if(root->right != NULL){\\n            rangeSum(root->right, counter, L, R);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nRuntime: 144 ms, faster than 86.30% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int counter = 0;\\n        \\n        rangeSum(root, counter, L, R);\\n        \\n        return counter;\\n    }\\n    \\n    void rangeSum(TreeNode* root, int& counter, int L, int R){\\n        \\n        if(root->val >= L && root->val <= R){\\n            counter += root->val;\\n        }\\n        if(root->left != NULL){\\n            rangeSum(root->left, counter, L, R);\\n        }\\n        if(root->right != NULL){\\n            rangeSum(root->right, counter, L, R);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885654,
                "title": "java-runtime-0ms-faster-than-100-recursive-iterative-solutions",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Approach\\nDepth-First Search\\n\\n# Code\\nRecursive Implementation \\n```\\nclass Solution {\\n    private int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (low < root.val) rangeSumBST(root.left, low, high);\\n        if (root.val < high) rangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```\\n\\nIterative Implementation\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        while (!stack.empty()) {\\n            TreeNode current = stack.pop();\\n            if (current == null) continue;\\n            if (current.val >= low && current.val <= high) sum += current.val;\\n            if (low < current.val) stack.push(current.left);\\n            if (current.val < high) stack.push(current.right);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2022-12-07 \\u0432 06.04.34.png](https://assets.leetcode.com/users/images/efd4433e-de08-4faa-ac6d-0e80535a2838_1670382321.6916676.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (low < root.val) rangeSumBST(root.left, low, high);\\n        if (root.val < high) rangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        while (!stack.empty()) {\\n            TreeNode current = stack.pop();\\n            if (current == null) continue;\\n            if (current.val >= low && current.val <= high) sum += current.val;\\n            if (low < current.val) stack.push(current.left);\\n            if (current.val < high) stack.push(current.right);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361957,
                "title": "java-short-0ms-solution-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Range Sum of BST.\\nMemory Usage: 67.1 MB, less than 42.28% of Java online submissions for Range Sum of BST.\\n```\\nclass Solution {\\n    int sum = 0;\\n    int lo = 0; // low\\n    int hi = 0; // and high\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        lo = low;\\n        hi = high;\\n        addSum(root);\\n        return sum;\\n    }\\n    \\n    void addSum(TreeNode root) {\\n        if (root == null) return;\\n        if (root.val >= lo && root.val <= hi) { // if the root value is in the range\\n            sum += root.val; // add to sum\\n            addSum(root.left); // left\\n            addSum(root.right); // right\\n        } else if (root.val < lo) addSum(root.right); // if the root value is too small\\n        else addSum(root.left); // if the root value is too big\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    int lo = 0; // low\\n    int hi = 0; // and high\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        lo = low;\\n        hi = high;\\n        addSum(root);\\n        return sum;\\n    }\\n    \\n    void addSum(TreeNode root) {\\n        if (root == null) return;\\n        if (root.val >= lo && root.val <= hi) { // if the root value is in the range\\n            sum += root.val; // add to sum\\n            addSum(root.left); // left\\n            addSum(root.right); // right\\n        } else if (root.val < lo) addSum(root.right); // if the root value is too small\\n        else addSum(root.left); // if the root value is too big\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628151,
                "title": "daily-leetcoding-challenge-14-december-2021",
                "content": "**Solution in c++**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(!root) return 0;\\n        int sum = 0;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        return sum + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n\\n    }\\n};\\n```\\n**if you understand solution then dont forget to upvote**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(!root) return 0;\\n        int sum = 0;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        return sum + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227687,
                "title": "c-easy-to-understand-iterative-o-n-time-complexity",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)\\n        return 0;\\n        int sum=0;\\n        if(root->val<=high&&root->val>=low)\\n        {\\n            sum+=root->val;\\n        }\\n        if(root->val>high)\\n        {\\n            sum+=rangeSumBST(root->left,low,high);\\n        }\\n        else if(root->val<low)\\n        {\\n            sum+=rangeSumBST(root->right,low,high);\\n        }\\n        else\\n        {\\n            sum+=rangeSumBST(root->right,low,high)+rangeSumBST(root->left,low,high);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)\\n        return 0;\\n        int sum=0;\\n        if(root->val<=high&&root->val>=low)\\n        {\\n            sum+=root->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 936934,
                "title": "c-python-in-order-bst-traverse",
                "content": "```\\nclass Solution { // DFS: in-order traverse\\npublic: // Time/Space Complexity: O(N); O(N)\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> nums;\\n        dfs(root, nums);\\n        int ans = 0;\\n        for(auto e: nums) \\n            if(e >= low && e <=high) ans += e;\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root) return;\\n        dfs(root->left, nums);\\n        nums.push_back(root->val);\\n        dfs(root->right, nums);\\n    }\\n};\\n```\\n\\nApproach 2(python)\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def dfs(root):\\n            if root:\\n                dfs(root.left)\\n                nums.append(root.val)\\n                dfs(root.right)\\n        \\n        nums=[]\\n        dfs(root)\\n        running_sum = list(itertools.accumulate(nums))\\n        left = max(bisect.bisect_left(nums, low)-1, 0)\\n        right = min(bisect.bisect_left(nums, high), len(nums) - 1)                \\n        return running_sum[right] - running_sum[left]\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution { // DFS: in-order traverse\\npublic: // Time/Space Complexity: O(N); O(N)\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> nums;\\n        dfs(root, nums);\\n        int ans = 0;\\n        for(auto e: nums) \\n            if(e >= low && e <=high) ans += e;\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root) return;\\n        dfs(root->left, nums);\\n        nums.push_back(root->val);\\n        dfs(root->right, nums);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def dfs(root):\\n            if root:\\n                dfs(root.left)\\n                nums.append(root.val)\\n                dfs(root.right)\\n        \\n        nums=[]\\n        dfs(root)\\n        running_sum = list(itertools.accumulate(nums))\\n        left = max(bisect.bisect_left(nums, low)-1, 0)\\n        right = min(bisect.bisect_left(nums, high), len(nums) - 1)                \\n        return running_sum[right] - running_sum[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572265,
                "title": "js-fast-and-simple-solution",
                "content": "\\n\\n```js\\nvar rangeSumBST = function(root, L, R) {\\n    if(!root)return 0  \\n    let v = (root.val <= R && root.val >= L)? root.val : 0\\n    return v + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nvar rangeSumBST = function(root, L, R) {\\n    if(!root)return 0  \\n    let v = (root.val <= R && root.val >= L)? root.val : 0\\n    return v + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 284771,
                "title": "javascript-recursive-solution",
                "content": "```\\nconst rangeSumBST = (root, L, R) => {\\n\\tif (root === null) {\\n  \\t    return 0;\\n    }    \\n\\n    return (root.val >= L && root.val <= R ? root.val : 0) + rangeSumBST(root.left, L , R) + rangeSumBST(root.right, L , R);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nconst rangeSumBST = (root, L, R) => {\\n\\tif (root === null) {\\n  \\t    return 0;\\n    }    \\n\\n    return (root.val >= L && root.val <= R ? root.val : 0) + rangeSumBST(root.left, L , R) + rangeSumBST(root.right, L , R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213098,
                "title": "rust-recursive-solution",
                "content": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, l: i32, r: i32) -> i32 {\\n        if let Some(root) = root {\\n            let mut sum = 0;\\n            if l <= root.borrow().val && root.borrow().val <=r {\\n                sum += root.borrow().val;\\n            }\\n            \\n            if l < root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().left.clone(), l, r);\\n            }\\n            \\n            if r > root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().right.clone(), l, r);\\n            }\\n            return sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, l: i32, r: i32) -> i32 {\\n        if let Some(root) = root {\\n            let mut sum = 0;\\n            if l <= root.borrow().val && root.borrow().val <=r {\\n                sum += root.borrow().val;\\n            }\\n            \\n            if l < root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().left.clone(), l, r);\\n            }\\n            \\n            if r > root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().right.clone(), l, r);\\n            }\\n            return sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459881,
                "title": "my-rangesumbst",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum=0;\\n\\n    if(root){\\n        sum+=(root.val>=low&&root.val<=high)?root.val:0;\\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum=0;\\n\\n    if(root){\\n        sum+=(root.val>=low&&root.val<=high)?root.val:0;\\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887527,
                "title": "java-100-solution-range-sum-of-bst",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return sum;\\n        if(root.val>=low && root.val<=high)\\n            sum+=root.val;\\n        \\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return sum;\\n        if(root.val>=low && root.val<=high)\\n            sum+=root.val;\\n        \\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886299,
                "title": "python-97-84-faster-explained-line-by-line-recursive-solution",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\t    s = 0 # answer is zero initially\\n\\t    if root: # if we have a root\\n\\t\\t    if low <= root.val <= high: # if in the right range\\n\\t\\t\\t    s += root.val \\n            # if the root is in the range [low, high]\\n\\t\\t    if low <= root.val: \\n\\t\\t\\t    s += self.rangeSumBST(root.left,low,high) # add nodes to the left sub tree\\n\\t\\t    if root.val <= high: \\n\\t\\t\\t    s += self.rangeSumBST(root.right,low,high) # add nodes to the right sub tree\\n\\t    return s\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\t    s = 0 # answer is zero initially\\n\\t    if root: # if we have a root\\n\\t\\t    if low <= root.val <= high: # if in the right range\\n\\t\\t\\t    s += root.val \\n            # if the root is in the range [low, high]\\n\\t\\t    if low <= root.val: \\n\\t\\t\\t    s += self.rangeSumBST(root.left,low,high) # add nodes to the left sub tree\\n\\t\\t    if root.val <= high: \\n\\t\\t\\t    s += self.rangeSumBST(root.right,low,high) # add nodes to the right sub tree\\n\\t    return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886158,
                "title": "easy-explained-recursion-optimized-2-line-code-cpp",
                "content": "# Approach\\nWe are doing regular tree traversal and adding values within [L, R]. Note that in the solution description, we are given BST, however, this solution works for any binary tree.\\n\\n# CPP Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic://Thanks to Bhalerao-2002\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;//If tree is not Exist \\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R)/*For Left Side traversal of BST*/ + rangeSumBST(root->right, L, R)/*For Right Side traversal of BST*/;\\n}\\n};\\n```\\n# Upvote If it Helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic://Thanks to Bhalerao-2002\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;//If tree is not Exist \\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R)/*For Left Side traversal of BST*/ + rangeSumBST(root->right, L, R)/*For Right Side traversal of BST*/;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885461,
                "title": "97-27-fast-javascript-very-easy-to-understand-solution",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let iterate = (node=root) =>{\\n        if(!node) return;\\n\\n        iterate(node.left)\\n\\n        if(node.val>=low && node.val<=high) sum += node.val;\\n\\n        iterate(node.right)\\n    }\\n\\n    iterate()\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let iterate = (node=root) =>{\\n        if(!node) return;\\n\\n        iterate(node.left)\\n\\n        if(node.val>=low && node.val<=high) sum += node.val;\\n\\n        iterate(node.right)\\n    }\\n\\n    iterate()\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885377,
                "title": "c-easy-to-understand-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Case-1** : If currVal is in range [>=low && <= high] \\n         Then **traverse both** the left and right subtree\\n\\n**Case-2 :** If [currVal <= low] \\nThen traverse only the right subtree\\n\\n**Case-3 :** If [currVal >= high]\\nThen traverse only the left subtree\\n        \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* curr, int& low, int& high)\\n    {\\n        if (curr == NULL) return 0;\\n        \\n        int ans = 0;\\n        bool isInRange = false;\\n        if (curr->val >= low && curr->val <= high) \\n        {\\n            isInRange = true;\\n            ans += curr->val;\\n        }\\n        \\n        if (isInRange || (curr->val <= low)) ans += solve(curr->right, low, high);\\n        if (isInRange || (curr->val >= high)) ans += solve(curr->left, low, high);\\n        return ans;\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        return solve(root, low, high);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* curr, int& low, int& high)\\n    {\\n        if (curr == NULL) return 0;\\n        \\n        int ans = 0;\\n        bool isInRange = false;\\n        if (curr->val >= low && curr->val <= high) \\n        {\\n            isInRange = true;\\n            ans += curr->val;\\n        }\\n        \\n        if (isInRange || (curr->val <= low)) ans += solve(curr->right, low, high);\\n        if (isInRange || (curr->val >= high)) ans += solve(curr->left, low, high);\\n        return ans;\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        return solve(root, low, high);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508766,
                "title": "python-elegant-short-recursive-three-lines",
                "content": "\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        return self.rangeSumBST(root.left, low, high) + \\\\\\n               self.rangeSumBST(root.right, low, high) + \\\\\\n               root.val * (low <= root.val <= high)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        return self.rangeSumBST(root.left, low, high) + \\\\\\n               self.rangeSumBST(root.right, low, high) + \\\\\\n               root.val * (low <= root.val <= high)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2369507,
                "title": "c-two-solutions-recursion-and-queue",
                "content": "Apporach 1: \\nUsing Inorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n       if(root==NULL)\\n        {\\n            return sum;\\n        }\\n        rangeSumBST(root->left,low,high);\\n         if(root->val>high){\\n            return sum;\\n        }\\n        if(root->val>=low&&root->val<=high)\\n        {\\n            sum=sum+root->val;\\n        }\\n       rangeSumBST(root->right,low,high);\\n        return sum;\\n    }\\n};\\n```\\n\\nApproach 2:\\nUsing Queue and property of BST:\\nExplaination :\\n1. Take a Queue data structure and push root to it;\\n2. If node->val is in the range then both the subtrees can be in the range so we w\\'ll add both left and right child : node->right and node->right to the queue.\\n3. If the node->val is lower than (low) ,the left subtree will also be smaller than (low) but there is a possibility that its right child can be in the range , so we\\'ll eliminate left subtree and add node->right to the queue.\\n4. If the node->val is greater than (high),the rightt subtree will also be greater than (low) ,but  there is a possibility that its leftt child can be in the range , so we\\'ll eliminate right subtree and add node->right to the queue.\\n**CODE**\\n```\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)return 0;\\n    int sum =0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n          TreeNode* node=q.front();\\n            q.pop();\\n            if(node->val<low)\\n            {\\n                if(node->right!=NULL)q.push(node->right);\\n            }\\n            else if(node->val >high && node->left!=NULL){\\n                q.push(node->left);                \\n            }\\n            else if(node->val>=low && node->val <=high){\\n                sum+=(node->val);\\n                if(node->left!=NULL)q.push(node->left);\\n                if(node->right!=NULL)q.push(node->right);\\n            } \\n        }\\n        return sum;\\n    }\\n\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n       if(root==NULL)\\n        {\\n            return sum;\\n        }\\n        rangeSumBST(root->left,low,high);\\n         if(root->val>high){\\n            return sum;\\n        }\\n        if(root->val>=low&&root->val<=high)\\n        {\\n            sum=sum+root->val;\\n        }\\n       rangeSumBST(root->right,low,high);\\n        return sum;\\n    }\\n};\\n```\n```\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)return 0;\\n    int sum =0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n          TreeNode* node=q.front();\\n            q.pop();\\n            if(node->val<low)\\n            {\\n                if(node->right!=NULL)q.push(node->right);\\n            }\\n            else if(node->val >high && node->left!=NULL){\\n                q.push(node->left);                \\n            }\\n            else if(node->val>=low && node->val <=high){\\n                sum+=(node->val);\\n                if(node->left!=NULL)q.push(node->left);\\n                if(node->right!=NULL)q.push(node->right);\\n            } \\n        }\\n        return sum;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943473,
                "title": "python-recursive-memory-usage-less-than-93",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        suma = 0\\n        def search(node):\\n            nonlocal suma\\n            if node:\\n                if node.val <= high and node.val >=low:\\n                    suma+=node.val\\n                search(node.left)\\n                search(node.right)\\n        search(root)\\n        return(suma)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        suma = 0\\n        def search(node):\\n            nonlocal suma\\n            if node:\\n                if node.val <= high and node.val >=low:\\n                    suma+=node.val\\n                search(node.left)\\n                search(node.right)\\n        search(root)\\n        return(suma)",
                "codeTag": "Java"
            },
            {
                "id": 1628957,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void fun(TreeNode* root, int low, int high){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val<low){\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>=low && root->val<=high){\\n            res+=root->val;\\n            fun(root->left,low, high);\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>high){\\n            fun(root->left,low, high);\\n        }\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        fun(root, low, high);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void fun(TreeNode* root, int low, int high){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val<low){\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>=low && root->val<=high){\\n            res+=root->val;\\n            fun(root->left,low, high);\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>high){\\n            fun(root->left,low, high);\\n        }\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        fun(root, low, high);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628367,
                "title": "c-super-simple-and-easy-recursive-solution",
                "content": "We iterate through the entire tree.\\nFor every node, if its value is within the range, we add it to `res`.\\n```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res += root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res += root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434547,
                "title": "c-solution-91-faster-recursion",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val >= low && root->val <= high){\\n\\t\\t\\t\\tsum+=root->val;\\n\\t\\t\\t}\\n\\t\\t\\trangeSumBST(root->left,low,high);\\n\\t\\t\\trangeSumBST(root->right,low,high);\\n\\n\\t\\t\\treturn sum;\\n\\n\\n\\t\\t}\\n\\n\\t};\\n\\t\\n**\\tPlease upvote if it helped. **",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1387035,
                "title": "easy-recursive-python3-solution-faster-than-99",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        s = 0\\n        def explore(root, low, high):\\n            nonlocal s\\n            if low<=root.val<=high:\\n                s += root.val\\n            if root.left and low<root.val:\\n                explore(root.left, low, high)\\n            if root.right and high>=root.val:\\n                explore(root.right, low, high)\\n        explore(root, low, high)\\n        return s\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        s = 0\\n        def explore(root, low, high):\\n            nonlocal s\\n            if low<=root.val<=high:\\n                s += root.val\\n            if root.left and low<root.val:\\n                explore(root.left, low, high)\\n            if root.right and high>=root.val:\\n                explore(root.right, low, high)\\n        explore(root, low, high)\\n        return s\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1011277,
                "title": "rust-treenode-implementation-could-be-simplified",
                "content": "Current TreeNode in rust looks like that \\n```\\npub struct TreeNode {\\n   pub val: i32,\\n   pub left: Option<Rc<RefCell<TreeNode>>>,\\n   pub right: Option<Rc<RefCell<TreeNode>>>,\\n }\\n ```\\n But since each node in tree has only one owner it could be simplified to \\n ```\\npub struct TreeNode {\\n    pub val: i32,\\n    pub left: Option<Box<TreeNode>>,\\n    pub right: Option<Box<TreeNode>>,\\n}\\n```\\nHow does it help ?\\n1. It will work faster since we don\\'t do reference counting. So compared to current 12-20 ms we will get  better results for rust.\\n2. Code to build tree becomes simpler.\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct TreeNode {\\n   pub val: i32,\\n   pub left: Option<Rc<RefCell<TreeNode>>>,\\n   pub right: Option<Rc<RefCell<TreeNode>>>,\\n }\\n ```\n```\\npub struct TreeNode {\\n    pub val: i32,\\n    pub left: Option<Box<TreeNode>>,\\n    pub right: Option<Box<TreeNode>>,\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936564,
                "title": "simple-dfs-solution-java",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int[] res = new int[1];\\n        dfs(root, low, high, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode root, int low, int high, int[] sum){\\n        if(root == null) return;\\n        if(root.val <= high && root.val >= low) sum[0] += root.val;\\n        dfs(root.left, low, high, sum);\\n        dfs(root.right, low, high, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int[] res = new int[1];\\n        dfs(root, low, high, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode root, int low, int high, int[] sum){\\n        if(root == null) return;\\n        if(root.val <= high && root.val >= low) sum[0] += root.val;\\n        dfs(root.left, low, high, sum);\\n        dfs(root.right, low, high, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936292,
                "title": "c-super-simple-recursive-easiest-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res+=root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res+=root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838391,
                "title": "brute-force-solution-optimal-solution-in-c",
                "content": "Brute-force solution is quite obvious, simply DFS the tree and add the current node value aslong as its in range L<-->R\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l) (*res)+=root->val;\\n    if(root->left) dfs(root->left,l,r,res);\\n    if(root->right)dfs(root->right,l,r,res);\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\\n\\na more optimal solution is to check if the current node value is not in range of L<--->R then check if its lower than L or higher than R,\\nif its higher than R we need to check the left subtree(lower value elements).\\nelse if its lower than L we need to check the right subtree(higher value elements).\\nthus we reduce the traversal time on the tree\\ncode :\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l){\\n       (*res)+=root->val; \\n    if(root->left)  dfs(root->left,l,r,res);\\n    if(root->right) dfs(root->right,l,r,res);\\n    \\n    } \\n    else if(root->val>r) {\\n        if(root->left) dfs(root->left,l,r,res);\\n    }\\n    else if(root->val<l)if(root->right) dfs(root->right,l,r,res);\\n\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l) (*res)+=root->val;\\n    if(root->left) dfs(root->left,l,r,res);\\n    if(root->right)dfs(root->right,l,r,res);\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l){\\n       (*res)+=root->val; \\n    if(root->left)  dfs(root->left,l,r,res);\\n    if(root->right) dfs(root->right,l,r,res);\\n    \\n    } \\n    else if(root->val>r) {\\n        if(root->left) dfs(root->left,l,r,res);\\n    }\\n    else if(root->val<l)if(root->right) dfs(root->right,l,r,res);\\n\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 813295,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        return ((root.val >= L && root.val <= R) ? root.val : 0) + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        return ((root.val >= L && root.val <= R) ? root.val : 0) + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783846,
                "title": "c-optimized-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root == NULL) return 0;\\n        if(root->val<L) return rangeSumBST(root->right,L,R);\\n        else if(root->val>R) return rangeSumBST(root->left,L,R);\\n\\n        int ans = root->val;\\n        ans+= rangeSumBST(root->left,L,R);\\n        ans+= rangeSumBST(root->right,L,R);      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root == NULL) return 0;\\n        if(root->val<L) return rangeSumBST(root->right,L,R);\\n        else if(root->val>R) return rangeSumBST(root->left,L,R);\\n\\n        int ans = root->val;\\n        ans+= rangeSumBST(root->left,L,R);\\n        ans+= rangeSumBST(root->right,L,R);      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770913,
                "title": "sweet-short-recursive-c-solution-97-21",
                "content": "```\\nclass Solution {\\npublic:\\n  int rangeSumBST(TreeNode* root, int L, int R) {\\n    if(!root) return 0;\\n\\t// to save time we will only go to the left when we are not sure what lies on the left\\n\\t// in simple words, if the current root->val == L then there is no need to go to the left\\n\\t// because it is guaranteed all the values would be smaller than L\\n\\t// similarly for right too\\n    return ((root->val > L) ? rangeSumBST(root->left, L, R) : 0) + \\n\\t\\t   ((root->val < R) ? rangeSumBST(root->right, L, R) : 0) + \\n\\t\\t   ((root->val <= R && root->val >= L) ? root->val : 0);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int rangeSumBST(TreeNode* root, int L, int R) {\\n    if(!root) return 0;\\n\\t// to save time we will only go to the left when we are not sure what lies on the left\\n\\t// in simple words, if the current root->val == L then there is no need to go to the left\\n\\t// because it is guaranteed all the values would be smaller than L\\n\\t// similarly for right too\\n    return ((root->val > L) ? rangeSumBST(root->left, L, R) : 0) + \\n\\t\\t   ((root->val < R) ? rangeSumBST(root->right, L, R) : 0) + \\n\\t\\t   ((root->val <= R && root->val >= L) ? root->val : 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739437,
                "title": "javascript-dfs",
                "content": "```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = 0){\\n  if(!root) return 0;\\n  if(root.val >= L && root.val <= R ){\\n    res = root.val;\\n  }\\n  return res + dfs(root.left, L, R) + dfs(root.right, L, R)\\n}\\n```\\n\\nAnother DFS option:\\n\\n```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = {total : 0}){\\n  if(!root) return res;\\n  if(root.val >= L && root.val <= R ){\\n    res.total += root.val;\\n  }\\n  dfs(root.left, L, R, res)\\n  dfs(root.right, L, R, res)\\n  return res.total;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = 0){\\n  if(!root) return 0;\\n  if(root.val >= L && root.val <= R ){\\n    res = root.val;\\n  }\\n  return res + dfs(root.left, L, R) + dfs(root.right, L, R)\\n}\\n```\n```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = {total : 0}){\\n  if(!root) return res;\\n  if(root.val >= L && root.val <= R ){\\n    res.total += root.val;\\n  }\\n  dfs(root.left, L, R, res)\\n  dfs(root.right, L, R, res)\\n  return res.total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515506,
                "title": "intuitive-python-solution",
                "content": "I saw some inorder solutions for python , but like any other recursion problem, I like to just break it down into two parts:\\ni) recursive part.\\nii) base case to terminate recursion.\\n\\nBase case is trivial:\\n```\\nif not root:\\n  return 0\\n```\\n\\nCase I\\n```\\nif root.val > R \\n\\tans = self.rangeSum(root.left, L,R)\\n```\\nCase II\\n```\\nif root.val < L:\\n\\tans = self.rangeSum(root.right, L, R)\\n```\\nCase III\\nwhen root value lies in between\\n```\\n\\tans = root.val + self.rangeSum(root.left, L, R) + self.rangeSum(root.right, L, R)\\n```\\n\\nFull code beats 98%\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        total = 0\\n        if root.val > R:\\n            total = self.rangeSumBST(root.left, L, R)\\n        elif root.val < L :\\n            total = self.rangeSumBST(root.right, L, R)\\n        else:\\n            total = root.val + self.rangeSumBST(root.left, L, R) \\\\\\n            + self.rangeSumBST(root.right, L, R)\\n        return total\\n```\\n\\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nif not root:\\n  return 0\\n```\n```\\nif root.val > R \\n\\tans = self.rangeSum(root.left, L,R)\\n```\n```\\nif root.val < L:\\n\\tans = self.rangeSum(root.right, L, R)\\n```\n```\\n\\tans = root.val + self.rangeSum(root.left, L, R) + self.rangeSum(root.right, L, R)\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        total = 0\\n        if root.val > R:\\n            total = self.rangeSumBST(root.left, L, R)\\n        elif root.val < L :\\n            total = self.rangeSumBST(root.right, L, R)\\n        else:\\n            total = root.val + self.rangeSumBST(root.left, L, R) \\\\\\n            + self.rangeSumBST(root.right, L, R)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500831,
                "title": "java-beats-100-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n    \\n        if(root==null)\\n        return 0;\\n    \\n        else if(L<=root.val&&root.val<=R)\\n        return rangeSumBST(root.left,L,R)+rangeSumBST(root.right,L,R)+root.val;\\n    \\n        else if(L>root.val)\\n        return rangeSumBST(root.right,L,R);\\n    \\n        else \\n        return rangeSumBST(root.left,L,R);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n    \\n        if(root==null)\\n        return 0;\\n    \\n        else if(L<=root.val&&root.val<=R)\\n        return rangeSumBST(root.left,L,R)+rangeSumBST(root.right,L,R)+root.val;\\n    \\n        else if(L>root.val)\\n        return rangeSumBST(root.right,L,R);\\n    \\n        else \\n        return rangeSumBST(root.left,L,R);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384415,
                "title": "c-solution",
                "content": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (root == NULL)\\n        return 0;\\n    else if (root->val >= L && root->val <= R)\\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    else\\n        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (root == NULL)\\n        return 0;\\n    else if (root->val >= L && root->val <= R)\\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    else\\n        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290385,
                "title": "c-short-solution",
                "content": "```\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(nullptr == root) return 0;\\n        int sum = 0;\\n        if(root->val >= L && root->val <= R) sum += root->val;\\n        if(root->val <= R) sum += rangeSumBST(root->right, L, R);\\n        if(root->val >= L) sum += rangeSumBST(root->left, L, R);\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(nullptr == root) return 0;\\n        int sum = 0;\\n        if(root->val >= L && root->val <= R) sum += root->val;\\n        if(root->val <= R) sum += rangeSumBST(root->right, L, R);\\n        if(root->val >= L) sum += rangeSumBST(root->left, L, R);\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260017,
                "title": "swift",
                "content": "\\n```\\nclass Solution {\\n    func rangeSumBST(_ root: TreeNode?, _ L: Int, _ R: Int) -> Int {\\n        var sum = 0\\n        guard let node = root else { return sum }\\n        if L <= node.val &&  node.val <= R {\\n            sum += node.val\\n        }\\n        if L < node.val {\\n            sum = sum + rangeSumBST(node.left, L, R)\\n        }\\n        if node.val < R {\\n            sum = sum + rangeSumBST(node.right, L, R)\\n        }\\n\\n        return sum\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rangeSumBST(_ root: TreeNode?, _ L: Int, _ R: Int) -> Int {\\n        var sum = 0\\n        guard let node = root else { return sum }\\n        if L <= node.val &&  node.val <= R {\\n            sum += node.val\\n        }\\n        if L < node.val {\\n            sum = sum + rangeSumBST(node.left, L, R)\\n        }\\n        if node.val < R {\\n            sum = sum + rangeSumBST(node.right, L, R)\\n        }\\n\\n        return sum\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194047,
                "title": "medium-i-don-t-think-so",
                "content": "No way this is medium, all the test cases pass without even adding the early termination condition. \\n```\\n    public int rangeSumBST(TreeNode root, int l, int r) {\\n    \\tStack<TreeNode> s = new Stack<>();\\n    \\ts.add(root);\\n    \\tint sum = 0;\\n    \\twhile(!s.isEmpty()) {\\n    \\t\\tTreeNode n = s.pop();\\n    \\t\\tif(n != null) {\\n        \\t\\tif(n.val >= l && n.val <= r) {\\n        \\t\\t\\tsum += n.val;\\n        \\t\\t}\\n        \\t\\tif(n.val > l) s.add(n.left);\\n        \\t\\tif(n.val < r) s.add(n.right); \\n    \\t\\t}  \\t\\t\\n    \\t}\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int l, int r) {\\n    \\tStack<TreeNode> s = new Stack<>();\\n    \\ts.add(root);\\n    \\tint sum = 0;\\n    \\twhile(!s.isEmpty()) {\\n    \\t\\tTreeNode n = s.pop();\\n    \\t\\tif(n != null) {\\n        \\t\\tif(n.val >= l && n.val <= r) {\\n        \\t\\t\\tsum += n.val;\\n        \\t\\t}\\n        \\t\\tif(n.val > l) s.add(n.left);\\n        \\t\\tif(n.val < r) s.add(n.right); \\n    \\t\\t}  \\t\\t\\n    \\t}\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192875,
                "title": "simple-recursive-c-code-beats-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if (root ==NULL){return 0;}\\n        else if (root->val > R)\\n            return rangeSumBST(root->left, L,R);\\n        else if (root->val < L)\\n            return rangeSumBST(root->right, L,R);\\n        else\\n            return root->val+rangeSumBST(root->left,L,root->val)+rangeSumBST(root->right, root->val,R);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if (root ==NULL){return 0;}\\n        else if (root->val > R)\\n            return rangeSumBST(root->left, L,R);\\n        else if (root->val < L)\\n            return rangeSumBST(root->right, L,R);\\n        else\\n            return root->val+rangeSumBST(root->left,L,root->val)+rangeSumBST(root->right, root->val,R);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994954,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923247,
                "title": "easy-java-solution-for-beginners-binary-tree-concept-no-bst",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            sum += rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            sum += rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            sum += rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            sum += rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013606,
                "title": "very-easy-to-understand-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum=0; \\n        if(root==NULL) return 0;\\n\\n        int l=rangeSumBST(root->left,low,high);\\n        int r=rangeSumBST(root->right,low,high);\\n\\n        sum=l+r;\\n\\n        if(root->val >= low && root->val <= high){\\n            sum+=root->val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum=0; \\n        if(root==NULL) return 0;\\n\\n        int l=rangeSumBST(root->left,low,high);\\n        int r=rangeSumBST(root->right,low,high);\\n\\n        sum=l+r;\\n\\n        if(root->val >= low && root->val <= high){\\n            sum+=root->val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892550,
                "title": "c-easy-4-lines-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t//time: O(less than total nodes) i.e bcz we are moving on nodes in range[low,high], space: O(height)\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root == NULL) return 0;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tif(root->val >= low && root->val <= high)  sum += root->val;\\n\\t\\t\\tif(root->val >= low)  sum += rangeSumBST(root->left, low, high); //travel on left child\\n\\t\\t\\tif(root->val <= high)   sum += rangeSumBST(root->right, low, high); //travel on right child\\n\\t\\t\\treturn sum;\\n\\t   }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//time: O(less than total nodes) i.e bcz we are moving on nodes in range[low,high], space: O(height)\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root == NULL) return 0;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tif(root->val >= low && root->val <= high)  sum += root->val;\\n\\t\\t\\tif(root->val >= low)  sum += rangeSumBST(root->left, low, high); //travel on left child\\n\\t\\t\\tif(root->val <= high)   sum += rangeSumBST(root->right, low, high); //travel on right child\\n\\t\\t\\treturn sum;\\n\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 2886868,
                "title": "simple-tree-traversal",
                "content": "# Code\\n```\\n=class Solution \\n{\\n    private:\\n        int sum=0;\\n\\n    public:\\n        void treeTraversal(TreeNode* root, int low, int high)\\n        {\\n            if(root)\\n            {\\n                treeTraversal(root->left, low, high);\\n\\n                if(root->val >= low && root->val <= high)\\n                {\\n                    sum += root->val;\\n                }\\n\\n                treeTraversal(root->right, low, high);\\n            }\\n        }\\n\\n        int rangeSumBST(TreeNode* root, int low, int high)\\n        {\\n            treeTraversal(root, low, high);\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n=class Solution \\n{\\n    private:\\n        int sum=0;\\n\\n    public:\\n        void treeTraversal(TreeNode* root, int low, int high)\\n        {\\n            if(root)\\n            {\\n                treeTraversal(root->left, low, high);\\n\\n                if(root->val >= low && root->val <= high)\\n                {\\n                    sum += root->val;\\n                }\\n\\n                treeTraversal(root->right, low, high);\\n            }\\n        }\\n\\n        int rangeSumBST(TreeNode* root, int low, int high)\\n        {\\n            treeTraversal(root, low, high);\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886354,
                "title": "java-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H), where H is the height of the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        ans = 0;\\n        dfs(root, L, R);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node, int L, int R) {\\n        if (node != null) {\\n            if (L <= node.val && node.val <= R)\\n                ans += node.val;\\n            if (L < node.val)\\n                dfs(node.left, L, R);\\n            if (node.val < R)\\n                dfs(node.right, L, R);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        ans = 0;\\n        dfs(root, L, R);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node, int L, int R) {\\n        if (node != null) {\\n            if (L <= node.val && node.val <= R)\\n                ans += node.val;\\n            if (L < node.val)\\n                dfs(node.left, L, R);\\n            if (node.val < R)\\n                dfs(node.right, L, R);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885832,
                "title": "java-solution-0ms-beats-100",
                "content": "\\n```\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        if(root.val > high) return rangeSumBST(root.left, low, high);\\n        if(root.val < low) return rangeSumBST(root.right, low, high);\\n        return root.val + rangeSumBST(root.left, low,high) + rangeSumBST(root.right, low, high); \\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        if(root.val > high) return rangeSumBST(root.left, low, high);\\n        if(root.val < low) return rangeSumBST(root.right, low, high);\\n        return root.val + rangeSumBST(root.left, low,high) + rangeSumBST(root.right, low, high); \\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885646,
                "title": "easy-and-faster-than-98-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf Explainatory Code.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHopeYou Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for recursion stack space\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0; // Initialised Sum\\n    void Traversal(TreeNode* root,int low,int high)\\n    {\\n        if(root==NULL) // If Node is NULL then we return \\n        return;\\n        Traversal(root->left,low,high); // To check for left Node\\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\\n        Traversal(root->right,low,high); // To check for right Node\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr); // To make input output fast\\n        Traversal(root,low,high); //To Traverse in BST\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0; // Initialised Sum\\n    void Traversal(TreeNode* root,int low,int high)\\n    {\\n        if(root==NULL) // If Node is NULL then we return \\n        return;\\n        Traversal(root->left,low,high); // To check for left Node\\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\\n        Traversal(root->right,low,high); // To check for right Node\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr); // To make input output fast\\n        Traversal(root,low,high); //To Traverse in BST\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2349128,
                "title": "range-sum-of-bst-by-using-inorder",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    void inorder(TreeNode*root, vector<int>&v){\\n        if(root==NULL) return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n        \\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        inorder(root, v);\\n        int sum=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low  && v[i]<=high){\\n               sum+=v[i]; \\n            }\\n        }\\n        return sum;\\n    }\\n}; \\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode*root, vector<int>&v){\\n        if(root==NULL) return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1903109,
                "title": "faster-than-100-solution-java-algorithm",
                "content": "hello Leetcoder, hope you are well\\n\\nYpu are reading this means you want to konw other apporach or you are stuck in this problem, so\\nLet me help you\\n\\n**Problem Understanding**\\nThis problem is saying basically you have a Binary Search Tree and a range [low, high], you have to traverse through the BST and find all nodes which lies between the range and calculate sum of those nodes.\\n\\nNow think about BST property : we will use the this property to calculate the sum between range [low, high].\\n\\t* \\tLeft child\\'s root.data  < root.data\\n\\t* \\tright child\\'s root.data > root.data\\n![image](https://assets.leetcode.com/users/images/0893e510-f313-49b9-80a3-08b1fe050737_1648806799.7505903.png)\\n\\n**According to the above rule we can say this**\\n```\\n\\troot.val < low \\n\\t\\tWe don\\'t have to traverse left sub-tree cause all left sub tree nodes values will be less than low that we don\\'t need\\n\\troot.val > high\\n\\t\\tWe  don\\'t need to traverse right sub-tree cause all right sub-tree nodes value will be greater than high that we don\\'t need\\n```\\n\\nNow how we calculate the sum?\\n\\n**Algorithum**\\n1. check base case : root == null ?\\n2. now element sub-trees based on above assumption.\\n3. if root.data lies between range[low, high], call for both left and right sub-tree and add current node value into sum\\n4. return this sum;\\n\\nTime complexity   T(n) = O(n)\\n\\n**Code**\\n\\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        \\n        if(root.val < low) { // discard the left sub-tree\\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        if(root.val > high) { //  discard the right sub-tree\\n            return rangeSumBST(root.left, low, high);\\n        }\\n        \\n        return rangeSumBST(root.left, low, high) + root.val + rangeSumBST(root.right, low, high);\\n    }\\n```\\n\\t\\t\\t\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\troot.val < low \\n\\t\\tWe don\\'t have to traverse left sub-tree cause all left sub tree nodes values will be less than low that we don\\'t need\\n\\troot.val > high\\n\\t\\tWe  don\\'t need to traverse right sub-tree cause all right sub-tree nodes value will be greater than high that we don\\'t need\\n```\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        \\n        if(root.val < low) { // discard the left sub-tree\\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        if(root.val > high) { //  discard the right sub-tree\\n            return rangeSumBST(root.left, low, high);\\n        }\\n        \\n        return rangeSumBST(root.left, low, high) + root.val + rangeSumBST(root.right, low, high);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842871,
                "title": "recurisve-python-solution-with-comments",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        if not(root): return root\\n        # return nextNode(root, low, high, 0)\\n        return getsum(root, low, high, 0)\\n    \\n    \\n# Ordinary: Binary Tree Recursion;\\ndef nextNode(root, lo, hi, sumi):\\n    # base case;\\n    if not(root): return sumi\\n    # main case\\n    sumi = nextNode(root.left, lo, hi, sumi)\\n    if(root.val >= lo and root.val <= hi):\\n        sumi = sumi + root.val\\n    sumi = nextNode(root.right, lo, hi, sumi)\\n    return sumi\\n\\n\\n# Little More Optimized\\ndef getsum(root, lo, hi, res):\\n    if not root: \\n        return res\\n    if(root.val >= lo and root.val <= hi):\\n        res += root.val\\n    if(root.val > lo):                      # going left only when root\\'s value greater than low;\\n        res = getsum(root.left,lo,hi,res)\\n    if(root.val <= hi):                     # going right onyl when root\\'s value smaller than high;\\n        res = getsum(root.right,lo,hi,res)\\n    return res\\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        if not(root): return root\\n        # return nextNode(root, low, high, 0)\\n        return getsum(root, low, high, 0)\\n    \\n    \\n# Ordinary: Binary Tree Recursion;\\ndef nextNode(root, lo, hi, sumi):\\n    # base case;\\n    if not(root): return sumi\\n    # main case\\n    sumi = nextNode(root.left, lo, hi, sumi)\\n    if(root.val >= lo and root.val <= hi):\\n        sumi = sumi + root.val\\n    sumi = nextNode(root.right, lo, hi, sumi)\\n    return sumi\\n\\n\\n# Little More Optimized\\ndef getsum(root, lo, hi, res):\\n    if not root: \\n        return res\\n    if(root.val >= lo and root.val <= hi):\\n        res += root.val\\n    if(root.val > lo):                      # going left only when root\\'s value greater than low;\\n        res = getsum(root.left,lo,hi,res)\\n    if(root.val <= hi):                     # going right onyl when root\\'s value smaller than high;\\n        res = getsum(root.right,lo,hi,res)\\n    return res\\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829411,
                "title": "scala-tailrec",
                "content": "```\\ndef rangeSumBST(root: TreeNode, low: Int, high: Int): Int = {\\n        import scala.util.control.TailCalls.{TailRec, done}\\n        def dfs(tn: TreeNode) : TailRec[Int] = tn match {\\n            case null => done(0)\\n            case n =>\\n                val t = if (low <= n.value && n.value <= high) n.value else 0\\n                for {\\n                    l <- dfs(n.left)\\n                    r <- dfs(n.right)\\n                } yield l + r + t\\n        }\\n        dfs(root).result\\n    }\\n```",
                "solutionTags": [
                    "Scala",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef rangeSumBST(root: TreeNode, low: Int, high: Int): Int = {\\n        import scala.util.control.TailCalls.{TailRec, done}\\n        def dfs(tn: TreeNode) : TailRec[Int] = tn match {\\n            case null => done(0)\\n            case n =>\\n                val t = if (low <= n.value && n.value <= high) n.value else 0\\n                for {\\n                    l <- dfs(n.left)\\n                    r <- dfs(n.right)\\n                } yield l + r + t\\n        }\\n        dfs(root).result\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769566,
                "title": "c-recursion-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif(root->val > high)\\n\\t\\t\\t\\treturn rangeSumBST(root->left , low , high);\\n\\t\\t\\telse if(root->val < low)\\n\\t\\t\\t\\treturn rangeSumBST(root->right , low , high);\\n\\t\\t\\treturn root->val + rangeSumBST(root->left , low , high) + \\n\\t\\t\\t\\t   rangeSumBST(root->right , low , high);\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif(root->val > high)\\n\\t\\t\\t\\treturn rangeSumBST(root->left , low , high);\\n\\t\\t\\telse if(root->val < low)\\n\\t\\t\\t\\treturn rangeSumBST(root->right , low , high);\\n\\t\\t\\treturn root->val + rangeSumBST(root->left , low , high) + \\n\\t\\t\\t\\t   rangeSumBST(root->right , low , high);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1724362,
                "title": "python3-faster",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        summ=0\\n        if root.val>=low and root.val<=high:\\n            summ+=root.val\\n        summ=summ+self.rangeSumBST(root.left,low,high)\\n        summ=summ+self.rangeSumBST(root.right,low,high)\\n        return summ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        summ=0\\n        if root.val>=low and root.val<=high:\\n            summ+=root.val\\n        summ=summ+self.rangeSumBST(root.left,low,high)\\n        summ=summ+self.rangeSumBST(root.right,low,high)\\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682399,
                "title": "java-easy-recursion-o-n-0ms-faster-than-100-submission",
                "content": "```\\nclass Solution{\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n      if(root==null) return 0;\\n        if(root.val>low && root.val>high){\\n           return rangeSumBST(root.left,low,high);\\n        }else if(root.val<low && root.val<high){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            int l=rangeSumBST(root.left,low,high);\\n            int r=rangeSumBST(root.right,low,high);\\n            return l+r+root.val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n      if(root==null) return 0;\\n        if(root.val>low && root.val>high){\\n           return rangeSumBST(root.left,low,high);\\n        }else if(root.val<low && root.val<high){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            int l=rangeSumBST(root.left,low,high);\\n            int r=rangeSumBST(root.right,low,high);\\n            return l+r+root.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629351,
                "title": "easy-to-understand-python-solution",
                "content": "```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:                               # If the node does not exist or is null\\n\\t\\treturn 0                               # add a 0 value for that node\\n\\t\\n\\telif root.val >= low and root.val <= high: # If it exists and is in the inclusive range of low and high, return it\\'s val\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # and recurse into left and right branches\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telse:                                      # If it exists but is outside of the range, we still\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # recurse into left and right branches because a child node may be in range\\n\\t\\treturn self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\\n\\n\\n\\nOptimized version:\\n\\n```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\telif root.val >= low and root.val <= high:\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telif root.val < low:                               # If the node is less than the low range,\\n\\t\\treturn self.rangeSumBST(root.right, low, high) # all left children will also be, so we only pursue right\\n\\t\\n\\telif root.val > high:                              # same principle here, but in the other direction\\n\\t\\treturn self.rangeSumBST(root.left, low, high)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:                               # If the node does not exist or is null\\n\\t\\treturn 0                               # add a 0 value for that node\\n\\t\\n\\telif root.val >= low and root.val <= high: # If it exists and is in the inclusive range of low and high, return it\\'s val\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # and recurse into left and right branches\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telse:                                      # If it exists but is outside of the range, we still\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # recurse into left and right branches because a child node may be in range\\n\\t\\treturn self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\n```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\telif root.val >= low and root.val <= high:\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telif root.val < low:                               # If the node is less than the low range,\\n\\t\\treturn self.rangeSumBST(root.right, low, high) # all left children will also be, so we only pursue right\\n\\t\\n\\telif root.val > high:                              # same principle here, but in the other direction\\n\\t\\treturn self.rangeSumBST(root.left, low, high)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1628460,
                "title": "c-99-faster-93-less-space-using-std-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        uint32_t sum = 0;\\n        std::stack<TreeNode*> nodes_to_pass;\\n        nodes_to_pass.push(root);\\n        while(!nodes_to_pass.empty()) {\\n            TreeNode* current_node = nodes_to_pass.top();\\n            if (current_node->val >= low && current_node->val <= high) {\\n                sum += current_node->val;\\n            }\\n            nodes_to_pass.pop();\\n            if (current_node->left && current_node->val >= low) {\\n                nodes_to_pass.push(current_node->left);\\n            }\\n            if (current_node->right && current_node->val <= high) {\\n                nodes_to_pass.push(current_node->right);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        uint32_t sum = 0;\\n        std::stack<TreeNode*> nodes_to_pass;\\n        nodes_to_pass.push(root);\\n        while(!nodes_to_pass.empty()) {\\n            TreeNode* current_node = nodes_to_pass.top();\\n            if (current_node->val >= low && current_node->val <= high) {\\n                sum += current_node->val;\\n            }\\n            nodes_to_pass.pop();\\n            if (current_node->left && current_node->val >= low) {\\n                nodes_to_pass.push(current_node->left);\\n            }\\n            if (current_node->right && current_node->val <= high) {\\n                nodes_to_pass.push(current_node->right);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627963,
                "title": "python3-iterative-bfs-explained",
                "content": "We are using a queue to do the Breadth-First Search iteratively. For every node, we check whether the value is in the range. Children are added to the queue only if they can have nodes in the given range using the main property of the Binary Tree: greater nodes go to the right, smaller nodes to the left. That allows us to avoid useless passes through the tree.\\n\\nTime: **O(N)** - for the BFS\\nSpace: **O(logN)** - for the queue\\n\\nRuntime: 196 ms, faster than **94.28%** of Python3 online submissions for Range Sum of BST.\\nMemory Usage: 22.4 MB, less than **5.88%** of Python3 online submissions for Range Sum of BST.\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:\\n        res = 0\\n        \\n        q = deque([root])\\n        while q:\\n            c = q.popleft()\\n            v, l, r = c.val, c.left, c.right\\n\\n            if lo <= v and v <= hi:\\n                res += v\\n                \\n            if l and (lo < v or v > hi):\\n                q.append(l)\\n                \\n            if r and (lo > v or v < hi):\\n                q.append(r)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:\\n        res = 0\\n        \\n        q = deque([root])\\n        while q:\\n            c = q.popleft()\\n            v, l, r = c.val, c.left, c.right\\n\\n            if lo <= v and v <= hi:\\n                res += v\\n                \\n            if l and (lo < v or v > hi):\\n                q.append(l)\\n                \\n            if r and (lo > v or v < hi):\\n                q.append(r)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627949,
                "title": "easy-recursive-solution-in-c",
                "content": "\\n//smjh\\n\\n``` \\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n      if(root == NULL) return 0;\\n        \\n       if(root->val > high){\\n           return rangeSumBST(root->left,low ,high);\\n       }\\n        else if(root->val <low){\\n            return rangeSumBST(root->right,low,high);\\n        }\\n        \\n        return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        \\n    }\\n\\t\\nDo upvote if you find it helpful",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n//smjh\\n\\n``` \\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n      if(root == NULL) return 0;\\n        \\n       if(root->val > high){\\n           return rangeSumBST(root->left,low ,high);\\n       }\\n        else if(root->val <low){\\n            return rangeSumBST(root->right,low,high);\\n        }\\n        \\n        return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        \\n    }\\n\\t\\nDo upvote if you find it helpful",
                "codeTag": "Unknown"
            },
            {
                "id": 1627797,
                "title": "python3-clean-7-lines-o-n-time-beats-94-28-o-n-space-dfs",
                "content": "Below is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root: return 0\\n        res = root.val if low <= root.val <= high else 0\\n        if root.val <= low: return res + self.rangeSumBST(root.right, low, high)\\n        if root.val >= high: return res + self.rangeSumBST(root.left, low, high)\\n        return res + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root: return 0\\n        res = root.val if low <= root.val <= high else 0\\n        if root.val <= low: return res + self.rangeSumBST(root.right, low, high)\\n        if root.val >= high: return res + self.rangeSumBST(root.left, low, high)\\n        return res + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518247,
                "title": "c-recursive-solution",
                "content": "**Uncomment the commented part to see the recursive call pattern for better understanding.**\\n*Do upvote if you understand the solution : )*\\n\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n      \\n      if(root == NULL) \\n      {\\n          // cout<<\" sum : \"<<sum<<endl;\\n          return sum;\\n      }\\n      // cout<<\"For value : \"<<root->val<<\" sum : \"<<sum<<endl;\\n\\n      if(root->val>=low && root->val<=high)\\n      {\\n          sum+=root->val;\\n          rangeSumBST(root->left,low,high);\\n          rangeSumBST(root->right,low,high);\\n      }\\n      else if (root->val < low)\\n      {\\n        rangeSumBST(root->right,low,high);\\n      }\\n      else\\n      {\\n        rangeSumBST(root->left,low,high);\\n      }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n      \\n      if(root == NULL) \\n      {\\n          // cout<<\" sum : \"<<sum<<endl;\\n          return sum;\\n      }\\n      // cout<<\"For value : \"<<root->val<<\" sum : \"<<sum<<endl;\\n\\n      if(root->val>=low && root->val<=high)\\n      {\\n          sum+=root->val;\\n          rangeSumBST(root->left,low,high);\\n          rangeSumBST(root->right,low,high);\\n      }\\n      else if (root->val < low)\\n      {\\n        rangeSumBST(root->right,low,high);\\n      }\\n      else\\n      {\\n        rangeSumBST(root->left,low,high);\\n      }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1324875,
                "title": "java-cpp-one-liner-soln-brute-force-and-java-clean-soln-using-bst",
                "content": "Java:\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        return (root != null && root.val <= high && root.val >= low ? root.val : 0) + (root == null ? 0 : rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high));\\n    }\\n}\\n```\\ncpp:\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n        return (root != NULL && root->val <= high && root->val >= low ? root->val : 0) + (root == NULL ? 0 : rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high));\\n    }\\n};\\n```\\n\\nJava (clean code):\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        if (root == null) return 0;\\n        \\n        if (root.val >= low && root.val <= high) {\\n            \\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n        else if (root.val < low) {\\n            \\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        else {\\n            return rangeSumBST(root.left, low, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        return (root != null && root.val <= high && root.val >= low ? root.val : 0) + (root == null ? 0 : rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high));\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n        return (root != NULL && root->val <= high && root->val >= low ? root->val : 0) + (root == NULL ? 0 : rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high));\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        if (root == null) return 0;\\n        \\n        if (root.val >= low && root.val <= high) {\\n            \\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n        else if (root.val < low) {\\n            \\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        else {\\n            return rangeSumBST(root.left, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309553,
                "title": "100-faster-and-99-5-less-memory-consumption-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(root==NULL){\\n            return sum;\\n        }\\n       \\n        if(root->val>=low&&root->val<=high){\\n                sum+=root->val;\\n        }\\n        rangeSumBST(root->left,low, high);\\n        rangeSumBST(root->right,low, high);\\n        root->left=root->right=nullptr;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(root==NULL){\\n            return sum;\\n        }\\n       \\n        if(root->val>=low&&root->val<=high){\\n                sum+=root->val;\\n        }\\n        rangeSumBST(root->left,low, high);\\n        rangeSumBST(root->right,low, high);\\n        root->left=root->right=nullptr;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1298049,
                "title": "c-recursion-dfs-bst-property-usage",
                "content": "Some of the recent solutions that I\\'ve seen is missing important BST property in their codes. \\nHere is the code that uses BST property during traversing.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n        if(root->val>=low and root->val<=high)\\n            return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);\\n        else if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        else\\n            return rangeSumBST(root->left,low,high);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n        if(root->val>=low and root->val<=high)\\n            return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);\\n        else if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        else\\n            return rangeSumBST(root->left,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292484,
                "title": "3-line-code-lmaooooo-dfs",
                "content": "**I don\\'t think this code requires intiution but for beginner here is the brute force first approach all you need to calculate sum right? so what you could do is check if your root value is lie b/w the range just add it in your answer and call on your left and right childs and add their answer too return the answer**\\n\\n\\n**since it\\'s BST we can improve our logic check if your root->val is greater than high? if yes this means no need to call on right child it will never give you an answer so call on only left now check if root->val is less than low? if yes no need to call on left it won\\'t give you an answer so call on right only now if both the cases are not true it means your root value is lie  b/w range so add root->val in your answer and call on left and right simple that\\'s it bois/girls.......... don\\'t forget to upvote \\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)return 0;\\n        if(root->val>high)return rangeSumBST(root->left, low,high);\\n        else if(root->val<low)return rangeSumBST(root->right,low,high);\\n        else return root->val + rangeSumBST(root->left, low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)return 0;\\n        if(root->val>high)return rangeSumBST(root->left, low,high);\\n        else if(root->val<low)return rangeSumBST(root->right,low,high);\\n        else return root->val + rangeSumBST(root->left, low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248688,
                "title": "simple-recursive-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        ans+=rangeSumBST(root.left,low,high);\\n        if(inRange(root.val,low,high))ans+=root.val;\\n        ans+=rangeSumBST(root.right,low,high);\\n        return ans;\\n    }\\n    public boolean inRange(int n,int low,int high)\\n    {\\n        return n>=low&&n<=high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        ans+=rangeSumBST(root.left,low,high);\\n        if(inRange(root.val,low,high))ans+=root.val;\\n        ans+=rangeSumBST(root.right,low,high);\\n        return ans;\\n    }\\n    public boolean inRange(int n,int low,int high)\\n    {\\n        return n>=low&&n<=high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243988,
                "title": "c-better-than-o-n-clean",
                "content": "**if the current node value is not in the range  low and high  then you have decide if is it possible to go right   and left**\\n\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(root==NULL)\\n            return 0;\\n        if(root->val<=high and root->val>=low)\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        if(root->val>high)\\n            return  rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);    \\n        return 0;\\n        \\n    }",
                "solutionTags": [],
                "code": "**if the current node value is not in the range  low and high  then you have decide if is it possible to go right   and left**\\n\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(root==NULL)\\n            return 0;\\n        if(root->val<=high and root->val>=low)\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        if(root->val>high)\\n            return  rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);    \\n        return 0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1219173,
                "title": "easy-java-recursion",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n        int rootsum =0;\\n        int ls = rangeSumBST(root.left, low, high);\\n        int rs = rangeSumBST(root.right, low, high);\\n        if(root.val>= low && root.val <= high) rootsum = root.val;\\n        else rootsum = 0;\\n        int sum = ls+ rs+ rootsum;\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n        int rootsum =0;\\n        int ls = rangeSumBST(root.left, low, high);\\n        int rs = rangeSumBST(root.right, low, high);\\n        if(root.val>= low && root.val <= high) rootsum = root.val;\\n        else rootsum = 0;\\n        int sum = ls+ rs+ rootsum;\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1218050,
                "title": "use-of-the-fact-that-it-is-bst-explaination-beginner-90-fast",
                "content": "**JUST WANT TO GET IMPLEMENTATION JUMP TO CODE**\\n\\nBasic property of bst is that it contains its left child as smaller or equal to node and its right child greater to it,(the equal child can be kept any of the side).\\n\\n\\nin the given diagram \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t/   \\\\\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t5          15\\n\\t\\t\\t\\t\\t\\t\\t   /  \\\\\\\\           \\\\\\\\\\n\\t\\t\\t\\t\\t\\t\\t 3       7           18\\nthe node value(10) is in given range therefore the possibilty of having a in-range value on both subtrees  is possible,\\ntherefore we take a extra memory(taking queue) and add both its child to it\\nQueue has 5,15 now .\\npicking 5(as of fifo).\\nnow 5 is smaller than the lower value but its right child can have a value greater to it which might be in  given range,so we eliminate the left subtree and add the right child of it to the queue.\\n\\nnow,queue become 15,7.\\nas 15 is in range we\"ll again add both of its child to queue.\\nand the process goes....\\nthe moment we get a node in given range we take the sum of it and add it to a variable.\\n\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n          if(root==NULL)return 0;\\n        queue<TreeNode*>q;\\n        int res=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode*temp=q.front();\\n            q.pop();\\n            if(temp->val<low)\\n            {\\n                if(temp->right!=NULL)q.push(temp->right);\\n            }\\n            else if(temp->val>high)\\n            {\\n                if(temp->left!=NULL)q.push(temp->left);\\n            }\\n\\n            else if(temp->val>=low&&temp->val<=high)\\n            {\\n                res+=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);   \\n            }\\n           \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**HAPPY CODING!**\\n\\n\\n\\n\\n\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n          if(root==NULL)return 0;\\n        queue<TreeNode*>q;\\n        int res=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode*temp=q.front();\\n            q.pop();\\n            if(temp->val<low)\\n            {\\n                if(temp->right!=NULL)q.push(temp->right);\\n            }\\n            else if(temp->val>high)\\n            {\\n                if(temp->left!=NULL)q.push(temp->left);\\n            }\\n\\n            else if(temp->val>=low&&temp->val<=high)\\n            {\\n                res+=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);   \\n            }\\n           \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159445,
                "title": "3-line-c-solution-without-creating-new-function",
                "content": "end to end recursive c++ solution.\\n\\n```\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL) return 0;\\n        \\n        if(root->val>=low && root->val<=high){\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL) return 0;\\n        \\n        if(root->val>=low && root->val<=high){\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146310,
                "title": "javascript-stack-easy",
                "content": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let stack = [root];\\n    let sum = 0;\\n    while(stack.length !== 0) {\\n        let currentNode = stack.pop();\\n        if (currentNode !== null) {\\n            if (currentNode.val >= low && currentNode.val <= high) {\\n                sum += currentNode.val;\\n            }\\n            // when current value is greater than low, we check the left node since the left node is always smaller than current node\\n            if (currentNode.val > low) {\\n                stack.push(currentNode.left);\\n            }\\n            if (currentNode.val < high) {\\n                stack.push(currentNode.right);\\n            }\\n        }\\n    }\\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let stack = [root];\\n    let sum = 0;\\n    while(stack.length !== 0) {\\n        let currentNode = stack.pop();\\n        if (currentNode !== null) {\\n            if (currentNode.val >= low && currentNode.val <= high) {\\n                sum += currentNode.val;\\n            }\\n            // when current value is greater than low, we check the left node since the left node is always smaller than current node\\n            if (currentNode.val > low) {\\n                stack.push(currentNode.left);\\n            }\\n            if (currentNode.val < high) {\\n                stack.push(currentNode.right);\\n            }\\n        }\\n    }\\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1131662,
                "title": "simple-js-faster-than-95",
                "content": "```\\nconst rangeSumBST =(root, low, high)=> {\\n    let q = [];\\n    q.push(root);\\n    let sum =0;\\n    while(q.length){\\n        const temp = q.pop();\\n        if(temp.left) q.push(temp.left);\\n        if(temp.right) q.push(temp.right);\\n        sum = temp.val>=low && temp.val<=high ? sum+temp.val : sum;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst rangeSumBST =(root, low, high)=> {\\n    let q = [];\\n    q.push(root);\\n    let sum =0;\\n    while(q.length){\\n        const temp = q.pop();\\n        if(temp.left) q.push(temp.left);\\n        if(temp.right) q.push(temp.right);\\n        sum = temp.val>=low && temp.val<=high ? sum+temp.val : sum;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093153,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node == NULL)\\n                continue;\\n            if(node->val >= low && node->val <= high)\\n                sum += node->val;\\n            \\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node == NULL)\\n                continue;\\n            if(node->val >= low && node->val <= high)\\n                sum += node->val;\\n            \\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937409,
                "title": "follow-up-question-for-interview-preparations",
                "content": "I see that many people got confused by the language of the question, but still this question seems easy.\\nIf this question were to appear in a interview, it will be a warm up question and then it will be slightly modified to add complexity.\\n\\nOne such question - How can we handle if there are multiple queries for getting range sum ? i.e. ```getRangeSumBST(int low, int high)``` is called again and again with different low, high values. \\nHow would you optimize? \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```getRangeSumBST(int low, int high)```",
                "codeTag": "Unknown"
            },
            {
                "id": 936345,
                "title": "c-recursive-one-liner-solutions-explained-100-time-80-space",
                "content": "This is a rather straightfoward problem and we might easily solve it calling a helper `dfs` function to gradually go top-down, from node to node, to solve it.\\n\\nI preferred going for an extra bit of challenge and writing directly a recursive one-liner, ignoring the condition that it is a BST, since I found little value in potentially skipping a conditional every time we examine a node, whereas that would have costed much more code complexity.\\n\\nTo do so, I \"hid\" the result variable as a fourth optional parameter, defaulted to `0`.\\n\\nI will then return it when `root == NULL`, ie: we ended up out of the tree; otherwise, I will call recursively our `rangeSumBST` function on both the `left` and `right` branches, with a twist:\\n* the call to the `left` branch will keep increasing `res` with the value of the current `root->val`;\\n* the call to the `right` branch will every time reset `res` to `0` and compute a sub-sum from scratch.\\n\\nOnce all the recursive calls will be done, we I will have to just the result of `root->val` plus the sub-sum of everything to the left of it with the sub-sum of whatever is at the right of it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high, int res = 0) {\\n        return root ? rangeSumBST(root->left, low, high, res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, low, high) : res;\\n    }\\n};\\n```\\n\\nAnd looking back to the one-liner I wrote in May, one that has some earlier stopping condition, I really struggle to find it worth in terms of extra performances, since it is one more check at each step.\\n\\nBasically at each iteration we update the upper and lower limit `low` and `high` as we go: going `left` will reduce potentially reduce `high`, while going `right` will have us check if we need to update `low`.\\n\\nAt the beginning of our code, we are not checking that `root` is not `NULL`, plus the new condition `low <= high`, meaning we already reached a part of the tree that does not matter to us.\\n\\nFor example, if we started with `low == 10` and `high == 20`, moving `left` after having it a node with value `9` or lower (and thus having updated `high` to that value) would not be meaningul, since by definition any value to its left needs to be smaller in a BST; similarly moving `right` after encountering anything `> 20` should have us halt right there.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        return root && low <= high ? (root->val >= low && root->val <= high ? root->val : 0) + rangeSumBST(root->left, low, min(high, root->val)) + rangeSumBST(root->right, max(root->val, low), high) : 0;\\n    }\\n};\\n```\\n\\nHybrid of the 2 approaches, using also [RedaKerouicha](https://leetcode.com/RedaKerouicha/)\\'s suggestion:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, const int low, const int high, const int res = 0) {\\n        return root && low <= high ? rangeSumBST(root->left, low, min(high, root->val), res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, max(root->val, low), high) : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high, int res = 0) {\\n        return root ? rangeSumBST(root->left, low, high, res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, low, high) : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        return root && low <= high ? (root->val >= low && root->val <= high ? root->val : 0) + rangeSumBST(root->left, low, min(high, root->val)) + rangeSumBST(root->right, max(root->val, low), high) : 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, const int low, const int high, const int res = 0) {\\n        return root && low <= high ? rangeSumBST(root->left, low, min(high, root->val), res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, max(root->val, low), high) : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825233,
                "title": "recursive-solution-dfs-solution-with-one-trick-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // recursive solution\\n\\t\\n\\t``\\n    //one simple trick you bcan use is that you can find the inorder of bst and add l to r all values\\n\\t``\\n\\t\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n         int ans = 0;\\n        dfs(root, L, R,ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int L, int R,int & ans) {\\n        if (node != NULL) {\\n            if (L <= node -> val && node ->  val <= R)\\n                ans += node -> val;\\n            if (L < node -> val)\\n                dfs(node -> left, L, R,ans);\\n            if (node ->  val < R)\\n                dfs(node -> right, L, R,ans);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // recursive solution\\n\\t\\n\\t``\\n    //one simple trick you bcan use is that you can find the inorder of bst and add l to r all values\\n\\t``\\n\\t\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n         int ans = 0;\\n        dfs(root, L, R,ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int L, int R,int & ans) {\\n        if (node != NULL) {\\n            if (L <= node -> val && node ->  val <= R)\\n                ans += node -> val;\\n            if (L < node -> val)\\n                dfs(node -> left, L, R,ans);\\n            if (node ->  val < R)\\n                dfs(node -> right, L, R,ans);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637185,
                "title": "go-recursive",
                "content": "```go\\nfunc rangeSumBST(root *TreeNode, L int, R int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    res := 0\\n    \\n    // Node is within range\\n    if root.Val >= L && root.Val <= R {\\n        res += root.Val\\n    }\\n    \\n    // Range is overlapped with left tree\\n    if root.Val > L {\\n        res += rangeSumBST(root.Left, L, R)\\n    }\\n    \\n    // Range is overlapped with right tree\\n    if root.Val < R {\\n        res += rangeSumBST(root.Right, L, R)\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc rangeSumBST(root *TreeNode, L int, R int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    res := 0\\n    \\n    // Node is within range\\n    if root.Val >= L && root.Val <= R {\\n        res += root.Val\\n    }\\n    \\n    // Range is overlapped with left tree\\n    if root.Val > L {\\n        res += rangeSumBST(root.Left, L, R)\\n    }\\n    \\n    // Range is overlapped with right tree\\n    if root.Val < R {\\n        res += rangeSumBST(root.Right, L, R)\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359598,
                "title": "scala-using-pattern-matching",
                "content": "```\\nobject Solution {\\n    def rangeSumBST(root: TreeNode, L: Int, R: Int): Int = root match {\\n        case r if r == null => \\n            0\\n        case r if r.value < L => \\n            rangeSumBST(r.right,L,R)\\n        case r if r.value > R => \\n            rangeSumBST(r.left,L,R)\\n        case r => \\n            r.value + rangeSumBST(r.right,L,R) + rangeSumBST(r.left,L,R)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def rangeSumBST(root: TreeNode, L: Int, R: Int): Int = root match {\\n        case r if r == null => \\n            0\\n        case r if r.value < L => \\n            rangeSumBST(r.right,L,R)\\n        case r if r.value > R => \\n            rangeSumBST(r.left,L,R)\\n        case r => \\n            r.value + rangeSumBST(r.right,L,R) + rangeSumBST(r.left,L,R)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 333717,
                "title": "c-one-liner",
                "content": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n\\treturn root ? (root->val >= L && root->val <= R ? root->val : 0) + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) : 0;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n\\treturn root ? (root->val >= L && root->val <= R ? root->val : 0) + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299679,
                "title": "simple-java-solution-0ms-faster-than-100-solution",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return -1;\\n        if(root.val >=L && root.val<=R) ans+= root.val;\\n        if(root.val>L) rangeSumBST(root.left, L, R);\\n        if(root.val<R) rangeSumBST(root.right, L, R);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return -1;\\n        if(root.val >=L && root.val<=R) ans+= root.val;\\n        if(root.val>L) rangeSumBST(root.left, L, R);\\n        if(root.val<R) rangeSumBST(root.right, L, R);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296103,
                "title": "i-am-confused-on-how-to-represent-this-tree",
                "content": "so if we have \\n\\nroot = [10, 5, 15, 3, 7, null, 18], L = 7, R = 15\\n\\nShouldn\\'t the output be 37 because the tree would be represented this way\\n\\n                             10\\n\\t\\t\\t\\t\\t\\t\\t /  \\\\\\n\\t\\t\\t\\t\\t\\t   5    15\\n\\t\\t\\t\\t\\t\\t  /  \\\\    \\\\\\n\\t\\t\\t\\t\\t\\t 3\\t 7\\t 18\\n\\t\\t\\t\\t\\t\\t \\nIf the previous representation is the correct way, then the answer should be 37 because 7+5+10+15\\n\\nHow are they getting 32?\\n",
                "solutionTags": [],
                "code": "so if we have \\n\\nroot = [10, 5, 15, 3, 7, null, 18], L = 7, R = 15\\n\\nShouldn\\'t the output be 37 because the tree would be represented this way\\n\\n                             10\\n\\t\\t\\t\\t\\t\\t\\t /  \\\\\\n\\t\\t\\t\\t\\t\\t   5    15\\n\\t\\t\\t\\t\\t\\t  /  \\\\    \\\\\\n\\t\\t\\t\\t\\t\\t 3\\t 7\\t 18\\n\\t\\t\\t\\t\\t\\t \\nIf the previous representation is the correct way, then the answer should be 37 because 7+5+10+15\\n\\nHow are they getting 32?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 284070,
                "title": "c-code-using-dfs",
                "content": "````\\n\\npublic int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root == null) return 0;\\n        return ((root.val>=L && root.val<=R) ? root.val : 0)+\\n            RangeSumBST(root.left,L,R)+\\n        RangeSumBST(root.right,L,R);\\n    }\\n\\n// using a variable\\n\\npublic class Solution {\\n    private int sum = 0;\\n    public int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root!=null)\\n        {\\n            RangeSumBST(root.left,L,R);\\n            sum+= (root.val>=L && root.val<=R) ? root.val : 0;\\n            RangeSumBST(root.right,L,R);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\n\\npublic int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root == null) return 0;\\n        return ((root.val>=L && root.val<=R) ? root.val : 0)+\\n            RangeSumBST(root.left,L,R)+\\n        RangeSumBST(root.right,L,R);\\n    }\\n\\n// using a variable\\n\\npublic class Solution {\\n    private int sum = 0;\\n    public int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root!=null)\\n        {\\n            RangeSumBST(root.left,L,R);\\n            sum+= (root.val>=L && root.val<=R) ? root.val : 0;\\n            RangeSumBST(root.right,L,R);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196165,
                "title": "c-simple-bfs",
                "content": "```\\n public int RangeSumBST(TreeNode root, int L, int R) {\\n        \\n        var totalSum = 0;\\n\\n        var que = new Queue<TreeNode>();\\n        que.Enqueue(root);\\n\\n        while (que.Count() > 0)\\n        {\\n            root = que.Dequeue();\\n          if(root.val >= L && root.val <= R){\\n              totalSum += root.val;\\n          }\\n\\n            if (root.left != null)\\n            {\\n                que.Enqueue(root.left);\\n            }\\n            if (root.right != null)\\n            {\\n                que.Enqueue(root.right);\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int RangeSumBST(TreeNode root, int L, int R) {\\n        \\n        var totalSum = 0;\\n\\n        var que = new Queue<TreeNode>();\\n        que.Enqueue(root);\\n\\n        while (que.Count() > 0)\\n        {\\n            root = que.Dequeue();\\n          if(root.val >= L && root.val <= R){\\n              totalSum += root.val;\\n          }\\n\\n            if (root.left != null)\\n            {\\n                que.Enqueue(root.left);\\n            }\\n            if (root.right != null)\\n            {\\n                que.Enqueue(root.right);\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192065,
                "title": "c-with-morris-inorder-traversal",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n   \\n    int inorderTraversal(TreeNode* root,int L, int R){\\n        int sum = 0;\\n        TreeNode *cur = root,*pre;\\n        while(cur!=nullptr){\\n            if(cur->left!=nullptr){\\n                pre = cur->left;\\n                while(pre->right!=nullptr && pre->right!=cur){\\n                    pre = pre->right;\\n                }\\n                if(pre->right==nullptr){\\n                    pre->right = cur;\\n                    cur = cur->left;\\n                }else{\\n                    if(cur->val>=L && cur->val<=R)\\n                        sum+=cur->val;\\n                    pre->right = nullptr;\\n                    cur = cur->right;\\n                }\\n            }else{\\n                if(cur->val>=L && cur->val<=R)\\n                        sum+=cur->val;\\n                cur = cur->right;\\n            }\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root==nullptr)\\n            return 0;\\n        return inorderTraversal(root,L,R);\\n    }\\n};\\n\\'\\'\\'\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    int inorderTraversal(TreeNode* root,int L, int R){\\n        int sum = 0;\\n        TreeNode *cur = root,*pre;\\n        while(cur!=nullptr){\\n            if(cur->left!=nullptr){\\n                pre = cur->left;\\n                while(pre->right!=nullptr && pre->right!=cur){\\n                    pre = pre->right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4004175,
                "title": "well-defined-full-explanation-c-solution-easy-to-understand",
                "content": "Solution is quite simple. Lets recall the properties of a Binary Search Tree.\\n\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n1. The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n2. The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n3. The left and right subtree each must also be a binary search tree.\\n\\nThe code I\\'ve provided is a recursive function for traversing a binary search tree (BST) in a modified form of Inorder Traversal. In a standard Inorder Traversal, you would visit nodes in ascending order. However, this function is modified to only visit nodes that fall within a specified range defined by low and high.\\n\\nHere\\'s how it works:\\n\\n1. If the current node\\'s value (root->val) is within the range [low, high], it includes the value of the current node in the sum and then recursively calls the function on both the left and right subtrees.\\n\\n2. If the current node\\'s value is less than low, it means that all values in the left subtree are also less than low, so it recursively calls the function on the right subtree only.\\n\\n3. If the current node\\'s value is greater than high, it means that all values in the right subtree are also greater than high, so it recursively calls the function on the left subtree only.\\n\\nThis approach efficiently eliminates the need to visit nodes that are guaranteed to be outside the specified range, making it a modified Inorder Traversal tailored for this specific problem.\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL)return 0;\\n        \\n        if(root->val >= low && root->val <= high){\\n            return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n        }\\n        \\n        //use property of BST that how elements are arranged.\\n        //if we have root value lessThan LOW then, discard the left part of the BST.\\n        if(root->val<low)\\n            return rangeSumBST(root->right , low , high);\\n        //if we have root value greaterThan HIGH then, discard the right part of the BST.\\n        return rangeSumBST(root->left , low , high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL)return 0;\\n        \\n        if(root->val >= low && root->val <= high){\\n            return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n        }\\n        \\n        //use property of BST that how elements are arranged.\\n        //if we have root value lessThan LOW then, discard the left part of the BST.\\n        if(root->val<low)\\n            return rangeSumBST(root->right , low , high);\\n        //if we have root value greaterThan HIGH then, discard the right part of the BST.\\n        return rangeSumBST(root->left , low , high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525288,
                "title": "solution",
                "content": "```C++ []\\nconst int ZERO = [](){\\n     ios_base::sync_with_stdio(false);\\n     cin.tie(nullptr);\\n     return 0;\\n}();\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == nullptr) return 0;\\n\\n        if(root->val < low) root->left = nullptr;\\n        if(root->val > high) root->right = nullptr;\\n\\n        return (root->val >= low && root->val <=high ? root->val : 0) +rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root:\\n            return 0 \\n        elif root.val<low:\\n            return self.rangeSumBST(root.right,low,high) \\n        elif root.val>high:\\n            return self.rangeSumBST(root.left,low,high) \\n        return root.val + self.rangeSumBST(root.left,low,high)+self.rangeSumBST(root.right,low,high)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int ans = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        helper(root, low, high);\\n        return ans;\\n    }\\n    public void helper(TreeNode root, int low, int high) {\\n        if (root == null) return;\\n\\n        if (root.val > low) {\\n            helper(root.left, low, high);\\n        }\\n        if (root.val >= low && root.val <= high) {\\n            ans += root.val;\\n        }\\n        if (root.val < high) {\\n            helper(root.right, low, high);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nconst int ZERO = [](){\\n     ios_base::sync_with_stdio(false);\\n     cin.tie(nullptr);\\n     return 0;\\n}();\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == nullptr) return 0;\\n\\n        if(root->val < low) root->left = nullptr;\\n        if(root->val > high) root->right = nullptr;\\n\\n        return (root->val >= low && root->val <=high ? root->val : 0) +rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root:\\n            return 0 \\n        elif root.val<low:\\n            return self.rangeSumBST(root.right,low,high) \\n        elif root.val>high:\\n            return self.rangeSumBST(root.left,low,high) \\n        return root.val + self.rangeSumBST(root.left,low,high)+self.rangeSumBST(root.right,low,high)\\n```\n```Java []\\nclass Solution {\\n    public int ans = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        helper(root, low, high);\\n        return ans;\\n    }\\n    public void helper(TreeNode root, int low, int high) {\\n        if (root == null) return;\\n\\n        if (root.val > low) {\\n            helper(root.left, low, high);\\n        }\\n        if (root.val >= low && root.val <= high) {\\n            ans += root.val;\\n        }\\n        if (root.val < high) {\\n            helper(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395967,
                "title": "easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        if(root.val>=low && root.val<=high){\\n            return root.val+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n        }else if(root.val<low){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            return rangeSumBST(root.left,low,high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        if(root.val>=low && root.val<=high){\\n            return root.val+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n        }else if(root.val<low){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            return rangeSumBST(root.left,low,high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344324,
                "title": "python3-iterative-dfs-recursive-dfs-bfs",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterative DFS\\nRecursive DFS\\nBFS\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n\\n                                                    #recursive DFS\\n        # a = []\\n        # def dfs(node):\\n        #     if not node:\\n        #         return\\n        #     if low <= node.val <= high:\\n        #         a.append(node.val)\\n        #     dfs(node.left)\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # return sum(a)\\n\\n                                                            #DFS                                        \\n        stack = [(root, root.val)]\\n        a = 0\\n        while stack:\\n            node, val = stack.pop()\\n            if low <= val <= high:\\n                a += val\\n            if node.left:\\n                stack.append((node.left, node.left.val))\\n            if node.right:\\n                stack.append((node.right, node.right.val))\\n        return a\\n\\n                                                            #BSF\\n        \\n        # d = collections.deque([(root, root.val)])\\n        # a = 0\\n        # while d:\\n        #     node, val = d.popleft()\\n        #     if low <= val <= high:\\n        #         a += val\\n        #     if not ( node.left or node.right):\\n        #         continue\\n        #     if node.left:\\n        #         d.append((node.left, node.left.val))\\n        #     if node.right:\\n        #         d.append((node.right, node.right.val))\\n        # return a\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n\\n                                                    #recursive DFS\\n        # a = []\\n        # def dfs(node):\\n        #     if not node:\\n        #         return\\n        #     if low <= node.val <= high:\\n        #         a.append(node.val)\\n        #     dfs(node.left)\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # return sum(a)\\n\\n                                                            #DFS                                        \\n        stack = [(root, root.val)]\\n        a = 0\\n        while stack:\\n            node, val = stack.pop()\\n            if low <= val <= high:\\n                a += val\\n            if node.left:\\n                stack.append((node.left, node.left.val))\\n            if node.right:\\n                stack.append((node.right, node.right.val))\\n        return a\\n\\n                                                            #BSF\\n        \\n        # d = collections.deque([(root, root.val)])\\n        # a = 0\\n        # while d:\\n        #     node, val = d.popleft()\\n        #     if low <= val <= high:\\n        #         a += val\\n        #     if not ( node.left or node.right):\\n        #         continue\\n        #     if node.left:\\n        #         d.append((node.left, node.left.val))\\n        #     if node.right:\\n        #         d.append((node.right, node.right.val))\\n        # return a\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240199,
                "title": "storing-values-in-range-c-omar-kashif",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    First we store all the values (from the tree) that are in the range\\n    then we simply sum them up, and return the sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    void foo(TreeNode* root, int low, int high, vector<int>&a)\\n    {\\n        if(root==nullptr)\\n            return;\\n        if(root->val>=low && root->val<=high)\\n            a.push_back(root->val);\\n        if(root->right!=nullptr)\\n            foo(root->right,low,high,a);\\n        if(root->left!=nullptr)\\n            foo(root->left,low,high,a);\\n    }\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        foo(root,low,high,v);\\n        int n=v.size(), sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=v[i];\\n        return sum;\\n    }\\n    // Code by OK!\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    void foo(TreeNode* root, int low, int high, vector<int>&a)\\n    {\\n        if(root==nullptr)\\n            return;\\n        if(root->val>=low && root->val<=high)\\n            a.push_back(root->val);\\n        if(root->right!=nullptr)\\n            foo(root->right,low,high,a);\\n        if(root->left!=nullptr)\\n            foo(root->left,low,high,a);\\n    }\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        foo(root,low,high,v);\\n        int n=v.size(), sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=v[i];\\n        return sum;\\n    }\\n    // Code by OK!\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142790,
                "title": "range-path-sum-bst-optimal-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val <= high){\\n            rangeSumBST(root.left, low, high);\\n            sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        }\\n        else if(root.val>=high){\\n            rangeSumBST(root.left, low, high);\\n        } else {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val <= high){\\n            rangeSumBST(root.left, low, high);\\n            sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        }\\n        else if(root.val>=high){\\n            rangeSumBST(root.left, low, high);\\n        } else {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888265,
                "title": "cpp-recursion-efficient-solution",
                "content": "# Approach\\nCheck if current node is betweeen [low, high] and recurse accordingly for the subtrees.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root) return 0;\\n    \\n        if(root->val < low) return rangeSumBST(root->right, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else if(root->val > high) return rangeSumBST(root->left, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else return root->val + rangeSumBST(root->right, low, high) + rangeSumBST(root->left, low, high);\\n        // Required nodes can be in both subtree + Add node->val\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root) return 0;\\n    \\n        if(root->val < low) return rangeSumBST(root->right, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else if(root->val > high) return rangeSumBST(root->left, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else return root->val + rangeSumBST(root->right, low, high) + rangeSumBST(root->left, low, high);\\n        // Required nodes can be in both subtree + Add node->val\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888217,
                "title": "simple-java-solution-0ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sum = 0;\\n\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(low <= root.val && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sum = 0;\\n\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(low <= root.val && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888145,
                "title": "938-range-sum-of-bst-java-0-ms-faster-than-100-00-using-dfs-clean-code-with-comment",
                "content": "If you like the solution then an Upvote would really be an O(n) decision :)\\n```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2888105,
                "title": "java-simple-100-faster-solution",
                "content": "# Intuition\\nThink of it as a binary search... Just with one change that you\\'re not actually looking for a value but for a range of values.\\n\\n# Approach\\nJust follow the similar strategy as you would follow in case of Binary Search that is discard halves if your current node falls out of range.\\n\\n# Complexity\\n- Time complexity:\\nO(N) -> In worst case all your elements might fall in range\\n- Space complexity:\\nO(N) -> Recursive Stack Space\\n# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n\\n        if(root.val < low){   // if current node value is less than low than move it to greater side that is right side\\n            return rangeSumBST(root.right, low, high);\\n        }else if(root.val > high){  // if current node value is greater than high than move it to lower side that is left side\\n            return rangeSumBST(root.left, low, high);\\n        }else{  // if it\\'s in range add the current value and repeat for left and right subtree\\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n\\n        if(root.val < low){   // if current node value is less than low than move it to greater side that is right side\\n            return rangeSumBST(root.right, low, high);\\n        }else if(root.val > high){  // if current node value is greater than high than move it to lower side that is left side\\n            return rangeSumBST(root.left, low, high);\\n        }else{  // if it\\'s in range add the current value and repeat for left and right subtree\\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887794,
                "title": "how-do-i-replace-vecdeque-with-vec-allahu-s-greatest-warrior",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdd them up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVist every node withing range and add them to sum before returnign sum\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```rs\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, low: i32, high: i32) -> i32 {\\n        let mut stack: std::collections::VecDeque<Option<Rc<RefCell<TreeNode>>>> = std::collections::VecDeque::new();\\n        stack.push_back(root);\\n\\n        let mut sum:i32 = 0;\\n        while let Some(stack_object) = stack.pop_front() {\\n            let node = stack_object.as_ref().unwrap().replace(TreeNode::new(0));\\n            if node.val <= high && node.val >= low { \\n                sum += node.val; \\n            }\\n        \\n            if node.val > low && node.left.is_some() { stack.push_back(node.left); }\\n            if node.val < high && node.right.is_some() { stack.push_back(node.right); }\\n        }\\n        sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, low: i32, high: i32) -> i32 {\\n        let mut stack: std::collections::VecDeque<Option<Rc<RefCell<TreeNode>>>> = std::collections::VecDeque::new();\\n        stack.push_back(root);\\n\\n        let mut sum:i32 = 0;\\n        while let Some(stack_object) = stack.pop_front() {\\n            let node = stack_object.as_ref().unwrap().replace(TreeNode::new(0));\\n            if node.val <= high && node.val >= low { \\n                sum += node.val; \\n            }\\n        \\n            if node.val > low && node.left.is_some() { stack.push_back(node.left); }\\n            if node.val < high && node.right.is_some() { stack.push_back(node.right); }\\n        }\\n        sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887681,
                "title": "simple-c-solution-with-comments",
                "content": "# Intuition and Approach\\nWe traverse the tree using a depth first search. If root\\'s data falls inside the range` [low, high]`, then we will add root\\'s data in `sum` else we will traverse left branch and right branch until root is `NULL`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // sum will store the sum of values of all nodes with a value\\n    // in the inclusive range [low, high].\\n    int sum = 0;\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        //Edge Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        //Checking if the root\\'s data lies in the inclusive\\n        // range [low, high] if yes then add the value of \\n        //root\\'s data in sum\\n        if(root->val >= low && root->val <= high){\\n            sum += root->val;\\n        }\\n        //Calling left and right branch\\n        rangeSumBST(root->left,low,high);\\n        rangeSumBST(root->right,low,high);\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:O(n), where n is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n), is a worst case space required by stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // sum will store the sum of values of all nodes with a value\\n    // in the inclusive range [low, high].\\n    int sum = 0;\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        //Edge Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        //Checking if the root\\'s data lies in the inclusive\\n        // range [low, high] if yes then add the value of \\n        //root\\'s data in sum\\n        if(root->val >= low && root->val <= high){\\n            sum += root->val;\\n        }\\n        //Calling left and right branch\\n        rangeSumBST(root->left,low,high);\\n        rangeSumBST(root->right,low,high);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887668,
                "title": "extremely-easy-just-do-one-traversal-c",
                "content": "# Approach\\n- Do any type of binary tree traversal and store the node values.\\n- Iterate over the values and apply the conditions.\\n\\n(This approach is quite lengthy and this question can be done in traversing tree and applying conditions simultaneously.)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   void preorder(TreeNode* root, vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> v;\\n        preorder(root,v);\\n        int ans=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low && v[i]<=high) ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   void preorder(TreeNode* root, vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> v;\\n        preorder(root,v);\\n        int ans=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low && v[i]<=high) ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887584,
                "title": "easy-approach",
                "content": "# Intuition\\nFirst thought that must comes to mind must be to store inorder traversal in case of BST.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Storing inorder traversal \\n2.Then,from low to high range add the available values.\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,ans);\\n       ans.push_back(root->val);\\n        inorder(root->right,ans);\\n        \\n    }\\n\\npublic:\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n//            \\n//      // inorder ->sorted array\\n//     // from low to high elements hai \\n//      //or fir unka sum kralenge\\n            vector<int> ans;\\n            inorder(root,ans);\\n\\n        int sum = 0;\\n        \\n        for (int i : ans) {\\n            if (i >= low && i <= high)\\n            sum += i;\\n        }\\n        \\n        return sum;\\n            \\n    }\\n\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,ans);\\n       ans.push_back(root->val);\\n        inorder(root->right,ans);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2887479,
                "title": "simple-c-recursive",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int RangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        if (root == null)\\n            return sum;\\n        if (root.val >= low && root.val <= high)\\n            sum += root.val;\\n        if (root.val > low)\\n            sum += RangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n            sum += RangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        if (root == null)\\n            return sum;\\n        if (root.val >= low && root.val <= high)\\n            sum += root.val;\\n        if (root.val > low)\\n            sum += RangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n            sum += RangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887423,
                "title": "go-recursive-solution-beats-100-naive-and-optimal-solution-explained",
                "content": "1. Naive approach \\n\\nTraverse the entire tree, note the nodes that falls under the range, and add them all together. This is the simplest possible solution with O(N) time complexity and O(N) memory.\\n\\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n        var sum = 0\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := rangeSumBST(root.Left, low, high)\\n\\n        r := rangeSumBST(root.Right, low, high)\\n        return sum + l + r\\n}\\n```\\n\\n2. Optimal Solution\\n\\nNow, can we do better? **YES**.  There are plenty of **unneccesary** work in the previous solution. \\n\\nRemember, it\\'s a **Binary Search Tree**, meaning, the left node is guaranteed to have a smaller value than the root, and the right node is guaranteed to have a greater value than the root. \\n\\nWhy would we want to traverse the **LEFT** subtree if the **low >= root.Val**, similarly, why would we want to traverse the **RIGHT** subtree if **high <= root.Val**?\\n\\nWith these optimizations our avg. time complexity becomes O(logN) on average.\\n\\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n\\n        var sum = 0\\n\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := 0\\n        r := 0\\n\\n        if low <= root.Val {\\n                l = rangeSumBST(root.Left, low, high)\\n        }\\n\\n        if high >= root.Val {\\n                r = rangeSumBST(root.Right, low, high)\\n        }\\n\\n        return sum + l + r\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Binary Search Tree"
                ],
                "code": "```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n        var sum = 0\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := rangeSumBST(root.Left, low, high)\\n\\n        r := rangeSumBST(root.Right, low, high)\\n        return sum + l + r\\n}\\n```\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n\\n        var sum = 0\\n\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := 0\\n        r := 0\\n\\n        if low <= root.Val {\\n                l = rangeSumBST(root.Left, low, high)\\n        }\\n\\n        if high >= root.Val {\\n                r = rangeSumBST(root.Right, low, high)\\n        }\\n\\n        return sum + l + r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887003,
                "title": "5-lines-very-easy-solution-using-normal-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\tdef rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n\\t\\treturn self.helper(root,0,L,R)\\n\\n\\tdef helper(self,node,res,L,R):\\n\\t\\tif not node:\\n\\t\\t\\treturn res\\n\\t\\tif node.val>=L and node.val<=R:\\n\\t\\t\\tres+=node.val\\n\\t\\tres=self.helper(node.left,res,L,R)\\n\\t\\tres=self.helper(node.right,res,L,R)\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n\\tdef rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n\\t\\treturn self.helper(root,0,L,R)\\n\\n\\tdef helper(self,node,res,L,R):\\n\\t\\tif not node:\\n\\t\\t\\treturn res\\n\\t\\tif node.val>=L and node.val<=R:\\n\\t\\t\\tres+=node.val\\n\\t\\tres=self.helper(node.left,res,L,R)\\n\\t\\tres=self.helper(node.right,res,L,R)\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886533,
                "title": "easy-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n\\n        if(root->val < low)\\n            return rangeSumBST(root->right , low , high);\\n            \\n        if(root->val >high)\\n            return rangeSumBST(root->left , low , high);\\n        \\n        return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n\\n        if(root->val < low)\\n            return rangeSumBST(root->right , low , high);\\n            \\n        if(root->val >high)\\n            return rangeSumBST(root->left , low , high);\\n        \\n        return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886501,
                "title": "2-lines-hot-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        return ((root.val>=low && root.val<=high)?root.val:0)+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        return ((root.val>=low && root.val<=high)?root.val:0)+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886238,
                "title": "range-sum-of-bst-100ms-solution-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing with any order Traversal and Cheaking the Condition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) squeue tree:worst case\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n    stack<TreeNode*>st;\\n    st.push(root);\\n    int sum=0;\\n    while(!st.empty()){\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        if(temp->val>=low && temp->val<=high) sum+=temp->val;\\n        if(temp->left!=NULL) st.push(temp->left);\\n        if(temp->right!=NULL) st.push(temp->right);\\n    }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n    stack<TreeNode*>st;\\n    st.push(root);\\n    int sum=0;\\n    while(!st.empty()){\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        if(temp->val>=low && temp->val<=high) sum+=temp->val;\\n        if(temp->left!=NULL) st.push(temp->left);\\n        if(temp->right!=NULL) st.push(temp->right);\\n    }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886031,
                "title": "simple-dfs-solution-beats-90-python",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = []\\n        if not root:\\n            return 0\\n        def DFS(node):\\n            if node:\\n                if low <= node.val <= high :\\n                    res.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        DFS(root)\\n        return sum(res)\\n\\n```\\n\\n**Upvote if you like the solution.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = []\\n        if not root:\\n            return 0\\n        def DFS(node):\\n            if node:\\n                if low <= node.val <= high :\\n                    res.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        DFS(root)\\n        return sum(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885741,
                "title": "simple-3-line-python-java-c-solution",
                "content": "# Intuition\\nA classical Recursion Problem similar to find height and depth of tree.\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if (root == NULL) return 0;\\n\\n        int child = rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n        if (root->val >= low && root->val <= high){\\n            return root->val + child; \\n        }\\n        return child;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if (root == None): return 0\\n\\n        val = root.val if low <= root.val <= high else 0\\n\\n        return val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\\n```Java []\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int val = (low <= root.val && root.val <= high) ? root.val: 0;\\n        return val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right,low, high);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if (root == NULL) return 0;\\n\\n        int child = rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n        if (root->val >= low && root->val <= high){\\n            return root->val + child; \\n        }\\n        return child;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if (root == None): return 0\\n\\n        val = root.val if low <= root.val <= high else 0\\n\\n        return val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\n```Java []\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int val = (low <= root.val && root.val <= high) ? root.val: 0;\\n        return val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right,low, high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885585,
                "title": "3-approaches-faster-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Pre order Traversal : root -> left -> right\\n- Check if values of these nodes lie in given range \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0\\n        \\n        ans = 0\\n        if low <= root.val <= high:\\n            ans += root.val\\n        ans += self.rangeSumBST(root.left,low,high)\\n        ans += self.rangeSumBST(root.right,low,high)\\n\\n        return ans \\n        \\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        return (root.val if low <= root.val <= high else 0) + \\\\\\n                self.rangeSumBST(root.left,low,high) + \\\\\\n                self.rangeSumBST(root.right,low,high)\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In a BST, value of left node < value of root < value of right node\\n- So, we will take advantage of the same. \\n- Add the value of left node only if root val > low, because, if root val < low then left nodes value will also be less. \\n- Add the value of right node only if root val < high , because, if root val > high then right nodes value will also be more.\\n- Doing this just to reduce the number of iterations \\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        # Taking advantage of BST\\n        if not root:\\n            return 0 \\n        \\n        ans = 0\\n        ans += root.val if low <= root.val <= high else 0 \\n        if root.val > low:\\n            ans += self.rangeSumBST(root.left,low,high)\\n        if root.val < high:\\n            ans += self.rangeSumBST(root.right,low,high)\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0\\n        \\n        ans = 0\\n        if low <= root.val <= high:\\n            ans += root.val\\n        ans += self.rangeSumBST(root.left,low,high)\\n        ans += self.rangeSumBST(root.right,low,high)\\n\\n        return ans \\n        \\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        return (root.val if low <= root.val <= high else 0) + \\\\\\n                self.rangeSumBST(root.left,low,high) + \\\\\\n                self.rangeSumBST(root.right,low,high)\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        # Taking advantage of BST\\n        if not root:\\n            return 0 \\n        \\n        ans = 0\\n        ans += root.val if low <= root.val <= high else 0 \\n        if root.val > low:\\n            ans += self.rangeSumBST(root.left,low,high)\\n        if root.val < high:\\n            ans += self.rangeSumBST(root.right,low,high)\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885572,
                "title": "range-sum-easy-java-solution-o-n",
                "content": "# Intuition\\nWe can do traversal either (Pre , Post or IN) does\\'nt matter.\\n\\n# Approach\\nWe need to just check the current node lies in between low and high inclusive edge.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(h)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n     if(root == null) \\n        return result;\\n        \\n        if(root.val == low || root.val == high || (root.val>low) && (root.val<high)){\\n            result+=root.val;\\n        }\\n        rangeSumBST(root.left, low, high);\\n        rangeSumBST(root.right, low, high);\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n     if(root == null) \\n        return result;\\n        \\n        if(root.val == low || root.val == high || (root.val>low) && (root.val<high)){\\n            result+=root.val;\\n        }\\n        rangeSumBST(root.left, low, high);\\n        rangeSumBST(root.right, low, high);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885555,
                "title": "video-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVisit all the nodes. Use one of the traversal methods. I used DFS (preOrder traversal) to solve the problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://youtu.be/ENL_c3n9BCU\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nThe Code below is a more optimized solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); // value of nodes to the left sub tree is always less than the root node\\n        if(node.val < high) dfs(node.right); // value of nodes to the right sub tree is always greater than the root node\\n    }\\n    dfs(root);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); // value of nodes to the left sub tree is always less than the root node\\n        if(node.val < high) dfs(node.right); // value of nodes to the right sub tree is always greater than the root node\\n    }\\n    dfs(root);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885529,
                "title": "java-using-complete-tree-traversal",
                "content": "# Intuition\\nTraverse the entire tree, but add only those nodes whose values fall within the range.\\n\\n# Approach\\nDeclare a global variable \\'sum\\' to store the range sum.\\nTraverse the tree using DFS.\\nIn each recursion, check if the node value is in between high and low. If so, add node value to \\'sum\\'.\\nReturn \\'sum\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - where n is the total number of nodes in the tree\\n\\n- Space complexity:\\nAverage case - log(n) [stack space used by recursive calls]\\nWorst case - O(n) if the tree is completely skewed.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        traverse(root, low, high);\\n        return sum;\\n    }\\n\\n    void traverse(TreeNode node, int low, int high){\\n        if(node == null){\\n            return;\\n        }\\n        if(node.val >= low && node.val <= high){\\n            sum += node.val;\\n        }\\n\\n        traverse(node.left, low, high);\\n        traverse(node.right, low, high);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        traverse(root, low, high);\\n        return sum;\\n    }\\n\\n    void traverse(TreeNode node, int low, int high){\\n        if(node == null){\\n            return;\\n        }\\n        if(node.val >= low && node.val <= high){\\n            sum += node.val;\\n        }\\n\\n        traverse(node.left, low, high);\\n        traverse(node.right, low, high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564692,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565457,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1566300,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565640,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568256,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568153,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568258,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568194,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568158,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708160,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1564692,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565457,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1566300,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565640,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568256,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568153,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568258,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568194,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568158,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708160,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1569696,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1569538,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1750570,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708348,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708107,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1574985,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1574286,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1573324,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1572624,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708189,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1884872,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1828371,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1808389,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1806120,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1793409,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1728241,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1710992,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1710160,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709654,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709386,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709084,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1709076,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708946,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708852,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708813,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708734,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708728,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708719,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708628,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708620,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708508,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708395,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708376,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708264,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708252,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708244,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708237,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708236,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708204,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708188,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            }
        ]
    },
    {
        "title": "Design a Stack With Increment Operation",
        "question_content": "<p>Design a stack that supports increment operations on its elements.</p>\n\n<p>Implement the <code>CustomStack</code> class:</p>\n\n<ul>\n\t<li><code>CustomStack(int maxSize)</code> Initializes the object with <code>maxSize</code> which is the maximum number of elements in the stack.</li>\n\t<li><code>void push(int x)</code> Adds <code>x</code> to the top of the stack if the stack has not reached the <code>maxSize</code>.</li>\n\t<li><code>int pop()</code> Pops and returns the top of the stack or <code>-1</code> if the stack is empty.</li>\n\t<li><code>void inc(int k, int val)</code> Increments the bottom <code>k</code> elements of the stack by <code>val</code>. If there are less than <code>k</code> elements in the stack, increment all the elements in the stack.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n<strong>Output</strong>\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n<strong>Explanation</strong>\nCustomStack stk = new CustomStack(3); // Stack is Empty []\nstk.push(1);                          // stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.pop();                            // return 2 --&gt; Return top of the stack 2, stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.push(3);                          // stack becomes [1, 2, 3]\nstk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4\nstk.increment(5, 100);                // stack becomes [101, 102, 103]\nstk.increment(2, 100);                // stack becomes [201, 202, 103]\nstk.pop();                            // return 103 --&gt; Return top of the stack 103, stack becomes [201, 202]\nstk.pop();                            // return 202 --&gt; Return top of the stack 202, stack becomes [201]\nstk.pop();                            // return 201 --&gt; Return top of the stack 201, stack becomes []\nstk.pop();                            // return -1 --&gt; Stack is empty return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxSize, x, k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n\t<li>At most <code>1000</code> calls will be made to each method of <code>increment</code>, <code>push</code> and <code>pop</code> each separately.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 539716,
                "title": "java-c-python-lazy-increment-o-1",
                "content": "## **Explanation**\\nUse an additional array to record the increment value.\\n`inc[i]` means for all elements `stack[0] ~ stack[i]`,\\nwe should plus `inc[i]` when popped from the stack.\\nThen `inc[i-1]+=inc[i]`,\\nso that we can accumulate the increment `inc[i]`\\nfor the bottom elements and the following `pop`s.\\n<br>\\n\\n## **Complexity**\\nC++/Python, initialization is `O(1)` time & space.\\nJava, initialization is `O(N)` time & space.\\n(We cam use ArrayList, but shrug)\\n`push`, `pop`, `increment`, all O(1) time and space.\\n<br>\\n\\n**Java**\\n```java\\n    int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0)\\n            return -1;\\n        if (i > 0)\\n            inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n        int i = Math.min(k, stack.size()) - 1;\\n        if (i >= 0)\\n            inc[i] += val;\\n    }\\n```\\n**C++:**\\n```cpp\\n    vector<int> stack, inc;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == n) return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n\\n    int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0) return -1;\\n        if (i > 0) inc[i - 1] += inc[i];\\n        int res = stack[i] + inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n\\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size()) - 1;\\n        if (i >= 0) inc[i] += val;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0)\\n            return -1;\\n        if (i > 0)\\n            inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n        int i = Math.min(k, stack.size()) - 1;\\n        if (i >= 0)\\n            inc[i] += val;\\n    }\\n```\n```cpp\\n    vector<int> stack, inc;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == n) return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n\\n    int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0) return -1;\\n        if (i > 0) inc[i - 1] += inc[i];\\n        int res = stack[i] + inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n\\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size()) - 1;\\n        if (i >= 0) inc[i] += val;\\n    }\\n```\n```py\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 843182,
                "title": "lee215-s-solution-with-more-explanation",
                "content": "solution from: https://leetcode.com/problems/design-a-stack-with-increment-operation/discuss/539716/JavaC%2B%2BPython-Lazy-increment-O(1)\\n\\nIntuition: like lee215 says, \"Use an additional array to record the increment value.\\ninc[i] means for all elements stack[0] ~ stack[i],\\nwe should plus inc[i] when popped from the stack.\\nThen inc[i-1]+=inc[i],\\nso that we can accumulate the increment inc[i]\\nfor the bottom elements and the following pops.\"\\n\\nI would like to expand on his explanation a bit further and hand simulate a bit. Some key obsrvations:\\n- when we push we push to both inc and stack, so that at any point in time inc and stack have the same amount of elements. \\n- earlier we said that \"inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack\" -- let\\'s look at this idea a bit further. The key with this idea is easier to see with hand simulation:\\n\\nlet\\'s say we have a list of ops: push 5, push 3, push 1, inc 2 3, push 9, inc 4 -1\\n\\nafter the 1st inc our data looks like this:\\nstack: [5,3,1]\\ninc: [0,3,0]\\n\\ninc[1] encodes the knowledge that elements 0 thru 1 (inclusive) in the stack are incremented by 3. If we generalize this a bit, inc[i] encodes the knowledge that elements 0 thru i (inclusive) are incremented by the value at inc[i]. \\n\\nlet\\'s continue examining this idea. What does our data look like after the second inc?\\nstack: [5,3,1,9]\\ninc:[0,3,0,-1]\\n\\nso this is what our data looks like at the end of all of our operations stated above. we see that our second inc operation is now encoded in our inc array, since inc[3] = -1, which encodes the knowledge that elements 0 thru 3 (inclusive) are incremented by -1. Now observe that our two increment operations now \\'overlap\\' eachother. In the sense that inc[1] is applied to elements 0 thru 1 inclusive and inc[3] is applied to elements 0 thru 3 inclusive. Hence, elements 0 and 1 will have both increment operators applied to them. So for elements 0 and 1, we don\\'t just need to add 3 upon pop (we also need to -1). \\n\\nNow here\\'s the tricky part which requires somewhat of an intellectual leap to get to. observe that, for our inc array, only inc[-1] (the last element) accurately encodes what to increment by (and this is only accurate for stack[-1] at any given point in time). What this means concretely is that whatever inc[-1] is, if we have a pop operation from our stack, all we have to do is stack.pop()+inc.pop() in order to get the right value popped. \\n\\nLet\\'s come back to the example we had earlier:\\nstack: [5,3,1,9]\\ninc:[0,3,0,-1]\\n\\nStarting with our data like this, what if we perform a pop? Then we can do inc.pop()+stack.pop() which will yield 8. This is the correct output. However, what we do next is more important. Earlier we said that inc[3] encodes the value we want to add to elements 0 thru 3 (inclusive) of the stack. However at this point we\\'ve only added inc[3] to the 3rd element, so we don\\'t want to lose this knowledge before we\\'ve acted on all of it. So now that we\\'ve popped 3rd element, \\n\\ninc[3] encodes the value we want to add to elements 0 thru 3 (inclusive) of the stack -> inc[3] encodes the value we want to add to elements 0 thru 2 (inclusive) of the stack\\n\\nDo you understand how that leap was made? since i\\'ve already applied the increment operation to 3rd element, inc[3] no longer needs to encode that knowledge because it\\'s already been acted upon, so at that point inc[3] only encodes the knowledge that this is the value we want to add to elements 0 thru 2 (inclusive), instead of 0 thru 3. So how do we represent this in code? This next step requires a combination of ideas. If we think back to our representation, we said we want at any given point for our last element inc[-1] to have the accurate increment for stack[-1]. And also if we think back to our discussion earlier, we discussed overlap and how our algorithm needs to take into account that overlap. So the way we can do that is by taking inc[3]\\'s value and adding it to inc[2]. This represents the knowledge transition, from inc[3] encoding the value we want to add to elements 0 thru 3 of ths stack to inc[3] only encoding the value we want to add to elements 0 thru 2. So how do represent this knowledge transition? by moving inc[3]\\'s value into inc[2]. This is an exact move of our knowledge transition. \\n\\nSo then after that pop we look like this: \\nstack: [5,3,1]\\ninc:[0,3,-1]\\n\\nwhere inc[2] encodes that -1 should be added to stack elements 0 thru 2 (inclusive). This is in line with what we believe because we are keeping the information from inc[3] alive, as long as we haven\\'t fully acted upon the information. Also -1 is the correct value here because there is no overlap at this element. \\n\\nSo we pop again and end up looking like this:\\n\\nstack: [5,3]\\ninc:[0,2]\\n\\nNotice that we incorporate inc[2]\\'s value into inc[1]. This is because of the same reasoning as earlier, that inc[2] encodes value about elements 0 thru 2 (incl), and now that we\\'ve acted on element 2, we still need to encode the knowledge regarding elements 0 thru 1 (incl), so the way we do that is by bringing inc[2] into inc[1]. But notice that is how our overlap gets handled here. Now instead of increment elements 0 thru 1 by 3 (as our first increment operation suggests), we incorporate the second increment operation (since the ranges overlap), and we only increment the first 2 elements by exactly what is necessary. \\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539704,
                "title": "java-python-3-simple-codes-using-arraylist-list",
                "content": "```java\\n    private List<Integer> stk = new ArrayList<>();\\n    private int sz;\\n    public CustomStack(int maxSize) {\\n        sz = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (stk.size() < sz) {\\n            stk.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stk.isEmpty() ? -1 : stk.remove(stk.size() - 1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < k && i < stk.size(); ++i) {\\n            stk.set(i, stk.get(i) + val);            \\n        }\\n    }\\n```\\n```python\\n\\n    def __init__(self, maxSize: int):\\n        self.stk = []\\n        self.sz = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.sz:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stk.pop() if self.stk else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "solutionTags": [],
                "code": "```java\\n    private List<Integer> stk = new ArrayList<>();\\n    private int sz;\\n    public CustomStack(int maxSize) {\\n        sz = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (stk.size() < sz) {\\n            stk.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stk.isEmpty() ? -1 : stk.remove(stk.size() - 1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < k && i < stk.size(); ++i) {\\n            stk.set(i, stk.get(i) + val);            \\n        }\\n    }\\n```\n```python\\n\\n    def __init__(self, maxSize: int):\\n        self.stk = []\\n        self.sz = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.sz:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stk.pop() if self.stk else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043433,
                "title": "java-4ms-99-faster",
                "content": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int size;\\n    int index;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        size = maxSize;\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<size){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(stack.length == 0) return;\\n        for(int i = 0;i<k && i<stack.length;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n    }\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int size;\\n    int index;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        size = maxSize;\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<size){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(stack.length == 0) return;\\n        for(int i = 0;i<k && i<stack.length;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n    }\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1231589,
                "title": "c-easy-solution-beats-97-78",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int max;\\n    vector<int> v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0)\\n            return -1;\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k)\\n            x=v.size();\\n        for(int i=0;i<x;i++)\\n        {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```\\nRuntime: 24 ms, faster than 97.78% of C++ online submissions for Design a Stack With Increment Operation.\\nMemory Usage: 20.9 MB, less than 96.99% of C++ online submissions for Design a Stack With Increment Operation.\\n\\n**Please upvote if this helps :)**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int max;\\n    vector<int> v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0)\\n            return -1;\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k)\\n            x=v.size();\\n        for(int i=0;i<x;i++)\\n        {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542205,
                "title": "python-prefix-sum-with-1-array",
                "content": "Prefix sum reference can be found [here](https://en.wikipedia.org/wiki/Prefix_sum/).\\n\\n```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.size = maxSize\\n        self.stack = []\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n        \\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        \\n        res, inc = self.stack.pop()\\n        res += inc\\n        \\n        if self.stack:\\n            self.stack[-1][1] += inc\\n            \\n        return res\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k, len(self.stack)) - 1][1] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.size = maxSize\\n        self.stack = []\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n        \\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        \\n        res, inc = self.stack.pop()\\n        res += inc\\n        \\n        if self.stack:\\n            self.stack[-1][1] += inc\\n            \\n        return res\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k, len(self.stack)) - 1][1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539971,
                "title": "java-clean-and-simple-array-solution",
                "content": "We keep the stack data in array and keep a cursor in another variable.\\n```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   curr = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (curr+1 < arr.length) {\\n            arr[++curr] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return curr < 0 ? curr : arr[curr--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < Math.min(k, curr+1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   curr = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (curr+1 < arr.length) {\\n            arr[++curr] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return curr < 0 ? curr : arr[curr--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < Math.min(k, curr+1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 938891,
                "title": "java-o-1-4ms-beat-98-12",
                "content": "```\\nclass CustomStack {\\n    private int index;\\n    private Deque<Integer> stack = new ArrayDeque<>();\\n    private int increment[]; // check the range of increment\\n    public CustomStack(int maxSize) {\\n        index = -1;\\n        increment = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() == increment.length)\\n            return;\\n        stack.push(x);\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if(index == -1)\\n            return -1;\\n        int ret = stack.pop();\\n        int incre = increment[index]; //get increment with index\\n        if(index > 0){\\n            increment[index - 1] += increment[index]; // go to previous one\\n        }\\n        increment[index] = 0; // set the current one to zero\\n        index--;\\n        return ret + incre;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(index == -1)\\n            return;\\n        if(stack.size() < k){\\n            increment[index] += val; // increment\\n        }\\n        else{\\n            increment[k - 1] += val; // increment\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    private int index;\\n    private Deque<Integer> stack = new ArrayDeque<>();\\n    private int increment[]; // check the range of increment\\n    public CustomStack(int maxSize) {\\n        index = -1;\\n        increment = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() == increment.length)\\n            return;\\n        stack.push(x);\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if(index == -1)\\n            return -1;\\n        int ret = stack.pop();\\n        int incre = increment[index]; //get increment with index\\n        if(index > 0){\\n            increment[index - 1] += increment[index]; // go to previous one\\n        }\\n        increment[index] = 0; // set the current one to zero\\n        index--;\\n        return ret + incre;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(index == -1)\\n            return;\\n        if(stack.size() < k){\\n            increment[index] += val; // increment\\n        }\\n        else{\\n            increment[k - 1] += val; // increment\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933166,
                "title": "c-lazy-increment-with-explain",
                "content": "The idea of this problem is the lazy increment. It means when we pop a value from the stack, we will increment it. I used a map to save the top of elements that need to increase. So when we meet an element we will increase the value of this index\\n```\\nclass CustomStack {\\nprivate:\\n    unordered_map<int, int> map;\\n    stack<int> stack;\\n    int limit;\\npublic:\\n    CustomStack(int maxSize) {\\n        limit = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == limit) return;\\n        stack.push(x);\\n    }\\n\\n    int pop() {\\n        if (stack.empty()) return -1;\\n        int value = map[stack.size()]; //value we need to increase of this index\\n        map[stack.size()] = 0; // after we increase, value of this index will set to 0\\n        int top = stack.top(); \\n        stack.pop();\\n        map[stack.size()] += value; // If this index increase by value, so the bottom  of the index  will increase by value\\n        return top + value;\\n    }\\n\\n    void increment(int k, int val) {\\n        k = min(k, (int) stack.size()); // Sometime k bigger than stack.size() so we use stack.size()\\n        map[k] += val;\\n    }\\n};```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\nprivate:\\n    unordered_map<int, int> map;\\n    stack<int> stack;\\n    int limit;\\npublic:\\n    CustomStack(int maxSize) {\\n        limit = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == limit) return;\\n        stack.push(x);\\n    }\\n\\n    int pop() {\\n        if (stack.empty()) return -1;\\n        int value = map[stack.size()]; //value we need to increase of this index\\n        map[stack.size()] = 0; // after we increase, value of this index will set to 0\\n        int top = stack.top(); \\n        stack.pop();\\n        map[stack.size()] += value; // If this index increase by value, so the bottom  of the index  will increase by value\\n        return top + value;\\n    }\\n\\n    void increment(int k, int val) {\\n        k = min(k, (int) stack.size()); // Sometime k bigger than stack.size() so we use stack.size()\\n        map[k] += val;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 673734,
                "title": "c-o-1-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    CustomStack(int maxSize) {\\n        SIZE = maxSize;\\n        inc = std::vector<int>(maxSize+1, 0);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < SIZE) s.push(x);\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int v{s.top() + inc[s.size()]};\\n        inc[s.size()-1] += inc[s.size()], inc[s.size()] = 0, s.pop();\\n        return v;\\n    }\\n    \\n    void increment(int k, int val) {\\n        inc[min(k, (int)s.size())] += val;\\n    }\\n    \\n    int SIZE;\\n    std::stack<int> s;\\n    std::vector<int> inc;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    CustomStack(int maxSize) {\\n        SIZE = maxSize;\\n        inc = std::vector<int>(maxSize+1, 0);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < SIZE) s.push(x);\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int v{s.top() + inc[s.size()]};\\n        inc[s.size()-1] += inc[s.size()], inc[s.size()] = 0, s.pop();\\n        return v;\\n    }\\n    \\n    void increment(int k, int val) {\\n        inc[min(k, (int)s.size())] += val;\\n    }\\n    \\n    int SIZE;\\n    std::stack<int> s;\\n    std::vector<int> inc;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539727,
                "title": "c-python3-simulation",
                "content": "Design a stack with the following operations:\\n\\n* `CustomStack(int maxSize)`: initialize the stack with `maxSize`\\n* `void push(int x)`: Adds `x` to the top of the stack if the size doesn\\'t reach `maxSize`\\n* `int pop()`: return the top of the stack and pop it, or return -1 when it is empty\\n* `void inc(int k, int val)`: increase the bottom `min(k, size)` elements of the stack by `val`\\n\\n# Explanation\\n\\nSince the constraints are small (`1 <= maxSize <= 1000`, at most 1000 calls), just simulate the whole process.\\n\\n# C++ Solution\\n\\n```cpp\\nclass CustomStack {\\n    int maxSize;\\n    vector<int> stk;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if (stk.size() < maxSize)\\n            stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if (stk.size() > 0) {\\n            int x = stk.back();\\n            stk.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for (int i = 0; i < min(k, (int) stk.size()); i++)\\n            stk[i] += val;\\n    }\\n};\\n```\\n\\n# python3 Solution\\n\\n```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stk = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.maxSize:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stk) > 0:\\n            x = self.stk[-1];\\n            self.stk.pop()\\n            return x\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass CustomStack {\\n    int maxSize;\\n    vector<int> stk;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if (stk.size() < maxSize)\\n            stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if (stk.size() > 0) {\\n            int x = stk.back();\\n            stk.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for (int i = 0; i < min(k, (int) stk.size()); i++)\\n            stk[i] += val;\\n    }\\n};\\n```\n```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stk = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.maxSize:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stk) > 0:\\n            x = self.stk[-1];\\n            self.stk.pop()\\n            return x\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800767,
                "title": "python3-solution-stack",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxLength = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxLength:\\n            self.stack.append(x)\\n        \\n    def pop(self) -> int:\\n        if len(self.stack) >0:\\n            return self.stack.pop()\\n        return -1\\n    \\n    def increment(self, k: int, val: int) -> None:\\n        n = min(k,len(self.stack))\\n        for i in range(n):\\n            self.stack[i] += val",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxLength = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxLength:\\n            self.stack.append(x)\\n        \\n    def pop(self) -> int:\\n        if len(self.stack) >0:\\n            return self.stack.pop()\\n        return -1\\n    \\n    def increment(self, k: int, val: int) -> None:\\n        n = min(k,len(self.stack))\\n        for i in range(n):\\n            self.stack[i] += val",
                "codeTag": "Java"
            },
            {
                "id": 637422,
                "title": "python-sol-by-update-just-in-time-90-w-hint",
                "content": "Pythonic sol by update just-in-time\\n\\n---\\n\\n**Hint**:\\n\\nRecall the technique of **update just-in-time**.\\n\\nHere, we design and implement a class, called **Entry**, with two member variables.\\nOne is for recording **element value**, the other is for **increment offset**.\\n\\nApply just-in-time update in **pop**() and **increment**() operation in order to reduce overhead and improve overall performance.\\n\\n---\\n\\n```\\nclass Entry:\\n    def __init__(self, value, offset ):\\n        \\n        self.value = value\\n        self.offset = offset\\n\\n        \\n    def __repr__(self):\\n        # override __repr__ to help programmer trace and debug\\n        msg = [ f\\'value = {self.value}\\', f\\'offset = {self.offset}\\', \\'---\\']\\n        return \\'\\\\n\\'.join( msg )\\n        \\n        \\n        \\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.stk = []\\n        self.size_limit = maxSize\\n\\n        \\n        \\n    def push(self, x: int) -> None:\\n\\n        \\n        if len(self.stk) < self.size_limit:\\n            \\n            # push new element when stack size is within limit\\n            self.stk.append( Entry( value = x, offset = 0) )\\n\\n\\n        \\n    def pop(self) -> int:\\n        \\n        if self.stk:\\n            \\n            # fetch and pop top element from stack\\n            top_element = self.stk.pop()\\n            \\n            if self.stk:\\n                # If stack is still non-empty, \\n                # propagate increment offset to lower level\\n                self.stk[-1].offset += top_element.offset\\n            \\n\\n            # compute result with increment offset\\n            return top_element.value + top_element.offset\\n        \\n        else:\\n            \\n            # stack is empty, directly return -1\\n            return -1\\n\\n        \\n        \\n    def increment(self, k: int, val: int) -> None:\\n        \\n\\n        if self.stk:\\n            \\n            # update offset at k-th element when stack is non-empty\\n            \\n            # adjust k if k is over stack size\\n            k = min( k, len(self.stk) )\\n            \\n            self.stk[k-1].offset += val\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Entry:\\n    def __init__(self, value, offset ):\\n        \\n        self.value = value\\n        self.offset = offset\\n\\n        \\n    def __repr__(self):\\n        # override __repr__ to help programmer trace and debug\\n        msg = [ f\\'value = {self.value}\\', f\\'offset = {self.offset}\\', \\'---\\']\\n        return \\'\\\\n\\'.join( msg )\\n        \\n        \\n        \\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.stk = []\\n        self.size_limit = maxSize\\n\\n        \\n        \\n    def push(self, x: int) -> None:\\n\\n        \\n        if len(self.stk) < self.size_limit:\\n            \\n            # push new element when stack size is within limit\\n            self.stk.append( Entry( value = x, offset = 0) )\\n\\n\\n        \\n    def pop(self) -> int:\\n        \\n        if self.stk:\\n            \\n            # fetch and pop top element from stack\\n            top_element = self.stk.pop()\\n            \\n            if self.stk:\\n                # If stack is still non-empty, \\n                # propagate increment offset to lower level\\n                self.stk[-1].offset += top_element.offset\\n            \\n\\n            # compute result with increment offset\\n            return top_element.value + top_element.offset\\n        \\n        else:\\n            \\n            # stack is empty, directly return -1\\n            return -1\\n\\n        \\n        \\n    def increment(self, k: int, val: int) -> None:\\n        \\n\\n        if self.stk:\\n            \\n            # update offset at k-th element when stack is non-empty\\n            \\n            # adjust k if k is over stack size\\n            k = min( k, len(self.stk) )\\n            \\n            self.stk[k-1].offset += val\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 539702,
                "title": "c-simple-stack-implementation",
                "content": "```csharp\\npublic class CustomStack \\n{\\n    private int[] maxSizeStack;\\n    private int maxSize;\\n    private int top;\\n\\n    public CustomStack(int maxSize) \\n    {\\n        maxSizeStack = new int[maxSize];\\n        this.maxSize = maxSize;\\n        top = -1;\\n    }\\n    \\n    public void Push(int x) \\n    {\\n        if(top == maxSize - 1)\\n        {\\n            return;\\n        }\\n        \\n        top++;\\n        maxSizeStack[top] = x;        \\n    }\\n    \\n    public int Pop() \\n    {\\n        if(top == -1)\\n        {\\n            return -1;\\n        }                \\n        \\n        int element = maxSizeStack[top];\\n        top--;\\n        return element;        \\n    }\\n    \\n    public void Increment(int k, int val) \\n    {\\n        for(int i = 0; i < k && i <= top; i++)\\n        {\\n            maxSizeStack[i] += val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class CustomStack \\n{\\n    private int[] maxSizeStack;\\n    private int maxSize;\\n    private int top;\\n\\n    public CustomStack(int maxSize) \\n    {\\n        maxSizeStack = new int[maxSize];\\n        this.maxSize = maxSize;\\n        top = -1;\\n    }\\n    \\n    public void Push(int x) \\n    {\\n        if(top == maxSize - 1)\\n        {\\n            return;\\n        }\\n        \\n        top++;\\n        maxSizeStack[top] = x;        \\n    }\\n    \\n    public int Pop() \\n    {\\n        if(top == -1)\\n        {\\n            return -1;\\n        }                \\n        \\n        int element = maxSizeStack[top];\\n        top--;\\n        return element;        \\n    }\\n    \\n    public void Increment(int k, int val) \\n    {\\n        for(int i = 0; i < k && i <= top; i++)\\n        {\\n            maxSizeStack[i] += val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135820,
                "title": "c-vector-average-time-and-space",
                "content": "```\\npublic:\\n    int n;\\n    vector<int> s;\\n    CustomStack(int maxSize) {\\n        n=(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size()<n){\\n            s.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.size()==0)\\n            return -1;\\n        int temp = s.back();\\n        s.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        while(k-- && i<s.size()){\\n            \\n            s[i]=s[i]+val;\\n            i++;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    int n;\\n    vector<int> s;\\n    CustomStack(int maxSize) {\\n        n=(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size()<n){\\n            s.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.size()==0)\\n            return -1;\\n        int temp = s.back();\\n        s.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        while(k-- && i<s.size()){\\n            \\n            s[i]=s[i]+val;\\n            i++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863073,
                "title": "java-90-faster-self-expalanatory",
                "content": "```\\nclass CustomStack {\\n    int size;\\n    Stack<Integer> st;\\n    int[] arr;\\n    boolean[] state;\\n    int curr;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        size = maxSize;\\n        st = new Stack<>();\\n        arr = new int[maxSize];\\n        state = new boolean[maxSize];\\n        curr = 0;\\n        idx = 0;\\n    }\\n    public void push(int x) {\\n        if(curr < size){\\n            st.push(x);\\n            arr[idx++] = x;\\n            curr++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty()) return -1;\\n        idx--;\\n        if(state[idx]){\\n            int res = arr[idx];\\n            arr[idx]=0;\\n            state[idx] = false;\\n            curr--;\\n            st.pop();\\n            return res;\\n        }else{\\n            curr--;\\n            arr[idx]=0;\\n            state[idx]=false;\\n            return st.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<arr.length;i++){\\n            arr[i]+=val;\\n            state[i] = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    Stack<Integer> st;\\n    int[] arr;\\n    boolean[] state;\\n    int curr;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        size = maxSize;\\n        st = new Stack<>();\\n        arr = new int[maxSize];\\n        state = new boolean[maxSize];\\n        curr = 0;\\n        idx = 0;\\n    }\\n    public void push(int x) {\\n        if(curr < size){\\n            st.push(x);\\n            arr[idx++] = x;\\n            curr++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty()) return -1;\\n        idx--;\\n        if(state[idx]){\\n            int res = arr[idx];\\n            arr[idx]=0;\\n            state[idx] = false;\\n            curr--;\\n            st.pop();\\n            return res;\\n        }else{\\n            curr--;\\n            arr[idx]=0;\\n            state[idx]=false;\\n            return st.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<arr.length;i++){\\n            arr[i]+=val;\\n            state[i] = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509474,
                "title": "java-two-solutions-o-n-and-o-1-easy-to-understand",
                "content": "I am trying to solve problems as if I am in a real interview with time limit. I just would like to share my code as a reference in case it might be useful to anyone. Below, in the same class, both solutions are implemented at the same time. \\n\\nI firstly implemented the basic solution with an array which takes O(k) time for the increment() method. The basic solution can be implemented by using an array or a linked list etc. \\n\\nThe second solution creates an extra array for the increment array. With this approach, both increment and pop methods have constant time complexity. It is a bit lengthy to explain this part here, but if you ask or if it is not clear, I would explain it. Please upvote my post if you find it useful. \\n\\n```\\nclass CustomStack { \\n    private int [] inc; \\n    private int [] stack;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        inc = new int[maxSize]; \\n        size = 0;\\n    }\\n    \\n    public void push(int x) {  \\n        if (size < stack.length) {\\n            stack[size++] = x;\\n        }     \\n    }\\n    \\n    public int pop (){\\n        if(size > 0) {\\n            return stack[--size];\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) { \\n        if (k > size) k = size; \\n        \\n        for (int i = 0; i < k; i++) {\\n            stack[i] += val; \\n        }\\n    }\\n    \\n\\t/* The second method - Constant time operations */\\n    public int popConstant() {        \\n        if(size > 0) {\\n            int top = stack[--size] + inc[size];\\n            if (size > 0) inc[size - 1] += inc[size];\\n            inc[size] = 0;\\n            return top;\\n        }\\n        return -1;\\n    }\\n    \\n    public void incrementConstant(int k, int val) {\\n        \\n        if (k > size) k = size;\\n        if (k > 0) inc[k - 1] += val; \\n    }        \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack { \\n    private int [] inc; \\n    private int [] stack;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        inc = new int[maxSize]; \\n        size = 0;\\n    }\\n    \\n    public void push(int x) {  \\n        if (size < stack.length) {\\n            stack[size++] = x;\\n        }     \\n    }\\n    \\n    public int pop (){\\n        if(size > 0) {\\n            return stack[--size];\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) { \\n        if (k > size) k = size; \\n        \\n        for (int i = 0; i < k; i++) {\\n            stack[i] += val; \\n        }\\n    }\\n    \\n\\t/* The second method - Constant time operations */\\n    public int popConstant() {        \\n        if(size > 0) {\\n            int top = stack[--size] + inc[size];\\n            if (size > 0) inc[size - 1] += inc[size];\\n            inc[size] = 0;\\n            return top;\\n        }\\n        return -1;\\n    }\\n    \\n    public void incrementConstant(int k, int val) {\\n        \\n        if (k > size) k = size;\\n        if (k > 0) inc[k - 1] += val; \\n    }        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291158,
                "title": "beats-95-easy-python-constant-time-increment-operation",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.maxsize = maxSize\\n        self.stack=[]\\n        self.inc = []\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        if len(self.stack)< self.maxsize:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self) -> int:\\n        \\n        if not self.stack:\\n            return -1\\n        \\n        if len(self.inc)>1:\\n            self.inc[-2]+=self.inc[-1]\\n        \\n        return self.stack.pop()+self.inc.pop()\\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.inc:\\n            self.inc[min(k,len(self.inc))-1]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.maxsize = maxSize\\n        self.stack=[]\\n        self.inc = []\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        if len(self.stack)< self.maxsize:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self) -> int:\\n        \\n        if not self.stack:\\n            return -1\\n        \\n        if len(self.inc)>1:\\n            self.inc[-2]+=self.inc[-1]\\n        \\n        return self.stack.pop()+self.inc.pop()\\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.inc:\\n            self.inc[min(k,len(self.inc))-1]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835519,
                "title": "easy-c-solution-beats-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nrepresent stack with an array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nicrement the first k elements of the array by val\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() < n){\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size() != 0){\\n            int x = st[st.size() - 1];\\n            st.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int a;\\n        if(k <= st.size()) a = k;\\n        else a = st.size();\\n        for(int i = 0; i < a;i++){\\n            st[i] += val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() < n){\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size() != 0){\\n            int x = st[st.size() - 1];\\n            st.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int a;\\n        if(k <= st.size()) a = k;\\n        else a = st.size();\\n        for(int i = 0; i < a;i++){\\n            st[i] += val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340542,
                "title": "python-o-1-time-operation-complexity-easy-lazy-increment",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:  \\n            self.stack.append([x, 0])\\n    \\n    def pop(self) -> int:\\n        if self.stack:\\n            val, inc = self.stack.pop()\\n            if self.stack:\\n                self.stack[-1][1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k-1, len(self.stack)-1)][1] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:  \\n            self.stack.append([x, 0])\\n    \\n    def pop(self) -> int:\\n        if self.stack:\\n            val, inc = self.stack.pop()\\n            if self.stack:\\n                self.stack[-1][1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k-1, len(self.stack)-1)][1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877537,
                "title": "best-c-solution-using-vector-beats-100",
                "content": "# Code\\n```\\nclass CustomStack {\\n    int size;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < size)\\n            arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int x = k;\\n        if(arr.size() < k)\\n            x = arr.size();\\n        for(int i=0; i < x; i++){\\n            arr[i] += val;\\n        }\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < size)\\n            arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int x = k;\\n        if(arr.size() < k)\\n            x = arr.size();\\n        for(int i=0; i < x; i++){\\n            arr[i] += val;\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482633,
                "title": "simple-java-solution-using-2-stacks",
                "content": "Simple Java Solution using 2 stacks.\\n```\\nclass CustomStack {\\n\\n    int max= 0;\\n    Stack<Integer> s1= new Stack<>();\\n    \\n    public CustomStack(int maxSize) {\\n        max= maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if( s1.size() < max ){\\n            s1.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(s1.size() > 0){\\n            return s1.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> s2= new Stack<>();\\n        \\n        while(!s1.isEmpty()){\\n            s2.push(s1.pop());\\n        }\\n        \\n        for(int i=0; i<k; i++){\\n            if(s2.size() == 0){\\n                break;\\n            }\\n            \\n            s1.push(s2.pop()+val);\\n        }\\n        \\n        while(s2.size() != 0){\\n            s1.push(s2.pop());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int max= 0;\\n    Stack<Integer> s1= new Stack<>();\\n    \\n    public CustomStack(int maxSize) {\\n        max= maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if( s1.size() < max ){\\n            s1.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(s1.size() > 0){\\n            return s1.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> s2= new Stack<>();\\n        \\n        while(!s1.isEmpty()){\\n            s2.push(s1.pop());\\n        }\\n        \\n        for(int i=0; i<k; i++){\\n            if(s2.size() == 0){\\n                break;\\n            }\\n            \\n            s1.push(s2.pop()+val);\\n        }\\n        \\n        while(s2.size() != 0){\\n            s1.push(s2.pop());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386914,
                "title": "c-using-lazy-array-o-1-for-each-querry",
                "content": "If you are aware of lazy propogation in segment tree than i did something same in the array \\n\\nMy Code:-\\n\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    vector<int> lazy;\\n    int sze;\\n    CustomStack(int maxSize) {\\n        sze = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < sze){\\n            arr.push_back(x);\\n            lazy.push_back(0);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0) return -1;\\n        int tp = arr.back() + lazy.back();\\n        arr.pop_back();\\n        if(arr.size() != 0) lazy[lazy.size()-2] += lazy.back();\\n        lazy.pop_back();\\n        return tp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(arr.size() == 0) return;\\n        k = min(k, (int)arr.size());\\n        lazy[k-1] += val;\\n    }\\n};\\n```\\n\\nUpvoting will make me Happy BTW :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    vector<int> lazy;\\n    int sze;\\n    CustomStack(int maxSize) {\\n        sze = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < sze){\\n            arr.push_back(x);\\n            lazy.push_back(0);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0) return -1;\\n        int tp = arr.back() + lazy.back();\\n        arr.pop_back();\\n        if(arr.size() != 0) lazy[lazy.size()-2] += lazy.back();\\n        lazy.pop_back();\\n        return tp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(arr.size() == 0) return;\\n        k = min(k, (int)arr.size());\\n        lazy[k-1] += val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385742,
                "title": "c-easy-approach-with-explanation",
                "content": "**time complexity :- O(1) for push and pop and O(n) for increment**\\n```\\nclass CustomStack {\\n    int *data;\\n    int nextIndex;\\n    int capacity;\\npublic:\\n    CustomStack(int maxSize) {\\n        data = new int[maxSize];\\n        nextIndex = 0;\\n        capacity = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(nextIndex == capacity){\\n            return;\\n        }\\n        data[nextIndex] = x;\\n        nextIndex++;\\n    }\\n    \\n    int pop() {\\n        if(nextIndex == 0){\\n            return -1;\\n        }\\n        int temp = data[nextIndex-1];\\n        nextIndex--;\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n\\t\\t//loop will run upto nextIndex if k >= nextIndex else runt upto k only\\n        int n = (k >= nextIndex) ? nextIndex : k;\\n        for(int i = 0; i < n; i++){\\n            data[i]  = data[i] + val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int *data;\\n    int nextIndex;\\n    int capacity;\\npublic:\\n    CustomStack(int maxSize) {\\n        data = new int[maxSize];\\n        nextIndex = 0;\\n        capacity = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(nextIndex == capacity){\\n            return;\\n        }\\n        data[nextIndex] = x;\\n        nextIndex++;\\n    }\\n    \\n    int pop() {\\n        if(nextIndex == 0){\\n            return -1;\\n        }\\n        int temp = data[nextIndex-1];\\n        nextIndex--;\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n\\t\\t//loop will run upto nextIndex if k >= nextIndex else runt upto k only\\n        int n = (k >= nextIndex) ? nextIndex : k;\\n        for(int i = 0; i < n; i++){\\n            data[i]  = data[i] + val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879712,
                "title": "easiest-approach-using-vectors-faster-than-others",
                "content": "```\\nclass CustomStack {\\n    int cap;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       cap=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<cap)\\n            arr.push_back(x);\\n        \\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n      int x=k;\\n        if(arr.size()<k){\\n            x=arr.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            arr[i]+=val;\\n        }\\n    }\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\n    int cap;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       cap=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<cap)\\n            arr.push_back(x);\\n        \\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n      int x=k;\\n        if(arr.size()<k){\\n            x=arr.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            arr[i]+=val;\\n        }\\n    }\\n};\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1778364,
                "title": "easy-c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int>v;\\n    int limit;\\n    CustomStack(int maxSize) {\\n        v.clear();\\n        limit=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<limit) {\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()>0) {\\n            int d=v.back();\\n            v.erase(v.begin()+v.size()-1);\\n            return d;\\n        }\\n        else {\\n            return -1;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<min(int(v.size()),k);i++) {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n```\\n***Please upvote if you\\'ve got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int>v;\\n    int limit;\\n    CustomStack(int maxSize) {\\n        v.clear();\\n        limit=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<limit) {\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()>0) {\\n            int d=v.back();\\n            v.erase(v.begin()+v.size()-1);\\n            return d;\\n        }\\n        else {\\n            return -1;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<min(int(v.size()),k);i++) {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633403,
                "title": "using-deque-short-and-simple-code",
                "content": "```\\nclass CustomStack {\\npublic:\\n    deque<int> stk;\\n    int maxsize;\\n    CustomStack(int maxSize) {\\n        maxsize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stk.size() < maxsize ) stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(stk.empty()) return -1;\\n        int temp = stk.back();\\n        stk.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i = 0; i < k && i < stk.size(); i++)\\n            stk[i] += val;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    deque<int> stk;\\n    int maxsize;\\n    CustomStack(int maxSize) {\\n        maxsize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stk.size() < maxsize ) stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(stk.empty()) return -1;\\n        int temp = stk.back();\\n        stk.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i = 0; i < k && i < stk.size(); i++)\\n            stk[i] += val;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1036267,
                "title": "c-all-o-1-operations-using-hashing-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/design-a-stack-with-increment-operation/submissions/\\n    \\n    Push and pop are simple to do with O(1), problem is with increment operation\\n    that can take O(k) if done naively each time.\\n    To make that faster, we can use a hash table that can save the increment needed\\n    till elements of stack from position: 0 -> position\\n    Eg: if increment(2): then we can set hash_table[2] = value\\n    Now a check for incremented value can only be ensured with a pop operation\\n    in a stack, so we update the popped value. During pop, we check the additional\\n    value needed for the element with that index, it might happen that the current position\\n    is lesser than the position for which the increment update was done in hash table and\\n    hence the current position in hash table is not aware that it should have some increment\\n    amount. The optimization lies in this problem, if we simply look for the first updated\\n    value position in hash table after the current stack top position, O(max_size) worst case.\\n    So each time when we do a pop, we make sure to pass the value to its immediate left index\\n    and we do the same each time during a pop.\\n    This ensures that the index in hash table for any pop operation is always updated.\\n    \\n    Eg: Stack: 1, 2 \\n    Hash Table: \\n    \\n    inc(2, 100): Hash Table: <2, 100> // Notice how oonly index 2 is set and not index 1\\n    pop(): Stack: 1\\n        Hash Table: \\n            #Step 1: <1, 0> + <2, 100> = <1, 100> : Pass the increment value to lower index\\n            #Step 2: <2, 0>: Reset value for index which has passed\\n    \\n    TC: Push: O(1), Pop: O(1), increment: O(1)\\n    SC: O(max_size)\\n*/\\nclass CustomStack {\\n    int max_size = 0;\\n    vector<int> s;\\n    int top = 0;\\n    // This saves the increment value set for \\n    // till each position\\n    unordered_map<int, int> additional_val;\\npublic:\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n        s.resize(max_size);\\n    }\\n    \\n    void push(int x) {\\n        if (top < max_size)\\n            s[top++] = x;\\n    }\\n    \\n    int pop() {\\n        if (top <= 0)\\n            return -1;\\n        int increment_val = additional_val[top];\\n        // propagate the increment to lower indices, since all lower \\n        // position elements should also have component of this increment\\n        additional_val[top-1] += increment_val;\\n        // reset the increment for till this position caused\\n        // by incrment() for this position\\n        additional_val[top] = 0;\\n        return increment_val + s[--top];\\n    }\\n    \\n    void increment(int k, int val) {\\n        // find the effective K based on actual number of elements\\n        k = min(k, top);\\n        additional_val[k] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/design-a-stack-with-increment-operation/submissions/\\n    \\n    Push and pop are simple to do with O(1), problem is with increment operation\\n    that can take O(k) if done naively each time.\\n    To make that faster, we can use a hash table that can save the increment needed\\n    till elements of stack from position: 0 -> position\\n    Eg: if increment(2): then we can set hash_table[2] = value\\n    Now a check for incremented value can only be ensured with a pop operation\\n    in a stack, so we update the popped value. During pop, we check the additional\\n    value needed for the element with that index, it might happen that the current position\\n    is lesser than the position for which the increment update was done in hash table and\\n    hence the current position in hash table is not aware that it should have some increment\\n    amount. The optimization lies in this problem, if we simply look for the first updated\\n    value position in hash table after the current stack top position, O(max_size) worst case.\\n    So each time when we do a pop, we make sure to pass the value to its immediate left index\\n    and we do the same each time during a pop.\\n    This ensures that the index in hash table for any pop operation is always updated.\\n    \\n    Eg: Stack: 1, 2 \\n    Hash Table: \\n    \\n    inc(2, 100): Hash Table: <2, 100> // Notice how oonly index 2 is set and not index 1\\n    pop(): Stack: 1\\n        Hash Table: \\n            #Step 1: <1, 0> + <2, 100> = <1, 100> : Pass the increment value to lower index\\n            #Step 2: <2, 0>: Reset value for index which has passed\\n    \\n    TC: Push: O(1), Pop: O(1), increment: O(1)\\n    SC: O(max_size)\\n*/\\nclass CustomStack {\\n    int max_size = 0;\\n    vector<int> s;\\n    int top = 0;\\n    // This saves the increment value set for \\n    // till each position\\n    unordered_map<int, int> additional_val;\\npublic:\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n        s.resize(max_size);\\n    }\\n    \\n    void push(int x) {\\n        if (top < max_size)\\n            s[top++] = x;\\n    }\\n    \\n    int pop() {\\n        if (top <= 0)\\n            return -1;\\n        int increment_val = additional_val[top];\\n        // propagate the increment to lower indices, since all lower \\n        // position elements should also have component of this increment\\n        additional_val[top-1] += increment_val;\\n        // reset the increment for till this position caused\\n        // by incrment() for this position\\n        additional_val[top] = 0;\\n        return increment_val + s[--top];\\n    }\\n    \\n    void increment(int k, int val) {\\n        // find the effective K based on actual number of elements\\n        k = min(k, top);\\n        additional_val[k] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799451,
                "title": "java-o-1-simple-solution-beats-100",
                "content": "Simple idea is to maintain two arrays for values and increments. Keep a counter to track the current `currInd`.  We lazily transfer the `inc` down the stack when `pop` takes place. \\n\\n- On a `push` just initialize the `currInd`. Note we just overwrite entries.\\n- On a `pop` transfer the `inc` value to `currInd-1`. This way we transfer `inc` to the bottom entries. Also the actual value in the stack is `val`+`inc` value.\\n- On an `increment` just update the `kth` index. \\n\\nSo if we see two increments for `(ind, val)` -> `(3,10)` and `(5,15)` we will maintain 15 and 10 at right indices. Once pop occurs at index 5 we will transfer 15 to index 4, and on subsequent pop the inc value becomes `10+15=25` at index 3.   \\n\\n```\\nclass CustomStack {\\n\\n    int currInd = -1;\\n    int valStack[];\\n    int incStack[];\\n    int maxLen;\\n    public CustomStack(int maxSize) {\\n        valStack = new int[maxSize];\\n        incStack = new int[maxSize];\\n        maxLen = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (currInd+1 != maxLen) {\\n            valStack[currInd+1] = x;\\n            incStack[currInd+1] = 0;\\n            currInd++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (currInd == -1) {\\n            return -1;\\n        }\\n        int val = valStack[currInd]+incStack[currInd];\\n        if (currInd > 0) {\\n            incStack[currInd-1] += incStack[currInd];\\n        }\\n        currInd--;    \\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (currInd == -1) {\\n            return;\\n        }\\n        int ind = Math.min(currInd, k-1);\\n        incStack[ind] += val;\\n    }\\n}\\n\\n```\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    int currInd = -1;\\n    int valStack[];\\n    int incStack[];\\n    int maxLen;\\n    public CustomStack(int maxSize) {\\n        valStack = new int[maxSize];\\n        incStack = new int[maxSize];\\n        maxLen = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (currInd+1 != maxLen) {\\n            valStack[currInd+1] = x;\\n            incStack[currInd+1] = 0;\\n            currInd++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (currInd == -1) {\\n            return -1;\\n        }\\n        int val = valStack[currInd]+incStack[currInd];\\n        if (currInd > 0) {\\n            incStack[currInd-1] += incStack[currInd];\\n        }\\n        currInd--;    \\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (currInd == -1) {\\n            return;\\n        }\\n        int ind = Math.min(currInd, k-1);\\n        incStack[ind] += val;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702716,
                "title": "simple-and-fast-python-solution",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n        \\n\\n    def pop(self) -> int:\\n        if len(self.stack) <= 0:\\n            return -1\\n        \\n        return self.stack.pop()\\n\\n    \\n    def increment(self, k: int, val: int) -> None:        \\n        end = min(k,len(self.stack))\\n        for i in range(0,end):\\n            self.stack[i] += val\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n        \\n\\n    def pop(self) -> int:\\n        if len(self.stack) <= 0:\\n            return -1\\n        \\n        return self.stack.pop()\\n\\n    \\n    def increment(self, k: int, val: int) -> None:        \\n        end = min(k,len(self.stack))\\n        for i in range(0,end):\\n            self.stack[i] += val\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 590434,
                "title": "java-2-accepted-solutions-clear-explanation",
                "content": "ok lets do this!!\\nwe have to implement a stack where some operations are to be done-pop,push,increment etc!\\n\\nnote- i see many people using a stack to solve to solve this question!i am not going to do that because i feel that is absurd because you are already using predefined functions like push() and pop() ,which the question doesnt ask!\\nthe question asks us to implement a stack!\\ni am going to show two data structures that you can do to simulate the stack operations!\\n\\nAPPROACH 1-\\nUSING ARRAY!\\n\\n1>we take an array which we initialise with size as maaxSize\\n2>we also take an pointer initialy set to -1;\\n3>so that whenever underflow condition occurs we print -1\\n4>whenever we are popping we decrement the pointer by 1\\n\\nrest of it is pretty much self explanatory!\\n```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   i = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (i+1 < arr.length) {\\n            arr[++i] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return i < 0 ? i : arr[i--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int j = 0; j < Math.min(k, i+1); j++) {\\n            arr[j] += val;\\n        }\\n    }\\n}\\n```\\n\\n\\n\\nAPPROACH 2-\\nUSING ARRAYLIST\\n\\n```\\nimport java.util.*;\\nclass CustomStack {\\n int n;\\n  List<Integer> s=new ArrayList<>()  ;\\n        \\n    public CustomStack(int maxSize) {\\n        n=maxSize;\\n       \\n    }\\n    \\n    public void push(int x) {\\n        if(s.size()<n)\\n        {\\n            s.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n      if(s.size()!=0)\\n        return   s.remove(s.size()-1);\\n   \\n        else\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n    for(int i=0;i<k && i<s.size();i++)\\n    {\\n        s.set(i,s.get(i)+val);\\n    }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   i = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (i+1 < arr.length) {\\n            arr[++i] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return i < 0 ? i : arr[i--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int j = 0; j < Math.min(k, i+1); j++) {\\n            arr[j] += val;\\n        }\\n    }\\n}\\n```\n```\\nimport java.util.*;\\nclass CustomStack {\\n int n;\\n  List<Integer> s=new ArrayList<>()  ;\\n        \\n    public CustomStack(int maxSize) {\\n        n=maxSize;\\n       \\n    }\\n    \\n    public void push(int x) {\\n        if(s.size()<n)\\n        {\\n            s.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n      if(s.size()!=0)\\n        return   s.remove(s.size()-1);\\n   \\n        else\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n    for(int i=0;i<k && i<s.size();i++)\\n    {\\n        s.set(i,s.get(i)+val);\\n    }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3887585,
                "title": "100-beats-easy-to-understand-beginner-friendly-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    int *arr;\\n    int top;\\n    int size;\\npublic:\\n    CustomStack(int maxSize) {\\n         size=maxSize;\\n        arr=new int [size];\\n        top=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(top==size-1);\\n       else{ top=top+1;\\n        arr[top]=x;\\n       }\\n    }\\n    \\n    int pop() {\\n        if(top==-1)return -1;\\n        int ans=arr[top];\\n        top=top-1;\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int peek=0;\\n        if(top+1<k){\\n            while(peek!=top+1){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n        else{\\n            while(peek!=k){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int *arr;\\n    int top;\\n    int size;\\npublic:\\n    CustomStack(int maxSize) {\\n         size=maxSize;\\n        arr=new int [size];\\n        top=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(top==size-1);\\n       else{ top=top+1;\\n        arr[top]=x;\\n       }\\n    }\\n    \\n    int pop() {\\n        if(top==-1)return -1;\\n        int ans=arr[top];\\n        top=top-1;\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int peek=0;\\n        if(top+1<k){\\n            while(peek!=top+1){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n        else{\\n            while(peek!=k){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885986,
                "title": "beginner-friendly-solution-runtime-100-beats-memory-94-beats-fully-explained",
                "content": "# Approach\\n\\nThe goal of this problem is to design a custom stack that supports various operations such as push, pop, and an increment operation for specific elements in the stack. We need to make sure we implement these operations efficiently within the given constraints.\\n\\n**Logic:**\\n\\n1. **Initialization:** The `CustomStack` class is initialized with a constructor that takes the `maxSize` as an argument and initializes an integer array named `stack` to store the elements. An integer variable `inc` is used to keep track of the current index to which an element will be pushed.\\n\\n2. **Push Operation:** The `push` operation takes an integer `x` as an argument. If the value of `inc` (the current index) is less than the length of the `stack` array, it means there is space to push an element. So, the value `x` is added to the `stack` array at the index `inc`, and then `inc` is incremented.\\n\\n3. **Pop Operation:** The `pop` operation doesn\\'t need any arguments. It first checks if the value of `inc` is greater than 0, indicating that there are elements in the stack. If so, it decrements `inc` to point to the last pushed element and stores that element in the `last` variable. Then, the value at the index `inc` is reset to 0 (indicating an empty slot). Finally, the `last` element is returned.\\n\\n4. **Increment Operation:** The `increment` operation takes two arguments: `k` and `val`. This operation is used to increment the bottom `k` elements of the stack by `val`. The idea here is to loop through the first `k` elements of the `stack` array (or all elements if there are fewer than `k` elements) and add `val` to each of them.\\n\\n**Explanation:**\\n\\n- The `push` operation is quite straightforward. It adds an element to the stack if there\\'s space available.\\n\\n- The `pop` operation retrieves the last pushed element (if available) and also clears that slot in the stack.\\n\\n- The `increment` operation modifies the bottom `k` elements by adding `val`. The loop ensures that we only modify existing elements within the range of the stack.\\n\\nOverall, this approach uses an integer array as the main data structure to simulate the stack behavior. The use of the `inc` variable keeps track of the current index to manage elements effectively. The logic is designed to accommodate the constraints and requirements of the problem statement.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(maxSize)$$\\n\\n# Code\\n```\\nclass CustomStack {\\n    int[] stack;\\n    int inc;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n       if(inc < stack.length) {\\n           stack[inc++] = x;\\n       } \\n    }\\n    \\n    public int pop() {\\n        int last = -1;\\n        if(inc > 0) {\\n            last = stack[--inc];\\n            stack[inc] = 0;\\n        }\\n        return last;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int limit = inc > k ? k : inc;\\n        for(int i = 0; i < limit; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int inc;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n       if(inc < stack.length) {\\n           stack[inc++] = x;\\n       } \\n    }\\n    \\n    public int pop() {\\n        int last = -1;\\n        if(inc > 0) {\\n            last = stack[--inc];\\n            stack[inc] = 0;\\n        }\\n        return last;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int limit = inc > k ? k : inc;\\n        for(int i = 0; i < limit; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782186,
                "title": "python-98-18-faster-easy-o-solution",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.n=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.n:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack)==0:\\n            return -1\\n        return self.stack.pop()\\n\\n    def increment(self, k: int, val: int) -> None:\\n        l=len(self.stack)\\n        for i in range(l):\\n            if i==k:\\n                break\\n            self.stack[i]+=val\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.n=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.n:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack)==0:\\n            return -1\\n        return self.stack.pop()\\n\\n    def increment(self, k: int, val: int) -> None:\\n        l=len(self.stack)\\n        for i in range(l):\\n            if i==k:\\n                break\\n            self.stack[i]+=val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456461,
                "title": "design-a-stack-with-increment-operation-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()<n)\\n        {\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size()>0)\\n        {\\n            int popped = st[st.size()-1];\\n            st.erase(st.begin()+st.size()-1);\\n            return popped;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k>st.size())\\n        {\\n            for(int i=0 ; i<st.size() ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0 ; i<k ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/8c633a21-6464-4048-b3f4-a8c7af621f87_1682612493.9823296.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()<n)\\n        {\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size()>0)\\n        {\\n            int popped = st[st.size()-1];\\n            st.erase(st.begin()+st.size()-1);\\n            return popped;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k>st.size())\\n        {\\n            for(int i=0 ; i<st.size() ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0 ; i<k ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117997,
                "title": "c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    int sz;\\n    \\n    CustomStack(int maxSize) {\\n        sz= maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<sz) arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)return -1;\\n        int ans= arr.back();\\n        arr.pop_back();\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k= min(k,(int)arr.size());\\n        for(int i=0;i<k;i++) arr[i]+= val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    int sz;\\n    \\n    CustomStack(int maxSize) {\\n        sz= maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<sz) arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)return -1;\\n        int ans= arr.back();\\n        arr.pop_back();\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k= min(k,(int)arr.size());\\n        for(int i=0;i<k;i++) arr[i]+= val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117089,
                "title": "c-using-2-stacks",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    stack<int> s;\\n    stack<int> ss;\\n    int maxsize;\\npublic:\\n    CustomStack(int maxsize) {\\n        this -> maxsize = maxsize;\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < maxsize) {\\n            s.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int t = s.top();\\n        s.pop();\\n        return t;\\n    }\\n    \\n    void increment(int k, int val) {\\n        while(s.size() > k) {\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(s.size()) {\\n            s.top() += val;\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(ss.size()) {\\n            s.push(ss.top());\\n            ss.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\n    stack<int> s;\\n    stack<int> ss;\\n    int maxsize;\\npublic:\\n    CustomStack(int maxsize) {\\n        this -> maxsize = maxsize;\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < maxsize) {\\n            s.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int t = s.top();\\n        s.pop();\\n        return t;\\n    }\\n    \\n    void increment(int k, int val) {\\n        while(s.size() > k) {\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(s.size()) {\\n            s.top() += val;\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(ss.size()) {\\n            s.push(ss.top());\\n            ss.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036366,
                "title": "simple-array-solution",
                "content": "\\n# Code\\n```\\nclass CustomStack {\\n    int capacity,top_index,count=0;\\n    int arr[1000];\\npublic:\\n    CustomStack(int maxSize) {\\n        capacity=maxSize;\\n        top_index=-1;\\n        arr[maxSize];\\n    }\\n    \\n    void push(int x) {\\n        if(count < capacity){\\n            top_index++;\\n            if(top_index <capacity){\\n                arr[top_index]=x;\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top_index == -1) return -1;\\n        count--;\\n        return arr[top_index--];\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        if(k>=count){\\n            while(i<=top_index){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n        else{\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\n    int capacity,top_index,count=0;\\n    int arr[1000];\\npublic:\\n    CustomStack(int maxSize) {\\n        capacity=maxSize;\\n        top_index=-1;\\n        arr[maxSize];\\n    }\\n    \\n    void push(int x) {\\n        if(count < capacity){\\n            top_index++;\\n            if(top_index <capacity){\\n                arr[top_index]=x;\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top_index == -1) return -1;\\n        count--;\\n        return arr[top_index--];\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        if(k>=count){\\n            while(i<=top_index){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n        else{\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979569,
                "title": "java-100-faster-solution-4ms-easy-to-understand",
                "content": "# Intuition\\nSince a fixed size stack is to be implemented, we will use an Array.\\n# Approach\\nCreate an array of size maxSize in the constructor function and store the top and maxSize of the stack in a variable.\\n\\n# Complexity\\n- Time complexity:\\npush: $$O(1)$$\\npop: $$O(1)$$\\nincrement: $$O(k)$$\\n\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```\\nclass CustomStack {\\n    int[] arr;\\n    int top;\\n    int maxSize;\\n\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < maxSize-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top == -1){\\n            return -1;\\n        }\\n        return arr[top--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int margin = (int)Math.min(k, arr.length);\\n        for (int i=0; i<margin; i++) {\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] arr;\\n    int top;\\n    int maxSize;\\n\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < maxSize-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top == -1){\\n            return -1;\\n        }\\n        return arr[top--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int margin = (int)Math.min(k, arr.length);\\n        for (int i=0; i<margin; i++) {\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846669,
                "title": "javascript-soultion-using-array",
                "content": "# Code\\n```\\nclass CustomStack {\\n  constructor (maxSize) {\\n    this.elements = [];\\n    this.maxSize = maxSize;\\n  }\\n\\n  // Time O(1)\\n  // Space O(1)\\n  push(x) {\\n    if (this.elements.length < this.maxSize) {\\n      this.elements.push(x);\\n    }\\n  }\\n \\n  // Time O(1)\\n  // Space O(1)   \\n  pop() {\\n    if (this.elements.length > 0) {\\n      return this.elements.pop();\\n    } else {\\n      return -1;\\n    }\\n  }\\n    \\n  // Time O(k) - where k is the number of elements to increment \\n  // Space O(1)\\n  increment(k, val) {\\n    if (this.elements.length < k) {\\n      for (let i = 0; i < this.elements.length; i++) {\\n        this.elements[i] += val;\\n      }\\n    } else {\\n      for (let i = 0; i < k; i++) {\\n        this.elements[i] += val;\\n      }\\n    }\\n  }\\n}\\n    \\n    \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass CustomStack {\\n  constructor (maxSize) {\\n    this.elements = [];\\n    this.maxSize = maxSize;\\n  }\\n\\n  // Time O(1)\\n  // Space O(1)\\n  push(x) {\\n    if (this.elements.length < this.maxSize) {\\n      this.elements.push(x);\\n    }\\n  }\\n \\n  // Time O(1)\\n  // Space O(1)   \\n  pop() {\\n    if (this.elements.length > 0) {\\n      return this.elements.pop();\\n    } else {\\n      return -1;\\n    }\\n  }\\n    \\n  // Time O(k) - where k is the number of elements to increment \\n  // Space O(1)\\n  increment(k, val) {\\n    if (this.elements.length < k) {\\n      for (let i = 0; i < this.elements.length; i++) {\\n        this.elements[i] += val;\\n      }\\n    } else {\\n      for (let i = 0; i < k; i++) {\\n        this.elements[i] += val;\\n      }\\n    }\\n  }\\n}\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808144,
                "title": "java-o-k-increment-array-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - Since, array provides the functionality of random access, which is performed in $$O(1)$$ time, we can easily implement the ```push()```, ```pop()``` functions in $$O(1)$$.\\n - Though ```increment()``` will take $$O(k)$$ because we have to traverse first k elements *(if k < list.length)* in order to increment them.\\n - Maintaining ```idx``` becomes important since indices from ```0``` to ```idx``` represent the actual **stack**.\\n \\n# Complexity\\n- Time complexity: **O(k)** - For ```increment()``` function.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(maxSize)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n\\n# Code\\n```\\nclass CustomStack {\\n\\n    int[] list;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        list = new int[maxSize];\\n        idx=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(idx < list.length-1) list[++idx]=x;\\n    }\\n    \\n    public int pop() {\\n        if(idx == -1) return -1;\\n        return list[idx--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int count = k > list.length? list.length : k;\\n        while(count-- > 0) list[count] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```push()```\n```pop()```\n```increment()```\n```idx```\n```0```\n```idx```\n```increment()```\n```\\nclass CustomStack {\\n\\n    int[] list;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        list = new int[maxSize];\\n        idx=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(idx < list.length-1) list[++idx]=x;\\n    }\\n    \\n    public int pop() {\\n        if(idx == -1) return -1;\\n        return list[idx--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int count = k > list.length? list.length : k;\\n        while(count-- > 0) list[count] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558408,
                "title": "unique-implementation-java-easy-to-understand-using-two-arrays",
                "content": "```\\nclass CustomStack {\\n    int[] st;\\n    int[] inc;\\n    \\n    int ms=0;\\n    \\n    int top=1;\\n\\n    public CustomStack(int maxSize) {\\n        st=new int[maxSize+1];\\n        inc=new int[maxSize+1];\\n        ms=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top>ms)\\n            return;\\n        st[top++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(top==1)\\n            return -1;\\n        int offset=inc[top-1];\\n        inc[top-1]=0;\\n        inc[top-2]+=offset;\\n        \\n        return st[--top]+offset;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        inc[0]+=-val;\\n        inc[(int)Math.min(k,top-1)]+=val;\\n    }\\n}\\n```\\n\\nDo upvote if you like my approach, Also comment if any doubt ! :)",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] st;\\n    int[] inc;\\n    \\n    int ms=0;\\n    \\n    int top=1;\\n\\n    public CustomStack(int maxSize) {\\n        st=new int[maxSize+1];\\n        inc=new int[maxSize+1];\\n        ms=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top>ms)\\n            return;\\n        st[top++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(top==1)\\n            return -1;\\n        int offset=inc[top-1];\\n        inc[top-1]=0;\\n        inc[top-2]+=offset;\\n        \\n        return st[--top]+offset;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        inc[0]+=-val;\\n        inc[(int)Math.min(k,top-1)]+=val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982092,
                "title": "easiest-sol-out-there-push-pop-o-1-increment-o-min-size-k",
                "content": "```\\nclass CustomStack {\\n    vector<int> s;\\n    int k;\\npublic:\\n    CustomStack(int maxSize):s(maxSize){\\n        k=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(k+1>=s.size())return;\\n        s[++k]=x;\\n    }\\n    \\n    int pop() {\\n        if(k>=0)\\n            return s[k--];\\n        else \\n            return -1;\\n    }\\n    \\n    void increment(int kth, int val) {\\n        if(kth>k)\\n            for(auto &i:s)i+=val;\\n        \\n        else{\\n            int i=0;\\n            while(kth--)\\n                s[i++]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    vector<int> s;\\n    int k;\\npublic:\\n    CustomStack(int maxSize):s(maxSize){\\n        k=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(k+1>=s.size())return;\\n        s[++k]=x;\\n    }\\n    \\n    int pop() {\\n        if(k>=0)\\n            return s[k--];\\n        else \\n            return -1;\\n    }\\n    \\n    void increment(int kth, int val) {\\n        if(kth>k)\\n            for(auto &i:s)i+=val;\\n        \\n        else{\\n            int i=0;\\n            while(kth--)\\n                s[i++]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906381,
                "title": "java-easy-to-understand-solution-o-1",
                "content": "```\\nclass CustomStack {\\n    \\n    int value[];\\n    int increment[];\\n    int index;\\n    \\n\\n    public CustomStack(int maxSize) {\\n        value = new int[maxSize];\\n        increment = new int[maxSize];\\n        index=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(index+1 == value.length){\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        increment[index]=0;\\n    }\\n    \\n    public int pop() {\\n        if(index==-1){\\n            return -1;\\n        }\\n        int x = value[index];\\n        int inc = increment[index];\\n        index--;\\n        if(index>=0){\\n            increment[index]+=inc;\\n        }\\n        \\n        return x+inc;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int ind = Math.min(k-1 , index);\\n        if(index>=0){\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n    int value[];\\n    int increment[];\\n    int index;\\n    \\n\\n    public CustomStack(int maxSize) {\\n        value = new int[maxSize];\\n        increment = new int[maxSize];\\n        index=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(index+1 == value.length){\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        increment[index]=0;\\n    }\\n    \\n    public int pop() {\\n        if(index==-1){\\n            return -1;\\n        }\\n        int x = value[index];\\n        int inc = increment[index];\\n        index--;\\n        if(index>=0){\\n            increment[index]+=inc;\\n        }\\n        \\n        return x+inc;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int ind = Math.min(k-1 , index);\\n        if(index>=0){\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531200,
                "title": "c-solution-using-vector-pair",
                "content": "```\\nclass CustomStack {\\n    int maxSize;\\n    vector<pair<int,int>> stack;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stack.size() == maxSize) return;\\n        stack.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(stack.empty()) return -1;\\n        auto [a,b] = stack.back(); stack.pop_back();\\n        if(!stack.empty()) stack.back().second += b;\\n        return a+b;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(stack.empty()) return;\\n        stack[min(int(stack.size()-1), k-1)].second += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\n    int maxSize;\\n    vector<pair<int,int>> stack;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stack.size() == maxSize) return;\\n        stack.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(stack.empty()) return -1;\\n        auto [a,b] = stack.back(); stack.pop_back();\\n        if(!stack.empty()) stack.back().second += b;\\n        return a+b;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(stack.empty()) return;\\n        stack[min(int(stack.size()-1), k-1)].second += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1464802,
                "title": "java-easy-solution-beats-96-5-users-runtime-4ms",
                "content": "```\\nclass CustomStack {\\n\\n    int arr[];\\n    int top;\\n    public CustomStack(int maxSize) {\\n  \\n        arr=new int[maxSize];\\n        top=0;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top==arr.length)\\n        { return;\\n        }\\n        else\\n        {  \\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n       \\n        if(top==0)\\n        {\\n            return -1;\\n        }\\n      else\\n      {top--;\\n       int ele=arr[top];\\n       return ele;\\n      }\\n  }\\n    \\n    public void increment(int k, int val) {\\n        int i;\\n        if(k>arr.length)\\n        {\\n        for(i=0;i<arr.length;i++)\\n        {  \\n            arr[i]+=val;\\n            }\\n        }   \\n        else\\n        {\\n            for(i=0;i<k;i++)\\n        { \\n            arr[i]+=val;\\n        }\\n       \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    int arr[];\\n    int top;\\n    public CustomStack(int maxSize) {\\n  \\n        arr=new int[maxSize];\\n        top=0;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top==arr.length)\\n        { return;\\n        }\\n        else\\n        {  \\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n       \\n        if(top==0)\\n        {\\n            return -1;\\n        }\\n      else\\n      {top--;\\n       int ele=arr[top];\\n       return ele;\\n      }\\n  }\\n    \\n    public void increment(int k, int val) {\\n        int i;\\n        if(k>arr.length)\\n        {\\n        for(i=0;i<arr.length;i++)\\n        {  \\n            arr[i]+=val;\\n            }\\n        }   \\n        else\\n        {\\n            for(i=0;i<k;i++)\\n        { \\n            arr[i]+=val;\\n        }\\n       \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252019,
                "title": "python-using-list",
                "content": "```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246010,
                "title": "java-using-array-easy-to-understand-beginner-friendly",
                "content": "```\\nclass CustomStack {\\n\\n    int stackArr[];\\n    \\n    int top;\\n    public CustomStack(int maxSize) {\\n        \\n        stackArr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top != stackArr.length -1)\\n        {\\n            top++;\\n            stackArr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(top == -1)\\n            return -1;\\n        \\n        int ele = stackArr[top];\\n        top--;\\n        return ele;\\n            \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int size = top +1;\\n       \\n        for(int level = 0 ; level < k ;level++)\\n        {\\n            \\n            if(level > top)\\n                break;\\n            \\n            stackArr[level] += val;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int stackArr[];\\n    \\n    int top;\\n    public CustomStack(int maxSize) {\\n        \\n        stackArr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top != stackArr.length -1)\\n        {\\n            top++;\\n            stackArr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(top == -1)\\n            return -1;\\n        \\n        int ele = stackArr[top];\\n        top--;\\n        return ele;\\n            \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int size = top +1;\\n       \\n        for(int level = 0 ; level < k ;level++)\\n        {\\n            \\n            if(level > top)\\n                break;\\n            \\n            stackArr[level] += val;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171434,
                "title": "c-implementing-stack-using-array",
                "content": "```\\nclass CustomStack \\n{\\npublic:\\n    int arr[1000];\\n    int count = 0;\\n    int size = 0;\\n    \\n    CustomStack(int maxSize) \\n    {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) \\n    {\\n        if ( count < size ) \\n            arr[count++] = x;        \\n    }\\n    \\n    int pop() \\n    {\\n        if ( count > 0 )\\n            return arr[--count]; \\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) \\n    {\\n        for ( int i=0; i<min(k,count); i++) \\n            arr[i] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack \\n{\\npublic:\\n    int arr[1000];\\n    int count = 0;\\n    int size = 0;\\n    \\n    CustomStack(int maxSize) \\n    {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) \\n    {\\n        if ( count < size ) \\n            arr[count++] = x;        \\n    }\\n    \\n    int pop() \\n    {\\n        if ( count > 0 )\\n            return arr[--count]; \\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) \\n    {\\n        for ( int i=0; i<min(k,count); i++) \\n            arr[i] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654733,
                "title": "java-solution-with-100-space-complexity-easy-to-understand",
                "content": "Here we have to keep track of no of elements in stack so i have used count variable which gives no of elements in stack at current time.\\n\\nAnd size variable will be used to check the maximum size of stack.\\n\\n```\\nclass CustomStack {\\n    Stack<Integer> stack;\\n    int size;\\n    int count = 0;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new Stack<>();\\n        this.size = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(count < size) {\\n            stack.push(x);\\n            count++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stack.empty())\\n            return -1;\\n        else {\\n            count--;\\n            return stack.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n\\t\\n\\t// If total no of elements is less than k then we have to increment all elements of stack.\\n\\t// else we have to increment from i=0 to i=k which are last k bottom elements of stack.\\n        if(count < k) {\\n            for(int i=0; i<count; i++) {\\n                stack.set(i, stack.get(i)+val);\\n            }\\n        } else {\\n            for(int i=0; i<k; i++)\\n                stack.set(i, stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    Stack<Integer> stack;\\n    int size;\\n    int count = 0;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new Stack<>();\\n        this.size = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(count < size) {\\n            stack.push(x);\\n            count++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stack.empty())\\n            return -1;\\n        else {\\n            count--;\\n            return stack.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n\\t\\n\\t// If total no of elements is less than k then we have to increment all elements of stack.\\n\\t// else we have to increment from i=0 to i=k which are last k bottom elements of stack.\\n        if(count < k) {\\n            for(int i=0; i<count; i++) {\\n                stack.set(i, stack.get(i)+val);\\n            }\\n        } else {\\n            for(int i=0; i<k; i++)\\n                stack.set(i, stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617516,
                "title": "java-solution-using-arra-100-of-memory",
                "content": "Easy to undertand \\n```\\nclass CustomStack {\\n\\t\\t\\n\\t\\tprivate int[] customStack;\\n\\t\\tprivate int position;\\n\\t\\t\\n\\t    public CustomStack(int maxSize) {\\n\\t        customStack = new int[maxSize];\\n\\t        position = 0;\\n\\t    }\\n\\t    \\n\\t    public void push(int x) {\\n\\t        if(position < customStack.length) {\\n\\t        \\tcustomStack[position] = x;\\n\\t        \\tposition++;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    public int pop() {\\n\\t    \\tint val = -1;\\n\\t    \\tif(position > 0) {\\n                position--;\\n\\t    \\t\\tval = customStack[position];\\n\\t    \\t\\tcustomStack[position] = 0;\\t    \\t\\t\\n\\t    \\t}\\n\\t    \\treturn val;\\n\\t    }\\n\\t    \\n\\t    public void increment(int k, int val) {\\n\\t        int i = 0;\\n\\t        while(i< Math.min(k, customStack.length)) {\\n\\t        \\tcustomStack[i++] += val;\\n\\t        }\\n\\t    }\\n\\t}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\t\\t\\n\\t\\tprivate int[] customStack;\\n\\t\\tprivate int position;\\n\\t\\t\\n\\t    public CustomStack(int maxSize) {\\n\\t        customStack = new int[maxSize];\\n\\t        position = 0;\\n\\t    }\\n\\t    \\n\\t    public void push(int x) {\\n\\t        if(position < customStack.length) {\\n\\t        \\tcustomStack[position] = x;\\n\\t        \\tposition++;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    public int pop() {\\n\\t    \\tint val = -1;\\n\\t    \\tif(position > 0) {\\n                position--;\\n\\t    \\t\\tval = customStack[position];\\n\\t    \\t\\tcustomStack[position] = 0;\\t    \\t\\t\\n\\t    \\t}\\n\\t    \\treturn val;\\n\\t    }\\n\\t    \\n\\t    public void increment(int k, int val) {\\n\\t        int i = 0;\\n\\t        while(i< Math.min(k, customStack.length)) {\\n\\t        \\tcustomStack[i++] += val;\\n\\t        }\\n\\t    }\\n\\t}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578190,
                "title": "javascript-solution-with-array-as-stack",
                "content": "```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function (maxSize) {\\n  // set max size\\n  this.maxSize = maxSize;\\n\\n  // set initial size\\n  this.size = 0;\\n\\n  // stack\\n  this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function (x) {\\n  // make sure we\\'re not at max size\\n  if (this.size !== this.maxSize) {\\n    // push as normal\\n    this.stack.push(x);\\n    // increment size\\n    this.size++;\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function () {\\n  // check if empty to return -1\\n  if (this.size === 0) {\\n    return -1;\\n  } else {\\n    // decrement size and return pop()\\n    this.size--;\\n    return this.stack.pop();\\n  }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function (k, val) {\\n  // iterate from 0 to k (or size since thats as far we can go)\\n  for (let i = 0; i < Math.min(k, this.size); i++) {\\n    // increment at this index\\n    this.stack[i] += val;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function (maxSize) {\\n  // set max size\\n  this.maxSize = maxSize;\\n\\n  // set initial size\\n  this.size = 0;\\n\\n  // stack\\n  this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function (x) {\\n  // make sure we\\'re not at max size\\n  if (this.size !== this.maxSize) {\\n    // push as normal\\n    this.stack.push(x);\\n    // increment size\\n    this.size++;\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function () {\\n  // check if empty to return -1\\n  if (this.size === 0) {\\n    return -1;\\n  } else {\\n    // decrement size and return pop()\\n    this.size--;\\n    return this.stack.pop();\\n  }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function (k, val) {\\n  // iterate from 0 to k (or size since thats as far we can go)\\n  for (let i = 0; i < Math.min(k, this.size); i++) {\\n    // increment at this index\\n    this.stack[i] += val;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 555419,
                "title": "java-lazy-increment-push-pop-increment-o-1-5ms",
                "content": "```\\nclass CustomStack {\\n    private int[] arr;\\n    private int[] val;\\n    private int index;\\n    private int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.maxSize=maxSize;\\n        arr=new int[maxSize];\\n        val=new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n        if(index==maxSize)\\n            return;\\n        arr[index]=x;\\n        index++;\\n    }\\n\\n    public int pop() {\\n        if(index==0)return -1;\\n        \\n        \\n        index--;\\n        \\n        if(val[index]==0){\\n            return arr[index];\\n        }else{\\n            int ans=arr[index]+val[index];\\n            if(index>0)\\n                val[index-1]+=val[index];\\n            val[index]=0;\\n            return ans;\\n        }\\n        \\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index==0)\\n            return;\\n        if(k>index-1) {\\n            this.val[index-1] += val;\\n            return;\\n        }\\n        this.val[k-1]+=val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    private int[] arr;\\n    private int[] val;\\n    private int index;\\n    private int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.maxSize=maxSize;\\n        arr=new int[maxSize];\\n        val=new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n        if(index==maxSize)\\n            return;\\n        arr[index]=x;\\n        index++;\\n    }\\n\\n    public int pop() {\\n        if(index==0)return -1;\\n        \\n        \\n        index--;\\n        \\n        if(val[index]==0){\\n            return arr[index];\\n        }else{\\n            int ans=arr[index]+val[index];\\n            if(index>0)\\n                val[index-1]+=val[index];\\n            val[index]=0;\\n            return ans;\\n        }\\n        \\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index==0)\\n            return;\\n        if(k>index-1) {\\n            this.val[index-1] += val;\\n            return;\\n        }\\n        this.val[k-1]+=val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540579,
                "title": "java-use-array-only-no-stack-all-o-1",
                "content": "All O(1) solution.\\n```java\\nclass CustomStack {\\n    int[] arr; // value\\n    int[] inc; // increment\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        inc = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        if (index > 0) {\\n            inc[index - 1] += inc[index];\\n        }\\n        int val = arr[index] + inc[index];\\n        inc[index--] = 0;\\n        return val;\\n    }\\n\\n    // O(1)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n\\n        int i = Math.min(k, index + 1) - 1;\\n        if (i >= 0) {\\n            inc[i] += val;\\n        }\\n    }\\n}\\n```\\nBelow solution is easy to understand, but O(n) for increment.\\n```java\\npublic class CustomStack {\\n    int[] arr;\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        return arr[index--];\\n    }\\n\\n    // O(n)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n        for (int i = 0; i < Math.min(k, index + 1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass CustomStack {\\n    int[] arr; // value\\n    int[] inc; // increment\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        inc = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        if (index > 0) {\\n            inc[index - 1] += inc[index];\\n        }\\n        int val = arr[index] + inc[index];\\n        inc[index--] = 0;\\n        return val;\\n    }\\n\\n    // O(1)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n\\n        int i = Math.min(k, index + 1) - 1;\\n        if (i >= 0) {\\n            inc[i] += val;\\n        }\\n    }\\n}\\n```\n```java\\npublic class CustomStack {\\n    int[] arr;\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        return arr[index--];\\n    }\\n\\n    // O(n)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n        for (int i = 0; i < Math.min(k, index + 1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540166,
                "title": "javascript-lazy-increment-o-1-busy-increment-o-n",
                "content": "### Lazy increment\\n- Time Complexity: O(1)\\n- Space Complexity; O(N)\\n```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.inc = new Array(maxSize).fill(0);\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        const idx = this.stack.length - 1;\\n        const inc = this.inc[idx];\\n        if (idx - 1 >= 0) this.inc[idx - 1] += inc;\\n        this.inc[idx] = 0;\\n        return this.stack.pop() + inc;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const idx = Math.min(k, this.stack.length ) - 1;\\n    this.inc[idx] += val;\\n};\\n```\\n\\n### Busy increment\\n- Time Complexity: O(N)\\n- Space Complexity; O(1) `it does not require extra space`\\n```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        return this.stack.pop();\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for (let i = 0; i < Math.min(this.stack.length, k); i++) {\\n        this.stack[i] += val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.inc = new Array(maxSize).fill(0);\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        const idx = this.stack.length - 1;\\n        const inc = this.inc[idx];\\n        if (idx - 1 >= 0) this.inc[idx - 1] += inc;\\n        this.inc[idx] = 0;\\n        return this.stack.pop() + inc;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const idx = Math.min(k, this.stack.length ) - 1;\\n    this.inc[idx] += val;\\n};\\n```\n```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        return this.stack.pop();\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for (let i = 0; i < Math.min(this.stack.length, k); i++) {\\n        this.stack[i] += val;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539892,
                "title": "simple-solution-in-c",
                "content": "/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n class CustomStack {\\n \\nprivate:\\n\\n    int maxi;\\n    int size;\\n    int s[1005];\\npublic:\\n\\n    CustomStack(int maxSize) {\\n        maxi=maxSize;\\n        size=0;\\n    }\\n    \\n    void push(int x) {\\n        if(size<maxi){\\n            s[size]=x;\\n            size++;           \\n        }\\n    }\\n    \\n    int pop() {\\n        if(size>0){\\n            size--;\\n            return s[size];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k=min(k,size+1);\\n        for(int i=0;i<k;i++){\\n            s[i]+=val;\\n        }\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n class CustomStack {\\n \\nprivate:\\n\\n    int maxi;\\n    int size;\\n    int s[1005];\\npublic:\\n\\n    CustomStack(int maxSize) {\\n        maxi=maxSize;\\n        size=0;\\n    }\\n    \\n    void push(int x) {\\n        if(size<maxi){\\n            s[size]=x;\\n            size++;           \\n        }\\n    }\\n    \\n    int pop() {\\n        if(size>0){\\n            size--;\\n            return s[size];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k=min(k,size+1);\\n        for(int i=0;i<k;i++){\\n            s[i]+=val;\\n        }\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 539773,
                "title": "java-using-stack",
                "content": "```\\nclass CustomStack {\\n    \\n    int maxSize;\\n    Stack<Integer> st;\\n\\n    public CustomStack(int maxSize) {\\n        this.st = new Stack<Integer>();\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(st.size()>=maxSize)return;\\n        st.push(x);\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty())return -1;\\n        return st.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> util = new Stack<Integer>();\\n        int pass = st.size()-k;\\n        while(!st.isEmpty()){\\n            if(pass>0){\\n                pass--;\\n                util.push(st.pop());\\n            }else{\\n                int tmp = st.pop() + val;\\n                util.push(tmp);\\n            }\\n        }\\n        while(!util.isEmpty())st.push(util.pop());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n    int maxSize;\\n    Stack<Integer> st;\\n\\n    public CustomStack(int maxSize) {\\n        this.st = new Stack<Integer>();\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(st.size()>=maxSize)return;\\n        st.push(x);\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty())return -1;\\n        return st.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> util = new Stack<Integer>();\\n        int pass = st.size()-k;\\n        while(!st.isEmpty()){\\n            if(pass>0){\\n                pass--;\\n                util.push(st.pop());\\n            }else{\\n                int tmp = st.pop() + val;\\n                util.push(tmp);\\n            }\\n        }\\n        while(!util.isEmpty())st.push(util.pop());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539755,
                "title": "python-cocnstant-solution",
                "content": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.a = []\\n        self.msize = maxSize\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.a) < self.msize:\\n            self.a.append([x, 0])\\n            \\n\\n    def pop(self) -> int:\\n        if not self.a: return -1\\n        ret, inc = self.a[-1]\\n        del self.a[-1]\\n        if self.a: self.a[-1][1] += inc\\n        return ret + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if k == 0 or not self.a: return\\n        if k > len(self.a): k = len(self.a)\\n        self.a[k-1][1] += val \\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.a = []\\n        self.msize = maxSize\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.a) < self.msize:\\n            self.a.append([x, 0])\\n            \\n\\n    def pop(self) -> int:\\n        if not self.a: return -1\\n        ret, inc = self.a[-1]\\n        del self.a[-1]\\n        if self.a: self.a[-1][1] += inc\\n        return ret + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if k == 0 or not self.a: return\\n        if k > len(self.a): k = len(self.a)\\n        self.a[k-1][1] += val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 539730,
                "title": "java-using-linknode",
                "content": "```\\nclass CustomStack {\\n\\n    LinkNode head = null;\\n    int maxSize;\\n    int currentSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(currentSize<maxSize) {\\n            if(head == null) {\\n                head = new LinkNode(x);\\n            } else {\\n                LinkNode node = new LinkNode(x);\\n                node.next = head;\\n                head = node;\\n            }\\n            currentSize++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(currentSize == 0) return -1;\\n        int result = head.val;\\n        head = head.next;\\n        currentSize--;\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(currentSize != 0) {\\n            LinkNode frontNode = head;\\n            for(int i=0;i<k && frontNode != null;i++) {\\n                frontNode = frontNode.next;\\n            }\\n            LinkNode backNode = head;\\n            while(frontNode != null) {\\n                backNode = backNode.next;\\n                frontNode = frontNode.next;\\n            }\\n            while(backNode!=null) {\\n                backNode.val += val;\\n                backNode = backNode.next;\\n            }\\n        }\\n    }\\n}\\n\\nclass LinkNode {\\n    int val;\\n    LinkNode next;\\n    LinkNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    LinkNode head = null;\\n    int maxSize;\\n    int currentSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(currentSize<maxSize) {\\n            if(head == null) {\\n                head = new LinkNode(x);\\n            } else {\\n                LinkNode node = new LinkNode(x);\\n                node.next = head;\\n                head = node;\\n            }\\n            currentSize++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(currentSize == 0) return -1;\\n        int result = head.val;\\n        head = head.next;\\n        currentSize--;\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(currentSize != 0) {\\n            LinkNode frontNode = head;\\n            for(int i=0;i<k && frontNode != null;i++) {\\n                frontNode = frontNode.next;\\n            }\\n            LinkNode backNode = head;\\n            while(frontNode != null) {\\n                backNode = backNode.next;\\n                frontNode = frontNode.next;\\n            }\\n            while(backNode!=null) {\\n                backNode.val += val;\\n                backNode = backNode.next;\\n            }\\n        }\\n    }\\n}\\n\\nclass LinkNode {\\n    int val;\\n    LinkNode next;\\n    LinkNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539682,
                "title": "c-use-deque",
                "content": "```cpp\\nclass CustomStack {\\npublic:\\n    // Space Complexity: O(n)\\n    deque<int> dq;\\n    int n;\\n    \\n    CustomStack(int maxSize) {\\n        // Time Complexity: O(1)\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        // Time Complexity: O(1)\\n        if (dq.size() == n) return;\\n        dq.push_back(x);\\n    }\\n    \\n    int pop() {\\n        // Time Complexity: O(1)\\n        if (dq.empty()) return -1;\\n        int x = dq.back();\\n        dq.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        // Time Complexity: O(k)\\n        for (auto it = dq.begin(); it != (k > dq.size() ? dq.end() : dq.begin() + k); ++it)\\n            *it += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```cpp\\nclass CustomStack {\\npublic:\\n    // Space Complexity: O(n)\\n    deque<int> dq;\\n    int n;\\n    \\n    CustomStack(int maxSize) {\\n        // Time Complexity: O(1)\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        // Time Complexity: O(1)\\n        if (dq.size() == n) return;\\n        dq.push_back(x);\\n    }\\n    \\n    int pop() {\\n        // Time Complexity: O(1)\\n        if (dq.empty()) return -1;\\n        int x = dq.back();\\n        dq.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        // Time Complexity: O(k)\\n        for (auto it = dq.begin(); it != (k > dq.size() ? dq.end() : dq.begin() + k); ++it)\\n            *it += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3972261,
                "title": "implementing-a-custom-stack-by-using-stack-ds",
                "content": "# Intuition\\nThe problem description is quite simple and requires implementing a **Stack DS** (data structure), that follows LIFO-schema.\\n\\n# Approach\\n1. inside `__init__` method store `maxSize` and `stack`\\n2. implement `push` and `pop` methods as regular stack methods\\n3. implement `increment` method, that increments in the range of `k` at each step current value by `val` \\n\\n# Complexity\\n- Time complexity: **O(n)** because of iterating inside `increment`\\n\\n- Space complexity: **O(k)** because of storing **exactly** `k`- elements\\n\\n# Code\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        j = min(k, len(self.stack))\\n\\n        for i in range(j):\\n            self.stack[i] += val\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        j = min(k, len(self.stack))\\n\\n        for i in range(j):\\n            self.stack[i] += val\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647046,
                "title": "c-solution-to-design-a-stack-with-increment-operation-leetcode",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\npush(): O(1)\\npop(): O(1)\\nincrement(): O(k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(maxSize)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    int maxSize;\\n    stack<int> st;\\n    CustomStack(int maxSize) {\\n        this->maxSize=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if((int)st.size()<maxSize)\\n        {\\n            st.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!st.empty())\\n        {\\n            int ans=st.top();\\n            st.pop();\\n            return ans;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack<int> temp;\\n        int count=0;\\n        for(int i=0;!st.empty();i++)\\n        {\\n            temp.push(st.top());\\n            st.pop();\\n        }\\n        for(int i=0;i<k && !temp.empty();i++)\\n        {\\n            count++;\\n            st.push(temp.top()+val);\\n            temp.pop();\\n        }\\n        while(!temp.empty())\\n        {\\n            st.push(temp.top());\\n            temp.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int maxSize;\\n    stack<int> st;\\n    CustomStack(int maxSize) {\\n        this->maxSize=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if((int)st.size()<maxSize)\\n        {\\n            st.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!st.empty())\\n        {\\n            int ans=st.top();\\n            st.pop();\\n            return ans;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack<int> temp;\\n        int count=0;\\n        for(int i=0;!st.empty();i++)\\n        {\\n            temp.push(st.top());\\n            st.pop();\\n        }\\n        for(int i=0;i<k && !temp.empty();i++)\\n        {\\n            count++;\\n            st.push(temp.top()+val);\\n            temp.pop();\\n        }\\n        while(!temp.empty())\\n        {\\n            st.push(temp.top());\\n            temp.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578936,
                "title": "beginners-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    private int[] stack;\\n    private int currIndex;\\n    int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.currIndex=0;\\n        this.stack= new int[maxSize];\\n        this.maxSize= maxSize;\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(currIndex< maxSize) stack[currIndex++]=x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(currIndex ==0) return -1;\\n        else return stack[--currIndex];\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int n= Math.min(currIndex, k);\\n        for(int i=0;i<n;i++){\\n            stack[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    private int[] stack;\\n    private int currIndex;\\n    int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.currIndex=0;\\n        this.stack= new int[maxSize];\\n        this.maxSize= maxSize;\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(currIndex< maxSize) stack[currIndex++]=x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(currIndex ==0) return -1;\\n        else return stack[--currIndex];\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int n= Math.min(currIndex, k);\\n        for(int i=0;i<n;i++){\\n            stack[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548414,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int ms ;\\n    int curr;\\n    CustomStack(int maxSize) {\\n        ms = maxSize;\\n        st.resize(ms,-1);\\n        curr = 0;\\n    }\\n    \\n    void push(int x) {\\n        if(curr == ms){\\n            return;\\n        }\\n\\n        st[curr] = x;\\n        // cout << curr << endl;\\n        curr++;\\n    }\\n    \\n    int pop() {\\n        if(curr == 0){\\n            return -1;\\n        }\\n        // cout << curr << endl;\\n\\n        int k = st[curr-1];\\n        st[curr-1] = -1;\\n        curr--;\\n        return k;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int n = min(curr,k);\\n        for(int i=0;i<n;i++){\\n            st[i] += val;\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int ms ;\\n    int curr;\\n    CustomStack(int maxSize) {\\n        ms = maxSize;\\n        st.resize(ms,-1);\\n        curr = 0;\\n    }\\n    \\n    void push(int x) {\\n        if(curr == ms){\\n            return;\\n        }\\n\\n        st[curr] = x;\\n        // cout << curr << endl;\\n        curr++;\\n    }\\n    \\n    int pop() {\\n        if(curr == 0){\\n            return -1;\\n        }\\n        // cout << curr << endl;\\n\\n        int k = st[curr-1];\\n        st[curr-1] = -1;\\n        curr--;\\n        return k;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int n = min(curr,k);\\n        for(int i=0;i<n;i++){\\n            st[i] += val;\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3276947,
                "title": "java-easy-optimized-explained",
                "content": "# Intuition\\nHere, we will be using **Array** for better optimization. We will create a array of given maxSize and we will keep a **Ptr** to update our values in array. Based on two conditon of k we will update the values in array.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    int[] data;\\n    int ptr=0;\\n    int max;\\n    public CustomStack(int maxSize) {\\n        this.data =new int[maxSize];\\n        this.max=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(ptr==data.length) return;\\n        data[ptr++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(ptr==0){\\n            return -1;\\n        }\\n        return data[--ptr];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(k>ptr){\\n            for(int i=0 ;i<max ; i++){\\n                data[i]=data[i]+val;\\n            }\\n        }else{\\n            for(int i=0; i<k ;i++){\\n                data[i]=data[i]+val;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] data;\\n    int ptr=0;\\n    int max;\\n    public CustomStack(int maxSize) {\\n        this.data =new int[maxSize];\\n        this.max=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(ptr==data.length) return;\\n        data[ptr++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(ptr==0){\\n            return -1;\\n        }\\n        return data[--ptr];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(k>ptr){\\n            for(int i=0 ;i<max ; i++){\\n                data[i]=data[i]+val;\\n            }\\n        }else{\\n            for(int i=0; i<k ;i++){\\n                data[i]=data[i]+val;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089313,
                "title": "stack-with-top-and-maxsize",
                "content": "# Upvote it :)\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.m = maxSize\\n        self.top = -1\\n\\n    def push(self, x: int) -> None:\\n        if self.top < self.m - 1:\\n            self.arr.append(x)\\n            self.top += 1\\n\\n    def pop(self) -> int:\\n        if self.top == -1: return -1\\n        self.top -= 1\\n        return(self.arr.pop(-1))\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.m = maxSize\\n        self.top = -1\\n\\n    def push(self, x: int) -> None:\\n        if self.top < self.m - 1:\\n            self.arr.append(x)\\n            self.top += 1\\n\\n    def pop(self) -> int:\\n        if self.top == -1: return -1\\n        self.top -= 1\\n        return(self.arr.pop(-1))\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053991,
                "title": "c-two-stack-solution",
                "content": "\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass CustomStack {\\npublic:\\n    stack<int> st;\\n    int size;\\n\\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() == size) return;\\n        st.push(x);\\n    }\\n    \\n    int pop() {\\n        if(st.size() == 0) return -1;\\n        int val = st.top();\\n        st.pop();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {. // Time Complexity -> O(st.size())\\n        stack<int> st0;\\n        while(!st.empty()) {\\n            st0.push(st.top());\\n            st.pop();\\n        }\\n        while(!st0.empty() && k--) {\\n            st.push(st0.top() + val);\\n            st0.pop();\\n        }\\n        while(!st0.empty()) {\\n            st.push(st0.top());\\n            st0.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    stack<int> st;\\n    int size;\\n\\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() == size) return;\\n        st.push(x);\\n    }\\n    \\n    int pop() {\\n        if(st.size() == 0) return -1;\\n        int val = st.top();\\n        st.pop();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {. // Time Complexity -> O(st.size())\\n        stack<int> st0;\\n        while(!st.empty()) {\\n            st0.push(st.top());\\n            st.pop();\\n        }\\n        while(!st0.empty() && k--) {\\n            st.push(st0.top() + val);\\n            st0.pop();\\n        }\\n        while(!st0.empty()) {\\n            st.push(st0.top());\\n            st0.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008786,
                "title": "very-easy-to-understand-solution-with-a-details",
                "content": "### Intuition\\n- First of all I think I need array and one varieble that equal max size. So I assigned `self.arr` equal empty and `self.max` inside `__init__ `function.\\n\\n### Approach\\n- To solve this problem we only need to write a few lines.\\n    1. Inside `push` function we need to append a new variable to our `self.arr` but we must check `length` of our array because we can capable to add `self.max` elements. So our `push` function can be this kind of:\\n        ```\\n        if len(self.arr)<self.max: self.arr.append(x)\\n        ```\\n    2. Inside `pop` function we need to `pop` an element from the array and before doing that we need to know there is an element inside our array. Instead of checking there is an element in array we can simply use `try` and `except` function for this purpose. So our `pop` function can be this kind of:\\n        ```\\n        try: return self.arr.pop()\\n        except: return -1\\n        ```\\n    3. Inside last `increment` function we need to increment `self.arr[0]` to `self.arr[k]` or `self.arr[-1]` because if length of arr id less thank k we need to stop our loop on the last element of the array. That means we need to identify `minimum` these two of them and then we need to use for loop to increment every single element that we need to increment. So our `increment` function can be this kind of:\\n        ```\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n        ```\\n### Code\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.max = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr)<self.max: self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        try: return self.arr.pop()\\n        except: return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if len(self.arr)<self.max: self.arr.append(x)\\n        ```\n```\\n        try: return self.arr.pop()\\n        except: return -1\\n        ```\n```\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n        ```\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.max = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr)<self.max: self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        try: return self.arr.pop()\\n        except: return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882609,
                "title": "100-runtime-beats-96-memory-beats-java",
                "content": "- 34/34 cases passed (4 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 96.05 % of java submissions (42.8 MB)\\n\\n# Code\\n```\\nclass CustomStack {\\n\\n    int[] out;\\n    int i=-1,z;\\n\\n    public CustomStack(int maxSize) {\\n        out=new int[maxSize];\\n        z=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(i<z-1)\\n            out[++i]=x;\\n    }\\n    \\n    public int pop() {\\n        if(i>-1)\\n            return out[i--];\\n        return -1;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n\\n        for(int j=0;j<(k>i?i+1:k);j++)\\n            out[j]+=val;\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int[] out;\\n    int i=-1,z;\\n\\n    public CustomStack(int maxSize) {\\n        out=new int[maxSize];\\n        z=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(i<z-1)\\n            out[++i]=x;\\n    }\\n    \\n    public int pop() {\\n        if(i>-1)\\n            return out[i--];\\n        return -1;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n\\n        for(int j=0;j<(k>i?i+1:k);j++)\\n            out[j]+=val;\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598190,
                "title": "easy-java-code-damn-easy",
                "content": "```\\n// code by- SATYARTH \\n// upvote if u like my code\\nclass CustomStack {\\n    int stackArray[];   // stack using array\\n    int top;            // top pointer\\n\\n    public CustomStack(int maxSize) { // constructor will help to initialize the array and top pointer\\n        stackArray=new int[maxSize];\\n        \\n        top=-1;         // as index starts from 0, so we will point the stackArray from -1\\n    }\\n    \\n    public void push(int x) {\\n        // overflow condition : means u can\\'t add more elements to it \\n        if(top == (stackArray.length-1)){\\n            return; \\n        }\\n        \\n       else{\\n           top+=1;   // each time we have to update the pointer to add the element at the top\\n           stackArray[top]=x;  // add the element at the top \\n       }\\n        \\n        \\n    }\\n    \\n    public int pop() { \\n        // underflow condition : means stack is empty \\n        if(top== -1){\\n            return -1;\\n        }\\n        \\n        int del=stackArray[top]; // storing the top value of stack \\n        \\n        top--; // reducing the top pointer to next top element after deletion \\n        \\n        return del;     \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n     // the following block can be optimised :- but its simple to understand and my code works with stack property,not with array operations i.e.  top to bottom \\n        \\n        // first check :if k is greater the stack size \\n        if((top+1)<k ){\\n            int temp=top;  // storing top in temporary variable so that top won\\'t be affected\\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n            \\n        }\\n        // second : if stack size is greater than k\\n        else{\\n            \\n            int temp=top -((top+1)-k);  \\n            //ex:- stack size = 5 then top = 4 and let k=3 then elements to be increased from index 2 to 0\\n            // temp = 4 - ((4+1)-3) = 4-2=2 , see we reached at 2 , now decrease temp and update the value \\n            \\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n// code by- SATYARTH \\n// upvote if u like my code\\nclass CustomStack {\\n    int stackArray[];   // stack using array\\n    int top;            // top pointer\\n\\n    public CustomStack(int maxSize) { // constructor will help to initialize the array and top pointer\\n        stackArray=new int[maxSize];\\n        \\n        top=-1;         // as index starts from 0, so we will point the stackArray from -1\\n    }\\n    \\n    public void push(int x) {\\n        // overflow condition : means u can\\'t add more elements to it \\n        if(top == (stackArray.length-1)){\\n            return; \\n        }\\n        \\n       else{\\n           top+=1;   // each time we have to update the pointer to add the element at the top\\n           stackArray[top]=x;  // add the element at the top \\n       }\\n        \\n        \\n    }\\n    \\n    public int pop() { \\n        // underflow condition : means stack is empty \\n        if(top== -1){\\n            return -1;\\n        }\\n        \\n        int del=stackArray[top]; // storing the top value of stack \\n        \\n        top--; // reducing the top pointer to next top element after deletion \\n        \\n        return del;     \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n     // the following block can be optimised :- but its simple to understand and my code works with stack property,not with array operations i.e.  top to bottom \\n        \\n        // first check :if k is greater the stack size \\n        if((top+1)<k ){\\n            int temp=top;  // storing top in temporary variable so that top won\\'t be affected\\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n            \\n        }\\n        // second : if stack size is greater than k\\n        else{\\n            \\n            int temp=top -((top+1)-k);  \\n            //ex:- stack size = 5 then top = 4 and let k=3 then elements to be increased from index 2 to 0\\n            // temp = 4 - ((4+1)-3) = 4-2=2 , see we reached at 2 , now decrease temp and update the value \\n            \\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574383,
                "title": "simple-array-implementation",
                "content": "```\\nclass CustomStack {\\n    int arr[], top =-1, maxSize ;    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {        \\n        if(top< maxSize-1)\\n            arr[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top!= -1){\\n            int val = arr[top--];            \\n            return val;\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        if(top!= -1){\\n            if( k <= top){\\n                for(int i=0;i<k;++i)  arr[i]+= val;\\n            }\\n            else{\\n                for(int i=0;i<=top;++i)  arr[i]+= val;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass CustomStack {\\n    int arr[], top =-1, maxSize ;    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {        \\n        if(top< maxSize-1)\\n            arr[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top!= -1){\\n            int val = arr[top--];            \\n            return val;\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        if(top!= -1){\\n            if( k <= top){\\n                for(int i=0;i<k;++i)  arr[i]+= val;\\n            }\\n            else{\\n                for(int i=0;i<=top;++i)  arr[i]+= val;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407992,
                "title": "c-easy-approach-using-dynamic-array-stack",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int *arr;\\n    int size;\\n    int csize;\\n    CustomStack(int maxSize) {\\n       size=maxSize;\\n        arr=new int[size];\\n        csize=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(csize<size-1)\\n        {   csize++;\\n           arr[csize]=x;\\n            \\n        }\\n    }\\n    \\n    int pop() {\\n        if(csize==-1)\\n        {\\n            return -1;\\n        }\\n        return arr[csize--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<k&&i<=csize;i++)\\n        {\\n            arr[i]=arr[i]+val;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int *arr;\\n    int size;\\n    int csize;\\n    CustomStack(int maxSize) {\\n       size=maxSize;\\n        arr=new int[size];\\n        csize=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(csize<size-1)\\n        {   csize++;\\n           arr[csize]=x;\\n            \\n        }\\n    }\\n    \\n    int pop() {\\n        if(csize==-1)\\n        {\\n            return -1;\\n        }\\n        return arr[csize--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<k&&i<=csize;i++)\\n        {\\n            arr[i]=arr[i]+val;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366157,
                "title": "java-array-implementation",
                "content": "```\\nclass CustomStack {\\n    int cap;\\n    int[] arr;\\n    int head;\\n    public CustomStack(int maxSize) {\\n        this.cap=maxSize;\\n        this.arr=new int[maxSize];\\n        this.head=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.head==cap-1) return;\\n        this.head++;\\n        this.arr[this.head]=x;\\n    }\\n    \\n    public int pop() {\\n        if(this.head==-1) return -1;\\n        int res=this.arr[this.head];\\n        this.head--;\\n        return res;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<Math.min(cap,k); i++){\\n            this.arr[i]+=val;\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int cap;\\n    int[] arr;\\n    int head;\\n    public CustomStack(int maxSize) {\\n        this.cap=maxSize;\\n        this.arr=new int[maxSize];\\n        this.head=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.head==cap-1) return;\\n        this.head++;\\n        this.arr[this.head]=x;\\n    }\\n    \\n    public int pop() {\\n        if(this.head==-1) return -1;\\n        int res=this.arr[this.head];\\n        this.head--;\\n        return res;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<Math.min(cap,k); i++){\\n            this.arr[i]+=val;\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323949,
                "title": "c-solution-easy-to-understand-list",
                "content": "```C#\\npublic class CustomStack {\\n    private readonly List<int> _l;\\n    private readonly int _maxSize;\\n    \\n    private int _size = 0;\\n    public CustomStack(int maxSize) {\\n        this._l = new (capacity: maxSize);\\n        this._maxSize = maxSize;\\n    }\\n    \\n    public void Push(int x) {\\n        if (this._size < this._maxSize) {\\n            this._l.Insert(this._size, x);\\n            this._size++;\\n        }\\n    }\\n    \\n    public int Pop() {\\n        if (this._size == 0) return -1;\\n        \\n        this._size--;\\n        return this._l[this._size];\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        int end = Math.Min(this._size, k);\\n        for (int i = 0; i < end; i++) this._l[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * obj.Increment(k,val);\\n */\\n ```",
                "solutionTags": [],
                "code": "```C#\\npublic class CustomStack {\\n    private readonly List<int> _l;\\n    private readonly int _maxSize;\\n    \\n    private int _size = 0;\\n    public CustomStack(int maxSize) {\\n        this._l = new (capacity: maxSize);\\n        this._maxSize = maxSize;\\n    }\\n    \\n    public void Push(int x) {\\n        if (this._size < this._maxSize) {\\n            this._l.Insert(this._size, x);\\n            this._size++;\\n        }\\n    }\\n    \\n    public int Pop() {\\n        if (this._size == 0) return -1;\\n        \\n        this._size--;\\n        return this._l[this._size];\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        int end = Math.Min(this._size, k);\\n        for (int i = 0; i < end; i++) this._l[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * obj.Increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2312741,
                "title": "c-stack-medium-beginner-friendly",
                "content": "class CustomStack {\\npublic:\\n    int max;\\n    vector<int>v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max){\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k){\\n            x=v.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n if it helps plz dont forget to upvote it :)",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "class CustomStack {\\npublic:\\n    int max;\\n    vector<int>v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max){\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k){\\n            x=v.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n if it helps plz dont forget to upvote it :)",
                "codeTag": "Java"
            },
            {
                "id": 2296300,
                "title": "java-stack-easy-explanation-with-comments",
                "content": "```\\nclass CustomStack {\\n\\n    // Make value array where we can push and pop value.\\n    int value[];\\n    // Make increment array to implememt our logic.\\n    int increment[];\\n    // Index use to store element.\\n    int index;\\n    public CustomStack(int maxSize) {\\n        // Initailize it to max Size.\\n        value = new int[maxSize];\\n        // Initailize it to max Size.\\n        increment = new int[maxSize];\\n        //At first make index point to -1.\\n        index = -1;\\n    }\\n    \\n    public void push(int x) {\\n        // Before pushing first check if it is already filled completely just simply return.\\n        if(index + 1 == value.length)\\n        {\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        //It shows incrememt regarding this value is equal to zero.\\n        increment[index] = 0;\\n        \\n        \\n        \\n    }\\n    \\n    public int pop() {\\n        //Before popping check if stack is already empty.\\n        if(index == -1)\\n        {\\n            return index;\\n        }\\n        // Here we are storing the popped value.\\n        int x = value[index];\\n        // Here we are storing the corresponding increment of popped value.\\n        int increased = increment[index];\\n        // And we decrease index value.\\n        index--;\\n        \\n//     | 4  | \\n//     | 3  |\\n//     | 2  |\\n//     | 1  |\\n//     |____|\\n\\n// Increment of (4,100)\\n\\n//4    |100 |\\n//3    | 0  |\\n//2    | 0  |\\n//1    | 0  |\\n//     |____|\\n        \\n        //When we pop element from stack we will shift it inc val to below ele\\n        \\n// 4   |100 |\\n// 3   |100 |\\n// 2   | 0  |\\n// 1   | 0  |\\n//     |____|\\n        \\n        // It will continue until 1.\\n        \\n        if(index>=0)\\n        {\\n            increment[index]+=increased;\\n        }\\n        // Now return popped element + increased value;\\n        return x + increased;\\n    }\\n    \\n    public void increment(int k, int val) {\\n       \\n        // If k = 4 we need to put increme red val on 3 because of 0 based indexing.\\n        // Lets suppose if k = 5 but we have only 3 elements so we will take 3\\n        \\n        int ind = Math.min(k-1,index);\\n        //If index is -1 and k - 1 = 0.It will take index as min val which is -1.\\n        //But -1 is not a valid index.So we have to check is there any element present in             stack or not\\n        \\n        if(index >=0)\\n        {\\n            //Update increment array value.\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    // Make value array where we can push and pop value.\\n    int value[];\\n    // Make increment array to implememt our logic.\\n    int increment[];\\n    // Index use to store element.\\n    int index;\\n    public CustomStack(int maxSize) {\\n        // Initailize it to max Size.\\n        value = new int[maxSize];\\n        // Initailize it to max Size.\\n        increment = new int[maxSize];\\n        //At first make index point to -1.\\n        index = -1;\\n    }\\n    \\n    public void push(int x) {\\n        // Before pushing first check if it is already filled completely just simply return.\\n        if(index + 1 == value.length)\\n        {\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        //It shows incrememt regarding this value is equal to zero.\\n        increment[index] = 0;\\n        \\n        \\n        \\n    }\\n    \\n    public int pop() {\\n        //Before popping check if stack is already empty.\\n        if(index == -1)\\n        {\\n            return index;\\n        }\\n        // Here we are storing the popped value.\\n        int x = value[index];\\n        // Here we are storing the corresponding increment of popped value.\\n        int increased = increment[index];\\n        // And we decrease index value.\\n        index--;\\n        \\n//     | 4  | \\n//     | 3  |\\n//     | 2  |\\n//     | 1  |\\n//     |____|\\n\\n// Increment of (4,100)\\n\\n//4    |100 |\\n//3    | 0  |\\n//2    | 0  |\\n//1    | 0  |\\n//     |____|\\n        \\n        //When we pop element from stack we will shift it inc val to below ele\\n        \\n// 4   |100 |\\n// 3   |100 |\\n// 2   | 0  |\\n// 1   | 0  |\\n//     |____|\\n        \\n        // It will continue until 1.\\n        \\n        if(index>=0)\\n        {\\n            increment[index]+=increased;\\n        }\\n        // Now return popped element + increased value;\\n        return x + increased;\\n    }\\n    \\n    public void increment(int k, int val) {\\n       \\n        // If k = 4 we need to put increme red val on 3 because of 0 based indexing.\\n        // Lets suppose if k = 5 but we have only 3 elements so we will take 3\\n        \\n        int ind = Math.min(k-1,index);\\n        //If index is -1 and k - 1 = 0.It will take index as min val which is -1.\\n        //But -1 is not a valid index.So we have to check is there any element present in             stack or not\\n        \\n        if(index >=0)\\n        {\\n            //Update increment array value.\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230083,
                "title": "c-o-1-all-operations-small-easy-code",
                "content": "```\\nclass CustomStack {\\npublic:\\n    stack<int> s;\\n    vector<int> add;\\n    \\n    CustomStack(int maxSize) {\\n        add.resize(maxSize, 0);\\n    }\\n    \\n    void push(int x) {\\n        if ((int)s.size() == (int)add.size()) return;\\n        s.push(x);\\n    }\\n    \\n    int pop() {\\n        if (s.empty()) return -1;\\n        int sze = s.size();\\n        int res = s.top() + add[sze - 1];\\n        if (sze >= 2) {\\n            add[sze - 2] += add[sze - 1];\\n        }\\n        add[sze - 1] = 0;\\n        s.pop();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (s.empty()) return;\\n        int sze = s.size();\\n        add[min(sze, k) - 1] += val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    stack<int> s;\\n    vector<int> add;\\n    \\n    CustomStack(int maxSize) {\\n        add.resize(maxSize, 0);\\n    }\\n    \\n    void push(int x) {\\n        if ((int)s.size() == (int)add.size()) return;\\n        s.push(x);\\n    }\\n    \\n    int pop() {\\n        if (s.empty()) return -1;\\n        int sze = s.size();\\n        int res = s.top() + add[sze - 1];\\n        if (sze >= 2) {\\n            add[sze - 2] += add[sze - 1];\\n        }\\n        add[sze - 1] = 0;\\n        s.pop();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (s.empty()) return;\\n        int sze = s.size();\\n        add[min(sze, k) - 1] += val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186251,
                "title": "python-o-1-on-all-operations-by-lazy",
                "content": "I feel there is a point of design when it comes to increment as it can be realized in O(1) instead of O(k) just by adding another list.\\n\\nSince in a stack, we will only access the top element, the increment to the below elements can be delayed until needed.\\n\\nWe keep a additional list to keep track of increment needed at exactly this index AND below. When the element is popped, calculate the increment on the fly and pass on the increment.\\n\\n```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.l = 0\\n        self.data = [0] * maxSize\\n        self.maxSize = maxSize\\n        self.inc = [0] * maxSize\\n\\n    def push(self, x: int) -> None:\\n        if self.l >= self.maxSize:\\n            return\\n        \\n        self.data[self.l] = x\\n        self.inc[self.l] = 0\\n        self.l += 1\\n\\n    def pop(self) -> int:\\n        if self.l <= 0:\\n            return -1\\n        self.l -= 1\\n        inc = self.inc[self.l]\\n        if self.l - 1 >= 0:\\n            self.inc[self.l - 1] += inc\\n        return self.data[self.l] + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        self.inc[min(k, self.l)-1] += val\\n```\\nIt doesn\\'t end up fast on the test case pool probably due to its overhead of additional list. However complexity wise, it\\'s a non-trivial difference.",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.l = 0\\n        self.data = [0] * maxSize\\n        self.maxSize = maxSize\\n        self.inc = [0] * maxSize\\n\\n    def push(self, x: int) -> None:\\n        if self.l >= self.maxSize:\\n            return\\n        \\n        self.data[self.l] = x\\n        self.inc[self.l] = 0\\n        self.l += 1\\n\\n    def pop(self) -> int:\\n        if self.l <= 0:\\n            return -1\\n        self.l -= 1\\n        inc = self.inc[self.l]\\n        if self.l - 1 >= 0:\\n            self.inc[self.l - 1] += inc\\n        return self.data[self.l] + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        self.inc[min(k, self.l)-1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078665,
                "title": "simple-straight-forward-approach",
                "content": "Solution time is O(n) or O(k) depending upon test cases.\\n\\n```\\nclass CustomStack:\\n    # Solution O(k) or O(n).\\n    def __init__(self, maxSize: int):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0) \\n        \\n    def pop(self) -> int:\\n        if len(self.inc) == 0:\\n            return -1\\n        else:\\n            return self.stack.pop() + self.inc.pop()\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k,len(self.inc))):\\n            self.inc[i] += val\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n    # Solution O(k) or O(n).\\n    def __init__(self, maxSize: int):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0) \\n        \\n    def pop(self) -> int:\\n        if len(self.inc) == 0:\\n            return -1\\n        else:\\n            return self.stack.pop() + self.inc.pop()\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k,len(self.inc))):\\n            self.inc[i] += val\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043741,
                "title": "java-design",
                "content": "```\\nclass CustomStack {\\n    int size;\\n    int[] arr;\\n    int top;\\n    \\n    public CustomStack(int maxSize) {\\n        this.size = maxSize;\\n        this.arr = new int[maxSize];\\n        this.top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(size - top > 1) {\\n            top++;\\n            arr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (top != -1) {\\n            int topElement = arr[top];\\n            top--;\\n            return topElement;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int num = Math.min(k, size);\\n        \\n        for(int i = 0; i < num; i++) {\\n            arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    int[] arr;\\n    int top;\\n    \\n    public CustomStack(int maxSize) {\\n        this.size = maxSize;\\n        this.arr = new int[maxSize];\\n        this.top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(size - top > 1) {\\n            top++;\\n            arr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (top != -1) {\\n            int topElement = arr[top];\\n            top--;\\n            return topElement;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int num = Math.min(k, size);\\n        \\n        for(int i = 0; i < num; i++) {\\n            arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996567,
                "title": "using-vector-c-solution-easy-solution",
                "content": "\\tclass CustomStack {\\n\\tprivate:\\n    vector<int> vec;\\n    int top;\\n\\tpublic:\\n    CustomStack(int maxSize) {\\n        vec.resize(maxSize);\\n        top = -1;\\n    }\\n    \\n    void push(int x) {\\n        if(top+1 == vec.size())\\n            return;\\n        else {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top == -1)\\n            return -1;\\n        else {\\n            int temp = vec[top];\\n            top--;\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top >= k - 1) {\\n            for(int i = 0; i< k ; i++) \\n                vec[i] += val;\\n        }\\n        else {\\n            for(int i = 0; i<= top ;i++)\\n                vec[i] += val;\\n        }\\n    }\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tclass CustomStack {\\n\\tprivate:\\n    vector<int> vec;\\n    int top;\\n\\tpublic:\\n    CustomStack(int maxSize) {\\n        vec.resize(maxSize);\\n        top = -1;\\n    }\\n    \\n    void push(int x) {\\n        if(top+1 == vec.size())\\n            return;\\n        else {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top == -1)\\n            return -1;\\n        else {\\n            int temp = vec[top];\\n            top--;\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top >= k - 1) {\\n            for(int i = 0; i< k ; i++) \\n                vec[i] += val;\\n        }\\n        else {\\n            for(int i = 0; i<= top ;i++)\\n                vec[i] += val;\\n        }\\n    }\\n\\t};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1939266,
                "title": "design-a-stack-with-increment-operation",
                "content": "class CustomStack {\\n   \\n    private int [] arr;\\n    private int n;\\n    private int idx;\\n    public CustomStack(int maxSize) {\\n         n = maxSize;\\n         idx = 0;\\n         arr = new int [n];\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(idx<n){\\n            arr[idx++] = x;\\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n    \\n        if(idx==0) return -1;\\n        return arr[--idx];\\n    }\\n    \\n    public void increment(int k, int val) {\\n    \\n        if(idx>=k){\\n            int i = 0;\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }else{\\n            int i = 0;\\n            while(i<idx){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "class CustomStack {\\n   \\n    private int [] arr;\\n    private int n;\\n    private int idx;\\n    public CustomStack(int maxSize) {\\n         n = maxSize;\\n         idx = 0;\\n         arr = new int [n];\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(idx<n){\\n            arr[idx++] = x;\\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n    \\n        if(idx==0) return -1;\\n        return arr[--idx];\\n    }\\n    \\n    public void increment(int k, int val) {\\n    \\n        if(idx>=k){\\n            int i = 0;\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }else{\\n            int i = 0;\\n            while(i<idx){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1930744,
                "title": "java-solution",
                "content": "```\\nclass CustomStack {\\n    int[] stack;\\n    int top;\\n    int size;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];    \\n        top = -1;\\n        size = maxSize;\\n    }\\n    \\n    public void push(int x) {     \\n        if (top >= size-1) return;\\n        stack[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top<0) return -1;\\n        int x = stack[top--];\\n        return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<size && i<=top;i++) {  \\n            \\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int top;\\n    int size;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];    \\n        top = -1;\\n        size = maxSize;\\n    }\\n    \\n    public void push(int x) {     \\n        if (top >= size-1) return;\\n        stack[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top<0) return -1;\\n        int x = stack[top--];\\n        return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<size && i<=top;i++) {  \\n            \\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1918686,
                "title": "1381-design-a-stack-with-increment-operation",
                "content": "```\\nclass CustomStack {\\n    int count,k;\\n    stack<int>st;\\n    stack<int>st1;\\npublic:\\n    CustomStack(int maxSize) {\\n        k=maxSize;\\n        count=0;\\n    }\\n    \\n    void push(int x){\\n        if(count>=k)\\n        {\\n        }\\n        else{\\n        count++;\\n        st.push(x);\\n        }\\n    }\\n    int pop() {\\n        if(count==0)\\n            return -1;\\n        int x=st.top();\\n        st.pop();\\n        count--;\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        if(k>st.size()){\\n            while(!st.empty()){\\n                int x=st.top()+val;\\n                st.pop();\\n                st1.push(x);\\n            }\\n              while(!st1.empty()){\\n                int x=st1.top();\\n                st1.pop();\\n                st.push(x);\\n            }\\n        }\\n        else{\\n            while(!st.empty()){\\n            if(k>=st.size()){\\n                 int x=st.top()+val;\\n                 st.pop();\\n                st1.push(x);\\n            }\\n            else{\\n                int x=st.top();\\n                st.pop();\\n                st1.push(x);\\n            }\\n        }\\n            while(!st1.empty()){\\n                int x=st1.top();\\n                cout<<x<<endl;\\n                st1.pop();\\n                st.push(x);\\n            }\\n      }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int count,k;\\n    stack<int>st;\\n    stack<int>st1;\\npublic:\\n    CustomStack(int maxSize) {\\n        k=maxSize;\\n        count=0;\\n    }\\n    \\n    void push(int x){\\n        if(count>=k)\\n        {\\n        }\\n        else{\\n        count++;\\n        st.push(x);\\n        }\\n    }\\n    int pop() {\\n        if(count==0)\\n            return -1;\\n        int x=st.top();\\n        st.pop();\\n        count--;\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        if(k>st.size()){\\n            while(!st.empty()){\\n                int x=st.top()+val;\\n                st.pop();\\n                st1.push(x);\\n            }\\n              while(!st1.empty()){\\n                int x=st1.top();\\n                st1.pop();\\n                st.push(x);\\n            }\\n        }\\n        else{\\n            while(!st.empty()){\\n            if(k>=st.size()){\\n                 int x=st.top()+val;\\n                 st.pop();\\n                st1.push(x);\\n            }\\n            else{\\n                int x=st.top();\\n                st.pop();\\n                st1.push(x);\\n            }\\n        }\\n            while(!st1.empty()){\\n                int x=st1.top();\\n                cout<<x<<endl;\\n                st1.pop();\\n                st.push(x);\\n            }\\n      }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1793874,
                "title": "python-o-1-increment-solution-explained-with-examples",
                "content": "I read a lot of solutions in discussions but none of them explained it, so here is my code with explaination.\\nThe logic is explained in comments:\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n        self.increments = []\\n\\n    # Simple to understand\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n            self.increments.append(0)\\n\\n\\n    def pop(self) -> int:\\n        if self.stack:\\n\\n            # Say increments is: [0,0,0,5,0,0,0,9]\\n            # This means increment the first four elements by 5 and also the first eight element by 9\\n            # Since 9 is present only once but it affetcs all the elements before it\\n            # Hence we\\'ll pop and increment the new last element by 9, now the effect of 9 will still carry on\\n            lastIncrement = self.increments.pop()\\n            \\n            # This if handles the case to retain 9\\'s effect on previous elements\\n            # After this new increments will be: [0,0,0,5,0,0,9]\\n            if self.increments:\\n                self.increments[-1] += lastIncrement\\n            \\n            # And now we can simply pop the last element, add the last increment and return it\\n            return self.stack.pop() + lastIncrement\\n        \\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            # Make the last element += val \\n            # So when we pop them this will increment all the elements of the stack\\n            if k >= len(self.stack):\\n                self.increments[-1] += val\\n            \\n            # Make last element of the fist k elements += val\\n            # So when we pop them this will increment only the first k elements\\n            else:\\n                self.increments[k-1] += val\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n        self.increments = []\\n\\n    # Simple to understand\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n            self.increments.append(0)\\n\\n\\n    def pop(self) -> int:\\n        if self.stack:\\n\\n            # Say increments is: [0,0,0,5,0,0,0,9]\\n            # This means increment the first four elements by 5 and also the first eight element by 9\\n            # Since 9 is present only once but it affetcs all the elements before it\\n            # Hence we\\'ll pop and increment the new last element by 9, now the effect of 9 will still carry on\\n            lastIncrement = self.increments.pop()\\n            \\n            # This if handles the case to retain 9\\'s effect on previous elements\\n            # After this new increments will be: [0,0,0,5,0,0,9]\\n            if self.increments:\\n                self.increments[-1] += lastIncrement\\n            \\n            # And now we can simply pop the last element, add the last increment and return it\\n            return self.stack.pop() + lastIncrement\\n        \\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            # Make the last element += val \\n            # So when we pop them this will increment all the elements of the stack\\n            if k >= len(self.stack):\\n                self.increments[-1] += val\\n            \\n            # Make last element of the fist k elements += val\\n            # So when we pop them this will increment only the first k elements\\n            else:\\n                self.increments[k-1] += val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784658,
                "title": "java-simple-o-1-100-solution",
                "content": "```java\\nclass CustomStack {\\n    private int[] stack;\\n    private int[] increment;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.increment = new int[maxSize];\\n        this.size = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.size < this.stack.length)\\n            this.stack[this.size++] = x;\\n    }\\n    \\n    public int pop() {\\n        if(this.size < 1)\\n            return -1;\\n        \\n        if(--this.size > 0)\\n            this.increment[this.size - 1] += this.increment[this.size];\\n        \\n        int result = this.stack[this.size] + this.increment[this.size];\\n        \\n        this.increment[this.size] = 0;\\n        \\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int i = Math.min(k, this.size) - 1;\\n        \\n        if(i > -1)\\n            this.increment[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```java\\nclass CustomStack {\\n    private int[] stack;\\n    private int[] increment;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.increment = new int[maxSize];\\n        this.size = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.size < this.stack.length)\\n            this.stack[this.size++] = x;\\n    }\\n    \\n    public int pop() {\\n        if(this.size < 1)\\n            return -1;\\n        \\n        if(--this.size > 0)\\n            this.increment[this.size - 1] += this.increment[this.size];\\n        \\n        int result = this.stack[this.size] + this.increment[this.size];\\n        \\n        this.increment[this.size] = 0;\\n        \\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int i = Math.min(k, this.size) - 1;\\n        \\n        if(i > -1)\\n            this.increment[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760887,
                "title": "c-array-without-using-stack",
                "content": "**Upvote if my solution is helpful to you**\\n```C++\\nclass CustomStack\\n{\\npublic:\\n    int Size;\\n    vector<int> stack;\\n    CustomStack(int maxSize)\\n    {\\n        Size = maxSize;\\n    }\\n\\n    void push(int x)\\n    {\\n        if (stack.size() < Size)\\n        {\\n            stack.push_back(x);\\n        }\\n    }\\n\\n    int pop()\\n    {\\n        if (!stack.empty())\\n        {\\n            int x = stack.back();\\n            stack.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n\\n    void increment(int k, int val)\\n    {\\n        int n = stack.size();\\n        for (int i = 0; i < min(k, n); i++)\\n        {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```C++\\nclass CustomStack\\n{\\npublic:\\n    int Size;\\n    vector<int> stack;\\n    CustomStack(int maxSize)\\n    {\\n        Size = maxSize;\\n    }\\n\\n    void push(int x)\\n    {\\n        if (stack.size() < Size)\\n        {\\n            stack.push_back(x);\\n        }\\n    }\\n\\n    int pop()\\n    {\\n        if (!stack.empty())\\n        {\\n            int x = stack.back();\\n            stack.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n\\n    void increment(int k, int val)\\n    {\\n        int n = stack.size();\\n        for (int i = 0; i < min(k, n); i++)\\n        {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740899,
                "title": "java-solution-using-array-stack-for-increment-and-global-pointer-capacity",
                "content": "```\\nclass CustomStack {\\n    private int[] stack;\\n    private int capacity;\\n    private int top = -1;\\n\\n    public CustomStack(int maxSize) {\\n           this.capacity = maxSize;\\n           stack = new int[this.capacity];\\n    }\\n    \\n    public void push(int x) {\\n       if(top+1 == this.capacity)\\n           return;\\n        \\n       stack[++top] = x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top < 0)\\n            return -1;\\n        \\n        int val;\\n        val = stack[top];\\n        \\n        //for garbage collection\\n        stack[top--] = Integer.MIN_VALUE;\\n        \\n        return val;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> inc = new Stack<>();\\n        \\n        while(top+1 > k && top > -1){\\n            inc.push(stack[top--]);\\n        }\\n        \\n        while(top > -1){\\n            int data = stack[top--];\\n            inc.push(data+val);\\n        }\\n        \\n        while(!inc.isEmpty()){\\n            stack[++top] = inc.pop();\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    private int[] stack;\\n    private int capacity;\\n    private int top = -1;\\n\\n    public CustomStack(int maxSize) {\\n           this.capacity = maxSize;\\n           stack = new int[this.capacity];\\n    }\\n    \\n    public void push(int x) {\\n       if(top+1 == this.capacity)\\n           return;\\n        \\n       stack[++top] = x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top < 0)\\n            return -1;\\n        \\n        int val;\\n        val = stack[top];\\n        \\n        //for garbage collection\\n        stack[top--] = Integer.MIN_VALUE;\\n        \\n        return val;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> inc = new Stack<>();\\n        \\n        while(top+1 > k && top > -1){\\n            inc.push(stack[top--]);\\n        }\\n        \\n        while(top > -1){\\n            int data = stack[top--];\\n            inc.push(data+val);\\n        }\\n        \\n        while(!inc.isEmpty()){\\n            stack[++top] = inc.pop();\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1714966,
                "title": "java-one-array-o-1-finite-difference-prefix-sum",
                "content": "Intsead of storing the original value of each element in the stack, we store the difference between each element and its previous one, except for the bottom of the stack - we just store its original value. Let\\'s call this stack ```difference``` to distinguish it from the ```CustomStack``` the question told us to implement. ```difference[k] = CustomStack[k] - CustomStack[k-1]``` for all ```k > 0```, and ```difference[0] = CustomStack[0]```. \\n\\nWe also keep track of the top value of the ```CustomStack```. When we push an element to the ```CustomStack```, we update the value of the top element, and put the difference between the old top element and the new top element in the ```difference``` stack. When we pop an element, the new top element will be ```the old top element - top of the difference stack```.\\n\\nThen how do we implement ```inc()```? Surely, we should increment the bottom of the ```difference``` stack by ```val``` since it is supposed to be also the bottom of the ```CustomStack```. However, since we increment the bottom k elements of the ```CustomStack``` simultaneously, the difference between each of the bottom k elements won\\'t change at all! We only need to take care of ```stack[k]```. Since ```CustomStack[k - 1]``` increases by ```val``` and ```CustomStack[k]``` remains the same, ```difference[k]``` should decrease by ```val```.\\n```\\nclass CustomStack {\\n    int[] difference;\\n    int size;\\n    int top;\\n\\n    public CustomStack(int maxSize) {\\n        difference = new int[maxSize];\\n        size = 0;\\n        top = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(size < difference.length){\\n            difference[size] = x - top;\\n            top = x;\\n            size++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(size == 0){\\n            return -1;\\n        }\\n        int old = top;\\n        top -= difference[size - 1];\\n        size--;\\n        return old;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        difference[0] += val;\\n        if(k < size){\\n            difference[k] -= val;\\n        }\\n        else{\\n            top += val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```difference```\n```CustomStack```\n```difference[k] = CustomStack[k] - CustomStack[k-1]```\n```k > 0```\n```difference[0] = CustomStack[0]```\n```CustomStack```\n```CustomStack```\n```difference```\n```the old top element - top of the difference stack```\n```inc()```\n```difference```\n```val```\n```CustomStack```\n```CustomStack```\n```stack[k]```\n```CustomStack[k - 1]```\n```val```\n```CustomStack[k]```\n```difference[k]```\n```val```\n```\\nclass CustomStack {\\n    int[] difference;\\n    int size;\\n    int top;\\n\\n    public CustomStack(int maxSize) {\\n        difference = new int[maxSize];\\n        size = 0;\\n        top = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(size < difference.length){\\n            difference[size] = x - top;\\n            top = x;\\n            size++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(size == 0){\\n            return -1;\\n        }\\n        int old = top;\\n        top -= difference[size - 1];\\n        size--;\\n        return old;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        difference[0] += val;\\n        if(k < size){\\n            difference[k] -= val;\\n        }\\n        else{\\n            top += val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655050,
                "title": "easy-implementation-than-lee215-java",
                "content": "int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n+1];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size();\\n        if (i <= 0) return -1;\\n    \\n        inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n            int i = Math.min(k, stack.size()) ;\\n            inc[i] += val;\\n    }",
                "solutionTags": [],
                "code": "int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n+1];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size();\\n        if (i <= 0) return -1;\\n    \\n        inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n            int i = Math.min(k, stack.size()) ;\\n            inc[i] += val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1607780,
                "title": "java-easy",
                "content": "```\\nclass CustomStack {\\n\\n    int maxSize =0;\\n    int curr_size;\\n    int  arr[];        \\n    public CustomStack(int _maxSize) {\\n        maxSize =_maxSize;\\n        curr_size =0;\\n        arr = new int[maxSize];\\n       \\n    }\\n    \\n    public void push(int x) {\\n       \\n        if(curr_size < maxSize ){\\n             arr[curr_size++] =x;\\n        }\\n         \\n    }\\n    \\n    public int pop() {\\n        if(curr_size < 1) return  -1;\\n        return  arr[--curr_size];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        k= Math.min(k,curr_size);\\n        \\n        for(int  i = 0 ; i < k;i++){\\n            arr[i]= arr[i]+val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int maxSize =0;\\n    int curr_size;\\n    int  arr[];        \\n    public CustomStack(int _maxSize) {\\n        maxSize =_maxSize;\\n        curr_size =0;\\n        arr = new int[maxSize];\\n       \\n    }\\n    \\n    public void push(int x) {\\n       \\n        if(curr_size < maxSize ){\\n             arr[curr_size++] =x;\\n        }\\n         \\n    }\\n    \\n    public int pop() {\\n        if(curr_size < 1) return  -1;\\n        return  arr[--curr_size];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        k= Math.min(k,curr_size);\\n        \\n        for(int  i = 0 ; i < k;i++){\\n            arr[i]= arr[i]+val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604651,
                "title": "java-increment-only-during-pop-operation-o-1-time-o-2n-space",
                "content": "```\\nclass CustomStack {\\n    int[] stack;\\n    int[] extra;\\n    int tos;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        extra = new int[maxSize];\\n        tos = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if (tos < stack.length) {\\n            stack[tos++] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        var result = -1;\\n        if (tos > 0) {\\n            tos--;\\n            result = stack[tos] + extra[tos];\\n            if (tos > 0) {\\n                extra[tos-1] += extra[tos];\\n            }\\n            extra[tos] = 0;\\n        }\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(tos, k);\\n        if (k > 0) {\\n            extra[k-1] += val;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int[] extra;\\n    int tos;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        extra = new int[maxSize];\\n        tos = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if (tos < stack.length) {\\n            stack[tos++] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        var result = -1;\\n        if (tos > 0) {\\n            tos--;\\n            result = stack[tos] + extra[tos];\\n            if (tos > 0) {\\n                extra[tos-1] += extra[tos];\\n            }\\n            extra[tos] = 0;\\n        }\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(tos, k);\\n        if (k > 0) {\\n            extra[k-1] += val;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603438,
                "title": "cleanest-java-stack-solution-o-1",
                "content": "We can use a Stack to hold numbers, which is easy. The trick is how do we maintain the incremented values on each k? Using an array [0, 1, ..., maxSize] will denote that arr[i] represents the increment applied to all element from stack[0, ..., i] or from the bottom element to the ith element. Using an array is best because we can access the increment k from any position or index in O(1) time.\\n\\nHow to handle increment(k, val) ?\\nWe can simply increment arr[k] += val, this way even if increment(k, val) is called repeatedly with the same k, the amount is always added up. The only case to be aware of is whether or not ```K > stack.size()``` because this may cause an index out of bounds exception.\\n\\nHow to handle pop?\\nFor the case where stack is empty, return -1.\\nOtherwise get the increment amount we must apply to the popped value, by calling ```int amount = arr[stack.size()]```. This access provides the amount to increment for the popped value and all values below it in the stack. Then erase the increment being applied to the popped value from the arr like so: ```arr[stack.size()] = 0```. Finally, we want to maintain that increment for all items in the stack so we add it to the previous index ```arr[stack.size() - 1] += amount```. Finally just ```stack.pop() + amount``` to get the next value incremented.\\n\\nThe only edge case to worry about is when k > maxSize which would be out of bounds.\\n```\\nclass CustomStack {\\n    \\n    Stack<Integer> stack = new Stack<>();\\n    int[] additions;\\n    int maxSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        this.additions = new int[maxSize + 1];\\n    }\\n    \\n    public void push(int x) {\\n        // edge case: stack is full at maxSize\\n        if (stack.size() == maxSize)\\n            return;\\n        // push val into stack\\n        stack.push(x);\\n    }\\n    \\n    public int pop() {\\n        // edge case: stack is empty\\n        if (stack.isEmpty())\\n            return -1;\\n        \\n        // get addition amount for next num and erase it from arr\\n        int amount = additions[stack.size()];\\n        additions[stack.size()] = 0;\\n        \\n        // add amount to item below next val\\n        additions[stack.size() - 1] += amount;\\n        \\n        return stack.pop() + amount;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        // add val to kth index\\n        additions[Math.min(k, stack.size())] += val;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```K > stack.size()```\n```int amount = arr[stack.size()]```\n```arr[stack.size()] = 0```\n```arr[stack.size() - 1] += amount```\n```stack.pop() + amount```\n```\\nclass CustomStack {\\n    \\n    Stack<Integer> stack = new Stack<>();\\n    int[] additions;\\n    int maxSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        this.additions = new int[maxSize + 1];\\n    }\\n    \\n    public void push(int x) {\\n        // edge case: stack is full at maxSize\\n        if (stack.size() == maxSize)\\n            return;\\n        // push val into stack\\n        stack.push(x);\\n    }\\n    \\n    public int pop() {\\n        // edge case: stack is empty\\n        if (stack.isEmpty())\\n            return -1;\\n        \\n        // get addition amount for next num and erase it from arr\\n        int amount = additions[stack.size()];\\n        additions[stack.size()] = 0;\\n        \\n        // add amount to item below next val\\n        additions[stack.size() - 1] += amount;\\n        \\n        return stack.pop() + amount;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        // add val to kth index\\n        additions[Math.min(k, stack.size())] += val;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1564441,
                "title": "c-easy-using-vector",
                "content": "class CustomStack {\\npublic:\\n    vector<int> st;\\n    int top;\\n    int maxS;\\n    CustomStack(int maxSize) : st(maxSize){\\n        top = 0;\\n        maxS = maxSize;\\n       \\n    }\\n    \\n    void push(int x) {\\n      \\n        if(top < maxS)\\n        {\\n            st[top] = x;\\n            top++;\\n        }\\n        \\n    }\\n    \\n    int pop() {\\n        \\n        int res = -1;\\n        if(top > 0)\\n        {\\n            res = st[top-1];\\n            top--;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n       for(int i = 0; i < k && i < top; i++)\\n       {\\n           st[i] = st[i] + val;\\n       }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */",
                "solutionTags": [],
                "code": "class CustomStack {\\npublic:\\n    vector<int> st;\\n    int top;\\n    int maxS;\\n    CustomStack(int maxSize) : st(maxSize){\\n        top = 0;\\n        maxS = maxSize;\\n       \\n    }\\n    \\n    void push(int x) {\\n      \\n        if(top < maxS)\\n        {\\n            st[top] = x;\\n            top++;\\n        }\\n        \\n    }\\n    \\n    int pop() {\\n        \\n        int res = -1;\\n        if(top > 0)\\n        {\\n            res = st[top-1];\\n            top--;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n       for(int i = 0; i < k && i < top; i++)\\n       {\\n           st[i] = st[i] + val;\\n       }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1550514,
                "title": "using-just-an-array",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int pos;\\n    int size;\\n    int arr[1001]={};\\n    \\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n        arr[0] = -1;\\n        pos = 0;\\n    }\\n    \\n    void push(int x) {\\n        //cout << x << \\' \\' << pos << \\'\\\\n\\';\\n        if(pos < size){arr[++pos] = x;}\\n    }\\n    \\n    int pop() {\\n        //cout << pos << \\' \\' << arr[pos] << \\'\\\\n\\';\\n        if(pos>0){return arr[pos--];}\\n        else{return arr[pos];}\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i;        \\n        for(i=1; i<=k && i<=pos; i++){arr[i]+=val;}\\n        //cout << pos << \\' \\' << val << \\' \\' << arr[pos] << \\'\\\\n\\';\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int pos;\\n    int size;\\n    int arr[1001]={};\\n    \\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n        arr[0] = -1;\\n        pos = 0;\\n    }\\n    \\n    void push(int x) {\\n        //cout << x << \\' \\' << pos << \\'\\\\n\\';\\n        if(pos < size){arr[++pos] = x;}\\n    }\\n    \\n    int pop() {\\n        //cout << pos << \\' \\' << arr[pos] << \\'\\\\n\\';\\n        if(pos>0){return arr[pos--];}\\n        else{return arr[pos];}\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i;        \\n        for(i=1; i<=k && i<=pos; i++){arr[i]+=val;}\\n        //cout << pos << \\' \\' << val << \\' \\' << arr[pos] << \\'\\\\n\\';\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 1546807,
                "title": "python-soluion",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack) > 0:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if k > len(self.stack):\\n            k = len(self.stack)\\n        for i in range(0, k):\\n            self.stack[i] += val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack) > 0:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if k > len(self.stack):\\n            k = len(self.stack)\\n        for i in range(0, k):\\n            self.stack[i] += val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544173,
                "title": "easy-understandable-java-code-using-array",
                "content": "```\\nclass CustomStack {\\n    private int arr[];\\n    private int top, size;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < arr.length-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top != -1) {\\n            return arr[top--];\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0; i < k && i < arr.length; i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    private int arr[];\\n    private int top, size;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < arr.length-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top != -1) {\\n            return arr[top--];\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0; i < k && i < arr.length; i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538549,
                "title": "java-solution-using-array",
                "content": "class CustomStack {\\n\\n    int top = -1;\\n    int[] arr;\\n    \\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(top<arr.length-1)\\n        arr[++top]=x; \\n    }\\n    \\n    public int pop() {\\n        if(top == -1)\\n            return -1;\\n        int value = arr[top];\\n        arr[top] = Integer.MIN_VALUE;\\n        top--;\\n        return value;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int increment = -1;\\n        if(k-1<top)\\n          increment=k-1;  \\n        else\\n          increment=top;           \\n        for(int i=0;i<=increment;i++)\\n            arr[i]+=val;         \\n    }\\n}",
                "solutionTags": [],
                "code": "class CustomStack {\\n\\n    int top = -1;\\n    int[] arr;\\n    \\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(top<arr.length-1)\\n        arr[++top]=x; \\n    }\\n    \\n    public int pop() {\\n        if(top == -1)\\n            return -1;\\n        int value = arr[top];\\n        arr[top] = Integer.MIN_VALUE;\\n        top--;\\n        return value;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int increment = -1;\\n        if(k-1<top)\\n          increment=k-1;  \\n        else\\n          increment=top;           \\n        for(int i=0;i<=increment;i++)\\n            arr[i]+=val;         \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1479010,
                "title": "c-24ms-98-simple-solution",
                "content": "Runtime: 24 ms, faster than 98.16% of C++ online submissions for Design a Stack With Increment Operation.\\nMemory Usage: 21 MB, less than 75.46% of C++ online submissions for Design a Stack With Increment Operation.\\n```\\nclass CustomStack {\\npublic:\\n  int i, mi;\\n  vector<int> s;\\n  \\n  CustomStack(int maxSize) {\\n    i = -1, mi = maxSize - 1;\\n    s.resize(maxSize);\\n  }\\n    \\n  void push(int x) {\\n    if(i != mi) s[++i] = x;  \\n  }\\n    \\n  int pop() {\\n    return i != -1 ? s[i--] : -1;      \\n  }\\n    \\n  void increment(int k, int val) {\\n    k = min(k, i + 1);\\n    while(--k >= 0) s[k] += val;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n  int i, mi;\\n  vector<int> s;\\n  \\n  CustomStack(int maxSize) {\\n    i = -1, mi = maxSize - 1;\\n    s.resize(maxSize);\\n  }\\n    \\n  void push(int x) {\\n    if(i != mi) s[++i] = x;  \\n  }\\n    \\n  int pop() {\\n    return i != -1 ? s[i--] : -1;      \\n  }\\n    \\n  void increment(int k, int val) {\\n    k = min(k, i + 1);\\n    while(--k >= 0) s[k] += val;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441406,
                "title": "c-o-1-time-o-maxsize-space",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int, int>> stk;\\n    int capacity, top;\\n    \\n    CustomStack(int maxSize) : \\n        capacity(maxSize), top(-1), stk(maxSize) {}\\n    \\n    void push(int x) {\\n        if (top == capacity - 1)\\n            return;\\n        top++;\\n        stk[top].first = x;\\n        stk[top].second = 0;\\n    }\\n    \\n    int pop() {\\n        if (top == -1)\\n            return -1;\\n        if (top != 0)\\n            stk[top - 1].second += stk[top].second;\\n        int val = stk[top].first + stk[top].second;\\n        top--;\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (k <= 0 || top == -1)\\n            return;\\n        stk[min(k - 1, top)].second += val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int, int>> stk;\\n    int capacity, top;\\n    \\n    CustomStack(int maxSize) : \\n        capacity(maxSize), top(-1), stk(maxSize) {}\\n    \\n    void push(int x) {\\n        if (top == capacity - 1)\\n            return;\\n        top++;\\n        stk[top].first = x;\\n        stk[top].second = 0;\\n    }\\n    \\n    int pop() {\\n        if (top == -1)\\n            return -1;\\n        if (top != 0)\\n            stk[top - 1].second += stk[top].second;\\n        int val = stk[top].first + stk[top].second;\\n        top--;\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (k <= 0 || top == -1)\\n            return;\\n        stk[min(k - 1, top)].second += val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407529,
                "title": "c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> incr,vec;\\n    int top = -1;\\n    CustomStack(int maxSize) {\\n        vector<int> temp(maxSize,0);\\n        incr = vec = temp;\\n    }\\n    \\n    void push(int x) {\\n        if(top != vec.size()-1)\\n        {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top != -1)\\n        {\\n            int incrVal = incr[top];\\n            if(top != 0)\\n            {\\n                incr[top-1] += incr[top];\\n            }\\n            incr[top] = 0;\\n            top--;\\n            return incrVal+vec[top+1];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top == -1)\\n        {\\n            return;\\n        }\\n        if(k > top)\\n        {\\n            incr[top] += val;\\n        }else{\\n            incr[k-1] += val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> incr,vec;\\n    int top = -1;\\n    CustomStack(int maxSize) {\\n        vector<int> temp(maxSize,0);\\n        incr = vec = temp;\\n    }\\n    \\n    void push(int x) {\\n        if(top != vec.size()-1)\\n        {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top != -1)\\n        {\\n            int incrVal = incr[top];\\n            if(top != 0)\\n            {\\n                incr[top-1] += incr[top];\\n            }\\n            incr[top] = 0;\\n            top--;\\n            return incrVal+vec[top+1];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top == -1)\\n        {\\n            return;\\n        }\\n        if(k > top)\\n        {\\n            incr[top] += val;\\n        }else{\\n            incr[k-1] += val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395643,
                "title": "javascript-solution",
                "content": "```\\nvar CustomStack = function(maxSize) {\\n    this.arr = [];\\n    this.maxSize = maxSize;\\n};\\n\\n\\nCustomStack.prototype.push = function(x) {\\n    if (this.arr.length === this.maxSize) return;\\n    this.arr.push(x);\\n};\\n\\n\\nCustomStack.prototype.pop = function() {\\n    if (this.arr.length === 0) return -1;\\n    return this.arr.pop();\\n};\\n\\n\\nCustomStack.prototype.increment = function(k, val) {\\n    let index = 0;\\n    \\n    for (let i = 0; i < Math.min(this.maxSize, k); i++) {\\n        this.arr[i] += val;\\n    }    \\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nvar CustomStack = function(maxSize) {\\n    this.arr = [];\\n    this.maxSize = maxSize;\\n};\\n\\n\\nCustomStack.prototype.push = function(x) {\\n    if (this.arr.length === this.maxSize) return;\\n    this.arr.push(x);\\n};\\n\\n\\nCustomStack.prototype.pop = function() {\\n    if (this.arr.length === 0) return -1;\\n    return this.arr.pop();\\n};\\n\\n\\nCustomStack.prototype.increment = function(k, val) {\\n    let index = 0;\\n    \\n    for (let i = 0; i < Math.min(this.maxSize, k); i++) {\\n        this.arr[i] += val;\\n    }    \\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382871,
                "title": "c-fastest-runtime-20-ms-faster-than-100-00-of-c-online-submissions",
                "content": "class CustomStack {\\n    int * ar,i = -1,n;\\npublic:\\n    CustomStack(int maxSize) {\\n        ar = new int[maxSize];\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(i != n-1)\\n        {\\n            ar[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i == -1)\\n            return i;\\n        return ar[i--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(i < k-1)\\n        {\\n            for(int j = 0 ; j <=i;j++)\\n                ar[j] += val;\\n        }\\n        else\\n        {\\n            for(int j = 0 ; j <k;j++)\\n                ar[j] += val; \\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class CustomStack {\\n    int * ar,i = -1,n;\\npublic:\\n    CustomStack(int maxSize) {\\n        ar = new int[maxSize];\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(i != n-1)\\n        {\\n            ar[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i == -1)\\n            return i;\\n        return ar[i--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(i < k-1)\\n        {\\n            for(int j = 0 ; j <=i;j++)\\n                ar[j] += val;\\n        }\\n        else\\n        {\\n            for(int j = 0 ; j <k;j++)\\n                ar[j] += val; \\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1373623,
                "title": "java-easy-to-understand-solution-array-to-represent-the-stack",
                "content": "My `JAVA` solution using an array to represent the stack.\\n\\n`Adding` elements to the stack : \\n* We add elements in our stack array from left to right (index 0 to MAX - 1).\\n* Here index is the leftmost free position in stack array.\\n\\n`Removing` elements from the stack : \\n* We remove elements from our stack array from right to left (index MAX - 1 to 0).\\n* Here index is the rightmost element in stack array.\\n\\n`Increment` elements last k elements by value :\\n* So we have to add value to the elements from index 0 to endPosition.\\n* `endPosition =  Math.min(k - 1, index - 1).`\\n* Add value to endPosition(it will mean that we have to add value from index 0 to endPosition).\\n* Now during removal of an element from stack array, we pass this removed index value to the previous element in stack.\\n\\n```\\nclass CustomStack {\\n    int[] stack;\\n    int[] increment;\\n    int MAX;\\n    int index = 0;\\n    public CustomStack(int maxSize) {\\n        MAX = maxSize;\\n        stack = new int[MAX];\\n        increment = new int[MAX];\\n    }\\n    \\n    public void push(int x) {\\n        if (index == MAX) {\\n            return;\\n        }\\n        stack[index] = x;\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if (index == 0) {\\n            return -1;\\n        }\\n        if (index > 1) {\\n            increment[index - 2] += increment[index - 1];\\n        }\\n        index--;\\n        int sum = stack[index] + increment[index];\\n        increment[index] = 0;\\n        return sum;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (index == 0) {\\n            return;\\n        }\\n        int endPosition = Math.min(k - 1, index - 1);\\n        increment[endPosition] += val;\\n    }\\n}\\n\\n/*\\n\\n\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```\\n\\nIf you like the solution, please Upvote \\uD83D\\uDC4D!!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int[] increment;\\n    int MAX;\\n    int index = 0;\\n    public CustomStack(int maxSize) {\\n        MAX = maxSize;\\n        stack = new int[MAX];\\n        increment = new int[MAX];\\n    }\\n    \\n    public void push(int x) {\\n        if (index == MAX) {\\n            return;\\n        }\\n        stack[index] = x;\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if (index == 0) {\\n            return -1;\\n        }\\n        if (index > 1) {\\n            increment[index - 2] += increment[index - 1];\\n        }\\n        index--;\\n        int sum = stack[index] + increment[index];\\n        increment[index] = 0;\\n        return sum;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (index == 0) {\\n            return;\\n        }\\n        int endPosition = Math.min(k - 1, index - 1);\\n        increment[endPosition] += val;\\n    }\\n}\\n\\n/*\\n\\n\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363388,
                "title": "my-java-answer",
                "content": "\\n    int cusMaxSize = 0;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public CustomStack(int maxSize) {\\n        cusMaxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < cusMaxSize){\\n            stack.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.isEmpty() ? -1 : stack.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> holder = new Stack<Integer>();\\n        int addLimit = k > cusMaxSize ? cusMaxSize : k;\\n        \\n        int ctr=stack.size();\\n        while(!stack.isEmpty()){\\n            holder.push(stack.pop() + (ctr <= addLimit ? val : 0));    \\n            ctr--;\\n        }\\n        \\n        while(!holder.isEmpty()){\\n            stack.push(holder.pop());\\n        }\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int cusMaxSize = 0;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public CustomStack(int maxSize) {\\n        cusMaxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < cusMaxSize){\\n            stack.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.isEmpty() ? -1 : stack.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> holder = new Stack<Integer>();\\n        int addLimit = k > cusMaxSize ? cusMaxSize : k;\\n        \\n        int ctr=stack.size();\\n        while(!stack.isEmpty()){\\n            holder.push(stack.pop() + (ctr <= addLimit ? val : 0));    \\n            ctr--;\\n        }\\n        \\n        while(!holder.isEmpty()){\\n            stack.push(holder.pop());\\n        }\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1363137,
                "title": "stack-implementation-using-array-easy-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int arr[1000];\\n    int top = 0;\\n    int max = 0;\\n    CustomStack(int maxSize) {\\n        max = maxSize; \\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top] = x;\\n            top = top+1;\\n            \\n           \\n        }\\n        \\n    }\\n    \\n    int pop() {\\n       if(top>0)\\n       {\\n           top = top-1;\\n           return arr[top];\\n       }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k<top)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int arr[1000];\\n    int top = 0;\\n    int max = 0;\\n    CustomStack(int maxSize) {\\n        max = maxSize; \\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top] = x;\\n            top = top+1;\\n            \\n           \\n        }\\n        \\n    }\\n    \\n    int pop() {\\n       if(top>0)\\n       {\\n           top = top-1;\\n           return arr[top];\\n       }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k<top)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1330699,
                "title": "c-easy-to-understand-array",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int max = 0;\\n    int arr[1000];\\n    int top=0;\\n    CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top>0)\\n        {\\n            int ret = arr[--top];\\n            arr[top]=0;\\n            return ret;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top>k)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] +=val;\\n            }\\n        }\\n    }\\n};\\n```\\nPlease upto if you find it useful.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int max = 0;\\n    int arr[1000];\\n    int top=0;\\n    CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top>0)\\n        {\\n            int ret = arr[--top];\\n            arr[top]=0;\\n            return ret;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top>k)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] +=val;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265421,
                "title": "python3-very-easy-to-understand-o-1-faster-than-94",
                "content": "Just add a pair and update accordingly. For the preceding indices, add the val to previous when you pop. \\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.max=maxSize\\n        self.ini=0\\n        self.stack=[]\\n\\n    def push(self, x: int) -> None:\\n        if self.ini<self.max:\\n            self.stack.append([x,0])\\n            self.ini+=1\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        k=self.stack.pop()\\n        if len(self.stack)>0:\\n            self.stack[-1][1]+=k[1]\\n        self.ini-=1\\n        return k[0]+k[1]\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(len(self.stack)-1,k-1)][1]+=val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.max=maxSize\\n        self.ini=0\\n        self.stack=[]\\n\\n    def push(self, x: int) -> None:\\n        if self.ini<self.max:\\n            self.stack.append([x,0])\\n            self.ini+=1\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        k=self.stack.pop()\\n        if len(self.stack)>0:\\n            self.stack[-1][1]+=k[1]\\n        self.ini-=1\\n        return k[0]+k[1]\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(len(self.stack)-1,k-1)][1]+=val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263425,
                "title": "java-ac-solution",
                "content": "```\\nclass CustomStack {\\n    ArrayList<Integer> stack = new ArrayList();\\n    int max=0;\\n    public CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < max){\\n            stack.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.size() == 0 ? -1 : stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0;i < stack.size() && i < k;i++){\\n            stack.set(i,stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    ArrayList<Integer> stack = new ArrayList();\\n    int max=0;\\n    public CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < max){\\n            stack.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.size() == 0 ? -1 : stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0;i < stack.size() && i < k;i++){\\n            stack.set(i,stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258510,
                "title": "c-solution-in-o-1-time",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> original_val_;\\n    vector<int> inc_val_;\\n    int size_;\\n    \\n    \\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(original_val_.size() == size_) return;\\n        \\n        original_val_.push_back(x);\\n        inc_val_.push_back(0);\\n}\\n    \\n    int pop() {\\n        if(original_val_.empty()) return -1;\\n        \\n        int last = original_val_.back() + inc_val_.back();\\n        \\n        //Transfer to previous\\n        if(original_val_.size() > 1){\\n            inc_val_[inc_val_.size() -2] += inc_val_.back();\\n        }\\n        //pop\\n        original_val_.pop_back();\\n        inc_val_.pop_back();\\n        \\n        return last;\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        int n = original_val_.size();\\n        \\n        if(n==0) return;\\n        inc_val_[min(k,n)-1] +=val;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> original_val_;\\n    vector<int> inc_val_;\\n    int size_;\\n    \\n    \\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(original_val_.size() == size_) return;\\n        \\n        original_val_.push_back(x);\\n        inc_val_.push_back(0);\\n}\\n    \\n    int pop() {\\n        if(original_val_.empty()) return -1;\\n        \\n        int last = original_val_.back() + inc_val_.back();\\n        \\n        //Transfer to previous\\n        if(original_val_.size() > 1){\\n            inc_val_[inc_val_.size() -2] += inc_val_.back();\\n        }\\n        //pop\\n        original_val_.pop_back();\\n        inc_val_.pop_back();\\n        \\n        return last;\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        int n = original_val_.size();\\n        \\n        if(n==0) return;\\n        inc_val_[min(k,n)-1] +=val;\\n        \\n        \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1258465,
                "title": "c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> custom_Stack_;\\n    int size_;\\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    //O(1)\\n    void push(int x) {\\n        if(custom_Stack_.size() == size_) return ;\\n        else custom_Stack_.push_back(x);\\n    }\\n    //O(1)\\n    int pop() {\\n        if(custom_Stack_.empty()) return -1;\\n        \\n        int last = custom_Stack_.back();\\n        custom_Stack_.pop_back();\\n        return last;\\n        }\\n    //O(k)\\n    void increment(int k, int val) {\\n        int n = custom_Stack_.size();\\n        for(int i = 0; i < min(n,k); i++){\\n            custom_Stack_[i]+=val;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> custom_Stack_;\\n    int size_;\\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    //O(1)\\n    void push(int x) {\\n        if(custom_Stack_.size() == size_) return ;\\n        else custom_Stack_.push_back(x);\\n    }\\n    //O(1)\\n    int pop() {\\n        if(custom_Stack_.empty()) return -1;\\n        \\n        int last = custom_Stack_.back();\\n        custom_Stack_.pop_back();\\n        return last;\\n        }\\n    //O(k)\\n    void increment(int k, int val) {\\n        int n = custom_Stack_.size();\\n        for(int i = 0; i < min(n,k); i++){\\n            custom_Stack_[i]+=val;\\n        }\\n        \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1257648,
                "title": "python3-solution-using-lazy-update",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.size=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.size:\\n            self.stack.append([x,0]) # second value contain lazy update\\n\\n    def pop(self) -> int:\\n        if len(self.stack)>0:\\n            x=self.stack.pop()\\n            if len(self.stack)>0:\\n                self.stack[-1][1]+=x[1] # propagate lazy update to below elements\\n            return x[0]+x[1] # return updated value\\n        else:\\n            return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack)>0:\\n            self.stack[min(k-1,len(self.stack)-1)][1]+=val  # pile up lazy update\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.size=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.size:\\n            self.stack.append([x,0]) # second value contain lazy update\\n\\n    def pop(self) -> int:\\n        if len(self.stack)>0:\\n            x=self.stack.pop()\\n            if len(self.stack)>0:\\n                self.stack[-1][1]+=x[1] # propagate lazy update to below elements\\n            return x[0]+x[1] # return updated value\\n        else:\\n            return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack)>0:\\n            self.stack[min(k-1,len(self.stack)-1)][1]+=val  # pile up lazy update\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248210,
                "title": "c-solution-using-one-vector",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int,int> >st;\\n    int size;\\n    int top=0;\\n    CustomStack(int maxSize)\\n    {\\n        size=maxSize;\\n        st.resize(size+1,make_pair(0,0));\\n    }\\n    \\n    void push(int x)\\n    {\\n        if(top<size)\\n        {\\n            st[++top]=make_pair(x,0);    \\n            \\n        }\\n    }\\n    \\n    int pop()\\n    {\\n        if(top!=0)\\n        {\\n          int x=st[top].first;\\n          int y=st[top].second;\\n          x+=y;\\n          top--;\\n          st[top].second+=y;\\n          return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val)\\n    {\\n        int in=top;\\n         if(top>=k)\\n         {\\n             in=k;\\n         }\\n         else\\n         {\\n            in=top; \\n         }\\n        st[in].second+=val;\\n    }\\n};\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int,int> >st;\\n    int size;\\n    int top=0;\\n    CustomStack(int maxSize)\\n    {\\n        size=maxSize;\\n        st.resize(size+1,make_pair(0,0));\\n    }\\n    \\n    void push(int x)\\n    {\\n        if(top<size)\\n        {\\n            st[++top]=make_pair(x,0);    \\n            \\n        }\\n    }\\n    \\n    int pop()\\n    {\\n        if(top!=0)\\n        {\\n          int x=st[top].first;\\n          int y=st[top].second;\\n          x+=y;\\n          top--;\\n          st[top].second+=y;\\n          return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val)\\n    {\\n        int in=top;\\n         if(top>=k)\\n         {\\n             in=k;\\n         }\\n         else\\n         {\\n            in=top; \\n         }\\n        st[in].second+=val;\\n    }\\n};\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226320,
                "title": "java-with-own-custom-stack",
                "content": "```\\nclass CustomStack {\\n    \\n\\tprivate int[] stack;\\n\\tprivate int i;\\n\\n\\tpublic CustomStack(int maxSize) {\\n\\t\\tstack = new int[maxSize];\\n\\t\\ti = 0;\\n\\t}\\n\\n\\tpublic void push(int x) {\\n\\t\\tif (i < stack.length) {\\n\\t\\t\\tstack[i++] = x;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\tif (i > 0) {\\n\\t\\t\\treturn stack[--i];\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic void increment(int k, int val) {\\n\\t\\tfor (int j = 0; j < k && j < i; j++) {\\n\\t\\t\\tstack[j] = stack[j] + val;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n\\tprivate int[] stack;\\n\\tprivate int i;\\n\\n\\tpublic CustomStack(int maxSize) {\\n\\t\\tstack = new int[maxSize];\\n\\t\\ti = 0;\\n\\t}\\n\\n\\tpublic void push(int x) {\\n\\t\\tif (i < stack.length) {\\n\\t\\t\\tstack[i++] = x;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\tif (i > 0) {\\n\\t\\t\\treturn stack[--i];\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic void increment(int k, int val) {\\n\\t\\tfor (int j = 0; j < k && j < i; j++) {\\n\\t\\t\\tstack[j] = stack[j] + val;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205393,
                "title": "java-simple-solution-using-arraylist",
                "content": "```\\nclass CustomStack {\\n\\n    List<Integer>stack;\\n    int sizz;\\n    public CustomStack(int maxSize) {\\n        stack = new ArrayList<>(maxSize);\\n        sizz = maxSize ;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < sizz) stack.add(x);\\n    }\\n    \\n    public int pop() {\\n        if(stack.isEmpty()) return -1;\\n        else return stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n      for(int i = 0; i < k && i < stack.size() ;++i )\\n          stack.set(i, stack.get(i) + val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    List<Integer>stack;\\n    int sizz;\\n    public CustomStack(int maxSize) {\\n        stack = new ArrayList<>(maxSize);\\n        sizz = maxSize ;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < sizz) stack.add(x);\\n    }\\n    \\n    public int pop() {\\n        if(stack.isEmpty()) return -1;\\n        else return stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n      for(int i = 0; i < k && i < stack.size() ;++i )\\n          stack.set(i, stack.get(i) + val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184211,
                "title": "java-runtime-faster-than-98-using-array",
                "content": "```\\nclass CustomStack {\\n\\n    private int[] stack;\\n    private int stackHead;\\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.stackHead = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(stackHead+1 < stack.length){\\n            stackHead++;\\n            stack[stackHead] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stackHead == -1){\\n            return stackHead;\\n        }\\n        int val = stack[stackHead];\\n        stackHead--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<=stackHead && i<k; i++){\\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```\\n\\nSugessions are always welcome..",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    private int[] stack;\\n    private int stackHead;\\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.stackHead = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(stackHead+1 < stack.length){\\n            stackHead++;\\n            stack[stackHead] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stackHead == -1){\\n            return stackHead;\\n        }\\n        int val = stack[stackHead];\\n        stackHead--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<=stackHead && i<k; i++){\\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173491,
                "title": "got-the-tc-down-from-o-k-every-increment-down-to-o-1",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            val, inc = self.arr.pop()\\n            if self.arr:\\n                self.arr[-1][-1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.arr) == 0:\\n            return\\n        self.arr[min(k, len(self.arr)) - 1][-1] += val\\n\\n\\n```\\n\\n\\nBrute force solution\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            return self.arr.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))):\\n            self.arr[i] += val\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            val, inc = self.arr.pop()\\n            if self.arr:\\n                self.arr[-1][-1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.arr) == 0:\\n            return\\n        self.arr[min(k, len(self.arr)) - 1][-1] += val\\n\\n\\n```\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            return self.arr.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))):\\n            self.arr[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162969,
                "title": "basic-and-optimal-solution-python",
                "content": "**Optimal solution:**\\n```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\tself.inc = []\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\t\\tself.inc.append(0)\\n\\ndef pop(self):\\n\\tif not self.s:\\n\\t\\treturn -1\\n\\tif len(self.s) > 1:\\n\\t\\tself.inc[-2] += self.inc[-1]\\n\\treturn self.s.pop() + self.inc.pop()\\n\\ndef increment(self, k, val):\\n\\tif self.s:\\n\\t\\tif k < len(self.s):\\n\\t\\t\\tself.inc[k - 1] += val\\n\\t\\telse:\\n\\t\\t\\tself.inc[-1] += val\\n```\\n\\n**Basic solution:**\\n```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\ndef pop(self):\\n\\treturn self.s.pop() if self.s else -1\\n\\ndef increment(self, k, val):\\n\\tn = min(k, len(self.s))\\n\\tfor i in range(n):\\n\\t\\tself.s[i] += val\\n```",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\tself.inc = []\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\t\\tself.inc.append(0)\\n\\ndef pop(self):\\n\\tif not self.s:\\n\\t\\treturn -1\\n\\tif len(self.s) > 1:\\n\\t\\tself.inc[-2] += self.inc[-1]\\n\\treturn self.s.pop() + self.inc.pop()\\n\\ndef increment(self, k, val):\\n\\tif self.s:\\n\\t\\tif k < len(self.s):\\n\\t\\t\\tself.inc[k - 1] += val\\n\\t\\telse:\\n\\t\\t\\tself.inc[-1] += val\\n```\n```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\ndef pop(self):\\n\\treturn self.s.pop() if self.s else -1\\n\\ndef increment(self, k, val):\\n\\tn = min(k, len(self.s))\\n\\tfor i in range(n):\\n\\t\\tself.s[i] += val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1159636,
                "title": "python3-simple-efficient-solution",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.maxSize:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if len(self.stack):\\n            return self.stack.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack):\\n            for i in range(min(k,len(self.stack))):\\n                self.stack[i]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.maxSize:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if len(self.stack):\\n            return self.stack.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack):\\n            for i in range(min(k,len(self.stack))):\\n                self.stack[i]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)",
                "codeTag": "Java"
            },
            {
                "id": 1137268,
                "title": "java-easy-solution-stack-basics",
                "content": "```\\nclass CustomStack {\\n   int top=0;\\n   int size=0;\\n   int arr[]=null;\\n    public CustomStack(int maxSize) {\\n        size=maxSize;\\n        arr=new int[maxSize];\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n          arr[top]=x;\\n          top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n      return arr[--top];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k;i++){\\n          if(i<top){\\n            arr[i]=arr[i]+val;\\n          }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n   int top=0;\\n   int size=0;\\n   int arr[]=null;\\n    public CustomStack(int maxSize) {\\n        size=maxSize;\\n        arr=new int[maxSize];\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n          arr[top]=x;\\n          top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n      return arr[--top];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k;i++){\\n          if(i<top){\\n            arr[i]=arr[i]+val;\\n          }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131752,
                "title": "java-easy-solution",
                "content": "```\\nclass CustomStack {\\n    int size = 0,top=0;\\n   int[] arr = null;\\n    public CustomStack(int maxSize) {\\n        arr=new int[maxSize];\\n        size=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n            //++top;\\n            arr[top++]=x;\\n           \\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n        \\n        return arr[--top];\\n            \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int curr=0;\\n        if(arr.length==0) return;\\n        while(curr<k && curr<arr.length){\\n            arr[curr]+=val;\\n            curr++;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int size = 0,top=0;\\n   int[] arr = null;\\n    public CustomStack(int maxSize) {\\n        arr=new int[maxSize];\\n        size=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n            //++top;\\n            arr[top++]=x;\\n           \\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n        \\n        return arr[--top];\\n            \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int curr=0;\\n        if(arr.length==0) return;\\n        while(curr<k && curr<arr.length){\\n            arr[curr]+=val;\\n            curr++;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124169,
                "title": "my-simple-python-solution",
                "content": "\\'\\'\\'\\n\\t\\n\\tclass CustomStack:\\n\\n\\t\\tdef __init__(self, maxSize: int):\\n\\t\\t\\tself.maxSize = maxSize\\n\\t\\t\\tself.stack = []\\n\\n\\t\\tdef push(self, x: int) -> None:\\n\\t\\t\\tif len(self.stack) < self.maxSize:\\n\\t\\t\\t\\tself.stack.append(x)\\n\\n\\t\\tdef pop(self) -> int:\\n\\t\\t\\tif len(self.stack) > 0:\\n\\t\\t\\t\\tthing_to_return = self.stack[-1]\\n\\t\\t\\t\\tself.stack.pop()\\n\\t\\t\\t\\treturn thing_to_return\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\tdef increment(self, k: int, val: int) -> None:  # for first k items + val to them\\n\\t\\t\\tif k > len(self.stack):\\n\\t\\t\\t\\tk = len(self.stack)  # if k > than make k the same, it will increment all in stack but won\\'t go out of range\\n\\n\\t\\t\\tfor i in range(0, k):\\n\\t\\t\\t\\tself.stack[i] += val\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\t\\n\\tclass CustomStack:\\n\\n\\t\\tdef __init__(self, maxSize: int):\\n\\t\\t\\tself.maxSize = maxSize\\n\\t\\t\\tself.stack = []\\n\\n\\t\\tdef push(self, x: int) -> None:\\n\\t\\t\\tif len(self.stack) < self.maxSize:\\n\\t\\t\\t\\tself.stack.append(x)\\n\\n\\t\\tdef pop(self) -> int:\\n\\t\\t\\tif len(self.stack) > 0:\\n\\t\\t\\t\\tthing_to_return = self.stack[-1]\\n\\t\\t\\t\\tself.stack.pop()\\n\\t\\t\\t\\treturn thing_to_return\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\tdef increment(self, k: int, val: int) -> None:  # for first k items + val to them\\n\\t\\t\\tif k > len(self.stack):\\n\\t\\t\\t\\tk = len(self.stack)  # if k > than make k the same, it will increment all in stack but won\\'t go out of range\\n\\n\\t\\t\\tfor i in range(0, k):\\n\\t\\t\\t\\tself.stack[i] += val\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1103612,
                "title": "swift-100ms-beats-100-easy-solution",
                "content": "```swift\\n// in the worst scenarios, we are calling storage.count which is an O(n) operation\\n// you could argue if that is constant, given that we know `maxSize`\\nfinal class CustomStack {\\n    \\n    private let maxSize: Int\\n    private var _storage: [Int]\\n\\n    init(_ maxSize: Int) {\\n        self.maxSize = maxSize\\n        _storage = []\\n        _storage.reserveCapacity(maxSize)\\n    }\\n    // O(n) where n = maxSize\\n    func push(_ x: Int) {\\n        guard _storage.count < maxSize else { return }\\n        _storage.append(x)\\n    }\\n    // O(1)\\n    func pop() -> Int {\\n        guard let popped = _storage.popLast() else { return -1 }\\n        return popped\\n    }\\n    // O(n) where n = maxSize \\n    func increment(_ k: Int, _ val: Int) {\\n        let K = min(k, _storage.count)\\n        for i in 0..<K {\\n            _storage[i] += val\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\n// in the worst scenarios, we are calling storage.count which is an O(n) operation\\n// you could argue if that is constant, given that we know `maxSize`\\nfinal class CustomStack {\\n    \\n    private let maxSize: Int\\n    private var _storage: [Int]\\n\\n    init(_ maxSize: Int) {\\n        self.maxSize = maxSize\\n        _storage = []\\n        _storage.reserveCapacity(maxSize)\\n    }\\n    // O(n) where n = maxSize\\n    func push(_ x: Int) {\\n        guard _storage.count < maxSize else { return }\\n        _storage.append(x)\\n    }\\n    // O(1)\\n    func pop() -> Int {\\n        guard let popped = _storage.popLast() else { return -1 }\\n        return popped\\n    }\\n    // O(n) where n = maxSize \\n    func increment(_ k: Int, _ val: Int) {\\n        let K = min(k, _storage.count)\\n        for i in 0..<K {\\n            _storage[i] += val\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050030,
                "title": "simple-java-easy-understanding",
                "content": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int index;\\n   \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<stack.length){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index == 0) return;\\n        for(int i = 0; i<k && i<index;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int index;\\n   \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<stack.length){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index == 0) return;\\n        for(int i = 0; i<k && i<index;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049998,
                "title": "c-o-1",
                "content": "```\\nclass CustomStack {\\nprivate:\\n    vector<int>stack,inc;\\n    int n;\\npublic:\\n    CustomStack(int maxSize):n(maxSize) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(n==stack.size())\\n            return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n    \\n    int pop() {\\n        int i=stack.size()-1;\\n        if(i<0)\\n        {\\n            return -1;\\n        }\\n        if(i>0)\\n        {\\n            inc[i-1]+=inc[i];\\n        }\\n        int res=stack[i]+inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size())-1;\\n        if(i>=0)\\n        {\\n            inc[i]+=val;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\nprivate:\\n    vector<int>stack,inc;\\n    int n;\\npublic:\\n    CustomStack(int maxSize):n(maxSize) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(n==stack.size())\\n            return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n    \\n    int pop() {\\n        int i=stack.size()-1;\\n        if(i<0)\\n        {\\n            return -1;\\n        }\\n        if(i>0)\\n        {\\n            inc[i-1]+=inc[i];\\n        }\\n        int res=stack[i]+inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size())-1;\\n        if(i>=0)\\n        {\\n            inc[i]+=val;\\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1042120,
                "title": "python-3-lazy-increment-w-o-extra-array",
                "content": "A lazy increment approach, without using another \"shadow\" array/list to keep track of increments.\\nBecause in some cases that would be a waste of memory when the stack size is huge.\\nInstead, only use a dictionay to record increment events.\\n\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self._max_size = maxSize\\n        self._data = []\\n        self._curr_incr = 0\\n        self._incr_dict = defaultdict(int)\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self._data) == self._max_size:\\n            return\\n        if self._curr_incr != 0:\\n            self._incr_dict[len(self._data)] += self._curr_incr\\n            self._curr_incr = 0\\n        self._data.append(x)\\n\\n    def pop(self) -> int:\\n        if not self._data:\\n            return -1\\n        curr_size = len(self._data)\\n        if curr_size in self._incr_dict:\\n            self._curr_incr += self._incr_dict[curr_size]\\n            del self._incr_dict[curr_size]\\n        res = self._data.pop() + self._curr_incr\\n        if not self._data:\\n            self._curr_incr = 0\\n        return res\\n\\n    def increment(self, k: int, val: int) -> None:\\n        k = min(k, len(self._data))\\n        if k == 0:\\n            return\\n        self._incr_dict[k] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self._max_size = maxSize\\n        self._data = []\\n        self._curr_incr = 0\\n        self._incr_dict = defaultdict(int)\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self._data) == self._max_size:\\n            return\\n        if self._curr_incr != 0:\\n            self._incr_dict[len(self._data)] += self._curr_incr\\n            self._curr_incr = 0\\n        self._data.append(x)\\n\\n    def pop(self) -> int:\\n        if not self._data:\\n            return -1\\n        curr_size = len(self._data)\\n        if curr_size in self._incr_dict:\\n            self._curr_incr += self._incr_dict[curr_size]\\n            del self._incr_dict[curr_size]\\n        res = self._data.pop() + self._curr_incr\\n        if not self._data:\\n            self._curr_incr = 0\\n        return res\\n\\n    def increment(self, k: int, val: int) -> None:\\n        k = min(k, len(self._data))\\n        if k == 0:\\n            return\\n        self._incr_dict[k] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020986,
                "title": "python3-simple-solution",
                "content": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if self.stack:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n    def increment(self, k: int, val: int) -> None:\\n        for i,j in enumerate(self.stack[:k]):\\n            self.stack[i] += val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if self.stack:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n    def increment(self, k: int, val: int) -> None:\\n        for i,j in enumerate(self.stack[:k]):\\n            self.stack[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999867,
                "title": "c-o-1-solution-faster-than-97",
                "content": "```\\nclass CustomStack {\\npublic:\\n    \\n    vector<int>incr;\\n    vector<int>st;\\n    int i = -1;\\n    CustomStack(int N) {\\n        incr.resize(N);\\n        fill(incr.begin(),incr.end(),0);\\n        st.resize(N);\\n        fill(st.begin(),st.end(),0);\\n    }\\n    \\n    void push(int x) {\\n        int y = st.size() -1;\\n        if (i < y){\\n            st[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i<0)return -1;\\n        int x = st[i] + incr[i];\\n\\t\\t//incr works like reverse prefix sum. As pop operations are called, incr[i] keeps attaining its correct value\\n        if(i>0)\\n        \\tincr[i-1] += incr[i];\\n        incr[i]=0;\\n        i--;\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k = min(k-1,i);\\n        if(k>=0)\\n        \\tincr[k]+=val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    \\n    vector<int>incr;\\n    vector<int>st;\\n    int i = -1;\\n    CustomStack(int N) {\\n        incr.resize(N);\\n        fill(incr.begin(),incr.end(),0);\\n        st.resize(N);\\n        fill(st.begin(),st.end(),0);\\n    }\\n    \\n    void push(int x) {\\n        int y = st.size() -1;\\n        if (i < y){\\n            st[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i<0)return -1;\\n        int x = st[i] + incr[i];\\n\\t\\t//incr works like reverse prefix sum. As pop operations are called, incr[i] keeps attaining its correct value\\n        if(i>0)\\n        \\tincr[i-1] += incr[i];\\n        incr[i]=0;\\n        i--;\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k = min(k-1,i);\\n        if(k>=0)\\n        \\tincr[k]+=val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977212,
                "title": "javascript-solution-o-1-all-methods",
                "content": "Time complexity: O(1) for push, pop, increment.\\nSpace complexity: O(N)\\n```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n    this.incrementDP = new Array(maxSize);\\n    this.incrementDP.fill(0);\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.maxSize) {\\n      this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (!this.stack.length) return -1;\\n    let result = this.stack.pop();\\n    const length = this.stack.length;\\n    if (this.incrementDP[length]) {\\n      result += this.incrementDP[length];\\n      if (length > 0) {\\n        this.incrementDP[length - 1] += this.incrementDP[length]\\n      }\\n      this.incrementDP[length] = 0;\\n    }\\n    return result;\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const t = Math.min(k, this.stack.length);\\n    this.incrementDP[t - 1] += val;\\n};\\n\\n/** \\n * Your CustomStack object will be instantiated and called as such:\\n * var obj = new CustomStack(maxSize)\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * obj.increment(k,val)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n    this.incrementDP = new Array(maxSize);\\n    this.incrementDP.fill(0);\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.maxSize) {\\n      this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (!this.stack.length) return -1;\\n    let result = this.stack.pop();\\n    const length = this.stack.length;\\n    if (this.incrementDP[length]) {\\n      result += this.incrementDP[length];\\n      if (length > 0) {\\n        this.incrementDP[length - 1] += this.incrementDP[length]\\n      }\\n      this.incrementDP[length] = 0;\\n    }\\n    return result;\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const t = Math.min(k, this.stack.length);\\n    this.incrementDP[t - 1] += val;\\n};\\n\\n/** \\n * Your CustomStack object will be instantiated and called as such:\\n * var obj = new CustomStack(maxSize)\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * obj.increment(k,val)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945413,
                "title": "java-solution",
                "content": "```\\nclass CustomStack {\\n    private int[] array;\\n    private int size;\\n\\n    public CustomStack(int maxSize) {\\n        this.array = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (size < array.length) {\\n            array[size++] = x;            \\n        }\\n    }\\n    \\n    public int pop() {\\n        return size > 0 ? array[--size] : -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0 ; i < Math.min(k, size) ; i++) {\\n            array[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    private int[] array;\\n    private int size;\\n\\n    public CustomStack(int maxSize) {\\n        this.array = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (size < array.length) {\\n            array[size++] = x;            \\n        }\\n    }\\n    \\n    public int pop() {\\n        return size > 0 ? array[--size] : -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0 ; i < Math.min(k, size) ; i++) {\\n            array[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894044,
                "title": "java-3ms-100-faster-o-1-timecomplexity",
                "content": "```\\n    int[] increments;\\n    int[] stack;\\n    int stackIndex = -1;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        increments = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (stackIndex < stack.length -1)\\n        {\\n            stack[++stackIndex] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (stackIndex < 0) return -1;\\n        int x = stack[stackIndex] + increments[stackIndex];\\n        if (stackIndex > 0)\\n        {\\n            increments[stackIndex -1] = increments[stackIndex -1] + increments[stackIndex];\\n        }\\n         increments[stackIndex] = 0;\\n        stackIndex--;\\n         return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(k -1,stackIndex);\\n        if (k >=0)\\n        increments[k] += val;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int[] increments;\\n    int[] stack;\\n    int stackIndex = -1;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        increments = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (stackIndex < stack.length -1)\\n        {\\n            stack[++stackIndex] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (stackIndex < 0) return -1;\\n        int x = stack[stackIndex] + increments[stackIndex];\\n        if (stackIndex > 0)\\n        {\\n            increments[stackIndex -1] = increments[stackIndex -1] + increments[stackIndex];\\n        }\\n         increments[stackIndex] = 0;\\n        stackIndex--;\\n         return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(k -1,stackIndex);\\n        if (k >=0)\\n        increments[k] += val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 884037,
                "title": "o-1-time-and-o-n-space",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        \\n        self.stack = [-float(\\'inf\\')] * maxSize\\n        self.count = 0\\n        self.maxsize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        \\n        if(self.count < self.maxsize ):\\n            self.stack[self.count] = x\\n            self.count +=1\\n        \\n\\n    def pop(self) -> int:\\n        \\n    \\n        if(self.count - 1 >= 0):\\n            \\n            el = self.stack[self.count-1]\\n            self.count -=1\\n            \\n            return el\\n        \\n        return -1\\n            \\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        \\n        for i in range(min(k,self.count)):\\n            self.stack[i] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        \\n        self.stack = [-float(\\'inf\\')] * maxSize\\n        self.count = 0\\n        self.maxsize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        \\n        if(self.count < self.maxsize ):\\n            self.stack[self.count] = x\\n            self.count +=1\\n        \\n\\n    def pop(self) -> int:\\n        \\n    \\n        if(self.count - 1 >= 0):\\n            \\n            el = self.stack[self.count-1]\\n            self.count -=1\\n            \\n            return el\\n        \\n        return -1\\n            \\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        \\n        for i in range(min(k,self.count)):\\n            self.stack[i] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881547,
                "title": "python3-customstack-design-with-o-1-operation-time-o-n-space",
                "content": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.increament_at = collections.defaultdict(lambda: 0)\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.max_size:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n    \\n        tmp = self.increament_at[len(self.stack) - 1]\\n        self.increament_at[len(self.stack) - 2] += tmp\\n        self.increament_at[len(self.stack) - 1] = 0\\n        return self.stack.pop() + tmp\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack) < k:\\n            self.increament_at[len(self.stack) - 1] += val\\n        else:\\n            self.increament_at[k-1] += val\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.increament_at = collections.defaultdict(lambda: 0)\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.max_size:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n    \\n        tmp = self.increament_at[len(self.stack) - 1]\\n        self.increament_at[len(self.stack) - 2] += tmp\\n        self.increament_at[len(self.stack) - 1] = 0\\n        return self.stack.pop() + tmp\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack) < k:\\n            self.increament_at[len(self.stack) - 1] += val\\n        else:\\n            self.increament_at[k-1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862963,
                "title": "straightforward-double-linkedlist",
                "content": "```\\nclass CustomStack {\\n    \\n    ListNode head;\\n    ListNode tail;\\n    int size;\\n    int max;\\n\\n    public CustomStack(int maxSize) {\\n        \\n        head = new ListNode(-1);\\n        tail = new ListNode(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n        size = 0;\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(size == max) return;\\n        \\n        ListNode first = head.next;\\n        ListNode pushed_in = new ListNode(x);\\n        head.next = pushed_in;\\n        pushed_in.next = first;\\n        first.prev = pushed_in;\\n        pushed_in.prev = head;\\n        size++;\\n    }\\n    \\n    public int pop() {\\n        \\n        if(size == 0)   return -1;\\n        ListNode first = head.next;\\n        ListNode second = first.next;\\n        head.next = second;\\n        second.prev = head;\\n        size--;\\n        \\n        return first.val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        ListNode curr = tail.prev;\\n        int i = 0;\\n        while(curr != head && i < Math.min(k, size))\\n        {\\n            curr.addVal(val);\\n            curr = curr.prev;\\n            i++;\\n        }\\n    }\\n}\\n\\nclass ListNode {\\n    \\n    int val;\\n    ListNode prev;\\n    ListNode next;\\n    \\n    public ListNode(int val) {\\n        \\n        this.val = val;\\n        this.prev = null;\\n        this.next = null;\\n    }\\n    \\n    public void addVal(int increment) {\\n        \\n        this.val += increment;\\n    } \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    \\n    ListNode head;\\n    ListNode tail;\\n    int size;\\n    int max;\\n\\n    public CustomStack(int maxSize) {\\n        \\n        head = new ListNode(-1);\\n        tail = new ListNode(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n        size = 0;\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(size == max) return;\\n        \\n        ListNode first = head.next;\\n        ListNode pushed_in = new ListNode(x);\\n        head.next = pushed_in;\\n        pushed_in.next = first;\\n        first.prev = pushed_in;\\n        pushed_in.prev = head;\\n        size++;\\n    }\\n    \\n    public int pop() {\\n        \\n        if(size == 0)   return -1;\\n        ListNode first = head.next;\\n        ListNode second = first.next;\\n        head.next = second;\\n        second.prev = head;\\n        size--;\\n        \\n        return first.val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        ListNode curr = tail.prev;\\n        int i = 0;\\n        while(curr != head && i < Math.min(k, size))\\n        {\\n            curr.addVal(val);\\n            curr = curr.prev;\\n            i++;\\n        }\\n    }\\n}\\n\\nclass ListNode {\\n    \\n    int val;\\n    ListNode prev;\\n    ListNode next;\\n    \\n    public ListNode(int val) {\\n        \\n        this.val = val;\\n        this.prev = null;\\n        this.next = null;\\n    }\\n    \\n    public void addVal(int increment) {\\n        \\n        this.val += increment;\\n    } \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827087,
                "title": "ruby-all-ops-o-1-100",
                "content": "If we update the corresponging elements in stacks whenever increment(k, val) methos is call, thats gonna take O(k) time. Instead we can keep a hashmap of index k with the value it needs to increment with bottom k stack elements. This value can be added to the stack element whenever it is popped out. and the same valy can be propagated to lower elements\\n\\n```\\nclass CustomStack\\n    \\n    attr_accessor :stack, :hash, :max_size\\n=begin\\n    :type max_size: Integer\\n=end\\n    def initialize(max_size)\\n        self.stack = []\\n        self.hash = Hash.new(0)\\n        self.max_size = max_size\\n    end\\n\\n\\n=begin\\n    :type x: Integer\\n    :rtype: Void\\n=end\\n    def push(x)\\n        if stack.size < max_size\\n            stack.push(x)\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def pop()\\n        if stack.empty?\\n            return -1\\n        else\\n            increment_val = 0\\n            if hash[stack.size] > 0\\n                increment_val += hash[stack.size]\\n                hash.delete(stack.size)\\n                hash[stack.size-1] += increment_val\\n            end\\n            stack.pop + increment_val\\n        end\\n    end\\n\\n\\n=begin\\n    :type k: Integer\\n    :type val: Integer\\n    :rtype: Void\\n=end\\n    def increment(k, val)\\n        return if stack.empty?\\n        k = [k, stack.size].min\\n        hash[k] += val\\n    end\\n\\n\\nend\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack.new(max_size)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k, val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack\\n    \\n    attr_accessor :stack, :hash, :max_size\\n=begin\\n    :type max_size: Integer\\n=end\\n    def initialize(max_size)\\n        self.stack = []\\n        self.hash = Hash.new(0)\\n        self.max_size = max_size\\n    end\\n\\n\\n=begin\\n    :type x: Integer\\n    :rtype: Void\\n=end\\n    def push(x)\\n        if stack.size < max_size\\n            stack.push(x)\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def pop()\\n        if stack.empty?\\n            return -1\\n        else\\n            increment_val = 0\\n            if hash[stack.size] > 0\\n                increment_val += hash[stack.size]\\n                hash.delete(stack.size)\\n                hash[stack.size-1] += increment_val\\n            end\\n            stack.pop + increment_val\\n        end\\n    end\\n\\n\\n=begin\\n    :type k: Integer\\n    :type val: Integer\\n    :rtype: Void\\n=end\\n    def increment(k, val)\\n        return if stack.empty?\\n        k = [k, stack.size].min\\n        hash[k] += val\\n    end\\n\\n\\nend\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack.new(max_size)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k, val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826026,
                "title": "c-all-operations-in-o-1-100",
                "content": "\\n\\nclass CustomStack {\\n\\n\\n\\npublic:\\n\\n\\t// value at top and amount by how much it should be incremented\\n    \\n\\tvector<pair<int,int>> st;\\n    \\n    int maxSize;\\n    \\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()==maxSize){\\n            return;\\n        }\\n        st.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(st.size()==0)\\n            return -1;\\n        int size = st.size();\\n        if(size!=1){\\n            st[size-2].second += st[size-1].second;\\n        }\\n        int val =  st[size-1].first+st[size-1].second;\\n        st.pop_back();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(st.size()==0){\\n            return;\\n        }\\n        if(st.size()>=k){\\n            st[k-1].second+=val;\\n        }else{\\n            st[st.size()-1].second+=val;\\n        }\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "\\n\\nclass CustomStack {\\n\\n\\n\\npublic:\\n\\n\\t// value at top and amount by how much it should be incremented\\n    \\n\\tvector<pair<int,int>> st;\\n    \\n    int maxSize;\\n    \\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()==maxSize){\\n            return;\\n        }\\n        st.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(st.size()==0)\\n            return -1;\\n        int size = st.size();\\n        if(size!=1){\\n            st[size-2].second += st[size-1].second;\\n        }\\n        int val =  st[size-1].first+st[size-1].second;\\n        st.pop_back();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(st.size()==0){\\n            return;\\n        }\\n        if(st.size()>=k){\\n            st[k-1].second+=val;\\n        }else{\\n            st[st.size()-1].second+=val;\\n        }\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 803496,
                "title": "ultra-simple-cpp-solution-suggestion-for-optimization-are-welcomed",
                "content": "Runtime: 600 ms, faster than 5.38% of C++ online submissions\\nMemory Usage: 21.1 MB, less than 63.83% of C++ online submissions\\n\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> v;\\n    int size=0;\\n    CustomStack(int maxSize) {\\n        \\n        size=maxSize;\\n        v.reserve(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        \\n        if(v.size()<size)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        \\n        if(v.size()==0)\\n            return -1;\\n        else\\n        {\\n            int temp=v[v.size()-1];\\n            v.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        for(int i=0;i<v.size()&&k-->0;i++)\\n            v[i]+=val;\\n        }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> v;\\n    int size=0;\\n    CustomStack(int maxSize) {\\n        \\n        size=maxSize;\\n        v.reserve(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        \\n        if(v.size()<size)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        \\n        if(v.size()==0)\\n            return -1;\\n        else\\n        {\\n            int temp=v[v.size()-1];\\n            v.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        for(int i=0;i<v.size()&&k-->0;i++)\\n            v[i]+=val;\\n        }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792756,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780735,
                "title": "java-5-ms-faster-than-91-04",
                "content": "```\\nclass CustomStack {\\n\\n    int []arr;\\n    int maxSize;\\n    int count;\\n    public CustomStack(int mSize) {\\n        maxSize = mSize;\\n        count = 0;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int a) {\\n        if(maxSize > count){\\n           arr[count++] = a; \\n        }\\n    }\\n    \\n    public int pop() {\\n        if(count > 0) {\\n            \\n            return arr[--count];\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        int m = Math.min(k, count);\\n        \\n        for(int i=0; i<m; i++){\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    int []arr;\\n    int maxSize;\\n    int count;\\n    public CustomStack(int mSize) {\\n        maxSize = mSize;\\n        count = 0;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int a) {\\n        if(maxSize > count){\\n           arr[count++] = a; \\n        }\\n    }\\n    \\n    public int pop() {\\n        if(count > 0) {\\n            \\n            return arr[--count];\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        int m = Math.min(k, count);\\n        \\n        for(int i=0; i<m; i++){\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769917,
                "title": "c-simple-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int * m_array;\\n    int m_maxSize;\\n    int m_count;\\n    \\n    CustomStack(int maxSize) : \\n        m_array(new int[maxSize]),\\n        m_maxSize(maxSize),\\n        m_count(0) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (m_count < m_maxSize) {\\n            m_array[m_count++] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = -1;\\n        if (m_count > 0) {\\n            ret = m_array[--m_count];\\n        }\\n        return ret;\\n    }\\n    \\n    void increment(int k, int val) {\\n        const int upperBound = min(m_count, k);\\n        for (int i = 0; i < upperBound; ++i) {\\n            m_array[i] += val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int * m_array;\\n    int m_maxSize;\\n    int m_count;\\n    \\n    CustomStack(int maxSize) : \\n        m_array(new int[maxSize]),\\n        m_maxSize(maxSize),\\n        m_count(0) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (m_count < m_maxSize) {\\n            m_array[m_count++] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = -1;\\n        if (m_count > 0) {\\n            ret = m_array[--m_count];\\n        }\\n        return ret;\\n    }\\n    \\n    void increment(int k, int val) {\\n        const int upperBound = min(m_count, k);\\n        for (int i = 0; i < upperBound; ++i) {\\n            m_array[i] += val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750827,
                "title": "simple-java-solution",
                "content": "class CustomStack {\\n    int stack[];\\n    int msize = 0;\\n    int ind;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];``\\n        msize = maxSize;\\n        ind = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(ind < msize-1)\\n            stack[++ind] = x;\\n    }\\n    \\n    public int pop() {\\n        if(ind == -1){\\n            return -1;\\n        }\\n        return stack[ind--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        ind++;\\n        int n = ind > k ? k:ind;\\n        for(int i=0;i<n;i++){\\n            stack[i] = stack[i]+val;\\n        }\\n        \\n        ind--;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "solutionTags": [],
                "code": "class CustomStack {\\n    int stack[];\\n    int msize = 0;\\n    int ind;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];``\\n        msize = maxSize;\\n        ind = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(ind < msize-1)\\n            stack[++ind] = x;\\n    }\\n    \\n    public int pop() {\\n        if(ind == -1){\\n            return -1;\\n        }\\n        return stack[ind--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        ind++;\\n        int n = ind > k ? k:ind;\\n        for(int i=0;i<n;i++){\\n            stack[i] = stack[i]+val;\\n        }\\n        \\n        ind--;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 726494,
                "title": "c-easiest-explained-solution-with-stack-for-beginners",
                "content": "```\\nclass CustomStack {\\n    int size;\\n    stack<int> st;\\npublic:\\n    CustomStack(int maxSize) {\\n        size=maxSize;  //initializing the size of the stack\\n    }\\n    void push(int x) {\\n        if(st.size()!=size)  //push down the element if the size of stack is less than maxsize\\n        {\\n            st.push(x);   \\n        }            \\n    }\\n    \\n    int pop() {\\n        if(st.size()==0) return -1;  //if stack size is zero then return -1\\n        int temp=st.top();  //storing top element of the stack, for returning later\\n        st.pop();  //delete the top element\\n        return temp;  //return the top element, which we saved earlier\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack <int> temp_stk;  //temporary stack for incrementing the bottom k elements\\n        \\n        while(!st.empty())  //firstly, push all elements of the stack into temporary stack \\n        {\\n            temp_stk.push(st.top());\\n            st.pop();\\n        }\\n        \\n        while(k-- && !temp_stk.empty())  //now if k>0 and any value exist in temporary stack then push it\\'s top element by incrementing the value by val.\\n        {\\n            int temp = temp_stk.top() + val;\\n            st.push(temp);\\n            temp_stk.pop();  // delete the top element of the temporary stack\\n        }\\n        \\n        if(!temp_stk.empty())  //if there exist any element means k become 0, so we will add all remaining elements as it is.\\n        {\\n            while(!temp_stk.empty())\\n            {\\n                int temp = temp_stk.top();\\n                st.push(temp);\\n                temp_stk.pop();\\n            }\\n        }\\n    }\\n};\\n```\\n**For such explained solution don\\'t forget to upvote!!!**",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    stack<int> st;\\npublic:\\n    CustomStack(int maxSize) {\\n        size=maxSize;  //initializing the size of the stack\\n    }\\n    void push(int x) {\\n        if(st.size()!=size)  //push down the element if the size of stack is less than maxsize\\n        {\\n            st.push(x);   \\n        }            \\n    }\\n    \\n    int pop() {\\n        if(st.size()==0) return -1;  //if stack size is zero then return -1\\n        int temp=st.top();  //storing top element of the stack, for returning later\\n        st.pop();  //delete the top element\\n        return temp;  //return the top element, which we saved earlier\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack <int> temp_stk;  //temporary stack for incrementing the bottom k elements\\n        \\n        while(!st.empty())  //firstly, push all elements of the stack into temporary stack \\n        {\\n            temp_stk.push(st.top());\\n            st.pop();\\n        }\\n        \\n        while(k-- && !temp_stk.empty())  //now if k>0 and any value exist in temporary stack then push it\\'s top element by incrementing the value by val.\\n        {\\n            int temp = temp_stk.top() + val;\\n            st.push(temp);\\n            temp_stk.pop();  // delete the top element of the temporary stack\\n        }\\n        \\n        if(!temp_stk.empty())  //if there exist any element means k become 0, so we will add all remaining elements as it is.\\n        {\\n            while(!temp_stk.empty())\\n            {\\n                int temp = temp_stk.top();\\n                st.push(temp);\\n                temp_stk.pop();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724217,
                "title": "java",
                "content": "```\\nclass CustomStack {\\n    int length;\\n    int stack[];\\n    public CustomStack(int maxSize) {\\n        this.length = -1;\\n        stack = new int[maxSize];\\n    }\\n    public void push(int x) {\\n        if(length < maxSize-1) {\\n            length++;\\n            stack[length] = x;\\n        }\\n        return;\\n    }\\n    public int pop() {\\n        if(length > -1) {\\n            int pop = stack[length];\\n            length--;\\n            return pop;\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) {\\n        if(k > stack.length) {\\n            for(int i = 0; i < stack.length; i++) {\\n                stack[i] += val;\\n            }\\n        } else {\\n            for(int i = k-1; i >= 0; i--) {\\n                stack[i] += val;\\n            }\\n        }   \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int length;\\n    int stack[];\\n    public CustomStack(int maxSize) {\\n        this.length = -1;\\n        stack = new int[maxSize];\\n    }\\n    public void push(int x) {\\n        if(length < maxSize-1) {\\n            length++;\\n            stack[length] = x;\\n        }\\n        return;\\n    }\\n    public int pop() {\\n        if(length > -1) {\\n            int pop = stack[length];\\n            length--;\\n            return pop;\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) {\\n        if(k > stack.length) {\\n            for(int i = 0; i < stack.length; i++) {\\n                stack[i] += val;\\n            }\\n        } else {\\n            for(int i = k-1; i >= 0; i--) {\\n                stack[i] += val;\\n            }\\n        }   \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712561,
                "title": "python-3-o-1-single-stack-with-successive-differences",
                "content": "Here\\'s my personal solution to this problem. This uses a single stack rather than two, as some other solutions presented, and all operations are O(1).\\n\\nThe idea of this algorithm is to keep the top-most value of the stack exact, then keep only successive differences with their next values in the lower values.\\n\\nHere\\'s an example:\\n\\n* `my_stack.push(5)`: `my_stack.stack == [5]`\\n* `my_stack.push(3)`: `my_stack.stack == [2, 3]`. Here, `5 = 3 + 2`.\\n* `my_stack.push(7)`: `my_stack.stack == [2, -4, 7]`. Here, `3 = 7 + (-4)`.\\n\\nWith this approach, we only have to increase the `k`-th value of the stack to increment all values between `0` and `k`, because the difference will be kept down when popping the values.\\n\\nHere\\'s the implementation:\\n\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) >= self.max_size:\\n            return\\n\\t\\t# Update the previous last value to become the difference with the new last value.\\n        if self.stack:\\n            self.stack[-1] -= x\\n        self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        val = self.stack.pop()\\n\\t\\t# Update the new last value by adding the popped value to retrieve its real value.\\n        if self.stack:\\n            self.stack[-1] += val\\n        return val\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k - 1, len(self.stack) - 1)] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) >= self.max_size:\\n            return\\n\\t\\t# Update the previous last value to become the difference with the new last value.\\n        if self.stack:\\n            self.stack[-1] -= x\\n        self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        val = self.stack.pop()\\n\\t\\t# Update the new last value by adding the popped value to retrieve its real value.\\n        if self.stack:\\n            self.stack[-1] += val\\n        return val\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k - 1, len(self.stack) - 1)] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710036,
                "title": "python-3-solution-faster-than-99-7",
                "content": "```\\ndef __init__(self, maxSize: int):\\n\\tself.stack = []\\n\\tself.size, self.limit = 0, maxSize\\n\\n\\ndef push(self, x: int) -> None:\\n\\tif self.size==self.limit:\\n\\t\\treturn\\n\\tself.stack.append([x, 0])\\n\\tself.size+=1\\n\\ndef pop(self) -> int:\\n\\tif self.size==0:\\n\\t\\treturn -1\\n\\n\\tpopped, increment = self.stack.pop()\\n\\tself.size-=1\\n\\tif self.size:\\n\\t\\tself.stack[-1][1] +=increment\\n\\n\\treturn popped+increment\\n\\ndef increment(self, k: int, val: int) -> None:\\n\\n\\tk = min(self.size, k)\\n\\tif k:\\n\\t\\tself.stack[k-1][1] +=val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef __init__(self, maxSize: int):\\n\\tself.stack = []\\n\\tself.size, self.limit = 0, maxSize\\n\\n\\ndef push(self, x: int) -> None:\\n\\tif self.size==self.limit:\\n\\t\\treturn\\n\\tself.stack.append([x, 0])\\n\\tself.size+=1\\n\\ndef pop(self) -> int:\\n\\tif self.size==0:\\n\\t\\treturn -1\\n\\n\\tpopped, increment = self.stack.pop()\\n\\tself.size-=1\\n\\tif self.size:\\n\\t\\tself.stack[-1][1] +=increment\\n\\n\\treturn popped+increment\\n\\ndef increment(self, k: int, val: int) -> None:\\n\\n\\tk = min(self.size, k)\\n\\tif k:\\n\\t\\tself.stack[k-1][1] +=val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 702921,
                "title": "python-3-lazy-increment-o-1-for-all-operations",
                "content": "In stack, we store the exact value `x`, and the addition value `dx` from the increment operation.\\n- Everytime when we `pop()`, the current top-of-stack would \"inherit\" the `dx` of the previous top-of-stack.\\n- Everytime when we `increment()`, we add that addition value to the `dx` for the correct index.\\n\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        x, dx = self.stack.pop()\\n        if self.stack:\\n            self.stack[-1][-1] += dx\\n        return x + dx\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            index = min(len(self.stack), k) - 1\\n            self.stack[index][-1] += val\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        x, dx = self.stack.pop()\\n        if self.stack:\\n            self.stack[-1][-1] += dx\\n        return x + dx\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            index = min(len(self.stack), k) - 1\\n            self.stack[index][-1] += val\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702552,
                "title": "c-very-simple-using-vectors",
                "content": "```\\n vector<int> vec;\\n    int max_size;\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(vec.size() < max_size)\\n            vec.push_back(x);\\n    }\\n    \\n    int pop() {\\n        int val= -1;\\n        if(vec.size()>0)\\n        {\\n            val = vec[vec.size()-1];\\n            vec.erase(vec.begin()+vec.size()-1);\\n        }\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int increment_count;\\n        increment_count = (k>=vec.size()? vec.size() : k);\\n        for(int i=0; i<increment_count; i++)\\n            vec[i] = vec[i]+val;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<int> vec;\\n    int max_size;\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(vec.size() < max_size)\\n            vec.push_back(x);\\n    }\\n    \\n    int pop() {\\n        int val= -1;\\n        if(vec.size()>0)\\n        {\\n            val = vec[vec.size()-1];\\n            vec.erase(vec.begin()+vec.size()-1);\\n        }\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int increment_count;\\n        increment_count = (k>=vec.size()? vec.size() : k);\\n        for(int i=0; i<increment_count; i++)\\n            vec[i] = vec[i]+val;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 614410,
                "title": "cpp-simple-easy-list-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int c=0;\\n    list<int> l;\\n    CustomStack(int maxSize) {\\n        c=maxSize;\\n        l.clear();\\n    }\\n    \\n    void push(int x) {\\n        if(l.size()<c){\\n            l.push_front(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!l.empty()){\\n            int x=l.front();\\n            l.pop_front();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        auto x=l.rbegin();\\n        while(x!=l.rend()&&k>0){\\n            *x+=val;\\n            x++;\\n            k--;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int c=0;\\n    list<int> l;\\n    CustomStack(int maxSize) {\\n        c=maxSize;\\n        l.clear();\\n    }\\n    \\n    void push(int x) {\\n        if(l.size()<c){\\n            l.push_front(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!l.empty()){\\n            int x=l.front();\\n            l.pop_front();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        auto x=l.rbegin();\\n        while(x!=l.rend()&&k>0){\\n            *x+=val;\\n            x++;\\n            k--;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570462,
                "title": "c-o-1-push-pop-and-increment-using-two-arrays",
                "content": "In this approach I used two arrays each of size maxSize. One stores the values the other one stores the increments at the k\\'th number.\\nThis approach can be further optimized by using a linked list instead of an array. Especially in scenarios where maxSize is much larger \\nthan the actual number of elements being on the stack a performance boost will be notable.\\n\\n```\\npublic class CustomStack {\\n    private int[] _arr;\\n    private int[] _inc;\\n    private int _count;\\n    \\n    public CustomStack(int maxSize) {\\n        _arr = new int[maxSize];\\n        _inc = new int[maxSize];\\n    }\\n    \\n    public void Push(int x) {\\n        if (_count >= _arr.Length)\\n            return;\\n        _arr[_count++] = x;\\n    }\\n    \\n    public int Pop() {\\n        if (_count == 0)\\n            return -1;\\n        \\n        var inc = _inc[--_count];\\n        if (_count - 1 >= 0) _inc[_count - 1] += _inc[_count];\\n        _inc[_count] = 0;\\n        \\n        return _arr[_count] + inc;\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        if (k == 0 || _count == 0) return;\\n        _inc[Math.Min(k, _count) - 1] += val;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class CustomStack {\\n    private int[] _arr;\\n    private int[] _inc;\\n    private int _count;\\n    \\n    public CustomStack(int maxSize) {\\n        _arr = new int[maxSize];\\n        _inc = new int[maxSize];\\n    }\\n    \\n    public void Push(int x) {\\n        if (_count >= _arr.Length)\\n            return;\\n        _arr[_count++] = x;\\n    }\\n    \\n    public int Pop() {\\n        if (_count == 0)\\n            return -1;\\n        \\n        var inc = _inc[--_count];\\n        if (_count - 1 >= 0) _inc[_count - 1] += _inc[_count];\\n        _inc[_count] = 0;\\n        \\n        return _arr[_count] + inc;\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        if (k == 0 || _count == 0) return;\\n        _inc[Math.Min(k, _count) - 1] += val;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557241,
                "title": "javascript-without-push-or-pop",
                "content": "I saw a few JavaScript solutions that were using .pop() and .push(). While they are available methods that really doesn\\'t show that someone in JavaScript actually knows how .push() and .pop() work. \\n\\nWhen you attempt to write a solution without those functions you\\'ll learn more about how arrays work behind the scenes:\\n\\nHere\\'s more info:\\nhttps://stackoverflow.com/questions/27386264/how-does-the-javascript-array-push-code-work-internally\\n\\nYou\\'ll note that when I add an element in .push(), I\\'m not having to adjust the .length property. Whereas when I delete an element manually I must update it. Run this in debug mode in your IDE to see why and what happens ;) It is rather interesting.\\n\\n```\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if(this.stack.length < this.maxSize) {\\n        this.stack[this.stack.length] = x;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if(this.stack.length > 0) {\\n        const retVal = this.stack[this.stack.length - 1];\\n        delete this.stack[this.stack.length - 1];\\n        this.stack.length = this.stack.length - 1;\\n        return retVal;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for(let i = 0; i < k; i++) {\\n        if(this.stack[i]) this.stack[i] = this.stack[i] + val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if(this.stack.length < this.maxSize) {\\n        this.stack[this.stack.length] = x;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if(this.stack.length > 0) {\\n        const retVal = this.stack[this.stack.length - 1];\\n        delete this.stack[this.stack.length - 1];\\n        this.stack.length = this.stack.length - 1;\\n        return retVal;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for(let i = 0; i < k; i++) {\\n        if(this.stack[i]) this.stack[i] = this.stack[i] + val;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1701366,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1757638,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 2074888,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 2071928,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 2038633,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1995614,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1868989,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1827825,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            }
        ]
    }
]