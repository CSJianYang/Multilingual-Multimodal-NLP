[
    {
        "title": "Permutations II",
        "question_content": "Given a collection of numbers, nums,&nbsp;that might contain duplicates, return all possible unique permutations in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 8\n\t-10 <= nums[i] <= 10",
        "solutions": [
            {
                "id": 18594,
                "title": "really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote",
                "content": "Use an extra boolean array \" boolean[] used\"  to indicate whether the value is added to list. \\n\\nSort the array \"int[] nums\" to make sure we can skip the same value.\\n\\nwhen a number has the same value with its previous, we can use this number only if his previous is used\\n \\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(nums==null || nums.length==0) return res;\\n            boolean[] used = new boolean[nums.length];\\n            List<Integer> list = new ArrayList<Integer>();\\n            Arrays.sort(nums);\\n            dfs(nums, used, list, res);\\n            return res;\\n        }\\n    \\n        public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){\\n            if(list.size()==nums.length){\\n                res.add(new ArrayList<Integer>(list));\\n                return;\\n            }\\n            for(int i=0;i<nums.length;i++){\\n                if(used[i]) continue;\\n                if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;\\n                used[i]=true;\\n                list.add(nums[i]);\\n                dfs(nums,used,list,res);\\n                used[i]=false;\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(nums==null || nums.length==0) return res;\\n            boolean[] used = new boolean[nums.length];\\n            List<Integer> list = new ArrayList<Integer>();\\n            Arrays.sort(nums);\\n            dfs(nums, used, list, res);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18596,
                "title": "a-simple-c-solution-in-only-20-lines",
                "content": "    class Solution {\\n    public:\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }\\n            for (int k = i; k < j; k++) {\\n                if (i != k && num[i] == num[k]) continue;\\n                swap(num[i], num[k]);\\n                recursion(num, i+1, j, res);\\n            }\\n        }\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            sort(num.begin(), num.end());\\n            vector<vector<int> >res;\\n            recursion(num, 0, num.size(), res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 18602,
                "title": "9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others",
                "content": "Very similar to Permutation I, see explanations in https://leetcode.com/discuss/19510/my-ac-simple-iterative-java-python-solution. To handle duplication, just avoid inserting a number after any of its duplicates.\\n\\n    def permuteUnique(self, nums):\\n        ans = [[]]\\n        for n in nums:\\n            new_ans = []\\n            for l in ans:\\n                for i in xrange(len(l)+1):\\n                    new_ans.append(l[:i]+[n]+l[i:])\\n                    if i<len(l) and l[i]==n: break              #handles duplication\\n            ans = new_ans\\n        return ans\\n\\t\\t\\n\\nBelow is a backtracking solution:\\n```\\n    from collections import Counter\\n    def permuteUnique(self, nums):\\n        def btrack(path, counter):\\n            if len(path)==len(nums):\\n                ans.append(path[:])\\n            for x in counter:  # dont pick duplicates\\n                if counter[x] > 0:\\n                    path.append(x)\\n                    counter[x] -= 1\\n                    btrack(path, counter)\\n                    path.pop()\\n                    counter[x] += 1\\n        ans = []\\n        btrack([], Counter(nums))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    from collections import Counter\\n    def permuteUnique(self, nums):\\n        def btrack(path, counter):\\n            if len(path)==len(nums):\\n                ans.append(path[:])\\n            for x in counter:  # dont pick duplicates\\n                if counter[x] > 0:\\n                    path.append(x)\\n                    counter[x] -= 1\\n                    btrack(path, counter)\\n                    path.pop()\\n                    counter[x] += 1\\n        ans = []\\n        btrack([], Counter(nums))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18648,
                "title": "share-my-java-code-with-detailed-explanantion",
                "content": "    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums==null || nums.length==0) { return ans; }\\n            permute(ans, nums, 0);\\n            return ans;\\n        }\\n        \\n        private void permute(List<List<Integer>> ans, int[] nums, int index) {\\n            if (index == nums.length) { \\n                List<Integer> temp = new ArrayList<>();\\n                for (int num: nums) { temp.add(num); }\\n                ans.add(temp);\\n                return;\\n            }\\n            Set<Integer> appeared = new HashSet<>();\\n            for (int i=index; i<nums.length; ++i) {\\n                if (appeared.add(nums[i])) {\\n                    swap(nums, index, i);\\n                    permute(ans, nums, index+1);\\n                    swap(nums, index, i);\\n                }\\n            }\\n        }\\n        \\n        private void swap(int[] nums, int i, int j) {\\n            int save = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = save;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums==null || nums.length==0) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 18632,
                "title": "short-40ms-c-solution-similar-to-permutation-i-solution",
                "content": "This is like the Permutation I solution, but we use an unordered_set to avoid swapping elements that are the same (which would generate identical permutations).\\n\\n    class Solution {\\n    public:\\n    \\n        void permuteUniqueHelper(int i, vector<int>& nums, vector<vector<int> >& result) {\\n            if (i == nums.size()) { result.emplace_back(nums); return; }\\n            unordered_set<int> st;\\n            for (int j = i; j < nums.size(); ++j) {\\n                if (st.count(nums[j]) == 1) { continue; }\\n                st.insert(nums[j]);\\n                std::swap(nums[i], nums[j]);\\n                permuteUniqueHelper(i + 1, nums, result);\\n                std::swap(nums[i], nums[j]);\\n            }\\n        }\\n        \\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            vector<vector<int> > result;\\n            permuteUniqueHelper(0, nums, result);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        void permuteUniqueHelper(int i, vector<int>& nums, vector<vector<int> >& result) {\\n            if (i == nums.size()) { result.emplace_back(nums); return; }",
                "codeTag": "Java"
            },
            {
                "id": 18649,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\ndef permuteUnique(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n    for i in xrange(len(nums)):\\n        if i > 0 and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef permuteUnique(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n    for i in xrange(len(nums)):\\n        if i > 0 and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 933190,
                "title": "c-4-different-solutions-with-explanations-and-tips",
                "content": "**First solution**\\nStarting with the simplest solution using `std::next_permutation`. This may not be acceptable in a 1:1 interview, but it\\'s a good start. If you are doing a technical evaluation, this may be acceptable. Note that I\\'m sorting the elements as `std::next_permutation` returns `false` once it reaches the last lexicographically sorted permutation.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t\\n        vector<vector<int>> output;\\n        output.emplace_back(nums);\\n        while (next_permutation(begin(nums), end(nums))) {\\n            output.emplace_back(nums);\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Second Solution**\\nIn the previous solution, I used `std::sort` which increases the time complexity, but it\\'s not entirely necessary. We could simply record the initial state of the array and keep generating the next permutation until we completed a cycle. To provide an acceptable solution for this approach, I implemented `next_permutation` myself. The great thing about this solution is that it solves 4 different problems that I know of: [Permutations I](https://leetcode.com/problems/permutations/), [Permutation II](https://leetcode.com/problems/permutations-ii/), [Next Permutation problem](https://leetcode.com/problems/next-permutation/), and [Next Greater Element iii](https://leetcode.com/problems/next-greater-element-iii/) so it\\'s worth practicing it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int> initial_state(nums);\\n        vector<vector<int>> output;\\n        do {\\n            output.emplace_back(nums);\\n            nextPermutation(nums);\\n        } while (nums != initial_state);\\n        return output;\\n    }\\nprivate:\\n    void nextPermutation(vector<int>& nums) {\\n        if (size(nums) <= 1) return;\\n        auto pos = 0;\\n        for (int i = size(nums) - 2; i >= 0; --i) {\\n            if (nums[i] < nums[i + 1]) {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for (int i = size(nums) - 1; i >= pos; --i) {\\n            if (nums[pos] < nums[i]) {\\n                swap(nums[i], nums[pos]);\\n                ++pos;\\n                break;\\n            }\\n        }\\n        reverse(begin(nums) + pos, end(nums));\\n    }\\n};\\n```\\n\\n**Third Solution**\\nMy intuition to solving this problem was using a similar solution to the [Permutations problem](https://leetcode.com/problems/permutations/) but skipping iterations for duplicate numbers. In order to do that I had to sort the array first. That approach on its own wasn\\'t enough. Swapping numbers twice proved to be challenging. To prevent duplicates, I ended up removing the second swap and passing the array by value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        sort(begin(nums), end(nums));\\n        generatePermutations(nums, output, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(vector<int> nums, vector<vector<int>>& output, int idx) {\\n        if (idx == size(nums)) {\\n            output.emplace_back(nums);\\n        }\\n        for (int i = idx; i < size(nums); ++i) {\\n            if (i != idx && nums[i] == nums[idx]) continue;\\n            swap(nums[i], nums[idx]);\\n            generatePermutations(nums, output, idx + 1);\\n        }\\n    }\\n};\\n```\\n\\n**Fourth solution**\\nBacktracking using a hash table. This is the same solution you\\'d find in the `Solution` tab. The key insight here is that by iterating through unique numbers, we can avoid duplication. If you practice the [Permutations problem](https://leetcode.com/problems/permutations/) first, identifying this solution might be challenging, but it\\'s easy enough to understand when you consider it on its own.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> curr;\\n        unordered_map<int, int> counter;\\n        for (auto x : nums) ++counter[x];\\n        generatePermutations(counter, curr, output, size(nums));\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(unordered_map<int, int>& counter, vector<int>& curr, vector<vector<int>>& output, int n) {\\n        if (size(curr) == n) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (auto [key, value] : counter) {\\n            if (value == 0) continue;\\n            curr.emplace_back(key); --counter[key];\\n            generatePermutations(counter, curr, output, n);\\n            curr.pop_back(); ++counter[key];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t\\n        vector<vector<int>> output;\\n        output.emplace_back(nums);\\n        while (next_permutation(begin(nums), end(nums))) {\\n            output.emplace_back(nums);\\n        }\\n        return output;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int> initial_state(nums);\\n        vector<vector<int>> output;\\n        do {\\n            output.emplace_back(nums);\\n            nextPermutation(nums);\\n        } while (nums != initial_state);\\n        return output;\\n    }\\nprivate:\\n    void nextPermutation(vector<int>& nums) {\\n        if (size(nums) <= 1) return;\\n        auto pos = 0;\\n        for (int i = size(nums) - 2; i >= 0; --i) {\\n            if (nums[i] < nums[i + 1]) {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for (int i = size(nums) - 1; i >= pos; --i) {\\n            if (nums[pos] < nums[i]) {\\n                swap(nums[i], nums[pos]);\\n                ++pos;\\n                break;\\n            }\\n        }\\n        reverse(begin(nums) + pos, end(nums));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        sort(begin(nums), end(nums));\\n        generatePermutations(nums, output, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(vector<int> nums, vector<vector<int>>& output, int idx) {\\n        if (idx == size(nums)) {\\n            output.emplace_back(nums);\\n        }\\n        for (int i = idx; i < size(nums); ++i) {\\n            if (i != idx && nums[i] == nums[idx]) continue;\\n            swap(nums[i], nums[idx]);\\n            generatePermutations(nums, output, idx + 1);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> curr;\\n        unordered_map<int, int> counter;\\n        for (auto x : nums) ++counter[x];\\n        generatePermutations(counter, curr, output, size(nums));\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(unordered_map<int, int>& counter, vector<int>& curr, vector<vector<int>>& output, int n) {\\n        if (size(curr) == n) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (auto [key, value] : counter) {\\n            if (value == 0) continue;\\n            curr.emplace_back(key); --counter[key];\\n            generatePermutations(counter, curr, output, n);\\n            curr.pop_back(); ++counter[key];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189116,
                "title": "summarization-of-permutations-i-and-ii-python",
                "content": "Recall Permutation I, where there is no duplicate. \nThe basic idea was to enumerate all possibilities of the first element, and recursively permute the remaining, then concatenate. \n\nFor example: 123\nlet 1 be the first element, recursively permute 23\nlet 2 be the first element, recursively permute 13\nlet 3 be the first element, recursively permute 12\n\nI'll show two versions here; a more intutive recursion and less intutive (I think) backtracking \n\n```\n# intuitive recursion\nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return [[]]\n        res = []\n        for i in range(n):\n            for p in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + p)\n        return res\n```\n\n```\n# backtracking \nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                nums[l], nums[i] = nums[i], nums[l]   # swap nums[l] and nums[i]\n                dfs(l+1)\n                nums[l], nums[i] = nums[i], nums[l]  # swap them back\n        dfs(0)\n        return res\n```\n\nNow consider the case where there are duplicates in `nums`. \nThe idea is still the same. except we only put the duplicated element in the front once. \n\nFor example, 11223\nlet 1 be the first element, recursively permute 1223\nlet 2 be the first element, recursively permute 1123\nlet 3 be the first element, recursively permute 1122\n\nHow to adapt the previous code to take care of duplicates? \nWe can simply pick out the unique element, and recursively permute the remainining.\n\n```\n# intuitive recursion (beat 60.77%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return [[]]\n        res = []\n        for i in set(nums):\n            remaining = list(nums)\n            remaining.remove(i)\n            for p in self.permuteUnique(remaining):\n                res.append([i] + p)\n        return res\n```\n\n```\n# backtracking  (beat 94.13%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in set(nums[l:]):\n                remaining = nums[l:]\n                remaining.remove(i)\n                dfs(nums[:l] + [i] + remaining, l+1)\n        dfs(nums, 0)\n        return res\n\n```\n\nAll the above solutions don't require the nums to be sorted first. \nIf we sort nums first, we can have a more elegant solution as posted here: \nhttps://leetcode.com/problems/permutations-ii/discuss/18596/A-simple-C%2B%2B-solution-in-only-20-lines\n\nThe original post was in C++, here I reproduce in Python: \n\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap nums[l] and nums[i]\n                dfs(list(nums), l+1)  # it's important to pass the value of nums, not reference \n        nums.sort()\n        dfs(nums, 0)\n        return res\n```\n\nThis code may be less intutive at first glance, since it's different from usual backtracking: it swaps nums[l] and nums[i] before backtracking, but didn't swap them back afterwards! This is exactly the elegance of this solution. This is exactly implementing \"pick the unique and permute the remaining\". To see this, the k-th swap always does the following, swap the first appearance of the k-th largest value with the first value, which is the (k-1)-th largest value. This way the subarray passed on is maintained sorted! \nFor example:\n\n112233\n1st swap, 1 with itself, 1**12233**\n2nd swap, 1 with 2, 2**11233**\n3rd swap, 2 with 3, 3**11223**\nThe bolded part is always sorted. So this invariance is nicely maintained in this implementation. \n\nNote in the above implementation, we have to pass in the value of nums by passing in list(nums). We can avoid that by recover the array afterwards. This is easy since after all the swaps in the for loop, the array looks like, e.g., this:\n\n311223\n\nIt is rotated by one position. We can simply rotate it back! \n(this solution was also posted in that thread by dyp) \n\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def rotate(nums, l):\n            tmp = nums[l]\n            i = l + 1\n            while i < n:\n                nums[i-1] = nums[i]\n                i += 1\n            nums[-1] = tmp\n            \n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap\n                dfs(nums, l+1)  # note now we're passing by reference\n            # recover\n            rotate(nums, l)\n        nums.sort()\n        dfs(nums, 0)\n        return res\n```",
                "solutionTags": [],
                "code": "```\n# intuitive recursion\nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return [[]]\n        res = []\n        for i in range(n):\n            for p in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + p)\n        return res\n```\n```\n# backtracking \nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                nums[l], nums[i] = nums[i], nums[l]   # swap nums[l] and nums[i]\n                dfs(l+1)\n                nums[l], nums[i] = nums[i], nums[l]  # swap them back\n        dfs(0)\n        return res\n```\n```\n# intuitive recursion (beat 60.77%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return [[]]\n        res = []\n        for i in set(nums):\n            remaining = list(nums)\n            remaining.remove(i)\n            for p in self.permuteUnique(remaining):\n                res.append([i] + p)\n        return res\n```\n```\n# backtracking  (beat 94.13%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in set(nums[l:]):\n                remaining = nums[l:]\n                remaining.remove(i)\n                dfs(nums[:l] + [i] + remaining, l+1)\n        dfs(nums, 0)\n        return res\n\n```\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap nums[l] and nums[i]\n                dfs(list(nums), l+1)  # it's important to pass the value of nums, not reference \n        nums.sort()\n        dfs(nums, 0)\n        return res\n```\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def rotate(nums, l):\n            tmp = nums[l]\n            i = l + 1\n            while i < n:\n                nums[i-1] = nums[i]\n                i += 1\n            nums[-1] = tmp\n            \n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap\n                dfs(nums, l+1)  # note now we're passing by reference\n            # recover\n            rotate(nums, l)\n        nums.sort()\n        dfs(nums, 0)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 18628,
                "title": "accepted-backtracking-c-solution-by-using-map-28ms",
                "content": "I see most solutions are using next permutation. That's great and only uses O(1) space.\\n\\nAnyway I am sharing backtracking solution which uses O(n) space. This is actually a typical backtracking problem. We can use hash map to check whether the element was already taken. However, we could get TLE if we check vector<int> num every time. So we iterate the hash map instead.\\n\\n    class Solution {\\n    public:\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        vector<vector<int>> v;\\n        vector<int> r;\\n        map<int, int> map;\\n        for (int i : num)\\n        {\\n            if (map.find(i) == map.end()) map[i] = 0;\\n            map[i]++;\\n        }\\n        permuteUnique(v, r, map, num.size());\\n        return v;\\n    }\\n    \\n    void permuteUnique(vector<vector<int>> &v, vector<int> &r, map<int, int> &map, int n)\\n    {\\n        if (n <= 0)\\n        {\\n            v.push_back(r);\\n            return;\\n        }\\n        for (auto &p : map)\\n        {\\n            if (p.second <= 0) continue;\\n            p.second--;\\n            r.push_back(p.first);\\n            permuteUnique(v, r, map, n - 1);\\n            r.pop_back();\\n            p.second++;\\n        }\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        vector<vector<int>> v;\\n        vector<int> r;\\n        map<int, int> map;\\n        for (int i : num)\\n        {\\n            if (map.find(i) == map.end()) map[i] = 0;\\n            map[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18604,
                "title": "a-non-recursive-c-implementation-with-o-1-space-cost",
                "content": "    class Solution {\\n    public:\\n    \\tvector<vector<int> > permuteUnique(vector<int> &S) {\\n    \\t\\t// res.clear();\\n    \\t\\tsort(S.begin(), S.end());\\t\\t\\n    \\t\\tres.push_back(S);\\n    \\t\\tint j;\\n    \\t\\tint i = S.size()-1;\\n    \\t\\twhile (1){\\n    \\t\\t\\tfor (i=S.size()-1; i>0; i--){\\n    \\t\\t\\t\\tif (S[i-1]< S[i]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(i == 0){\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tfor (j=S.size()-1; j>i-1; j--){\\n    \\t\\t\\t\\tif (S[j]>S[i-1]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\t\\t\\t\\t\\t\\n    \\t\\t\\tswap(S[i-1], S[j]);\\n    \\t\\t\\treverse(S, i, S.size()-1);\\n    \\t\\t\\tres.push_back(S);\\n    \\t\\t}\\n    \\t\\treturn res;\\n        }\\n    \\tvoid reverse(vector<int> &S, int s, int e){\\t\\t\\n    \\t\\twhile (s<e){\\n    \\t\\t\\tswap(S[s++], S[e--]);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tvector<vector<int> > res;\\n    };\\n\\nBasically, assume we have \"1234\", the idea is to increase the number in ascending order, so next is \"1243\", next is \"1324\", and so on.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > permuteUnique(vector<int> &S) {\\n    \\t\\t// res.clear();\\n    \\t\\tsort(S.begin(), S.end());\\t\\t\\n    \\t\\tres.push_back(S);\\n    \\t\\tint j;\\n    \\t\\tint i = S.size()-1;\\n    \\t\\twhile (1){\\n    \\t\\t\\tfor (i=S.size()-1; i>0; i--){\\n    \\t\\t\\t\\tif (S[i-1]< S[i]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18669,
                "title": "c-backtracking-and-nextpermutation",
                "content": "**Backtracking**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                if (j == i || nums[j] != nums[i]) {\\n                    swap(nums[i], nums[j]);\\n                    permute(nums, i + 1, perms);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Next Permutation**\\n\\nBesides backtracking, you may also solve it using [Next Permutation](https://leetcode.com/problems/next-permutation/): computing the next permutation and add it to the result until it becomes the original array. To know when `nextPermutation` should stop, we sort `nums` in ascending order and stop when it becomes in descending order.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        do {\\n            perms.push_back(nums);\\n        } while(nextPermutation(nums));\\n        return perms;\\n    }\\nprivate:\\n    bool nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n            return false;\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                if (j == i || nums[j] != nums[i]) {\\n                    swap(nums[i], nums[j]);\\n                    permute(nums, i + 1, perms);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        do {\\n            perms.push_back(nums);\\n        } while(nextPermutation(nums));\\n        return perms;\\n    }\\nprivate:\\n    bool nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n            return false;\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214219,
                "title": "best-c-3-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\\n    the worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking + Hash Table(set). \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            set.insert(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            permuteUnique(nums, set, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        set<vector<int>> set;\\n        permuteUnique(nums, set, temp, 0);\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\\n    worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(isPresent){\\n                continue;\\n            }\\n            permuteUnique(nums, output, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        permuteUnique(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\\n        if(temp.size() == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\\n            visited[i] = true;\\n            temp.push_back(nums[i]);\\n            permuteUnique(nums, output, temp, visited);\\n            temp.pop_back();\\n            visited[i] = false;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        vector<bool> visited(nums.size(), 0); \\n        permuteUnique(nums, output, temp, visited);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\\n    the worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking + Hash Table(set). \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            set.insert(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            permuteUnique(nums, set, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        set<vector<int>> set;\\n        permuteUnique(nums, set, temp, 0);\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\\n    worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(isPresent){\\n                continue;\\n            }\\n            permuteUnique(nums, output, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        permuteUnique(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\\n        if(temp.size() == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\\n            visited[i] = true;\\n            temp.push_back(nums[i]);\\n            permuteUnique(nums, output, temp, visited);\\n            temp.pop_back();\\n            visited[i] = false;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        vector<bool> visited(nums.size(), 0); \\n        permuteUnique(nums, output, temp, visited);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030416,
                "title": "python-simple-backtrack-beats-90",
                "content": "The problem is solved using a backtracking approach. For this particular case, as we have duplicates in input, we can  track the count of each number.  Python provides a built-in lib `Counter` which I will be using for this problem. As the order of output results doesn\\'t matter, we can use this `Counter` variable to track visited elements in the exploration path\\n\\nThe solution Tree for this problem for an input `[1,1,2]` would look like this:\\n\\n<img width=\"400\" src=\"https://assets.leetcode.com/users/images/c7ae7036-ae8b-4d79-aca7-8950a2750a27_1652316056.5212104.jpeg\">\\n\\nBelow is the code that will represent the above solution tree\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        permutations = []\\n        counter = Counter(nums)\\n        def findAllPermutations(res):\\n            if len(res) == len(nums):\\n                permutations.append(res)\\n                return \\n            \\n            for key in counter:\\n                if counter[key]:\\n                    counter[key]-=1 # decrement visited key\\n                    findAllPermutations(res + [key])    \\n                    counter[key]+=1 # restore the state of visited key to find the next path\\n                \\n        findAllPermutations([])\\n        return permutations\\n```\\n**Space** - `O(N)` - Each call stack depth would be `N` where `N` is the length of input list.\\n**Time** - `O(n * \\u03A3(P(N, k)))` - In worst case, all numbers in the input array will be unique. In this case, each path will go upto `N` depth in solution tree. At each level, the branching factor is reduced by `1` so it will go like `N, N-1, N-2...1` starting from root.  (Time complexity shared by [@AntonBelski](https://leetcode.com/AntonBelski/))\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        permutations = []\\n        counter = Counter(nums)\\n        def findAllPermutations(res):\\n            if len(res) == len(nums):\\n                permutations.append(res)\\n                return \\n            \\n            for key in counter:\\n                if counter[key]:\\n                    counter[key]-=1 # decrement visited key\\n                    findAllPermutations(res + [key])    \\n                    counter[key]+=1 # restore the state of visited key to find the next path\\n                \\n        findAllPermutations([])\\n        return permutations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18616,
                "title": "6-lines-python-ruby",
                "content": "Build the list of permutations one number at a time, insert the number into each already built permutation but only **before** other instances of the same number, never after. Inspired by [cbmbbz's already good solution](https://leetcode.com/discuss/77245/line-python-solution-with-line-handle-duplication-beat-others), though I then saw others had used the idea earlier.\\n\\n---\\n\\nPython solution\\n-\\n\\nTo find the last index for inserting new number `n` into old permutation `p`, I search for previous instances of `n` in `p`. But because `index` throws an exception if unsuccessful, I add a [sentinel](https://en.wikipedia.org/wiki/Sentinel_value) `n` at the end (which is the appropriate last insertion index then).\\n\\n    def permuteUnique(self, nums):\\n        perms = [[]]\\n        for n in nums:\\n            perms = [p[:i] + [n] + p[i:]\\n                     for p in perms\\n                     for i in xrange((p + [n]).index(n) + 1)]\\n        return perms\\n\\nOr as \"one-liner\" using `reduce`:\\n\\n    def permuteUnique(self, nums):\\n        return reduce(lambda perms, n: [p[:i] + [n] + p[i:]\\n                                        for p in perms\\n                                        for i in xrange((p + [n]).index(n) + 1)],\\n                      nums, [[]])\\n\\n---\\n\\nRuby solution\\n-\\n\\n    def permute_unique(nums)\\n      nums.reduce([[]]) { |perms, n|\\n        perms.flat_map { |p|\\n          last = p.index(n) || p.size\\n          (0..last).map { |i| p[0,i] + [n] + p[i..-1] }\\n        }\\n      }\\n    end",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Build the list of permutations one number at a time, insert the number into each already built permutation but only **before** other instances of the same number, never after. Inspired by [cbmbbz's already good solution](https://leetcode.com/discuss/77245/line-python-solution-with-line-handle-duplication-beat-others), though I then saw others had used the idea earlier.\\n\\n---\\n\\nPython solution\\n-\\n\\nTo find the last index for inserting new number `n` into old permutation `p`, I search for previous instances of `n` in `p`. But because `index` throws an exception if unsuccessful, I add a [sentinel](https://en.wikipedia.org/wiki/Sentinel_value) `n` at the end (which is the appropriate last insertion index then).\\n\\n    def permuteUnique(self, nums):\\n        perms = [[]]\\n        for n in nums:\\n            perms = [p[:i] + [n] + p[i:]\\n                     for p in perms\\n                     for i in xrange((p + [n]).index(n) + 1)]\\n        return perms\\n\\nOr as \"one-liner\" using `reduce`:\\n\\n    def permuteUnique(self, nums):\\n        return reduce(lambda perms, n: [p[:i] + [n] + p[i:]\\n                                        for p in perms\\n                                        for i in xrange((p + [n]).index(n) + 1)],\\n                      nums, [[]])\\n\\n---\\n\\nRuby solution\\n-\\n\\n    def permute_unique(nums)\\n      nums.reduce([[]]) { |perms, n|\\n        perms.flat_map { |p|\\n          last = p.index(n) || p.size\\n          (0..last).map { |i| p[0,i] + [n] + p[i..-1] }\\n        }\\n      }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 562948,
                "title": "c-backtracking-24ms-with-explainations-about-remove-duplicates",
                "content": "I have to talk a little more about how I come up with this.\\nThere is difference between \"Combination/Subset\" and \"Permutation\".\\nFor example:[1,2,3], Combination only has [1,2,3]. Permutations includes[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1].\\n[**1.Combination Sum**](https://leetcode.com/problems/combination-sum/)\\nBecause it is combination, so [1,2,3] and [3,2,1] are duplicates.\\nIf we take [1,5,2,3] as an example, when we iterate to index 2 where value is 2, it makes no sense to start before index 2, because [1,5,2] and [2,1,5] are the same.\\nThat\\'s the meaning ```i_start```(or ```begin```) has,\\nand **this ```begin``` may make sense in other questions, we should keep it in mind**.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& combination, int target, int i_start){\\n\\t\\tif(target == 0){\\n\\t\\t\\t_res.push_back(combination);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = i_start; i < candidates.size();++i){//i_start is important to remove duplicates under the situation\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcombination.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, combination, target - candidates[i], i);\\n\\t\\t\\t\\tcombination.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n    vector<vector<int>> combinationSum(const vector<int>& candidates, int target) {\\n\\t\\tvector<int> combination;\\n\\t\\tDFS(candidates, combination, target,0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n[**2.Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nWhat about the duplicates caused from the duplicate numbers in input?\\nWe ```sort``` them first. and then take ```1122333``` as an example.\\nIf we meet ```11```, we will have these choice at this level(or layer or depth).\\n```11```\\n```2 || 2 || 3 || 3 || 3```\\nApparently, the second ```2``` and the 2nd & 3rd ```3``` will induce duplicate solutions, because we use DFS and these solutions have been computed in the path ```112(first \\'2\\')``` or ```113(first\\'3\\')```.\\n```\\n\\u2193If we choose first 2,                          \\u2193If we choose second 2,\\n      112                                                  112\\n2 || 3 || 3 || 3                                        3 || 3 || 3\\n```\\nThat\\'s why ```num[i]==num[i-1]```.\\nSo why ```i>begin```?\\nIf we go further, we will meet ```112```, we will have these choice at this level.\\n```112```\\n```2 || 3 || 3 || 3```\\nSurely, we are not willing to skip the first```2```at beginning of this level.\\nThat\\'s why ```i>begin```.\\nSo we use ```i>begin && num[i]==num[i-1]```.\\nIn short, to remove the second part duplicates, we have to **sort the array first, and then skip the same value at each level**.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& cur, int target, int begin){\\n\\t\\tif(target == 0)\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\tfor (int i = begin; i < candidates.size();++i){//begin is to remove first part of duplicates, which plays the same role in problem Combination Sum.\\n\\t\\t\\tif(i > begin && candidates[i] == candidates[i-1])//this means to remove the second part of duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcur.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, cur, target - candidates[i], i + 1);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\t\\tsort(candidates.begin(), candidates.end());//this helps to remove the second part of duplicates\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(candidates, cur, target, 0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n[**3.Permutations**](https://leetcode.com/problems/permutations/)\\nUnder this question, [1,2,3] and [3,2,1] are different.\\nSo **we have to iterate from 0 in each iteration rather than start from ```begin```.**\\nWhat about numbers we have used? We can mark them like **array ```visited```** in BFS.\\nIf we have used it, we should skip it. And we should keep this in mind.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because of it is permutation, we have to start from 0 in each iteration\\n\\t\\t\\tif(!_visited[i]){//the visited array\\n\\t\\t\\t\\t_visited[i] = true;\\n\\t\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t_visited[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n**4.Permutations II**\\nNow, it is time to talk about this problem.\\nYou can find both some similarities and some difference bettwen Combination Sum with Permutations, Combination Sum II with Permutations II.\\nIt is difficult for me to put it clear in English, but I wish you can find the similarities and difference.\\nAs we make use of the solution to Combination Sum in Combination Sum II, we also can make use of the array ```visited``` in Permutations.\\nAnd we just need to **skip same value at each level(or layer or depth)**, what should we do?\\nBecause it is problem about permutation, so we have to iterate from 0, resulting in using array ```visited```.\\n**The level should include every number in array ```nums``` which has not been visited.**\\nAnd like what we do in Combination Sum II, we skip same value at each level to remove duplicates.\\nWe have to iterate from 0, so i-1>=0, --> i>0.\\nSo we use ```(i && !_visited[i-1] && nums[i]==nums[i-1])```.\\nWhy ```!_visited[i-1]```? If ```nums[i-1]```has been visited, it is not the value at this level.\\nSolution:\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because it is a problem about permutation, we have to iterate from 0.\\n\\t\\t\\tif(_visited[i])//1st step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(i && !_visited[i-1] && nums[i]==nums[i-1])//2nd step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t_visited[i] = true;\\n\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\tcur.pop_back();\\n\\t\\t\\t_visited[i] = false;\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());//help to remove duplicates\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\nThere are more problems, wish you can find some similarities.\\n[A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```i_start```\n```begin```\n```begin```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& combination, int target, int i_start){\\n\\t\\tif(target == 0){\\n\\t\\t\\t_res.push_back(combination);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = i_start; i < candidates.size();++i){//i_start is important to remove duplicates under the situation\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcombination.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, combination, target - candidates[i], i);\\n\\t\\t\\t\\tcombination.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n    vector<vector<int>> combinationSum(const vector<int>& candidates, int target) {\\n\\t\\tvector<int> combination;\\n\\t\\tDFS(candidates, combination, target,0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```sort```\n```1122333```\n```11```\n```11```\n```2 || 2 || 3 || 3 || 3```\n```2```\n```3```\n```112(first \\'2\\')```\n```113(first\\'3\\')```\n```\\n\\u2193If we choose first 2,                          \\u2193If we choose second 2,\\n      112                                                  112\\n2 || 3 || 3 || 3                                        3 || 3 || 3\\n```\n```num[i]==num[i-1]```\n```i>begin```\n```112```\n```112```\n```2 || 3 || 3 || 3```\n```2```\n```i>begin```\n```i>begin && num[i]==num[i-1]```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& cur, int target, int begin){\\n\\t\\tif(target == 0)\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\tfor (int i = begin; i < candidates.size();++i){//begin is to remove first part of duplicates, which plays the same role in problem Combination Sum.\\n\\t\\t\\tif(i > begin && candidates[i] == candidates[i-1])//this means to remove the second part of duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcur.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, cur, target - candidates[i], i + 1);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\t\\tsort(candidates.begin(), candidates.end());//this helps to remove the second part of duplicates\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(candidates, cur, target, 0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```begin```\n```visited```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because of it is permutation, we have to start from 0 in each iteration\\n\\t\\t\\tif(!_visited[i]){//the visited array\\n\\t\\t\\t\\t_visited[i] = true;\\n\\t\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t_visited[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```visited```\n```visited```\n```nums```\n```(i && !_visited[i-1] && nums[i]==nums[i-1])```\n```!_visited[i-1]```\n```nums[i-1]```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because it is a problem about permutation, we have to iterate from 0.\\n\\t\\t\\tif(_visited[i])//1st step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(i && !_visited[i-1] && nums[i]==nums[i-1])//2nd step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t_visited[i] = true;\\n\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\tcur.pop_back();\\n\\t\\t\\t_visited[i] = false;\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());//help to remove duplicates\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18724,
                "title": "share-my-recursive-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            List<Integer> current = new ArrayList<Integer>();\\n            boolean[] visited = new boolean[num.length];\\n            permute(result, current, num, visited);\\n            return result;\\n        }\\n        \\n        private void permute(List<List<Integer>> result, List<Integer> current, int[] num, boolean[] visited) {\\n            if (current.size() == num.length) {\\n                result.add(new ArrayList<Integer>(current));\\n                return;\\n            }\\n            for (int i=0; i<visited.length; i++) {\\n                if (!visited[i]) {\\n                    if (i > 0 && num[i] == num[i-1] && visited[i-1]) {\\n                        return;\\n                    }\\n                    visited[i] = true;\\n                    current.add(num[i]);\\n                    permute(result, current, num, visited);\\n                    current.remove(current.size()-1);\\n                    visited[i] = false;\\n                }\\n            }\\n        }\\n    }\\n\\nThe idea to resolve duplicate is to ensure that for elements with the same value, we make sure that they are picked up in the ascending order of index. To implement this, every time we try to pick up some value, we just check if the previous element has the same value and is visited or not. If so, we just return!",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            List<Integer> current = new ArrayList<Integer>();\\n            boolean[] visited = new boolean[num.length];\\n            permute(result, current, num, visited);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18601,
                "title": "short-iterative-java-solution",
                "content": "Hi guys!\\n\\nHere's an iterative solution which doesn't use nextPermutation helper. It builds the permutations for i-1 first elements of an input array and tries to insert the ith element into all positions of each prebuilt i-1 permutation. I couldn't come up with more effective controling of uniqueness than just using a Set.\\n\\nSee the code below!\\n\\n----------\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            LinkedList<List<Integer>> res = new LinkedList<>();\\n            res.add(new ArrayList<>());\\n            for (int i = 0; i < num.length; i++) {\\n                Set<String> cache = new HashSet<>();\\n                while (res.peekFirst().size() == i) {\\n                    List<Integer> l = res.removeFirst();\\n                    for (int j = 0; j <= l.size(); j++) {\\n                        List<Integer> newL = new ArrayList<>(l.subList(0,j));\\n                        newL.add(num[i]);\\n                        newL.addAll(l.subList(j,l.size()));\\n                        if (cache.add(newL.toString())) res.add(newL);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            LinkedList<List<Integer>> res = new LinkedList<>();\\n            res.add(new ArrayList<>());\\n            for (int i = 0; i < num.length; i++) {\\n                Set<String> cache = new HashSet<>();\\n                while (res.peekFirst().size() == i) {\\n                    List<Integer> l = res.removeFirst();\\n                    for (int j = 0; j <= l.size(); j++) {\\n                        List<Integer> newL = new ArrayList<>(l.subList(0,j));\\n                        newL.add(num[i]);\\n                        newL.addAll(l.subList(j,l.size()));\\n                        if (cache.add(newL.toString())) res.add(newL);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2031042,
                "title": "java-backtracking-explained-easy-understanding",
                "content": "Hello Leetcoders, Hope you all are good.\\n\\nLet\\'s dig into the problem and think best way to get the solution.\\n\\n**Problem Discription :**\\n```\\nGiven an integer array that may contains duplicate values. You have to find all unique permutations of the integer array.\\nE.g arr = [1,1,2]\\n\\nAll possible permutations are \\n\\n[1,1,2]\\n[1,2,1]\\n[2,1,1]\\n```\\n\\n**formula** :-* (if they ask total no. of unique permutations)*\\ntotal no of permutations = n!\\nif there are some duplicates number in that case = n! / a! * b!\\nwhere a & b are frequency of the duplicate numbers\\n\\nbut question says print all permutations\\nso here we use **backtracking**\\n\\nfirst of all we need to **sort the array** because there are some duplicate numbers and we don\\'t want to process same number twice\\n\\nfor writting backrtracking code we need to create a **helper** method \\n\\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\t\\t\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        Arrays.sort(nums); // sort the array\\n\\t\\t\\n\\t\\t// create a boolean array which track the certain indexed integer is present in out temp list or not\\n        helper(ans, new ArrayList<>(), nums, new boolean[nums.length]); // helper method\\n\\t\\t\\n        return ans; // return output\\n    }\\n```\\n\\n**Now backtracking code**\\n\\n```\\nprivate void helper(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] vis) {\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\twhen size of the temp list and size of the inout array are same then add this temp list into the final ans list.\\n\\t\\t\\tthis is one of our permutation for given integer array\\n\\t\\t*/\\n        if(nums.length == temp.size()) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        /*\\n\\t\\t\\tTraverse for whole array one by one.\\n\\t\\t*/\\n        for(int i=0;i<nums.length; i++) {\\n\\t\\t\\n            if(vis[i]) continue; // if current element is already present in the temp, skip the element\\n            if(i > 0 && ! vis[i-1] && nums[i] == nums[i-1]) continue; // if prev element and current element is equal, skip the element\\n            \\n            vis[i] = true;\\n            temp.add(nums[i]);\\n            \\n            helper(ans, temp, nums, vis); // recursive call\\n            \\n\\t\\t\\t// backtracking\\n            temp.remove(temp.size() - 1);\\n            vis[i] = false;\\n        }\\n    }\\n\\n```\\n\\n\\n\\n\\n# ***If you like the explanation please UP-VOTE the article***\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nGiven an integer array that may contains duplicate values. You have to find all unique permutations of the integer array.\\nE.g arr = [1,1,2]\\n\\nAll possible permutations are \\n\\n[1,1,2]\\n[1,2,1]\\n[2,1,1]\\n```\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\t\\t\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        Arrays.sort(nums); // sort the array\\n\\t\\t\\n\\t\\t// create a boolean array which track the certain indexed integer is present in out temp list or not\\n        helper(ans, new ArrayList<>(), nums, new boolean[nums.length]); // helper method\\n\\t\\t\\n        return ans; // return output\\n    }\\n```\n```\\nprivate void helper(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] vis) {\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\twhen size of the temp list and size of the inout array are same then add this temp list into the final ans list.\\n\\t\\t\\tthis is one of our permutation for given integer array\\n\\t\\t*/\\n        if(nums.length == temp.size()) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        /*\\n\\t\\t\\tTraverse for whole array one by one.\\n\\t\\t*/\\n        for(int i=0;i<nums.length; i++) {\\n\\t\\t\\n            if(vis[i]) continue; // if current element is already present in the temp, skip the element\\n            if(i > 0 && ! vis[i-1] && nums[i] == nums[i-1]) continue; // if prev element and current element is equal, skip the element\\n            \\n            vis[i] = true;\\n            temp.add(nums[i]);\\n            \\n            helper(ans, temp, nums, vis); // recursive call\\n            \\n\\t\\t\\t// backtracking\\n            temp.remove(temp.size() - 1);\\n            vis[i] = false;\\n        }\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18670,
                "title": "short-and-fast-recursive-java-solution-easy-to-understand-with-explaination",
                "content": "The idea is to try to put every number at the beginning of the array, and then do the same thing for the rest of the array. There is no need to sort because we use a HashSet to track and make sure each number is put at the begining of the array only once.\\n\\n```\\nclass Solution {\\n    List<List<Integer>> res;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        res = new LinkedList<>();\\n        get(nums, 0);\\n        return res;\\n    }\\n    \\n    private void get(int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            res.add(toList(nums));\\n            return;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = start; i < nums.length; i++) {\\n            if (set.add(nums[i])) {\\n                int tmp = nums[start];\\n                nums[start] = nums[i];\\n                nums[i] = tmp;\\n                get(nums, start + 1);\\n                nums[i] = nums[start];\\n                nums[start] = tmp;\\n            }\\n        }\\n    }\\n    \\n    private List<Integer> toList(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for (int i : nums) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> res;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        res = new LinkedList<>();\\n        get(nums, 0);\\n        return res;\\n    }\\n    \\n    private void get(int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            res.add(toList(nums));\\n            return;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = start; i < nums.length; i++) {\\n            if (set.add(nums[i])) {\\n                int tmp = nums[start];\\n                nums[start] = nums[i];\\n                nums[i] = tmp;\\n                get(nums, start + 1);\\n                nums[i] = nums[start];\\n                nums[start] = tmp;\\n            }\\n        }\\n    }\\n    \\n    private List<Integer> toList(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for (int i : nums) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18657,
                "title": "iterative-python-solution-without-using-set-111ms",
                "content": "Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element.\\n\\n    \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        num.sort()\\n        ret = [[]]\\n        for n in num:\\n            new_ret = []\\n            l = len(ret[-1])\\n            for seq in ret:\\n                for i in range(l, -1, -1):\\n                    if i < l and seq[i] == n:\\n                        break\\n                    new_ret.append(seq[:i] + [n] + seq[i:])\\n            ret = new_ret\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element.\\n\\n    \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        num.sort()\\n        ret = [[]]\\n        for n in num:\\n            new_ret = []\\n            l = len(ret[-1])\\n            for seq in ret:\\n                for i in range(l, -1, -1):\\n                    if i < l and seq[i] == n:\\n                        break\\n                    new_ret.append(seq[:i] + [n] + seq[i:])\\n            ret = new_ret\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 1355985,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var res = [[Int]](), path = [Int](), vis = [Bool](repeating: false, count: nums.count)\\n        dfs(&res, &path, &vis, nums.sorted(by: <))\\n        return res\\n    }\\n    private func dfs(_ r: inout [[Int]], _ p: inout [Int], _ v: inout [Bool], _ n: [Int]) {\\n        guard p.count != n.count else { r.append(p); return }\\n        for i in 0..<n.count {\\n            if v[i] || (i > 0 && n[i] == n[i-1] && v[i-1]) { continue }\\n            p.append(n[i])\\n            v[i] = true\\n            dfs(&r, &p, &v, n)\\n            p.removeLast()\\n            v[i] = false\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.025 (0.027) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.permuteUnique([1,1,2])\\n        XCTAssertEqual(value, [[1,1,2],[1,2,1],[2,1,1]])\\n    }\\n    func test1() {\\n        let value = solution.permuteUnique([1,2,3])\\n        XCTAssertEqual(value, [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var res = [[Int]](), path = [Int](), vis = [Bool](repeating: false, count: nums.count)\\n        dfs(&res, &path, &vis, nums.sorted(by: <))\\n        return res\\n    }\\n    private func dfs(_ r: inout [[Int]], _ p: inout [Int], _ v: inout [Bool], _ n: [Int]) {\\n        guard p.count != n.count else { r.append(p); return }\\n        for i in 0..<n.count {\\n            if v[i] || (i > 0 && n[i] == n[i-1] && v[i-1]) { continue }\\n            p.append(n[i])\\n            v[i] = true\\n            dfs(&r, &p, &v, n)\\n            p.removeLast()\\n            v[i] = false\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.permuteUnique([1,1,2])\\n        XCTAssertEqual(value, [[1,1,2],[1,2,1],[2,1,1]])\\n    }\\n    func test1() {\\n        let value = solution.permuteUnique([1,2,3])\\n        XCTAssertEqual(value, [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750388,
                "title": "python3-dfs-solutions-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121739,
                "title": "c-backtracking-solution-beat-95-with-explanation-no-extra-space-memory-to-record-choice",
                "content": "use backtracking with swap element to find solution\\n ```checkmiddle(nums,i,begin) ``` function is used for checking if there is any value same as i between i and begin.  if there is no such point, we proceed this operation and do the next recursion. If there is, it means the same swap has been done before. E.g. \\\\[1,1,2,2],  we should not swap value position 1 and 3 becuase when when list as \\\\[1,2,1,2] , swap position 2 and 3 (\\\\[1,2,2,1]) has been done before\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>res;\\n        backtracking(nums, res, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtracking(vector<int>& nums, vector<vector<int>>& res,int begin){\\n        if(begin==nums.size()-1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = begin; i<nums.size();i++){\\n            if((nums[i]!=nums[begin] || i == begin) && checkmiddle(nums,i,begin)){\\n                swap(nums[i],nums[begin]);\\n                backtracking(nums, res, begin+1);\\n                swap(nums[i],nums[begin]);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool checkmiddle(vector<int>& nums, int i , int begin){\\n        for(int k = begin; k<i; k++)\\n            if(nums[i] == nums[k])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```checkmiddle(nums,i,begin) ```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>res;\\n        backtracking(nums, res, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtracking(vector<int>& nums, vector<vector<int>>& res,int begin){\\n        if(begin==nums.size()-1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = begin; i<nums.size();i++){\\n            if((nums[i]!=nums[begin] || i == begin) && checkmiddle(nums,i,begin)){\\n                swap(nums[i],nums[begin]);\\n                backtracking(nums, res, begin+1);\\n                swap(nums[i],nums[begin]);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool checkmiddle(vector<int>& nums, int i , int begin){\\n        for(int k = begin; k<i; k++)\\n            if(nums[i] == nums[k])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265223,
                "title": "python-backtracking",
                "content": "```python\\nclass Solution:\\n    def _permute(self, nums, s, k):\\n        if len(s) == k:\\n            self.permutations.append(s[:])\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            s.append(nums[i])\\n            self._permute(nums[:i] + nums[i+1:], s, k)\\n            s.pop()\\n            \\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.permutations = []\\n        \\n        self._permute(sorted(nums), [], len(nums))\\n        \\n        return self.permutations\\n```\\n\\nA good way to think about the solution is to draw a recursion tree. The node in the tree here is the evaluation of s in each recursive call.\\n![image](https://assets.leetcode.com/users/vubui/image_1553967971.png)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def _permute(self, nums, s, k):\\n        if len(s) == k:\\n            self.permutations.append(s[:])\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            s.append(nums[i])\\n            self._permute(nums[:i] + nums[i+1:], s, k)\\n            s.pop()\\n            \\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.permutations = []\\n        \\n        self._permute(sorted(nums), [], len(nums))\\n        \\n        return self.permutations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527937,
                "title": "java-tc-o-n-n-sc-o-n-recursive-backtracking-iterative-solutions",
                "content": "**Recursive Backtracking**\\n\\n```java\\n/**\\n * Recursive Backtracking using countMap.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + countMap + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        permuteUniqueHelper(result, nums.length, countMap, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int inputLength, HashMap<Integer, Integer> countMap, List<Integer> tempList) {\\n        if (tempList.size() == inputLength) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int num : countMap.keySet()) {\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            countMap.put(num, count - 1);\\n            tempList.add(num);\\n            permuteUniqueHelper(result, inputLength, countMap, tempList);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the  first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n\\n                    // If number just added is same as the number at jth index of cur list. Then we\\n                    // can break to avoid duplicates.\\n                    if (j < i && cur.get(j) == nums[i]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Recursive Backtracking using visited array**\\n\\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N! + NlogN). Number of permutations = P(N,N) = N!.\\n * Each permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array + Sorting + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(nums);\\n        permuteUniqueHelper(result, nums, new ArrayList<>(), new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int[] nums, List<Integer> tempList, boolean[] visited) {\\n        if (tempList.size() == nums.length) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            /**\\n             * !visited[i - 1] is making sure that duplicate results are not added. Since\\n             * nums[i-1] and nums[i] are same, nums[i] can only be used if nums[i-1] is\\n             * currently in use.\\n             */\\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {\\n                continue;\\n            }\\n            visited[i] = true;\\n            tempList.add(nums[i]);\\n            permuteUniqueHelper(result, nums, tempList, visited);\\n            tempList.remove(tempList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Permutations questions on LeetCode:\\n- [46. Permutations](https://leetcode.com/problems/permutations/discuss/1527929/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Recursive-Backtracking-and-Iterative-Solutions)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Recursive Backtracking using countMap.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + countMap + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        permuteUniqueHelper(result, nums.length, countMap, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int inputLength, HashMap<Integer, Integer> countMap, List<Integer> tempList) {\\n        if (tempList.size() == inputLength) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int num : countMap.keySet()) {\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            countMap.put(num, count - 1);\\n            tempList.add(num);\\n            permuteUniqueHelper(result, inputLength, countMap, tempList);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the  first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n\\n                    // If number just added is same as the number at jth index of cur list. Then we\\n                    // can break to avoid duplicates.\\n                    if (j < i && cur.get(j) == nums[i]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N! + NlogN). Number of permutations = P(N,N) = N!.\\n * Each permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array + Sorting + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(nums);\\n        permuteUniqueHelper(result, nums, new ArrayList<>(), new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int[] nums, List<Integer> tempList, boolean[] visited) {\\n        if (tempList.size() == nums.length) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            /**\\n             * !visited[i - 1] is making sure that duplicate results are not added. Since\\n             * nums[i-1] and nums[i] are same, nums[i] can only be used if nums[i-1] is\\n             * currently in use.\\n             */\\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {\\n                continue;\\n            }\\n            visited[i] = true;\\n            tempList.add(nums[i]);\\n            permuteUniqueHelper(result, nums, tempList, visited);\\n            tempList.remove(tempList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932924,
                "title": "python-simple-dfs-backtracking-explained",
                "content": "Another classical backtracking problem. Let us try to built our sequence element by element, inserting new element in different places. Imagine, that we have `[1,3,1,2]`. Then our building process will look like:\\n\\n1. `[1]` on the first step we have not choice, so here we have only one option.\\n2. Now, we need to insert next element somewhere, and we have two options: before and after, so we have `[1,3]` and `[3,1]` options here.\\n3. Now we need to insert new element `1`. The problem here is that when we insert it, we can have repeating answers, so the rule is: insert in only before the already existing occurrences of this element. So, in `[1,3]` we can only insert it before `1` and get `[1,1,3]` and in `[3,1]` we have two places to insert and we have `[1,3,1]` and `[3,1,1]`.\\n4. Finally, we want to insert `2` to the each of existing answers, and we have: `[2,1,1,3]`, `[1,2,1,3]`, `[1,1,2,3]`, `[1,1,3,2]`, `[2,1,3,1]`, `[1,2,3,1]`, `[1,3,2,1]`, `[1,3,1,2]`, `[2,3,1,1]`, `[3,2,1,1]`, `[3,1,2,1]`, `[3,1,1,2]` \\n\\n**Complexity**: Time complexity is `O(Q n)`, where `Q` is number of desired permutations and `n` is length of `nums`, because every time we build our sequence we write it in our final answer, that is there will be no dead-ends. `Q` can be evaluated, using multinomial coefficients https://en.wikipedia.org/wiki/Multinomial_theorem. Space complexity is the same. \\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        def dfs(ind, built):\\n            if ind == len(nums):\\n                ans.append(built)\\n                return\\n\\n            stop = built.index(nums[ind]) if nums[ind] in built else ind\\n            \\n            for i in range(stop+1):\\n                dfs(ind+1, built[:i]+[nums[ind]]+built[i:])\\n\\n        ans = []\\n        dfs(0, [])  \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        def dfs(ind, built):\\n            if ind == len(nums):\\n                ans.append(built)\\n                return\\n\\n            stop = built.index(nums[ind]) if nums[ind] in built else ind\\n            \\n            for i in range(stop+1):\\n                dfs(ind+1, built[:i]+[nums[ind]]+built[i:])\\n\\n        ans = []\\n        dfs(0, [])  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662237,
                "title": "c-backtracking",
                "content": "Same code as for problem 46. Permutations, with an extra if\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429532,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18630,
                "title": "java-iterative-solution-no-set-needed",
                "content": "In each iteration, put the new number to all possible place. \\nTo avoid duplicate we also have to:\\n1) For duplicate numbers in a row, only add same number in in front of them.\\n2) Break when same number exists in the permutation.\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            LinkedList<List<Integer>> r = new LinkedList<>();\\n            r.add(new ArrayList<Integer>());\\n            for(int i=0; i<nums.length; i++){\\n                int n = r.size();\\n                for(int j=0; j<n; j++){\\n                    List<Integer> list = r.poll();\\n                    for(int k=0; k<=list.size(); k++){\\n                        if(k > 0 && list.get(k-1) == nums[i])\\n                            break;\\n                        ArrayList<Integer> t = new ArrayList<>(list);\\n                        t.add(k, nums[i]);\\n                        r.offer(t);\\n                    }\\n                }\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            LinkedList<List<Integer>> r = new LinkedList<>();\\n            r.add(new ArrayList<Integer>());\\n            for(int i=0; i<nums.length; i++){\\n                int n = r.size();\\n                for(int j=0; j<n; j++){\\n                    List<Integer> list = r.poll();\\n                    for(int k=0; k<=list.size(); k++){\\n                        if(k > 0 && list.get(k-1) == nums[i])\\n                            break;\\n                        ArrayList<Integer> t = new ArrayList<>(list);\\n                        t.add(k, nums[i]);\\n                        r.offer(t);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 589917,
                "title": "c-solution",
                "content": "**Intuition**\\n![image](https://assets.leetcode.com/users/newbiecoder1/image_1587445651.png)\\n\\n**Complexity**\\n- Time: O(n! * n)\\n- Space: O(n! * n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**update on 6/17/2021**\\nwhy ```if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;``` can avoid duplicates?\\nFor example, nums = [1,1,2]\\nWe add the first 1 to the list, then we need to explore [1] + permutation of [1,2] (index 1 and 2)\\nWhen checking the second 1, if we don\\'t check whether the first 1 has been used, then we will cexplore [1] + permutation of [1,2] (index 0 and 2)\\n\\n![image](https://assets.leetcode.com/users/images/87da018f-1dfb-4b05-a00a-7aa26fcde8da_1637625422.2813182.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```\n```if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;```",
                "codeTag": "Java"
            },
            {
                "id": 278301,
                "title": "java-1ms-solution-which-beats-100-with-explanation-of-how-to-remove-duplicate",
                "content": "The key of the problem is duplicate removal. The solution contains three steps which is simple:\\n1. Sort the given array;\\n2. Use an boolean array ```used``` to record whether the element with corresponding index has been used;\\n2. Judge whether current element is equal to previous element (```nums[i] == nums[i - 1]```) and previous element is used or not (```used[i - 1]```).\\n\\n```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> current, int[] nums, boolean[] used) {\\n\\tif( current.size() == nums.length )\\n\\t\\tresultList.add(new ArrayList<Integer>(current));\\n\\telse{\\n\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif( used[i] || ( i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) ) // remove duplicate\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcurrent.add(nums[i]);\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\ttraverse(resultList, current, nums, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t\\tcurrent.remove(current.size() - 1);\\n\\t\\t}\\n\\t}\\n}\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\tArrays.sort(nums); // sort is necessary\\n\\tList<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n\\ttraverse(resultList, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n\\treturn resultList;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```used```\n```nums[i] == nums[i - 1]```\n```used[i - 1]```\n```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> current, int[] nums, boolean[] used) {\\n\\tif( current.size() == nums.length )\\n\\t\\tresultList.add(new ArrayList<Integer>(current));\\n\\telse{\\n\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif( used[i] || ( i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) ) // remove duplicate\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcurrent.add(nums[i]);\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\ttraverse(resultList, current, nums, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t\\tcurrent.remove(current.size() - 1);\\n\\t\\t}\\n\\t}\\n}\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\tArrays.sort(nums); // sort is necessary\\n\\tList<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n\\ttraverse(resultList, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n\\treturn resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179947,
                "title": "4ms-backtracking-java-with-explanations",
                "content": "**Thought**\\nWe think about the Search Tree when we apply Backtracking.\\n```\\n- 1 - 1 - 2\\n    - 2 - 1\\n\\n- X\\n\\n- 2 - 1 - 1\\n    - X\\n  \\nX means pruning to avoid duplicate permutations.\\n```\\nHow do we ensure the permutations to be unique?\\nThe elements with the same value should be used one by one in order. \\nSo we sort elements first, and prune the branch when an element is the same as the previous element but the previous element has not been used in current result.\\n**Code**\\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteUniqueRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteUniqueRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i] || (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])) {\\n                continue;\\n            }\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteUniqueRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\n- 1 - 1 - 2\\n    - 2 - 1\\n\\n- X\\n\\n- 2 - 1 - 1\\n    - X\\n  \\nX means pruning to avoid duplicate permutations.\\n```\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteUniqueRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteUniqueRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i] || (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])) {\\n                continue;\\n            }\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteUniqueRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031720,
                "title": "c-simple-backtrack-solution-with-comments-easy-to-understand",
                "content": "**1st approach** Straight forward DFS by using set (to store unique answers).\\n\\n***CODE ->***\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,set<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){            // Base case-> if temporsry vector size becomes equal to size of given list \\n            ans.insert(t);                // Before returning store the valid permutation inside the ans\\n            return ;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=11){            // check if the element is already included\\n                int j=nums[i];\\n                nums[i]=11;        // make the current ele to 11 (which is out of the range) so that we will not insert this element in next call\\n                t.push_back(j);      // store it in the temporary vector\\n                solve(nums,ans,t);  //recursively call to complete the permutations\\n                nums[i]=j;      // backtrack \\n                t.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>> s;          //to store unique permutations\\n        vector<vector<int>> ans;\\n        \\n        solve(nums,s,{});\\n        \\n        for(auto i:s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2nd Approach** A simple extension of permutation 1. You just need to skip the same element to create unique permutations.\\n\\n***CODE ->***\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,vector<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){\\n            ans.push_back(t);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=11){\\n\\t\\t\\t// The difference between the upper code and this code\\n\\t\\t\\t\\n            if(j>0 && nums[j]==nums[j-1]) continue;       // skip the element which has already been included\\n            int i=nums[j];\\n            nums[j]=11;\\n            t.push_back(i);\\n            solve(nums,ans,t);\\n            t.pop_back();\\n            nums[j]=i;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());          // sort the givern nums vector to check the consecutive elements\\n        vector<vector<int>> ans;\\n        solve(nums,ans,{});\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Please Upvote if you like the explaination : )**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,set<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){            // Base case-> if temporsry vector size becomes equal to size of given list \\n            ans.insert(t);                // Before returning store the valid permutation inside the ans\\n            return ;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=11){            // check if the element is already included\\n                int j=nums[i];\\n                nums[i]=11;        // make the current ele to 11 (which is out of the range) so that we will not insert this element in next call\\n                t.push_back(j);      // store it in the temporary vector\\n                solve(nums,ans,t);  //recursively call to complete the permutations\\n                nums[i]=j;      // backtrack \\n                t.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>> s;          //to store unique permutations\\n        vector<vector<int>> ans;\\n        \\n        solve(nums,s,{});\\n        \\n        for(auto i:s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,vector<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){\\n            ans.push_back(t);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=11){\\n\\t\\t\\t// The difference between the upper code and this code\\n\\t\\t\\t\\n            if(j>0 && nums[j]==nums[j-1]) continue;       // skip the element which has already been included\\n            int i=nums[j];\\n            nums[j]=11;\\n            t.push_back(i);\\n            solve(nums,ans,t);\\n            t.pop_back();\\n            nums[j]=i;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());          // sort the givern nums vector to check the consecutive elements\\n        vector<vector<int>> ans;\\n        solve(nums,ans,{});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949631,
                "title": "c-solution-with-time-complexity-analysis-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursion & HashMap.***\\n- Here we\\u2019ll first take all the elements count in hashmap, as there could be duplicated elements, this will help us not to take the same elements twice for the same location.\\n- In our help function, we\\u2019ll pass the index value and given array size.\\n- Base condition when current index will be equal to given array size then we\\u2019ll push temp in ans vector, `if(index == n) ans.push_back(temp)`\\n- Else we\\u2019ll iterate the map & push value one by one to temp, at any point if the map value became 0, we\\u2019ll continue from that.\\n- After the function call, we\\u2019ll remove the current element from temp & run the loop again.\\n- **Time complexity:** O(n*k), where k is the size of unique elements & n is the size of given array.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n    unordered_map<int, int> mp;\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(auto x:nums) mp[x]++;\\n        \\n        help(0, n);\\n        return ans;\\n    }\\n    \\n    void help(int index, int n){\\n        if(index == n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto k:mp){\\n            int key = k.first;\\n            int value = k.second;\\n            \\n            if(value == 0) continue;\\n            \\n            temp.push_back(key);\\n            mp[key]--;\\n            \\n            help(index+1, n);\\n            \\n            temp.pop_back();\\n            mp[key]++;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n    unordered_map<int, int> mp;\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(auto x:nums) mp[x]++;\\n        \\n        help(0, n);\\n        return ans;\\n    }\\n    \\n    void help(int index, int n){\\n        if(index == n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto k:mp){\\n            int key = k.first;\\n            int value = k.second;\\n            \\n            if(value == 0) continue;\\n            \\n            temp.push_back(key);\\n            mp[key]--;\\n            \\n            help(index+1, n);\\n            \\n            temp.pop_back();\\n            mp[key]++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309479,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18799,
                "title": "my-c-recursive-dfs-backtracking-solutions",
                "content": "Using an unordered_map to get all the distinct elements and the number of their occurence so that we don't need to do sorting. Then do dfs and backtracking to generate all the permutations: for each iteration, put each available distinct element (i.e. numMap->second >0) into path, update numMap, and do DFS at the next level. Once path has a length of len, then we get a new permutation and just add path to res.\\n\\n    class Solution {\\n    private: \\n        void  dfsHelper(vector<vector<int>>  &res, vector<int> &path, unordered_map<int, int> &numMap, int len)\\n        {\\n            if(path.size()==len) {res.push_back(path); return;}\\n            for(auto it = numMap.begin(); it != numMap.end(); ++it)\\n            {\\n                if(it->second)\\n                {\\n                    path.push_back(it->first); // update the current path\\n                    --(it->second); // and map\\n                    dfsHelper(res, path, numMap, len); // then do dfs at the next level\\n                    path.pop_back(); // backtracking by recovering path and map\\n                    ++(it->second);\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            int i,len = nums.size();\\n            vector<vector<int>> res;\\n            if(len>0)\\n            {\\n                vector<int> path;\\n\\n                unordered_map<int, int> numMap; //generate a map\\n                for(i=0; i<len; ++i) ++numMap[nums[i]];\\n\\n                dfsHelper(res, path, numMap, len);\\n            }\\n            return res;\\n            \\n            \\n        }\\n    };\\n\\nIf we do soring, then the unordered_map is not needed.\\n\\n    class Solution {\\n    private:\\n        void dfs(vector<vector<int>> &res, vector<int> &cur, vector<int> canVec, int len)\\n        {\\n            if(cur.size()==len)\\n            {\\n                res.push_back(cur);\\n            }\\n            else\\n            {\\n                for(auto i=0; i<canVec.size(); ++i)\\n                {\\n                    if(i>0 && canVec[i] == canVec[i-1] ) continue;\\n                    cur.push_back(canVec[i]);\\n                    vector<int> temp = canVec;\\n                    temp.erase(temp.begin()+i);\\n                    dfs(res, cur, temp, len);\\n                    cur.pop_back();\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            \\n            vector<vector<int>> res;    \\n            int  len = nums.size();\\n            if(len>0)\\n            {\\n                vector<int> cur;\\n                std::sort(nums.begin(), nums.end());\\n                dfs(res, cur, nums, len);\\n            }\\n            return res;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private: \\n        void  dfsHelper(vector<vector<int>>  &res, vector<int> &path, unordered_map<int, int> &numMap, int len)\\n        {\\n            if(path.size()==len) {res.push_back(path); return;}",
                "codeTag": "Java"
            },
            {
                "id": 249718,
                "title": "python-dfs-easy-to-understand",
                "content": "Inspired by the answer from Permutations by @caikehe\\nhttps://leetcode.com/problems/permutations/discuss/18296/Simple-Python-solution-(DFS).\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Inspired by the answer from Permutations by @caikehe\\nhttps://leetcode.com/problems/permutations/discuss/18296/Simple-Python-solution-(DFS).\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "codeTag": "Java"
            },
            {
                "id": 18760,
                "title": "small-modification-of-permutation-i-using-a-set",
                "content": "    public static List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        permute(nums,0,nums.length,res);\\n        return res;\\n    }\\n    public static void permute(int[] nums, int i, int j, List<List<Integer>> res){\\n        \\n        if(i == j-1){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int x:nums) list.add(x);\\n            res.add(list);\\n            return;\\n        }\\n        HashSet<Integer> visited= new HashSet<Integer>();\\n        for(int k=i;k<j;k++){\\n            if(!visited.contains(nums[k])){\\n                swap(nums,i,k);\\n                permute(nums,i+1,j,res);\\n                swap(nums,i,k);\\n                visited.add(nums[k]);\\n            }\\n            \\n        }\\n    }\\n    public static void swap(int[] nums, int i,int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }",
                "solutionTags": [],
                "code": "    public static List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        permute(nums,0,nums.length,res);\\n        return res;\\n    }\\n    public static void permute(int[] nums, int i, int j, List<List<Integer>> res){\\n        \\n        if(i == j-1){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int x:nums) list.add(x);\\n            res.add(list);\\n            return;\\n        }\\n        HashSet<Integer> visited= new HashSet<Integer>();\\n        for(int k=i;k<j;k++){\\n            if(!visited.contains(nums[k])){\\n                swap(nums,i,k);\\n                permute(nums,i+1,j,res);\\n                swap(nums,i,k);\\n                visited.add(nums[k]);\\n            }\\n            \\n        }\\n    }\\n    public static void swap(int[] nums, int i,int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18844,
                "title": "share-python-solution-without-using-set",
                "content": "Same idea as already in other posts, just the Python version for reference.\\n     \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        return self.permute(sorted(num))\\n        \\n    def permute(self, num):\\n        if len(num) == 1:\\n            return [num]\\n            \\n        ret = []\\n        for index, elt in enumerate(num):\\n            if index > 0 and num[index - 1] == elt:\\n                continue\\n            ret += [[elt] + p for p in self.permute(num[:index] + num[index + 1:])]\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same idea as already in other posts, just the Python version for reference.\\n     \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        return self.permute(sorted(num))\\n        \\n    def permute(self, num):\\n        if len(num) == 1:\\n            return [num]\\n            \\n        ret = []\\n        for index, elt in enumerate(num):\\n            if index > 0 and num[index - 1] == elt:\\n                continue\\n            ret += [[elt] + p for p in self.permute(num[:index] + num[index + 1:])]\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 2031147,
                "title": "simplest-bruteforce-100-faster-easy-understanding-without-backtracking",
                "content": "**next_permutation** is an inbuilt library.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> st;\\n        vector<int> temp = nums;\\n        do\\n        {\\n            next_permutation(temp.begin(), temp.end());\\n            st.insert(temp);\\n        } while (temp != nums);\\n        vector<vector<int>> ans;\\n        for (auto it: st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```\\nHope you like the solution.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> st;\\n        vector<int> temp = nums;\\n        do\\n        {\\n            next_permutation(temp.begin(), temp.end());\\n            st.insert(temp);\\n        } while (temp != nums);\\n        vector<vector<int>> ans;\\n        for (auto it: st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909423,
                "title": "100-fastest-swift-solution-time-o-n-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n!), where n is the length of the nums.\\n    //   - space: O(n), where n is the length of the nums.\\n\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var dict = [Int: Int]()\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n\\n        for num in nums { dict[num, default: 0] += 1 }\\n        backtrack(&comb, nums.count, &dict, &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(_ comb: inout [Int], _ n: Int, _ dict: inout [Int: Int], _ ans: inout [[Int]]) {\\n        guard comb.count != n else { ans.append(comb); return }\\n\\n        for (_, el) in dict.enumerated() {\\n            guard el.value != 0 else { continue }\\n            comb.append(el.key)\\n            dict[el.key, default: 0] -= 1\\n            backtrack(&comb, n, &dict, &ans)\\n            comb.removeLast()\\n            dict[el.key] = el.value\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n!), where n is the length of the nums.\\n    //   - space: O(n), where n is the length of the nums.\\n\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var dict = [Int: Int]()\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n\\n        for num in nums { dict[num, default: 0] += 1 }\\n        backtrack(&comb, nums.count, &dict, &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(_ comb: inout [Int], _ n: Int, _ dict: inout [Int: Int], _ ans: inout [[Int]]) {\\n        guard comb.count != n else { ans.append(comb); return }\\n\\n        for (_, el) in dict.enumerated() {\\n            guard el.value != 0 else { continue }\\n            comb.append(el.key)\\n            dict[el.key, default: 0] -= 1\\n            backtrack(&comb, n, &dict, &ans)\\n            comb.removeLast()\\n            dict[el.key] = el.value\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228299,
                "title": "c-nextpermutation-backtracking-using-extraw-space-backtracking-most-optimised-one",
                "content": "**1st Approach * C++ NextPermutation***\\n\\t\\n\\tvector<int> nextPermutation(vector<int>& nums) {\\n        int i,j;\\n        for( i=nums.size()-2; i>=0; i--)  if(nums[i]<nums[i+1]) break; \\n        if( i<0 ) {reverse(nums.begin(), nums.end());}\\n        else\\n        {\\n            for( j=nums.size()-1; j>i; j--) if(nums[j] > nums[i])break; \\n            swap(nums[j],nums[i]); \\n\\t\\t\\treverse(nums.begin()+i+1, nums.end());\\n        }\\n            return nums;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans; int n = nums.size(),fact =1;\\n        for(int i =1; i<=n ; i++) fact *= i;\\n        ans.push_back(nums);\\n        for(int i =0; i<fact; i++) ans.push_back(nextPermutation(ans[i]));\\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n\\t\\n**2nd Approach Backtracking(Extraw Space )**\\n\\t\\n\\tvoid solve(vector<int>&nums, vector<int>&temp, vector<int>&vst, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(temp.size()==nums.size()) \\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(!vst[i])\\n            { \\n                vst[i]=1;\\n                temp.push_back(nums[i]);\\n                solve(nums, temp, vst,ans);\\n                vst[i]=0;\\n                temp.pop_back();\\n            }\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans; \\n        vector<int>vst,temp;\\n        for(int i=0; i<nums.size();i++) vst.push_back(0);\\n        solve(nums,temp, vst, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**3rd Approach Backtracking Optimised**\\n\\t\\n\\t void solve(vector<int>&nums, int idx, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(idx==nums.size()) \\n        {\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=idx; i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[idx]);\\n            solve(nums,idx+1,ans);\\n            swap(nums[i],nums[idx]);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        solve(nums, 0, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**4rth Approach Using STL**\\n\\t\\n\\t    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        do\\n        {\\n            res.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "**1st Approach * C++ NextPermutation***\\n\\t\\n\\tvector<int> nextPermutation(vector<int>& nums) {\\n        int i,j;\\n        for( i=nums.size()-2; i>=0; i--)  if(nums[i]<nums[i+1]) break; \\n        if( i<0 ) {reverse(nums.begin(), nums.end());}\\n        else\\n        {\\n            for( j=nums.size()-1; j>i; j--) if(nums[j] > nums[i])break; \\n            swap(nums[j],nums[i]); \\n\\t\\t\\treverse(nums.begin()+i+1, nums.end());\\n        }\\n            return nums;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans; int n = nums.size(),fact =1;\\n        for(int i =1; i<=n ; i++) fact *= i;\\n        ans.push_back(nums);\\n        for(int i =0; i<fact; i++) ans.push_back(nextPermutation(ans[i]));\\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n\\t\\n**2nd Approach Backtracking(Extraw Space )**\\n\\t\\n\\tvoid solve(vector<int>&nums, vector<int>&temp, vector<int>&vst, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(temp.size()==nums.size()) \\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(!vst[i])\\n            { \\n                vst[i]=1;\\n                temp.push_back(nums[i]);\\n                solve(nums, temp, vst,ans);\\n                vst[i]=0;\\n                temp.pop_back();\\n            }\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans; \\n        vector<int>vst,temp;\\n        for(int i=0; i<nums.size();i++) vst.push_back(0);\\n        solve(nums,temp, vst, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**3rd Approach Backtracking Optimised**\\n\\t\\n\\t void solve(vector<int>&nums, int idx, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(idx==nums.size()) \\n        {\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=idx; i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[idx]);\\n            solve(nums,idx+1,ans);\\n            swap(nums[i],nums[idx]);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        solve(nums, 0, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**4rth Approach Using STL**\\n\\t\\n\\t    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        do\\n        {\\n            res.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 824487,
                "title": "2-java-solution-using-set",
                "content": "This question is similar to below 2 questions ->\\n\\nhttps://leetcode.com/problems/permutations/solutions/822916/simple-java-solution-recursive-0ms-100-faster\\n\\nhttps://leetcode.com/problems/subsets-ii/solutions/1767720/2-java-solution-with-and-without-set\\n\\n# Approach 1-> \\nit will take little more time as we are processing duplicate data also and at last just adding to set which will ignore duplicate list.\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(nums);\\n        helper(0,nums,ans);\\n        return new ArrayList<>(ans);\\n    }\\n    private void helper(int i,int[] nums,Set<List<Integer>> ans) {\\n        if(i==nums.length) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int item:nums) {\\n                list.add(item);\\n            }\\n            ans.add(list);\\n            return;\\n        }\\n        for(int j=i;j<nums.length;j++) {\\n            swap(nums,i,j);\\n            helper(i+1,nums,ans);\\n            swap(nums,i,j);\\n        }\\n    }\\n\\n    private void swap(int[] nums,int i,int j) {\\n        int t=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=t;\\n    }\\n}\\n```\\n\\n# Approach 2->\\nit is faster as here we are ignoring branch which cannot lead to answer.\\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    permute(nums, 0, list);\\n    return list;\\n}\\n\\nprivate void permute(int[] nums, int i, List<List<Integer>> list) {\\n    if (i == nums.length) {\\n        List<Integer> l1 = new ArrayList<>();\\n        for (int n : nums) {\\n            l1.add(n);\\n        }\\n        list.add(l1);\\n        return;\\n    }\\n    Set<Integer> set = new HashSet<>();\\n    for (int s = i; s < nums.length; s++) {\\n        if (set.add(nums[s])) {\\n            swap(nums, s, i);\\n            permute(nums, i + 1, list);\\n            swap(nums, s, i);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(nums);\\n        helper(0,nums,ans);\\n        return new ArrayList<>(ans);\\n    }\\n    private void helper(int i,int[] nums,Set<List<Integer>> ans) {\\n        if(i==nums.length) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int item:nums) {\\n                list.add(item);\\n            }\\n            ans.add(list);\\n            return;\\n        }\\n        for(int j=i;j<nums.length;j++) {\\n            swap(nums,i,j);\\n            helper(i+1,nums,ans);\\n            swap(nums,i,j);\\n        }\\n    }\\n\\n    private void swap(int[] nums,int i,int j) {\\n        int t=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=t;\\n    }\\n}\\n```\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    permute(nums, 0, list);\\n    return list;\\n}\\n\\nprivate void permute(int[] nums, int i, List<List<Integer>> list) {\\n    if (i == nums.length) {\\n        List<Integer> l1 = new ArrayList<>();\\n        for (int n : nums) {\\n            l1.add(n);\\n        }\\n        list.add(l1);\\n        return;\\n    }\\n    Set<Integer> set = new HashSet<>();\\n    for (int s = i; s < nums.length; s++) {\\n        if (set.add(nums[s])) {\\n            swap(nums, s, i);\\n            permute(nums, i + 1, list);\\n            swap(nums, s, i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124324,
                "title": "python-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        result = []\\n        self.permutation(nums, [],result)\\n        return result\\n\\n    def permutation(self, numbers, curr, result):\\n        if len(numbers) == 0:\\n            result.append(curr)\\n\\n        for i in range(len(numbers)):\\n            if i > 0 and numbers[i] == numbers[i-1]:\\n                continue\\n            self.permutation(numbers[0:i]+numbers[i+1:], curr + [numbers[i]], result)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        result = []\\n        self.permutation(nums, [],result)\\n        return result\\n\\n    def permutation(self, numbers, curr, result):\\n        if len(numbers) == 0:\\n            result.append(curr)\\n\\n        for i in range(len(numbers)):\\n            if i > 0 and numbers[i] == numbers[i-1]:\\n                continue\\n            self.permutation(numbers[0:i]+numbers[i+1:], curr + [numbers[i]], result)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18607,
                "title": "concise-java-solution-based-on-dfs",
                "content": "The basic idea is using DFS to put possible numbers to each i position, use boolean visited[] to flag the visited nodes, so that avoid accessing the same node many times. The tricky part of this problem is the solution for duplicated numbers: in the same position, only put one distinct number once.\\n\\n**For i position, there're (n-i) possibilities, so the total possilities are: n*(n-1)*(n-2)..1 = O(n!):**\\n\\n**Time complexity = O(n!)**\\n\\n    public LinkedList<List<Integer>> permuteUnique(int[] A) {\\n    \\t LinkedList<List<Integer>>res = new LinkedList<List<Integer>>();\\n    \\t Arrays.sort(A);//Sort the array first\\n    \\t DFS(A, new LinkedList<Integer>(), new boolean[A.length], res);\\n    \\t return res;\\n     }\\n     void DFS(int[] A,  LinkedList<Integer>solution, boolean visited[], LinkedList<List<Integer>>res) {\\n    \\t if (solution.size() == A.length) {\\n    \\t\\t res.add(new LinkedList<Integer>(solution));\\n    \\t\\t return;\\n    \\t }\\t\\t  \\n    \\t for (int i = 0; i < A.length; i++) {\\n    \\t     //Deal with duplicated numbers, visited[i-1] should be true. (In the same position, only put one distinct number)\\n    \\t\\t if (visited[i] || (i-1 >= 0 && visited[i-1] && A[i] == A[i-1]))\\n    \\t\\t\\t continue; \\n    \\t\\t visited[i] = true;\\n    \\t\\t solution.add(A[i]);\\n    \\t\\t DFS(A, solution, visited, res);\\n    \\t\\t solution.remove(solution.size()-1);\\n    \\t\\t visited[i] = false;\\t\\n    \\t }\\n     }",
                "solutionTags": [],
                "code": "The basic idea is using DFS to put possible numbers to each i position, use boolean visited[] to flag the visited nodes, so that avoid accessing the same node many times. The tricky part of this problem is the solution for duplicated numbers: in the same position, only put one distinct number once.\\n\\n**For i position, there're (n-i) possibilities, so the total possilities are: n*(n-1)*(n-2)..1 = O(n!):**\\n\\n**Time complexity = O(n!)**\\n\\n    public LinkedList<List<Integer>> permuteUnique(int[] A) {\\n    \\t LinkedList<List<Integer>>res = new LinkedList<List<Integer>>();\\n    \\t Arrays.sort(A);//Sort the array first\\n    \\t DFS(A, new LinkedList<Integer>(), new boolean[A.length], res);\\n    \\t return res;\\n     }\\n     void DFS(int[] A,  LinkedList<Integer>solution, boolean visited[], LinkedList<List<Integer>>res) {\\n    \\t if (solution.size() == A.length) {\\n    \\t\\t res.add(new LinkedList<Integer>(solution));\\n    \\t\\t return;\\n    \\t }\\t\\t  \\n    \\t for (int i = 0; i < A.length; i++) {\\n    \\t     //Deal with duplicated numbers, visited[i-1] should be true. (In the same position, only put one distinct number)\\n    \\t\\t if (visited[i] || (i-1 >= 0 && visited[i-1] && A[i] == A[i-1]))\\n    \\t\\t\\t continue; \\n    \\t\\t visited[i] = true;\\n    \\t\\t solution.add(A[i]);\\n    \\t\\t DFS(A, solution, visited, res);\\n    \\t\\t solution.remove(solution.size()-1);\\n    \\t\\t visited[i] = false;\\t\\n    \\t }\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 18825,
                "title": "c-solution-adapted-from-the-most-voted-permutations-i-solution-of-mine",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            vector<vector<int> > result;\\n            \\n            permuteRecursive(num, 0, result);\\n            return result;\\n        }\\n     \\n        void permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)    {\\n            if (begin >= num.size()) {\\n                result.push_back(num);\\n                return;\\n            }\\n            \\n            // detect duplicate        \\n            unordered_set<int> set;\\n            for (int i = begin; i < num.size(); i++) {\\n                if (set.count(num[i]) > 0)\\n                    continue;\\n                set.insert(num[i]);\\n                \\n                swap(num[begin], num[i]);\\n                permuteRecursive(num, begin + 1, result);\\n                swap(num[begin], num[i]);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            vector<vector<int> > result;\\n            \\n            permuteRecursive(num, 0, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3385921,
                "title": "97-beats-c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefault backtrack solution. If elements are similar we dont need to swap them because we will get the same permutation, so we use ``` ++pos; ``` in loop to find different from ```nums[i]``` number. After all we should use ```pos = i;``` for use correct pos in next itteration. \\n\\n# Complexity\\n- Time complexity: suggest\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N! (if all numbers are unique there is N! factorial possible permutations)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currSubset;\\n\\n        std::sort(nums.begin(), nums.end());\\n        permutations(nums, 0, output);\\n\\n        return output;\\n    }\\nprivate:\\n    void permutations(std::vector<int> const& nums, int pos, std::vector<std::vector<int>>& output) {\\n        output.push_back(nums);\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            auto tmp = nums;\\n            while (pos < nums.size()-1) {\\n                ++pos;\\n                if (tmp[i] != tmp[pos]) {\\n                    std::swap(tmp[i], tmp[pos]);\\n                    permutations(tmp, i+1, output);\\n                }\\n            }\\n            pos = i;\\n        }\\n    }\\n};\\n```\\n![o7i7nDOFhCs.jpg](https://assets.leetcode.com/users/images/2b0d907c-3d3d-462f-b60e-8ecd1e45c4e5_1680844815.8535395.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` ++pos; ```\n```nums[i]```\n```pos = i;```\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currSubset;\\n\\n        std::sort(nums.begin(), nums.end());\\n        permutations(nums, 0, output);\\n\\n        return output;\\n    }\\nprivate:\\n    void permutations(std::vector<int> const& nums, int pos, std::vector<std::vector<int>>& output) {\\n        output.push_back(nums);\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            auto tmp = nums;\\n            while (pos < nums.size()-1) {\\n                ++pos;\\n                if (tmp[i] != tmp[pos]) {\\n                    std::swap(tmp[i], tmp[pos]);\\n                    permutations(tmp, i+1, output);\\n                }\\n            }\\n            pos = i;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140136,
                "title": "c-simple-and-efficient-2-different-solutions",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n*Note :This question is very similar to the [Permutations](https://leetcode.com/problems/permutations/) problem and I already explained that in detail [here](https://leetcode.com/problems/permutations/discuss/1140113/Clear-and-simple-explanation-(2-approach)-with-intuition%3A-100-faster) , so I am going to just tell the change thats going to be made for this particular question .*\\n\\n**Concept:** When the pointers(`i` and `idx`) are not equal but the elements are equal, we have to skip that combination but the problem that arises is that it can\\'t distinguish if the order is different between two combinations. For instance: `1,2,4]!=[4,2,1]` acc to our condition, but this can\\'t be distinguished , unless the ordering is same between the two....\\n\\nAnd to maintain the relative order, we do **sorting**.\\n\\n**Approach 1:** Using next_permutation\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n};\\n```\\n**Approach 2:** Backtracking\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void helper(vector<int> nums,int idx)\\n    {\\n        if(idx==nums.size())\\n        {\\n            ans.push_back(nums);\\n        }\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            if(i!=idx && nums[i]==nums[idx])    continue;\\n            swap(nums[i],nums[idx]);\\n            helper(nums,idx+1);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        helper(nums, 0);\\n        return ans;\\n    }\\n};\\n```\\n*Note: You can also use **find** method or use **for** loop and then check before adding in \"ans\" if it exists or not ,instead of sorting and doing what I did above, but I did that and the runtime was 700ms in that case, hence I didn\\'t include that. This code is optimised version of that raw code.*\\n\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you have any doubts regarding anything , please ask in comments!!!\\nIf you like, please **UPVOTE**\\nHappy Coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void helper(vector<int> nums,int idx)\\n    {\\n        if(idx==nums.size())\\n        {\\n            ans.push_back(nums);\\n        }\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            if(i!=idx && nums[i]==nums[idx])    continue;\\n            swap(nums[i],nums[idx]);\\n            helper(nums,idx+1);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        helper(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360071,
                "title": "explaining-the-used-array-trick",
                "content": "When a number has the same value with its previous, we can use this number only if its previous number (in sorted input array) is used.\\n\\nExplanation: \\n\\nA number which is equal to its previous number can be used only if its previous number has already been used, in this way we can make sure that in the resulting permutations, groups of same numbers will always have the same ordering between them. Thus we no longer have the problems of duplicates resulting permutations.\\n\\nFor example, for the array `aaabb`. The second `b` cannot be used if the first `b` has not been put somewhere in the current permutation. With the same logic, the second `a` cannot be used if the first `a` has not been put somewhere in the current permutation, the third `a` cannot be used if the second `a` has not been put somewhere in the current permutation. \\n\\nHere, `previous` means the ordering in the sorted input array `nums`.\\n\\nAs we have duplicates in input array `nums`, each number can be uniquely identified with their ordering index in the sorted input array `nums`. \\n\\n```\\n\\tvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(res, nums, current, used);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current, vector<bool>& used){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(!used[i]){\\n                if(i == 0 || nums[i] != nums[i - 1] || used[i - 1]){\\n                    used[i] = true;\\n                    current.push_back(nums[i]);\\n                    backtrack(res, nums, current, used);\\n                    used[i] = false;\\n                    current.pop_back();\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n\\tvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(res, nums, current, used);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current, vector<bool>& used){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(!used[i]){\\n                if(i == 0 || nums[i] != nums[i - 1] || used[i - 1]){\\n                    used[i] = true;\\n                    current.push_back(nums[i]);\\n                    backtrack(res, nums, current, used);\\n                    used[i] = false;\\n                    current.pop_back();\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217564,
                "title": "javascript-o-n-n-time-and-space-backtracking",
                "content": "```javascript\\n/**\\n * Time: O(n * n!)\\n * Space: O(n * n!)\\n * n - # of nums\\n */\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nfunction permuteUnique(nums) {\\n  const solutions = [];\\n  nums.sort((a, b) => a - b);\\n  findPermutations(nums, solutions, [], new Set());\\n  return solutions;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} solutions\\n * @param {number[]} current\\n * @param {Set} used\\n */\\nfunction findPermutations(nums, solutions, current, used) {\\n  if (current.length === nums.length) {\\n    return solutions.push(current.slice());\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (used.has(i)) {\\n      continue;\\n    }\\n\\n    // If current matches previous, only continue if previous is used\\n    if (i > 0 && nums[i] === nums[i - 1] && !used.has(i - 1)) {\\n      continue;\\n    }\\n\\n    current.push(nums[i]);\\n    used.add(i);\\n    findPermutations(nums, solutions, current, used);\\n    current.pop();\\n    used.delete(i);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n * n!)\\n * Space: O(n * n!)\\n * n - # of nums\\n */\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nfunction permuteUnique(nums) {\\n  const solutions = [];\\n  nums.sort((a, b) => a - b);\\n  findPermutations(nums, solutions, [], new Set());\\n  return solutions;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} solutions\\n * @param {number[]} current\\n * @param {Set} used\\n */\\nfunction findPermutations(nums, solutions, current, used) {\\n  if (current.length === nums.length) {\\n    return solutions.push(current.slice());\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (used.has(i)) {\\n      continue;\\n    }\\n\\n    // If current matches previous, only continue if previous is used\\n    if (i > 0 && nums[i] === nums[i - 1] && !used.has(i - 1)) {\\n      continue;\\n    }\\n\\n    current.push(nums[i]);\\n    used.add(i);\\n    findPermutations(nums, solutions, current, used);\\n    current.pop();\\n    used.delete(i);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18613,
                "title": "13-lines-c-backtracking",
                "content": "My [solution](https://discuss.leetcode.com/topic/94915/backtracking-clean-c-recursion-with-detailed-explanation) for [**Permutations I**](https://leetcode.com/problems/permutations/description/).\n\nSolution for **Permutations II** is similar to **Permutations I**, the only difference is that we **CAN'T** swap back after each permutation, cause we want to pick a new different number for position `i` in each loop.\n\nFor example, suppose array nums = [1, 1, 2, 2, 3], first we swap nums[0] = 1 with the first different number nums[2] = 2, after first swap, nums = [2, 1, 1, 2, 3], then if we swap back `1` with `2`,  nums = [1, 1, 2, 2, 3].\n\nNow, we want to pick nums[4] = 3 as a new number for position `0`, but nums[3] = 2 would be considered the new different number because we swaped the number '1' back to position `0`, so we will swap nums[0] with nums[3], nums = [2, 1, 2, 1, 3], so the same number '2' appears twice at position `0`, which caused the repeated outcomes.\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>>res;\n        DFS(res, nums, 0);\n        return res;        \n    }\n    \n    void DFS(vector<vector<int>>& res, vector<int> nums, int pos){\n        if(pos == nums.size() - 1){\n            res.push_back(nums);\n            return;\n        }\n        for(int i = pos; i < nums.size(); i++){\n            if(i != pos && nums[i] == nums[pos]) continue;\n            swap(nums[pos], nums[i]);\n            DFS(res, nums, pos + 1);\n        }\n    }\n};\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\nclass Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>>res;\n        DFS(res, nums, 0);\n        return res;        \n    }\n    \n    void DFS(vector<vector<int>>& res, vector<int> nums, int pos){\n        if(pos == nums.size() - 1){\n            res.push_back(nums);\n            return;\n        }\n        for(int i = pos; i < nums.size(); i++){\n            if(i != pos && nums[i] == nums[pos]) continue;\n            swap(nums[pos], nums[i]);\n            DFS(res, nums, pos + 1);\n        }\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 18615,
                "title": "difference-and-explanation-between-subset-i-ii-and-perm-i-ii-simple-sol-listed",
                "content": "There are many good posts explaining the backtrack idea of these two topics. \\n\\nThe subset and permutation problems all have similar code. However, I did not find one that explains the difference between them. And despite the fact that they have similar code, actually they are very different.\\n\\n\\n* subset I, II\\nMy codes are similar to many others: push one element into the vector and then recursively call the function. After that pop that element out.\\n**Explanation:** The subset problem is all about **choice**, whether you want certain element inside the vector or not. For example, [1, 2, 3], starting with pos = 0. At pos = 0, you push 1 into temp, then recursively call the function. Then this reclusive call is a \"crossroad\". Inside the call (with all other calls inside), you have the \"1\" chosen and every vector you produce will begin with 1. When the call returns (ie. you pop 1 out), you are on the other road of the crossroad, which does not contain 1. These are just the first \"choice\" you are faced. And after that you face with other similar choices. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n**subset II :** Eliminate the dup with sort and then the condition: do not put this element inside, if it has same element before && the former dup has not been put into it. Because otherwise, you better off put the former dup into the vector instead of this (latter dup) one. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n* Permutation I, II\\nPermutation I is a very typical problem. \\n\\n**Note:** the pos here is different with the pos in subset. The pos in subset is more like choice in front of crossroad while the pos in permutation is the \"digit\" you are considering. In other words, you you consider the elements one by one: which one should be the first? which one should be the second? ...and so on. The **pos** is just the \"first\", \"second\"...\\n\\nWhen you consider the n**th** element, you swap the n**th** with element from n**th** to the last one, so that every element after that will have a chance to stay in the n**th** position. You recursively call, after each case.\\n\\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\npermutation II\\nI prefer to use the unordered_map to solve the dup problem. How does it solve the problem? because it treats all the dup as one element with several copies. \\n\\nFor example, [1, 1, 2], when you iterate, in the same \"level\", the 1 will only be put once. We only put the other 1 into the vector in the recursive call in next levels.\\n\\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477601,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n*n!)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/b074654c-3a20-4c40-8faf-f265fc22c19b_1683031288.086733.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        // Create a list to store the final results\\n        List<List<Integer>> res = new ArrayList<>();\\n        // Sort the input array to group duplicates together\\n        Arrays.sort(nums);\\n        // Create a boolean array to keep track of used numbers\\n        boolean[] used = new boolean[nums.length];\\n        // Call the recursive backtrack method to generate all permutations\\n        backtrack(nums, used, new ArrayList<>(), res);\\n        // Return the list of permutations\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, boolean[] used, List<Integer> curr, List<List<Integer>> res) {\\n        // If the current permutation is complete, add it to the results list\\n        if (curr.size() == nums.length) {\\n            res.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        // Loop through the indices of the input array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Skip if the number has already been used or if it\\'s a duplicate that has already been used\\n            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) {\\n                continue;\\n            }\\n            // Mark the current number as used, add it to the current permutation list\\n            used[i] = true;\\n            curr.add(nums[i]);\\n            // Recursively call backtrack to generate all permutations\\n            backtrack(nums, used, curr, res);\\n            // Mark the current number as unused, remove it from the current permutation list\\n            used[i] = false;\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        // Create a list to store the final results\\n        List<List<Integer>> res = new ArrayList<>();\\n        // Sort the input array to group duplicates together\\n        Arrays.sort(nums);\\n        // Create a boolean array to keep track of used numbers\\n        boolean[] used = new boolean[nums.length];\\n        // Call the recursive backtrack method to generate all permutations\\n        backtrack(nums, used, new ArrayList<>(), res);\\n        // Return the list of permutations\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, boolean[] used, List<Integer> curr, List<List<Integer>> res) {\\n        // If the current permutation is complete, add it to the results list\\n        if (curr.size() == nums.length) {\\n            res.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        // Loop through the indices of the input array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Skip if the number has already been used or if it\\'s a duplicate that has already been used\\n            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) {\\n                continue;\\n            }\\n            // Mark the current number as used, add it to the current permutation list\\n            used[i] = true;\\n            curr.add(nums[i]);\\n            // Recursively call backtrack to generate all permutations\\n            backtrack(nums, used, curr, res);\\n            // Mark the current number as unused, remove it from the current permutation list\\n            used[i] = false;\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666977,
                "title": "python-backtracking-faster-96-detailed-explanation-and-visualization",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = [False] * len(nums)\\n        \\n        nums.sort()\\n        \\n        def backtracking(nums, res):\\n            # GOAL / Base case\\n            if len(res) == n:\\n                ans.append(res[:])\\n                return\\n            \\n            for i in range(len(nums)):\\n                # CONSTRAINTs\\n                # if current element is duplicated of previous one\\n                if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\\n                    continue\\n                \\n                # Make CHOICE\\n                res.append(nums[i])\\n                \\n                # BACKTRACKING\\n                visited[i] = True\\n                backtracking(nums, res)\\n                \\n                # RESET STATE\\n                visited[i] = False\\n                res.pop()\\n        \\n\\t\\t# Inital state\\n        backtracking(nums, [])\\n        return ans\\n        \\n```\\n\\nand visual explanation -\\n![image](https://assets.leetcode.com/users/images/f39f3270-e403-46a3-96c5-3ef4287d0217_1667010361.5402923.png)\\n\\n\\nPlease vote if you like my solution :D\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = [False] * len(nums)\\n        \\n        nums.sort()\\n        \\n        def backtracking(nums, res):\\n            # GOAL / Base case\\n            if len(res) == n:\\n                ans.append(res[:])\\n                return\\n            \\n            for i in range(len(nums)):\\n                # CONSTRAINTs\\n                # if current element is duplicated of previous one\\n                if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\\n                    continue\\n                \\n                # Make CHOICE\\n                res.append(nums[i])\\n                \\n                # BACKTRACKING\\n                visited[i] = True\\n                backtracking(nums, res)\\n                \\n                # RESET STATE\\n                visited[i] = False\\n                res.pop()\\n        \\n\\t\\t# Inital state\\n        backtracking(nums, [])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032690,
                "title": "c-easy-understanding-comments-with-picture-daily-leetcoding-challenge-may-day-12",
                "content": "**Please Upvote If It Helps**\\n\\n**![image](https://assets.leetcode.com/users/images/a25c51ac-74ea-4f44-b0a4-aa9b03225be4_1652378764.7523286.jpeg)\\n**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, set<vector<int>>& st, vector<int>& nums, int n)\\n    {\\n        // if our idx reaches to the n then store that vector into set\\n        if(idx==n)\\n        {\\n            st.insert(nums);\\n            return;\\n        }\\n        \\n        // now iterating over the given vector size\\n        // because we need , vector size subsets\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            // just swap the values and store them after swaping \\n            swap(nums[i],nums[idx]);\\n            \\n            helper(idx+1,st,nums,nums.size());\\n            \\n            // after taking them as a subset again swap them to make them as it is for next iteration\\n            swap(nums[i],nums[idx]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        // making a set that will store only unique values\\n        set<vector<int>> st;\\n        \\n        // it will help in determining the all permutations\\n        helper(0,st,nums,nums.size());\\n        \\n        // copying all the set values into a 2D vector because our main function return type is 2D vector \\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, set<vector<int>>& st, vector<int>& nums, int n)\\n    {\\n        // if our idx reaches to the n then store that vector into set\\n        if(idx==n)\\n        {\\n            st.insert(nums);\\n            return;\\n        }\\n        \\n        // now iterating over the given vector size\\n        // because we need , vector size subsets\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            // just swap the values and store them after swaping \\n            swap(nums[i],nums[idx]);\\n            \\n            helper(idx+1,st,nums,nums.size());\\n            \\n            // after taking them as a subset again swap them to make them as it is for next iteration\\n            swap(nums[i],nums[idx]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        // making a set that will store only unique values\\n        set<vector<int>> st;\\n        \\n        // it will help in determining the all permutations\\n        helper(0,st,nums,nums.size());\\n        \\n        // copying all the set values into a 2D vector because our main function return type is 2D vector \\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031755,
                "title": "properly-explained-c-backtrack-solution-explained-with-comments",
                "content": "**Easy Recursive Solution \\nUpvote for Explaination :D**\\n\\n```\\n vector<vector<int>> ans ;\\n    \\n    void helper( vector<int> &nums, int cnt, int n ){\\n        \\n        // If cnt == nums.size we have got our one combination \\n        // Push it inside our answer \\n        if( cnt == n ) {\\n            ans.push_back( nums ) ;\\n            return ;\\n        }\\n        \\n        unordered_set<int> s ;      // Set ensures that one element is placed once at every ith position  \\n        for( int i=cnt ; i<n ; i++ ){\\n            \\n            // If we have used the number at this ith position previously then just ignore this and continue to next number \\n            if( s.find(nums[i]) != s.end() )  \\n                continue ;  \\n            else s.insert(nums[i]);      // If we have not used the number then insert it for next verification\\n            \\n            swap( nums[i], nums[cnt] );       // Create a combination \\n            helper( nums, cnt+1, n ) ;        // Find out all possible combinations with the created one \\n            swap( nums[i], nums[cnt] );       // Backtracking \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        helper( nums, 0, n);\\n        return ans ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n vector<vector<int>> ans ;\\n    \\n    void helper( vector<int> &nums, int cnt, int n ){\\n        \\n        // If cnt == nums.size we have got our one combination \\n        // Push it inside our answer \\n        if( cnt == n ) {\\n            ans.push_back( nums ) ;\\n            return ;\\n        }\\n        \\n        unordered_set<int> s ;      // Set ensures that one element is placed once at every ith position  \\n        for( int i=cnt ; i<n ; i++ ){\\n            \\n            // If we have used the number at this ith position previously then just ignore this and continue to next number \\n            if( s.find(nums[i]) != s.end() )  \\n                continue ;  \\n            else s.insert(nums[i]);      // If we have not used the number then insert it for next verification\\n            \\n            swap( nums[i], nums[cnt] );       // Create a combination \\n            helper( nums, cnt+1, n ) ;        // Find out all possible combinations with the created one \\n            swap( nums[i], nums[cnt] );       // Backtracking \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        helper( nums, 0, n);\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682486,
                "title": "javascript-backtracking-solution-with-written-intuition",
                "content": "Time: `O(n!)` - Each `dfs` call makes (n-1) `dfs` calls\\nSpace: `O(n!)` - If all nums are unique, a unique combo is yielded at end of every branch.\\n\\nStrategy and Intuition\\n\\n* When asked for combos, it\\'s a good bet that we can use a recursive approach.\\n* To place an item once per combo, we\\'ll need to save info about the indicies we\\'ve visited.\\n* To meet the condition for unique combos, we\\'ll need a way to \"skip\" over nums that have already yielded combos.  Sorting helps us check if the curr num is a repeat one.\\n* Every `dfs` call has 3 steps.\\n\\t1) Add `i` to visited\\n\\t2) Call `dfs`\\n\\t3) Remove `i` from visited (this is the backtracking step)\\n* In plain English, \"skip\" the current `i` when:\\n\\t* We\\'ve already been to the index in an earlier call to `dfs`\\n\\t\\t* `if (visited.has(i)) continue;`\\n\\t* The curr num is the same as the prev num AND we haven\\'t seen the prev index\\n\\t\\t* `if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;`\\n* **Preventing Duplicates**\\n\\t* Any subsequent repeat nums will yield duplicate combos if not handled.\\n\\t* Take the input `[a1, a2, b1]` which yields combos `[a1, a2, b1], [a2, a1, b1]`\\n\\t\\t* To prevent this, simply stop `a2` from being added before `a1`\\n\\t\\t* Thus, `!visited.has(i-1)) continue;`\\n\\nHope this helps!\\n```\\nvar permuteUnique = function(nums) {\\n    let res = [];\\n    dfs(nums.sort(), res, new Set());\\n    return res;\\n};\\n\\nconst dfs = (nums, res, visited) => {\\n    if (nums.length === visited.size) {\\n        let arr = [];\\n        for (let idx of visited) {\\n            arr.push(nums[idx]);\\n        }\\n        res.push(arr);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {         \\n        if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;\\n        if (visited.has(i)) continue;\\n        visited.add(i);\\n        dfs(nums, res, visited);\\n        visited.delete(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let res = [];\\n    dfs(nums.sort(), res, new Set());\\n    return res;\\n};\\n\\nconst dfs = (nums, res, visited) => {\\n    if (nums.length === visited.size) {\\n        let arr = [];\\n        for (let idx of visited) {\\n            arr.push(nums[idx]);\\n        }\\n        res.push(arr);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {         \\n        if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;\\n        if (visited.has(i)) continue;\\n        visited.add(i);\\n        dfs(nums, res, visited);\\n        visited.delete(i);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501603,
                "title": "backtracking-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    set<vector<int>> ans;\\n    void permutation(vector<int>& nums, int i){\\n        if(i==nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int j=i;j<nums.size();j++){\\n            swap(nums[i],nums[j]);\\n            permutation(nums,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    \\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permutation(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    set<vector<int>> ans;\\n    void permutation(vector<int>& nums, int i){\\n        if(i==nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int j=i;j<nums.size();j++){\\n            swap(nums[i],nums[j]);\\n            permutation(nums,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    \\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permutation(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434637,
                "title": "simple-c-solution-with-explanation",
                "content": "Prerequisite -> How to find all permutations of a string.\\n\\nHere, We just have to make sure, every time we swap two positions, then we are swapping unique numbers. So we can take a hashMap, and store whether we have already swapped this number or not.\\nIf Swapped , then skip this recursvie call.\\nelse call the function and mark the number as swapped or true.\\n\\nHere is Implementation of the above approach.\\n\\nPLEASE UPVOTE, IF YOU LIKE MY CODE & APPROACH.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<vector<int>> &res, vector<int> nums, int idx) {\\n        if(idx == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        \\n        unordered_map<int, bool> mp;\\n        for(int i = idx; i < nums.size(); i++) {\\n            if(mp[nums[i]]) continue;\\n            mp[nums[i]] = true;\\n            swap(nums[i], nums[idx]);\\n            solve(res, nums, idx + 1);\\n            swap(nums[i], nums[idx]);\\n        }\\n        return;\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        solve(res, nums, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<vector<int>> &res, vector<int> nums, int idx) {\\n        if(idx == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        \\n        unordered_map<int, bool> mp;\\n        for(int i = idx; i < nums.size(); i++) {\\n            if(mp[nums[i]]) continue;\\n            mp[nums[i]] = true;\\n            swap(nums[i], nums[idx]);\\n            solve(res, nums, idx + 1);\\n            swap(nums[i], nums[idx]);\\n        }\\n        return;\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        solve(res, nums, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893745,
                "title": "very-easy-recursive-js-solution",
                "content": "```\\nfunction permuteUnique(nums: number[]): number[][] {\\n    const numberOfItems: number = nums.length;\\n    const map: Map<number, number> = new Map(); // (item, # of available times)\\n    const numsWithNoDuplicate: number[] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (map.has(num)) {\\n            map.set(num, map.get(num) + 1);\\n        } else {\\n            map.set(num, 1);\\n            numsWithNoDuplicate.push(num);\\n        }\\n    }\\n    \\n    const result: number[][] = [];\\n    const currPath: number[] = [];\\n    \\n    permute(numberOfItems, numsWithNoDuplicate, currPath, map, result);\\n    \\n    return result;\\n    // N = the number of items in the given array\\n    // T.C: O(N!)\\n    // S.C: O(N)\\n};\\n\\nfunction permute(numberOfItems: number, nums: number[], currPath: number[], map: Map<number,number>, result: number[][]) {\\n    if (currPath.length === numberOfItems) {\\n        const newArray: number[] = currPath.slice();\\n        result.push(newArray);\\n        return;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        const num: number = nums[i];\\n        if (map.get(num) > 0) {\\n            currPath.push(num);\\n            map.set(num, map.get(num) - 1);\\n            \\n            permute(numberOfItems, nums, currPath, map, result)\\n            \\n            currPath.pop();\\n            map.set(num, map.get(num) + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction permuteUnique(nums: number[]): number[][] {\\n    const numberOfItems: number = nums.length;\\n    const map: Map<number, number> = new Map(); // (item, # of available times)\\n    const numsWithNoDuplicate: number[] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (map.has(num)) {\\n            map.set(num, map.get(num) + 1);\\n        } else {\\n            map.set(num, 1);\\n            numsWithNoDuplicate.push(num);\\n        }\\n    }\\n    \\n    const result: number[][] = [];\\n    const currPath: number[] = [];\\n    \\n    permute(numberOfItems, numsWithNoDuplicate, currPath, map, result);\\n    \\n    return result;\\n    // N = the number of items in the given array\\n    // T.C: O(N!)\\n    // S.C: O(N)\\n};\\n\\nfunction permute(numberOfItems: number, nums: number[], currPath: number[], map: Map<number,number>, result: number[][]) {\\n    if (currPath.length === numberOfItems) {\\n        const newArray: number[] = currPath.slice();\\n        result.push(newArray);\\n        return;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        const num: number = nums[i];\\n        if (map.get(num) > 0) {\\n            currPath.push(num);\\n            map.set(num, map.get(num) - 1);\\n            \\n            permute(numberOfItems, nums, currPath, map, result)\\n            \\n            currPath.pop();\\n            map.set(num, map.get(num) + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460214,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    private void Helper(IList<IList<int>> res, int idx, int[] nums)\\n    {\\n        if (idx == nums.Length)\\n        {\\n            res.Add(nums.ToList());\\n            return;\\n        }\\n\\n        ISet<int> visited = new HashSet<int>();\\n\\n        for (int i = idx; i < nums.Length; i++)\\n        {\\n            if (!visited.Add(nums[i]))\\n            {\\n                continue;\\n            }\\n\\n            var tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n\\n            Helper(res, idx + 1, nums);\\n\\n            tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n        }\\n\\n    }\\n\\n    public IList<IList<int>> PermuteUnique(int[] nums)\\n    {\\n        IList<IList<int>> res = new List<IList<int>>();\\n        Helper(res, 0, nums);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private void Helper(IList<IList<int>> res, int idx, int[] nums)\\n    {\\n        if (idx == nums.Length)\\n        {\\n            res.Add(nums.ToList());\\n            return;\\n        }\\n\\n        ISet<int> visited = new HashSet<int>();\\n\\n        for (int i = idx; i < nums.Length; i++)\\n        {\\n            if (!visited.Add(nums[i]))\\n            {\\n                continue;\\n            }\\n\\n            var tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n\\n            Helper(res, idx + 1, nums);\\n\\n            tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n        }\\n\\n    }\\n\\n    public IList<IList<int>> PermuteUnique(int[] nums)\\n    {\\n        IList<IList<int>> res = new List<IList<int>>();\\n        Helper(res, 0, nums);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072933,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<vector<int>> ans;\\n    void f(vector<int> A,int l)\\n    {\\n        if(l==A.size())\\n        {\\n            ans.push_back(A);\\n            return;\\n        }\\n        unordered_set<int> seen;  \\n        for(int i=l;i<A.size();i++)\\n        {\\n            if(seen.find(A[i])!=seen.end())\\n            continue;\\n            swap(A[i],A[l]);\\n            f(A,l+1);\\n            swap(A[i],A[l]);\\n            seen.insert(A[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        f(nums,0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<vector<int>> ans;\\n    void f(vector<int> A,int l)\\n    {\\n        if(l==A.size())\\n        {\\n            ans.push_back(A);\\n            return;\\n        }\\n        unordered_set<int> seen;  \\n        for(int i=l;i<A.size();i++)\\n        {\\n            if(seen.find(A[i])!=seen.end())\\n            continue;\\n            swap(A[i],A[l]);\\n            f(A,l+1);\\n            swap(A[i],A[l]);\\n            seen.insert(A[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        f(nums,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661167,
                "title": "c-recursion-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n     void solution(vector<int> nums,int index,vector<vector<int>>& ans){\\n        if(index==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        unordered_set<int> st;\\n       for(int j=index;j<nums.size();j++){\\n           if(st.find(nums[j])!=st.end()) continue;\\n           st.insert(nums[j]);\\n           swap(nums[index],nums[j]);\\n           solution(nums,index+1,ans);\\n           swap(nums[index],nums[j]);\\n       }\\n     }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solution(nums,index,ans);\\n        return ans;        \\n    }\\n};\\n```Plz upvote if you like the code..",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n     void solution(vector<int> nums,int index,vector<vector<int>>& ans){\\n        if(index==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        unordered_set<int> st;\\n       for(int j=index;j<nums.size();j++){\\n           if(st.find(nums[j])!=st.end()) continue;\\n           st.insert(nums[j]);\\n           swap(nums[index],nums[j]);\\n           solution(nums,index+1,ans);\\n           swap(nums[index],nums[j]);\\n       }\\n     }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solution(nums,index,ans);\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030892,
                "title": "simple-swapping",
                "content": "The question is very similar to permutation 1 to understand this ,one must be familiar with permutation1 ,the only difference i sthat we are not suppose to take repeated element, that problem was solved earlier using set,but it used to take extra time, so i came up with new approach that we don\\'t need to store extras \\n```\\nclass Solution {\\n    List<List<Integer>>ans= new ArrayList<>();\\n    public void swap(int i,int j,int[]nums){\\n        int k=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=k;\\n    }\\n    \\n    public void fun(int k, int[]nums){\\n        if(k==nums.length){\\n            List<Integer>a= new ArrayList<>();\\n        for(int x:nums)a.add(x);\\n            ans.add(a);\\n            return;\\n        }\\n        HashSet<Integer>s=new HashSet<>();\\n\\t\\t//here i\\'m creating an hash set for one recurrsion\\n        for(int i=k;i<nums.length;i++){\\n\\t\\t//there i\\'m checking and making sure that nums[i] is not getting repeteation \\n          if(s.contains(nums[i]))continue;\\n            s.add(nums[i]);\\n            swap(i,k,nums);\\n            fun(k+1,nums);\\n            swap(i,k,nums);\\n       \\n        }\\n    }\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n    fun(0,nums);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>>ans= new ArrayList<>();\\n    public void swap(int i,int j,int[]nums){\\n        int k=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=k;\\n    }\\n    \\n    public void fun(int k, int[]nums){\\n        if(k==nums.length){\\n            List<Integer>a= new ArrayList<>();\\n        for(int x:nums)a.add(x);\\n            ans.add(a);\\n            return;\\n        }\\n        HashSet<Integer>s=new HashSet<>();\\n\\t\\t//here i\\'m creating an hash set for one recurrsion\\n        for(int i=k;i<nums.length;i++){\\n\\t\\t//there i\\'m checking and making sure that nums[i] is not getting repeteation \\n          if(s.contains(nums[i]))continue;\\n            s.add(nums[i]);\\n            swap(i,k,nums);\\n            fun(k+1,nums);\\n            swap(i,k,nums);\\n       \\n        }\\n    }\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n    fun(0,nums);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933335,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n   \\n    Set<List<Integer>> set = new HashSet<>();\\n    int visited[] = null;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n        visited = new int[nums.length];\\n        helper(nums, new ArrayList<Integer>());\\n       \\n        return new ArrayList<>(set);\\n        \\n    }\\n    \\n    private void helper(int[] nums, List<Integer> list){\\n         if(list.size()==nums.length){\\n           set.add(new ArrayList<>(list)); \\n             return;\\n         }\\n      \\n        for(int i=0; i<nums.length; i++){    \\n\\n            if(visited[i] == 0){\\n                list.add(nums[i]);\\n                visited[i] = 1;\\n                helper(nums, list);\\n                list.remove(list.size()-1);\\n                visited[i] = 0;\\n            }\\n\\n             \\n        }\\n        \\n        \\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n   \\n    Set<List<Integer>> set = new HashSet<>();\\n    int visited[] = null;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n        visited = new int[nums.length];\\n        helper(nums, new ArrayList<Integer>());\\n       \\n        return new ArrayList<>(set);\\n        \\n    }\\n    \\n    private void helper(int[] nums, List<Integer> list){\\n         if(list.size()==nums.length){\\n           set.add(new ArrayList<>(list)); \\n             return;\\n         }\\n      \\n        for(int i=0; i<nums.length; i++){    \\n\\n            if(visited[i] == 0){\\n                list.add(nums[i]);\\n                visited[i] = 1;\\n                helper(nums, list);\\n                list.remove(list.size()-1);\\n                visited[i] = 0;\\n            }\\n\\n             \\n        }\\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933328,
                "title": "c-simple-backtracking-solution",
                "content": "```\\nvector<vector<int>> ans;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int> nums, int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            if(nums[i] != nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                backtrack(nums, index+1);\\n            }\\n            else if(i == index)\\n            {\\n                backtrack(nums, index+1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>> ans;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int> nums, int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            if(nums[i] != nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                backtrack(nums, index+1);\\n            }\\n            else if(i == index)\\n            {\\n                backtrack(nums, index+1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18733,
                "title": "java-recursive-solution-with-minimal-extra-space",
                "content": "The idea is to directly modify the order of original array using a swap method instead of creating new list saving the results of every recursive call.\\n\\n    public class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n\\n        List<List<Integer>> result = new ArrayList();\\n        if(nums.length==0) return result;\\n        backTrack(nums, result, 0, nums.length-1);\\n        return result;\\n        \\n    }\\n    \\n    public void backTrack(int[] nums, List<List<Integer>> result, int begin, int end){\\n        if(begin>end){\\n            //changing int[] to arraylist and save into final result list\\n            result.add(new ArrayList<Integer>() {{ for (int i : nums) add(i); }});\\n        }\\n        \\n        else{\\n            for(int i=begin; i<=end; i++){\\n               \\n                if(!isDuplicate(nums, begin, i)){\\n                    swap(nums,i,begin);\\n                    backTrack(nums, result, begin+1, end); \\n                    swap(nums,i,begin);\\n                }\\n                \\n            }\\n        \\n        }\\n        \\n    }\\n    \\n    //check whether the current number has appeared in the subarray. if same number appears, we do not need to move this number again\\n\\n    public boolean isDuplicate(int[] nums, int begin, int i){\\n        for(int a=begin; a<i; a++){\\n            if(nums[a]==nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int buf = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = buf;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n\\n        List<List<Integer>> result = new ArrayList();\\n        if(nums.length==0) return result;\\n        backTrack(nums, result, 0, nums.length-1);\\n        return result;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 18720,
                "title": "for-those-who-get-tle-3-3-0-0-2-3-2",
                "content": "    #include<vector>\\n    #include<iostream>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        /* methods 1: no sort, swap twice, use reference */\\n        void recur(vector<int> &nums, int begin, vector< vector<int> > &res){\\n            if(begin == nums.size()){\\n                res.push_back(nums);\\n                return;\\n            }\\n            for(int i = begin; i < nums.size(); i++){\\n                if(begin != i && nums[begin] == nums[i])\\n                    continue;\\n                swap(nums[begin], nums[i]);\\n                recur(nums, begin + 1, res);\\n                swap(nums[begin], nums[i]);\\n            }\\n        }\\n        vector< vector<int> > permuteUnique(vector<int>& nums) {\\n            vector< vector<int> > res;\\n            recur(nums, 0, res);\\n            return res;\\n        }\\n    \\n        /*methods 2: sorted, pass value */\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }\\n            for (int k = i; k < j; k++) {\\n                if (i != k && num[i] == num[k]) continue;\\n                swap(num[i], num[k]);\\n                recursion(num, i+1, j, res);\\n            }\\n        }\\n        vector<vector<int> > permuteUnique2(vector<int> &num) {\\n            sort(num.begin(), num.end());\\n            vector<vector<int> >res;\\n            recursion(num, 0, num.size(), res);\\n            return res;\\n        }\\n    };\\n    \\n    int main(){\\n        class Solution a;\\n        int n[] = {3,3,0,0,2,3,2};\\n        vector<int> nums;\\n        for(int i = 0; i < sizeof(n) / sizeof(int); i++)\\n            nums.push_back(n[i]);\\n        vector< vector<int> > res = a.permuteUnique(nums);\\n        vector< vector<int> > res2 = a.permuteUnique2(nums);\\n        cout << \"size of methods 1: \" << res.size() << endl << \"size of methods 2: \" << res2.size() << endl;\\n        return 0;\\n    }\\n\\nAt first I use the first method and run into the problem and couldn't figure out why,then I find the answer at \\n[https://leetcode.com/discuss/25279/a-simple-c-solution-in-only-20-lines?state=edit-66279&show=61784#a61784][1] (in the first answer).\\n\\nBefore I figured it out, I also inplement this two methods to see the difference of the output, and it's really vivid; )\\nAfter you run it, res.size() is much bigger than res2.size() because it contains duplicate answers!\\nLet's take this array (1,2,2,3) for example, now pos(start) = 0 and i = 0;\\n\\n(1,2,2,3) (pos = 0, i = 0)\\n\\n(2,1,2,3) (pos = 0, i = 1)\\n\\n(2,2,1,3) (pos = 0, i =2)\\n\\n(3,2,2,1) (pos = 0, i =3)\\n\\nIn the second case and third case,the permutations of subsets (1,2,3) and (2,1,3) are exactly the same, so it generates duplicate answers as it continues recursion.\\n\\nREALLY appreciate BarneyZhao and TonyLic for pointing it out for me!\\n\\n\\n  [1]: https://leetcode.com/discuss/25279/a-simple-c-solution-in-only-20-lines",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /* methods 1: no sort, swap twice, use reference */\\n        void recur(vector<int> &nums, int begin, vector< vector<int> > &res){\\n            if(begin == nums.size()){\\n                res.push_back(nums);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 18809,
                "title": "tle-on-1-1-3-1-please-help",
                "content": "public List<List<Integer>> permuteUnique(int[] num) `{`\\n        ArrayList<List<Integer>> rst = new ArrayList<List<Integer>>();\\n        Arrays.sort(num);\\n        getPermute(num, 0, rst);\\n        return rst;\\n    }\\n    \\n    public void getPermute(int[] num, int start, ArrayList<List<Integer>> rst){\\n        \\n        if(start == num.length){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int i : num){\\n                list.add(i);\\n            }\\n            rst.add(list);\\n            return;\\n        }\\n        \\n        for(int i = start; i < num.length; i++){\\n            if(i > start && num[i] == num[start]){\\n                continue;\\n            }\\n            swap(num, i, start);\\n            getPermute(num, start + 1, rst);\\n            swap(num, i, start);\\n        }\\n    }\\n    \\n    private void swap(int[] num, int i, int j){\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n\\n\\nAnyone has a clue why this code will cause TLE? It runs pretty will on my eclipse",
                "solutionTags": [],
                "code": "public List<List<Integer>> permuteUnique(int[] num) `{`\\n        ArrayList<List<Integer>> rst = new ArrayList<List<Integer>>();\\n        Arrays.sort(num);\\n        getPermute(num, 0, rst);\\n        return rst;\\n    }\\n    \\n    public void getPermute(int[] num, int start, ArrayList<List<Integer>> rst){\\n        \\n        if(start == num.length){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int i : num){\\n                list.add(i);\\n            }\\n            rst.add(list);\\n            return;\\n        }\\n        \\n        for(int i = start; i < num.length; i++){\\n            if(i > start && num[i] == num[start]){\\n                continue;\\n            }\\n            swap(num, i, start);\\n            getPermute(num, start + 1, rst);\\n            swap(num, i, start);\\n        }\\n    }\\n    \\n    private void swap(int[] num, int i, int j){\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n\\n\\nAnyone has a clue why this code will cause TLE? It runs pretty will on my eclipse",
                "codeTag": "Unknown"
            },
            {
                "id": 3704875,
                "title": "easy-beginner-friendly-solution-recursion-and-stl-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive Tree\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I\\'ve considered the original array, and have done the operations in it.\\n2. Basically I have swapped all the values at differnt indices from a value at a particular index.\\n3. Here is the example: \\n   \\n![image.png](https://assets.leetcode.com/users/images/20211b7b-2484-4658-ac3f-3cba4e3569bf_1688225850.3467298.png)\\n\\n- Initally we are on index 0:\\nSwap 1 with 1 then 2 with 1 and then 3 with 1.\\nNow we have got three differnt arrays\\n- Now we are on index 1:\\n**For array 1:**\\nSwap 2 with 2 and then swap 3 with 2\\n**For array 2:**\\nSwap 1 with 1 and then swap 3 with 1.\\n**For array 3:**\\nSwap 2 with 2 and then swap 1 with 2.\\n\\nSo in total we have got 6 different arrays.\\n\\n4. Now let\\'s say instead of [1,2,3] we had [1,1,2]\\nIn this case, there would be **duplicate arrays**, so for removing them I have **used MAP**.\\n\\n\\nFeel free to mention your doubts in the comments below :)\\n\\n# Complexity\\n- Time complexity: **O(n!)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n!)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<int> nums, int index, vector<vector<int>> & ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            swap(nums[index], nums[i]);\\n            solve(nums, index + 1, ans);\\n\\n            //backtrack\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans, unique;\\n        int index = 0;\\n\\n        map<vector<int>, int> mp;\\n\\n        solve(nums, index, ans);\\n\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            mp[ans[i]]++;\\n        }\\n\\n        for(auto & it: mp)\\n        {\\n            unique.push_back(it.first);\\n        }\\n\\n        return unique;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<int> nums, int index, vector<vector<int>> & ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            swap(nums[index], nums[i]);\\n            solve(nums, index + 1, ans);\\n\\n            //backtrack\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans, unique;\\n        int index = 0;\\n\\n        map<vector<int>, int> mp;\\n\\n        solve(nums, index, ans);\\n\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            mp[ans[i]]++;\\n        }\\n\\n        for(auto & it: mp)\\n        {\\n            unique.push_back(it.first);\\n        }\\n\\n        return unique;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847565,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> pn;\\n        vector<int> t=nums;\\n        do\\n        {\\n            pn.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        while(nums!=t);\\n        return pn;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        int bp=-1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                bp=i;\\n                break;\\n            }\\n        }\\n        if(bp<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n            return;\\n        }\\n        for(int i=nums.size()-1;i>bp;i--)\\n        {\\n            if(nums[i]>nums[bp])\\n            {\\n                swap(nums[bp],nums[i]);\\n                reverse(nums.begin()+bp+1,nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> pn;\\n        vector<int> t=nums;\\n        do\\n        {\\n            pn.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        while(nums!=t);\\n        return pn;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        int bp=-1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                bp=i;\\n                break;\\n            }\\n        }\\n        if(bp<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n            return;\\n        }\\n        for(int i=nums.size()-1;i>bp;i--)\\n        {\\n            if(nums[i]>nums[bp])\\n            {\\n                swap(nums[bp],nums[i]);\\n                reverse(nums.begin()+bp+1,nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773174,
                "title": "permutations-2-java-solution-using-hashset-in-permutations-1",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         Set<List<Integer>> ans = new HashSet();\\n\\t        helper(nums,0,ans);\\n\\t        return new ArrayList(ans);\\n    }\\n     public void helper(int[] nums, int index, Set<List<Integer>> ans)\\n\\t    {\\n\\t    \\tif(index==nums.length)\\n\\t    \\t{\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t    \\t\\n\\t        for(int i = index; i<nums.length; i++)\\n\\t        {\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         Set<List<Integer>> ans = new HashSet();\\n\\t        helper(nums,0,ans);\\n\\t        return new ArrayList(ans);\\n    }\\n     public void helper(int[] nums, int index, Set<List<Integer>> ans)\\n\\t    {\\n\\t    \\tif(index==nums.length)\\n\\t    \\t{\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t    \\t\\n\\t        for(int i = index; i<nums.length; i++)\\n\\t        {\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032973,
                "title": "c-recursion-backtracking-permutations",
                "content": "**Approach-1 : Using set, recursion, and backtracking**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, set<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.insert(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=11) //check whether nums[i] already used if it is we skip if not we follow given statements\\n            {\\n                //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n                //then call helper function and when unique permutation is found and\\n                //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutaton\\n                permute.push_back(nums[i]); \\n                int j = nums[i]; \\n                nums[i] = 11;              \\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> unique; //use set for all unique permutation\\n        vector<vector<int>> ans;\\n        helper(nums, unique, {});\\n        \\n        //put set elements into ans\\n        for(auto i:unique) \\n            ans.push_back(i);\\n        \\n        return ans;     \\n    }\\n};\\n```\\n\\n**Approach-2 : Using sort, recursion, and backtracking**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, vector<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.push_back(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            //we check whether nums[i-1] equals to nums[i] if it is we continue, for avoiding duplicate permutation\\n            //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n            //then call helper function and when unique permutation is found and\\n            //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutation\\n            if(nums[i]!=11) \\n            {\\n                if(i>0 && nums[i-1]==nums[i]) continue;\\n            \\n                permute.push_back(nums[i]);\\n                int j = nums[i];\\n                nums[i] = 11;\\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n                \\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        //sort nums for getting duplicate nums in a sequence\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> unique;\\n        helper(nums, unique, {});\\n        return unique;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, set<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.insert(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=11) //check whether nums[i] already used if it is we skip if not we follow given statements\\n            {\\n                //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n                //then call helper function and when unique permutation is found and\\n                //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutaton\\n                permute.push_back(nums[i]); \\n                int j = nums[i]; \\n                nums[i] = 11;              \\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> unique; //use set for all unique permutation\\n        vector<vector<int>> ans;\\n        helper(nums, unique, {});\\n        \\n        //put set elements into ans\\n        for(auto i:unique) \\n            ans.push_back(i);\\n        \\n        return ans;     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, vector<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.push_back(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            //we check whether nums[i-1] equals to nums[i] if it is we continue, for avoiding duplicate permutation\\n            //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n            //then call helper function and when unique permutation is found and\\n            //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutation\\n            if(nums[i]!=11) \\n            {\\n                if(i>0 && nums[i-1]==nums[i]) continue;\\n            \\n                permute.push_back(nums[i]);\\n                int j = nums[i];\\n                nums[i] = 11;\\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n                \\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        //sort nums for getting duplicate nums in a sequence\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> unique;\\n        helper(nums, unique, {});\\n        return unique;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030556,
                "title": "c-next-perumutation",
                "content": "```\\nclass Solution {\\n    int n;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans; \\n        ans.push_back(nums);\\n        while(next_permu(nums))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n    \\n    bool next_permu(vector<int> &nums){\\n        int i;\\n        for(i = n - 2; i >= 0 and nums[i] >= nums[i+1]; i--);\\n        if(i < 0) return false;\\n        int j;\\n        for(j = n - 1; j >= 0 and nums[j] <= nums[i]; j--);\\n        \\n        swap(nums[j],nums[i]);        \\n        reverse(nums.begin() + i + 1, nums.end());\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans; \\n        ans.push_back(nums);\\n        while(next_permu(nums))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n    \\n    bool next_permu(vector<int> &nums){\\n        int i;\\n        for(i = n - 2; i >= 0 and nums[i] >= nums[i+1]; i--);\\n        if(i < 0) return false;\\n        int j;\\n        for(j = n - 1; j >= 0 and nums[j] <= nums[i]; j--);\\n        \\n        swap(nums[j],nums[i]);        \\n        reverse(nums.begin() + i + 1, nums.end());\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008905,
                "title": "python-recursion-with-explanation",
                "content": "for the recursion/backtrack function we have a base case and a main case:\\n* Base Case: if where the pointer is pointing at is beyond the length of nums, add the permutation made into the results list\\n* Main Case: for each time the backtrack function is called, generate a new empty seen set, so we can make sure that we don\\'t generate the same permutation again.\\nfor example, as you can see in the image, at the first leve (index =0) , the seen set has 1 and 2 in it. so for the second 2, as the seen set has already one 2 in it, it doesnt go through the actions under the if condition. The same procedure happens for other level as well. \\n\\n![image](https://assets.leetcode.com/users/images/a57b0466-9aaf-4c58-980e-0b186bd40b28_1651702847.700333.jpeg)\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n\\n        results = []\\n    \\n        def backtrack(pointer):\\n            if pointer == len(nums):\\n                results.append(nums[:])\\n                return\\n            \\n            seen = set() #generate an empty set eveytime the backtrack function is called\\n            for i in range(pointer, len(nums)):\\n\\t\\t\\t\\n                if nums[i] not in seen: #do below > if nums[i] is not already in the seen\\n\\t\\t\\t\\t\\n                    seen.add(nums[i]) #add nums[i] to the seen so if there is a duplicate, if condition can catch it\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n                    backtrack(pointer+1)\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n        backtrack(0)\\n        return results\\n```\\n\\nplease UPVOTE if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n\\n        results = []\\n    \\n        def backtrack(pointer):\\n            if pointer == len(nums):\\n                results.append(nums[:])\\n                return\\n            \\n            seen = set() #generate an empty set eveytime the backtrack function is called\\n            for i in range(pointer, len(nums)):\\n\\t\\t\\t\\n                if nums[i] not in seen: #do below > if nums[i] is not already in the seen\\n\\t\\t\\t\\t\\n                    seen.add(nums[i]) #add nums[i] to the seen so if there is a duplicate, if condition can catch it\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n                    backtrack(pointer+1)\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n        backtrack(0)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697139,
                "title": "javascript",
                "content": "```\\nvar permuteUnique = function(nums) {\\n    let result = []\\n    nums.sort((a,b) => a-b)\\n    let visited = new Array(nums.length).fill(false)\\n    \\n    function backtrack(permutations){\\n        if (permutations.length === nums.length){\\n            result.push([...permutations])\\n        } else {\\n            for (let i = 0; i < nums.length; i++){\\n                // duplicate check\\n                if (visited[i] || (i > 0 && nums[i] === nums[i-1] && !visited[i-1])) continue\\n                visited[i] = true\\n                permutations.push(nums[i])\\n                backtrack(permutations)\\n                visited[i] = false\\n                permutations.pop()\\n            }\\n        }\\n    }\\n    \\n    backtrack([])\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let result = []\\n    nums.sort((a,b) => a-b)\\n    let visited = new Array(nums.length).fill(false)\\n    \\n    function backtrack(permutations){\\n        if (permutations.length === nums.length){\\n            result.push([...permutations])\\n        } else {\\n            for (let i = 0; i < nums.length; i++){\\n                // duplicate check\\n                if (visited[i] || (i > 0 && nums[i] === nums[i-1] && !visited[i-1])) continue\\n                visited[i] = true\\n                permutations.push(nums[i])\\n                backtrack(permutations)\\n                visited[i] = false\\n                permutations.pop()\\n            }\\n        }\\n    }\\n    \\n    backtrack([])\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640499,
                "title": "two-js-easy-solutions-with-comments-with-wo-sorting",
                "content": "**IMPORTANT: It\\'s only for those who\\'ve solved the Permutations I probelem. This by no means, is an exhaustive explanation.**\\n**No sorting**\\nThe idea here is, the moment you encounter a number while looping over the remaining array, you check if that is already in the set of values. If yes, you continue, (move to the next element).\\nOtherwise, add the current element to the set that holds the unique elements in the array. And do the processing.\\nThis way, we don\\'t need to sort, which improves the timing, but extra space will be used O(n) where n is number of unique elements in the set, Since `set.has(el)` is constant time O(1), this improves the time complexity.\\nIn case of sorting, unless quicksort is used, you\\'ll endup using extra time and space both.\\n\\n**No Sorting**\\n```\\nvar permuteUnique = function(nums) {\\n    let data = [];\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        let uniques = new Set();\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n            if(uniques.has(remaining[i])) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n                uniques.add(remaining[i]);\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n};\\n```\\n**Sorting**\\n```\\nvar permuteUnique = function(nums) {\\n\\tlet data = [];\\n\\tnums = nums.sort();\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n\\t\\t\\tif (i > 0 && remaining[i] === remaining[i - 1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let data = [];\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        let uniques = new Set();\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n            if(uniques.has(remaining[i])) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n                uniques.add(remaining[i]);\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n};\\n```\n```\\nvar permuteUnique = function(nums) {\\n\\tlet data = [];\\n\\tnums = nums.sort();\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n\\t\\t\\tif (i > 0 && remaining[i] === remaining[i - 1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18660,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18803,
                "title": "accepted-iterative-solution-in-java",
                "content": "Here's my iterative solution in java:\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Set<List<Integer>> permutations = new HashSet<List<Integer>>();\\n            \\n            if(num.length > 0){\\n                permutations.add(Arrays.asList(num[0]));\\n                \\n                for(int index = 1; index < num.length; index++) {\\n                  \\n                    Set<List<Integer>> newPermutations = new HashSet<List<Integer>>();\\n                    for(List<Integer> list : permutations){\\n    \\n                        for(int innerIndex = 0; innerIndex <= list.size(); innerIndex++){\\n                            List<Integer> newList = new ArrayList(list);\\n                            newList.add(innerIndex, num[index]);\\n                            newPermutations.add(newList);\\n                        }\\n                    }\\n                    \\n                    permutations = newPermutations;\\n                }\\n            }\\n            return new ArrayList<List<Integer>>(permutations);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Set<List<Integer>> permutations = new HashSet<List<Integer>>();\\n            \\n            if(num.length > 0){\\n                permutations.add(Arrays.asList(num[0]));\\n                \\n                for(int index = 1; index < num.length; index++) {\\n                  \\n                    Set<List<Integer>> newPermutations = new HashSet<List<Integer>>();\\n                    for(List<Integer> list : permutations){\\n    \\n                        for(int innerIndex = 0; innerIndex <= list.size(); innerIndex++){\\n                            List<Integer> newList = new ArrayList(list);\\n                            newList.add(innerIndex, num[index]);\\n                            newPermutations.add(newList);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3312385,
                "title": "cheat-one-liner-in-python-using-in-built-permutations-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return set(permutations(nums)) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return set(permutations(nums)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279614,
                "title": "fast-easy-o-n-nlogn-o-1-no-backtracking-no-recursion-no-inbuilt-fn",
                "content": "# Intuition\\nBased on finding the next permutation every time.\\n\\n# Approach\\nThe approach is derived from the [next permuatation](https://leetcode.com/problems/next-permutation) solution, where we have to [find](https://leetcode.com/problems/next-permutation/submissions/911026310/) the next permuation of an array of integers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n! + nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> vc;\\n        int i,j,n=nums.size()-1;\\n        do{\\n            i=j=n;\\n            while(i && nums[i-1]>=nums[i]) i--;\\n            if(i){\\n                while(nums[i-1]>=nums[j]) j--;\\n                swap(nums[i-1],nums[j]);\\n            }\\n            reverse(nums.begin()+i,nums.end());\\n            vc.push_back(nums);\\n        }while(i);\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> vc;\\n        int i,j,n=nums.size()-1;\\n        do{\\n            i=j=n;\\n            while(i && nums[i-1]>=nums[i]) i--;\\n            if(i){\\n                while(nums[i-1]>=nums[j]) j--;\\n                swap(nums[i-1],nums[j]);\\n            }\\n            reverse(nums.begin()+i,nums.end());\\n            vc.push_back(nums);\\n        }while(i);\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103517,
                "title": "94-javascript-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\n\\nhttps://youtu.be/pamdPigxHoY\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018452,
                "title": "easiest-faang-method-ever",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N!*N) + O(N) + O(NlogN) ~  O(N! * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) //For using set DS & vector vec\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    void Permutations(int ind, vector<int> &nums, set<vector<int>> &ans){\\n        if(ind==nums.size())\\n            ans.insert(nums);\\n\\n        for(int i=ind;i<nums.size();i++){      \\n            if(i>ind && nums[i]==nums[ind]) continue;\\n            swap(nums[i],nums[ind]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<vector<int>> ans;\\n        vector<vector<int>> vec;\\n        Permutations(0, nums, ans);\\n        for(auto it:ans){\\n            vec.emplace_back(it);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    void Permutations(int ind, vector<int> &nums, set<vector<int>> &ans){\\n        if(ind==nums.size())\\n            ans.insert(nums);\\n\\n        for(int i=ind;i<nums.size();i++){      \\n            if(i>ind && nums[i]==nums[ind]) continue;\\n            swap(nums[i],nums[ind]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<vector<int>> ans;\\n        vector<vector<int>> vec;\\n        Permutations(0, nums, ans);\\n        for(auto it:ans){\\n            vec.emplace_back(it);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949128,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N*N!)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823043,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        do {\\n            ans.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        do {\\n            ans.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030931,
                "title": "java-classic-backtracking",
                "content": "```java\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> permutations = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtracking(permutations, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return permutations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> permutations, List<Integer> current, int[] nums, boolean[] used) {\\n        if (current.size() == nums.length)\\n            permutations.add(new ArrayList<>(current));\\n        else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue;\\n                current.add(nums[i]);\\n                used[i] = true;\\n                backtracking(permutations, current, nums, used);\\n                used[i] = false;\\n                current.remove(current.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> permutations = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtracking(permutations, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return permutations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> permutations, List<Integer> current, int[] nums, boolean[] used) {\\n        if (current.size() == nums.length)\\n            permutations.add(new ArrayList<>(current));\\n        else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue;\\n                current.add(nums[i]);\\n                used[i] = true;\\n                backtracking(permutations, current, nums, used);\\n                used[i] = false;\\n                current.remove(current.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030484,
                "title": "c-backtracking-and-hashing",
                "content": "Idea:\\n* Generate all permutations using the backtracking algorithm.\\n* Then generate a equivalent hash value for each permutations and store it into the map.\\n* For a permutation, if the hash value is not found into the map then add it to the answer otherwise discard it.\\n\\nComplexity for unordered_map: O(n^n)\\nComplexity for ordered_map: O(n^n) log (n^n)\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mymap;\\n    int mod = 1e9 + 7;\\n    int base = 37;\\n    vector<vector<int> > ans;\\n    vector<int> temp;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) nums[i] = nums[i] + 10;\\n        solve(nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& nums, int mask, int hashValue){\\n        int n = nums.size();\\n        if(mask == (1<<n)-1){\\n            if(!mymap[hashValue]){\\n                ans.push_back(temp);\\n                mymap[hashValue]++;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if( !(mask & (1<<i)) ){\\n                long long t = hashValue * 1ll * base + nums[i];\\n                if(t>=mod) t %= mod;\\n                temp.push_back(nums[i] - 10);\\n                solve(nums, mask | (1<<i), t);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mymap;\\n    int mod = 1e9 + 7;\\n    int base = 37;\\n    vector<vector<int> > ans;\\n    vector<int> temp;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) nums[i] = nums[i] + 10;\\n        solve(nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& nums, int mask, int hashValue){\\n        int n = nums.size();\\n        if(mask == (1<<n)-1){\\n            if(!mymap[hashValue]){\\n                ans.push_back(temp);\\n                mymap[hashValue]++;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if( !(mask & (1<<i)) ){\\n                long long t = hashValue * 1ll * base + nums[i];\\n                if(t>=mod) t %= mod;\\n                temp.push_back(nums[i] - 10);\\n                solve(nums, mask | (1<<i), t);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860786,
                "title": "c-backtracking-using-hashmap-to-avoid-identical-solution-c-easy-11ms-solution",
                "content": "```\\n//backtracking using hashmaps.\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;  //to store freqency of all unique elements.\\n    vector<vector<int>> ans;    // to store all permutations once formed.\\n    vector<int> curr;           //curr is empty initially, and is formed step by step \\n                                //one all elements are used in curr, it is pushed in ans.\\n    void permutations(int idx,vector<int>& nums){\\n        int n=nums.size();\\n        \\n        if(idx==n){                //all elements are used then push it in ans array.\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(auto &k: mp){\\n            int key=k.first;    //the element.\\n            int val=k.second;   //its frequency.\\n            \\n            if(val==0) continue;    // val==0 means this element is used completely\\n                                    // and cannot be further use.\\n            curr.push_back(key);mp[key]--;  //else use this element and form a permutation.\\n            permutations(idx+1,nums);       \\n            curr.pop_back();mp[key]++;      // pop back so as to leave no trail of previous\\n        }                                   // permutations formed.\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(auto &k: nums) mp[k]++; //storing frequency of elements.\\n        permutations(0,nums);\\n        \\n        return ans; \\n    }\\n};\\n```\\n\\n#####  For those who find difficulty understanding it and need explanation\\nwhat we are doing is,\\ntaking all possible unique element one by one in one place and then doing permutation for remaining places with remaing element (since all permutations should be unique, if for example , we have taken 1 in first place and calculated all possible permutations for the remaing , then we cannot take 1 again at same place and calculate the same permutation again)\\n\\n```\\n for(auto &k: nums) mp[k]++;\\n```\\nwe have stored the frequency of all elements in map.\\n```\\nif(idx==n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n```\\nif idx==n , means we have used all the element and a permutation is formed. then push this permutation in ans array.\\n```\\nfor(auto &k: mp){\\n            int key=k.first;\\n            int val=k.second;\\n            \\n            if(val==0) continue;\\n            \\n            curr.push_back(key);mp[key]--;\\n            permutations(idx+1,nums);\\n            curr.pop_back();mp[key]++;\\n        }\\n```\\ni) we are iterating to all the element in mp only once since we want unique numbers at unique places.\\nii) if (val==0) means , the element we are iterating at is used totally and none left , then we should continue and move to another element.\\niii) if (val != 0 ) means, we can use this element here. and so we push this element curr , and do permutation for the remaing , and again pop back to ensure it leaves no trail of its past.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n//backtracking using hashmaps.\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;  //to store freqency of all unique elements.\\n    vector<vector<int>> ans;    // to store all permutations once formed.\\n    vector<int> curr;           //curr is empty initially, and is formed step by step \\n                                //one all elements are used in curr, it is pushed in ans.\\n    void permutations(int idx,vector<int>& nums){\\n        int n=nums.size();\\n        \\n        if(idx==n){                //all elements are used then push it in ans array.\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(auto &k: mp){\\n            int key=k.first;    //the element.\\n            int val=k.second;   //its frequency.\\n            \\n            if(val==0) continue;    // val==0 means this element is used completely\\n                                    // and cannot be further use.\\n            curr.push_back(key);mp[key]--;  //else use this element and form a permutation.\\n            permutations(idx+1,nums);       \\n            curr.pop_back();mp[key]++;      // pop back so as to leave no trail of previous\\n        }                                   // permutations formed.\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(auto &k: nums) mp[k]++; //storing frequency of elements.\\n        permutations(0,nums);\\n        \\n        return ans; \\n    }\\n};\\n```\n```\\n for(auto &k: nums) mp[k]++;\\n```\n```\\nif(idx==n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n```\n```\\nfor(auto &k: mp){\\n            int key=k.first;\\n            int val=k.second;\\n            \\n            if(val==0) continue;\\n            \\n            curr.push_back(key);mp[key]--;\\n            permutations(idx+1,nums);\\n            curr.pop_back();mp[key]++;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437256,
                "title": "simple-java-solution-faster-than-99-39",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        permute(nums, new ArrayList<Integer>(), new boolean[nums.length]);\\n        return result;\\n    }\\n    \\n    public void permute(int[] nums, List<Integer> list , boolean[] used) {\\n        \\n        if(list.size() == nums.length){\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(!used[i]){\\n                if(i == 0 || nums[i-1] != nums[i] || used[i-1]){\\n                used[i] = true;\\n                list.add(nums[i]);\\n                permute(nums, list, used);\\n                used[i] = false;\\n                list.remove(list.size()-1);  \\n                }\\n                               \\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        permute(nums, new ArrayList<Integer>(), new boolean[nums.length]);\\n        return result;\\n    }\\n    \\n    public void permute(int[] nums, List<Integer> list , boolean[] used) {\\n        \\n        if(list.size() == nums.length){\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(!used[i]){\\n                if(i == 0 || nums[i-1] != nums[i] || used[i-1]){\\n                used[i] = true;\\n                list.add(nums[i]);\\n                permute(nums, list, used);\\n                used[i] = false;\\n                list.remove(list.size()-1);  \\n                }\\n                               \\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348102,
                "title": "swift-solution-backtracking-explanation-with-simple-example",
                "content": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        let sorted = nums.sorted()\\n        var candidates = [Int]()\\n        var result = [[Int]]()\\n        var isVisited = Array(repeating: false, count: nums.count)\\n        \\n        backTracking(sorted, &candidates, &result, &isVisited)\\n        return result\\n    }\\n    \\n    // assume its like a tree\\n    func backTracking(_ nums: [Int], _ candidates: inout [Int], _ result: inout [[Int]], _ isVisited: inout [Bool]) {\\n        // when reach the leaves\\n        guard candidates.count < nums.count else {\\n            result.append(candidates)\\n            return \\n        }\\n        \\n        for i in 0..<nums.count where !isVisited[i] {\\n\\n            // filter out cases when a number has same value with its previous, and its previous is not used, we mark as \"@\" in below graph; like sibling same value cases\\n            if i > 0 && nums[i-1] == nums[i] && !isVisited[i-1] { continue }\\n            \\n            candidates.append(nums[i])\\n            isVisited[i] = true\\n            \\n            backTracking(nums, &candidates, &result, &isVisited)\\n            \\n            candidates.removeLast()\\n            isVisited[i] = false\\n        }\\n        \\n    }\\n}\\n\\n\\n// eg: [1, 1, 2]; assume it\\'s like a tree; \"*\" means duplicated cases, \"@\" means who have same value of its previous\\' sibling\\n//                           [ ]\\n//              /             |                \\\\\\n//            [1]            [@1]               [2]\\n//           /   \\\\          /   \\\\             /   \\\\\\n//       [1,1]  [1,2]    *[1,1] *[1,2]      [2,1]  [2,@1]\\n//         /       \\\\       /        \\\\        /       \\\\\\n//     [1,1,2]  [1,2,1] *[1,1,2]  *[1,2,1] [2,1,1]  *[2,1,1]\\n\\n//    output: [[1,1,2],[1,2,1],[2,1,1]]\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        let sorted = nums.sorted()\\n        var candidates = [Int]()\\n        var result = [[Int]]()\\n        var isVisited = Array(repeating: false, count: nums.count)\\n        \\n        backTracking(sorted, &candidates, &result, &isVisited)\\n        return result\\n    }\\n    \\n    // assume its like a tree\\n    func backTracking(_ nums: [Int], _ candidates: inout [Int], _ result: inout [[Int]], _ isVisited: inout [Bool]) {\\n        // when reach the leaves\\n        guard candidates.count < nums.count else {\\n            result.append(candidates)\\n            return \\n        }\\n        \\n        for i in 0..<nums.count where !isVisited[i] {\\n\\n            // filter out cases when a number has same value with its previous, and its previous is not used, we mark as \"@\" in below graph; like sibling same value cases\\n            if i > 0 && nums[i-1] == nums[i] && !isVisited[i-1] { continue }\\n            \\n            candidates.append(nums[i])\\n            isVisited[i] = true\\n            \\n            backTracking(nums, &candidates, &result, &isVisited)\\n            \\n            candidates.removeLast()\\n            isVisited[i] = false\\n        }\\n        \\n    }\\n}\\n\\n\\n// eg: [1, 1, 2]; assume it\\'s like a tree; \"*\" means duplicated cases, \"@\" means who have same value of its previous\\' sibling\\n//                           [ ]\\n//              /             |                \\\\\\n//            [1]            [@1]               [2]\\n//           /   \\\\          /   \\\\             /   \\\\\\n//       [1,1]  [1,2]    *[1,1] *[1,2]      [2,1]  [2,@1]\\n//         /       \\\\       /        \\\\        /       \\\\\\n//     [1,1,2]  [1,2,1] *[1,1,2]  *[1,2,1] [2,1,1]  *[2,1,1]\\n\\n//    output: [[1,1,2],[1,2,1],[2,1,1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280164,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        var n = nums.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (n == 0) return result;\\n        \\n        Array.Sort(nums);\\n\\n        DFS(nums, new bool[n], 0, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, bool[] isVisited, int start, IList<int> oneResult, IList<IList<int>> result) {\\n        var n = nums.Length;\\n\\n        if (oneResult.Count == n) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = 0; i < n; i++) {\\n                if (isVisited[i]) continue;\\n                if (i > 0 && nums[i - 1] == nums[i] && isVisited[i-1]) continue;\\n\\n                oneResult.Add(nums[i]);\\n                isVisited[i] = true;\\n                DFS(nums, isVisited, i, oneResult, result);\\n                isVisited[i] = false;\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        var n = nums.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (n == 0) return result;\\n        \\n        Array.Sort(nums);\\n\\n        DFS(nums, new bool[n], 0, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, bool[] isVisited, int start, IList<int> oneResult, IList<IList<int>> result) {\\n        var n = nums.Length;\\n\\n        if (oneResult.Count == n) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = 0; i < n; i++) {\\n                if (isVisited[i]) continue;\\n                if (i > 0 && nums[i - 1] == nums[i] && isVisited[i-1]) continue;\\n\\n                oneResult.Add(nums[i]);\\n                isVisited[i] = true;\\n                DFS(nums, isVisited, i, oneResult, result);\\n                isVisited[i] = false;\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18731,
                "title": "1-line-python-solution-set-list-slicing-beats-46-11",
                "content": "Inspired by this [one-liners][1].\\n\\n    def permuteUnique(self, nums):\\n        return [[n] + p for n in set(nums) for p in self.permuteUnique(nums[:nums.index(n)] + nums[nums.index(n) + 1:])] or [[]]\\n\\n  [1]: https://leetcode.com/discuss/42550/one-liners-in-python",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "Inspired by this [one-liners][1].\\n\\n    def permuteUnique(self, nums):\\n        return [[n] + p for n in set(nums) for p in self.permuteUnique(nums[:nums.index(n)] + nums[nums.index(n) + 1:])] or [[]]\\n\\n  [1]: https://leetcode.com/discuss/42550/one-liners-in-python",
                "codeTag": "Python3"
            },
            {
                "id": 3713810,
                "title": "java-solution-using-backtrackingba-understandable",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo understand more check  my previous solution !!!\\nhttps://leetcode.com/problems/permutations/solutions/3713561/java-solution-using-backtracking-method/\\n\\n\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n\\n        backtrack(res, nums, 0, set);\\n        return res;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, int[] nums, int index, HashSet<List<Integer>> set) {\\n        if (index == nums.length) {\\n            List<Integer> current = toList(nums);\\n            if (!set.contains(current)) {\\n                res.add(current);\\n                set.add(current);\\n            }\\n        } else {\\n            for (int i = index; i < nums.length; i++) {\\n                swap(index, i, nums);\\n                backtrack(res, nums, index + 1, set);\\n                swap(index, i, nums);\\n            }\\n        }\\n    }\\n\\n    public void swap(int m, int n, int[] nums) {\\n        int temp = nums[m];\\n        nums[m] = nums[n];\\n        nums[n] = temp;\\n    }\\n\\n    public List<Integer> toList(int[] nums) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int n : nums) {\\n            l.add(n);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Hash Function"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n\\n        backtrack(res, nums, 0, set);\\n        return res;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, int[] nums, int index, HashSet<List<Integer>> set) {\\n        if (index == nums.length) {\\n            List<Integer> current = toList(nums);\\n            if (!set.contains(current)) {\\n                res.add(current);\\n                set.add(current);\\n            }\\n        } else {\\n            for (int i = index; i < nums.length; i++) {\\n                swap(index, i, nums);\\n                backtrack(res, nums, index + 1, set);\\n                swap(index, i, nums);\\n            }\\n        }\\n    }\\n\\n    public void swap(int m, int n, int[] nums) {\\n        int temp = nums[m];\\n        nums[m] = nums[n];\\n        nums[n] = temp;\\n    }\\n\\n    public List<Integer> toList(int[] nums) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int n : nums) {\\n            l.add(n);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712389,
                "title": "c-backtracking-using-hash-table",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& res, vector<int>& curr, unordered_map<int,int>& m, vector<int>& nums) {\\n        if(curr.size() == nums.size()) {\\n            res.push_back(curr);\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second == 0) continue;\\n            curr.push_back(itr->first);\\n            itr->second -= 1;\\n            backTrack(res, curr, m, nums);\\n            curr.pop_back();\\n            itr->second += 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> curr;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i]]++;\\n        }\\n        backTrack(res, curr, m, nums);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& res, vector<int>& curr, unordered_map<int,int>& m, vector<int>& nums) {\\n        if(curr.size() == nums.size()) {\\n            res.push_back(curr);\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second == 0) continue;\\n            curr.push_back(itr->first);\\n            itr->second -= 1;\\n            backTrack(res, curr, m, nums);\\n            curr.pop_back();\\n            itr->second += 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> curr;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i]]++;\\n        }\\n        backTrack(res, curr, m, nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209528,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097461,
                "title": "c-easy-solution-recursion-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void f(set<vector<int>>&res,vector<int>&temp,vector<int>& nums,vector<int>& vis){\\n        if(nums.size()==temp.size()){\\n            res.insert(temp);\\n            return;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                temp.push_back(nums[i]);\\n                f(res,temp,nums,vis);\\n                temp.pop_back();\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        vector<int>vis(nums.size(),0);\\n        f(res,temp,nums,vis);\\n        vector<vector<int>>ans;\\n        for(auto it:res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(set<vector<int>>&res,vector<int>&temp,vector<int>& nums,vector<int>& vis){\\n        if(nums.size()==temp.size()){\\n            res.insert(temp);\\n            return;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                temp.push_back(nums[i]);\\n                f(res,temp,nums,vis);\\n                temp.pop_back();\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        vector<int>vis(nums.size(),0);\\n        f(res,temp,nums,vis);\\n        vector<vector<int>>ans;\\n        for(auto it:res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845014,
                "title": "easy-c-solution-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void help(int pos,vector<vector<int>>&ans,vector<int>& nums){\\n        if(pos>nums.size()){\\n            return;\\n        }\\n        \\n        if(pos==nums.size()-1){\\n\\t\\t\\n\\t\\t//Check for duplicate vectors in 2D vector\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==nums){\\n                    return;\\n                }\\n            }\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i=pos;i<nums.size();i++){\\n            swap(nums[i],nums[pos]);\\n            help(pos+1,ans,nums);\\n\\t\\t\\t\\n\\t\\t\\t//Backtraking\\n            swap(nums[i],nums[pos]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        // set<set<int>>s;\\n        vector<vector<int>>ans;\\n        // vector<int>v;\\n        help(0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int pos,vector<vector<int>>&ans,vector<int>& nums){\\n        if(pos>nums.size()){\\n            return;\\n        }\\n        \\n        if(pos==nums.size()-1){\\n\\t\\t\\n\\t\\t//Check for duplicate vectors in 2D vector\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==nums){\\n                    return;\\n                }\\n            }\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i=pos;i<nums.size();i++){\\n            swap(nums[i],nums[pos]);\\n            help(pos+1,ans,nums);\\n\\t\\t\\t\\n\\t\\t\\t//Backtraking\\n            swap(nums[i],nums[pos]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        // set<set<int>>s;\\n        vector<vector<int>>ans;\\n        // vector<int>v;\\n        help(0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630122,
                "title": "easy-java-solution",
                "content": "**Solution**\\nThis is solution is same as LEETCODE permutations with few changes to remove duplication\\n```\\n public List<List<Integer>> permuteUnique(int[] nums) \\n {\\n        List<List<Integer>> al = new ArrayList<>();\\n        generate(nums, 0, nums.length-1, al);\\n\\t\\t//taking hashset of generic List so to remove duplicate lists\\n        HashSet<List> hs = new HashSet<>();\\n        for(List a: al)\\n        {\\n            hs.add(a); //adding all the lists from list of list to the HashSet\\n        }\\n        al.clear(); //clearing the original list of list to add new unique lists\\n        for(List a: hs)\\n        {\\n            al.add(a); //adding lists from HashSet\\n        }\\n        return al; //returning ans\\n    }\\n```\\nRest Same Logic as Permutations(leetcode 46):-\\n```\\nstatic void generate(int a[], int i, int l, List<List<Integer>> al)\\n    {\\n        if(i==l) //if index comes at last element of array\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n\\t\\t\\t//creating the list every time when the base conditions get hit\\n            for(int x: a)\\n            {\\n                cl.add(x);\\n            }\\n            al.add(cl); //adding this list to list of list\\n        }\\n        else\\n        {\\n            for(int j = i; j<=l; j++) // loop from i to last element //after each recursion i will get incremented and loop will also change \\n            {\\n                a = swap(a, i, j); //swapping ith element with jth element\\n                generate(a, i+1, l, al); // further calling the recursion call again for further swaping\\n                a = swap(a, j, i); //after the recursion ends returning back and swaping again the ith and jth element so that we get original array back for another recursion call\\n            }\\n            \\n        }\\n    }\\n\\t//Swap Function:---\\n\\tstatic int[] swap(int a[], int i, int j)\\n    {\\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j]= temp;\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> permuteUnique(int[] nums) \\n {\\n        List<List<Integer>> al = new ArrayList<>();\\n        generate(nums, 0, nums.length-1, al);\\n\\t\\t//taking hashset of generic List so to remove duplicate lists\\n        HashSet<List> hs = new HashSet<>();\\n        for(List a: al)\\n        {\\n            hs.add(a); //adding all the lists from list of list to the HashSet\\n        }\\n        al.clear(); //clearing the original list of list to add new unique lists\\n        for(List a: hs)\\n        {\\n            al.add(a); //adding lists from HashSet\\n        }\\n        return al; //returning ans\\n    }\\n```\n```\\nstatic void generate(int a[], int i, int l, List<List<Integer>> al)\\n    {\\n        if(i==l) //if index comes at last element of array\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n\\t\\t\\t//creating the list every time when the base conditions get hit\\n            for(int x: a)\\n            {\\n                cl.add(x);\\n            }\\n            al.add(cl); //adding this list to list of list\\n        }\\n        else\\n        {\\n            for(int j = i; j<=l; j++) // loop from i to last element //after each recursion i will get incremented and loop will also change \\n            {\\n                a = swap(a, i, j); //swapping ith element with jth element\\n                generate(a, i+1, l, al); // further calling the recursion call again for further swaping\\n                a = swap(a, j, i); //after the recursion ends returning back and swaping again the ith and jth element so that we get original array back for another recursion call\\n            }\\n            \\n        }\\n    }\\n\\t//Swap Function:---\\n\\tstatic int[] swap(int a[], int i, int j)\\n    {\\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j]= temp;\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030500,
                "title": "easy-cpp-solution-permutations-2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     vector<vector<int>>v;\\n    set<vector<int> > s;\\n    void number(vector<int>&x, int index, vector<int>&nums){\\n    if(index==nums.size()){\\n        auto pos = s.find(nums);\\n        if(pos==s.end()){\\n        v.push_back(nums);\\n        s.insert(nums);\\n        }\\n        \\n        return;\\n    }\\n    for(int i=index;i<nums.size();i++){\\n        swap(nums[i],nums[index]);\\n        number(x,index+1,nums);\\n        swap(nums[i],nums[index]);\\n    }\\n    \\n}\\n    \\n   \\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int>x;\\n    number(x, 0, nums);\\n    return v;\\n    }\\n};\\n```\\n\\nFeel free to comment if you have any doubt. Upvote if my solution helped you.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<vector<int>>v;\\n    set<vector<int> > s;\\n    void number(vector<int>&x, int index, vector<int>&nums){\\n    if(index==nums.size()){\\n        auto pos = s.find(nums);\\n        if(pos==s.end()){\\n        v.push_back(nums);\\n        s.insert(nums);\\n        }\\n        \\n        return;\\n    }\\n    for(int i=index;i<nums.size();i++){\\n        swap(nums[i],nums[index]);\\n        number(x,index+1,nums);\\n        swap(nums[i],nums[index]);\\n    }\\n    \\n}\\n    \\n   \\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int>x;\\n    number(x, 0, nums);\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030468,
                "title": "c-backtracking-with-bootleg-key-to-make-sure-it-is-unique",
                "content": "**Solved live on stream.  Link in profile.**\\n\\n```\\n\\nclass Solution {\\n    string makeKey(vector<int>& path) {\\n        string key = \"\";\\n        for(int x : path) {\\n            key += to_string(x) + \\':\\';\\n        }\\n        return key;\\n    }\\n    \\n    void bt(vector<int>& nums, unordered_set<int>& seen, vector<int>& path, vector<vector<int>>& ans, unordered_set<string>& uniques) {\\n        if(path.size() == nums.size()) {\\n            string key = makeKey(path);\\n            if(uniques.find(key) != uniques.end()) return;\\n            uniques.insert(key);\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(seen.find(i) != seen.end()) continue;\\n            seen.insert(i);\\n            path.push_back(nums[i]);\\n            bt(nums, seen, path, ans, uniques);\\n            seen.erase(i);\\n            path.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        unordered_set<string> uniques;\\n        unordered_set<int> seen;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        bt(nums, seen, path, ans, uniques);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    string makeKey(vector<int>& path) {\\n        string key = \"\";\\n        for(int x : path) {\\n            key += to_string(x) + \\':\\';\\n        }\\n        return key;\\n    }\\n    \\n    void bt(vector<int>& nums, unordered_set<int>& seen, vector<int>& path, vector<vector<int>>& ans, unordered_set<string>& uniques) {\\n        if(path.size() == nums.size()) {\\n            string key = makeKey(path);\\n            if(uniques.find(key) != uniques.end()) return;\\n            uniques.insert(key);\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(seen.find(i) != seen.end()) continue;\\n            seen.insert(i);\\n            path.push_back(nums[i]);\\n            bt(nums, seen, path, ans, uniques);\\n            seen.erase(i);\\n            path.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        unordered_set<string> uniques;\\n        unordered_set<int> seen;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        bt(nums, seen, path, ans, uniques);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976262,
                "title": "c-optimised-solution-without-duplicates-100-time-0ms-100-space-8mb",
                "content": "This problem is nice because it offers a few subtle challenges:\\n* we need to figure out how to get all the permutations; \\n* we want to do so as efficiently as possible, without generating duplicates;\\n* partially connected with the previous one, we want to avoid unnecessary memory usage, so we should have our result variable already properly sized in advance.\\n\\nLet\\'s start with the last point, *shall we?* [imagine this bit pronounced with the tone of [the Critical Drinker](https://www.youtube.com/channel/UCSJPFQdZwrOutnmSFYtbstA)]\\n\\nWe know (or can google/derive) that the number of permutations we will get is equal to the factorial of the numbers of elements, divided by the factorial of the frequency of each of them.\\n\\nSo, for example, if our input is `{1,2,3,4,5}`, we will get `5!` permutations, that is to say `120`; if we were still given `5` elements, but they were, say, `{1,1,4,4,4}`, we will have  `5! / 2! / 3!` (since we have `2` `1`s and `3` `4`s), which is `10`.\\n\\nAnd what about not generating duplicates? We can do it with the built-in `next_permutation` that will `return` us only the next different permutation, no matter whether we have duplicated elements or not. Even better if we try to replicate that behaviour ourselves, since it is good practice.\\n\\nWith that in mind, time to start, declaring externally a precomputed array `facts` with all the factorials up to `8` (our largest possible input); inside our function we will also declare:\\n* `len` as the size of our input;\\n* `resSize` as the size of our result, initially set to be the factorial of `len` (that we will also decrease, so that it will become the value of the last index of the input);\\n* `freqs` and `nFreqs` will store the frequencies of the positive and negative numbers we will be passed.\\n\\nWe will then loop through each element `n` in `nums` and:\\n* increased either `freqs[n]` or `nFreqs[-n]` by `1` (depending on whether or not `n` was positive);\\n* divide `resSize` by the updated frequence (which in turn will equate to dividing from the factorial of the overall frequence of each element).\\n\\nNow that we have a proper value for `resSize`, we can create our last support variables `res` with the proper capacity, without consuming resources with several painful/expensive reallocations!\\n\\nAnd now time to prepare `nums` - for convenience setting it to be our first permutation (ie:  the one with all its elements sorted in increasing order); I am fully aware this would not be strictly necessary, but since at some point we might reach a point in which we reach the last permutation (all the elements in decreasing order), and thus do the same, I just preferred to keep my logic a bit lighter and start with it.\\n\\nWe will write this value in `res[0]`.\\n\\nAssuming `resSize > 1`, we will then loop `resSize` times, using also `j`, `k` and `n` as loop variables and for each iteration we will basically replicate the behaviour of `next_permutation` by:\\n* setting `j` to be the value of the rightmost element (`len`);\\n* looping `while` `j > 0` and:\\n\\t* checking when we have to create a new permutation, which is when we find that the the element right before `j` is actually smaller, in which case we will:\\n\\t\\t* set `n` to be the preceding element (`nums[j - 1`);\\n\\t\\t* set `k` to equal the initial value of `j`, that is to say the index of the rightmost element - `len`;\\n\\t\\t* decrease `k` by `1` `while` nums[k] <= n`, to make it so that `k` is now pointing to the first element from the right greater than `n`;\\n\\t\\t* swap `nums[j- 1]` and `nums[k]`;\\n\\t\\t* if `j` is not still the last element `len`, we will then also sort `nums` from `j` onwards;\\n\\t\\t* finally, we will `break` out of the loop, since we have now a valid permutation :)\\n\\t* increasing `j` by `1`\\n* writing the updated `nums` in `res[i]`.\\n\\nFor a more indepth analysis of the generation of the next permutation, I put some more words [in the solution of that specific problem](https://leetcode.com/problems/next-permutation/discuss/1044321/C%2B%2B-2-Pointer-Solution-Explained-100-Time-~90-Space) ok\\n\\nOnce done,  we can just `return` our efficiently computed `res` :)\\n\\nThe code:\\n\\n```cpp\\nconstexpr int facts[9] = {0, 1, 2, 6, 24, 120, 720, 5040, 40320};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), resSize = facts[len--], freqs[11] = {}, nFreqs[11] = {};\\n        // adjusting resSize\\n        for (int n: nums) {\\n            resSize /= ++(n > 0 ? freqs[n] : nFreqs[-n]);\\n        }\\n        vector<vector<int>> res(resSize);\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        res[0] = nums;\\n        // adding all the other permutations to res\\n        for (int i = 1, j, k, n; i < resSize; i++) {\\n            // replicating next_permutation(begin(nums), end(nums));\\n            j = len;\\n            while (j) {\\n                // creating a new permutation, only when the next number is lower\\n                if (nums[j - 1] < nums[j]) {\\n                    // preparing the inner loop variables\\n                    n = nums[j - 1], k = len;\\n                    // looking for the first number > n, from right\\n                    while (nums[k] <= n) k--;\\n                    // swapping the number right before j and the one pointed by k\\n                    swap(nums[j - 1], nums[k]);\\n                    // sorting the rest\\n                    if (j != len) sort(begin(nums) + j, end(nums));\\n                    break;\\n                }\\n                j--;\\n            }\\n            res[i] = nums;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nconstexpr int facts[9] = {0, 1, 2, 6, 24, 120, 720, 5040, 40320};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), resSize = facts[len--], freqs[11] = {}, nFreqs[11] = {};\\n        // adjusting resSize\\n        for (int n: nums) {\\n            resSize /= ++(n > 0 ? freqs[n] : nFreqs[-n]);\\n        }\\n        vector<vector<int>> res(resSize);\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        res[0] = nums;\\n        // adding all the other permutations to res\\n        for (int i = 1, j, k, n; i < resSize; i++) {\\n            // replicating next_permutation(begin(nums), end(nums));\\n            j = len;\\n            while (j) {\\n                // creating a new permutation, only when the next number is lower\\n                if (nums[j - 1] < nums[j]) {\\n                    // preparing the inner loop variables\\n                    n = nums[j - 1], k = len;\\n                    // looking for the first number > n, from right\\n                    while (nums[k] <= n) k--;\\n                    // swapping the number right before j and the one pointed by k\\n                    swap(nums[j - 1], nums[k]);\\n                    // sorting the rest\\n                    if (j != len) sort(begin(nums) + j, end(nums));\\n                    break;\\n                }\\n                j--;\\n            }\\n            res[i] = nums;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852855,
                "title": "c-very-very-simple-code-easy-to-understand",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n       int n=nums.size();\\n   \\t   vector<vector<int>> res;\\n       res.push_back(nums);\\n       map<vector<int>,int> mp;\\n       \\n       for(int i=0;i<n;++i){\\n           int sz=res.size();\\n           for(int t=0;t<sz;++t){\\n               vector<int> temp=res[t];\\n               for(int j=i+1;j<n;++j){\\n                   if(temp[i]==temp[j]) continue;\\n                   vector<int> temp2=temp;\\n                   swap(temp2[i],temp2[j]);\\n                   if(!mp[temp2]) res.push_back(temp2),mp[temp2]++;\\n               }\\n           }\\n       }\\n       return res;\\n   }\\n```\\n.\\nFor the [***Permutation***](https://leetcode.com/problems/permutations/) Problem :\\n```\\nvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        res.push_back(nums);\\n        \\n        for(int i=0;i<n;++i){\\n            int sz=res.size();\\n            for(int t=0;t<sz;++t){\\n                vector<int> temp=res[t];\\n                for(int j=i+1;j<n;++j){\\n                    vector<int> temp2=temp;\\n                    swap(temp2[i],temp2[j]);\\n                    res.push_back(temp2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\t\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n       int n=nums.size();\\n   \\t   vector<vector<int>> res;\\n       res.push_back(nums);\\n       map<vector<int>,int> mp;\\n       \\n       for(int i=0;i<n;++i){\\n           int sz=res.size();\\n           for(int t=0;t<sz;++t){\\n               vector<int> temp=res[t];\\n               for(int j=i+1;j<n;++j){\\n                   if(temp[i]==temp[j]) continue;\\n                   vector<int> temp2=temp;\\n                   swap(temp2[i],temp2[j]);\\n                   if(!mp[temp2]) res.push_back(temp2),mp[temp2]++;\\n               }\\n           }\\n       }\\n       return res;\\n   }\\n```\n```\\nvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        res.push_back(nums);\\n        \\n        for(int i=0;i<n;++i){\\n            int sz=res.size();\\n            for(int t=0;t<sz;++t){\\n                vector<int> temp=res[t];\\n                for(int j=i+1;j<n;++j){\\n                    vector<int> temp2=temp;\\n                    swap(temp2[i],temp2[j]);\\n                    res.push_back(temp2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733304,
                "title": "faster-than-99-57-javascript",
                "content": "The difference of this problem with it\\'s prequel is `the inputs of the last one are all \\'unique\\'`.\\nHaving duplicate numbers in the inputs also means that there will be duplicate outputs.\\n\\nTo prevent this, I could just create a `seen` variable that holds all the seen permutations but this will be inefficient since we still need to go through every permutation, even duplicates.\\n\\nOne optimization is to stop the recursion once we know that we are going through the same numbers again. This is where backtracking becomes handy. First thing to do is to sort the nums array. Next thing is to use a `prev` variable that holds the previous element for each iteration. This prev variable will help us know if we\\'ve already gone through the number and mitigate further waste of time and space.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const sorted = nums.sort((x,y) => x-y), permutations = [];\\n\\n    const rcr = (arr, permutation) => {\\n        if (!arr.length) return permutations.push(permutation);\\n\\n        let prev = -Infinity;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (prev === arr[i]) continue;\\n\\n            newArr = arr.slice(0, i).concat(arr.slice(i+1));\\n            rcr(newArr, [...permutation, arr[i]]);\\n\\n            prev = arr[i];\\n        }\\n    }\\n    rcr(nums, []);\\n\\n    return permutations;\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/ac9db05d-8ec1-4843-a1d5-047d9fc493a3_1643608089.8550267.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const sorted = nums.sort((x,y) => x-y), permutations = [];\\n\\n    const rcr = (arr, permutation) => {\\n        if (!arr.length) return permutations.push(permutation);\\n\\n        let prev = -Infinity;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (prev === arr[i]) continue;\\n\\n            newArr = arr.slice(0, i).concat(arr.slice(i+1));\\n            rcr(newArr, [...permutation, arr[i]]);\\n\\n            prev = arr[i];\\n        }\\n    }\\n    rcr(nums, []);\\n\\n    return permutations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714036,
                "title": "permutations-ii-c-0ms-solution-stl-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>vec;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            vec=nums;\\n            v.push_back(vec);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>vec;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            vec=nums;\\n            v.push_back(vec);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233163,
                "title": "c-backtracking-only-using-swap-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(vector<int>&a,int x)\\n    {\\n        if(x==a.size())\\n        ans.push_back(a);\\n        bool us[21]={0};\\n        for(int i=x;i<a.size();i++)\\n        {\\n            if(us[a[i]+10]==0)\\n            {\\n            swap(a[i],a[x]);\\n            help(a,x+1);\\n            swap(a[i],a[x]);\\n            us[a[i]+10]=1;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>&a) {\\n        help(a,0);\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if this help you**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(vector<int>&a,int x)\\n    {\\n        if(x==a.size())\\n        ans.push_back(a);\\n        bool us[21]={0};\\n        for(int i=x;i<a.size();i++)\\n        {\\n            if(us[a[i]+10]==0)\\n            {\\n            swap(a[i],a[x]);\\n            help(a,x+1);\\n            swap(a[i],a[x]);\\n            us[a[i]+10]=1;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>&a) {\\n        help(a,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995011,
                "title": "python-optimal-iterative-recursive-solutions-visuals",
                "content": "-----------------\\nSub-optimal Iterative DFS \\n----------------\\n-----------------\\n\\n**Big-O**\\n* Time: `O(N*N!) * (N!)` => `O(N*N!^2)` => that\\'s just awful!\\n\\t- the `N!` multiplier is for having to check if a path already has a duplicate in results.\\n\\t- Can also be expressed as `O(E+V)*(V!)` where V = verticies/nodes\\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\nstack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                if path not in res: # -- O(N!)\\n                    res.append(path)\\n            # children\\n            for i in range(len(nums)): # -- O(E)\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\\n\\n-----------------\\nOptimal Iterative DFS \\n----------------\\n-----------------\\n\\n\\n**Idea:**\\n* Eliminate the possibility of a duplicate from the get go rather than deal with it later and introduce higher time complexity.\\n* nums must be sorted. See below for a visual illustation.\\n\\n![image](https://assets.leetcode.com/users/images/21ffa2fe-c9ad-4121-ac26-79ba2aaa42bb_1609396957.1626086.png)\\n\\n\\n\\n**Big-O**\\n* Time:  `O(N*N!)` or `O(E+V)` \\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n        sort first\\n        nums.sort() # O(nlogn)\\n        \\n        stack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(E+V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                res.append(path)\\n            # children\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:  # --- Skip the sibling node if its the same as current node\\n                    continue\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\\n\\n\\n\\n-----------------\\nSub-optimal Recursive with backtracking \\n----------------\\n-----------------\\n\\n**Big-O**\\n* Time:  `O(N*N!^2)`\\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\\n\\n\\n\\n-----------------\\nOptimal Recursive with backtracking \\n----------------\\n-----------------\\n**Big-O**\\n* Time:  `O(N*N!)` or `O(E+V)` \\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\\n\\nFor a detailed and visual-rich explanation of the permutation problem, please refer to my post on **46.Permutations** => https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nstack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                if path not in res: # -- O(N!)\\n                    res.append(path)\\n            # children\\n            for i in range(len(nums)): # -- O(E)\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\n```\\ndef permuteUnique(self, nums):\\n        sort first\\n        nums.sort() # O(nlogn)\\n        \\n        stack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(E+V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                res.append(path)\\n            # children\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:  # --- Skip the sibling node if its the same as current node\\n                    continue\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 933086,
                "title": "golang-backtrack-0ms-solution",
                "content": "BackTrack with 3 key considerations :\\n1. Goal - find a combination with length equals to nums\\n2. Options - each element in nums\\n3. Constrains\\n3.1 Each element can be visited once\\n3.2 If there is a duplication, the first element has to be visited before second element\\n\\n\\n```\\nfunc permuteUnique(nums []int) [][]int {\\n    if len(nums) == 0 {\\n        return nil\\n    }\\n    sort.Ints(nums)\\n    res := make([][]int, 0)\\n    visited := make(map[int]bool)\\n    list := make([]int, 0)\\n    backTrack(nums, visited, list, &res) \\n    return res\\n}\\n\\nfunc backTrack(nums []int, visited map[int]bool, list []int, res *[][]int) {\\n    //back track goal, length of list equals to length of nums\\n    if len(list) == len(nums) {\\n        temp := make([]int, len(list))\\n        copy(temp, list) //copy list into temp, so it won\\'t impact subsequent process on list\\n        *res = append(*res, temp)\\n        return\\n    }\\n    \\n    //options are each elements in nums slice\\n    for i := 0; i < len(nums); i++ {\\n        if visited[i] {\\n            continue //constrain, ignore visited element\\n        }\\n        if i > 0 && nums[i] == nums[i - 1] && !visited[i - 1] {\\n            continue //constrain, if there is a duplication, the first element need to be visited first\\n        }\\n        list = append(list, nums[i])\\n        visited[i] = true\\n        backTrack(nums, visited, list, res)\\n        list = list[:len(list) - 1]\\n        visited[i] = false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc permuteUnique(nums []int) [][]int {\\n    if len(nums) == 0 {\\n        return nil\\n    }\\n    sort.Ints(nums)\\n    res := make([][]int, 0)\\n    visited := make(map[int]bool)\\n    list := make([]int, 0)\\n    backTrack(nums, visited, list, &res) \\n    return res\\n}\\n\\nfunc backTrack(nums []int, visited map[int]bool, list []int, res *[][]int) {\\n    //back track goal, length of list equals to length of nums\\n    if len(list) == len(nums) {\\n        temp := make([]int, len(list))\\n        copy(temp, list) //copy list into temp, so it won\\'t impact subsequent process on list\\n        *res = append(*res, temp)\\n        return\\n    }\\n    \\n    //options are each elements in nums slice\\n    for i := 0; i < len(nums); i++ {\\n        if visited[i] {\\n            continue //constrain, ignore visited element\\n        }\\n        if i > 0 && nums[i] == nums[i - 1] && !visited[i - 1] {\\n            continue //constrain, if there is a duplication, the first element need to be visited first\\n        }\\n        list = append(list, nums[i])\\n        visited[i] = true\\n        backTrack(nums, visited, list, res)\\n        list = list[:len(list) - 1]\\n        visited[i] = false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836504,
                "title": "c-backtracking-dfs",
                "content": "![image](https://assets.leetcode.com/users/images/eb4e8d5a-3b93-4c0a-a0cf-bd91114f0923_1600261272.6389656.png)\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, vector<int>& nums, vector<int>& curr, vector<bool>& used)\\n    {\\n        if(curr.size() == nums.size()){\\n            subset.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(used[i] == true)\\n                continue;\\n            curr.push_back(nums[i]);\\n            used[i] = true;\\n            dfs(subset, nums, curr, used);\\n            curr.pop_back();\\n            used[i] = false;\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        vector<bool> used(nums.size());\\n        dfs(subset, nums, curr, used);\\n        sort(subset.begin(), subset.end());\\n        subset.erase(unique(subset.begin(), subset.end()), subset.end());\\n        return subset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, vector<int>& nums, vector<int>& curr, vector<bool>& used)\\n    {\\n        if(curr.size() == nums.size()){\\n            subset.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(used[i] == true)\\n                continue;\\n            curr.push_back(nums[i]);\\n            used[i] = true;\\n            dfs(subset, nums, curr, used);\\n            curr.pop_back();\\n            used[i] = false;\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        vector<bool> used(nums.size());\\n        dfs(subset, nums, curr, used);\\n        sort(subset.begin(), subset.end());\\n        subset.erase(unique(subset.begin(), subset.end()), subset.end());\\n        return subset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528326,
                "title": "issac3-general-approach-to-backtracking-questions-in-cpp",
                "content": "Thanks ```Issac3``` for sharing. Here is same approach in C++. \\n\\nPermutation:\\nGiven a collection of distinct integers, return all possible permutations.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\\n\\nPermutation-II \\n\\n47. Permutations II\\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\\n\\n78. Subsets\\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\\n\\n90. Subsets II\\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\\n39. Combination Sum\\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\\n\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        backtrack(s, temp, result, 0);\\n        return result;        \\n    }\\n    \\n    void backtrack(string& s, vector<string>& temp, vector<vector<string>>& result, int start){\\n        \\n        if(start == s.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<s.size(); i++){\\n                if(isPalindrome(s, start, i)){\\n                    temp.emplace_back(s.substr(start, i-start+1));\\n                    backtrack(s, temp, result, i+1);\\n                    temp.pop_back();\\n                }\\n            }            \\n        }        \\n    }\\n    \\n    bool isPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "```Issac3```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430222,
                "title": "rust-0ms-9-lines",
                "content": "```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut res = vec![nums];\\n        loop {\\n            let cur = Self::next(res.last().unwrap().clone());\\n            if cur == res[0] {\\n                break;\\n            }\\n            res.push(cur);\\n        }\\n        res\\n    }\\n\\n    fn next(mut nums: Vec<i32>) -> Vec<i32> {\\n        if let Some(prev) = (0..nums.len()-1).rposition(|x| nums[x] < nums[x+1]) {\\n            let j = nums.iter().rposition(|&x| x > nums[prev]).unwrap();\\n            nums.swap(prev, j);\\n            nums[prev+1..].reverse();\\n        } else {\\n            nums.reverse();\\n        }\\n        nums\\n    }\\n}\\n```\\n\\nAnd shorter version (however *successors* is not supported by the rust of leetcode):\\n\\n```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        std::iter::successors(Some(nums.clone()), |n| {\\n            let mut cur = n.clone();\\n            if let Some(prev) = (0..cur.len()-1).rposition(|x| cur[x] < cur[x+1]) {\\n                let j = cur.iter().rposition(|&x| x > cur[prev]).unwrap();\\n                cur.swap(prev, j);\\n                cur[prev+1..].reverse();\\n            } else { cur.reverse(); }\\n            if cur == nums { None } else { Some(cur) }\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut res = vec![nums];\\n        loop {\\n            let cur = Self::next(res.last().unwrap().clone());\\n            if cur == res[0] {\\n                break;\\n            }\\n            res.push(cur);\\n        }\\n        res\\n    }\\n\\n    fn next(mut nums: Vec<i32>) -> Vec<i32> {\\n        if let Some(prev) = (0..nums.len()-1).rposition(|x| nums[x] < nums[x+1]) {\\n            let j = nums.iter().rposition(|&x| x > nums[prev]).unwrap();\\n            nums.swap(prev, j);\\n            nums[prev+1..].reverse();\\n        } else {\\n            nums.reverse();\\n        }\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        std::iter::successors(Some(nums.clone()), |n| {\\n            let mut cur = n.clone();\\n            if let Some(prev) = (0..cur.len()-1).rposition(|x| cur[x] < cur[x+1]) {\\n                let j = cur.iter().rposition(|&x| x > cur[prev]).unwrap();\\n                cur.swap(prev, j);\\n                cur[prev+1..].reverse();\\n            } else { cur.reverse(); }\\n            if cur == nums { None } else { Some(cur) }\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354605,
                "title": "functional-style-scala-solution",
                "content": "```Scala\\nobject Solution {\\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\\n        permute(nums.toList)\\n    }\\n    \\n    def permute(nums: List[Int]): List[List[Int]] = {\\n        nums match {\\n            case List() => List(List())\\n            case _ => for {\\n                x <- nums.distinct\\n                perm <- permute(removeElem(nums, x))\\n            } yield x :: perm\\n        } \\n    }\\n    \\n    def removeElem(nums: List[Int], n: Int): List[Int] = {\\n        nums match {\\n            case List() => List()\\n            case (x :: xs) => if (x == n) { xs } else { x :: removeElem(xs, n) }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\\n        permute(nums.toList)\\n    }\\n    \\n    def permute(nums: List[Int]): List[List[Int]] = {\\n        nums match {\\n            case List() => List(List())\\n            case _ => for {\\n                x <- nums.distinct\\n                perm <- permute(removeElem(nums, x))\\n            } yield x :: perm\\n        } \\n    }\\n    \\n    def removeElem(nums: List[Int], n: Int): List[Int] = {\\n        nums match {\\n            case List() => List()\\n            case (x :: xs) => if (x == n) { xs } else { x :: removeElem(xs, n) }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 145257,
                "title": "simple-recursive-python-solution-beats-100",
                "content": "    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n        res = []\\n        self.helper(res,nums,[])\\n        return res\\n    \\n    def helper(self, res, nums, path):\\n        if not nums:\\n            res.append(path)\\n            return\\n        dic = {x:1 for x in nums}\\n        \\n        for i in range(len(nums)):\\n            if dic[nums[i]] == 1:\\n                self.helper(res, nums[:i] + nums[i+1:], path + [nums[i]])\\n                dic[nums[i]] -= 1",
                "solutionTags": [],
                "code": "    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n        res = []\\n        self.helper(res,nums,[])\\n        return res\\n    \\n    def helper(self, res, nums, path):\\n        if not nums:\\n            res.append(path)\\n            return\\n        dic = {x:1 for x in nums}\\n        \\n        for i in range(len(nums)):\\n            if dic[nums[i]] == 1:\\n                self.helper(res, nums[:i] + nums[i+1:], path + [nums[i]])\\n                dic[nums[i]] -= 1",
                "codeTag": "Python3"
            },
            {
                "id": 18718,
                "title": "easy-iterative-solution-similar-with-permutations-i",
                "content": "     \\n       The solution is similar with permutations I problem, but added a condition\\n        Method: repetition numbers only have one permutation, e.g. [1,1,1,1].\\n           so each time only adding a number to the left of its repetition\\n           e.g. [1,2] --> [1,1,2] -->then stop. \\n \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\\n        ret.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<nums.length; i++){\\n            List<List<Integer>> save = new ArrayList<List<Integer>>();\\n            for(List<Integer> lst: ret){\\n                for(int j=0; j<=lst.size(); j++){\\n                    if(j != 0 && lst.get(j-1) == nums[i]) // stop here\\n                        break;\\n                    List<Integer> l = new ArrayList<Integer>(lst);\\n                    l.add(j, nums[i]);\\n                    save.add(l);\\n                }\\n            }\\n            ret = save;\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "     \\n       The solution is similar with permutations I problem, but added a condition\\n        Method: repetition numbers only have one permutation, e.g. [1,1,1,1].\\n           so each time only adding a number to the left of its repetition\\n           e.g. [1,2] --> [1,1,2] -->then stop. \\n \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\\n        ret.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<nums.length; i++){\\n            List<List<Integer>> save = new ArrayList<List<Integer>>();\\n            for(List<Integer> lst: ret){\\n                for(int j=0; j<=lst.size(); j++){\\n                    if(j != 0 && lst.get(j-1) == nums[i]) // stop here\\n                        break;\\n                    List<Integer> l = new ArrayList<Integer>(lst);\\n                    l.add(j, nums[i]);\\n                    save.add(l);\\n                }\\n            }\\n            ret = save;\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18742,
                "title": "simple-20-line-c-solution-using-backtracking-with-explanation",
                "content": "    // This question is mostly the same as Permutation I, but with an unordered_set to avoid duplicates. \\n    // The key point to avoid duplicates is to avoid selecting repeated numbers at the same position.\\n    class Solution {\\n    public:\\n        void myPermuteUnique(vector<vector<int>>& results, vector<int>& nums, int index){\\n            if (index == nums.size()) {\\n                results.push_back(nums);\\n                return;\\n            }\\n            unordered_set<int> M;\\n            for (int i = index; i < nums.size(); i ++) {\\n                if (M.find(nums[i]) != M.end()) continue; \\n                else M.insert(nums[i]);\\n                swap(nums[i], nums[index]);\\n                myPermuteUnique(results, nums, index+1);\\n                swap(nums[i], nums[index]);\\n            }\\n        }\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            vector<vector<int>> results;\\n            myPermuteUnique(results, nums, 0);\\n            return results;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void myPermuteUnique(vector<vector<int>>& results, vector<int>& nums, int index){\\n            if (index == nums.size()) {\\n                results.push_back(nums);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3985033,
                "title": "ermutations-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int n, vector<vector<int> > &result) {\\n        if(i == n-1){\\n            result.push_back(num);\\n            return;\\n        }\\n\\n        for(int k = i; k < n; k++){\\n            if(k != i && num[k] == num[i]) continue;\\n\\n            swap(num[k], num[i]);\\n            recursion(num, i+1, n, result);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n\\n        int n = num.size();\\n\\n        vector<vector<int>> result;\\n        recursion(num, 0, n, result);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int n, vector<vector<int> > &result) {\\n        if(i == n-1){\\n            result.push_back(num);\\n            return;\\n        }\\n\\n        for(int k = i; k < n; k++){\\n            if(k != i && num[k] == num[i]) continue;\\n\\n            swap(num[k], num[i]);\\n            recursion(num, i+1, n, result);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n\\n        int n = num.size();\\n\\n        vector<vector<int>> result;\\n        recursion(num, 0, n, result);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860836,
                "title": "c-2-backtrackings-frequency-set-swap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere 2 different kinds of backtracking solutions are provided. One uses frequency table. Other uses swaps. Since it is hard to avoid of duplicates using swaps, the C++ set comes to aid.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using frequency table\\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    int n0, sz;\\n    vector<int2> nWm;\\n    vector<vector<int>> result;\\n\\n    void backtrack(vector<int>& subset, vector<int2>& freq) {\\n        if (subset.size() == n0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        for (int i = 0; i < sz; i++) {\\n            if (freq[i].second > 0) {\\n                subset.push_back(nWm[i].first);\\n                freq[i].second--;\\n                backtrack(subset, freq);\\n                subset.pop_back();\\n                freq[i].second++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        nWm.push_back({ nums[0], 1 });\\n        int idx = 0;\\n        n0 = nums.size();\\n        for (int i = 1; i < n0; i++) {\\n            if (nums[i] == nums[i-1])\\n                nWm[idx].second++;\\n            else {\\n                nWm.push_back({ nums[i], 1 });\\n                idx++;\\n            }\\n        }\\n        sz=++idx;\\n\\n        vector<int> subset;\\n        backtrack(subset, nWm);\\n        return result;\\n    }\\n};\\n\\n\\n```\\n# Code for swap & set\\n```\\nclass Solution {\\npublic:\\n    int n;  \\n    set<vector<int>> ans;\\n    void f(int i, vector<int>& nums){\\n        if (i==n){// reach the end of nums\\n            ans.insert(nums);\\n            return ;\\n        } \\n        f(i+1, nums);\\n        for (int j=i+1; j<n; j++){\\n            if (nums[i]!=nums[j]){\\n                swap(nums[i], nums[j]);\\n                f(i+1, nums);\\n                swap(nums[i], nums[j]);\\n            } \\n        }\\n    }    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        f(0, nums);\\n        return vector<vector<int>>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    int n0, sz;\\n    vector<int2> nWm;\\n    vector<vector<int>> result;\\n\\n    void backtrack(vector<int>& subset, vector<int2>& freq) {\\n        if (subset.size() == n0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        for (int i = 0; i < sz; i++) {\\n            if (freq[i].second > 0) {\\n                subset.push_back(nWm[i].first);\\n                freq[i].second--;\\n                backtrack(subset, freq);\\n                subset.pop_back();\\n                freq[i].second++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        nWm.push_back({ nums[0], 1 });\\n        int idx = 0;\\n        n0 = nums.size();\\n        for (int i = 1; i < n0; i++) {\\n            if (nums[i] == nums[i-1])\\n                nWm[idx].second++;\\n            else {\\n                nWm.push_back({ nums[i], 1 });\\n                idx++;\\n            }\\n        }\\n        sz=++idx;\\n\\n        vector<int> subset;\\n        backtrack(subset, nWm);\\n        return result;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int n;  \\n    set<vector<int>> ans;\\n    void f(int i, vector<int>& nums){\\n        if (i==n){// reach the end of nums\\n            ans.insert(nums);\\n            return ;\\n        } \\n        f(i+1, nums);\\n        for (int j=i+1; j<n; j++){\\n            if (nums[i]!=nums[j]){\\n                swap(nums[i], nums[j]);\\n                f(i+1, nums);\\n                swap(nums[i], nums[j]);\\n            } \\n        }\\n    }    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        f(0, nums);\\n        return vector<vector<int>>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851561,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) \\n    {\\n        if (i == j-1) \\n        {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) \\n        {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) \\n    {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) \\n    {\\n        if (i == j-1) \\n        {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) \\n        {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) \\n    {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696518,
                "title": "backtracking-concept",
                "content": "# Backtracking concept\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362041,
                "title": "if-it-equals-the-previous-element-just-skip-it-simple-backtracking-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(remainder, path):\\n            remainder = remainder[:]\\n            path = path[:]\\n            if len(remainder) == 0:\\n                result.append(path)\\n            for i in range(len(remainder)):\\n                if i > 0 and remainder[i] == remainder[i-1]:\\n                    continue\\n                path.append(remainder[i])\\n                backtrack(remainder[0:i] + remainder[i+1:], path)\\n                path.pop()\\n            return\\n\\n        nums.sort()\\n        result = []\\n        backtrack(nums, [])\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(remainder, path):\\n            remainder = remainder[:]\\n            path = path[:]\\n            if len(remainder) == 0:\\n                result.append(path)\\n            for i in range(len(remainder)):\\n                if i > 0 and remainder[i] == remainder[i-1]:\\n                    continue\\n                path.append(remainder[i])\\n                backtrack(remainder[0:i] + remainder[i+1:], path)\\n                path.pop()\\n            return\\n\\n        nums.sort()\\n        result = []\\n        backtrack(nums, [])\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217602,
                "title": "8ms-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n        if (i == j-1) {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n            // swap(num[i], num[k]);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n        if (i == j-1) {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n            // swap(num[i], num[k]);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940506,
                "title": "easy-and-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res=set()\\n        def per(nm: List[int],x: List[int]) -> None:\\n            if nm ==[]:\\n                aa=\"\"\\n                for i in x:\\n                    aa+=str(i)+\"*\"\\n                res.add(aa)\\n            else:\\n                for i in range(len(nm)):    \\n                    nmc=nm[:i]+nm[i+1:]\\n                    xx=x.copy()\\n                    xx.append(nm[i])\\n                    per(nmc,xx)\\n        per(nums,[])\\n        r=[]\\n        for i in res:\\n            a=i.split(\\'*\\')\\n            a.pop()\\n            b=[]\\n            for j in a:\\n                b.append(int(j))\\n            r.append(b)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res=set()\\n        def per(nm: List[int],x: List[int]) -> None:\\n            if nm ==[]:\\n                aa=\"\"\\n                for i in x:\\n                    aa+=str(i)+\"*\"\\n                res.add(aa)\\n            else:\\n                for i in range(len(nm)):    \\n                    nmc=nm[:i]+nm[i+1:]\\n                    xx=x.copy()\\n                    xx.append(nm[i])\\n                    per(nmc,xx)\\n        per(nums,[])\\n        r=[]\\n        for i in res:\\n            a=i.split(\\'*\\')\\n            a.pop()\\n            b=[]\\n            for j in a:\\n                b.append(int(j))\\n            r.append(b)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422874,
                "title": "recursion-striver-approach-with-explanation-map-technique",
                "content": "**Algo:**\\n**Step 1**: Create a boolean map and while iterating the array, whenever you encounter an element then pick that element and mark the particular index as false \\n**Step 2:** Repeat until you reach the last element\\n**Step 3:** Once the list size matches the array size then we got our first combination\\n**Step 4:** After that remove that element from our list and mark the index as true for other combination(back tracking)\\n**Step 5:** To avoid duplicate entries, sort the array and check if the arr[i] == arr[i+1], if matches then we can skip the iteration by i++ ( We can use HashSet, but it will consume additional space - Not recommended)\\n\\nCredits to Striver for this type of approach\\nNote: We can use swap technique as well to generate all permutations.\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<List<Integer>>();\\n        boolean[] map=new boolean[nums.length];\\n        List<Integer> list=new ArrayList<Integer>();\\n        //sort the array so that duplicate entries will be next to each other\\n        Arrays.sort(nums);\\n        mapCombo(nums,map,res,list);\\n        return res;\\n    }\\n    \\n    private void mapCombo(int[] nums,boolean[] map,List<List<Integer>> res,List<Integer> list){\\n        \\n        //base condition : Whenever our list size becomes same as arr size, we got our combination\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(!map[i]){\\n                list.add(nums[i]);\\n                //Pick \\n                map[i]=true;\\n                mapCombo(nums,map,res,list);\\n                //Not pick\\n                map[i]=false;\\n                list.remove(list.size()-1);\\n                //to avoid duplicates combination\\n                while(i+1<nums.length && nums[i]==nums[i+1])i++;\\n                \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<List<Integer>>();\\n        boolean[] map=new boolean[nums.length];\\n        List<Integer> list=new ArrayList<Integer>();\\n        //sort the array so that duplicate entries will be next to each other\\n        Arrays.sort(nums);\\n        mapCombo(nums,map,res,list);\\n        return res;\\n    }\\n    \\n    private void mapCombo(int[] nums,boolean[] map,List<List<Integer>> res,List<Integer> list){\\n        \\n        //base condition : Whenever our list size becomes same as arr size, we got our combination\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(!map[i]){\\n                list.add(nums[i]);\\n                //Pick \\n                map[i]=true;\\n                mapCombo(nums,map,res,list);\\n                //Not pick\\n                map[i]=false;\\n                list.remove(list.size()-1);\\n                //to avoid duplicates combination\\n                while(i+1<nums.length && nums[i]==nums[i+1])i++;\\n                \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269821,
                "title": "simple-and-easy-to-understand-java-solution-100-accepted",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result= new ArrayList<>();\\n        Permutation(result,nums,0);\\n        return result;\\n    }\\n    public void Permutation(List<List<Integer>> result,int[] nums,int start){\\n        if(start==nums.length)\\n            result.add(toList(nums));\\n        for(int i=start;i<nums.length;i++){\\n            if(i!=start && !Permutate(start,i,nums))continue;\\n            \\n            swap(i,start,nums);\\n            Permutation(result,nums,start+1);\\n            swap(i,start,nums);\\n        }\\n    }\\n    public List<Integer> toList(int[] nums){\\n        List<Integer> res=new ArrayList<>();\\n        for(int i:nums)\\n            res.add(i);\\n        return res;\\n    }\\n    public void swap(int i,int j,int[] nums){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public boolean Permutate(int start,int j,int[] nums){\\n        for(int i=start;i<j;i++)\\n            if(nums[i]==nums[j])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result= new ArrayList<>();\\n        Permutation(result,nums,0);\\n        return result;\\n    }\\n    public void Permutation(List<List<Integer>> result,int[] nums,int start){\\n        if(start==nums.length)\\n            result.add(toList(nums));\\n        for(int i=start;i<nums.length;i++){\\n            if(i!=start && !Permutate(start,i,nums))continue;\\n            \\n            swap(i,start,nums);\\n            Permutation(result,nums,start+1);\\n            swap(i,start,nums);\\n        }\\n    }\\n    public List<Integer> toList(int[] nums){\\n        List<Integer> res=new ArrayList<>();\\n        for(int i:nums)\\n            res.add(i);\\n        return res;\\n    }\\n    public void swap(int i,int j,int[] nums){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public boolean Permutate(int start,int j,int[] nums){\\n        for(int i=start;i<j;i++)\\n            if(nums[i]==nums[j])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118718,
                "title": "backtrack-solution-using-treemap-in-java",
                "content": "```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n      List<List<Integer>> res = new ArrayList();\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        for(int i=0; i<nums.length; i++){\\n            int temp = nums[i];\\n            if(map.get(temp) == null) map.put(temp, 1);\\n            else{\\n                int a = map.get(temp);\\n                map.put(temp, a+1);\\n            }\\n        }\\n        backtrack(nums, res, new ArrayList(), map);\\n        return res;\\n    }\\n    private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> temp, TreeMap<Integer, Integer> map){\\n        if(temp.size() == nums.length){\\n            res.add(new ArrayList(temp));\\n            return;\\n        }\\n        for(int num : map.keySet()){\\n            int count = map.get(num);\\n            if(count == 0) continue;\\n            map.put(num, count-1);\\n            temp.add(num);\\n            backtrack(nums, res, temp, map);\\n            temp.remove(temp.size()-1);\\n            map.put(num, count);\\n        }\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n      List<List<Integer>> res = new ArrayList();\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        for(int i=0; i<nums.length; i++){\\n            int temp = nums[i];\\n            if(map.get(temp) == null) map.put(temp, 1);\\n            else{\\n                int a = map.get(temp);\\n                map.put(temp, a+1);\\n            }\\n        }\\n        backtrack(nums, res, new ArrayList(), map);\\n        return res;\\n    }\\n    private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> temp, TreeMap<Integer, Integer> map){\\n        if(temp.size() == nums.length){\\n            res.add(new ArrayList(temp));\\n            return;\\n        }\\n        for(int num : map.keySet()){\\n            int count = map.get(num);\\n            if(count == 0) continue;\\n            map.put(num, count-1);\\n            temp.add(num);\\n            backtrack(nums, res, temp, map);\\n            temp.remove(temp.size()-1);\\n            map.put(num, count);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033012,
                "title": "c-backtracking-easy-to-understand-dlc-may13",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        vector<int> check(nums.size(), 0);\\n        \\n        helper(ds, res, check, nums);\\n        return res;\\n    }\\n    \\n    void helper(vector<int> &ds, vector<vector<int>> &res, vector<int> &check, vector<int> &nums){\\n        if(ds.size() == nums.size() && !(find(res.begin(), res.end(), ds) != res.end())){\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(check[i]==0){        //if unchecked, can be pushed\\n                ds.push_back(nums[i]);\\n                check[i] = 1;   //check\\n                helper(ds, res, check, nums);\\n                ds.pop_back();\\n                check[i] = 0;   //uncheck\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        vector<int> check(nums.size(), 0);\\n        \\n        helper(ds, res, check, nums);\\n        return res;\\n    }\\n    \\n    void helper(vector<int> &ds, vector<vector<int>> &res, vector<int> &check, vector<int> &nums){\\n        if(ds.size() == nums.size() && !(find(res.begin(), res.end(), ds) != res.end())){\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(check[i]==0){        //if unchecked, can be pushed\\n                ds.push_back(nums[i]);\\n                check[i] = 1;   //check\\n                helper(ds, res, check, nums);\\n                ds.pop_back();\\n                check[i] = 0;   //uncheck\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031631,
                "title": "multiple-solutions-js-with-explanation",
                "content": "**Time complxities** for both the approaches is no worse then O(b^d)\\n\\nExample: [1,1,2] O(3^3)\\n\\n**Solution 1 Create Map**\\n\\n```\\nvar permuteUnique = function(nums) {\\n    let map = new Map();\\n    \\n\\t//Create map and count occurence of each num\\n    for(let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        \\n        if(map.has(n)) {\\n            map.set(n, map.get(n) + 1);\\n        } else {\\n            map.set(n, 1);\\n        }\\n    }\\n    \\n    let res = [];\\n    \\n    const recursePermute = (start, map, ds) => {\\n        if(ds.length === nums.length) {\\n            res.push([...ds]);\\n            return res;\\n        }\\n        \\n        for(const [key, value] of map.entries()) {\\n            let n = key;\\n            \\n\\t\\t\\t//If we have count then add it in our \"ds\"\\n            if(map.get(n) > 0) {\\n                map.set(n, map.get(n) - 1);\\n                ds.push(n);\\n                recursePermute(start, map, ds);\\n                ds.pop();\\n                map.set(n, map.get(n) + 1);\\n            }\\n        }\\n    }\\n    \\n    recursePermute(0, map, []);\\n    \\n    return res;\\n};\\n```\\n\\n**Solution 2 Without creating Map beforehand, but use Indexes instead**\\n\\n**Idea**:\\n\\nSince we have duplicate numbers, that\\'s why we have to create Map in Solution 1. Another approach we can think of is that, why not keep track of \"indexes\" rather then values on that indexes. \\n\\nExample:\\n\\nnums:      [1, 1, 2] \\nindexes:   0, 1, 2\\n \\nIn Set, we will have [0,1,2] and hence while backtracking for next iteration, we can ignore permutation created from this set using \"uniqueSet\" set variable\\n\\n```\\nvar permuteUnique = function(nums) {\\n    const len = nums.length;\\n\\t\\n    const ans = [];\\n    const set = new Set();\\n\\t\\n    const uniqueSet = new Set();\\n    \\n    const recursePermuteUnique = (set) => {\\n        if(set.size === len) {\\n            let temp = [];\\n\\t\\t\\t//Create permuation using indexes saved in set\\n            let str = \\'\\';\\n            set.forEach(d => { temp.push(nums[d]); str = str + nums[d]; });\\n            if(!uniqueSet.has(str)) {\\n                ans.push(temp);\\n                uniqueSet.add(str);\\n            }\\n            return null;\\n        }\\n        \\n\\t\\t//Track each permutation with indexes saved in the set. Hence, keeping track of unique values.\\n        for(let i = 0; i < len; i++) {\\n            if(!set.has(i)) {\\n                set.add(i);\\n                recursePermuteUnique(set);\\n                set.delete(i);\\n            }\\n        }\\n    }\\n    \\n    recursePermuteUnique(set);\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let map = new Map();\\n    \\n\\t//Create map and count occurence of each num\\n    for(let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        \\n        if(map.has(n)) {\\n            map.set(n, map.get(n) + 1);\\n        } else {\\n            map.set(n, 1);\\n        }\\n    }\\n    \\n    let res = [];\\n    \\n    const recursePermute = (start, map, ds) => {\\n        if(ds.length === nums.length) {\\n            res.push([...ds]);\\n            return res;\\n        }\\n        \\n        for(const [key, value] of map.entries()) {\\n            let n = key;\\n            \\n\\t\\t\\t//If we have count then add it in our \"ds\"\\n            if(map.get(n) > 0) {\\n                map.set(n, map.get(n) - 1);\\n                ds.push(n);\\n                recursePermute(start, map, ds);\\n                ds.pop();\\n                map.set(n, map.get(n) + 1);\\n            }\\n        }\\n    }\\n    \\n    recursePermute(0, map, []);\\n    \\n    return res;\\n};\\n```\n```\\nvar permuteUnique = function(nums) {\\n    const len = nums.length;\\n\\t\\n    const ans = [];\\n    const set = new Set();\\n\\t\\n    const uniqueSet = new Set();\\n    \\n    const recursePermuteUnique = (set) => {\\n        if(set.size === len) {\\n            let temp = [];\\n\\t\\t\\t//Create permuation using indexes saved in set\\n            let str = \\'\\';\\n            set.forEach(d => { temp.push(nums[d]); str = str + nums[d]; });\\n            if(!uniqueSet.has(str)) {\\n                ans.push(temp);\\n                uniqueSet.add(str);\\n            }\\n            return null;\\n        }\\n        \\n\\t\\t//Track each permutation with indexes saved in the set. Hence, keeping track of unique values.\\n        for(let i = 0; i < len; i++) {\\n            if(!set.has(i)) {\\n                set.add(i);\\n                recursePermuteUnique(set);\\n                set.delete(i);\\n            }\\n        }\\n    }\\n    \\n    recursePermuteUnique(set);\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031514,
                "title": "easy-c-using-set-of-vector-and-next-permutation-function",
                "content": "We sort nums[] and keep inserting every possible permutation into an unordered set of vectors which will automatically remove any redundancy.\\n\\n```\\nstruct hashsetofvector\\n      {\\n         size_t operator()(const vector<int> &myVector) const \\n         {\\n             std::hash<int> hasher;\\n             size_t answer = 0;\\n             for (int i : myVector) \\n            {\\n                answer ^= hasher(i) + 0x9e3779b9 + \\n                                  (answer << 6) + (answer >> 2);\\n           }\\n           return answer;\\n       }\\n   };\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n          unordered_set <vector<int>,hashsetofvector> s;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n            s.insert(nums);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        vector<vector<int>> ans;\\n        for(auto i:s)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct hashsetofvector\\n      {\\n         size_t operator()(const vector<int> &myVector) const \\n         {\\n             std::hash<int> hasher;\\n             size_t answer = 0;\\n             for (int i : myVector) \\n            {\\n                answer ^= hasher(i) + 0x9e3779b9 + \\n                                  (answer << 6) + (answer >> 2);\\n           }\\n           return answer;\\n       }\\n   };\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n          unordered_set <vector<int>,hashsetofvector> s;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n            s.insert(nums);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        vector<vector<int>> ans;\\n        for(auto i:s)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031402,
                "title": "python-diagram-tree-structure-recursion-explained",
                "content": "We need to generate all possible unique permutations and the numbers inside the input list can be duplicates.\\nTo remove redundant permutations, I have used **set** as it stores unique values by hashing. And hence, elements inside the set should be hashable. List is not hashable but tuple is. So, we stored **tuples** inside the set.\\n\\nNow, Iterate through each element of the list, add the element to answer and send the remaining list ahead to the recursive call for further operations.\\n\\n![image](https://assets.leetcode.com/users/images/aea6eade-637e-47be-bec3-ef215661fb12_1652344786.5857453.png)\\n\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.ans = set()\\n        def get_perms(nums, lst):\\n            if not nums:\\n                self.ans.add(tuple(lst.copy()))\\n                return\\n            for i in range(len(nums)):\\n                get_perms(nums[:i] + nums[i+1:], lst + [nums[i]])\\n        get_perms(nums, [])\\n        return list(self.ans)  \\n```\\n\\n***EDIT:***\\n**Time Complexity** can be given by the recursive formula: \\n* **T(n) = n * T(n-1) + c** (solving by substitution) **= O(n!) = O(n^n).**\\n\\n**Space Complexity** owing to the \"lst\" list *(see code)* at each level: Max depth = Number of elements = n,\\n*at level 1, lst size = 1\\nat level 2, lst size = 2\\n...\\nat level n, lst size = n*\\nAnd all the levels are called on top of one another in a stack as function calls, so all the list are stored simultaneously.\\nSpace complexity = 1 * 2 * 3 * ... * n **= n! = O(n^n)**.\\nAlso, we store and return a list of size O(n^n).",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.ans = set()\\n        def get_perms(nums, lst):\\n            if not nums:\\n                self.ans.add(tuple(lst.copy()))\\n                return\\n            for i in range(len(nums)):\\n                get_perms(nums[:i] + nums[i+1:], lst + [nums[i]])\\n        get_perms(nums, [])\\n        return list(self.ans)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031150,
                "title": "short-and-simple-backtracking-set",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n\\n    void permute(vector<int> &nums, int index) {\\n        if (index == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        unordered_set<int> s;\\n        for (int i = index; i < nums.size(); i++) {\\n            if (s.find(nums[i]) != s.end())    continue;\\n            s.insert(nums[i]);\\n            swap(nums[index], nums[i]);\\n            permute(nums, index + 1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permute(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n\\n    void permute(vector<int> &nums, int index) {\\n        if (index == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        unordered_set<int> s;\\n        for (int i = index; i < nums.size(); i++) {\\n            if (s.find(nums[i]) != s.end())    continue;\\n            s.insert(nums[i]);\\n            swap(nums[index], nums[i]);\\n            permute(nums, index + 1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permute(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031039,
                "title": "python-solution-continuing-permutation-i-faster-than-96-33",
                "content": "# Permutation I \\n**Solution**\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for x in nums :\\n                rem = list(nums)\\n                rem.remove(x)\\n                dfs(rem, curr + [x])\\n        res = []\\n        dfs(nums, [])\\n        return res\\n```\\n\\n**#1 :** The only change we need to do in our permutation I code for permutation II code is to take care of dupelicates and this can be done by just using set( ) in nums while using for loop to iterate over nums. Rest code is same and simple .\\n# Permutation II\\n**Solution**\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:   \\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for i in set(nums) : #1\\n                rem = list(nums)\\n                rem.remove(i)\\n                dfs(rem, curr + [i])\\n        res = []\\n        dfs(nums, [])    \\n        return res\\n```\\n**Pls do upvote .. if it helps in anyway :-)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for x in nums :\\n                rem = list(nums)\\n                rem.remove(x)\\n                dfs(rem, curr + [x])\\n        res = []\\n        dfs(nums, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:   \\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for i in set(nums) : #1\\n                rem = list(nums)\\n                rem.remove(i)\\n                dfs(rem, curr + [i])\\n        res = []\\n        dfs(nums, [])    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807660,
                "title": "easy-solution-with-image-explanation-c-set",
                "content": "Before Read, This solution try to solve **[Permutations](https://leetcode.com/problems/permutations/)** Problem. Then try the Permutations II problem by yourself. if you are not able to do then read my solution.\\n\\nWe used **Set** because we don\\'t need to store duplicates value.\\n\\nSame as the permutation but we store answer data in Set Data structure for unique value.\\n\\n![image](https://assets.leetcode.com/users/images/5489ffc0-0eac-4ef6-a5c6-43796adfeb23_1646078649.0260248.jpeg)\\n\\n\\n```\\nclass Solution {\\n    void solve(int ind ,vector<int>&nums ,set<vector<int>>&ans){\\n        if(ind == nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n             swap(nums[ind],nums[i]);\\n             solve(ind+1,nums,ans);\\n             swap(nums[ind],nums[i]);\\n        }\\n    }\\npublic:\\n      vector<vector<int>>permuteUnique(vector<int> &nums)\\n        {\\n            set<vector < int>> ans;\\n            vector<vector < int>> store;\\n            solve(0, nums, ans);\\n\\n            return  vector<vector < int>>(ans.begin(),ans.end());\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void solve(int ind ,vector<int>&nums ,set<vector<int>>&ans){\\n        if(ind == nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n             swap(nums[ind],nums[i]);\\n             solve(ind+1,nums,ans);\\n             swap(nums[ind],nums[i]);\\n        }\\n    }\\npublic:\\n      vector<vector<int>>permuteUnique(vector<int> &nums)\\n        {\\n            set<vector < int>> ans;\\n            vector<vector < int>> store;\\n            solve(0, nums, ans);\\n\\n            return  vector<vector < int>>(ans.begin(),ans.end());\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768113,
                "title": "java-backtracking-hashmap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int num:nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        backtracking(nums, result, map, new ArrayList<Integer>());\\n        return result;\\n    }\\n    private void backtracking(int[] nums, List<List<Integer>> result, Map<Integer, Integer> map, List<Integer> list){\\n        if (list.size() == nums.length){\\n            result.add(new ArrayList<Integer>(list));\\n                return;\\n        }\\n        for (Integer key: map.keySet()){\\n            if (map.get(key)>0){\\n                list.add(key);\\n                map.put(key, map.get(key) -1);\\n                backtracking(nums, result, map, list);\\n                map.put(key, map.get(key) +1);\\n                list.remove(list.size() -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int num:nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        backtracking(nums, result, map, new ArrayList<Integer>());\\n        return result;\\n    }\\n    private void backtracking(int[] nums, List<List<Integer>> result, Map<Integer, Integer> map, List<Integer> list){\\n        if (list.size() == nums.length){\\n            result.add(new ArrayList<Integer>(list));\\n                return;\\n        }\\n        for (Integer key: map.keySet()){\\n            if (map.get(key)>0){\\n                list.add(key);\\n                map.put(key, map.get(key) -1);\\n                backtracking(nums, result, map, list);\\n                map.put(key, map.get(key) +1);\\n                list.remove(list.size() -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560188,
                "title": "python-3-2-approaches",
                "content": "```\\nclass Solution:\\n\\t# Implement with a counter\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res, path = [], []\\n        count = Counter(nums)\\n        \\n        def dfs():\\n            if len(path) == len(nums):\\n                res.append(path.copy())\\n                return\\n            \\n            for num in count:\\n                if count[num] > 0:\\n                    count[num] -= 1\\n                    path.append(num)\\n                    dfs()\\n                    path.pop()\\n                    count[num] += 1\\n        dfs()\\n        return res\\n\\t\\n\\t# Implement with sort and (i, i-1) comparision\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        def dfs(nums, path = []):\\n            if not nums:\\n                res.append(path)\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]])\\n        dfs(nums)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\t# Implement with a counter\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res, path = [], []\\n        count = Counter(nums)\\n        \\n        def dfs():\\n            if len(path) == len(nums):\\n                res.append(path.copy())\\n                return\\n            \\n            for num in count:\\n                if count[num] > 0:\\n                    count[num] -= 1\\n                    path.append(num)\\n                    dfs()\\n                    path.pop()\\n                    count[num] += 1\\n        dfs()\\n        return res\\n\\t\\n\\t# Implement with sort and (i, i-1) comparision\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        def dfs(nums, path = []):\\n            if not nums:\\n                res.append(path)\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]])\\n        dfs(nums)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493203,
                "title": "python-swapping-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        result = []\\n        def dfs(start: int):\\n            if start == len(nums):\\n                result.append([]+nums)\\n                return\\n            lookup = {}\\n            for i in range(start,len(nums)):\\n                num = nums[i]\\n                if num not in lookup:\\n                    nums[i],nums[start] = nums[start],nums[i]\\n                    dfs(start+1)\\n                    nums[i],nums[start] = nums[start],nums[i]                    \\n                    lookup[num] = True\\n                    \\n        dfs(0)\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        result = []\\n        def dfs(start: int):\\n            if start == len(nums):\\n                result.append([]+nums)\\n                return\\n            lookup = {}",
                "codeTag": "Java"
            },
            {
                "id": 1463505,
                "title": "c-12ms-recursion",
                "content": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        util(nums, ans, 0, nums.size()-1);\\n        return ans;\\n        \\n    }\\n    \\n    void util(vector<int> nums, vector<vector<int>> &ans,\\n                            int l, int r){\\n        \\n        if(l==r){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = l;i<=r;i++){\\n                if(l != i && nums[l] == nums[i]) {\\n                    continue;\\n                }\\n                swap(nums[l], nums[i]);\\n                util(nums, ans, l+1, r);\\n            }\\n        }\\n        return;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        util(nums, ans, 0, nums.size()-1);\\n        return ans;\\n        \\n    }\\n    \\n    void util(vector<int> nums, vector<vector<int>> &ans,\\n                            int l, int r){\\n        \\n        if(l==r){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = l;i<=r;i++){\\n                if(l != i && nums[l] == nums[i]) {\\n                    continue;\\n                }\\n                swap(nums[l], nums[i]);\\n                util(nums, ans, l+1, r);\\n            }\\n        }\\n        return;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453394,
                "title": "python-dfs-easy-to-understand-with-sorting",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return self.dfs(sorted(nums), [], [])\\n\\n    def dfs(self, nums: List[int], path: List[int], res: List[List[int]]) -> List[List[int]]:\\n        if not nums: res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return self.dfs(sorted(nums), [], [])\\n\\n    def dfs(self, nums: List[int], path: List[int], res: List[List[int]]) -> List[List[int]]:\\n        if not nums: res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404856,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var permuteUnique = function(nums) {\\n        nums.sort((a,b) => {\\n            return a-b\\n        })\\n    \\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(nums, temp) {\\n            if(nums.length === 0) {\\n                result.push([...temp])\\n                return\\n            }\\n            \\n            for(let i=0; i<nums.length; i++) {\\n                if(i !== 0 && nums[i] == nums[i-1]) continue\\n                \\n                temp.push(nums[i])\\n                nums.splice(i, 1)\\n                backtracking(nums, temp)\\n                nums.splice(i, 0, temp.pop())\\n            }\\n        }\\n        backtracking(nums, temp)\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "\\n\\n    var permuteUnique = function(nums) {\\n        nums.sort((a,b) => {\\n            return a-b\\n        })\\n    \\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(nums, temp) {\\n            if(nums.length === 0) {\\n                result.push([...temp])\\n                return\\n            }\\n            \\n            for(let i=0; i<nums.length; i++) {\\n                if(i !== 0 && nums[i] == nums[i-1]) continue\\n                \\n                temp.push(nums[i])\\n                nums.splice(i, 1)\\n                backtracking(nums, temp)\\n                nums.splice(i, 0, temp.pop())\\n            }\\n        }\\n        backtracking(nums, temp)\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1087101,
                "title": "python-easy-recursion-beats-99",
                "content": "We solve the recursion by dividing into 2 disjoint subproblems:\\n* rec1: dont put num at index i\\n* rec2: put num at index i\\n\\nThis way we get all permutations without duplicates.\\n```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        res = [[]]\\n        for num, freq in Counter(nums).items():\\n            res = self.permuteRec(res, num, freq, 0)\\n        return res\\n    \\n    def permuteRec(self, perms, num, freq, i):\\n        if freq == 0: return perms\\n        if i == len(perms[0]): return [p + [num] * freq for p in perms]\\n        rec1 = self.permuteRec(perms, num, freq, i + 1)\\n        rec2 = self.permuteRec([p[:i] + [num] + p[i:] for p in perms], num, freq - 1, i + 1)\\n        return rec1 + rec2\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        res = [[]]\\n        for num, freq in Counter(nums).items():\\n            res = self.permuteRec(res, num, freq, 0)\\n        return res\\n    \\n    def permuteRec(self, perms, num, freq, i):\\n        if freq == 0: return perms\\n        if i == len(perms[0]): return [p + [num] * freq for p in perms]\\n        rec1 = self.permuteRec(perms, num, freq, i + 1)\\n        rec2 = self.permuteRec([p[:i] + [num] + p[i:] for p in perms], num, freq - 1, i + 1)\\n        return rec1 + rec2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038659,
                "title": "python-one-liner-set-o-n-space-sol",
                "content": "After doing `permutations i`, which I abstracted away with an `itertools` func, you should be able to wrap everything from there in a `set` and return in O(N) space\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def permute(nums: List[int]) -> List[List[int]]:\\n            return itertools.permutations(nums)\\n        p = permute(nums)\\n        s = set()\\n        for x in p:\\n            if x not in s:\\n                s.add(x)\\n        return s\\n```\\nwhich can be simplified to:\\n```py\\nreturn set(itertools.permutations(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def permute(nums: List[int]) -> List[List[int]]:\\n            return itertools.permutations(nums)\\n        p = permute(nums)\\n        s = set()\\n        for x in p:\\n            if x not in s:\\n                s.add(x)\\n        return s\\n```\n```py\\nreturn set(itertools.permutations(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933438,
                "title": "rust-heap-s-algorithm",
                "content": "https://en.wikipedia.org/wiki/Heap%27s_algorithm\\n\\n```\\nimpl Solution {\\n    pub fn permute_unique(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut permutes = vec![];\\n        let n = nums.len();\\n        fn permute(arr: &mut Vec<i32>, size: usize, soln: &mut Vec<Vec<i32>>) {\\n            if size == 0 {\\n                soln.push(arr.clone());\\n            } else {\\n                permute(arr, size-1, soln);\\n                /* if size is odd swap first and last element\\n                   if size is even swap the ith and last element */\\n                for i in 0..size-1 {\\n                    if (size & 1) != 0 {\\n                        arr.swap(0, size-1);\\n                    } else {\\n                        arr.swap(i, size-1);\\n                    }\\n                    permute(arr, size-1, soln);\\n                }\\n            }\\n        }\\n        permute(&mut nums, n, &mut permutes);\\n        permutes.sort_unstable();\\n        permutes.dedup();\\n        permutes\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn permute_unique(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut permutes = vec![];\\n        let n = nums.len();\\n        fn permute(arr: &mut Vec<i32>, size: usize, soln: &mut Vec<Vec<i32>>) {\\n            if size == 0 {\\n                soln.push(arr.clone());\\n            } else {\\n                permute(arr, size-1, soln);\\n                /* if size is odd swap first and last element\\n                   if size is even swap the ith and last element */\\n                for i in 0..size-1 {\\n                    if (size & 1) != 0 {\\n                        arr.swap(0, size-1);\\n                    } else {\\n                        arr.swap(i, size-1);\\n                    }\\n                    permute(arr, size-1, soln);\\n                }\\n            }\\n        }\\n        permute(&mut nums, n, &mut permutes);\\n        permutes.sort_unstable();\\n        permutes.dedup();\\n        permutes\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 933066,
                "title": "rust-backtracking-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut hm: HashMap<i32, usize> = HashMap::new();\\n        nums.iter()\\n            .for_each(|&num| *hm.entry(num).or_insert(0) += 1);\\n        let mut answer = Vec::new();\\n        let mut v = Vec::new();\\n        Solution::helper(&mut hm, &mut answer, &mut v);\\n        answer\\n    }\\n    fn helper(hm: &mut HashMap<i32, usize>, answer: &mut Vec<Vec<i32>>, v: &mut Vec<i32>) {\\n        let candidates: Vec<i32> = hm.iter().filter(|(_, &v)| v > 0).map(|(&k, _)| k).collect();\\n        if candidates.is_empty() {\\n            answer.push(v.clone());\\n        } else {\\n            for candidate in candidates.iter() {\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val -= 1;\\n                }\\n                v.push(*candidate);\\n                Solution::helper(hm, answer, v);\\n                v.pop();\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val += 1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut hm: HashMap<i32, usize> = HashMap::new();\\n        nums.iter()\\n            .for_each(|&num| *hm.entry(num).or_insert(0) += 1);\\n        let mut answer = Vec::new();\\n        let mut v = Vec::new();\\n        Solution::helper(&mut hm, &mut answer, &mut v);\\n        answer\\n    }\\n    fn helper(hm: &mut HashMap<i32, usize>, answer: &mut Vec<Vec<i32>>, v: &mut Vec<i32>) {\\n        let candidates: Vec<i32> = hm.iter().filter(|(_, &v)| v > 0).map(|(&k, _)| k).collect();\\n        if candidates.is_empty() {\\n            answer.push(v.clone());\\n        } else {\\n            for candidate in candidates.iter() {\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val -= 1;\\n                }\\n                v.push(*candidate);\\n                Solution::helper(hm, answer, v);\\n                v.pop();\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val += 1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932931,
                "title": "java-backtracking-solution-1ms",
                "content": "```\\nclass Solution {\\n  List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         if(nums.length == 0){\\n          return new ArrayList<>();\\n        }\\n      Arrays.sort(nums);\\n      boolean visited[] = new boolean[nums.length];\\n      List<Integer> sans = new ArrayList<>();\\n      permute_(nums , visited , sans , 0);\\n      return ans;\\n    }\\n  public void permute_(int nums[] , boolean visited[] , List<Integer> sans , int count){\\n     \\n       if(count == nums.length){\\n         List<Integer> list = new ArrayList<>(sans);\\n         ans.add(list);\\n         return;\\n       }\\n       int prev = -(int)1e8;\\n       for(int i=0 ; i<nums.length ; i++){\\n          \\n            if(!visited[i] && prev!=nums[i]){\\n              visited[i] = true;\\n              prev = nums[i];\\n              sans.add(nums[i]);\\n              permute_(nums , visited , sans , count + 1);\\n              sans.remove(sans.size()-1);\\n              visited[i] = false;\\n            }\\n         \\n       }\\n      \\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         if(nums.length == 0){\\n          return new ArrayList<>();\\n        }\\n      Arrays.sort(nums);\\n      boolean visited[] = new boolean[nums.length];\\n      List<Integer> sans = new ArrayList<>();\\n      permute_(nums , visited , sans , 0);\\n      return ans;\\n    }\\n  public void permute_(int nums[] , boolean visited[] , List<Integer> sans , int count){\\n     \\n       if(count == nums.length){\\n         List<Integer> list = new ArrayList<>(sans);\\n         ans.add(list);\\n         return;\\n       }\\n       int prev = -(int)1e8;\\n       for(int i=0 ; i<nums.length ; i++){\\n          \\n            if(!visited[i] && prev!=nums[i]){\\n              visited[i] = true;\\n              prev = nums[i];\\n              sans.add(nums[i]);\\n              permute_(nums , visited , sans , count + 1);\\n              sans.remove(sans.size()-1);\\n              visited[i] = false;\\n            }\\n         \\n       }\\n      \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825485,
                "title": "java-swap-solution-with-photo",
                "content": "![image](https://assets.leetcode.com/users/images/3841a6d4-5dab-403a-8230-fd12710db6fe_1599076859.8893676.png)\\n\\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        final List<List<Integer>> results = new LinkedList<>();\\n        Arrays.sort(nums);\\n        permutate(nums, 0, results);\\n        return results;\\n    }\\n\\n    private void permutate(int[] nums, int start, List<List<Integer>> results) {\\n        if (start == nums.length) {\\n            results.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n        } else {\\n            for (int i = start; i < nums.length; i++) {\\n                int j = i - 1;\\n                while (j >= start && nums[j] != nums[i]) {\\n                    --j;\\n                }\\n                if (j != start - 1) {\\n                    continue;\\n                }\\n                swap(nums, i, start);\\n                permutate(nums, start + 1, results);\\n                swap(nums, i, start);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] array, int i, int j) {\\n        if (i != j) {\\n            int temp = array[i];\\n            array[i] = array[j];\\n            array[j] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        final List<List<Integer>> results = new LinkedList<>();\\n        Arrays.sort(nums);\\n        permutate(nums, 0, results);\\n        return results;\\n    }\\n\\n    private void permutate(int[] nums, int start, List<List<Integer>> results) {\\n        if (start == nums.length) {\\n            results.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n        } else {\\n            for (int i = start; i < nums.length; i++) {\\n                int j = i - 1;\\n                while (j >= start && nums[j] != nums[i]) {\\n                    --j;\\n                }\\n                if (j != start - 1) {\\n                    continue;\\n                }\\n                swap(nums, i, start);\\n                permutate(nums, start + 1, results);\\n                swap(nums, i, start);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] array, int i, int j) {\\n        if (i != j) {\\n            int temp = array[i];\\n            array[i] = array[j];\\n            array[j] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 814879,
                "title": "javascript-simple-recursive-with-foreach-filter",
                "content": "```\\nvar permuteUnique = function(nums, prefix = [], mem = {}, ret = []) {\\n    if (!nums.length && !mem[prefix]) {\\n        ret.push(prefix);\\n        mem[prefix] = 1;\\n    }\\n\\n    nums.forEach((n, i) => permuteUnique(nums.filter((v, j) => i !== j), prefix.concat(n), mem, ret));\\n    \\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar permuteUnique = function(nums, prefix = [], mem = {}, ret = []) {\\n    if (!nums.length && !mem[prefix]) {\\n        ret.push(prefix);\\n        mem[prefix] = 1;\\n    }\\n\\n    nums.forEach((n, i) => permuteUnique(nums.filter((v, j) => i !== j), prefix.concat(n), mem, ret));\\n    \\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769214,
                "title": "short-c-code-using-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        do{\\n            res.push_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        do{\\n            res.push_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732823,
                "title": "javascript-backtracking-with-memory-store-to-skip-repeated-calls",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const res = [];\\n    const length = nums.length;\\n    const visited = new Array(length).fill(0);\\n    const memo = new Set();\\n    traverse(nums, res, [], length, visited, memo);\\n    return res;\\n};\\n\\nconst traverse = (nums, res, temp, length, visited, memo) => {\\n    if (temp.length === length) {\\n        res.push([...temp]);\\n        return;\\n        \\n    }\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (visited[i]) continue;\\n        visited[i] = 1;\\n        temp.push(nums[i]);\\n        if (memo.has(temp.join(\\'\\'))) {\\n            temp.pop();\\n            visited[i] = 0;\\n            continue;\\n        }\\n        memo.add(temp.join(\\'\\'));\\n        traverse(nums, res, temp, length, visited, memo);\\n        temp.pop();\\n        visited[i] = 0;\\n    }\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const res = [];\\n    const length = nums.length;\\n    const visited = new Array(length).fill(0);\\n    const memo = new Set();\\n    traverse(nums, res, [], length, visited, memo);\\n    return res;\\n};\\n\\nconst traverse = (nums, res, temp, length, visited, memo) => {\\n    if (temp.length === length) {\\n        res.push([...temp]);\\n        return;\\n        \\n    }\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (visited[i]) continue;\\n        visited[i] = 1;\\n        temp.push(nums[i]);\\n        if (memo.has(temp.join(\\'\\'))) {\\n            temp.pop();\\n            visited[i] = 0;\\n            continue;\\n        }\\n        memo.add(temp.join(\\'\\'));\\n        traverse(nums, res, temp, length, visited, memo);\\n        temp.pop();\\n        visited[i] = 0;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 632531,
                "title": "java-backtracking-simple-solution-runtime-1-ms-faster-than-99-07",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        permuteRecursive(nums, resultList, 0, nums.length);\\n        return resultList;\\n    }\\n    \\n    public void permuteRecursive(int[] nums, List<List<Integer>> resultList, int index, int length) {\\n        if(index == length) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            for (int n : nums)\\n                results.add(n);\\n            resultList.add(results);\\n            return;\\n        }\\n        \\n\\t\\t// Set - To avoid duplicates\\n        Set<Integer> set = new HashSet();\\n        \\n        for(int i=index; i<length; i++) {\\n            if(set.add(nums[i])) {\\n                swap(nums, index, i);\\n                permuteRecursive(nums, resultList, index+1, length);\\n                swap(nums, index, i);\\n            }\\n        }\\n    }\\n    \\n    public void swap(int[] nums, int firstIndex, int secondIndex) {\\n        int temp = nums[firstIndex];\\n        nums[firstIndex] = nums[secondIndex];\\n        nums[secondIndex] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        permuteRecursive(nums, resultList, 0, nums.length);\\n        return resultList;\\n    }\\n    \\n    public void permuteRecursive(int[] nums, List<List<Integer>> resultList, int index, int length) {\\n        if(index == length) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            for (int n : nums)\\n                results.add(n);\\n            resultList.add(results);\\n            return;\\n        }\\n        \\n\\t\\t// Set - To avoid duplicates\\n        Set<Integer> set = new HashSet();\\n        \\n        for(int i=index; i<length; i++) {\\n            if(set.add(nums[i])) {\\n                swap(nums, index, i);\\n                permuteRecursive(nums, resultList, index+1, length);\\n                swap(nums, index, i);\\n            }\\n        }\\n    }\\n    \\n    public void swap(int[] nums, int firstIndex, int secondIndex) {\\n        int temp = nums[firstIndex];\\n        nums[firstIndex] = nums[secondIndex];\\n        nums[secondIndex] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475950,
                "title": "python-solution-faster-than-98-14-and-100-in-memory",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        solution = []\\n        combination = []\\n        \\n        self.findPermutations(nums, combination, solution)\\n        return solution\\n    \\n    def findPermutations(self, nums, combination, solution):\\n        if nums == []:\\n            solution.append(list(combination))\\n            return\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            combination.append(nums[i])\\n            new_nums = nums[:i] + nums[i+1:]\\n            self.findPermutations(new_nums, combination, solution)\\n            combination.pop()\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        solution = []\\n        combination = []\\n        \\n        self.findPermutations(nums, combination, solution)\\n        return solution\\n    \\n    def findPermutations(self, nums, combination, solution):\\n        if nums == []:\\n            solution.append(list(combination))\\n            return\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            combination.append(nums[i])\\n            new_nums = nums[:i] + nums[i+1:]\\n            self.findPermutations(new_nums, combination, solution)\\n            combination.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357834,
                "title": "backtracking-solution-clean-and-simple-beat-100",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultSet = new ArrayList<>();\\n        List<Integer> permutation = new ArrayList<>();\\n        boolean[] visited = new boolean[nums.length];\\n        \\n        Arrays.sort(nums); // sort the array first\\n        dfs(nums, visited, permutation, resultSet);\\n        return resultSet;\\n    }\\n    \\n    public void dfs(int[] nums, boolean[] visited, List<Integer> permutation, List<List<Integer>> resultSet) {\\n        // find one permutation, add into the resultSet, exit of recursion\\n        if (permutation.size() == nums.length) {\\n            resultSet.add(new ArrayList<>(permutation));\\n            return;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            // number is the same as the previous one, avoid reusing it\\n            if (i > 0 && visited[i - 1] == false && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            permutation.add(nums[i]);\\n            visited[i] = true;\\n            dfs(nums, visited, permutation, resultSet);\\n            // Backtracking, modify the visited status\\n            permutation.remove(permutation.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultSet = new ArrayList<>();\\n        List<Integer> permutation = new ArrayList<>();\\n        boolean[] visited = new boolean[nums.length];\\n        \\n        Arrays.sort(nums); // sort the array first\\n        dfs(nums, visited, permutation, resultSet);\\n        return resultSet;\\n    }\\n    \\n    public void dfs(int[] nums, boolean[] visited, List<Integer> permutation, List<List<Integer>> resultSet) {\\n        // find one permutation, add into the resultSet, exit of recursion\\n        if (permutation.size() == nums.length) {\\n            resultSet.add(new ArrayList<>(permutation));\\n            return;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            // number is the same as the previous one, avoid reusing it\\n            if (i > 0 && visited[i - 1] == false && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            permutation.add(nums[i]);\\n            visited[i] = true;\\n            dfs(nums, visited, permutation, resultSet);\\n            // Backtracking, modify the visited status\\n            permutation.remove(permutation.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304952,
                "title": "swift-o-n-n-no-recursion-no-extra-memory",
                "content": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        \\n        var nums = nums\\n        nums.sort()\\n        \\n        var result = [[Int]]()\\n        result.append(nums)\\n        \\n        while true {\\n            \\n            var flipIndex = -1\\n            \\n            var i: Int = nums.count - 2\\n            while i >= 0 {\\n                if nums[i + 1] > nums[i] {\\n                    flipIndex = i\\n                    break\\n                }\\n                i -= 1\\n            }\\n            \\n            if flipIndex == -1 { break }\\n            \\n            var successorIndex: Int = -1\\n            var successorValue: Int = 0\\n            \\n            i = flipIndex + 1\\n            while i < nums.count {\\n                if nums[i] > nums[flipIndex] {\\n                    if successorIndex == -1 || nums[i] <= successorValue {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                }\\n                i += 1\\n            }\\n            \\n            nums.swapAt(successorIndex, flipIndex)\\n            \\n            var first: Int = flipIndex + 1\\n            var last: Int = nums.count - 1\\n            while first < last {\\n                nums.swapAt(first, last)\\n                last -= 1\\n                first += 1\\n            }\\n            result.append(nums)\\n        }\\n        return result\\n    }\\n}\\n```\\n\\nThis is my preferred way to solve this problem diue to no",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        \\n        var nums = nums\\n        nums.sort()\\n        \\n        var result = [[Int]]()\\n        result.append(nums)\\n        \\n        while true {\\n            \\n            var flipIndex = -1\\n            \\n            var i: Int = nums.count - 2\\n            while i >= 0 {\\n                if nums[i + 1] > nums[i] {\\n                    flipIndex = i\\n                    break\\n                }\\n                i -= 1\\n            }\\n            \\n            if flipIndex == -1 { break }\\n            \\n            var successorIndex: Int = -1\\n            var successorValue: Int = 0\\n            \\n            i = flipIndex + 1\\n            while i < nums.count {\\n                if nums[i] > nums[flipIndex] {\\n                    if successorIndex == -1 || nums[i] <= successorValue {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                }\\n                i += 1\\n            }\\n            \\n            nums.swapAt(successorIndex, flipIndex)\\n            \\n            var first: Int = flipIndex + 1\\n            var last: Int = nums.count - 1\\n            while first < last {\\n                nums.swapAt(first, last)\\n                last -= 1\\n                first += 1\\n            }\\n            result.append(nums)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567629,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1747883,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1634028,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567758,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1729127,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816527,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1732784,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2058722,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2052381,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2027146,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567629,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1747883,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1634028,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567758,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1729127,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816527,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1732784,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2058722,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2052381,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2027146,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            }
        ]
    }
]