[
    {
        "title": "Minimum Path Sum",
        "question_content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n\nExample 2:\n\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 200\n\t0 <= grid[i][j] <= 200",
        "solutions": [
            {
                "id": 23457,
                "title": "c-dp",
                "content": "This is a typical DP problem. Suppose the minimum path sum of arriving at point `(i, j)` is `S[i][j]`, then the state equation is `S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]`.\\n\\nWell, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (`S[i - 1][j]` does not exist) and the leftmost column (`S[i][j - 1]` does not exist). Suppose `grid` is like `[1, 1, 1, 1]`, then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is `[1, 2, 3, 4]`.\\n\\nNow we can write down the following (unoptimized) code.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size(); \\n            vector<vector<int> > sum(m, vector<int>(n, grid[0][0]));\\n            for (int i = 1; i < m; i++)\\n                sum[i][0] = sum[i - 1][0] + grid[i][0];\\n            for (int j = 1; j < n; j++)\\n                sum[0][j] = sum[0][j - 1] + grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                for (int j = 1; j < n; j++)\\n                    sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\\n            return sum[m - 1][n - 1];\\n        }\\n    };\\n\\nAs can be seen, each time when we update `sum[i][j]`, we only need `sum[i - 1][j]` (at the current column) and `sum[i][j - 1]` (at the left column). So we need not maintain the full `m*n` matrix. Maintaining two columns is enough and now we have the following code.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> pre(m, grid[0][0]);\\n            vector<int> cur(m, 0);\\n            for (int i = 1; i < m; i++)\\n                pre[i] = pre[i - 1] + grid[i][0];\\n            for (int j = 1; j < n; j++) { \\n                cur[0] = pre[0] + grid[0][j]; \\n                for (int i = 1; i < m; i++)\\n                    cur[i] = min(cur[i - 1], pre[i]) + grid[i][j];\\n                swap(pre, cur); \\n            }\\n            return pre[m - 1];\\n        }\\n    };\\n\\nFurther inspecting the above code, it can be seen that maintaining `pre` is for recovering `pre[i]`, which is simply `cur[i]` before its update. So it is enough to use only one vector. Now the space is further optimized and the code also gets shorter.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> cur(m, grid[0][0]);\\n            for (int i = 1; i < m; i++)\\n                cur[i] = cur[i - 1] + grid[i][0]; \\n            for (int j = 1; j < n; j++) {\\n                cur[0] += grid[0][j]; \\n                for (int i = 1; i < m; i++)\\n                    cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n            }\\n            return cur[m - 1];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size(); \\n            vector<vector<int> > sum(m, vector<int>(n, grid[0][0]));\\n            for (int i = 1; i < m; i++)\\n                sum[i][0] = sum[i - 1][0] + grid[i][0];\\n            for (int j = 1; j < n; j++)\\n                sum[0][j] = sum[0][j - 1] + grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                for (int j = 1; j < n; j++)\\n                    sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\\n            return sum[m - 1][n - 1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 344980,
                "title": "java-details-from-recursion-to-dp",
                "content": "I had been struggling for recursive and DP problems before. But now I feeling like I am getting better.\\nThis is a simple explanations for those who are still not that good at these just like me.\\n\\n1. Recursion:\\n\\nSo basically let\\'s begin with recursion because it is easier to understand and code. When we think about this problem, we could use a top down approach. To get a path, we need to travel from grid[0][0] to grid[row - 1][col - 1]. So let\\'s set grid[0][0] as the basic case. This is when we jump out of recursion. On the other hand, grid[row - 1][col - 1] would be the starting point. We write a helper function to do the recursion work. At the starting point, this function returns (value of the end cell + value of the cell that has the less one). But we need to consider that things could happen that we reached the first row or column and we gotta make sure that we stay within the array index limit.\\nAt last, when we reach grid[0][0], we are done!\\n\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            return min(grid, height - 1, width - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int row, int col){\\n\\n            if(row == 0 && col == 0) return grid[row][col]; // this is the exit of the recursion\\n            if(row == 0) return grid[row][col] + min(grid, row, col - 1); /** when we reach the first row, we could only move horizontally.*/\\n            if(col == 0) return grid[row][col] + min(grid, row - 1, col); /** when we reach the first column, we could only move vertically.*/\\n            return grid[row][col] + Math.min(min(grid, row - 1, col), min(grid, row, col - 1)); /** we want the min sum path so we pick the cell with the less value */\\n\\t\\t\\t\\n}\\n```\\n\\n2. Dynamic Programming:\\n\\nNow, let\\'s upgrade this algorithm from recursion to DP since we don\\'t wanna get stackoverflow for large inputs. In fact, there is nothing fancy about DP. It is simply that we store or cache the results of every single calculation so that we don\\'t need to calculate the same thing again and again. The whole idea is almost the same. We just involve an array to store the values. Now let\\'s see the code:\\n\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            for (int row = 0; row < height; row++) {\\n                for (int col = 0; col < width; col++) {\\n                    if(row == 0 && col == 0) grid[row][col] = grid[row][col];\\n                    else if(row == 0 && col != 0) grid[row][col] = grid[row][col] + grid[row][col - 1];\\n                    else if(col == 0 && row != 0) grid[row][col] = grid[row][col] + grid[row - 1][col];\\n                    else grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n                }\\n            }\\n            return grid[height - 1][width - 1];\\n        }\\n```\\n\\nLooks quite familiar, right? The idea is the same. It\\'s just we reused the grid to store each sum results to boost the whole process. See? That\\'s the difference from recursion and DP. Not that hard, right? I hope this could be helpful.",
                "solutionTags": [],
                "code": "```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            return min(grid, height - 1, width - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int row, int col){\\n\\n            if(row == 0 && col == 0) return grid[row][col]; // this is the exit of the recursion\\n            if(row == 0) return grid[row][col] + min(grid, row, col - 1); /** when we reach the first row, we could only move horizontally.*/\\n            if(col == 0) return grid[row][col] + min(grid, row - 1, col); /** when we reach the first column, we could only move vertically.*/\\n            return grid[row][col] + Math.min(min(grid, row - 1, col), min(grid, row, col - 1)); /** we want the min sum path so we pick the cell with the less value */\\n\\t\\t\\t\\n}\\n```\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            for (int row = 0; row < height; row++) {\\n                for (int col = 0; col < width; col++) {\\n                    if(row == 0 && col == 0) grid[row][col] = grid[row][col];\\n                    else if(row == 0 && col != 0) grid[row][col] = grid[row][col] + grid[row][col - 1];\\n                    else if(col == 0 && row != 0) grid[row][col] = grid[row][col] + grid[row - 1][col];\\n                    else grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n                }\\n            }\\n            return grid[height - 1][width - 1];\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345656,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n\\n# Video Solution\\n**Search \\uD83D\\uDC49 `Minimum Path Sum by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (1).png](https://assets.leetcode.com/users/images/7f71add2-6efd-46d3-82a0-a94fa2243b84_1679883432.537066.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\n- The code implements a dynamic programming approach to find the minimum path sum in a grid.\\n\\n- The algorithm uses a 2D array to store the minimum path sum to reach each position (i, j) in the grid, where i represents the row and j represents the column.\\n\\n- The minimum path sum to reach each position (i, j) is computed by taking the minimum of the path sum to reach the position above (i-1, j) and the position to the left (i, j-1), and adding the cost of the current position (i, j).\\n\\n- The minimum path sum to reach the bottom-right corner of the grid is stored in the last element of the array (grid[m-1][n-1]), where m is the number of rows and n is the number of columns in the grid.\\n\\n# Intuition:\\n\\n- The intuition behind the dynamic programming approach is that the minimum path sum to reach a position (i, j) in the grid can be computed by considering the minimum path sum to reach the positions (i-1, j) and (i, j-1).\\n\\n- This is because the only two possible ways to reach the position (i, j) are either by moving down from (i-1, j) or moving right from (i, j-1).\\n\\n- By computing the minimum path sum to reach each position in the grid, the algorithm can find the minimum path sum to reach the bottom-right corner of the grid by simply looking at the last element of the array (grid[m-1][n-1]).\\n\\n\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n            \\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n    \\n        # An Upvote will be encouraging\\n\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n            \\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n    \\n        # An Upvote will be encouraging\\n\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23466,
                "title": "simple-python-dp-70ms",
                "content": "\\n\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23471,
                "title": "dp-with-o-n-n-space-complexity",
                "content": "\\tpublic int minPathSum(int[][] grid) {\\n\\t\\tint m = grid.length;// row\\n\\t\\tint n = grid[0].length; // column\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0 && j != 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i][j - 1];\\n\\t\\t\\t\\t} else if (i != 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i - 1][j];\\n\\t\\t\\t\\t} else if (i == 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgrid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j])\\n\\t\\t\\t\\t\\t\\t\\t+ grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn grid[m - 1][n - 1];\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic int minPathSum(int[][] grid) {\\n\\t\\tint m = grid.length;// row\\n\\t\\tint n = grid[0].length; // column\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0 && j != 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i][j - 1];\\n\\t\\t\\t\\t} else if (i != 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i - 1][j];\\n\\t\\t\\t\\t} else if (i == 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgrid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j])\\n\\t\\t\\t\\t\\t\\t\\t+ grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn grid[m - 1][n - 1];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 584967,
                "title": "python-grid-reduction-sounds-fancy-but-a-simple-method-no-additional-space",
                "content": "Let\\'s think of this problem in a super simple manner.\\n\\nOne important thing to remember is you can only walk right and down.\\n*Notation I am going to use (row, column).*\\n\\nWe are going to walk over the cells (the two for loops in the code). And each time we step on a cell, we are going to ask a question to ourself, how can I get to this cell with minimum sum from the previous step? Well, for the first cell (0,0) we don\\'t need to do anything, right?\\n\\nNext, think of walking over cell (0,1). What is the minimum sum to get to this cell? Well, it is too simple, just add the current number in the cell with the number of the cell on the left (for the case of (0,1) add it with the number in (0,0). This behavior is same for all the cells in the topmost row.\\n\\nNow, we get to the second row, we ask the same qustion for the cell in (1,0). How can we get here with minimum sum? This is too simple, add the number in (1,0) with (0,0). But now, when we get to (1,1), we have to add the number in (1,1) with **minimum** number from the cell above and the cell on the left. By this time, your cell above and the one on the left already contains the minimum sum path up to that cell. How conveninet, right? ^_^\\n\\nThat\\'s all you gotta do. And whenever you step on the cell, update the cell accordingly.\\n\\nWe don\\'t even need to use any additional space, we will overwrite stuff in the original grid. Why can we do this? We can do this since we are processing the grid and every point that we are currently reaching at bascially has the minimum sum *up to that cell*. We are accumulating the minimum sum path as we walk over the grid.\\n\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) <= 0 or grid is None:\\n            return 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r==0 and c==0: # We just want to skip the top-left corner of the grid\\n                    continue\\n                if r-1<0: # Cases for elements in top row\\n                    grid[r][c] = grid[r][c] + grid[r][c-1]  \\n                elif c-1<0: # Cases for elements in leftmost column\\n                    grid[r][c] = grid[r][c] + grid[r-1][c]  \\n                else: # Normal cell\\n                    grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])               \\n        \\n        return grid[rows-1][cols-1] # We have got the minimum path accumaled at the bottom-right corner, just return this\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) <= 0 or grid is None:\\n            return 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r==0 and c==0: # We just want to skip the top-left corner of the grid\\n                    continue\\n                if r-1<0: # Cases for elements in top row\\n                    grid[r][c] = grid[r][c] + grid[r][c-1]  \\n                elif c-1<0: # Cases for elements in leftmost column\\n                    grid[r][c] = grid[r][c] + grid[r-1][c]  \\n                else: # Normal cell\\n                    grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])               \\n        \\n        return grid[rows-1][cols-1] # We have got the minimum path accumaled at the bottom-right corner, just return this\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23647,
                "title": "my-8-lines-simple-solution",
                "content": "    int m = grid.length, n = grid[0].length;\\n    for(int i = 0; i < m; i++){\\n    \\tfor(int j = 0; j < n; j++){\\n    \\tif(i == 0 && j != 0) grid[i][j] += grid[i][j-1];\\n    \\tif(i != 0 && j == 0) grid[i][j] += grid[i-1][j];\\n    \\tif (i != 0 && j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n    \\t}\\n    }\\n    return grid[m-1][n-1];",
                "solutionTags": [],
                "code": "    int m = grid.length, n = grid[0].length;\\n    for(int i = 0; i < m; i++){\\n    \\tfor(int j = 0; j < n; j++){\\n    \\tif(i == 0 && j != 0) grid[i][j] += grid[i][j-1];\\n    \\tif(i != 0 && j == 0) grid[i][j] += grid[i-1][j];\\n    \\tif (i != 0 && j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n    \\t}\\n    }\\n    return grid[m-1][n-1];",
                "codeTag": "Unknown"
            },
            {
                "id": 584892,
                "title": "c-crystal-clear-dp",
                "content": "Question Decoration:\\n* Consider the matrix as a rectangular plot,\\nand grids as houses\\n* Now, you have to go from top-left house to bottom right    house\\n* Also when you are in some house, you have to pay the rent\\n* You can move by only one house at a time, either to Right   house  or to Down house\\n* You have to find the minimum rent to reach the bottom-Right house\\n------------------------------------------------------------------------\\nSolution:\\nWhy DP???\\nBECAUSE this problem requires optimizing the rent(minimum rent),and at each step we have multiple options, therefore we will use DP\\nsteps:\\n* Create a dp array of same size as grid\\n* dp[0][0] = grid[0][0] , b\\'coz we are initially in this house\\n* dp[i][j] means minimum rent i need to pay to reach the house [i,j]\\n* for 0th row , there is only one way to reach any house, and that is by moving to right, therefore ,\\n          dp[0][i] = dp[0][i-1] + grid[0][i]  (rent paid so far + rent for this house)\\n* for 0th column, there is only one way to reach any house, and that is by moving down, therefore,\\n         dp[i][0] = dp[i-1][0] + grid[i][0]  (rent paid so far + rent for this house)\\n* And now for rest of the houses in the grid, say grid[i][j]\\n         * we can reach either from grid[i-1][j]\\n         * or from grid[i][j-1]\\n         * we will choose the one with minimum rent\\n         therefore, dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\\n* and .....\\nWe are Done \\uD83D\\uDE03\\n----------------------------------------\\nCODE:\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> dp(m,vector<int>(n,0));\\n    dp[0][0] = grid[0][0];\\n    for(int i=1;i<m;i++)\\n        dp[i][0] = dp[i-1][0] + grid[i][0];\\n    for(int j=1;j<n;j++)\\n        dp[0][j] = dp[0][j-1] + grid[0][j];\\n     for(int i=1;i<m;i++)\\n         for(int j=1;j<n;j++)\\n             dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];\\n        return dp[m-1][n-1];\\n    }",
                "solutionTags": [],
                "code": "Question Decoration:\\n* Consider the matrix as a rectangular plot,\\nand grids as houses\\n* Now, you have to go from top-left house to bottom right    house\\n* Also when you are in some house, you have to pay the rent\\n* You can move by only one house at a time, either to Right   house  or to Down house\\n* You have to find the minimum rent to reach the bottom-Right house\\n------------------------------------------------------------------------\\nSolution:\\nWhy DP???\\nBECAUSE this problem requires optimizing the rent(minimum rent),and at each step we have multiple options, therefore we will use DP\\nsteps:\\n* Create a dp array of same size as grid\\n* dp[0][0] = grid[0][0] , b\\'coz we are initially in this house\\n* dp[i][j] means minimum rent i need to pay to reach the house [i,j]\\n* for 0th row , there is only one way to reach any house, and that is by moving to right, therefore ,\\n          dp[0][i] = dp[0][i-1] + grid[0][i]  (rent paid so far + rent for this house)\\n* for 0th column, there is only one way to reach any house, and that is by moving down, therefore,\\n         dp[i][0] = dp[i-1][0] + grid[i][0]  (rent paid so far + rent for this house)\\n* And now for rest of the houses in the grid, say grid[i][j]\\n         * we can reach either from grid[i-1][j]\\n         * or from grid[i][j-1]\\n         * we will choose the one with minimum rent\\n         therefore, dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\\n* and .....\\nWe are Done \\uD83D\\uDE03\\n----------------------------------------\\nCODE:\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> dp(m,vector<int>(n,0));\\n    dp[0][0] = grid[0][0];\\n    for(int i=1;i<m;i++)\\n        dp[i][0] = dp[i-1][0] + grid[i][0];\\n    for(int j=1;j<n;j++)\\n        dp[0][j] = dp[0][j-1] + grid[0][j];\\n     for(int i=1;i<m;i++)\\n         for(int j=1;j<n;j++)\\n             dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];\\n        return dp[m-1][n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 856314,
                "title": "sequential-thought-recursion-memo-dp-faster-easy-understanding",
                "content": "```\\n// sequential thought process for this problem\\n\\n//The path to reach (m, n) must be through one of the 2 cells:(m-1, n) or (m, n-1). So minimum cost to reach (m, n) can be written as \\u201Cminimum of the 2 cells plus cost[m][n]\\u201D.\\n//minCost(m, n) =min(minCost(m-1, n), minCost(m, n-1) )+ cost[m][n]\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n        \\n      return cost[m][n]+min(minCost(cost,m-1,n),minCost(cost,m,n-1)); \\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int M=grid.size(),N=grid[0].size();\\n        return minCost(grid,M-1,N-1);\\n    }\\n    \\n};\\n\\n//2.memoization[faster than 71.35% ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>>& memo) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n      if(memo[m][n]!=-1)\\n          return memo[m][n];\\n      int r=cost[m][n]+min(minCost(cost,m-1,n,memo),minCost(cost,m,n-1,memo));\\n        memo[m][n]=r;\\n      return r;\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> memo(m,vector<int>(n, -1));\\n        return minCost(grid,m-1,n-1,memo);\\n    }\\n    \\n};\\n\\n//3. Dynamic Programming [ faster than 71.65% ] [ TC: (m*n) ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>> dp) { \\n      dp[m-1][n-1]=cost[m-1][n-1];\\n      for(int i=n-2;i>=0;i--){\\n          dp[m-1][i]=dp[m-1][i+1]+cost[m-1][i];\\n      } \\n      for(int i=m-2;i>=0;i--){\\n          dp[i][n-1]=dp[i+1][n-1]+cost[i][n-1];\\n      }\\n      for(int i=m-2;i>=0;i--){\\n          for(int j=n-2;j>=0;j--){\\n              dp[i][j]=cost[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n          }\\n      }\\n      return dp[0][0];\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n        return minCost(grid,m,n,dp);\\n    }\\n    \\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// sequential thought process for this problem\\n\\n//The path to reach (m, n) must be through one of the 2 cells:(m-1, n) or (m, n-1). So minimum cost to reach (m, n) can be written as \\u201Cminimum of the 2 cells plus cost[m][n]\\u201D.\\n//minCost(m, n) =min(minCost(m-1, n), minCost(m, n-1) )+ cost[m][n]\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n        \\n      return cost[m][n]+min(minCost(cost,m-1,n),minCost(cost,m,n-1)); \\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int M=grid.size(),N=grid[0].size();\\n        return minCost(grid,M-1,N-1);\\n    }\\n    \\n};\\n\\n//2.memoization[faster than 71.35% ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>>& memo) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n      if(memo[m][n]!=-1)\\n          return memo[m][n];\\n      int r=cost[m][n]+min(minCost(cost,m-1,n,memo),minCost(cost,m,n-1,memo));\\n        memo[m][n]=r;\\n      return r;\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> memo(m,vector<int>(n, -1));\\n        return minCost(grid,m-1,n-1,memo);\\n    }\\n    \\n};\\n\\n//3. Dynamic Programming [ faster than 71.65% ] [ TC: (m*n) ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>> dp) { \\n      dp[m-1][n-1]=cost[m-1][n-1];\\n      for(int i=n-2;i>=0;i--){\\n          dp[m-1][i]=dp[m-1][i+1]+cost[m-1][i];\\n      } \\n      for(int i=m-2;i>=0;i--){\\n          dp[i][n-1]=dp[i+1][n-1]+cost[i][n-1];\\n      }\\n      for(int i=m-2;i>=0;i--){\\n          for(int j=n-2;j>=0;j--){\\n              dp[i][j]=cost[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n          }\\n      }\\n      return dp[0][0];\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n        return minCost(grid,m,n,dp);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23477,
                "title": "dp-solution-linear-space",
                "content": "You can only reach a cell by going from its left or top neighbor.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int> > &grid) {\\n            if(!grid.size())return 0;\\n            const int rows=grid.size(),cols=grid[0].size();\\n            // r[i] == min path sum to previous row's column i.\\n            vector<int> r(cols,0);\\n            int i,j;\\n            r[0]=grid[0][0];\\n            for(j=1;j<cols;j++){\\n                r[j]=grid[0][j]+r[j-1];       \\n            }\\n            for(i=1;i<rows;i++){\\n                r[0]+=grid[i][0];\\n                for(j=1;j<cols;j++){\\n                    r[j]=min(r[j-1],r[j])+grid[i][j];\\n                }\\n            }\\n            return r[cols-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int> > &grid) {\\n            if(!grid.size())return 0;\\n            const int rows=grid.size(),cols=grid[0].size();\\n            // r[i] == min path sum to previous row's column i.\\n            vector<int> r(cols,0);\\n            int i,j;\\n            r[0]=grid[0][0];\\n            for(j=1;j<cols;j++){\\n                r[j]=grid[0][j]+r[j-1];       \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23613,
                "title": "python-easy-to-understand-solutions-o-m-n-o-n-space",
                "content": "```\\nclass Solution(object):\\n    def minPathSum1(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [[grid[0][0] for _ in range(c)] for _ in range(r)]\\n        for i in range(1, r):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, c):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[-1][-1]\\n    \\n    def minPathSum(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [grid[0][0] for _ in range(c)]\\n        for j in range(1, c):\\n            dp[j] = dp[j-1] + grid[0][j]\\n        for i in range(1, r):\\n            dp[0] += grid[i][0]\\n            for j in range(1, c):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPathSum1(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [[grid[0][0] for _ in range(c)] for _ in range(r)]\\n        for i in range(1, r):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, c):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[-1][-1]\\n    \\n    def minPathSum(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [grid[0][0] for _ in range(c)]\\n        for j in range(1, c):\\n            dp[j] = dp[j-1] + grid[0][j]\\n        for i in range(1, r):\\n            dp[0] += grid[i][0]\\n            for j in range(1, c):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345999,
                "title": "python3-c-dp-91-ms-beats-94-21",
                "content": "This code is an implementation of the minimum path sum problem on a 2D grid. The problem requires finding the minimum sum of numbers along a path from the top-left corner to the bottom-right corner of the grid.\\n\\nThe function takes a 2D list of integers grid as input, which represents the values in the grid. The function uses dynamic programming approach to solve the problem.\\n\\nFirst, the function determines the dimensions of the grid using the len() function. Then, it iterates over the grid using two nested for loops to check each cell of the grid.\\n\\nFor each cell, the function checks if it is on the top row or the leftmost column of the grid. If the cell is on the top row, the function adds the value of the cell to the value of the cell immediately to its left. Similarly, if the cell is on the leftmost column, the function adds the value of the cell to the value of the cell immediately above it.\\n\\nFor all other cells, the function adds the value of the cell to the minimum value of the cells directly above and directly to the left of the current cell.\\n\\nFinally, the function returns the value in the bottom-right corner of the grid, which represents the minimum path sum.\\n![image.png](https://assets.leetcode.com/users/images/6e1928e7-6041-4e68-afbc-504275ec9b60_1679888401.7288485.png)\\n# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if i==0:\\n                    if j!=0:\\n                        grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    if i!=0:\\n                        grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\\n        return grid[n-1][m-1]\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if i==0:\\n                    if j!=0:\\n                        grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    if i!=0:\\n                        grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\\n        return grid[n-1][m-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202628,
                "title": "c-three-solutions-recursion-top-down-bottom-up-easy-to-understand",
                "content": "**Recursive Solution**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j);\\n            m = min(m, s);\\n        }\\n        return m;\\n    }\\n    \\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Top Down DP - Memoization**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j, vector <vector<int>> &dp) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1, dp);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j, dp);\\n            m = min(m, s);\\n        }\\n        \\n        dp[i][j] = m;\\n        return dp[i][j];\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Bottom Up DP - Table Filling**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        vector <vector <int>> dp(r, vector <int>(c, 0));\\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 1; i < c; i++) {\\n            dp[0][i] = grid[0][i] + dp[0][i - 1];\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            dp[i][0] = grid[i][0] + dp[i - 1][0];\\n        }\\n\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n         \\n        return dp[r - 1][c - 1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint getMinPath(vector <vector <int>> &grid, int i, int j) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j);\\n            m = min(m, s);\\n        }\\n        return m;\\n    }\\n    \\n```\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j, vector <vector<int>> &dp) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1, dp);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j, dp);\\n            m = min(m, s);\\n        }\\n        \\n        dp[i][j] = m;\\n        return dp[i][j];\\n    }\\n```\n```\\nint getMinPath(vector <vector <int>> &grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        vector <vector <int>> dp(r, vector <int>(c, 0));\\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 1; i < c; i++) {\\n            dp[0][i] = grid[0][i] + dp[0][i - 1];\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            dp[i][0] = grid[i][0] + dp[i - 1][0];\\n        }\\n\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n         \\n        return dp[r - 1][c - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467216,
                "title": "python-bottom-up-dp-in-place-clean-concise",
                "content": "**Idea**\\n- For the current cell `[r, c]`, there are two options to choose:\\n\\t- Choose from up cell `[r-1, c]` go down to `[r, c]`.\\n\\t- Choose from left cell `[r, c-1]` go right to `[r, c]`.\\n- So, we need to choose minium cost between 2 above options.\\n```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 and c == 0:\\n                    pass\\n                elif r == 0:\\n                    grid[r][c] += grid[r][c-1]\\n                elif c == 0:\\n                    grid[r][c] += grid[r-1][c]\\n                else:\\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\\n        return grid[m-1][n-1]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 and c == 0:\\n                    pass\\n                elif r == 0:\\n                    grid[r][c] += grid[r][c-1]\\n                elif c == 0:\\n                    grid[r][c] += grid[r-1][c]\\n                else:\\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\\n        return grid[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23532,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Minimum Path Sum**https://leetcode.com/problems/minimum-path-sum/\\n\\n**Dynamic Programming using Memoization**\\n* Start Point: 0, 0. Destination Point: M-1, N-1\\n* Cost[i,j]: The cost to reach destination from (i,j). Matrix is initialized to inf.\\n* The solution will be cost(0,0)\\n* Initialize the cost matrix with boundary condition. cost[M-1,N-1]=grid[M-1,N-1]\\n* Be careful with what you return for out of bound grid points. Make sure you return infinity so that they are ignored within the min equation\\n* Time and Space Complexity: O(MN)\\n```\\nclass Solution(object):\\n    def helper(self, x, y, grid, cost):\\n        M, N = len(grid), len(grid[0])\\n        if x == M or y == N:\\n            return float('inf')\\n        elif cost[x][y] != -1:\\n            return cost[x][y]\\n        else:\\n            right, down = self.helper(x,y+1,grid,cost), self.helper(x+1,y,grid,cost)\\n            cost[x][y] = min(right, down) + grid[x][y]\\n        return cost[x][y]\\n    \\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[-1]*N for _ in range(M)]\\n        cost[M-1][N-1] = grid[M-1][N-1]\\n        return self.helper(0, 0, grid, cost)\\n```\\n\\n**Dynamic Programming: O(MN) space**\\n* Start Point: 0, 0. Destination Point: M-1, N-1\\n* Cost[i,j]: The cost to reach (i,j) from (0,0). We initialize  \\n* The solution will be cost(M-1,N-1)\\n* Time & Space Complexity:O(MN)\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[0]*N for _ in range(M)]\\n        cost[0][0] = grid[0][0]\\n        for j in range(1,N):\\n            cost[0][j] = grid[0][j] + cost[0][j-1]\\n        for i in range(1,M):\\n            cost[i][0] = grid[i][0] + cost[i-1][0]\\n        for i in range(1,M):\\n            for j in range(1,N):\\n                cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j]\\n        return cost[M-1][N-1]\\n```\\n\\n**Dynamic Programming: Using O(N) space**\\n* Space complexity can be reduced to O(N) since we only require the previous row to compute the current row.\\n* Note that we initialize the cost array to inf. Note how we initialize cost[0] at every row iteration.\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [float('inf')]*N\\n        for i in range(M):\\n            cost[0] = grid[i][0] + cost[0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                cost[j] = min(cost[j-1], cost[j]) + grid[i][j]\\n        return cost[-1]\\n```\\n\\n**Dynamic Programming: Using O(1) space**\\n* Space complexity can be reduced to O(1) as grid can be reused as cost matrix\\n* Notice how we iterate the two loops and the special condition we use for i=0\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        for i in range(M):\\n            grid[i][0] = grid[i][0] + grid[i-1][0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] if i > 0 else grid[i][j-1]+grid[i][j]\\n        return grid[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, x, y, grid, cost):\\n        M, N = len(grid), len(grid[0])\\n        if x == M or y == N:\\n            return float('inf')\\n        elif cost[x][y] != -1:\\n            return cost[x][y]\\n        else:\\n            right, down = self.helper(x,y+1,grid,cost), self.helper(x+1,y,grid,cost)\\n            cost[x][y] = min(right, down) + grid[x][y]\\n        return cost[x][y]\\n    \\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[-1]*N for _ in range(M)]\\n        cost[M-1][N-1] = grid[M-1][N-1]\\n        return self.helper(0, 0, grid, cost)\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[0]*N for _ in range(M)]\\n        cost[0][0] = grid[0][0]\\n        for j in range(1,N):\\n            cost[0][j] = grid[0][j] + cost[0][j-1]\\n        for i in range(1,M):\\n            cost[i][0] = grid[i][0] + cost[i-1][0]\\n        for i in range(1,M):\\n            for j in range(1,N):\\n                cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j]\\n        return cost[M-1][N-1]\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [float('inf')]*N\\n        for i in range(M):\\n            cost[0] = grid[i][0] + cost[0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                cost[j] = min(cost[j-1], cost[j]) + grid[i][j]\\n        return cost[-1]\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        for i in range(M):\\n            grid[i][0] = grid[i][0] + grid[i-1][0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] if i > 0 else grid[i][j-1]+grid[i][j]\\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502072,
                "title": "javascript-95-speed-o-mn-time-o-1-space-w-comments",
                "content": "```\\nvar minPathSum = function(grid) {\\n\\t// Get the two dimensions of the grid\\n    const n = grid.length;\\n    const m = grid[0].length;\\n    \\n\\t// Calculate the distance travelled within the first column\\n\\t// This is because each square depends on the one above\\n\\t// And the one to the left. However there is nothing left\\n\\t// of the first column so we can calculate it by adding\\n\\t// the current square to the square above it\\n    for(let i=1; i<n; i++) {\\n        grid[i][0] += grid[i-1][0];\\n    }\\n    \\n\\t// The same goes for the first row. There is nothing above the \\n\\t// first row. So we just calculate the distance by what is to the left\\n\\t// of it\\n    for(let j=1; j<m; j++) {\\n        grid[0][j] += grid[0][j-1];\\n    }\\n    \\n\\t// Start one row and one column in because we\\'ve precomputed\\n\\t// those above\\n    for(let i=1; i<n; i++) {\\n        for(let j=1; j<m; j++) {\\n\\t\\t\\t// The distance to the grid at i,j is equal to itself plus the minimum\\n\\t\\t\\t// of the two grid spaces (one above, one to the left)\\n            grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        }\\n    }\\n    \\n\\t// Return the distance bottom right corner\\n    return grid[n-1][m-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathSum = function(grid) {\\n\\t// Get the two dimensions of the grid\\n    const n = grid.length;\\n    const m = grid[0].length;\\n    \\n\\t// Calculate the distance travelled within the first column\\n\\t// This is because each square depends on the one above\\n\\t// And the one to the left. However there is nothing left\\n\\t// of the first column so we can calculate it by adding\\n\\t// the current square to the square above it\\n    for(let i=1; i<n; i++) {\\n        grid[i][0] += grid[i-1][0];\\n    }\\n    \\n\\t// The same goes for the first row. There is nothing above the \\n\\t// first row. So we just calculate the distance by what is to the left\\n\\t// of it\\n    for(let j=1; j<m; j++) {\\n        grid[0][j] += grid[0][j-1];\\n    }\\n    \\n\\t// Start one row and one column in because we\\'ve precomputed\\n\\t// those above\\n    for(let i=1; i<n; i++) {\\n        for(let j=1; j<m; j++) {\\n\\t\\t\\t// The distance to the grid at i,j is equal to itself plus the minimum\\n\\t\\t\\t// of the two grid spaces (one above, one to the left)\\n            grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        }\\n    }\\n    \\n\\t// Return the distance bottom right corner\\n    return grid[n-1][m-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345863,
                "title": "image-explanation-recursion-dp-4-methods-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`)\\n`Minimum Path Sum` by `Aryan Mittal`\\n![meta5.png](https://assets.leetcode.com/users/images/ba681d93-09f3-4124-8452-da3ff1212d19_1679887228.3219895.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/1e83ac93-0c25-49f7-a1bc-5d19636b9c7c_1679883307.3522673.png)\\n![image.png](https://assets.leetcode.com/users/images/3d44f039-7517-4742-be15-675c7f45f7e4_1679883343.370807.png)\\n![image.png](https://assets.leetcode.com/users/images/7ec80aa0-711a-4e46-be05-33efca08da7e_1679883363.6013312.png)\\n![image.png](https://assets.leetcode.com/users/images/5df527f7-94c4-430d-b241-ba92925aa010_1679883392.19581.png)\\n![image.png](https://assets.leetcode.com/users/images/39a67687-3976-4fdd-a4e6-48ef70c2b867_1679883404.3252819.png)\\n![image.png](https://assets.leetcode.com/users/images/bf0d85ae-ff30-4140-a094-fbc4e5b10946_1679883414.034133.png)\\n![image.png](https://assets.leetcode.com/users/images/e98a682a-52a3-4e86-9a63-46f4408f3a04_1679883421.3524578.png)\\n![image.png](https://assets.leetcode.com/users/images/a03890d0-83f0-44dc-a008-2cac56151a9c_1679883428.471258.png)\\n![image.png](https://assets.leetcode.com/users/images/eb14045b-08d6-4774-b456-ff345390b3ee_1679883436.9386165.png)\\n\\n\\n\\n# Method1 Code: By Modifying the Grid O(1) Space\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n```\\n\\n# Method4 Code: Without Modifying the Grid O(m) Space\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] cur = new int[m];\\n        cur[0] = grid[0][0];\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0];\\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                cur[i] = Math.min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cur = [grid[0][0]] * m\\n        \\n        for i in range(1, m):\\n            cur[i] = cur[i - 1] + grid[i][0]\\n        \\n        for j in range(1, n):\\n            cur[0] += grid[0][j]\\n            for i in range(1, m):\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]\\n        \\n        return cur[m - 1]\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] cur = new int[m];\\n        cur[0] = grid[0][0];\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0];\\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                cur[i] = Math.min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cur = [grid[0][0]] * m\\n        \\n        for i in range(1, m):\\n            cur[i] = cur[i - 1] + grid[i][0]\\n        \\n        for j in range(1, n):\\n            cur[0] += grid[0][j]\\n            for i in range(1, m):\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]\\n        \\n        return cur[m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825410,
                "title": "python3-dynamic-programming-90-w-explaination",
                "content": "Dynamic programming is all about breaking the whole problem into smaller problems in which you can then minimize, which will result in the whole problem being minimized. In this question, we should notice that the minimum path sum for each cell is the smaller value between the cell itself plus the cell above it or the the cell itself plus the cell to the left of it. So, as you visit each future cell and refer to previous cells to the left and above you, you know that those cells have been optimized to have the minimum path sum for that index - thus obtaining the most optimal path.\\n\\nFor example,\\n```\\n[1,3,1],\\n[1,5,1],\\n[4,2,1]\\n```\\n* **grid[0][1]**, there is a cell to the left of it (grid[0][0] = 1) and no cell above it, this means we know that the minimum path sum for this cell is at best 4 (3 + 1).\\n* **grid[0][2]**, similar to grid[0][1], at best is 5 (1 + 4)\\n* **grid[1][0]**, there is a cell above (grid[0][0] = 1) and no cell to the left of it, this means we know that the minimum path sum for this cell is at best 2 (1 + 1).\\n* **grid[1][1]**, there is a cell above and also a cell to the left of it, we will need to add a cell (grid[0][1] = 4 or grid[1][0] = 2) that will result in the current cell having the smallest sum possible. It is ideal to add grid[1][0], thus the minimum path sum for this cell is at best 7 (2 + 5).\\n* **grid[1][2]**, similar to grid[1][1], at best is 6 (1 + 5)\\n* **grid[2][0]**, similar to grid[1][0], at best is 6 (4 + 2)\\n* **grid[2][1]**, similar to grid[1][1], at best is 8 (2 + 6)\\n* **grid[2][2]**, similar to grid[1][1], at best is 7 (1 + 6)\\n\\nThe resulting DP array - you can put your calculated results for each cell in a seperate 2D array or do it in-place (which I did).\\n```\\n[1,4,5],\\n[2,7,6],\\n[6,8,7]\\n```\\nHere is the actual code:\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i > 0 and j > 0:\\n                    grid[i][j] = min(grid[i][j] + grid[i-1][j], grid[i][j] + grid[i][j-1])\\n                elif i > 0:\\n                    grid[i][j] += grid[i-1][j]\\n                elif j > 0:\\n                    grid[i][j] += grid[i][j-1]\\n        \\n        return grid[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n[1,3,1],\\n[1,5,1],\\n[4,2,1]\\n```\n```\\n[1,4,5],\\n[2,7,6],\\n[6,8,7]\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i > 0 and j > 0:\\n                    grid[i][j] = min(grid[i][j] + grid[i-1][j], grid[i][j] + grid[i][j-1])\\n                elif i > 0:\\n                    grid[i][j] += grid[i-1][j]\\n                elif j > 0:\\n                    grid[i][j] += grid[i][j-1]\\n        \\n        return grid[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180305,
                "title": "my-java-dp-solution-easy-to-understand-beats-96",
                "content": "The idea is to sum up the first row and first column as there is no way to reach to that point other than to go right or down respectively. For the rest of the grid[i][j] (for all i >1 and j >1) find the minimum of the grid-left (j-1) and grid-top (i-1) value and add to the current grid value. At the end, the minimum path sum would be the buttom last value in the grid.\n\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        \n        for(int i=1; i<grid.length; i++) {\n            grid[i][0] = grid[i-1][0] + grid[i][0];\n        }\n        for(int j=1; j<grid[0].length; j++) {\n            grid[0][j] = grid[0][j-1] + grid[0][j];\n        }\n        for(int i=1; i<grid.length; i++) {\n            for(int j=1; j<grid[0].length; j++) {\n                grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        \n        for(int i=1; i<grid.length; i++) {\n            grid[i][0] = grid[i-1][0] + grid[i][0];\n        }\n        for(int j=1; j<grid[0].length; j++) {\n            grid[0][j] = grid[0][j-1] + grid[0][j];\n        }\n        for(int i=1; i<grid.length; i++) {\n            for(int j=1; j<grid[0].length; j++) {\n                grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345894,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\nTo find the minimum sum path from the top left corner to the bottom right corner of the grid, we can use dynamic programming. We create a dp table to store the minimum sum path to each cell. The value in the (i, j) cell of the dp table represents the minimum sum path from the top left corner to that cell. We can then fill the dp table using the values from the grid.\\n\\n\\n\\n# Approach\\n- Initialize the dp table with the value of the top left corner of the grid.\\n- Fill the first row of the dp table by adding the values in the previous cell and the current cell in the grid.\\n- Fill the first column of the dp table by adding the values in the previous cell and the current cell in the grid.\\n- Fill the rest of the dp table by taking the minimum of the value above and the value to the left of the current cell in the dp table, and adding the value in the current cell of the grid.\\n- Return the value in the bottom right corner of the dp table, which represents the minimum sum path from the top left corner to the bottom right corner of the grid.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of nodes in the graph. We visit each node at most once, and perform constant-time operations on each node.\\n\\n- Space complexity: O(n), where n is the number of nodes in the graph. We use an array of size n to keep track of the time at which we visit each node.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // Fill the first row\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        \\n        // Fill the first row\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Create a dp table to store the minimum sum path to each cell\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        \\n        # Fill the first row\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] + grid[0][i]\\n        \\n        # Fill the first column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        \\n        # Fill the rest of the dp table\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        \\n        return dp[m-1][n-1]\\n\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // Fill the first row\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        \\n        // Fill the first row\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Create a dp table to store the minimum sum path to each cell\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        \\n        # Fill the first row\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] + grid[0][i]\\n        \\n        # Fill the first column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        \\n        # Fill the rest of the dp table\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        \\n        return dp[m-1][n-1]\\n\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329435,
                "title": "python-dijkstra-s-with-topological-sort-o-e-v-time",
                "content": "Because we can only move down or right, we are given a directional acyclic graph (DAG) and do not need to check for cycles.\\n\\nWe also do not need to use a priority queue to select our next minimum distance vertex to visit.\\n\\nInstead we can use topological sort to make the next vertex selection, and process vertices which have an indegree of 0. This results in a linear O(|E| + |V|) time solution instead of O(|E| log |V|) with priority queue.\\n\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n\\n        distances = {}\\n        adj_to = defaultdict(dict)\\n        indegree = defaultdict(int)\\n        \\n        for i, row in enumerate(grid):\\n            for j, dist in enumerate(row):\\n                distances[(i,j)] = float(\"inf\")\\n                if i > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i-1,j)][(i,j)] = dist\\n                if j > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i,j-1)][(i,j)] = dist\\n        \\n        to_visit = deque([((0,0), grid[0][0])])\\n        \\n        distances[(0,0)] = grid[0][0]\\n        \\n        while to_visit:\\n            cur, cur_dist = to_visit.popleft()\\n            \\n            for adj in adj_to[cur]:\\n                this_dist = cur_dist + adj_to[cur][adj]\\n                distances[adj] = min(this_dist,distances[adj])\\n                indegree[adj] -= 1\\n                if indegree[adj] == 0:\\n                    to_visit.append((adj, distances[adj]))\\n            \\n        return distances[max(distances)]\\n                \\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n\\n        distances = {}\\n        adj_to = defaultdict(dict)\\n        indegree = defaultdict(int)\\n        \\n        for i, row in enumerate(grid):\\n            for j, dist in enumerate(row):\\n                distances[(i,j)] = float(\"inf\")\\n                if i > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i-1,j)][(i,j)] = dist\\n                if j > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i,j-1)][(i,j)] = dist\\n        \\n        to_visit = deque([((0,0), grid[0][0])])\\n        \\n        distances[(0,0)] = grid[0][0]\\n        \\n        while to_visit:\\n            cur, cur_dist = to_visit.popleft()\\n            \\n            for adj in adj_to[cur]:\\n                this_dist = cur_dist + adj_to[cur][adj]\\n                distances[adj] = min(this_dist,distances[adj])\\n                indegree[adj] -= 1\\n                if indegree[adj] == 0:\\n                    to_visit.append((adj, distances[adj]))\\n            \\n        return distances[max(distances)]\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190409,
                "title": "java-best-recursive-memo-dp-solution",
                "content": "Start from basics and move forward.\\n\\n1. Recursive.\\n\\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        return find(grid, m, n);\\n\\t\\t}\\n    public int find(int grid[][], int m, int n)\\n    {\\n        if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        return grid[m][n] + Math.min(find(grid, m-1, n),find(grid, m, n-1)); \\n   }\\n}\\n```\\n\\n2. Memo Based Solution\\n\\n```\\nclass Solution \\n{\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        \\n        memo = new int[m+1][n+1];\\n        \\n        return find(grid, m, n, memo);\\n    }\\n    public int find(int grid[][], int m, int n, int[][] memo)\\n    {\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        \\n        else if(memo[m][n]!=0)\\n            return memo[m][n];\\n        else\\n            return memo[m][n] =  grid[m][n] + Math.min(find(grid, m-1, n, memo),find(grid, m, n-1, memo)); \\n}\\n    }\\n```\\n\\n3. Dp Based Solution\\n\\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        //Initialisation\\n        int[][] dp = new int[m][n];\\n        \\n        //Base Case Transformation\\n        \\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[0][i]  = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            dp[i][0]  = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        //Main logic\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j] = Math.min(dp[i][j-1] , dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\nI hope you get the solutions.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        return find(grid, m, n);\\n\\t\\t}\\n    public int find(int grid[][], int m, int n)\\n    {\\n        if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        return grid[m][n] + Math.min(find(grid, m-1, n),find(grid, m, n-1)); \\n   }\\n}\\n```\n```\\nclass Solution \\n{\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        \\n        memo = new int[m+1][n+1];\\n        \\n        return find(grid, m, n, memo);\\n    }\\n    public int find(int grid[][], int m, int n, int[][] memo)\\n    {\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        \\n        else if(memo[m][n]!=0)\\n            return memo[m][n];\\n        else\\n            return memo[m][n] =  grid[m][n] + Math.min(find(grid, m-1, n, memo),find(grid, m, n-1, memo)); \\n}\\n    }\\n```\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        //Initialisation\\n        int[][] dp = new int[m][n];\\n        \\n        //Base Case Transformation\\n        \\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[0][i]  = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            dp[i][0]  = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        //Main logic\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j] = Math.min(dp[i][j-1] , dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23555,
                "title": "ac-java-dp-solution-v-s-tle-dijstra-solution",
                "content": "When I looked at this question, the first thought was the Dijkstra solution, which is a very fast algorithm to calculate the shortest path. But this solution got TLE in this question, while DP solution worked fine.\\n\\nI will talk about the Dijkstra solution first, as it's the first though came into my mind, and there is already discussions on the DP solution. If you are not interested in the Dijkstra solution, you can jump to the latter part of this post, which is about the DP solution, which is accepted.\\n\\n**Dijkstra**\\nThe idea of Dijkstra algorithm is to divide the graph into 2 parts, visited and unvisited. \\nFor every node in the visited part has a *dist* value. Then we need to exam every edges across the visited part and the unvisited parts, which are edges that its start node is in the visited part, while its end node is in the unvisited part. What we are looking for is one edge, which has the minimum value of (dist(start node) + the edge's value). Then we put this node into the visited part and exam the edges again.\\n\\nFollowing is the code. It uses a Java Heap, PriorityQueue to keep track of the minimum (dist(start node) + the edge's value), but in this question, the edge value is in the node itself, which is the same for every edges ending to it, so actually the heap just keeps track of the mimimum dist(start node) of every unvisited nodes around the boarder between visited and unvisited.\\n\\n    public class Solution_dijkstra {\\n\\t\\n\\tclass PointComparator implements Comparator<int[]>{\\n    \\tint[][] dist;\\n    \\tpublic PointComparator(int[][] dist){\\n    \\t\\tthis.dist = dist;\\n    \\t}\\n    \\t@Override\\n    \\tpublic int compare(int[] o1, int[] o2) {\\n    \\t\\tint[] point1 = (int[])o1;\\n            int[] point2 = (int[])o2;\\n            return Integer.valueOf(dist[point1[0]][point1[1]])\\n                .compareTo(Integer.valueOf(dist[point2[0]][point2[1]]));\\n        }\\n    }\\n    \\t\\n    public int minPathSum(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dist = new int[m][n];\\n        \\n        for(int x = 0; x < m; x++){\\n            for(int y = 0; y < n; y++){\\n                dist[x][y] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        dist[0][0] = grid[0][0];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( m*n, new PointComparator(dist));\\n        \\n        pq.add(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] point = pq.poll();\\n            int x = point[0];\\n            int y = point[1];\\n            int d = dist[x][y];\\n            \\n            if(x == n-1 && y == m-1){\\n                return d;\\n            }\\n            \\n            visited[x][y] = true;\\n            \\n            if((y+1 < n) && !visited[x][y+1]){\\n                dist[x][y+1] = min(\\n                    dist[x][y+1],\\n                    d + grid[x][y+1]);\\n                pq.add(new int[]{x, y+1});\\n            }\\n            \\n            if((x+1 < m ) && !visited[x+1][y]){\\n                dist[x+1][y] = min(\\n                    dist[x+1][y],\\n                    d + grid[x+1][y]);\\n                pq.add(new int[]{x+1, y});\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    private int min(int i1, int i2){\\n    \\treturn i1 < i2 ? i1 : i2;\\n    }\\n\\n\\n} \\n\\n\\nThis solution got LTE error, mostly because of the priority queue and doesn't consider the special condition here that it's a grid and directed, which means a node can only be accessed from it's left and upper nodes. Put all these into consideration, we have the DP solution. It's essentially formula is\\n\\ndist(node) = min( dist(upper node), dist(left node)) + node's value\\n\\n**DP**\\nhere is the code:\\n\\n    public class Solution_dp {\\n\\t\\n\\tprivate int getDist(int[][] dist, int x, int y){\\n\\t\\tif(x < 0 || y < 0){\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn dist[x][y];\\t\\t\\n\\t}\\n\\t\\n\\tprivate int min(int i1, int i2){\\n\\t\\treturn i1 < i2 ? i1 : i2;\\n\\t}\\n\\t\\n\\t\\n\\tpublic int minPathSum(int[][] grid) {\\n\\n\\t\\tif(grid == null || grid.length == 0) return 0;\\n\\t\\t\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\t\\n\\t\\tint[][] dist = new int[m][n];\\n\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\n\\t\\tfor(int x = 0; x < m; x++){\\n\\t\\t\\tfor(int y = 0; y < n; y++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(x == 0 && y == 0){\\n\\t\\t\\t\\t\\tdist[0][0] = grid[0][0];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tdist[x][y] = min(getDist(dist, x-1, y), getDist(dist, x, y-1))  + grid[x][y];\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t}\\n\\t\\n\\t\\treturn dist[m-1][n-1];\\n\\t\\t\\t\\t\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution_dijkstra {\\n\\t\\n\\tclass PointComparator implements Comparator<int[]>{\\n    \\tint[][] dist;\\n    \\tpublic PointComparator(int[][] dist){\\n    \\t\\tthis.dist = dist;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3345882,
                "title": "6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat",
                "content": "# Intuition\\nTry to reach every points with minimium path sum.\\n\\n# Approach\\nReach to each point but alwasy with minimum path sum possible \\n```\\n<!-- Assume we need to reach ar[i][j]  -->\\n<!-- always check minimum possiblle rach value near by it -->\\nar[i][j] = ar[i][j] + min(ar[i-1][j],ar[i][j-1])\\n```\\nThat is all aproch and there is given 6 ways\\n\\n# CODES\\n\\n# Simple recursion start from (0,0) to (n,n) filling (TLE)\\n- Time complexity: O(2^n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        int a = fun(gr,i+1,j);\\n        int b = fun(gr,i,j+1);\\n        return gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0);\\n    }\\n};\\n``` \\n# Simple recursion start from (n,n) to (0,0) filling (TLE)\\n- Time complexity: O(2^n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j  ){\\n        if(i==0 && j==0) return gr[i][j];\\n        if(i<0 || j<0) return 1e8;\\n        return gr[i][j] + min(fun(gr,i-1,j),fun(gr,i,j-1));\\n    }\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1);\\n    }\\n};\\n```\\n# Recursion + memoization (n,n) to (0,0) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ,vector<vector<int>> &dp ){\\n        if(i==0 && j==0) return gr[i][j];\\n\\n        if(i<0 || j<0)  return 1e8;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        return dp[i][j] = gr[i][j] + min(fun(gr,i-1,j,dp),fun(gr,i,j-1,dp));\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1,dp);\\n    }\\n};\\n```\\n# Recursion + memoization (0,0) to (n,n) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j, vector<vector<int>> &dp){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = fun(gr,i+1,j,dp);\\n        int b = fun(gr,i,j+1,dp);\\n        return dp[i][j] = gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0,dp);\\n    }\\n};\\n\\n```\\n# Tabulation (0,0) to (n,n) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i=0;i<gr.size();i++){\\n            for(int j=0; j<gr[0].size();j++){\\n                if(i==0 && j==0) dp[i][j] = gr[i][j];\\n                else{\\n                    int a=1e7,b=1e7;\\n                    if(i>0)\\n                        a= dp[i-1][j];\\n                    if(j>0)\\n                        b = dp[i][j-1];\\n                    dp[i][j] = gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[gr.size()-1][gr[0].size()-1];\\n    }\\n};\\n\\n```\\n# Tabulation (n,n) to (0,0) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i = gr.size()-1; i>=0;i--){\\n            for(int j= gr[0].size()-1;j>=0;j--){\\n                if(i==gr.size()-1 && j==gr[0].size()-1) dp[i][j] = gr[i][j];\\n                else{\\n                    int a= 1e8, b= 1e8;\\n                    if(i < gr.size()-1)\\n                        a = dp[i+1][j];\\n                    if(j < gr[0].size()-1)\\n                        b= dp[i][j+1];\\n                    dp[i][j]=gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<!-- Assume we need to reach ar[i][j]  -->\\n<!-- always check minimum possiblle rach value near by it -->\\nar[i][j] = ar[i][j] + min(ar[i-1][j],ar[i][j-1])\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        int a = fun(gr,i+1,j);\\n        int b = fun(gr,i,j+1);\\n        return gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j  ){\\n        if(i==0 && j==0) return gr[i][j];\\n        if(i<0 || j<0) return 1e8;\\n        return gr[i][j] + min(fun(gr,i-1,j),fun(gr,i,j-1));\\n    }\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ,vector<vector<int>> &dp ){\\n        if(i==0 && j==0) return gr[i][j];\\n\\n        if(i<0 || j<0)  return 1e8;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        return dp[i][j] = gr[i][j] + min(fun(gr,i-1,j,dp),fun(gr,i,j-1,dp));\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j, vector<vector<int>> &dp){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = fun(gr,i+1,j,dp);\\n        int b = fun(gr,i,j+1,dp);\\n        return dp[i][j] = gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0,dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i=0;i<gr.size();i++){\\n            for(int j=0; j<gr[0].size();j++){\\n                if(i==0 && j==0) dp[i][j] = gr[i][j];\\n                else{\\n                    int a=1e7,b=1e7;\\n                    if(i>0)\\n                        a= dp[i-1][j];\\n                    if(j>0)\\n                        b = dp[i][j-1];\\n                    dp[i][j] = gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[gr.size()-1][gr[0].size()-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i = gr.size()-1; i>=0;i--){\\n            for(int j= gr[0].size()-1;j>=0;j--){\\n                if(i==gr.size()-1 && j==gr[0].size()-1) dp[i][j] = gr[i][j];\\n                else{\\n                    int a= 1e8, b= 1e8;\\n                    if(i < gr.size()-1)\\n                        a = dp[i+1][j];\\n                    if(j < gr[0].size()-1)\\n                        b= dp[i][j+1];\\n                    dp[i][j]=gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23493,
                "title": "my-java-solution-using-dp-with-memorization-beats-about-98-submissions",
                "content": "    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        return minPathSumHelper(grid, 0, 0, memo);\\n    }\\n    \\n    public int minPathSumHelper(int[][] grid, int row, int col, int[][] memo) {\\n        if(row == grid.length-1 && col == grid[0].length-1) return grid[row][col];\\n        if(memo[row][col] != 0) return memo[row][col];\\n\\n        int rowInc = Integer.MAX_VALUE, colInc = Integer.MAX_VALUE;\\n        if(row < grid.length-1) rowInc = minPathSumHelper(grid, row+1, col, memo);\\n        if(col < grid[0].length-1) colInc = minPathSumHelper(grid, row, col+1, memo);\\n        memo[row][col] = Math.min(rowInc, colInc) + grid[row][col];\\n        return memo[row][col];\\n    }\\n\\nUse a 2D array named memo to remember value which is calculated before to speed up.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        return minPathSumHelper(grid, 0, 0, memo);\\n    }\\n    \\n    public int minPathSumHelper(int[][] grid, int row, int col, int[][] memo) {\\n        if(row == grid.length-1 && col == grid[0].length-1) return grid[row][col];\\n        if(memo[row][col] != 0) return memo[row][col];\\n\\n        int rowInc = Integer.MAX_VALUE, colInc = Integer.MAX_VALUE;\\n        if(row < grid.length-1) rowInc = minPathSumHelper(grid, row+1, col, memo);\\n        if(col < grid[0].length-1) colInc = minPathSumHelper(grid, row, col+1, memo);\\n        memo[row][col] = Math.min(rowInc, colInc) + grid[row][col];\\n        return memo[row][col];\\n    }\\n\\nUse a 2D array named memo to remember value which is calculated before to speed up.",
                "codeTag": "Unknown"
            },
            {
                "id": 1513899,
                "title": "java-tc-o-r-c-sc-o-min-r-c-space-optimized-dynamic-programming-solution",
                "content": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j].\\n * If j == 0, then dp[i][0] = dp[i-1][0] + grid[i][0].\\n * If i == 0, then dp[0][j] = dp[0][j-1] + grid[0][j].\\n *\\n * We can just use 1D array of size rows or columns.\\n *\\n * Time Complexity: O(R * C)\\n *\\n * Space Complexity : O(min(R, C))\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0];\\n        }\\n\\n        if (cols <= rows) {\\n            return minPathSumHelper(grid, rows, cols, true);\\n        } else {\\n            return minPathSumHelper(grid, cols, rows, false);\\n        }\\n    }\\n\\n    private int minPathSumHelper(int[][] grid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        // Process 1st small column/row\\n        dp[0] = grid[0][0];\\n        for (int j = 1; j < small; j++) {\\n            dp[j] = dp[j - 1] + (isColsSmall ? grid[0][j] : grid[j][0]);\\n        }\\n        // Process remaining columns/rows\\n        for (int i = 1; i < big; i++) {\\n            dp[0] += isColsSmall ? grid[i][0] : grid[0][i];\\n            for (int j = 1; j < small; j++) {\\n                dp[j] = Math.min(dp[j], dp[j - 1]) + (isColsSmall ? grid[i][j] : grid[j][i]);\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/discuss/1513886/Java-or-TC:-O(M*N)-or-SC:-O(min(MN))-or-Space-optimized-Dynamic-Programming-solution)\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/discuss/1513891/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/discuss/1513906/Java-or-TC:-O(3(R*C))-or-SC:-O(R*C)-or-DFS-solution-with-Backtracking)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j].\\n * If j == 0, then dp[i][0] = dp[i-1][0] + grid[i][0].\\n * If i == 0, then dp[0][j] = dp[0][j-1] + grid[0][j].\\n *\\n * We can just use 1D array of size rows or columns.\\n *\\n * Time Complexity: O(R * C)\\n *\\n * Space Complexity : O(min(R, C))\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0];\\n        }\\n\\n        if (cols <= rows) {\\n            return minPathSumHelper(grid, rows, cols, true);\\n        } else {\\n            return minPathSumHelper(grid, cols, rows, false);\\n        }\\n    }\\n\\n    private int minPathSumHelper(int[][] grid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        // Process 1st small column/row\\n        dp[0] = grid[0][0];\\n        for (int j = 1; j < small; j++) {\\n            dp[j] = dp[j - 1] + (isColsSmall ? grid[0][j] : grid[j][0]);\\n        }\\n        // Process remaining columns/rows\\n        for (int i = 1; i < big; i++) {\\n            dp[0] += isColsSmall ? grid[i][0] : grid[0][i];\\n            for (int j = 1; j < small; j++) {\\n                dp[j] = Math.min(dp[j], dp[j - 1]) + (isColsSmall ? grid[i][j] : grid[j][i]);\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360106,
                "title": "python-5-approaches-dijkstra-a-dp-dfs-explained-and-visulaized",
                "content": "- Updated solutions 07/11/2021\\n------------------------------------------\\n\\n# [1] Dijkstra | 152 ms | faster than 12.02% \\n\\n------------------------------------------\\n- Cost to get to a cell is the value of the cell (the values of the cells will serve as weighted edges), while the nodes will only store the coordiantes of the cell.\\n\\t- nodes -> cells cooridinates\\n\\t- weighted edges -> costs -> values in cells\\n\\t- startNode = 0,0\\n\\t- endNode = len(grid)-1, len(grid[0])-1\\n\\n- Time: `O(Elogv)`\\n\\n![image](https://assets.leetcode.com/users/images/1c97142b-5137-4138-8c9c-151c9ab81cb8_1626646631.2057364.jpeg)\\n\\n\\n- the ultimate and only goal of Dijkstra is to populate the cost_so_far dict (or minWeights dict)\\nfor all nodes (aka min cost to get to each node)\\n- Dijkstra does not necessarlily have to wait until the entire weights dict is populated\\n- We can introduce an early exit if we are interesetd in a particular destination\\nthat we we might encounter in our search\\n\\n- we can also add a cameFrom dict to record parent:child relationships and\\nuse it to generate min path to any node we desire\\n\\n- heap frontier instead of queue\\n- find nei and add current cost to nei cost (cost to get to nei)\\n- For the nei we need to check:\\n\\t- [1] Is this the first time we are seeing this nei?\\n\\t- [2] Or, Did we see this nei before however this time we rached it via less expensive route?\\n\\n\\t- if the answer is yes to either [1] or [2]\\n\\t\\t- we update cost_so_far\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n\\tfrom heapq import heappush, heappop\\n\\th = []\\n\\tstartNode = (grid[0][0], (0,0)) # cost, coor\\n\\theappush(h, startNode)\\n\\tdirs = [(1,0), (0,1)] # only right and down are allowed\\n\\tcost_so_far = {(0,0): grid[0][0]} # stores min cost to get to all nodes\\n\\t# cameFrom = {(0,0): None} # -- NOTE [1]\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\t\\tif x == len(grid)-1 and y == len(grid[0])-1: # destination found\\n\\t\\t\\tbreak\\n\\n\\t\\t# explore nei\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t# check bounds\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost, nei = grid[newX][newY], (newX, newY)\\n\\t\\t\\t\\tnewCost = cost + edgeCost \\n\\t\\t\\t\\t# check if weights needs to be updated\\n\\t\\t\\t\\tif ( nei not in cost_so_far or (nei in cost_so_far and cost_so_far[nei] > newCost) ):\\n\\t\\t\\t\\t\\tcost_so_far[nei] = newCost\\n\\t\\t\\t\\t\\theappush(h, (newCost, nei))\\n\\t\\t\\t\\t\\t# cameFrom[nei] = node # -- NOTE [1]\\n\\n\\t# return cost to reach destination\\n\\treturn cost_so_far[(x,y)]\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# Min path debugging:\\n\\t# path = []\\n\\t# trgt = (len(grid)-1, len(grid[0])-1)\\n\\t# while trgt in cameFrom:\\n\\t#\\tpath.insert(0, trgt)\\n\\t#\\ttrgt = cameFrom[trgt]\\n\\t# print(\"path = \", path)\\n        \\n ```\\n \\n ------------------------------------------\\n# [2] A* Algorithm | 176 ms | faster than 7.45% of Python3\\n ------------------------------------------\\n \\n- Dijkstra wastes some time exploring paths that seem promising initailly due to its high sensetivity to local miminma\\n\\t- for ex: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t- correct answer (global mimima is achived by) : 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1\\n\\t- however dijkstra will waste some time in the begining exploring the path\\n\\t\\t1 -> 1 -> 4 -> 2\\n\\t\\tbecause initally it looked more promising from the heap\\'s point of view\\n\\n- Let\\'s see if we can speed it up by adding a heurstic function (estimation) using manhattan distance\\n\\t- A* f(n) = g(n) + h(n)\\n\\t- h(n) = straight line distance (or Manhattan distance)\\n\\n\\tknowledge + estimation\\n\\tg(n) = knowledge\\n\\th(n) = estimation -> Eucledian or Manhattan distance\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/2bd70406-7c7e-4c78-b1f7-0b3ad23e0fe9_1626646839.7684267.jpeg)\\n\\n\\n\\t\\n\\t- Notice how our heuristic function of choice is admissible (aka. optimistic) meaning it\\'s optimistic in estimating the distance to the destination. Satisfying this condition is a prerequsite for the A* algorithm to be stable (it guarantess A* will find the optimal answer)\\n\\t- h(n) is optimistic when h(n) is less than the actual cost endured from cell n to target. \\n\\t- h(n) is optimisitic (aka admissible) because it simply adds up the remaining nodes that we need to traverse to reach target (and it DOES NOT assign any weights to the indivdual steps) whereas we know the range for the actual cost of each step is from `(1 ~ 100)`\\nfrom the input `0 <= grid[i][j] <= 100 `\\n\\n- h(n) should speed the search by serving as a tie breaker in situations where g(n) (aka. cost) is the same for two different directions/steps\\nThis is specially true because our grid is rectangular ` m*n`. Thus distance h(n) will favor either (a step to the right, or a step downwards) based on the distance.\\n- Using h(n) would still make sense even if we had a square grid `n*n` because narrows down the explored space before the target is found. See comparsion below:\\n\\n**[ credit** : https://www.redblobgames.com/pathfinding/a-star/introduction.html **]**\\n![image](https://assets.leetcode.com/users/images/89c24a54-cecb-46b8-b5aa-6513e5b8f5fa_1626645746.9307761.png)\\n\\n\\n- One last detail to pay attention to is the fact that -unlike Dijkstra- A* is not a `shortest-path-algorithm`, but rather a `search-algorithm`\\n\\t- In other words:\\n\\t\\t- A* : Essentially, helps us find a target in a grid:\\n\\t\\t\\t-  Faster than BFS\\n\\t\\t\\t-  Guarantees correctness -unlike purely greedy algorthims- which do not gauarntee correctness (aka. does not always return the global min/max) )\\n\\t\\t-  Dijkstra : By nature, allows us to find the shortest path to all nodes (including of-course our target node)\\n\\t\\t-  That being said, we need to do some post-processing after A* finishes\\n\\t\\t\\t-  Remember when we added h(n) to speed up the search and make it waste less time exploring\\n\\t\\t\\t-  The output of A* is a weights dict `ex: {node A : minCostToReach node A}` (simialr to Dijkstra)\\n\\t\\t\\t\\t-  However, the values of that dict will be the sum of `h(n) + g(n)` hence we have to subtract h(n) in order to return the correct answer. See note [1]. This extra step most probably cancels out any speed we might have gained by adding h(n) and converting our algorithm from Dijkstra to A*, however it\\'s worth the learning process. \\n\\n ```                        \\ndef minPathSum(self, grid: List[List[int]]) -> int:        \\n        \\n\\t# helper to generate heuristic function h(n) based on Manhattan distance\\n        def generateHeuristics():\\n            trgtX, trgtY = len(grid[0])-1, len(grid)-1\\n            heuristics = {}\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    dist = abs(trgtY - r) + abs(trgtX - c) \\n                    heuristics[(r,c)] = dist\\n            return heuristics\\n        \\n        \\n        # main\\n        heuristics = generateHeuristics()\\n        h = []\\n        from heapq import heappush, heappop\\n        # cost = cost + estimation\\n        cost = grid[0][0] + heuristics[(0,0)]\\n        start = (cost, (0,0))\\n        cost_so_far = {(0,0): cost}\\n        cameFrom = {(0,0): None}\\n        heappush(h, start)\\n        trgtX, trgtY = len(grid)-1, len(grid[0])-1\\n        \\n        dirs = [(1,0), (0,1)]\\n        totalEstimationAdded = 0\\n        while h:\\n            cost, (x,y) = heappop(h)\\n            # print(cost, (x,y))\\n            if (x,y) == (trgtX, trgtY): # trgt found\\n                break\\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                \\n                if newX <= len(grid)-1 and newY <= len(grid[0])-1: # bounds\\n                    # print(\\'newX, newY = \\', newX, newY)\\n                    edgeCost = grid[newX][newY] \\n                    newCost = cost + edgeCost\\n\\n                    if (newX, newY) not in cost_so_far or ((newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n                        cost_so_far[(newX, newY)] = newCost\\n                        heappush(h, (newCost + heuristics[(newX, newY)], (newX, newY)))\\n                        cameFrom[(newX, newY)] = (x, y)\\n\\n        \\n        costFunc = cost_so_far[(trgtX, trgtY)] # - NOTE [1]\\n\\n        \\n        # NOTE [1]\\n        # --------\\n        # Please notice that costFunc is a sum of (knowledge, estimation) along the shortest path\\n        # hence does not exactly match the desired ouput of this problem (problem is only asking for knoweldge based cost - free from heurtisitc or estimation)\\n        # Perhaps A* is not best suited for this probelm since the problem is not\\n        # asking to just find the target (a process that A* accelartes)\\n        # but rather, asks for the actual cost (knowledge free from estimation)\\n        \\n        # However, we can obtain the desired output bu doing some simple post-processing to the answer since the answer\\n        # (aka cost) is a sum of both knowledge and estimation\\n        # we have to subtract estimation to arrive at the wanted answer\\n        # totalEstimationAdded += (cost - grid[x][y]) # subtract knowledge from total \\n        # we can do that by building the shortest path and then subtract\\n        \\n        \\n        # Generate shortest path\\n        path = []\\n        trgt = (trgtX, trgtY)\\n        while trgt in cameFrom:\\n            path.insert(0, trgt)\\n            trgt = cameFrom[trgt]\\n        # print(\"path = \", path)\\n        \\n        actualCost = costFunc\\n        for (x,y) in path:\\n            actualCost -= heuristics[(x,y)]\\n        return actualCost\\n```\\n\\n\\n ------------------------------------------\\n# [3] Bottom up DP with in-place tabulation | 88 ms | faster than 97.41%\\n ------------------------------------------\\n- Similar to UniquePaths I/II : https://leetcode.com/problems/unique-paths-ii/discuss/1595001/Python3-4-approaches-(top-down-bottom-up-brute-force)\\n- bottom - up approach, solving the problem at a smaller scale first\\n- Instead of finding the min cost to get to the m,n cell right away, we first find the min cost to get to each cell, starting from the cells adjacent to the origin.\\n- cells at the top most row, can only be accessed from the left\\nwhich means the cost of visiting each one of them will be simply the sum of the\\ncurr cell and the cell the preceeded it\\n\\n- same concept applies for the cells in the left most col\\n\\n- for the rest of the grid, cost of visiting each cell:\\n\\n\\tg[i][j] = min(g[i-1][j], g[i][j-1])\\n\\n\\twhich is very similar to what we did in unique paths\\n\\n\\tg[i][j] = g[i-1][j] + g[i][j-1]\\n\\n- time: O(m-1)*(n-1) === O(m*n)\\n- space: O(1) in-place\\n\\n- starting from cell (1,1) -> min(left, top) aka the 2 direction we might have came from\\n- use the grid itself as a dp matrix\\n- this is a 2-dimensional dp problem since the steps could either be 1) horizontal 2) vertical\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\t# top row\\n\\tfor i in range(1, len(grid[0])):\\n\\t\\tgrid[0][i] += grid[0][i-1]\\n\\n\\t# left most col\\n\\tfor i in range(1, len(grid)):\\n\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t# rest of the grid\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(1, len(grid[0])):\\n\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]) \\n\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\treturn grid[trgtX][trgtY]\\n\\n```\\n\\n---------------------------------------------\\n# [4] Iterative brute-force DFS\\nTLE 20 / 61 test cases passed.\\n---------------------------------------------\\n---------------------------------------------\\n- a post discussing a simialr approach : https://leetcode.com/problems/all-paths-from-source-to-target/discuss/986429/Python-Iterative-DFS-with-detailed-time-complexity-and-visuals \\n- Examine each path individually till the end and return the one with min cost \\n- O(k-avg * N)\\nN = number of cells M*N\\nK-avg = the average of how many times a node is visited (due to not using a visited set)\\nk-min = 1\\nk-max = number of paths in the grid (number of times the (trgtX, trgtY) node is visited)\\nk-max = ( (m-1) + (n-1) ) / ( (m-1)! * (n-1)! )\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\tminPathCost = float(\\'inf\\')\\n\\tstack = [( (0,0), grid[0][0] )]\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\tdirs = [(1,0), (0,1)]\\n\\twhile stack:\\n\\t\\t(x,y), pathCost = stack.pop()\\n\\n\\t\\tif (x,y) == (trgtX, trgtY): # only capture pathCost when path is fully traversed (aka rigt-bottm corner cell is reached)\\n\\t\\t\\tminPathCost = min(minPathCost, pathCost)\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= trgtX and newY <= trgtY:\\n\\t\\t\\t\\tstack.append( ( (newX, newY), pathCost+grid[newX][newY] ) )\\n\\n\\treturn minPathCost\\n\\n```\\n\\n---------------------------------------------\\n# [5] Recursive DFS with memoization\\n---------------------------------------------\\n\\n\\n```\\n def minPathSum(self, grid: List[List[int]]) -> int:         \\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif (i,j) == (len(grid)-1, len(grid[0])-1): # reachedt traget\\n\\t\\t\\treturn grid[i][j] # return the value of the cell to be added to the sum\\n\\n\\t\\tif i > len(grid)-1 or j > len(grid[0])-1: # out of bounds\\n\\t\\t\\treturn float(\\'inf\\') # return a huge number to cause the path to be disgarded\\n\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\n\\t\\t# if none of the above\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i, j+1))\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main:\\n\\tmemo = {}\\n\\treturn recurse(0,0) # starting Node\\n\\n\\t# NOTE\\n\\t# memo is going to start building from target \\n\\t# memo =  {}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7, (1, 2): 2, (1, 1): 7, (1, 0): 8}\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n\\tfrom heapq import heappush, heappop\\n\\th = []\\n\\tstartNode = (grid[0][0], (0,0)) # cost, coor\\n\\theappush(h, startNode)\\n\\tdirs = [(1,0), (0,1)] # only right and down are allowed\\n\\tcost_so_far = {(0,0): grid[0][0]} # stores min cost to get to all nodes\\n\\t# cameFrom = {(0,0): None} # -- NOTE [1]\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\t\\tif x == len(grid)-1 and y == len(grid[0])-1: # destination found\\n\\t\\t\\tbreak\\n\\n\\t\\t# explore nei\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t# check bounds\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost, nei = grid[newX][newY], (newX, newY)\\n\\t\\t\\t\\tnewCost = cost + edgeCost \\n\\t\\t\\t\\t# check if weights needs to be updated\\n\\t\\t\\t\\tif ( nei not in cost_so_far or (nei in cost_so_far and cost_so_far[nei] > newCost) ):\\n\\t\\t\\t\\t\\tcost_so_far[nei] = newCost\\n\\t\\t\\t\\t\\theappush(h, (newCost, nei))\\n\\t\\t\\t\\t\\t# cameFrom[nei] = node # -- NOTE [1]\\n\\n\\t# return cost to reach destination\\n\\treturn cost_so_far[(x,y)]\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# Min path debugging:\\n\\t# path = []\\n\\t# trgt = (len(grid)-1, len(grid[0])-1)\\n\\t# while trgt in cameFrom:\\n\\t#\\tpath.insert(0, trgt)\\n\\t#\\ttrgt = cameFrom[trgt]\\n\\t# print(\"path = \", path)\\n        \\n ```\n```                        \\ndef minPathSum(self, grid: List[List[int]]) -> int:        \\n        \\n\\t# helper to generate heuristic function h(n) based on Manhattan distance\\n        def generateHeuristics():\\n            trgtX, trgtY = len(grid[0])-1, len(grid)-1\\n            heuristics = {}\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    dist = abs(trgtY - r) + abs(trgtX - c) \\n                    heuristics[(r,c)] = dist\\n            return heuristics\\n        \\n        \\n        # main\\n        heuristics = generateHeuristics()\\n        h = []\\n        from heapq import heappush, heappop\\n        # cost = cost + estimation\\n        cost = grid[0][0] + heuristics[(0,0)]\\n        start = (cost, (0,0))\\n        cost_so_far = {(0,0): cost}\\n        cameFrom = {(0,0): None}\\n        heappush(h, start)\\n        trgtX, trgtY = len(grid)-1, len(grid[0])-1\\n        \\n        dirs = [(1,0), (0,1)]\\n        totalEstimationAdded = 0\\n        while h:\\n            cost, (x,y) = heappop(h)\\n            # print(cost, (x,y))\\n            if (x,y) == (trgtX, trgtY): # trgt found\\n                break\\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                \\n                if newX <= len(grid)-1 and newY <= len(grid[0])-1: # bounds\\n                    # print(\\'newX, newY = \\', newX, newY)\\n                    edgeCost = grid[newX][newY] \\n                    newCost = cost + edgeCost\\n\\n                    if (newX, newY) not in cost_so_far or ((newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n                        cost_so_far[(newX, newY)] = newCost\\n                        heappush(h, (newCost + heuristics[(newX, newY)], (newX, newY)))\\n                        cameFrom[(newX, newY)] = (x, y)\\n\\n        \\n        costFunc = cost_so_far[(trgtX, trgtY)] # - NOTE [1]\\n\\n        \\n        # NOTE [1]\\n        # --------\\n        # Please notice that costFunc is a sum of (knowledge, estimation) along the shortest path\\n        # hence does not exactly match the desired ouput of this problem (problem is only asking for knoweldge based cost - free from heurtisitc or estimation)\\n        # Perhaps A* is not best suited for this probelm since the problem is not\\n        # asking to just find the target (a process that A* accelartes)\\n        # but rather, asks for the actual cost (knowledge free from estimation)\\n        \\n        # However, we can obtain the desired output bu doing some simple post-processing to the answer since the answer\\n        # (aka cost) is a sum of both knowledge and estimation\\n        # we have to subtract estimation to arrive at the wanted answer\\n        # totalEstimationAdded += (cost - grid[x][y]) # subtract knowledge from total \\n        # we can do that by building the shortest path and then subtract\\n        \\n        \\n        # Generate shortest path\\n        path = []\\n        trgt = (trgtX, trgtY)\\n        while trgt in cameFrom:\\n            path.insert(0, trgt)\\n            trgt = cameFrom[trgt]\\n        # print(\"path = \", path)\\n        \\n        actualCost = costFunc\\n        for (x,y) in path:\\n            actualCost -= heuristics[(x,y)]\\n        return actualCost\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\t# top row\\n\\tfor i in range(1, len(grid[0])):\\n\\t\\tgrid[0][i] += grid[0][i-1]\\n\\n\\t# left most col\\n\\tfor i in range(1, len(grid)):\\n\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t# rest of the grid\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(1, len(grid[0])):\\n\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]) \\n\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\treturn grid[trgtX][trgtY]\\n\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\tminPathCost = float(\\'inf\\')\\n\\tstack = [( (0,0), grid[0][0] )]\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\tdirs = [(1,0), (0,1)]\\n\\twhile stack:\\n\\t\\t(x,y), pathCost = stack.pop()\\n\\n\\t\\tif (x,y) == (trgtX, trgtY): # only capture pathCost when path is fully traversed (aka rigt-bottm corner cell is reached)\\n\\t\\t\\tminPathCost = min(minPathCost, pathCost)\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= trgtX and newY <= trgtY:\\n\\t\\t\\t\\tstack.append( ( (newX, newY), pathCost+grid[newX][newY] ) )\\n\\n\\treturn minPathCost\\n\\n```\n```\\n def minPathSum(self, grid: List[List[int]]) -> int:         \\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif (i,j) == (len(grid)-1, len(grid[0])-1): # reachedt traget\\n\\t\\t\\treturn grid[i][j] # return the value of the cell to be added to the sum\\n\\n\\t\\tif i > len(grid)-1 or j > len(grid[0])-1: # out of bounds\\n\\t\\t\\treturn float(\\'inf\\') # return a huge number to cause the path to be disgarded\\n\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\n\\t\\t# if none of the above\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i, j+1))\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main:\\n\\tmemo = {}\\n\\treturn recurse(0,0) # starting Node\\n\\n\\t# NOTE\\n\\t# memo is going to start building from target \\n\\t# memo =  {}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7, (1, 2): 2, (1, 1): 7, (1, 0): 8}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 23678,
                "title": "c-easy-solution-using-dp-space-compexity-o-1",
                "content": "    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& a) {\\n            int m=a.size();\\n            if(m==0) return 0;\\n            int n= a[0].size();\\n            \\n            for(int i = 0 ; i<m; i++  ){\\n                for(int j=0; j<n ; j++){\\n                    int left= (j==0) ? INT_MAX : a[i][j-1];\\n                    int up = (i==0) ? INT_MAX : a[i-1][j];\\n                    if(i==0 && j==0) continue;\\n                    a[i][j] += min(left, up );\\n                }\\n            }\\n            return a[m-1][n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& a) {\\n            int m=a.size();\\n            if(m==0) return 0;\\n            int n= a[0].size();\\n            \\n            for(int i = 0 ; i<m; i++  ){\\n                for(int j=0; j<n ; j++){\\n                    int left= (j==0) ? INT_MAX : a[i][j-1];\\n                    int up = (i==0) ? INT_MAX : a[i-1][j];\\n                    if(i==0 && j==0) continue;\\n                    a[i][j] += min(left, up );\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 23615,
                "title": "my-solution-beats-100-java-solutions",
                "content": "    public class Solution {\\n        public int minPathSum(int[][] grid) {\\n            if(grid.length == 0)  return 0;\\n            \\n            int r = grid.length;\\n            int c = grid[0].length;\\n            \\n            for(int i=0;i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n                    int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n                    if(i==0 && j==0) continue;\\n                    \\n                    grid[i][j] += Math.min(leftSum, topSum);\\n                }\\n            }\\n            return grid[r-1][c-1];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minPathSum(int[][] grid) {\\n            if(grid.length == 0)  return 0;\\n            \\n            int r = grid.length;\\n            int c = grid[0].length;\\n            \\n            for(int i=0;i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n                    int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n                    if(i==0 && j==0) continue;\\n                    \\n                    grid[i][j] += Math.min(leftSum, topSum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3345712,
                "title": "complete-intuition-explained-recursion-memoization-tabulation-dp",
                "content": "![image](https://assets.leetcode.com/users/images/c87574f8-29ca-47eb-af34-a41610f4dee4_1679888406.0141091.png)\\n![image](https://assets.leetcode.com/users/images/60006acc-70fe-4065-b14f-7585a2875ddc_1679888413.6319273.png)\\n![image](https://assets.leetcode.com/users/images/80f0011b-c7fc-4f0e-89c9-85fc16ec6840_1679888421.8878033.png)\\n\\n\\n\\n### RECURSION \\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        int rightMin = solve(grid, currRow, currCol + 1);\\n        int downMin = solve(grid, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return (grid[currRow][currCol] + bestChoice);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        return solve(grid, 0, 0);\\n    }\\n};\\n```\\n//===========================================================================================================================================\\n\\n### MEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\\n        int downMin = solve(grid, dp, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \\n        //\\'-1\\' to denote that subproblem result for that cell is not computed and not stored\\n        return solve(grid, dp, 0, 0);\\n    }\\n};\\n```\\n\\n//=========================================================================================================================================\\n\\n### BOTTOM-UP DYNAMIC PROGRAMMING \\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        //traverse from \\'bottom->top\\' and \\'right->left\\'\\n        //as for any cell we need computed result from \\'down\\' and \\'right\\'\\n        for (int i = m - 1; i >= 0; i--)\\n        {\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                if (i == m - 1 && j == n - 1) continue;\\n                \\n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \\n                //rather than making a new \\'DP\\' grid store results of subproblems in the same grid\\n            }\\n        }\\n        return grid[0][0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        int rightMin = solve(grid, currRow, currCol + 1);\\n        int downMin = solve(grid, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return (grid[currRow][currCol] + bestChoice);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        return solve(grid, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\\n        int downMin = solve(grid, dp, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \\n        //\\'-1\\' to denote that subproblem result for that cell is not computed and not stored\\n        return solve(grid, dp, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        //traverse from \\'bottom->top\\' and \\'right->left\\'\\n        //as for any cell we need computed result from \\'down\\' and \\'right\\'\\n        for (int i = m - 1; i >= 0; i--)\\n        {\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                if (i == m - 1 && j == n - 1) continue;\\n                \\n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \\n                //rather than making a new \\'DP\\' grid store results of subproblems in the same grid\\n            }\\n        }\\n        return grid[0][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453856,
                "title": "beautiful-tasty-java-dp-solution-w-comments",
                "content": "```java\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        // get mxn sizes\\n        int m = grid.length; int n = grid[0].length;\\n        \\n        // dp array\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // handle first column\\n        for (int i = 1; i < m; i++) {\\n            // add one before it\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }\\n        \\n        // handle first row\\n        for (int i = 1; i < n; i++) {\\n            // add one before it\\n            dp[0][i] = grid[0][i] + dp[0][i-1];\\n        }\\n        \\n        // starting from (1,1) iterate thru array taking min path choices along the way\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // dp value at this coordinate is lesser of the two possible paths\\n                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        \\n        // the result should be at the bottom right corner of DP array\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        // get mxn sizes\\n        int m = grid.length; int n = grid[0].length;\\n        \\n        // dp array\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // handle first column\\n        for (int i = 1; i < m; i++) {\\n            // add one before it\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }\\n        \\n        // handle first row\\n        for (int i = 1; i < n; i++) {\\n            // add one before it\\n            dp[0][i] = grid[0][i] + dp[0][i-1];\\n        }\\n        \\n        // starting from (1,1) iterate thru array taking min path choices along the way\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // dp value at this coordinate is lesser of the two possible paths\\n                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        \\n        // the result should be at the bottom right corner of DP array\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848341,
                "title": "python-solution-greedy-recursive-memorization-bottom-up-approach",
                "content": "### Solution by Ranjal (Leetcode username: ranjal_omer)\\n\\t\\n\\timport sys\\n\\tclass Solution:\\n\\t\\tdef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n### ___ Greedy Approach___\\n        \"\"\"\\n        \\n        @ Lets Discuss why not to follow greedy technique in this problem:\\n        \\n        1- Because if we follow greedy we might endup choosing the wrong path which rather\\n        \\n        giving us the minimum value will give us some another higher value\\n        \\n        for example if we take a grid \\n            \\n            1 2 6 4\\n            5 8 5 85\\n            1 3 2 1\\n            \\n            if we follow the greedy method and starting from 0,0 we will choose minimum of (2,5)\\n            since 2 will be the minimum we will move in the direction of 2\\n            as we can only move downwards and right\\n            \\n            and so on we will get the path like 1-> 2 -> 6 -> 4 -> 85 ->1 === 99\\n            \\n            but because of the greeedy nature we have missed the optimum path which gives us the minimum\\n            sum that is\\n            \\n            1-> 5 -> 1 -> 3 -> 2 -> 1 ==== 13 \\n            \\n            Therefore the greedy Technique fails here\\n        \\n        \"\"\"\\n        #-----------------------------------------------------------------------------------------#\\n        \"\"\"\\n        \\n        Time Complexity : O(m*n)\\n        Stack Space : O(m*n)+ O(path length)\\n        \\n        \\n### ___ Recursive Approach___\\n        # Now moving towards the recursive solution\\n        \\n        # which will gives us all the possible path from which we can find the min path (Exploring all paths)\\n        \"\"\"\\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            return min(up,left)\\n        \\n        # return f(len(grid)-1,len(grid[0])-1)\\n        \\n        #-----------------------------------------------------------------------------------------#\\n### ___ Memoizing the Recursive Approach___   \\n        \"\"\"\\n        \\n        Now memoizing the recursive code:---->\\n        \\n        \\n        \"\"\"\\n        n=len(grid)\\n        m= len(grid[0])\\n        \\n        dp=[[-1]*m for i in range(n)]\\n        \\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            dp[i][j]=min(up,left)\\n            return dp[i][j]\\n        # return f(n-1,m-1)\\n        \\n        \\n        \\n        \\n        #-----------------------------------------------------------------------------------------#\\n        \\n### ___ Bottom-Up Approach___\\n        \"\"\"\\n        \\n        Now Converting  the memoized code into bottom up:---->\\n        \\n        \\n        \"\"\"\\n        \\n        dp=[[0]*m for i in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i==0 and j==0:\\n                    dp[i][j]= grid[i][j]\\n                    \\n                else:\\n                    up=grid[i][j]\\n                    left=grid[i][j]\\n                    \\n                    if i>0:\\n                        up+= dp[i-1][j]\\n                    else:\\n                        up+=sys.maxsize\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=sys.maxsize\\n                    \\n                    dp[i][j]= min(up,left)\\n                    \\n        return dp[n-1][m-1]\\n\\t\\n## Thankyou for visiting!! \\n### Please upvote the solution and share it with your friends :) <3",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "### Solution by Ranjal (Leetcode username: ranjal_omer)\\n\\t\\n\\timport sys\\n\\tclass Solution:\\n\\t\\tdef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n### ___ Greedy Approach___\\n        \"\"\"\\n        \\n        @ Lets Discuss why not to follow greedy technique in this problem:\\n        \\n        1- Because if we follow greedy we might endup choosing the wrong path which rather\\n        \\n        giving us the minimum value will give us some another higher value\\n        \\n        for example if we take a grid \\n            \\n            1 2 6 4\\n            5 8 5 85\\n            1 3 2 1\\n            \\n            if we follow the greedy method and starting from 0,0 we will choose minimum of (2,5)\\n            since 2 will be the minimum we will move in the direction of 2\\n            as we can only move downwards and right\\n            \\n            and so on we will get the path like 1-> 2 -> 6 -> 4 -> 85 ->1 === 99\\n            \\n            but because of the greeedy nature we have missed the optimum path which gives us the minimum\\n            sum that is\\n            \\n            1-> 5 -> 1 -> 3 -> 2 -> 1 ==== 13 \\n            \\n            Therefore the greedy Technique fails here\\n        \\n        \"\"\"\\n        #-----------------------------------------------------------------------------------------#\\n        \"\"\"\\n        \\n        Time Complexity : O(m*n)\\n        Stack Space : O(m*n)+ O(path length)\\n        \\n        \\n### ___ Recursive Approach___\\n        # Now moving towards the recursive solution\\n        \\n        # which will gives us all the possible path from which we can find the min path (Exploring all paths)\\n        \"\"\"\\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            return min(up,left)\\n        \\n        # return f(len(grid)-1,len(grid[0])-1)\\n        \\n        #-----------------------------------------------------------------------------------------#\\n### ___ Memoizing the Recursive Approach___   \\n        \"\"\"\\n        \\n        Now memoizing the recursive code:---->\\n        \\n        \\n        \"\"\"\\n        n=len(grid)\\n        m= len(grid[0])\\n        \\n        dp=[[-1]*m for i in range(n)]\\n        \\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            dp[i][j]=min(up,left)\\n            return dp[i][j]\\n        # return f(n-1,m-1)\\n        \\n        \\n        \\n        \\n        #-----------------------------------------------------------------------------------------#\\n        \\n### ___ Bottom-Up Approach___\\n        \"\"\"\\n        \\n        Now Converting  the memoized code into bottom up:---->\\n        \\n        \\n        \"\"\"\\n        \\n        dp=[[0]*m for i in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i==0 and j==0:\\n                    dp[i][j]= grid[i][j]\\n                    \\n                else:\\n                    up=grid[i][j]\\n                    left=grid[i][j]\\n                    \\n                    if i>0:\\n                        up+= dp[i-1][j]\\n                    else:\\n                        up+=sys.maxsize\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=sys.maxsize\\n                    \\n                    dp[i][j]= min(up,left)\\n                    \\n        return dp[n-1][m-1]\\n\\t\\n## Thankyou for visiting!! \\n### Please upvote the solution and share it with your friends :) <3",
                "codeTag": "Java"
            },
            {
                "id": 1145356,
                "title": "memoization",
                "content": "```\\nclass Solution \\n{\\n  public:\\n    int minPathSumHelper(vector<vector<int>> &grid,vector<vector<int>> &dp,int m, int n, int i, int j){\\n        //base case \\n        \\n        if(i==m-1 && j==n-1){\\n            return grid[i][j];\\n        }\\n        if(i>=m || j>=n){\\n            return INT_MAX; \\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        //recusrive call\\n        int x = minPathSumHelper(grid,dp,m,n,i+1,j);\\n        int y = minPathSumHelper(grid,dp,m,n,i,j+1);\\n        \\n        //small calculation for recursion\\n        int ans = min(x,y) + grid[i][j];\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    int minPathSum(vector<vector<int>> &grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n\\n       return minPathSumHelper(grid,dp,m,n,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution \\n{\\n  public:\\n    int minPathSumHelper(vector<vector<int>> &grid,vector<vector<int>> &dp,int m, int n, int i, int j){\\n        //base case \\n        \\n        if(i==m-1 && j==n-1){\\n            return grid[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 644784,
                "title": "c-easy-to-understand-using-dp-with-explanation-must-see-for-beginners",
                "content": "Pls upvote if you find this helpful :))\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n```\\n        int row=grid.size();\\n        int column=grid[0].size();\\n        int sum=0;\\n        for(int i=0;i<column;i++) {\\t\\n\\t\\t\\tsum+=grid[0][i];                                      //Filling the first row ,only movement in right is possible here\\n            grid[0][i]=sum;\\n            }\\n        sum=0;\\n        for(int i=0;i<row;i++) {                                            \\n            sum+=grid[i][0];                                    //Filling the first column ,only movement in downward direction  \\n            grid[i][0]=sum;\\n            }\\n        for(int i=1;i<row;i++)\\n\\t\\t\\t{\\n            for(int j=1;j<column;j++)\\n\\t\\t\\t{                                                                            \\n            grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j];//Filling the remaining cells using the minimum value and adding to the current cell value   \\n            }\\n        }\\n        return grid[row-1][column-1];                  //Return the last grid\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584871,
                "title": "very-easy-c-solution-without-using-space-explained",
                "content": "We can think of solving this problem recursively. We are standing at a current cell then the cost of reaching that cell is minimum of ( cost of reaching upper cell, cost of reaching the left cell ) + cost of current cell.\\n\\nSuppose we have a fiunction called getMinSum which return minimum cost to reach. Suppose We are at 2,2 then,\\ngetMinCost(2,2) = grid[2,2] + min(getMinCost(2,1), getMinCost(1,2));\\nRecursive Call, getMinCost(2,1) = grid[2,1] + min(getMinCost(2,0), getMinCost(1,1));\\nRecursive Call, getMinCost(2,0) = grid[2,0] + getMinCost(1,0);\\nRecursive Call, getMinCost(1,0) = grid[1,0] + getMinCost(0,0);\\nRecursive Call, getMinCost(1,0) = grid[0,0];\\nRecursive Call, getMinCost(1,1) = grid[1,1] + min(**getMinCost(1,0)**, getMinCost(0,1));\\nRecursive Call, getMinCost(0,1) = grid[0,1] + **getMinCost(0,0)** ;\\nRecursive Call, getMinCost(1,2) = grid[1,2] + min(**getMinCost(1,1)**, **getMinCost(0,2)**);\\n\\nNow as we can see direct recursive solution is making us to calculate the same cost of reaching a cell again and again(shown in bold above). For large matrix this can make the complexity of finding a solution to be exponential.\\n\\nWe need to store these results of subsolutions.\\n\\nFor the first row and column the path sum will only be the sum of the cells till that point as there is no other way to reach the other cells.\\n```\\ngrid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        if(m==0)    return 0;\\n        int n = grid[0].size();\\n        if(n==0)    return 0;\\n        for(int i=1; i<m; i++)\\n            grid[i][0] += grid[i-1][0];\\n        \\n        for(int i=1; i<n; i++)\\n            grid[0][i] += grid[0][i-1];\\n        for(int i=1; i<m; i++)\\n            for(int j=1; j<n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            \\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ngrid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        if(m==0)    return 0;\\n        int n = grid[0].size();\\n        if(n==0)    return 0;\\n        for(int i=1; i<m; i++)\\n            grid[i][0] += grid[i-1][0];\\n        \\n        for(int i=1; i<n; i++)\\n            grid[0][i] += grid[0][i-1];\\n        for(int i=1; i<m; i++)\\n            for(int j=1; j<n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            \\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23589,
                "title": "minimum-path-sum-how-can-i-reduce-the-memory",
                "content": "Here is the idea:\\n\\n 1. f[m][n] is a matrix store the min value of every location we can\\n    get.\\n 2. f[0][0] =grid[0][0], f[i][0]=f[i-1][0]+grid[i][0],\\n    f[0][j]=f[0][j-1]+grid[0][j]\\n 3. f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j].\\n 4. at last return the f[m-1][n-1]\\n\\n----------\\n\\n\\n    class Solution {\\n            public:\\n                int minPathSum(vector<vector<int> > &grid) {\\n                    // IMPORTANT: Please reset any member data you declared, as\\n                    // the same Solution instance will be reused for each test case.\\n                    int m=grid.size();\\n                    int n=grid[0].size();\\n                    int** f;\\n                    f=new int*[m];\\n                    for(int i=0;i<m;i){\\n                        f[i]=new int[n];\\n                    }\\n                    f[0][0]=grid[0][0];\\n                    for(int i=1;i<m;i++){\\n                        f[i][0]=f[i-1][0]+grid[i][0];\\n                    }\\n                    for(int i=1;i<n;i++){\\n                        f[0][i]=f[0][i-1]+grid[0][i];\\n                    }\\n                    for(int i=1;i<m;i++){\\n                        for(int j=1;j<n;j++)\\n                            f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j];\\n                    }\\n                    return f[m-1][n-1];\\n                }\\n                int min(int a,int b){\\n                    if(a>b)\\n                        return b;\\n                    else\\n                        return a;\\n                }\\n            };",
                "solutionTags": [],
                "code": "class Solution {\\n            public:\\n                int minPathSum(vector<vector<int> > &grid) {\\n                    // IMPORTANT: Please reset any member data you declared, as\\n                    // the same Solution instance will be reused for each test case.\\n                    int m=grid.size();\\n                    int n=grid[0].size();\\n                    int** f;\\n                    f=new int*[m];\\n                    for(int i=0;i<m;i){\\n                        f[i]=new int[n];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3347989,
                "title": "c-easy-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++){\\n         dp[i][1] =g[i-1][0] + dp[i-1][1];\\n        }\\n        for(int j=1;j<=m;j++){\\n         dp[1][j] = g[0][j-1] + dp[1][j-1];   \\n        }\\n        for(int i=2;i<=n;i++){\\n            for(int j=2;j<=m;j++){\\n                dp[i][j] = g[i-1][j-1] + min(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/38a2afd8-6fc2-4079-bb12-4e653512ffed_1679927263.2603066.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++){\\n         dp[i][1] =g[i-1][0] + dp[i-1][1];\\n        }\\n        for(int j=1;j<=m;j++){\\n         dp[1][j] = g[0][j-1] + dp[1][j-1];   \\n        }\\n        for(int i=2;i<=n;i++){\\n            for(int j=2;j<=m;j++){\\n                dp[i][j] = g[i-1][j-1] + min(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346108,
                "title": "day-86-dp-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe intuition behind the approach is that, in order to find the minimum path sum from the top left corner to the bottom right corner of the grid, we can consider the subproblems of finding the minimum path sum to reach each cell of the grid. We can then use the solutions to these subproblems to solve the original problem.\\n\\nTo calculate the minimum path sum to reach a cell (i, j), we can take the minimum of the minimum path sum to reach the cell above (i-1, j) and the cell to the left (i, j-1), and add it to the value of the current cell. This is because we can only move either down or right, so the minimum path sum to reach the current cell is the minimum of the minimum path sum to reach the cell above and the cell to the left, plus the value of the current cell.\\n\\nWe can use this approach to calculate the minimum path sum to reach each cell of the grid, starting from the top left corner and working our way down and to the right. By the time we reach the bottom right corner, the minimum path sum to reach that cell will be the solution to the original problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize variables row and col to the number of rows and columns of the grid, respectively.\\n2. Traverse the first row of the grid and set each element to be the cumulative sum of the previous elements in the row.\\n3. Traverse the first column of the grid and set each element to be the cumulative sum of the previous elements in the column.\\n4. Traverse the remaining cells of the grid using two nested loops, starting from the second row and second column.\\n5. For each cell (i, j), set the value of the cell to be the sum of the current cell\\'s value and the minimum of the values of the cells above (i-1, j) and to the left (i, j-1).\\n6. After traversing all cells, the minimum sum of all numbers along the path from top left to bottom right of the grid is stored in the bottom right cell (i.e., grid[row-1][col-1]).\\n7. Return the value of the bottom right cell as the output.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //we will modify the same array and return the last index grid[row-1][col-1]\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        for i in range(1, row):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, col):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, row):\\n            for j in range(1, col):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[row-1][col-1]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(mn)**, where m is number of rows and n is number of column\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //we will modify the same array and return the last index grid[row-1][col-1]\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        for i in range(1, row):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, col):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, row):\\n            for j in range(1, col):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[row-1][col-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677369,
                "title": "recursion-to-space-optimized-in-java",
                "content": "**upvote if it helped, feeel free to ask queries**\\n`IDEA : ALWAYS REMEMBER WHENEVER YOU FEEL LIKE THERE IS A NEED TO FIND ALL POSSIBLE WAYS, THERE\\'S A RECURSION(which can further be improved).`\\n**the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]**\\n\\nhere, to get a path, we need to travel from grid[0][0] to grid[row - 1][col - 1]. So let\\'s set grid[0][0] as the basic case. This is when we jump out of recursion. On the other hand, grid[row - 1][col - 1] would be the starting point.  we need to consider that things could happen that we reached the first row or column and we gotta make sure that we stay within the array index limit.\\nWe will move in grid for every row and column, looking for minimum path sum\\n\\n**Recursion**\\n------------------------------------------time complexity in exponential----------\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            return min(grid, m - 1, n - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int m, int n){\\n\\n// this is the exit of the recursion\\n            if(m == 0 && n == 0) return grid[m][n]; \\n/** when we reach the first row, we could only move horizontally.*/\\n            if(m == 0) return grid[m][n] + min(grid, m, n - 1); \\n/** when we reach the first column, we could only move vertically.*/\\n            if(n == 0) return grid[m][n] + min(grid, m - 1, n); \\n/** we want the min sum path so we pick the cell with the less value */\\n            return grid[m][n] + Math.min(min(grid, m - 1, n), min(grid, m, n - 1)); \\n\\t\\t\\t\\n}\\n```\\n\\n**Memoization:**\\n*simply memoization to handle the recursion*\\n----------------------100% faster-----------------------1ms---------------------------\\n```\\nclass Solution {\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        memo = new int[m][n];\\n        return find(grid, m-1, n-1, memo);\\n    }\\n    \\n    private int find(int[][] grid, int m, int n, int[][] memo){\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        else if(memo[m][n]!=0)\\n           return memo[m][n];\\n        return memo[m][n] = grid[m][n] + Math.min(find(grid, m-1, n, memo), find(grid, m, n-1, memo));\\n    }\\n}\\n```\\n**Tabulation:**\\n*now properly using pre-calculated values to enhance the performance*\\n-------------------------------------------------with 2-d array-----------\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<m;i++)\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int j=1;j<n;j++)\\n            dp[0][j] = dp[0][j-1] + grid[0][j];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n**always remember** \\n*if tabulation approach contains something like (i+1) or(i-1), that means u can always space optimized it\\ni+1 or i-1 means we are using last calculated results, which we can store in the input array itself too, and very easily*\\n\\n------------------------------------------------------space optimized----------------\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=1;i<m;i++)\\n            grid[i][0] += grid[i-1][0];\\n        for(int j=1;j<n;j++)\\n            grid[0][j] += grid[0][j-1];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n**upvote if u learned something**\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/18dc01d9-d41f-40db-9b5a-1988158c2a07_1679893506.8129675.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            return min(grid, m - 1, n - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int m, int n){\\n\\n// this is the exit of the recursion\\n            if(m == 0 && n == 0) return grid[m][n]; \\n/** when we reach the first row, we could only move horizontally.*/\\n            if(m == 0) return grid[m][n] + min(grid, m, n - 1); \\n/** when we reach the first column, we could only move vertically.*/\\n            if(n == 0) return grid[m][n] + min(grid, m - 1, n); \\n/** we want the min sum path so we pick the cell with the less value */\\n            return grid[m][n] + Math.min(min(grid, m - 1, n), min(grid, m, n - 1)); \\n\\t\\t\\t\\n}\\n```\n```\\nclass Solution {\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        memo = new int[m][n];\\n        return find(grid, m-1, n-1, memo);\\n    }\\n    \\n    private int find(int[][] grid, int m, int n, int[][] memo){\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        else if(memo[m][n]!=0)\\n           return memo[m][n];\\n        return memo[m][n] = grid[m][n] + Math.min(find(grid, m-1, n, memo), find(grid, m, n-1, memo));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<m;i++)\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int j=1;j<n;j++)\\n            dp[0][j] = dp[0][j-1] + grid[0][j];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=1;i<m;i++)\\n            grid[i][0] += grid[i-1][0];\\n        for(int j=1;j<n;j++)\\n            grid[0][j] += grid[0][j-1];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054796,
                "title": "simple-understandable-c-code-dp-recursive-iterative",
                "content": "Recursion+Memoization\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = grid[x][y];\\n        if(x==m && y<n) ans += fun(x, y+1, grid);\\n        else if(x<m && y==n) ans += fun(x+1, y, grid);\\n        else if(x<m && y<n) ans += min (fun(x+1, y, grid), fun(x, y+1, grid));\\n        return dp[x][y] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        m = grid.size()-1, n = grid[0].size()-1;\\n        dp.resize(m+1, vector<int>(n+1, -1));\\n        return fun(0, 0, grid);\\n    }\\n};\\n```\\n\\n\\nIterative Approach\\n```\\nclass Solution {\\npublic:\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = grid[i][j];\\n                if(i>0 && j>0) dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n                else if(i>0) dp[i][j] += dp[i-1][j];\\n                else if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = grid[x][y];\\n        if(x==m && y<n) ans += fun(x, y+1, grid);\\n        else if(x<m && y==n) ans += fun(x+1, y, grid);\\n        else if(x<m && y<n) ans += min (fun(x+1, y, grid), fun(x, y+1, grid));\\n        return dp[x][y] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        m = grid.size()-1, n = grid[0].size()-1;\\n        dp.resize(m+1, vector<int>(n+1, -1));\\n        return fun(0, 0, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = grid[i][j];\\n                if(i>0 && j>0) dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n                else if(i>0) dp[i][j] += dp[i-1][j];\\n                else if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915672,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows in the grid, and m is the number of columns in the grid.\\n    //   - space: O(m), where m is the number of columns in the grid.\\n\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = grid\\n        let n = grid.count - 1\\n        let m = grid[0].count - 1\\n        \\n        for i in 0...n {\\n            for j in 0...m {\\n                var step = matrix[i][j]\\n        \\n                if i > 0 && j > 0 {\\n                    step += min(matrix[i - 1][j], matrix[i][j - 1])\\n                } else if i > 0 && j == 0 {\\n                    step += matrix[i - 1][j]\\n                } else if j > 0 && i == 0 {\\n                    step += matrix[i][j - 1]\\n                }\\n                \\n                matrix[i][j] = step\\n            }\\n        }\\n        \\n        return matrix[n][m]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows in the grid, and m is the number of columns in the grid.\\n    //   - space: O(m), where m is the number of columns in the grid.\\n\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = grid\\n        let n = grid.count - 1\\n        let m = grid[0].count - 1\\n        \\n        for i in 0...n {\\n            for j in 0...m {\\n                var step = matrix[i][j]\\n        \\n                if i > 0 && j > 0 {\\n                    step += min(matrix[i - 1][j], matrix[i][j - 1])\\n                } else if i > 0 && j == 0 {\\n                    step += matrix[i - 1][j]\\n                } else if j > 0 && i == 0 {\\n                    step += matrix[i][j - 1]\\n                }\\n                \\n                matrix[i][j] = step\\n            }\\n        }\\n        \\n        return matrix[n][m]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554297,
                "title": "python-in-place-dp-with-explanatory-comments-92ms-or-faster-than-97",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # get dimensions\\n        n = len(grid) # no of cells in each col\\n        m = len(grid[0]) # no of cells in each row\\n        \\n        # populate first row using m for no of cells in row\\n        for i in range(1,m):\\n            grid[0][i] = grid[0][i] + grid[0][i-1]\\n        \\n        # populate first col using n for no of cells in col\\n        for j in range(1,n):\\n            grid[j][0] = grid[j-1][0] + grid[j][0]\\n        \\n        # populate the rest\\n        for i in range(1,n):\\n            for j in range(1,m):\\n\\t\\t\\t\\t# get min seen so far plus curr cell value\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1]) + grid[i][j]\\n        \\n        # return last cell\\n        return grid[-1][-1]\\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # get dimensions\\n        n = len(grid) # no of cells in each col\\n        m = len(grid[0]) # no of cells in each row\\n        \\n        # populate first row using m for no of cells in row\\n        for i in range(1,m):\\n            grid[0][i] = grid[0][i] + grid[0][i-1]\\n        \\n        # populate first col using n for no of cells in col\\n        for j in range(1,n):\\n            grid[j][0] = grid[j-1][0] + grid[j][0]\\n        \\n        # populate the rest\\n        for i in range(1,n):\\n            for j in range(1,m):\\n\\t\\t\\t\\t# get min seen so far plus curr cell value\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1]) + grid[i][j]\\n        \\n        # return last cell\\n        return grid[-1][-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 23617,
                "title": "c-solution-beat-98-59",
                "content": "    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        vector<int> res(grid[0].size(),INT_MAX);\\n        res[0] = 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(j > 0)\\n                    res[j] = min(res[j-1],res[j]) + grid[i][j];\\n                else\\n                    res[j] = res[j] + grid[i][j];\\n        \\n        return res[grid[0].size()-1];\\n    }",
                "solutionTags": [],
                "code": "    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        vector<int> res(grid[0].size(),INT_MAX);\\n        res[0] = 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(j > 0)\\n                    res[j] = min(res[j-1],res[j]) + grid[i][j];\\n                else\\n                    res[j] = res[j] + grid[i][j];\\n        \\n        return res[grid[0].size()-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23611,
                "title": "my-java-clean-code-dp-no-extra-space",
                "content": "\\n    public int minPathSum(int[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(i == 0 && j == 0) continue;\\n                if(i == 0) grid[i][j] += grid[i][j - 1];\\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\\n                else grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n            }\\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n    public int minPathSum(int[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(i == 0 && j == 0) continue;\\n                if(i == 0) grid[i][j] += grid[i][j - 1];\\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\\n                else grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n            }\\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3225715,
                "title": "dynamic-programming-finding-the-minimum-path-sum-in-a-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe problem asks to find the minimum sum of a path from the top-left corner to the bottom-right corner of a grid. Since we are only allowed to move right and down, the possible paths we can take are limited. Hence, we can use dynamic programming to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can create a 2D array `dp` that stores the minimum sum of a path from the top-left corner to the current cell (i, j). We can initialize `dp[0][0]` as the first element of the grid. We can then populate the first row and column of the `dp` array by adding the current element of the grid to the previous element in the row/column.\\n\\nAfter initializing the first row and column, we can iterate through the rest of the `dp` array and calculate the minimum sum of the path to the current cell (i, j). We can calculate this by taking the minimum of the previous minimum path sum of the cell above (i-1, j) and the cell to the left (i, j-1). We then add the current element of the grid to the minimum sum.\\n\\nThe minimum sum of the path from the top-left corner to the bottom-right corner of the grid will be stored in `dp[m-1][n-1]`, where `m` and `n` are the dimensions of the grid.\\n# Complexity\\n- Time complexity: $$O(mn)$$, where m and n are the dimensions of the grid. We iterate through each cell in the `dp` array exactly once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(mn)$$, where m and n are the dimensions of the grid. We create a 2D array of size m x n to store the minimum path sum to each cell.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949291,
                "title": "simple-java-solution-with-tabulation-100-beat",
                "content": "\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n    if(grid.length == 0) return 0;\\n    int row = grid.length;\\n    int col = grid[0].length;\\n    \\n    for(int i=0;i<row; i++) {\\n        for(int j=0; j<col; j++) {\\n            int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n            int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n            if(i==0 && j==0) continue;\\n            \\n            grid[i][j] += Math.min(leftSum, topSum);\\n        }\\n    }\\n    return grid[row-1][col-1];\\n }\\n}\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n    if(grid.length == 0) return 0;\\n    int row = grid.length;\\n    int col = grid[0].length;\\n    \\n    for(int i=0;i<row; i++) {\\n        for(int j=0; j<col; j++) {\\n            int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n            int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n            if(i==0 && j==0) continue;\\n            \\n            grid[i][j] += Math.min(leftSum, topSum);\\n        }\\n    }\\n    return grid[row-1][col-1];\\n }\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323556,
                "title": "java-recursive-memoization-tabulization",
                "content": "```\\n**RECURSIVE APPROACH **\\n(gives TLE)\\n\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        return minPathSum(0,0,n,m,grid);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        \\n        return grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid), minPathSum(i, j+1, n,m,grid));\\n    }\\n}\\n```\\n**Memoization**\\n***ACCEPTED***\\n```\\npublic int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] num : memo)\\n            Arrays.fill(num, -1);\\n        return minPathSum(0,0,n,m,grid, memo);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid, int[][] memo){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        \\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        return memo[i][j] = grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid, memo), minPathSum(i, j+1, n,m,grid,memo));\\n    }\\n```\\n**Tabulization**\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 0; i<grid.length; i++){\\n            for(int j = 0; j<grid[0].length; j++){ \\n                if(i == 0 && j == 0)\\n                    grid[i][j] = grid[i][j];\\n \\n                else if(i == 0 && j != 0){\\n                    grid[i][j] = grid[i][j] + grid[i][j-1];\\n                }\\n                else if(i!= 0 && j == 0)\\n                    grid[i][j] = grid[i][j] + grid[i-1][j];\\n                else\\n                    grid[i][j] = grid[i][j] + Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n**RECURSIVE APPROACH **\\n(gives TLE)\\n\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        return minPathSum(0,0,n,m,grid);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        \\n        return grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid), minPathSum(i, j+1, n,m,grid));\\n    }\\n}\\n```\n```\\npublic int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] num : memo)\\n            Arrays.fill(num, -1);\\n        return minPathSum(0,0,n,m,grid, memo);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid, int[][] memo){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        \\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        return memo[i][j] = grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid, memo), minPathSum(i, j+1, n,m,grid,memo));\\n    }\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 0; i<grid.length; i++){\\n            for(int j = 0; j<grid[0].length; j++){ \\n                if(i == 0 && j == 0)\\n                    grid[i][j] = grid[i][j];\\n \\n                else if(i == 0 && j != 0){\\n                    grid[i][j] = grid[i][j] + grid[i][j-1];\\n                }\\n                else if(i!= 0 && j == 0)\\n                    grid[i][j] = grid[i][j] + grid[i-1][j];\\n                else\\n                    grid[i][j] = grid[i][j] + Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998855,
                "title": "backtracking-recursive-dp-java-solution-explained",
                "content": "**1. Backtracking**\\n\\tBacktracking template is Goal, Search Space & Constraint.\\n\\t\\n\\t```\\n\\t\\tpublic void backTracking() {\\n\\t\\t\\t// GOAL(Here we need to check what do we want in the end, \\n\\t\\t\\t// in our question the GOAL is to reach the bottom right index)\\n\\t\\t\\t\\n\\t\\t\\t// SEARCH SPACE(Here we basically iterate through \\n\\t\\t\\t// every possible move from current position, \\n\\t\\t\\t// in our question it is either moving to right or down)\\n\\t\\t\\t\\n\\t\\t\\t// CONSTRAINT(Here we need to check \\n\\t\\t\\t// whether the above chosen move is valid or not, here in our question \\n\\t\\t\\t// the CONSTRAINT is that the chosen move should be within the boundaries)\\n\\t\\t}\\n\\t```\\n\\t\\nWith the above being said, BackTracking Solution below\\n``` \\nclass Solution {\\n    private int res;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        res = Integer.MAX_VALUE;\\n        backTrack(arr, 0, 0, m-1, n-1, arr[0][0]);\\n        return res;\\n    }\\n    \\n    private int x[] = new int[]{0, 1};\\n    private int y[] = new int[]{1, 0};\\n    private void backTrack(int arr[][], int a, int b, int c, int d, int cur) {\\n\\t\\t// GOAL\\n        if(a == c && b == d) {\\n            res = Math.min(res, cur);\\n            return ;\\n        }\\n\\t\\t\\n\\t\\t// SEARCH SPACE\\n        for(int i=0;i<2;i++) {\\n            int nx = a + x[i];\\n            int ny = b + y[i];\\n\\t\\t\\t// CONSTRAINT\\n            if(isSafe(nx, ny, c, d)) {\\n                backTrack(arr, nx, ny, c, d, cur+arr[nx][ny]);\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(int a, int b, int c, int d) {\\n        return a >= 0 && b >= 0 && a <= c && b <= d;\\n    }\\n}\\n```\\n\\nThe above solution gives **TLE** because it takes every possible path into consideration.\\n\\n2. **Recursive** approach\\n\\n\\tThis problem pattern is similar to **\"With, Without\"** classic principle.\\n\\t\\n\\tAt each and every position , we have 2 choices in our given question. We can either go to the right or we can go to down. And we need to take the minimum of those 2 choices.\\n\\t\\n\\tLet\\'s just say that we are at position (a, b) & the array is arr[][] & the number of rows as m and the number of columns as n.\\n\\t\\n\\tThe recursive function goes like this:\\n\\t```\\n\\tfunction(int a, int b, int m, int n, int arr[][]) {\\n\\t\\n\\t\\t// Handle base case \\n\\t\\t// which is when we reach our desired bottom right position\\n\\t\\tif(a == m-1 && b == n-1) {\\n\\t\\t\\treturn arr[a][b];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Handle out of boundary cases\\n\\t\\tif(a >= m || b >= n)\\n            return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t\\n\\t\\t// Below means that we can take the current pos value \\n\\t\\t// and we are taking the minimum of right & down\\n\\t\\treturn arr[a][b] + Math.min(function(a, b+1, m, n, arr), function(a+1, b, m, n, arr));\\n\\t}\\n\\t```\\n\\t\\n\\tI have used a Map to cache the already calculated results\\n\\t\\n\\tWith that being said , Recursive solution below\\n\\t\\n\\t```\\n\\tclass Solution {\\n    private Map<String, Integer> map;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        map = new HashMap<>();\\n        return recur(arr, 0, 0, m, n);\\n    }\\n\\t\\n    private int recur(int arr[][], int a, int b, int c, int d) {\\n        if(a == c-1 && b == d-1)\\n            return arr[a][b];\\n        if(a >= c || b >= d)\\n            return Integer.MAX_VALUE;\\n        String key = String.valueOf(a) + \",\" + String.valueOf(b);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        int res = arr[a][b] + Math.min(\\n            recur(arr, a, b+1, c, d),\\n            recur(arr, a+1, b, c, d)\\n        );\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n\\t```\\n3. **Dynamic Programming** approach\\n\\nOnce we write the recursive approach, DP is easy to write.\\n\\nDP Solution below.\\n```\\nclass Solution {\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        return dy(arr);\\n    }\\n    \\n    private int dy(int arr[][]) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if( i == 0 && j == 0) {\\n                    dp[i][j] = arr[i][j];\\n                    continue;\\n                }\\n                dp[i][j] = arr[i][j] + Math.min(j > 0 ? dp[i][j-1] : Integer.MAX_VALUE, i > 0 ? dp[i-1][j] : Integer.MAX_VALUE);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\t\\tpublic void backTracking() {\\n\\t\\t\\t// GOAL(Here we need to check what do we want in the end, \\n\\t\\t\\t// in our question the GOAL is to reach the bottom right index)\\n\\t\\t\\t\\n\\t\\t\\t// SEARCH SPACE(Here we basically iterate through \\n\\t\\t\\t// every possible move from current position, \\n\\t\\t\\t// in our question it is either moving to right or down)\\n\\t\\t\\t\\n\\t\\t\\t// CONSTRAINT(Here we need to check \\n\\t\\t\\t// whether the above chosen move is valid or not, here in our question \\n\\t\\t\\t// the CONSTRAINT is that the chosen move should be within the boundaries)\\n\\t\\t}\\n\\t```\n``` \\nclass Solution {\\n    private int res;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        res = Integer.MAX_VALUE;\\n        backTrack(arr, 0, 0, m-1, n-1, arr[0][0]);\\n        return res;\\n    }\\n    \\n    private int x[] = new int[]{0, 1};\\n    private int y[] = new int[]{1, 0};\\n    private void backTrack(int arr[][], int a, int b, int c, int d, int cur) {\\n\\t\\t// GOAL\\n        if(a == c && b == d) {\\n            res = Math.min(res, cur);\\n            return ;\\n        }\\n\\t\\t\\n\\t\\t// SEARCH SPACE\\n        for(int i=0;i<2;i++) {\\n            int nx = a + x[i];\\n            int ny = b + y[i];\\n\\t\\t\\t// CONSTRAINT\\n            if(isSafe(nx, ny, c, d)) {\\n                backTrack(arr, nx, ny, c, d, cur+arr[nx][ny]);\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(int a, int b, int c, int d) {\\n        return a >= 0 && b >= 0 && a <= c && b <= d;\\n    }\\n}\\n```\n```\\n\\tfunction(int a, int b, int m, int n, int arr[][]) {\\n\\t\\n\\t\\t// Handle base case \\n\\t\\t// which is when we reach our desired bottom right position\\n\\t\\tif(a == m-1 && b == n-1) {\\n\\t\\t\\treturn arr[a][b];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Handle out of boundary cases\\n\\t\\tif(a >= m || b >= n)\\n            return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t\\n\\t\\t// Below means that we can take the current pos value \\n\\t\\t// and we are taking the minimum of right & down\\n\\t\\treturn arr[a][b] + Math.min(function(a, b+1, m, n, arr), function(a+1, b, m, n, arr));\\n\\t}\\n\\t```\n```\\n\\tclass Solution {\\n    private Map<String, Integer> map;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        map = new HashMap<>();\\n        return recur(arr, 0, 0, m, n);\\n    }\\n\\t\\n    private int recur(int arr[][], int a, int b, int c, int d) {\\n        if(a == c-1 && b == d-1)\\n            return arr[a][b];\\n        if(a >= c || b >= d)\\n            return Integer.MAX_VALUE;\\n        String key = String.valueOf(a) + \",\" + String.valueOf(b);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        int res = arr[a][b] + Math.min(\\n            recur(arr, a, b+1, c, d),\\n            recur(arr, a+1, b, c, d)\\n        );\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n\\t```\n```\\nclass Solution {\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        return dy(arr);\\n    }\\n    \\n    private int dy(int arr[][]) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if( i == 0 && j == 0) {\\n                    dp[i][j] = arr[i][j];\\n                    continue;\\n                }\\n                dp[i][j] = arr[i][j] + Math.min(j > 0 ? dp[i][j-1] : Integer.MAX_VALUE, i > 0 ? dp[i-1][j] : Integer.MAX_VALUE);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226798,
                "title": "javascript",
                "content": "**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u57FA\\u672C\\u601D\\u8DEF\\u4E3A: (i, j) = (i, j) + min((i - 1, j), (i, j - 1)).\\n2. \\u4F46\\u662F\\u7B2C\\u4E00\\u5217\\u548C\\u7B2C\\u4E00\\u884C\\u7684\\u6BCF\\u4E00\\u4E2A\\u5143\\u7D20, \\u5747\\u9700\\u8981\\u52A0\\u4E0A\\u524D\\u9762\\u4E00\\u4E2A\\u5143\\u7D20.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar minPathSum = function(grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  \\n  for (let i = 1; i < m; i++) {\\n    grid[i][0] += grid[i - 1][0];\\n  }\\n  for (let i = 1; i < n; i++) {\\n    grid[0][i] += grid[0][i - 1];\\n  }\\n  \\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n    }\\n  }\\n  \\n  return grid[m - 1][n - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minPathSum = function(grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  \\n  for (let i = 1; i < m; i++) {\\n    grid[i][0] += grid[i - 1][0];\\n  }\\n  for (let i = 1; i < n; i++) {\\n    grid[0][i] += grid[0][i - 1];\\n  }\\n  \\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n    }\\n  }\\n  \\n  return grid[m - 1][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3117215,
                "title": "c-recursion-dp-memoization-tabulation-space-optimization",
                "content": "# \\uD83D\\uDCA1Intuition and Approach :-\\n\\nhttps://www.youtube.com/watch?v=_rgTlyky1uQ&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=11\\n\\n#### This video helped me understand the Solution. Thanks to TUF and Striver \\uD83D\\uDE4F\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDCA1Code\\n# \\uD83D\\uDCA5Recursion :-\\n```\\nTC:O(2^n) SC:O((m-1)+(n-1))\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 ||j<0) return INT_MAX;\\n\\n        int up = grid[i][j] + f(i-1, j, grid);\\n        int left = grid[i][j] + f(i, j-1, grid);\\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        return f(n-1, m-1, grid);\\n    }\\n};\\n```\\n# \\uD83D\\uDCA5Memoization :-\\n```\\nTC:O(m*n) SC:O((m-1)+(n-1))+O(m*n)\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(i==0 && j==0) return grid[0][0];\\n        if(i<0 ||j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up = grid[i][j] + f(i-1, j, grid, dp);\\n        int left = grid[i][j] + f(i, j-1, grid, dp);\\n        return dp[i][j] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        return f(n-1,m-1, grid, dp);\\n    }\\n};\\n```\\n# \\uD83D\\uDCA5Tabulation :-\\n```\\nTC:O(m*n) SC:O(m*n)\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n\\n```\\n\\n# \\uD83D\\uDCA5Space Optimization :-\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<int> prev(m,0);\\n        for(int i=0; i<n; i++){\\n            vector<int> temp(m,0);\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    temp[0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= temp[j-1];\\n                    else left+= 1e9;\\n\\n                    temp[j] = min(up, left);\\n                }\\n            }\\n            prev = temp;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nTC:O(2^n) SC:O((m-1)+(n-1))\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 ||j<0) return INT_MAX;\\n\\n        int up = grid[i][j] + f(i-1, j, grid);\\n        int left = grid[i][j] + f(i, j-1, grid);\\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        return f(n-1, m-1, grid);\\n    }\\n};\\n```\n```\\nTC:O(m*n) SC:O((m-1)+(n-1))+O(m*n)\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(i==0 && j==0) return grid[0][0];\\n        if(i<0 ||j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up = grid[i][j] + f(i-1, j, grid, dp);\\n        int left = grid[i][j] + f(i, j-1, grid, dp);\\n        return dp[i][j] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        return f(n-1,m-1, grid, dp);\\n    }\\n};\\n```\n```\\nTC:O(m*n) SC:O(m*n)\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<int> prev(m,0);\\n        for(int i=0; i<n; i++){\\n            vector<int> temp(m,0);\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    temp[0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= temp[j-1];\\n                    else left+= 1e9;\\n\\n                    temp[j] = min(up, left);\\n                }\\n            }\\n            prev = temp;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405052,
                "title": "recursion-to-dp-memoization",
                "content": "Recursion:\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n                \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n            return grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            \\n        \\n        return helper(0,0)\\n```\\n\\nAdding memoization:\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cache = {}\\n        \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n\\t\\t\\t# return from cache if present\\n            if (i,j) in cache :\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t# populate cache\\n            cache[(i,j)] = grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            return cache[(i,j)]\\n            \\n        return helper(0,0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n                \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n            return grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            \\n        \\n        return helper(0,0)\\n```\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cache = {}\\n        \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n\\t\\t\\t# return from cache if present\\n            if (i,j) in cache :\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t# populate cache\\n            cache[(i,j)] = grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            return cache[(i,j)]\\n            \\n        return helper(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23637,
                "title": "passed-c-code-only-need-o-n-extra-space-and-don-t-change-the-original-data",
                "content": "    int minPathSum(vector<vector<int> > &grid) {\\n        int rows = grid.size();\\n        if (rows==0) return 0;\\n        int cols = grid[0].size();\\n        vector<int> vi(cols, INT_MAX);\\n\\n        int i, j;\\n        vi[0] = 0;\\n        for (i=0; i<rows; i++) {\\n            vi[0] += grid[i][0];\\n            for (j=1; j<cols; j++) {\\n                vi[j] = min(vi[j-1], vi[j])+grid[i][j];\\n            }\\n        }\\n        return vi[cols-1];\\n    }",
                "solutionTags": [],
                "code": "    int minPathSum(vector<vector<int> > &grid) {\\n        int rows = grid.size();\\n        if (rows==0) return 0;\\n        int cols = grid[0].size();\\n        vector<int> vi(cols, INT_MAX);\\n\\n        int i, j;\\n        vi[0] = 0;\\n        for (i=0; i<rows; i++) {\\n            vi[0] += grid[i][0];\\n            for (j=1; j<cols; j++) {\\n                vi[j] = min(vi[j-1], vi[j])+grid[i][j];\\n            }\\n        }\\n        return vi[cols-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3856514,
                "title": "most-optimized-2-methods-explained-dry-run-1d-dp-beats-100",
                "content": "# Method #1\\n# Intuition & Approach \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We are creating a vector of size rows and storing grid[i][0] in cur[i]\\n- Cur vector is used as dp vector in this method.\\n- Now update cur as if we are following the downward path only. \\n- Use nested loop and dry run the code,\\n- Here we are comparing the two possibilities(Right or Downward direction)\\n- For reaching the cell[i][j] in matrix and update it with minimum.\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m): m(Rows)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n\\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\\n### Dry Run:\\n![#dryRunMethod1(MinimumPathSum).jpeg](https://assets.leetcode.com/users/images/073a6b38-7fbd-4c14-be48-bb2ae1a7e872_1691043144.5424638.jpeg)\\n\\n# Method #2\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In any matrix where dp is involved this is the **generic** way to solve the problem.\\n- Create DP vector of n*m, initialize it by -1.\\n- Call it recursively.\\n- Check for valid indices, if we are at destination return dp[i][j]\\n- Store results of possible way, like(down, right, left, up)\\n- Store the required result like max/min OR sum/multiplication of it in dp[i][j]\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int i, int j,vector<vector<int>> &grid, vector<vector<int>> &dp){\\n    if(i<0 || j<0 ) return 1e9;\\n    if(i==0 && j==0) return grid[0][0];\\n    if(dp[i][j] != -1) return dp[i][j];\\n    \\n    int up = grid[i][j] + f(i-1, j, grid, dp);\\n    int left = grid[i][j] + f(i,j-1, grid, dp);\\n    return dp[i][j] = min(left,up); \\n  }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int> (n, -1));\\n\\n        return f(m-1, n-1,grid, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n\\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int f(int i, int j,vector<vector<int>> &grid, vector<vector<int>> &dp){\\n    if(i<0 || j<0 ) return 1e9;\\n    if(i==0 && j==0) return grid[0][0];\\n    if(dp[i][j] != -1) return dp[i][j];\\n    \\n    int up = grid[i][j] + f(i-1, j, grid, dp);\\n    int left = grid[i][j] + f(i,j-1, grid, dp);\\n    return dp[i][j] = min(left,up); \\n  }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int> (n, -1));\\n\\n        return f(m-1, n-1,grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345991,
                "title": "try-ones-more-using-my-hints-easy-java-solution-2-approaches-recursive-and-iterative",
                "content": "# Approach 1 Using recursion(Brute force)\\n\\n# Hints \\n- Use recursion \\n- Start from Destination grid[n][m] \\n- Each time check :- \\n    - If we reach source(i.e. n == 0 && m == 0) return grid[0][0]\\n    - Else if index is not valid return Integer.MAX_VALUE\\n    - Else return cost of current node(grid[n][m]) sum with mininum of cost to reach (n-1, m) and (n, m-1).\\n\\n# Note \\n- It will give Time Limit Exceeded as time is 2^n\\n\\n# Complexity\\n- Time complexity: O(2^(n*m))\\n\\n# Code \\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        return minPathSum(grid, grid.length-1, grid[0].length-1);\\n    }\\n    private int minPathSum(int[][] grid, int n, int m){\\n        if(n == 0 && m == 0) return grid[n][m];\\n        if(n < 0 || m < 0) return Integer.MAX_VALUE;\\n        return grid[n][m] + Math.min(minPathSum(grid, n-1, m), minPathSum(grid, n, m-1));\\n    }\\n}\\n```\\n\\n# Approach 2 Using DP\\n- Same approach in dp\\n- Try to frame dp solution yourself\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n                else if(i == 0) dp[i][j] = dp[i][j-1] + grid[i][j];\\n                else if(j == 0) dp[i][j] = dp[i-1][j] + grid[i][j];\\n                else {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        return minPathSum(grid, grid.length-1, grid[0].length-1);\\n    }\\n    private int minPathSum(int[][] grid, int n, int m){\\n        if(n == 0 && m == 0) return grid[n][m];\\n        if(n < 0 || m < 0) return Integer.MAX_VALUE;\\n        return grid[n][m] + Math.min(minPathSum(grid, n-1, m), minPathSum(grid, n, m-1));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n                else if(i == 0) dp[i][j] = dp[i][j-1] + grid[i][j];\\n                else if(j == 0) dp[i][j] = dp[i-1][j] + grid[i][j];\\n                else {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345808,
                "title": "java-easy-solution-fully-explained-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    /**\\n     * Space Complexity O(m*n) -- for dp matrix\\n     * Time Complexity O(m*n)\\n     * @param grid\\n     * @return\\n     */\\n    public int minPathSum(int[][] grid) {\\n        //initialise a dp with size same as original array\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                //start counting the cost from the bottom right cell(bottom up approach) this is base condition\\n                //Cost of going to destination from destination is the lowest subset problem\\n                //then expand with the computed value to other cells gradually\\n                //when solving bigger subsets other than base condition, remember we can only go right or bottom\\n                if (i + 1 > m - 1 && j + 1 > n - 1) //base condition\\n                    dp[i][j] = grid[i][j];\\n\\n                else if (i + 1 > m - 1)//boundary condition: handles the bottom most row\\n                    dp[i][j] = dp[i][j + 1] + grid[i][j];\\n\\n                else if (j + 1 > n - 1)//boundary condition: handles the right most column\\n                    dp[i][j] = dp[i + 1][j] + grid[i][j];\\n                else {// normal cells : get the min of 1 horizontal  right travel and 1 vertical bottom travel\\n                    dp[i][j] = Math.min(dp[i][j + 1] + grid[i][j], dp[i + 1][j] + grid[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Space Complexity O(m*n) -- for dp matrix\\n     * Time Complexity O(m*n)\\n     * @param grid\\n     * @return\\n     */\\n    public int minPathSum(int[][] grid) {\\n        //initialise a dp with size same as original array\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                //start counting the cost from the bottom right cell(bottom up approach) this is base condition\\n                //Cost of going to destination from destination is the lowest subset problem\\n                //then expand with the computed value to other cells gradually\\n                //when solving bigger subsets other than base condition, remember we can only go right or bottom\\n                if (i + 1 > m - 1 && j + 1 > n - 1) //base condition\\n                    dp[i][j] = grid[i][j];\\n\\n                else if (i + 1 > m - 1)//boundary condition: handles the bottom most row\\n                    dp[i][j] = dp[i][j + 1] + grid[i][j];\\n\\n                else if (j + 1 > n - 1)//boundary condition: handles the right most column\\n                    dp[i][j] = dp[i + 1][j] + grid[i][j];\\n                else {// normal cells : get the min of 1 horizontal  right travel and 1 vertical bottom travel\\n                    dp[i][j] = Math.min(dp[i][j + 1] + grid[i][j], dp[i + 1][j] + grid[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240046,
                "title": "c-solution-recursion-memoization-tabulation-with-tc-and-sc",
                "content": "**Normal Recursion (Result in TLE)**\\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        return min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int ans = rec(0,0,m,n,grid);\\n        return ans;\\n    }\\n};\\n```\\nTC: O(2^mxn)\\nSC: O(n {which is the largest path}) (stack space)\\n<hr style=\"margin:2rem 0;\">\\n\\n**Memoization**\\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        \\n        return dp[r][c] = min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans = rec(0,0,m,n,grid,dp);\\n        return ans;\\n    }\\n};\\n```\\nTC: O(mxn)\\nSC: O(n)(Stack space) + O(m x n) (DP array)\\n<hr style=\"margin:2rem 0;\">\\n\\n**Tabulation**\\n```\\n// Tabulation\\n// See Notes for recursion and memoization\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), down, right;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                down = right = 1000; // Random large number\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[0][0];\\n                else\\n                {\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    \\n                    dp[i][j] = min(down,right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\nTC: O(mxn)\\nSC: O(mxn) (DP array)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        return min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int ans = rec(0,0,m,n,grid);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        \\n        return dp[r][c] = min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans = rec(0,0,m,n,grid,dp);\\n        return ans;\\n    }\\n};\\n```\n```\\n// Tabulation\\n// See Notes for recursion and memoization\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), down, right;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                down = right = 1000; // Random large number\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[0][0];\\n                else\\n                {\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    \\n                    dp[i][j] = min(down,right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985866,
                "title": "c-dp-6-ms-faster-than-94-05-o-n-2",
                "content": "Simple DP solution in O(n^2)\\n\\nStep 1: Initialize a dp array\\nStep 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or column is the sum of all the elements from 0 to that index in the grid vector.\\nStep 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already filled them in Step 2.\\nStep 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\nthe value will be sum of the current value at grid, plus the minimum of the element at the top or element at the left side of the current element in the array.\\nStep 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n\\t\\t// Step 1: Initialize a dp array\\n\\n        int dp[row][col];\\n        \\n\\t\\t// Step 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or\\n\\t\\t// column is the sum of all the elements from 0 to that index in the grid vector.\\n\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<col;i++)\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        for(int i=1;i<row;i++)\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        \\n\\t\\t// Step 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already \\n\\t\\t// filled them in Step 2.\\n\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// Step 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\n\\t\\t\\t// the value will be sum of the current value at grid plus the minimum of the element at the top or \\n\\t\\t\\t// element at the left side of the current element in the array.\\n\\t\\t\\t\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n        \\n        return dp[row-1][col-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n\\t\\t// Step 1: Initialize a dp array\\n\\n        int dp[row][col];\\n        \\n\\t\\t// Step 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or\\n\\t\\t// column is the sum of all the elements from 0 to that index in the grid vector.\\n\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<col;i++)\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        for(int i=1;i<row;i++)\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        \\n\\t\\t// Step 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already \\n\\t\\t// filled them in Step 2.\\n\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// Step 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\n\\t\\t\\t// the value will be sum of the current value at grid plus the minimum of the element at the top or \\n\\t\\t\\t// element at the left side of the current element in the array.\\n\\t\\t\\t\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n        \\n        return dp[row-1][col-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510686,
                "title": "javascript-solution-faster-than-98-91-o-n-easy-method",
                "content": "```\\n// Optimized Implementation  | Runtime O(n) | space O(1)\\n// Runtime: 68 ms, faster than 98.91 % of JavaScript online submissions for Minimum Path Sum.\\n// Memory Usage: 41 MB, less than 46.37 % of JavaScript online submissions for Minimum Path Sum.\\n\\n//By doing this method, we can find the shortest distance for all the cell in the grid from the starting point.\\n\\nvar minPathSum = function (grid) {\\n    //loops through all the cell in the grid:\\n    for (let i = 0; i < grid.length; i++)\\n        for (let j = 0; j < grid[0].length; j++)\\n            // if the position is (0,0) ,pass it...\\n            if (i == 0 && j == 0)\\n                continue\\n            // if i=0 then update the grid[0][j] position value by (0,j) + (0,j-1) position\\'s value  { other_words:: current cell value + left cell of the current cell\\'s value in the grid }\\n            else if (i == 0)\\n                grid[i][j] += grid[i][j - 1];\\n            // if j=0 then update the grid[i][0] position value by (i,0) + (i-1,0) position\\'s value { other_words:: current cell value + top cell of the current cell\\'s value in the grid }\\n            else if (j == 0)\\n                grid[i][j] += grid[i - 1][j];\\n            // else (both i and j are not equal to zero)\\n            else\\n                // current cell value + left cell of the current cell\\'s value in the grid is smaller { < } then  current cell value + top cell of the current cell\\'s value in the grid\\n                //if true ,update the grid[i][j] value by current cell value + left cell of the current cell\\'s value in the grid\\n                if (grid[i][j] + grid[i][j - 1] < grid[i][j] + grid[i - 1][j])\\n                    grid[i][j] += grid[i][j - 1];\\n                //else ,update the grid[i][j] value by current cell value + top cell of the current cell\\'s value in the grid\\n                else\\n                    grid[i][j] += grid[i - 1][j];\\n    //return the last cell value \\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n\\nFor Example :\\n\\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___3____|___1____|\\n    |        |        |        |\\n    |___1____|___5____|___1____|\\n    |        |        | finish |\\n    |___4____|___2____|___1____|\\n\\t\\n\\tAt the end , grid is updated to the shortest distance sum from the starting point :\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___4____|___5____|\\n    |        |        |        |\\n    |___2____|___7____|___6____|\\n    |        |        | finish |\\n    |___6____|___8____|___7____|   return the last cell value  (7 in this case)\\n\\t\\n\\t\\tOutput: 7\\n\\t\\tExplanation: Because the path 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1 minimizes the sum.\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Optimized Implementation  | Runtime O(n) | space O(1)\\n// Runtime: 68 ms, faster than 98.91 % of JavaScript online submissions for Minimum Path Sum.\\n// Memory Usage: 41 MB, less than 46.37 % of JavaScript online submissions for Minimum Path Sum.\\n\\n//By doing this method, we can find the shortest distance for all the cell in the grid from the starting point.\\n\\nvar minPathSum = function (grid) {\\n    //loops through all the cell in the grid:\\n    for (let i = 0; i < grid.length; i++)\\n        for (let j = 0; j < grid[0].length; j++)\\n            // if the position is (0,0) ,pass it...\\n            if (i == 0 && j == 0)\\n                continue\\n            // if i=0 then update the grid[0][j] position value by (0,j) + (0,j-1) position\\'s value  { other_words:: current cell value + left cell of the current cell\\'s value in the grid }\\n            else if (i == 0)\\n                grid[i][j] += grid[i][j - 1];\\n            // if j=0 then update the grid[i][0] position value by (i,0) + (i-1,0) position\\'s value { other_words:: current cell value + top cell of the current cell\\'s value in the grid }\\n            else if (j == 0)\\n                grid[i][j] += grid[i - 1][j];\\n            // else (both i and j are not equal to zero)\\n            else\\n                // current cell value + left cell of the current cell\\'s value in the grid is smaller { < } then  current cell value + top cell of the current cell\\'s value in the grid\\n                //if true ,update the grid[i][j] value by current cell value + left cell of the current cell\\'s value in the grid\\n                if (grid[i][j] + grid[i][j - 1] < grid[i][j] + grid[i - 1][j])\\n                    grid[i][j] += grid[i][j - 1];\\n                //else ,update the grid[i][j] value by current cell value + top cell of the current cell\\'s value in the grid\\n                else\\n                    grid[i][j] += grid[i - 1][j];\\n    //return the last cell value \\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n\\nFor Example :\\n\\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___3____|___1____|\\n    |        |        |        |\\n    |___1____|___5____|___1____|\\n    |        |        | finish |\\n    |___4____|___2____|___1____|\\n\\t\\n\\tAt the end , grid is updated to the shortest distance sum from the starting point :\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___4____|___5____|\\n    |        |        |        |\\n    |___2____|___7____|___6____|\\n    |        |        | finish |\\n    |___6____|___8____|___7____|   return the last cell value  (7 in this case)\\n\\t\\n\\t\\tOutput: 7\\n\\t\\tExplanation: Because the path 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1 minimizes the sum.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369639,
                "title": "swift-minimum-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var dp = grid\\n        let rs = grid.count, cs = grid[0].count\\n        (1..<cs).forEach {\\n            dp[0][$0] += dp[0][$0-1]\\n        }\\n        (1..<rs).forEach {\\n            dp[$0][0] += dp[$0-1][0]\\n            for i in 1..<cs {\\n                dp[$0][i] += min(dp[$0-1][i], dp[$0][i-1])\\n            }\\n        }\\n        return dp[rs-1][cs-1]\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.036 (0.038) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.minPathSum([[1,3,1],[1,5,1],[4,2,1]])\\n        XCTAssertEqual(res, 7)\\n    }\\n    func test1() {\\n        let res = s.minPathSum([[1,2,3],[4,5,6]])\\n        XCTAssertEqual(res, 12)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var dp = grid\\n        let rs = grid.count, cs = grid[0].count\\n        (1..<cs).forEach {\\n            dp[0][$0] += dp[0][$0-1]\\n        }\\n        (1..<rs).forEach {\\n            dp[$0][0] += dp[$0-1][0]\\n            for i in 1..<cs {\\n                dp[$0][i] += min(dp[$0-1][i], dp[$0][i-1])\\n            }\\n        }\\n        return dp[rs-1][cs-1]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.036 (0.038) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.minPathSum([[1,3,1],[1,5,1],[4,2,1]])\\n        XCTAssertEqual(res, 7)\\n    }\\n    func test1() {\\n        let res = s.minPathSum([[1,2,3],[4,5,6]])\\n        XCTAssertEqual(res, 12)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819102,
                "title": "evolve-from-recursion-to-dp",
                "content": "1.  brute force O(2^min(m,n)), dfs returns the min cost from i, j to bottom right.\\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        return dfs(0,0,grid);\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        int down=dfs(i+1,j,grid), right=dfs(i,j+1,grid);\\n        return Math.min(down,right)+grid[i][j];\\n    }\\n```\\n2. Memoization O(mn) \\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        Integer[][] mem=new Integer[grid.length][grid[0].length];\\n        return dfs(0,0,grid,mem);\\n    }\\n    private int dfs(int i, int j, int[][] grid, Integer[][] mem) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        if(mem[i][j]!=null) return mem[i][j];\\n        int down=dfs(i+1,j,grid,mem), right=dfs(i,j+1,grid,mem);\\n        return mem[i][j]=Math.min(down,right)+grid[i][j];\\n    }\\n```\\n3. dp O(mn) Time, O(mn) Space. From #1, f[i][j] = min(f[i+1][j],f[i][j+1]) + grid[i][j] \\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[][] dp=new int[r+1][c+1];\\n\\t\\tfor(int i=0;i<r-1;i++) dp[i][c]=Integer.MAX_VALUE;// dp[r-1][c]=0\\n        for(int i=0;i<c-1;i++) dp[r][i]=Integer.MAX_VALUE;// dp[r][c-1]=0\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+grid[i][j];\\n        return dp[0][0];\\n    }\\n```\\n4. O(mn) Time, O(n) space dp\\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[] dp=new int[c+1];\\n\\t\\tArrays.fill(dp,Integer.MAX_VALUE);//row r\\n        dp[c-1]=0;\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[j]=Math.min(dp[j],dp[j+1])+grid[i][j];\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minPathSum(int[][] grid) {\\n        return dfs(0,0,grid);\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        int down=dfs(i+1,j,grid), right=dfs(i,j+1,grid);\\n        return Math.min(down,right)+grid[i][j];\\n    }\\n```\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        Integer[][] mem=new Integer[grid.length][grid[0].length];\\n        return dfs(0,0,grid,mem);\\n    }\\n    private int dfs(int i, int j, int[][] grid, Integer[][] mem) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        if(mem[i][j]!=null) return mem[i][j];\\n        int down=dfs(i+1,j,grid,mem), right=dfs(i,j+1,grid,mem);\\n        return mem[i][j]=Math.min(down,right)+grid[i][j];\\n    }\\n```\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[][] dp=new int[r+1][c+1];\\n\\t\\tfor(int i=0;i<r-1;i++) dp[i][c]=Integer.MAX_VALUE;// dp[r-1][c]=0\\n        for(int i=0;i<c-1;i++) dp[r][i]=Integer.MAX_VALUE;// dp[r][c-1]=0\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+grid[i][j];\\n        return dp[0][0];\\n    }\\n```\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[] dp=new int[c+1];\\n\\t\\tArrays.fill(dp,Integer.MAX_VALUE);//row r\\n        dp[c-1]=0;\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[j]=Math.min(dp[j],dp[j+1])+grid[i][j];\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 585111,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minPathSum = function(grid) {\\n    const i = grid.length - 1\\n    const j = grid[0].length - 1\\n    \\n    for(let k = 0; k <= i; ++k) {\\n        for(let l = 0; l <= j; ++l) {\\n            if(k > 0 && l > 0)\\n                grid[k][l] = Math.min(grid[k][l] + grid[k][l - 1], grid[k - 1][l] + grid[k][l])\\n            else if(k > 0 || l > 0) {\\n                if(l > 0)\\n                    grid[k][l] += grid[k][l - 1]\\n                else\\n                    grid[k][l] += grid[k - 1][l]\\n                }   \\n        }\\n    }\\n    \\n    return grid[i][j]\\n};\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minPathSum = function(grid) {\\n    const i = grid.length - 1\\n    const j = grid[0].length - 1\\n    \\n    for(let k = 0; k <= i; ++k) {\\n        for(let l = 0; l <= j; ++l) {\\n            if(k > 0 && l > 0)\\n                grid[k][l] = Math.min(grid[k][l] + grid[k][l - 1], grid[k - 1][l] + grid[k][l])\\n            else if(k > 0 || l > 0) {\\n                if(l > 0)\\n                    grid[k][l] += grid[k][l - 1]\\n                else\\n                    grid[k][l] += grid[k - 1][l]\\n                }   \\n        }\\n    }\\n    \\n    return grid[i][j]\\n};\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324419,
                "title": "java-solution-using-bfs-priorityqueue",
                "content": "Should be more efficient when m >> n or n >> m.\\n```\\nclass Solution {\\n    \\n    final int[][] dirs = new int[][]{{0, 1},{1, 0}};\\n    \\n    public int minPathSum(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n]; // dp[i][j] min sum to reach grid[i][j].\\n        boolean[][] visited = new boolean[m][n];\\n        pq.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            for(int[] dir : dirs) {\\n                int row = curr[0] + dir[0];\\n                int col = curr[1] + dir[1];\\n                if(row < 0 || row >= m || col < 0 || col >= n || visited[row][col])\\n                    continue;\\n                int[] next = new int[]{row, col, curr[2] + grid[row][col]};\\n                if(next[0] == m - 1 && next[1] == n - 1)\\n                    return next[2];\\n                visited[row][col] = true;\\n                pq.add(next);\\n            }\\n        }\\n        return grid[0][0]; // never reach unless m == n == 1.\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    final int[][] dirs = new int[][]{{0, 1},{1, 0}};\\n    \\n    public int minPathSum(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n]; // dp[i][j] min sum to reach grid[i][j].\\n        boolean[][] visited = new boolean[m][n];\\n        pq.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            for(int[] dir : dirs) {\\n                int row = curr[0] + dir[0];\\n                int col = curr[1] + dir[1];\\n                if(row < 0 || row >= m || col < 0 || col >= n || visited[row][col])\\n                    continue;\\n                int[] next = new int[]{row, col, curr[2] + grid[row][col]};\\n                if(next[0] == m - 1 && next[1] == n - 1)\\n                    return next[2];\\n                visited[row][col] = true;\\n                pq.add(next);\\n            }\\n        }\\n        return grid[0][0]; // never reach unless m == n == 1.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132430,
                "title": "top-down-dp",
                "content": "```\\n// Iteratively - hard to implement:\\nfor each path from (0,0) to (m-1,n-1)\\n    maintain min sum path\\n\\n// Recursively - recursion formula:\\nminPathSumFrom(x, y) = min(grid[x][y] + minPathSumFrom(nx, ny))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\_ move down or right from (x, y)\\nreturn minPathSumFrom(0, 0)\\n\\n// Add memoization because:\\nminPathSumFrom(nx, ny) will be calculated for multiple times since we have different paths to reach (x, y)\\n```\\n****\\n**Top-down DP**\\n```\\nclass Solution {\\n    // Assume we can only move either down or right at any point in time\\n    private final int[][] dirs = {{0, 1}, {1, 0}};\\n    private Integer[][] memo;\\n    \\n    public int minPathSum(int[][] grid) {\\n        memo = new Integer[grid.length][grid[0].length];\\n        return minPathSumFrom(grid, 0, 0);\\n    }\\n    \\n    private int minPathSumFrom(int[][] grid, int x, int y) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1){\\n            return grid[x][y];\\n        } else {\\n            if (memo[x][y] != null)\\n                return memo[x][y];\\n            \\n            int min = Integer.MAX_VALUE;\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx < grid.length && ny < grid[0].length) {\\n                    min = Math.min(grid[x][y] + minPathSumFrom(grid, nx, ny), min);\\n                }\\n            }\\n            \\n            memo[x][y] = min;\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Iteratively - hard to implement:\\nfor each path from (0,0) to (m-1,n-1)\\n    maintain min sum path\\n\\n// Recursively - recursion formula:\\nminPathSumFrom(x, y) = min(grid[x][y] + minPathSumFrom(nx, ny))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\_ move down or right from (x, y)\\nreturn minPathSumFrom(0, 0)\\n\\n// Add memoization because:\\nminPathSumFrom(nx, ny) will be calculated for multiple times since we have different paths to reach (x, y)\\n```\n```\\nclass Solution {\\n    // Assume we can only move either down or right at any point in time\\n    private final int[][] dirs = {{0, 1}, {1, 0}};\\n    private Integer[][] memo;\\n    \\n    public int minPathSum(int[][] grid) {\\n        memo = new Integer[grid.length][grid[0].length];\\n        return minPathSumFrom(grid, 0, 0);\\n    }\\n    \\n    private int minPathSumFrom(int[][] grid, int x, int y) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1){\\n            return grid[x][y];\\n        } else {\\n            if (memo[x][y] != null)\\n                return memo[x][y];\\n            \\n            int min = Integer.MAX_VALUE;\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx < grid.length && ny < grid[0].length) {\\n                    min = Math.min(grid[x][y] + minPathSumFrom(grid, nx, ny), min);\\n                }\\n            }\\n            \\n            memo[x][y] = min;\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23610,
                "title": "go-golang-solution",
                "content": "    func minPathSum(grid [][]int) int {\\n        var m int = len(grid)\\n        var n int = len(grid[0])\\n        for i := 1; i < m; i++{\\n        \\tgrid[i][0] += grid[i-1][0];\\n        }\\n        for j := 1; j < n; j++{\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for i:= 1; i < m; i++{\\n            for j:=1; j<n; j++{\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n        \\n    }\\n    func min(a, b int) int {\\n        if a < b {\\n            return a\\n        }\\n        return b\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func minPathSum(grid [][]int) int {\\n        var m int = len(grid)\\n        var n int = len(grid[0])\\n        for i := 1; i < m; i++{\\n        \\tgrid[i][0] += grid[i-1][0];\\n        }\\n        for j := 1; j < n; j++{\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for i:= 1; i < m; i++{\\n            for j:=1; j<n; j++{\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n        \\n    }\\n    func min(a, b int) int {\\n        if a < b {\\n            return a\\n        }\\n        return b\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23621,
                "title": "python-solution-dp-52-ms",
                "content": "The fastest time: `52 ms,beats 100.00% ` . \\n\\n    def minPathSum(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        for i in xrange(m):\\n            dp[0] += grid[i][0]\\n            for j in xrange(1, n):\\n                dp[j] = (min(dp[j], dp[j-1]) or dp[j-1]) + grid[i][j]\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The fastest time: `52 ms,beats 100.00% ` . \\n\\n    def minPathSum(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        for i in xrange(m):\\n            dp[0] += grid[i][0]\\n            for j in xrange(1, n):\\n                dp[j] = (min(dp[j], dp[j-1]) or dp[j-1]) + grid[i][j]\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23715,
                "title": "my-accepted-solution-in-java",
                "content": "In order to get the minimum sum to get to grid(m-1,n-1);\\n\\nSo we should get the minimum sum both  grid(m-1,n-1-1) and grid(m-1-1,n-1),\\n\\nSo that could convert to(I using every space in grid to hold the minimum sum get to grid(i,j))\\n\\n                               min( grid(i-1,j) , grid(i,j-1) ) + grid(i,j)                 i>0 && j>0\\n                       /  \\n          grid(i,j)=   |       grid(i,j-1)+grid(i,j)                                        i=0 && j>0\\n                       |  \\n                       |       grid(i-1,j)+grid(i,j)                                        i>0 && j=0 \\n                       \\\\  \\n                               grid(0,0)                                                    i=0 && j=0\\n                          \\n\\nFinally, the grid(m-1,n-1) is the result\\n\\nHope you can get my point :)\\n\\n\\n\\n    public class Solution {\\n        \\n        public int min(int a,int b)\\n        {\\n            return a>b?b:a;\\n        }\\n        \\n        public int minPathSum(int[][] grid) {\\n            if(grid.length==0) return 0;\\n            int m=grid.length;\\n            int n=grid[0].length;\\n            int[][] res=new int[grid.length][];\\n            for(int i=0;i<res.length;i++)\\n            {\\n                res[i]=Arrays.copyOf(grid[i],grid[i].length);\\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                res[0][i]+=res[0][i-1];\\n            }\\n            for(int i=1;i<m;i++)\\n            {\\n                res[i][0]+=res[i-1][0];\\n            }\\n            for(int i=1;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    res[i][j]+=min(res[i][j-1],res[i-1][j]);\\n                }\\n            }\\n            return res[m-1][n-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int min(int a,int b)\\n        {\\n            return a>b?b:a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3771191,
                "title": "unlocking-optimal-time-complexity-with-memoization-tabulation-and-space-optimization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // below is the function for recusion+memoization\\n    int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& DP)\\n    {\\n        if(i==0 && j==0)\\n            return grid[0][0];\\n        if(i<0 || j<0)\\n            return INT_MAX;\\n        if(DP[i][j] != -1)\\n            return DP[i][j];\\n        //here we need to take care if our solve function is returning INT_MAX and we adds grid[i][0] to it there will be integer overflow so I handled that only\\n        int up = (solve(i-1,j,grid,DP)==INT_MAX)?INT_MAX:(solve(i-1,j,grid,DP)+grid[i][j]);\\n        int left = (solve(i,j-1,grid,DP)==INT_MAX)?INT_MAX:(solve(i,j-1,grid,DP)+grid[i][j]);\\n\\n        return DP[i][j] = min(up,left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> DP(m,vector<int> (n,-1));\\n        // return solve(m-1,n-1,grid,DP);\\n\\n        // this below code if of tabulation\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         if(i==0 && j==0)\\n        //         {\\n        //             DP[i][j] = grid[0][0];\\n        //         }\\n        //         else\\n        //         {\\n        //             int up = INT_MAX;\\n        //             int left = INT_MAX;\\n        //             if(i>0)\\n        //                 up = DP[i-1][j] + grid[i][j]; \\n        //             if(j>0)\\n        //                 left = DP[i][j-1] + grid[i][j]; \\n        //             DP[i][j] = min(up,left);\\n        //         }\\n        //     }\\n        // }\\n        // return DP[m-1][n-1];\\n\\n\\n        // below is the code for space optimization\\n        // all we need is prev row and the current row on which we are doing operations\\n        vector<int> prev(n,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> curr(n,-1);\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    curr[j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    int up = INT_MAX;\\n                    int left = INT_MAX;\\n                    if(i>0)\\n                        up = prev[j] + grid[i][j]; \\n                    if(j>0)\\n                        left = curr[j-1] + grid[i][j]; \\n                    curr[j] = min(up,left);\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // below is the function for recusion+memoization\\n    int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& DP)\\n    {\\n        if(i==0 && j==0)\\n            return grid[0][0];\\n        if(i<0 || j<0)\\n            return INT_MAX;\\n        if(DP[i][j] != -1)\\n            return DP[i][j];\\n        //here we need to take care if our solve function is returning INT_MAX and we adds grid[i][0] to it there will be integer overflow so I handled that only\\n        int up = (solve(i-1,j,grid,DP)==INT_MAX)?INT_MAX:(solve(i-1,j,grid,DP)+grid[i][j]);\\n        int left = (solve(i,j-1,grid,DP)==INT_MAX)?INT_MAX:(solve(i,j-1,grid,DP)+grid[i][j]);\\n\\n        return DP[i][j] = min(up,left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> DP(m,vector<int> (n,-1));\\n        // return solve(m-1,n-1,grid,DP);\\n\\n        // this below code if of tabulation\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         if(i==0 && j==0)\\n        //         {\\n        //             DP[i][j] = grid[0][0];\\n        //         }\\n        //         else\\n        //         {\\n        //             int up = INT_MAX;\\n        //             int left = INT_MAX;\\n        //             if(i>0)\\n        //                 up = DP[i-1][j] + grid[i][j]; \\n        //             if(j>0)\\n        //                 left = DP[i][j-1] + grid[i][j]; \\n        //             DP[i][j] = min(up,left);\\n        //         }\\n        //     }\\n        // }\\n        // return DP[m-1][n-1];\\n\\n\\n        // below is the code for space optimization\\n        // all we need is prev row and the current row on which we are doing operations\\n        vector<int> prev(n,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> curr(n,-1);\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    curr[j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    int up = INT_MAX;\\n                    int left = INT_MAX;\\n                    if(i>0)\\n                        up = prev[j] + grid[i][j]; \\n                    if(j>0)\\n                        left = curr[j-1] + grid[i][j]; \\n                    curr[j] = min(up,left);\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346652,
                "title": "cpp-solution-using-graph-bfs-dijkstra-greedy",
                "content": "I used the greedy approach along with Dijkstra to reach the destination node with lowest path sum possible.\\n\\n* Used the Priority Queue (to create min-heap) to get the lowest possible path sum node out from the queue.\\n* Priority Queue store in the format: `{pathSum,{row,col}}`\\n* Created the **vis** array to store the lowest path sum along each path.\\n* Then a simple **BFS** along every possible node and storing the min pathSum for the node in **vis** array.\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,1e9));\\n        typedef pair<int,pair<int,int>> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n\\t\\tint pathSum0 = grid[0][0];\\n        pq.push({pathSum0,{0,0}});\\n        \\n        int delr[] = {1,0};\\n        int delc[] = {0,1};\\n        \\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t// Destination Node\\n            if(row==n-1 and col==m-1) return val;\\n            \\n\\t\\t\\t// checking for adjacent possible node\\n            for(int i=0;i<2;i++){\\n                int newr = row+delr[i];\\n                int newc = col+delc[i];\\n                \\n\\t\\t\\t\\t// Checking for valid nodes\\n                if(newr>=0 and newr<n and newc>=0 and newc<m){\\n\\t\\t\\t\\t\\tint pathSum=val+grid[newr][newc];\\n                    if(pathSum<vis[newr][newc]){\\n                        vis[newr][newc]=pathSum;\\n                        pq.push({pathSum,{newr,newc}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,1e9));\\n        typedef pair<int,pair<int,int>> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n\\t\\tint pathSum0 = grid[0][0];\\n        pq.push({pathSum0,{0,0}});\\n        \\n        int delr[] = {1,0};\\n        int delc[] = {0,1};\\n        \\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t// Destination Node\\n            if(row==n-1 and col==m-1) return val;\\n            \\n\\t\\t\\t// checking for adjacent possible node\\n            for(int i=0;i<2;i++){\\n                int newr = row+delr[i];\\n                int newc = col+delc[i];\\n                \\n\\t\\t\\t\\t// Checking for valid nodes\\n                if(newr>=0 and newr<n and newc>=0 and newc<m){\\n\\t\\t\\t\\t\\tint pathSum=val+grid[newr][newc];\\n                    if(pathSum<vis[newr][newc]){\\n                        vis[newr][newc]=pathSum;\\n                        pq.push({pathSum,{newr,newc}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345844,
                "title": "python-3-7-lines-prefix-array-w-explanation-t-m-95-81",
                "content": "For this discussion, let`grid = [[1,3,1,2],[1,5,1,2],[4,2,1,3]]`(Figure 1 below). The general plan is to overwrite`grid`with a prefix array based on the minimum cost at each cell in`grid`.\\n\\nHere are the steps:\\n\\n1. We start with the first row and first column. Because only down and right moves are permitted, the paths to the [2,0] and [0,3] are straightforward. (Figure 2).\\n\\n2. Finally we iterate through`grid`, updating each cell with the sum of the cell\\'s value and the minimum of the cell above and the cell to the left of it (Figure 3).\\n3. The value at the end cell is returned as the minimum path sum (Figure 4).\\n\\n \\n![Untitled.jpg](https://assets.leetcode.com/users/images/8bf67e06-c194-4b35-9718-a5803e0e843f_1679890563.3292673.jpeg)\\n\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid), len(grid[0])\\n        M, N = range(1,m),range(1,n)\\n\\n        for i in N: grid[0][i] += grid[0][i - 1]            #  \\n                                                            # <\\u2013\\u2013 1.\\n        for j in M: grid[j][0] += grid[j - 1][0]            #\\n\\n        for i, j in product(M,N):\\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])   # <\\u2013\\u2013 2.\\n\\n        return grid[m-1][n-1]                               # <\\u2013\\u2013 3.\\n```\\n[https://leetcode.com/problems/minimum-path-sum/submissions/922719112/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid), len(grid[0])\\n        M, N = range(1,m),range(1,n)\\n\\n        for i in N: grid[0][i] += grid[0][i - 1]            #  \\n                                                            # <\\u2013\\u2013 1.\\n        for j in M: grid[j][0] += grid[j - 1][0]            #\\n\\n        for i, j in product(M,N):\\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])   # <\\u2013\\u2013 2.\\n\\n        return grid[m-1][n-1]                               # <\\u2013\\u2013 3.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345625,
                "title": "daily-leetcoding-challenge-march-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming 2D\n\n  \n**Approach 3:** Dynamic Programming 1D\n\n  \n**Approach 4:** Dynamic Programming (Without Extra Space)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 4:** Dynamic Programming (Without Extra Space)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3055440,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& v) {\\n         int n = v.size(), m= v[0].size();\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    curr[j] = v[0][0];\\n                }\\n                else{\\n              int up =v[i][j] , left = v[i][j] ;\\n              if(i>0) up += prev[j];\\n\\n              else up += 1e9;\\n\\n        \\t   if(j>0) left += curr[j-1];\\n\\n        \\t   else left += 1e9;\\n        \\t  \\n        \\t    curr[j] = min(up,left) ;\\n            }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& v) {\\n         int n = v.size(), m= v[0].size();\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    curr[j] = v[0][0];\\n                }\\n                else{\\n              int up =v[i][j] , left = v[i][j] ;\\n              if(i>0) up += prev[j];\\n\\n              else up += 1e9;\\n\\n        \\t   if(j>0) left += curr[j-1];\\n\\n        \\t   else left += 1e9;\\n        \\t  \\n        \\t    curr[j] = min(up,left) ;\\n            }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810588,
                "title": "accepted-worst-to-most-optimised-approaches-easy-to-understand",
                "content": "# Approach 1: Recursion (TLE)\\n\\nStep 1: Take i and j variable initilaise both as 0, That will be or starting path for given matrix. Call solve fucntion.\\n\\nStep 2: (Base case) check if i and j are last box index then return grid [i][j];\\n\\nStep 3: Take down and right int variable initialize both as INT_MAX\\n* Check if we can jump to right side in our matrix range then check for right path and call same fuction with j+1\\n* Check if we can jump to down side in our matrix range then check for down path and call same fuction with i+1.\\n\\nStep 4: return sum of current grid[i][j] and min of either down or right value.\\n \\n\\n**Time Complexity: O(N * M)**\\n* **Reason:** At max, there will be N*M calls of recursion.\\n\\n**Space Complexity: O((M-1)+(N-1)) + O(N*M)**\\n* **Reason:** We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length\\n\\n**Recrusive Tree**\\n![MicrosoftTeams-image (69).png](https://assets.leetcode.com/users/images/6a545a74-9c08-4ae1-91f7-47ed1ab11761_1668339452.307515.jpeg)\\n\\n\\n**C++ Code: (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n\\n        int down=INT_MAX,right=INT_MAX;\\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid);\\n\\n        return grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        return solve(0,0,n,m,grid);\\n    }\\n};\\n```\\n\\n**Approach 2: Memoization (Accepted)**\\nwe have see that there are overlapping subproblems in recursive. In order to convert a recursive solution the following steps will be taken:\\n\\n1. Create a dp array of size [n][m]\\n2. Whenever we want to find the answer of a particular row and column (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.\\n3. If not, then we are finding the answer for the given values for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.\\n\\n**Time Complexity: O(N*M)**\\n* **Reason:** At max, there will be N*M calls of recursion.\\n\\n**Space Complexity: O((M-1)+(N-1)) + O(N*M)**\\n* **Reason:** We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length and an external DP Array of size \\u2018N*M\\u2019\\n\\n**C++ Code (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down=INT_MAX,right=INT_MAX;\\n        \\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid,dp);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,grid,dp);\\n    }\\n};\\n```\\n\\n**Approach 3: Tabulation (Accepted)**\\nTabulation is the bottom-up approach, which means we will go from the base case to the main problem.\\n\\nThe steps to convert to the tabular solution are given below:\\n\\n1. Declare a dp[] array of size [n][m].\\n2. First initialize the base condition values, i.e dp[n-1][m-1] = matrix[n-1][m-1]\\n3. Our answer should get stored in dp[0][0]. We want to move from (n-1,m-1) to (0,0). But we can\\u2019t move arbitrarily, we should move such that at a particular i and j, we have all the values required to compute dp[i][j].\\n4. If we see the memoized code, values required for dp[i][j] are: dp[i+1][j] and dp[i][j+1]. So we only use the next row and column value.\\n5. We have already filled the bottom-right corner (i=n-1 and j=m-1), if we move in any of the two following ways(given below), at every cell we do have all the previous values required to compute its value.\\n5. We can use two nested loops to have this traversal\\n6. Whenever i<n , j<n, we will simply mark dp[i][j] = matric[i][j] + min(dp[i+1][j],dp[i][j+1]), according to our recursive relation.\\n7. When i=n or j=m, we add to down OR right as INT_MAX, so that this path can be rejected.\\n\\n**Time Complexity: O(N*M)**\\n- **Reason:** There are two nested loops\\n\\n**Space Complexity: O(N*M)**\\n- **Reason:** We are using an external array of size \\u2018N*M\\u2019\\u2019.\\n\\n**Paper Dry run:**\\n![MicrosoftTeams-image (67).png](https://assets.leetcode.com/users/images/5645c7e7-bdd7-464a-8595-42391ac8c27c_1668338853.526015.jpeg)\\n\\n\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=dp[i+1][j];\\n                    if(j+1<m)\\n                        right=dp[i][j+1];\\n                    dp[i][j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n**Approach 4: Space optimised (Accepted most Optimised)**\\nIf we closely look the relation,\\n- dp[i][j] = grid[i][j] + min(dp[i+1][j] + dp[i][j+1]))\\n\\nWe see that we only need the next row and column, in order to calculate dp[i][j]. Therefore we can space optimize it.\\n\\n1. Initially, we can take a dummy row ( say prevRow) and initialize it as 0.\\n2. Now the current row(say CurrRow) only needs the next row value and the current row\\u2019s value in order to calculate dp[i][j].\\n\\n![MicrosoftTeams-image (68).png](https://assets.leetcode.com/users/images/b2caf957-e9d4-4a87-bc3b-75e66d420245_1668339394.1703806.jpeg)\\n\\n3. At the next step, the currRow array becomes the prevRow of the next step and using its values we can still calculate the next row\\u2019s values.\\n4. At last prevRow[0] will give us the required answer.\\n\\n**Time Complexity: O(M*N)**\\n- **Reason:** There are two nested loops\\n\\n**Space Complexity: O(N)**\\n- **Reason:** We are using an external array of size \\u2018N\\u2019 to store only one row.\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> prevRow(m+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            vector<int> currRow(m+1,0);\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    currRow[j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=prevRow[j];\\n                    if(j+1<m)\\n                        right=currRow[j+1];\\n                    currRow[j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n            prevRow=currRow;\\n        }\\n        \\n        return prevRow[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n\\n        int down=INT_MAX,right=INT_MAX;\\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid);\\n\\n        return grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        return solve(0,0,n,m,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down=INT_MAX,right=INT_MAX;\\n        \\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid,dp);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,grid,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=dp[i+1][j];\\n                    if(j+1<m)\\n                        right=dp[i][j+1];\\n                    dp[i][j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> prevRow(m+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            vector<int> currRow(m+1,0);\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    currRow[j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=prevRow[j];\\n                    if(j+1<m)\\n                        right=currRow[j+1];\\n                    currRow[j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n            prevRow=currRow;\\n        }\\n        \\n        return prevRow[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693577,
                "title": "c-easy-fast-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693571,
                "title": "c-easy-and-fast-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766321,
                "title": "c-3-solutions-recursive-memoization-tabulation",
                "content": "**1. Recursion**\\n```\\nint calculate(int row, int col, vector<vector<int>> &grid) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return 101;\\n    int left = calculate(row, col - 1, grid) + grid[row][col];\\n    int up = calculate(row - 1, col, grid) + grid[row][col];\\n    return min(left, up);\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    return calculate(row - 1, col - 1, grid);\\n}\\n```\\n\\n**2. Memoization**\\n```\\nint calculate(int row, int col, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return INT_MAX;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = calculate(row, col - 1, grid, dp);\\n    int up = calculate(row - 1, col, grid, dp);\\n    return dp[row][col] = min(left, up) + grid[row][col];\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return calculate(row - 1, col - 1, grid, dp);\\n}\\n```\\n\\n**3. Tabulation**\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n            else {\\n                int left = INT_MAX, up = INT_MAX;\\n                if(i > 0) up = min(up, dp[i - 1][j]);\\n                if(j > 0) left = min(left, dp[i][j - 1]);\\n                \\n                dp[i][j] = min(up, left) + grid[i][j];\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint calculate(int row, int col, vector<vector<int>> &grid) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return 101;\\n    int left = calculate(row, col - 1, grid) + grid[row][col];\\n    int up = calculate(row - 1, col, grid) + grid[row][col];\\n    return min(left, up);\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    return calculate(row - 1, col - 1, grid);\\n}\\n```\n```\\nint calculate(int row, int col, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return INT_MAX;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = calculate(row, col - 1, grid, dp);\\n    int up = calculate(row - 1, col, grid, dp);\\n    return dp[row][col] = min(left, up) + grid[row][col];\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return calculate(row - 1, col - 1, grid, dp);\\n}\\n```\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n            else {\\n                int left = INT_MAX, up = INT_MAX;\\n                if(i > 0) up = min(up, dp[i - 1][j]);\\n                if(j > 0) left = min(left, dp[i][j - 1]);\\n                \\n                dp[i][j] = min(up, left) + grid[i][j];\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401676,
                "title": "c-dp-space-o-1-time-o-m-n",
                "content": "Please upvote if it was helpful.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tgrid[i][0] += grid[i-1][0];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int j=1; j<n; j++){\\n\\t\\t\\t\\tgrid[0][j] += grid[0][j-1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tfor(int j=1; j<n; j++){\\n\\t\\t\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn grid[m-1][n-1];\\n\\t\\t}\\n\\t};\\nThank You!!",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tgrid[i][0] += grid[i-1][0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1361958,
                "title": "c-solution-for-64-minimum-path-sum-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {   \\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0 && j==0){ dp[0][0] = grid[0][0]; }\\n                else if(i==0){ dp[0][j] = dp[0][j-1] + grid[0][j]; }\\n                else if(j==0){ dp[i][0] = dp[i-1][0] + grid[i][0]; }\\n                else\\n                {\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] ; \\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {   \\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0 && j==0){ dp[0][0] = grid[0][0]; }\\n                else if(i==0){ dp[0][j] = dp[0][j-1] + grid[0][j]; }\\n                else if(j==0){ dp[i][0] = dp[i-1][0] + grid[i][0]; }\\n                else\\n                {\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] ; \\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231754,
                "title": "c-dynamic-programming-short-and-easy-approach",
                "content": "class Solution {\\npublic:\\n**The idea is to traverse from right to left (starting from bottom to top).\\nEach cell of the dp will contain cost to reach the end cell.**\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int dp[row][col];\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1 ; j>=0 ; j--){\\n                if(i==row-1 and j==col-1){ //means we are at end cell\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else if(i==row-1){  //means we are at last row\\n                    dp[i][j]=grid[i][j]+dp[i][j+1];\\n                }\\n                else if(j==col-1){ //means we are at last col\\n                    dp[i][j]=grid[i][j]+dp[i+1][j];\\n                }\\n                else{  //rest of the cell\\n                    dp[i][j] = grid[i][j] + min(dp[i+1][j],dp[i][j+1]);\\n                }\\n                \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n**The idea is to traverse from right to left (starting from bottom to top).\\nEach cell of the dp will contain cost to reach the end cell.**\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int dp[row][col];\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1 ; j>=0 ; j--){\\n                if(i==row-1 and j==col-1){ //means we are at end cell\\n                    dp[i][j]=grid[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1111685,
                "title": "c-dp-minimum-path-sum",
                "content": "```int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        dp[n-1][m-1]=grid[n-1][m-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[n-1][i]=grid[n-1][i]+dp[n-1][i+1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[i][m-1]=grid[i][m-1]+dp[i+1][m-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=grid[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return dp[0][0];```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        dp[n-1][m-1]=grid[n-1][m-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[n-1][i]=grid[n-1][i]+dp[n-1][i+1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[i][m-1]=grid[i][m-1]+dp[i+1][m-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=grid[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return dp[0][0];```",
                "codeTag": "Unknown"
            },
            {
                "id": 652173,
                "title": "python-dp",
                "content": "Python version:\\n\\n``` \\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n    \\n        n = len(grid)\\n        m = len(grid[0])\\n       \\n        # Edit the first row:\\n        for i in range(1, m):\\n            grid[0][i] = grid[0][i-1] + grid[0][i]\\n        \\n        # Edit the first col:\\n        for i in range(1, n):\\n            grid[i][0] = grid[i-1][0] + grid[i][0]\\n        \\n        # Edit the remaining values in the grid accordingly!\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]\\n        \\n        \\n        return grid[-1][-1]\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n    \\n        n = len(grid)\\n        m = len(grid[0])\\n       \\n        # Edit the first row:\\n        for i in range(1, m):\\n            grid[0][i] = grid[0][i-1] + grid[0][i]\\n        \\n        # Edit the first col:\\n        for i in range(1, n):\\n            grid[i][0] = grid[i-1][0] + grid[i][0]\\n        \\n        # Edit the remaining values in the grid accordingly!\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]\\n        \\n        \\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645575,
                "title": "all-possible-solution-with-c-code-brute-force-memoization-and-bottom-up",
                "content": "***Brute Force***\\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    return grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1),findMinSumInGrid(grid,row,col,currRow+1,currCol));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        return findMinSumInGrid(grid,row,col,0,0);\\n    \\n    }\\n};\\n```\\n\\n***memoization***\\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol,vector<vector<int>>& dp){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    if(dp[currRow][currCol] != -1)  return dp[currRow][currCol];\\n    \\n    return dp[currRow][currCol] = grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1,dp),findMinSumInGrid(grid,row,col,currRow+1,currCol,dp));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return findMinSumInGrid(grid,row,col,0,0,dp);\\n    \\n    }\\n};\\n```\\n***Bottom up***\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //bottom up approach for the problem\\n        //space complexity will be O(n*m)\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> dp(row,vector<int> (col,0));\\n        \\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                \\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }else{\\n                    if(i == 0){\\n                        dp[i][j] = grid[i][j] + dp[i][j-1];\\n                    }else{\\n                        if(j == 0){\\n                            dp[i][j] = grid[i][j] + dp[i-1][j];\\n                        }else{\\n                            dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1]);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[row-1][col-1];\\n    }\\n};\\n```\\nhope it helps!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    return grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1),findMinSumInGrid(grid,row,col,currRow+1,currCol));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        return findMinSumInGrid(grid,row,col,0,0);\\n    \\n    }\\n};\\n```\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol,vector<vector<int>>& dp){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    if(dp[currRow][currCol] != -1)  return dp[currRow][currCol];\\n    \\n    return dp[currRow][currCol] = grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1,dp),findMinSumInGrid(grid,row,col,currRow+1,currCol,dp));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return findMinSumInGrid(grid,row,col,0,0,dp);\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //bottom up approach for the problem\\n        //space complexity will be O(n*m)\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> dp(row,vector<int> (col,0));\\n        \\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                \\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }else{\\n                    if(i == 0){\\n                        dp[i][j] = grid[i][j] + dp[i][j-1];\\n                    }else{\\n                        if(j == 0){\\n                            dp[i][j] = grid[i][j] + dp[i-1][j];\\n                        }else{\\n                            dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1]);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[row-1][col-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586683,
                "title": "c-iterative-dp",
                "content": "```\\n/*I\\'m going to solve it by iterative dynamic programming\\n\\nfor iterative DP base cases shuld be filled \\n\\nbase cases are in this problem is that you can fill first row and first column the reson behind it is that you don\\'t have multiple path to reach there\\n\\nso for sample test case dp array would be look like\\n\\n1 4 5 (1,1+3,1+3+1)\\n2 \\n6\\n(\\n1,\\n1+1,\\n1+1+4\\n)\\n\\nnow iteratively I\\'m going to fell other enteries if I want to fill dp[i][j] it is obvious that i reach i,j from i-1,j or i,j-1 so I will take min of them and add it into grid[i][j]\\n\\n1 4 5\\n2 7\\n6\\n\\n1 4 5\\n2 7 6\\n6\\n\\n1 4 5\\n2 7 6\\n6 8 \\n\\n1 4 5\\n2 7 6\\n6 8 7\\n\\n7 is answer\\n\\n*/\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int** dp=new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i]=new int[n];\\n        }\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+grid[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n        int ans=dp[m-1][n-1];\\n        for(int i=0;i<grid.size();i++){\\n            delete[] dp[i];\\n        }\\n        delete[] dp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*I\\'m going to solve it by iterative dynamic programming\\n\\nfor iterative DP base cases shuld be filled \\n\\nbase cases are in this problem is that you can fill first row and first column the reson behind it is that you don\\'t have multiple path to reach there\\n\\nso for sample test case dp array would be look like\\n\\n1 4 5 (1,1+3,1+3+1)\\n2 \\n6\\n(\\n1,\\n1+1,\\n1+1+4\\n)\\n\\nnow iteratively I\\'m going to fell other enteries if I want to fill dp[i][j] it is obvious that i reach i,j from i-1,j or i,j-1 so I will take min of them and add it into grid[i][j]\\n\\n1 4 5\\n2 7\\n6\\n\\n1 4 5\\n2 7 6\\n6\\n\\n1 4 5\\n2 7 6\\n6 8 \\n\\n1 4 5\\n2 7 6\\n6 8 7\\n\\n7 is answer\\n\\n*/\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int** dp=new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i]=new int[n];\\n        }\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+grid[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n        int ans=dp[m-1][n-1];\\n        for(int i=0;i<grid.size();i++){\\n            delete[] dp[i];\\n        }\\n        delete[] dp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584858,
                "title": "python-straightforward-recursion-with-caching",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        maxx,maxy = len(grid),len(grid[0])\\n        cache={}\\n        \\n        def mPS(x,y):\\n            if x+1==maxx and y+1==maxy:\\n                return grid[x][y]            \\n            if x+1<maxx and y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+min(mPS(x+1,y),mPS(x,y+1))\\n            elif x+1<maxx:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x+1,y)\\n            elif y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x,y+1)\\n            return cache[(x,y)]\\n            \\n        return mPS(0,0)  \\n```\\n\\nPretty much self explanatory.\\n\\nRecursion ends when we hit the last cell. Otherwise we recursively try cells caching results along the way.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        maxx,maxy = len(grid),len(grid[0])\\n        cache={}\\n        \\n        def mPS(x,y):\\n            if x+1==maxx and y+1==maxy:\\n                return grid[x][y]            \\n            if x+1<maxx and y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+min(mPS(x+1,y),mPS(x,y+1))\\n            elif x+1<maxx:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x+1,y)\\n            elif y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x,y+1)\\n            return cache[(x,y)]\\n            \\n        return mPS(0,0)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 574715,
                "title": "java-o-n-in-place-no-recursion-simple-with-explaination",
                "content": "Since we don\\'t have any blocked squares, we can iterate through the entire array of arrays and find the minimum possible ways to reach from everywhere.\\nInstead of using another storage block, here we cumulatively add the values to the next cells and initialize the first row and first columns.\\nFor all the internal cells, we add the minimum value to reach from top or left, whichever is smaller.\\nAt the end, return the last cell which was our destination.\\n\\nThe time complexity is O(n) where n is the number of cells in the matrix. The space complexity is O(1) because no additional space is used.\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 1; i < grid.length; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j = 1; j < grid[0].length; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i = 1; i < grid.length; i++){\\n            for(int j = 1; j < grid[0].length; j++){\\n                grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```\\n\\n**Please upvote the solution if you found it helpful.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 1; i < grid.length; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j = 1; j < grid[0].length; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i = 1; i < grid.length; i++){\\n            for(int j = 1; j < grid[0].length; j++){\\n                grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321325,
                "title": "java-two-solutions-memorization-and-dp",
                "content": "1. Recursion with memorization\\n```java\\n    public int minPathSum(int[][] grid) {\\n        // boundary check\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        for (int[] r : cache) Arrays.fill(r, -1);\\n        \\n        // fill cache\\n        cache[0][0] = grid[0][0];\\n        dfs(row - 1, col - 1, grid, cache);\\n\\t\\t\\n\\t\\t// return result\\n        return cache[row - 1][col - 1];\\n    }\\n    \\n    public int dfs(int m, int n, int[][] grid, int[][] cache) {\\n        // reach to edge row or col, just return the max int to get row or col value\\n        if (m < 0 || n < 0) return Integer.MAX_VALUE; \\n\\t\\t// return grid[0][0]\\n        if (m == 0 && n == 0) return grid[m][n]; \\n\\t\\t// recursively compute min value if it\\'s not recorded in cache\\n        if (cache[m][n] == -1) \\n            cache[m][n] = grid[m][n] + Math.min(dfs(m - 1, n, grid, cache), dfs(m, n - 1, grid, cache));\\n        return cache[m][n];\\n    }\\n```\\n\\n2. DP\\n```java\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        cache[0][0] = grid[0][0];\\n\\n        // fill first row\\n        for (int i = 1; i < col; i++) {\\n            cache[0][i] = cache[0][i - 1] + grid[0][i];\\n        }\\n\\n        // fill first col\\n        for (int i = 1; i < row; i++) {\\n            cache[i][0] = cache[i - 1][0] + grid[i][0];\\n        }\\n\\n        // fill intermediate grid\\n        for(int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                cache[i][j] = grid[i][j] + Math.min(cache[i - 1][j], cache[i][j - 1]);\\n            }\\n        }\\n        return cache[row - 1][col - 1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minPathSum(int[][] grid) {\\n        // boundary check\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        for (int[] r : cache) Arrays.fill(r, -1);\\n        \\n        // fill cache\\n        cache[0][0] = grid[0][0];\\n        dfs(row - 1, col - 1, grid, cache);\\n\\t\\t\\n\\t\\t// return result\\n        return cache[row - 1][col - 1];\\n    }\\n    \\n    public int dfs(int m, int n, int[][] grid, int[][] cache) {\\n        // reach to edge row or col, just return the max int to get row or col value\\n        if (m < 0 || n < 0) return Integer.MAX_VALUE; \\n\\t\\t// return grid[0][0]\\n        if (m == 0 && n == 0) return grid[m][n]; \\n\\t\\t// recursively compute min value if it\\'s not recorded in cache\\n        if (cache[m][n] == -1) \\n            cache[m][n] = grid[m][n] + Math.min(dfs(m - 1, n, grid, cache), dfs(m, n - 1, grid, cache));\\n        return cache[m][n];\\n    }\\n```\n```java\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        cache[0][0] = grid[0][0];\\n\\n        // fill first row\\n        for (int i = 1; i < col; i++) {\\n            cache[0][i] = cache[0][i - 1] + grid[0][i];\\n        }\\n\\n        // fill first col\\n        for (int i = 1; i < row; i++) {\\n            cache[i][0] = cache[i - 1][0] + grid[i][0];\\n        }\\n\\n        // fill intermediate grid\\n        for(int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                cache[i][j] = grid[i][j] + Math.min(cache[i - 1][j], cache[i][j - 1]);\\n            }\\n        }\\n        return cache[row - 1][col - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 185358,
                "title": "easy-recursive-solution-with-memo-java",
                "content": "```\\n    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < memo.length; i++){\\n            Arrays.fill(memo[i],Integer.MAX_VALUE);\\n        }\\n        return dfs(grid,0,0,memo);\\n\\n    }\\n    \\n    private int dfs(int[][] grid,int i, int j, int[][] memo){\\n        if( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length )\\n            return Integer.MAX_VALUE;\\n        else if(memo[i][j] != Integer.MAX_VALUE)\\n            return memo[i][j];\\n        else if(i == grid.length - 1  && j == grid[0].length -1)\\n            return grid[i][j];\\n         else \\n            memo[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j,memo),dfs(grid, i, j + 1,memo));\\n        \\n        return memo[i][j];\\n        \\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < memo.length; i++){\\n            Arrays.fill(memo[i],Integer.MAX_VALUE);\\n        }\\n        return dfs(grid,0,0,memo);\\n\\n    }\\n    \\n    private int dfs(int[][] grid,int i, int j, int[][] memo){\\n        if( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length )\\n            return Integer.MAX_VALUE;\\n        else if(memo[i][j] != Integer.MAX_VALUE)\\n            return memo[i][j];\\n        else if(i == grid.length - 1  && j == grid[0].length -1)\\n            return grid[i][j];\\n         else \\n            memo[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j,memo),dfs(grid, i, j + 1,memo));\\n        \\n        return memo[i][j];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23600,
                "title": "share-my-java-solution",
                "content": "    public int minPathSum(int[][] grid) {\\n        if(grid==null||grid.length<1)\\n            return 0;\\n            \\n        int[][] minsum = new int[grid.length][grid[0].length];\\n        //initialize\\n        minsum[0][0] = grid[0][0];\\n        \\n        for(int j=1;j<minsum[0].length;j++){\\n            minsum[0][j] = minsum[0][j-1]+grid[0][j];\\n        }\\n        \\n        for(int i=1;i<minsum.length;i++){\\n            minsum[i][0] = minsum[i-1][0] + grid[i][0];\\n        }\\n        // calculate sum along the path\\n        for(int i = 1;i<minsum.length;i++){\\n            for(int j = 1;j<minsum[0].length;j++){\\n                minsum[i][j] = Math.min(minsum[i-1][j], minsum[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return minsum[minsum.length-1][minsum[0].length-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int minPathSum(int[][] grid) {\\n        if(grid==null||grid.length<1)\\n            return 0;\\n            \\n        int[][] minsum = new int[grid.length][grid[0].length];\\n        //initialize\\n        minsum[0][0] = grid[0][0];\\n        \\n        for(int j=1;j<minsum[0].length;j++){\\n            minsum[0][j] = minsum[0][j-1]+grid[0][j];\\n        }\\n        \\n        for(int i=1;i<minsum.length;i++){\\n            minsum[i][0] = minsum[i-1][0] + grid[i][0];\\n        }\\n        // calculate sum along the path\\n        for(int i = 1;i<minsum.length;i++){\\n            for(int j = 1;j<minsum[0].length;j++){\\n                minsum[i][j] = Math.min(minsum[i-1][j], minsum[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return minsum[minsum.length-1][minsum[0].length-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23593,
                "title": "beats-100-with-o-n-space",
                "content": "    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> dp(n);\\n            \\n            dp[0] = grid[0][0];\\n            for (int j = 1; j < n; j++) {   // init\\n                dp[j] = dp[j-1] + grid[0][j];\\n            }\\n            \\n            for (int i = 1; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[j] = (j == 0 ? dp[j] : min(dp[j], dp[j-1])) + grid[i][j];\\n                }   \\n            }\\n            return dp[n-1];\\n        }\\n    };\\n\\n\\nIn usual provide O(mn) solution first, then try to optimize it. From dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j], you can see it only depends on previous row and current row value, we waste a lot space if use mn space. \\n\\ndp[i][j] is row i, column j; \\ndp[i][j-1] is row i, column j-1; \\ndp[i-1][j] is row i-1, column j;\\n\\nif we just use row to represent dp[i], then it should be \\n\\nrow[j] = min(row[j-1], row[j]) + grid[i][j]; \\n\\nwhy dp[i-1][j] is row[j], because before we set new value for row[j], it saves old value, which is dp[i-1][j].\\n\\nSo the new transition formula is:\\n\\nrow[j] = min(row[j-1], row[j]) + grid[i][j];\\n\\nstill use dp variable to replace row, it is:\\n\\ndp[j] = min(dp[j-1], dp[j]) + grid[i][j];\\n\\nvariable j is from 0 to n, same as before. But the i is not used in two dimension row number, just use iteration number. We need do m-1 iterations, because we don't need do it for first row, which is init value.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> dp(n);\\n            \\n            dp[0] = grid[0][0];\\n            for (int j = 1; j < n; j++) {   // init\\n                dp[j] = dp[j-1] + grid[0][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23679,
                "title": "python-recursive-solution-with-cache-114ms",
                "content": "    class Solution:\\n        # @param {integer[][]} grid\\n        # @return {integer}\\n        def minPathSum(self, grid):\\n            if not len(grid) or not len(grid[0]):\\n                return 0\\n    \\n            m, n, cache = len(grid) - 1, len(grid[0]) - 1, {}\\n    \\n            return self.findMinSum(grid, m, n, cache)\\n    \\n        def findMinSum(self, grid, m, n, cache):\\n            if (m, n) in cache:\\n                return cache[(m, n)]\\n            elif m < 0 or n < 0:\\n                return float('inf')\\n            elif m == 0 and n == 0:\\n                return grid[0][0]\\n            else:\\n                cache[(m, n)] = grid[m][n] + min(self.findMinSum(grid, m - 1, n, cache), self.findMinSum(grid, m, n - 1, cache))\\n    \\n                return cache[(m, n)]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 3988970,
                "title": "easy-dp-solution",
                "content": "\\n# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe minPathSum function initializes a 2D vector dp with dimensions n x m+1 and initializes all elements to -1. This dp array will be used to memoize the results of subproblems to avoid redundant calculations.\\n\\nIt calls the solve function with the given grid, the starting indices (n-1, m-1), and the dp array.\\n\\nThe solve function is a recursive function with memoization. It takes the current cell (i, j) in the grid and calculates the minimum path sum from the top-left corner to that cell.\\n\\nIf (i, j) is the top-left corner (i.e., i == 0 and j == 0), it returns the value in that cell because there\\'s only one path to reach that cell.\\n\\nIf (i, j) is out of bounds (i.e., i < 0 or j < 0), it returns a large value (1e9) to indicate that this path is not valid.\\n\\nIf the result for (i, j) is already calculated and stored in the dp array, it returns that result to avoid redundant computation.\\n\\nIf the result for (i, j) is not calculated, it recursively calculates the minimum path sum by considering two possible moves:\\n\\nMoving up (i.e., (i-1, j)) and adding the current cell\\'s value to it.\\nMoving left (i.e., (i, j-1)) and adding the current cell\\'s value to it.\\nIt stores the minimum of these two values in the dp array at position (i, j) and returns that minimum value.\\n\\nFinally, the minPathSum function returns the result obtained by calling solve with the bottom-right corner cell (n-1, m-1).\\n\\nThis approach effectively uses memoization to avoid redundant calculations and finds the minimum path sum efficiently. The result returned by minPathSum is the minimum sum required to reach the bottom-right corner of the grid while moving only right or down.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>>& grid ,int i,int j,vector<vector<int>>& dp)\\n{\\n    if(i==0 && j==0 )\\n    {\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0)\\n    {\\n        return 1e9;\\n    } \\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int up= grid[i][j]+solve(grid, i-1,j,dp);\\n    int left= grid[i][j]+solve(grid, i,j-1,dp);\\n    return dp[i][j] = min(up,left);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size(); \\n        vector<vector<int>>dp(n,vector<int>(m+1,-1));\\n        return solve(grid,n-1,m-1,dp);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>>& grid ,int i,int j,vector<vector<int>>& dp)\\n{\\n    if(i==0 && j==0 )\\n    {\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0)\\n    {\\n        return 1e9;\\n    } \\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int up= grid[i][j]+solve(grid, i-1,j,dp);\\n    int left= grid[i][j]+solve(grid, i,j-1,dp);\\n    return dp[i][j] = min(up,left);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size(); \\n        vector<vector<int>>dp(n,vector<int>(m+1,-1));\\n        return solve(grid,n-1,m-1,dp);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775468,
                "title": "4-steps-of-optimization-naive-recursion-optimization-dp",
                "content": "# 1. Naive Recursive approach (TLE)\\n- **Time complexity: O(mn)**\\n In the worst case, the recursive calls will visit all cells in the grid except the first cell (grid[0][0]). Therefore, the total number of function calls will be (m-1) * (n-1). Each function call performs constant time operations, so the time complexity is O(mn).\\n- **Space complexity: O(m + n)**\\nIn the worst case, the recursive calls will visit all cells in the grid except the first cell (grid[0][0]). Therefore, the maximum depth of recursion will be m + n - 2. Since each recursive call requires constant space, the space complexity is O(m + n).\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1);\\n        int up=f(grid, row-1, col);\\n        return res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        return f(grid, m, n);\\n    }\\n};\\n\\n```\\n# 2. Memoization(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1, dp);\\n        int up=f(grid, row-1, col, dp);\\n        return dp[row][col] = res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(grid, m, n, dp);\\n    }\\n};\\n\\n```\\n\\n# 3. Tabulation(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 40001));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1){\\n                    dp[1][1]=grid[0][0];\\n                }\\n                else dp[i][j]=grid[i-1][j-1] + min(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n\\n```\\n\\n# 4. Optimized Space (Best Code)\\n- Time complexity: O(m*n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>dp(n+1, 40001);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1) dp[1]=grid[0][0];\\n                else dp[j]=grid[i-1][j-1] + min(dp[j-1], dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1);\\n        int up=f(grid, row-1, col);\\n        return res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        return f(grid, m, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1, dp);\\n        int up=f(grid, row-1, col, dp);\\n        return dp[row][col] = res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(grid, m, n, dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 40001));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1){\\n                    dp[1][1]=grid[0][0];\\n                }\\n                else dp[i][j]=grid[i-1][j-1] + min(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>dp(n+1, 40001);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1) dp[1]=grid[0][0];\\n                else dp[j]=grid[i-1][j-1] + min(dp[j-1], dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704034,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(i==n-1 && j==m-1){\\n        return grid[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int r=INT_MAX;\\n    int d=INT_MAX;\\n    if(i+1<n ){\\n        d=solve(i+1,j,grid,dp);\\n    }\\n    if(j+1<m) r=solve(i,j+1,grid,dp);\\n   \\n    return dp[i][j]=grid[i][j]+min(r,d);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n    int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(i==n-1 && j==m-1){\\n        return grid[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int r=INT_MAX;\\n    int d=INT_MAX;\\n    if(i+1<n ){\\n        d=solve(i+1,j,grid,dp);\\n    }\\n    if(j+1<m) r=solve(i,j+1,grid,dp);\\n   \\n    return dp[i][j]=grid[i][j]+min(r,d);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n    int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349044,
                "title": "java-memoized-dfs-and-dp-beats-99",
                "content": "# Approach 1: DFS\\nIn DFS we need to traverse all possibilities up to [m-1][n-1] and then compute the minimal path on our way from bottom up.\\nThere will be a lot of duplicated computations, so we need to memoize our dfs at i,j.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] memo;\\n    private int[][] grid;\\n    private int m = 0;\\n    private int n = 0;\\n\\n    public int minPathSum(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new int[m][n];\\n        this.grid = grid;\\n        for (int[] row: memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int i, int j) {\\n        if (i == m || j == n) return Integer.MAX_VALUE;\\n        if (i == m-1 && j == n-1) return grid[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        memo[i][j] = grid[i][j] + Math.min(\\n            dfs(i+1, j),\\n            dfs(i, j+1)\\n        );\\n        return memo[i][j];\\n    }\\n}\\n```\\n\\n# Approach 2: Dynamic programming\\nThis is a little more complicated and less straightforward as memoized DFS. We need to somehow tell what is the optimal previous path for index i,j. That means we need to memoize the best paths up to [i-1][j] and [i][j-1].\\n\\nThis means that our loop at i,j must do the following:\\n1. get previous at [i-1][j] or Infinity if it doesnt exist\\n2. get previous at [i][j-1] or Infinity\\n3. get minimum of these values (spec case is if they are both infinity, then we need to make them zero, because there is no previous path)\\n4. minPrev + grid[i][j] is our optimal value at i,j\\n5. the minimum in [m-1][n-1] is our answer\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] memo = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? memo[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? memo[i][j-1] : Integer.MAX_VALUE\\n                );\\n                memo[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return memo[m-1][n-1];\\n    }\\n}\\n```\\nBonus:\\nIf we are allowed to modify the input, we can solve it in O(1) space\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? grid[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? grid[i][j-1] : Integer.MAX_VALUE\\n                );\\n                grid[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n\\n---\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] memo;\\n    private int[][] grid;\\n    private int m = 0;\\n    private int n = 0;\\n\\n    public int minPathSum(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new int[m][n];\\n        this.grid = grid;\\n        for (int[] row: memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int i, int j) {\\n        if (i == m || j == n) return Integer.MAX_VALUE;\\n        if (i == m-1 && j == n-1) return grid[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        memo[i][j] = grid[i][j] + Math.min(\\n            dfs(i+1, j),\\n            dfs(i, j+1)\\n        );\\n        return memo[i][j];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] memo = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? memo[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? memo[i][j-1] : Integer.MAX_VALUE\\n                );\\n                memo[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return memo[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? grid[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? grid[i][j-1] : Integer.MAX_VALUE\\n                );\\n                grid[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347990,
                "title": "easy-solution-in-js-beat-91-just-loop-through-grid",
                "content": "Please UPVOTE!!!!\\n```\\nvar minPathSum = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    for(let i=0;i<row;i++) {\\n        for(let j=0;j<col;j++) {\\n            if(i == 0 && j== 0) {\\n                continue\\n            } else if( i== 0) {\\n                grid[i][j] += grid[i][j-1]\\n            } else if ( j== 0) {\\n                grid[i][j] += grid[i-1][j]\\n            } else {\\n                grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1])\\n            }\\n        }\\n    }\\n    return grid[row-1][col-1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathSum = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    for(let i=0;i<row;i++) {\\n        for(let j=0;j<col;j++) {\\n            if(i == 0 && j== 0) {\\n                continue\\n            } else if( i== 0) {\\n                grid[i][j] += grid[i][j-1]\\n            } else if ( j== 0) {\\n                grid[i][j] += grid[i-1][j]\\n            } else {\\n                grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1])\\n            }\\n        }\\n    }\\n    return grid[row-1][col-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347067,
                "title": "easy-solutions-with-explanation-in-java-dp",
                "content": "# Intuition\\nTo find minimum path sum we need result of our previous choices that we took, so this gives us intution of storing previous data and hence we choose DP\\nConsidering testcase 1\\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\\nOutput: 7\\n\\n# Approach\\n***Beginner -> Space O(n^2)***\\n\\n1) Begin by taking same size 2D and fill the first element from grid[0][0] to our new matrix dp[][];\\n2) Prefill first row and first column, because \\n\\n- ROW\\nWe can reach row 0 elements from only side i.e grid[0][0] will contribute to grid[0][1]  and so on\\nintially grid : 1 --> 3 ---> 1\\nso first row will look like \\nafter operation dp: 1 --> 4 --> 5\\n\\n- COL\\nWe can reach row 0 elements only from top as left indexes are out of bound\\ngrid --after operation-->  dp\\n1  ---->  1\\n5  ---->  6\\n1  ---->  7\\n\\n3) Now for any other element will is not part of corner case, we can reach from top or from same row left side so \\ndp[i][j] = Math.min(element from top, element from side) + current value\\ndp[i][j] = Math.min(dp[i][j-1], dp[i-1][j])\\n\\nand we return the last element of dp[n][n] which is the answer\\n\\n---\\n\\n\\n*Space O(n)*\\nWe can also solve the problem by using a 1D array, the array will always store the upper row values ( i.e the values that we fetch via dp[i-1][j]).\\nSo initially we will prefill it with 1 row same as in 2nd step row part.\\n\\nMin path of any element is\\ndp[j] = elements values will be added + min of ( top, side)\\n- top row data is already in the dp array and side we can calculate via dp[j-1]\\ndp[j]=  grid[i][j] +Math.min(dp[j], dp[j-1])+\\n\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) Since we visit all element of the matrix.\\n\\n# Code Space O(n^2)\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if(grid==null || grid.length==0 )\\n            return 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        /* prefilling the first row and first column */\\n        for(int i=1;i<col;i++)\\n            grid[0][i]+=grid[0][i-1];\\n        \\n        for(int i=1;i<row;i++)\\n            grid[i][0]+=grid[i-1][0];\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                grid[i][j]+=Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n```\\n\\n# Code Space O(n)\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row= grid.length;\\n        int col= grid[0].length;\\n        int [] dp = new int[col];\\n        \\n        dp[0]= grid[0][0];\\n        \\n        for(int i=1; i<col;i++)\\n            dp[i]=dp[i-1] + grid[0][i];\\n        \\n        for(int i=1; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(j>0){\\n                    dp[j]=Math.min(dp[j], dp[j-1])+ grid[i][j];\\n                }else{\\n                    dp[j]+=grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[col-1];\\n        \\n    }\\n}\\n```\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/839efe73-c747-4529-80da-c693220bcf93_1679908593.3237262.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if(grid==null || grid.length==0 )\\n            return 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        /* prefilling the first row and first column */\\n        for(int i=1;i<col;i++)\\n            grid[0][i]+=grid[0][i-1];\\n        \\n        for(int i=1;i<row;i++)\\n            grid[i][0]+=grid[i-1][0];\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                grid[i][j]+=Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row= grid.length;\\n        int col= grid[0].length;\\n        int [] dp = new int[col];\\n        \\n        dp[0]= grid[0][0];\\n        \\n        for(int i=1; i<col;i++)\\n            dp[i]=dp[i-1] + grid[0][i];\\n        \\n        for(int i=1; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(j>0){\\n                    dp[j]=Math.min(dp[j], dp[j-1])+ grid[i][j];\\n                }else{\\n                    dp[j]+=grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[col-1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347028,
                "title": "minimum-pathsum-recursion-memoisation-tabulation-space-optimized-in-o-m-instead-of-o-n-m",
                "content": "# Intuition\\nJust go from bottom right corner to top left and check the minimum cost to reach the top left of the grid.\\nfun(i,j):\\n    if(i<0 || j<0) return INT_MAX;  (returning int_max is preferrable for finding the minimum)\\n    if(i==0 && j==0) return grid[i][j];\\n    return grid[i][j]+min(fun(i-1,j),fun(i,j-1));\\n\\n\\n# Code\\nBasic recursion code which will give TLE\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid){\\n            //just do a normal index shift which willl be useful during tabulation if you want to  do from this intuition\\n\\n            if(i==0 ||j==0) return INT_MAX;\\n\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid);\\n            int lef=fun(i,j-1,grid);\\n\\n                //here returning that grid cost +min(getfrom left recursuon ,getfrom up recursioj)\\n            return grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\n        return fun(n,m,grid);\\n    }\\n};\\n```\\nMemosiation\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n        return fun(n,m,grid,dp);\\n    }\\n};\\n```\\nTabulation which reduce our axuliary space complexity\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                if(i==0 && j==0){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int up=grid[i][j];\\n        //just handling arror of indexing / runtime error\\n                   if(i>0) up+=dp[i-1][j];\\n                   else{\\n                       up+=1e5;\\n                   }\\n                   int lef=grid[i][j];\\n                   if(j>0) lef+=dp[i][j-1];\\n                   else{\\n                       lef+=1e5;\\n                   }\\n                   dp[i][j]=min(up,lef);\\n                }\\n                 \\n            }\\n        }\\n\\n        // return fun(n,m,grid,dp);\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\nTablulation space optimized O(n)\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // vector<vector<int>> dp(n,vector<int>(m,0));\\n     vector<int> prev(m, 0), cur(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) cur[j] = grid[i][j];\\n                else {\\n                    int up = i >= 1 ? grid[i][j] + prev[j] : INT_MAX;\\n                    int left = j >= 1 ? grid[i][j] + cur[j - 1] : INT_MAX;\\n                    cur[j] = min(up, left);\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[m - 1];\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid){\\n            //just do a normal index shift which willl be useful during tabulation if you want to  do from this intuition\\n\\n            if(i==0 ||j==0) return INT_MAX;\\n\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid);\\n            int lef=fun(i,j-1,grid);\\n\\n                //here returning that grid cost +min(getfrom left recursuon ,getfrom up recursioj)\\n            return grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\n        return fun(n,m,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n        return fun(n,m,grid,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                if(i==0 && j==0){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int up=grid[i][j];\\n        //just handling arror of indexing / runtime error\\n                   if(i>0) up+=dp[i-1][j];\\n                   else{\\n                       up+=1e5;\\n                   }\\n                   int lef=grid[i][j];\\n                   if(j>0) lef+=dp[i][j-1];\\n                   else{\\n                       lef+=1e5;\\n                   }\\n                   dp[i][j]=min(up,lef);\\n                }\\n                 \\n            }\\n        }\\n\\n        // return fun(n,m,grid,dp);\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // vector<vector<int>> dp(n,vector<int>(m,0));\\n     vector<int> prev(m, 0), cur(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) cur[j] = grid[i][j];\\n                else {\\n                    int up = i >= 1 ? grid[i][j] + prev[j] : INT_MAX;\\n                    int left = j >= 1 ? grid[i][j] + cur[j - 1] : INT_MAX;\\n                    cur[j] = min(up, left);\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332681,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^S)$$ --> S = m * n\\n\\n- Space complexity:\\n$$O(m + n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return INT_MAX;\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        return min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return solve(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return 1e9;\\n        if (dp[row][col] != -1)\\n            return dp[row][col];    \\n        int left = grid[row][col] + solve(row, col-1, grid, dp);\\n        int up = grid[row][col] + solve(row-1, col, grid, dp);\\n        return dp[row][col] = min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, grid, dp);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += dp[i][j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += dp[i-1][j];\\n                else\\n                    up += 1e9;    \\n                dp[i][j] = min (left, up);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    cur[j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += cur[j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += prev[j];\\n                else\\n                    up += 1e9;    \\n                cur[j] = min (left, up);\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return INT_MAX;\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        return min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return solve(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return 1e9;\\n        if (dp[row][col] != -1)\\n            return dp[row][col];    \\n        int left = grid[row][col] + solve(row, col-1, grid, dp);\\n        int up = grid[row][col] + solve(row-1, col, grid, dp);\\n        return dp[row][col] = min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += dp[i][j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += dp[i-1][j];\\n                else\\n                    up += 1e9;    \\n                dp[i][j] = min (left, up);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    cur[j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += cur[j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += prev[j];\\n                else\\n                    up += 1e9;    \\n                cur[j] = min (left, up);\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974540,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DP\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dp[n][m];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1; i<m; i++) dp[0][i] = dp[0][i-1] + grid[0][i];\\n        for(int i=1; i<n; i++) dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=1; j<m; j++) {\\n                dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dp[n][m];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1; i<m; i++) dp[0][i] = dp[0][i-1] + grid[0][i];\\n        for(int i=1; i<n; i++) dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=1; j<m; j++) {\\n                dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937659,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if(m==0 && n==0)\\n            return dp[m][n];\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        if(m==0 && n!=0)\\n            return dp[m][n] = grid[m][n]+solve(grid, m, n-1, dp);\\n        \\n        if(n==0 && m!=0)\\n            return dp[m][n] =grid[m][n]+solve(grid, m-1, n, dp);\\n        \\n        else\\n            return dp[m][n] =grid[m][n] + min(solve(grid, m-1, n, dp), solve(grid, m, n-1, dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j!=0)\\n                    grid[i][j]+=grid[i][j-1];\\n                else if(j==0 && i!=0)\\n                    grid[i][j]+=grid[i-1][j];\\n                else if(i && j)\\n                    grid[i][j]+=min(grid[i][j-1], grid[i-1][j]);\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if(m==0 && n==0)\\n            return dp[m][n];\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        if(m==0 && n!=0)\\n            return dp[m][n] = grid[m][n]+solve(grid, m, n-1, dp);\\n        \\n        if(n==0 && m!=0)\\n            return dp[m][n] =grid[m][n]+solve(grid, m-1, n, dp);\\n        \\n        else\\n            return dp[m][n] =grid[m][n] + min(solve(grid, m-1, n, dp), solve(grid, m, n-1, dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j!=0)\\n                    grid[i][j]+=grid[i][j-1];\\n                else if(j==0 && i!=0)\\n                    grid[i][j]+=grid[i-1][j];\\n                else if(i && j)\\n                    grid[i][j]+=min(grid[i][j-1], grid[i-1][j]);\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1771810,
                "title": "python-dp-solution-easy-and-simple",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Approach:\\n        1. Compute the sum to reach untill each element in first column\\n        2. Compute the sum to reach untill each element in first row\\n        3. Then traverse from index 1,1 to untill end and only take the minimum path at each location \\n        \\n        Minimum path comes from either from previous element(previous row and column).\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0]) \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, n):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Approach:\\n        1. Compute the sum to reach untill each element in first column\\n        2. Compute the sum to reach untill each element in first row\\n        3. Then traverse from index 1,1 to untill end and only take the minimum path at each location \\n        \\n        Minimum path comes from either from previous element(previous row and column).\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0]) \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, n):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643189,
                "title": "c-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                if(i == n-1 && j == m-1) // bottom right element\\n                    dp[i][j] = grid[i][j];\\n                else if(i == n-1)        // In last row we can\\'t go downwards\\n                    dp[i][j] = dp[i][j+1] + grid[i][j];\\n                else if(j == m-1)        // In last column we can\\'t go rightwards\\n                    dp[i][j] = dp[i+1][j] + grid[i][j];\\n                else\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                if(i == n-1 && j == m-1) // bottom right element\\n                    dp[i][j] = grid[i][j];\\n                else if(i == n-1)        // In last row we can\\'t go downwards\\n                    dp[i][j] = dp[i][j+1] + grid[i][j];\\n                else if(j == m-1)        // In last column we can\\'t go rightwards\\n                    dp[i][j] = dp[i+1][j] + grid[i][j];\\n                else\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496137,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # square becomes minimum of the thing above it or to the left of it\\n        # plus its own value\\n        \\n        \\n        # bfs right then down\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return grid[0][0]\\n        \\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0,0))\\n        \\n        while(q):\\n            row, col = q.popleft()\\n            if (row, col) in visited:\\n                continue\\n            if row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0]):\\n                q.append((row, col+1))\\n                q.append((row+1, col))\\n                visited.add((row,col))\\n                if row == 0 and col == 0:\\n                    continue\\n                elif row == 0 and col > 0:\\n                    grid[row][col] += grid[row][col-1]\\n                elif col == 0:\\n                    grid[row][col] += grid[row-1][col]\\n                else:\\n                    grid[row][col] += min(grid[row-1][col], grid[row][col-1])\\n       \\n            \\n        return grid[-1][-1]\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # square becomes minimum of the thing above it or to the left of it\\n        # plus its own value\\n        \\n        \\n        # bfs right then down\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return grid[0][0]\\n        \\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0,0))\\n        \\n        while(q):\\n            row, col = q.popleft()\\n            if (row, col) in visited:\\n                continue\\n            if row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0]):\\n                q.append((row, col+1))\\n                q.append((row+1, col))\\n                visited.add((row,col))\\n                if row == 0 and col == 0:\\n                    continue\\n                elif row == 0 and col > 0:\\n                    grid[row][col] += grid[row][col-1]\\n                elif col == 0:\\n                    grid[row][col] += grid[row-1][col]\\n                else:\\n                    grid[row][col] += min(grid[row-1][col], grid[row][col-1])\\n       \\n            \\n        return grid[-1][-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1476146,
                "title": "generalized-way-of-using-recursion-on-matrix-solution-for-this-problem-recursive-and-top-down",
                "content": "**WHAT IS RECURSION?**\\n=> just a lazy guy who will take help from others  to get the work done.{calling same function on smaller inputs eventually reaching base case where we will get our answer}\\n\\n**RECURSON IN MATRIX**\\n1) In a matrix we have to figure out the way to traverse, if I am at (0,0) and i have to go down then(1,0), up(-1,0),   right(0, 1) and left(0, -1). Generalizing this from (i, j) -> down(i+1, j), up(i-1, j), left(i, j-1), right(i, j+1).\\n2) While traversing we have to take care that we are inside out matrix, generalizing this if we go below 0 we are going out from two sides(left and top), if we go above n, m (considering n x m matrix) then we are going outside from other two sides.\\n3) At last we have to figure out the logic according to the question through which we will calculate the output.\\n\\n\\n**RECURSIVE SOLUTION (will result in TLE):**\\n```\\nclass Solution {\\nprivate:\\n    int recursion(int i, int j, int n, int m, vector<vector<int>> &grid){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.(conditions for returning will change according to question)\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        int down = recursion(i+1, j, n, m, grid); // value which i will get when i go down\\n        int right = recursion(i, j+1, n, m, grid);// value which i will get when i go right\\n        \\n        return grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell.\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        return recursion(0, 0, row, col, grid); // at index (0, 0) we will have the total min cost to reach end from (0,0).\\n    }\\n};\\n```\\n\\n**TOP-DOWN DP(AC):**\\n```\\nclass Solution {\\nprivate:\\n    int topDown(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]; // if not -1 then the value is already computed no need to calculate again\\n        \\n        int down = topDown(i+1, j, n, m, grid, dp); // value which function will return when we go down\\n        int right = topDown(i, j+1, n, m, grid, dp);// value which function will get when return we go right\\n        \\n        return dp[i][j] = grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell and store it in dp matrix\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, -1)); // declaring 2d matrix initialized as -1 to store values\\n        return topDown(0, 0, row, col, grid, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int recursion(int i, int j, int n, int m, vector<vector<int>> &grid){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.(conditions for returning will change according to question)\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        int down = recursion(i+1, j, n, m, grid); // value which i will get when i go down\\n        int right = recursion(i, j+1, n, m, grid);// value which i will get when i go right\\n        \\n        return grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell.\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        return recursion(0, 0, row, col, grid); // at index (0, 0) we will have the total min cost to reach end from (0,0).\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int topDown(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]; // if not -1 then the value is already computed no need to calculate again\\n        \\n        int down = topDown(i+1, j, n, m, grid, dp); // value which function will return when we go down\\n        int right = topDown(i, j+1, n, m, grid, dp);// value which function will get when return we go right\\n        \\n        return dp[i][j] = grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell and store it in dp matrix\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, -1)); // declaring 2d matrix initialized as -1 to store values\\n        return topDown(0, 0, row, col, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450433,
                "title": "1-ms-faster-than-99-of-java-online-submissions-for-minimum-path-sum",
                "content": "// It is much similar problem to Unique paths problem.\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n       \\n        \\n        for(int i=1;i<grid[0].length;i++){\\n            \\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int j=1;j<grid.length;j++){\\n            \\n            grid[j][0]+=grid[j-1][0];\\n        }\\n        for(int i=1;i<grid.length;i++){\\n            for(int j=1;j<grid[0].length;j++){\\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n       \\n        \\n        for(int i=1;i<grid[0].length;i++){\\n            \\n            grid[0][i]+=grid[0][i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1266207,
                "title": "top-down-recursion-memoization-c-beginners",
                "content": "Simplest top down approach\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    int rec(vector<vector<int> > &A,int i,int j)\\n    {\\n        int m=A.size(),n=A[0].size();\\n\\n        if(i>=m or j>=n) return INT_MAX;\\n        if(i==m-1 and j==n-1) return A[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        return dp[i][j]=min(rec(A,i+1,j),rec(A,i,j+1))+A[i][j];\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    int rec(vector<vector<int> > &A,int i,int j)\\n    {\\n        int m=A.size(),n=A[0].size();\\n\\n        if(i>=m or j>=n) return INT_MAX;\\n        if(i==m-1 and j==n-1) return A[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        return dp[i][j]=min(rec(A,i+1,j),rec(A,i,j+1))+A[i][j];\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585513,
                "title": "python-bottom-up-dynamic-programming",
                "content": "You only have two choices when determining the the minimum for a particular cell. Either you take the value above you or the value left from you. Choose the the minimum between them and add the value from the cell you\\'re currently on. Keep doing that untill you make it to the end of the grid.\\n\\n```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for j in range(1, len(grid[0])):\\n            grid[0][j] += grid[0][j-1]\\n        \\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n                \\n        return grid[-1][-1]\\n```\\n\\n**Time:** `O(m*n)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for j in range(1, len(grid[0])):\\n            grid[0][j] += grid[0][j-1]\\n        \\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n                \\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585035,
                "title": "java-linear-time-constant-space-easy-to-understand-dp-solution",
                "content": "```\\npublic int minPathSum(int[][] grid) {\\n        int xlen = grid.length;\\n        if(xlen == 0) return 0;\\n        int ylen = grid[0].length;\\n        //using grid as dp grid\\n        for(int i=1;i<xlen;i++) {\\n            grid[i][0]+=grid[i-1][0];\\n        }\\n        for(int i=1;i<ylen;i++) {\\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int i=1;i<xlen;i++){\\n            for(int j=1; j<ylen;j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[xlen-1][ylen-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minPathSum(int[][] grid) {\\n        int xlen = grid.length;\\n        if(xlen == 0) return 0;\\n        int ylen = grid[0].length;\\n        //using grid as dp grid\\n        for(int i=1;i<xlen;i++) {\\n            grid[i][0]+=grid[i-1][0];\\n        }\\n        for(int i=1;i<ylen;i++) {\\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int i=1;i<xlen;i++){\\n            for(int j=1; j<ylen;j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[xlen-1][ylen-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482511,
                "title": "dijkstra-s-algorithm-with-python-3-pictures",
                "content": "\\nPracticing on problems in which people have tagged with Dijkstra\\'s algorithm.\\n\\nSteps\\n* Convert to graph\\n* inf on unseen nodes\\n* start 0,0\\n* Loop\\n\\t* relax node\\n\\t* add cost to seen edge\\n\\t* mark node as visit\\n\\t* find min value cost on seen but not visited nodes\\n* Return value end  n, n\\n\\nThings I found\\n* Building graphs is expensive\\n* Didn\\'t see much improvement using a heap but could be smaller test sets.\\n* There\\'s still a lot I don\\'t know about Python.  First time using heaps and multi-key defaultdict\\n* Amazon youtube instructors like Abdul Bari https://youtu.be/XB4MIexjvY0\\n\\nVisual walk through \\n1.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222011.png)\\n2.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222457.png)\\n3.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222525.png)\\n4.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222551.png)\\n5.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222573.png)\\n6.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222609.png)\\n7.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222625.png)\\n8.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222657.png)\\n9.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222691.png)\\n10. ![image](https://assets.leetcode.com/users/dentedghost/image_1579222744.png)\\n11. ![image](https://assets.leetcode.com/users/dentedghost/image_1579222763.png)\\n\\nCode:\\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row =  len(grid)\\n        column = len(grid[0])\\n        \\n        # Craft graphs\\n        heap = []\\n        sum = defaultdict(list)\\n        cost = defaultdict(list)\\n        graph = defaultdict(list)\\n        seen = defaultdict(list)\\n        for r in range (0, row):\\n            for c in range (0, column):\\n                sum[r,c] = float(\\'inf\\')\\n                cost[r,c].append(grid[r][c])\\n                # check right\\n                if c < column - 1:\\n                    graph[r,c].append([r,c+1])\\n                # check down\\n                if r < row - 1:\\n                    graph[r,c].append([r+1,c])\\n  \\n        # Setup for start and end\\n        min_node = (0,0)\\n        end_node = ((row-1),(column-1))   \\n        sum[(min_node)] = cost.get(min_node)[0]\\n        seen[(min_node)] = True\\n        \\n        while len(seen) > 0:\\n            # check attached nodes\\n            if graph.get(min_node):\\n                # Visit next mini-value node and relax it\\'s edge\\n                for node in graph.get(min_node):\\n                    n = tuple(node)\\n                    visit_cost = cost.get(n)[0] + (sum.get(min_node))\\n                    # Check if relaxing has reduced the cost\\n                    if visit_cost < sum.get(n):\\n                        # Update the cost for each updated node\\n                        sum[(n)] = visit_cost\\n                        # Add to head future nodes to visit\\n                        heappush(heap, (visit_cost, n))\\n                        seen[(n)] = True\\n\\n            seen.pop(min_node)\\n\\n            # Check Next Cost Optimized with a heap\\n            if len(heap) > 0:\\n                next_min_node = heappop(heap)[1]\\n                min_node = next_min_node\\n\\n        return sum.get(end_node)\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row =  len(grid)\\n        column = len(grid[0])\\n        \\n        # Craft graphs\\n        heap = []\\n        sum = defaultdict(list)\\n        cost = defaultdict(list)\\n        graph = defaultdict(list)\\n        seen = defaultdict(list)\\n        for r in range (0, row):\\n            for c in range (0, column):\\n                sum[r,c] = float(\\'inf\\')\\n                cost[r,c].append(grid[r][c])\\n                # check right\\n                if c < column - 1:\\n                    graph[r,c].append([r,c+1])\\n                # check down\\n                if r < row - 1:\\n                    graph[r,c].append([r+1,c])\\n  \\n        # Setup for start and end\\n        min_node = (0,0)\\n        end_node = ((row-1),(column-1))   \\n        sum[(min_node)] = cost.get(min_node)[0]\\n        seen[(min_node)] = True\\n        \\n        while len(seen) > 0:\\n            # check attached nodes\\n            if graph.get(min_node):\\n                # Visit next mini-value node and relax it\\'s edge\\n                for node in graph.get(min_node):\\n                    n = tuple(node)\\n                    visit_cost = cost.get(n)[0] + (sum.get(min_node))\\n                    # Check if relaxing has reduced the cost\\n                    if visit_cost < sum.get(n):\\n                        # Update the cost for each updated node\\n                        sum[(n)] = visit_cost\\n                        # Add to head future nodes to visit\\n                        heappush(heap, (visit_cost, n))\\n                        seen[(n)] = True\\n\\n            seen.pop(min_node)\\n\\n            # Check Next Cost Optimized with a heap\\n            if len(heap) > 0:\\n                next_min_node = heappop(heap)[1]\\n                min_node = next_min_node\\n\\n        return sum.get(end_node)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 352726,
                "title": "java-dp-inplace-with-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // corner case \\n        if(grid == null || m == 0 || grid[0] == null || n == 0) return Integer.MIN_VALUE;\\n        // initialization -> overwrite 1st row & 1st col\\n        for(int i = 1; i < m; i++){\\n            grid[i][0] = grid[i][0] + grid[i-1][0];\\n        }\\n        for(int j = 1; j < n; j++){\\n            grid[0][j] = grid[0][j] + grid[0][j-1];\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // corner case \\n        if(grid == null || m == 0 || grid[0] == null || n == 0) return Integer.MIN_VALUE;\\n        // initialization -> overwrite 1st row & 1st col\\n        for(int i = 1; i < m; i++){\\n            grid[i][0] = grid[i][0] + grid[i-1][0];\\n        }\\n        for(int j = 1; j < n; j++){\\n            grid[0][j] = grid[0][j] + grid[0][j-1];\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267314,
                "title": "c-96-100",
                "content": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for (var i = 0; i < grid.Length; i++)\\n        {\\n            for (var j = 0; j < grid[0].Length; j++)\\n            {\\n                if (i == 0 && j == 0) continue;\\n\\n                grid[i][j] += Math.Min( i > 0 ? grid[i - 1][j] : int.MaxValue, j > 0 ? grid[i][j - 1] : int.MaxValue);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for (var i = 0; i < grid.Length; i++)\\n        {\\n            for (var j = 0; j < grid[0].Length; j++)\\n            {\\n                if (i == 0 && j == 0) continue;\\n\\n                grid[i][j] += Math.Min( i > 0 ? grid[i - 1][j] : int.MaxValue, j > 0 ? grid[i][j - 1] : int.MaxValue);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200981,
                "title": "straight-forward-javascript-solution-beats-100",
                "content": "Very easy to understand. It is an Bottom-Up dynamic programming.\\n\\nTime Complexity: **O(n * m)**\\n\\n```javascript\\nvar minPathSum = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i === 0 && j === 0) {\\n                continue;\\n            } else if (i === 0) {\\n                grid[i][j] = grid[i][j] + grid[i][j - 1];\\n            } else if (j === 0) {\\n                grid[i][j] = grid[i][j] + grid[i - 1][j];\\n            } else {\\n                grid[i][j] =  grid[i][j] + Math.min(grid[i - 1][j],  grid[i][j - 1]);\\n            }\\n        }\\n    }\\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minPathSum = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i === 0 && j === 0) {\\n                continue;\\n            } else if (i === 0) {\\n                grid[i][j] = grid[i][j] + grid[i][j - 1];\\n            } else if (j === 0) {\\n                grid[i][j] = grid[i][j] + grid[i - 1][j];\\n            } else {\\n                grid[i][j] =  grid[i][j] + Math.min(grid[i - 1][j],  grid[i][j - 1]);\\n            }\\n        }\\n    }\\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132703,
                "title": "dijkstra-s-shortest-path-algorithm",
                "content": "We can convert the given input to a DAG by number the vertices 0, 1, 2... and the edge weight to be the value at the sink node.\\nFor the sample input:\\n[\\n  [1,3,1],\\n  [1,5,1],\\n  [4,2,1]\\n]\\n\\nThe corresponding graph would be.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/charansingh/image_1526912419.png)\\n\\nNow our problem reduces to finding the shortest path from top-left vertex to the bottom-right vertex.\\n\\n```\\n vector<int> adj(vector<vector<int>>& grid, int i) {\\n      vector<int> res;\\n      int cols = grid[0].size();\\n      int rows = grid.size();\\n      int row = i / cols;\\n      int col = i % cols;\\n      if ( row < rows - 1)\\n         res.push_back(i + cols);\\n      if ( col < cols - 1)\\n         res.push_back(i + 1);\\n      return res;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       const unsigned int INF = 0x3f3f3f3f;\\n       int V = grid.size() * grid[0].size();\\n       // Create a vector for distances and initialize all distances as infinity\\n       vector<int> dist(V, INF);\\n       // Find shortest path from src(top-left vertex) to dst(bottom-right) vertex;\\n       int src = 0;\\n       dist[src] = 0;\\n       priority_queue<pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>>> pq;\\n       pq.push(make_pair(0, src));\\n       while (!pq.empty()) {\\n          int u = pq.top().second;\\n          pq.pop();\\n          // weight is nothing but the value of grid[row][col]\\n          for (int v : adj(grid, u)) {\\n            int weight = grid[v / grid[0].size()][v % grid[0].size()];\\n            if (dist[v] > dist[u] + weight) {\\n               dist[v] = dist[u] + weight;\\n               pq.push(make_pair(dist[v], v));\\n            }\\n          }\\n       }\\n\\t\\t\\t // Account for the value at [0][0]\\n       return dist[grid.size() * grid[0].size() - 1] + grid[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> adj(vector<vector<int>>& grid, int i) {\\n      vector<int> res;\\n      int cols = grid[0].size();\\n      int rows = grid.size();\\n      int row = i / cols;\\n      int col = i % cols;\\n      if ( row < rows - 1)\\n         res.push_back(i + cols);\\n      if ( col < cols - 1)\\n         res.push_back(i + 1);\\n      return res;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       const unsigned int INF = 0x3f3f3f3f;\\n       int V = grid.size() * grid[0].size();\\n       // Create a vector for distances and initialize all distances as infinity\\n       vector<int> dist(V, INF);\\n       // Find shortest path from src(top-left vertex) to dst(bottom-right) vertex;\\n       int src = 0;\\n       dist[src] = 0;\\n       priority_queue<pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>>> pq;\\n       pq.push(make_pair(0, src));\\n       while (!pq.empty()) {\\n          int u = pq.top().second;\\n          pq.pop();\\n          // weight is nothing but the value of grid[row][col]\\n          for (int v : adj(grid, u)) {\\n            int weight = grid[v / grid[0].size()][v % grid[0].size()];\\n            if (dist[v] > dist[u] + weight) {\\n               dist[v] = dist[u] + weight;\\n               pq.push(make_pair(dist[v], v));\\n            }\\n          }\\n       }\\n\\t\\t\\t // Account for the value at [0][0]\\n       return dist[grid.size() * grid[0].size() - 1] + grid[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23644,
                "title": "c-dp-solutions-o-m-n-and-o-n-space",
                "content": "       \\n    // O(m*n) space\\n    int minPathSum1(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp = grid;\\n        int row = dp.size(), col = dp[0].size();\\n        for (unsigned int i = 1; i < row; i++)\\n            dp[i][0] += dp[i-1][0];\\n        for (unsigned int j = 1; j < col;  j++) \\n            dp[0][j] += dp[0][j-1];\\n        for (unsigned int i = 1; i < row; i++) \\n            for (unsigned int j = 1; j < col; j++) \\n                dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        vector<int> dp = grid[0];\\n        for (unsigned int j = 1; j < col; j++)\\n            dp[j] += dp[j-1];\\n        for (unsigned int i = 1; i < row; i++) {\\n            dp[0] += grid[i][0];\\n            for (unsigned int j = 1; j < col; j++)\\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j]);\\n        }\\n        return dp[col-1];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "       \\n    // O(m*n) space\\n    int minPathSum1(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp = grid;\\n        int row = dp.size(), col = dp[0].size();\\n        for (unsigned int i = 1; i < row; i++)\\n            dp[i][0] += dp[i-1][0];\\n        for (unsigned int j = 1; j < col;  j++) \\n            dp[0][j] += dp[0][j-1];\\n        for (unsigned int i = 1; i < row; i++) \\n            for (unsigned int j = 1; j < col; j++) \\n                dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        vector<int> dp = grid[0];\\n        for (unsigned int j = 1; j < col; j++)\\n            dp[j] += dp[j-1];\\n        for (unsigned int i = 1; i < row; i++) {\\n            dp[0] += grid[i][0];\\n            for (unsigned int j = 1; j < col; j++)\\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j]);\\n        }\\n        return dp[col-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3693641,
                "title": "c-solution-dp-memorization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mini(int m, int n, vector<vector<int>> &arr, vector<vector<int>> &memo){\\n        if(m==0 && n==0){\\n            return arr[0][0];\\n        }\\n        if(m<0 || n<0) return 1e9;\\n\\n        if(memo[m][n]!= -1) return memo[m][n];\\n\\n        int up = arr[m][n] + mini( m-1, n,arr, memo);\\n        int left = arr[m][n] + mini(m, n-1, arr, memo);\\n        memo[m][n] = min(up,  left);\\n        return memo[m][n];\\n    }\\n  \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>( n, -1));\\n        return mini(m-1, n-1, grid, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mini(int m, int n, vector<vector<int>> &arr, vector<vector<int>> &memo){\\n        if(m==0 && n==0){\\n            return arr[0][0];\\n        }\\n        if(m<0 || n<0) return 1e9;\\n\\n        if(memo[m][n]!= -1) return memo[m][n];\\n\\n        int up = arr[m][n] + mini( m-1, n,arr, memo);\\n        int left = arr[m][n] + mini(m, n-1, arr, memo);\\n        memo[m][n] = min(up,  left);\\n        return memo[m][n];\\n    }\\n  \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>( n, -1));\\n        return mini(m-1, n-1, grid, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639702,
                "title": "ekdm-garda-simpul-solution-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive --> memoize\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive logic-> YOU ARE ON Nth row and Mth column \\n1. Assume recursion will give minimum sum till (row-1)th and (col-1)th position\\n2. Add current cell value to it.\\n3. Memoize \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                     O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                     O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&grid,int row,int col,vector<vector<int>>&dp){\\n       \\n        if(row==0 && col==0) return grid[row][col];\\n        if(row<0 || col<0) return 1e9;\\n         if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col]=grid[row][col]+min(solve(grid,row-1,col,dp),solve(grid,row,col-1,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==0) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(grid,n-1,m-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&grid,int row,int col,vector<vector<int>>&dp){\\n       \\n        if(row==0 && col==0) return grid[row][col];\\n        if(row<0 || col<0) return 1e9;\\n         if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col]=grid[row][col]+min(solve(grid,row-1,col,dp),solve(grid,row,col-1,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==0) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(grid,n-1,m-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354349,
                "title": "minimum-path-sum-dijikstra-python-3",
                "content": "If you had solved binary path in a maze, you\\'ll deduce its Intaution\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dis = [[inf] * len(grid[0]) for _ in range(len(grid))]\\n        dis[0][0] = grid[0][0]\\n        \\n        pq = [(grid[0][0], 0, 0)]\\n        directions = [[0,1],[1,0]]\\n        \\n        while pq :\\n            distance,row,col = heappop(pq)\\n            \\n            for dx,dy in directions :\\n                vis_row = row + dx\\n                vis_col = col + dy\\n                if vis_row < len(grid)   and vis_row >=0 and vis_col >= 0 and vis_col< len(grid[0])  :\\n                    if distance + grid[vis_row][vis_col] < dis[vis_row][vis_col] :\\n                        dis[vis_row][vis_col]  = distance + grid[vis_row][vis_col]\\n                        heappush(pq, (distance + grid[vis_row][vis_col],vis_row,vis_col))\\n                        \\n        return dis[-1][-1]\\n",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "If you had solved binary path in a maze, you\\'ll deduce its Intaution\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dis = [[inf] * len(grid[0]) for _ in range(len(grid))]\\n        dis[0][0] = grid[0][0]\\n        \\n        pq = [(grid[0][0], 0, 0)]\\n        directions = [[0,1],[1,0]]\\n        \\n        while pq :\\n            distance,row,col = heappop(pq)\\n            \\n            for dx,dy in directions :\\n                vis_row = row + dx\\n                vis_col = col + dy\\n                if vis_row < len(grid)   and vis_row >=0 and vis_col >= 0 and vis_col< len(grid[0])  :\\n                    if distance + grid[vis_row][vis_col] < dis[vis_row][vis_col] :\\n                        dis[vis_row][vis_col]  = distance + grid[vis_row][vis_col]\\n                        heappush(pq, (distance + grid[vis_row][vis_col],vis_row,vis_col))\\n                        \\n        return dis[-1][-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3352633,
                "title": "simple-solution-well-explained-c",
                "content": "# Intuition\\nThe very simple approach is to try all paths to reach the destination from source and find the minimum path. Here i started from destionation and found the ways to reach source. (We can not apply grredy here because the elements are not uniform).\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first approach that hit my brain is recursion, The question allowed to moves right and down, as i am moving backwards(dest. to source) so I\\'m alloweded left or up moves, so the idea is to explore all the paths and find that path which has minimum sum. \\nBase Condition of recursion-\\n1-> Suppose i reached (0,0), in this case I have to add the value present at this index.\\n2-> Suppose a path which takes me to an invalid index, so I did not reach to my destination, In that case I have to return something that this answer never considered in my answer, because we have to find minimum path sum here that\\'s why i returned a big integer.\\nAs I previously said I have two move left and up and they will be called recursively. At last minimum of them will be returned.\\n\\nSo the recursive solution gives TLE, then I opptimized it by using Memoization(saving recursive calls), it further reduced the time complexity but it increased the space complexity because we are using extra space(dp array).\\n\\nTabulation method is more optimized beacuse there is no recursion involved, and we saved the space taken by recursive calls in the programming stack.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Recursive solution(it will give TLE)\\n    int solve(vector<vector<int>>& grid, int i, int j){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );\\n        return min(left, up);\\n    }\\n    // MEMOIZATION\\n    int memo(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );  \\n        return dp[i][j] = min(left, up);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // int row= grid.size();\\n        // int col= grid[0].size();\\n        // // return solve(grid,row-1, col-1);\\n        // vector<vector<int>> dp(row,vector<int>(col,-1));\\n        // return memo(grid,row-1, col-1, dp);\\n\\n        // TABULATION\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<m ;j++){\\n                if(i==0 && j==0) dp[i][j]= grid[i][j];\\n                else{\\n                    int up= grid[i][j];\\n                    int left= grid[i][j];\\n                    if(i>0)\\n                        up += dp[i-1][j];\\n                    else up += 1e9;\\n                    if(j>0)\\n                        left += dp[i][j-1];\\n                    else left+=1e9;\\n                    dp[i][j]= min(up, left);\\n                }\\n            }    \\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive solution(it will give TLE)\\n    int solve(vector<vector<int>>& grid, int i, int j){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );\\n        return min(left, up);\\n    }\\n    // MEMOIZATION\\n    int memo(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );  \\n        return dp[i][j] = min(left, up);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // int row= grid.size();\\n        // int col= grid[0].size();\\n        // // return solve(grid,row-1, col-1);\\n        // vector<vector<int>> dp(row,vector<int>(col,-1));\\n        // return memo(grid,row-1, col-1, dp);\\n\\n        // TABULATION\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<m ;j++){\\n                if(i==0 && j==0) dp[i][j]= grid[i][j];\\n                else{\\n                    int up= grid[i][j];\\n                    int left= grid[i][j];\\n                    if(i>0)\\n                        up += dp[i-1][j];\\n                    else up += 1e9;\\n                    if(j>0)\\n                        left += dp[i][j-1];\\n                    else left+=1e9;\\n                    dp[i][j]= min(up, left);\\n                }\\n            }    \\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348274,
                "title": "python-easy-dp-beats-90-tc-o-m-n-sc-o-1",
                "content": "# Intuition\\nIteratively add minimum of upper or left cell to the current cell and return the last cell of last row.\\n\\n# Approach\\nFor 0th row, start from (0, 1) position and add the left cell value to the current cell.\\nFor 0th col, start from (1, 0) position and add the upper cell value to the current cell.\\n\\nNow for every other cell starting from (1, 1) position, choose the minimum of the upper cell value or the left cell value and add it to the current cell (as we can only go down or right).\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346941,
                "title": "c-time-o-m-n-space-o-1-short-sweet-easy-to-understand-tabulation",
                "content": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 1; i < n; i++){\\n            grid[0][i] += grid[0][i-1];\\n        }\\n        for(j = 1; j < m; j++){\\n            grid[j][0] += grid[j-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 1; i < n; i++){\\n            grid[0][i] += grid[0][i-1];\\n        }\\n        for(j = 1; j < m; j++){\\n            grid[j][0] += grid[j-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346886,
                "title": "python-elegant-short-dp-top-down-bottom-up-o-1-memory",
                "content": "# Top-Down DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(n*m)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return maxsize\\n            if i == j == 0:\\n                return grid[0][0]\\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\\n\\n        return dp(len(grid) - 1, len(grid[0]) - 1)\\n```\\n\\n\\n# Dottom-Up DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(1)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(1, n):\\n            grid[i][0] += grid[i - 1][0]\\n\\n        for j in range(1, m):\\n            grid[0][j] += grid[0][j - 1]\\n\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\\n\\n        return grid[n - 1][m - 1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return maxsize\\n            if i == j == 0:\\n                return grid[0][0]\\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\\n\\n        return dp(len(grid) - 1, len(grid[0]) - 1)\\n```\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(1, n):\\n            grid[i][0] += grid[i - 1][0]\\n\\n        for j in range(1, m):\\n            grid[0][j] += grid[0][j - 1]\\n\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\\n\\n        return grid[n - 1][m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346205,
                "title": "easy-java-explained-dp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm works by first initializing the first row and the first column of the **grid** array with the cumulative sum of the numbers in each row and column, respectively. Then, for each cell in the **grid** array that is not in the first row or column, the minimum path sum to reach that cell is the sum of the current cell value and the minimum of the path sum to reach the cell above and the cell to the left. This is computed using the formula **grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);**. Finally, the minimum path sum to reach the bottom-right corner of the **grid** array is returned.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for(int i=1;i<m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j=1; j<n; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n![a.jpg](https://assets.leetcode.com/users/images/4fcb60b5-156a-4322-bea7-9eaa100b4e78_1679892022.773603.jpeg)\\n\\n# **If you like the Solution Please Upvote me...**\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for(int i=1;i<m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j=1; j<n; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345904,
                "title": "c-very-simple-and-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity: o(m*n)\\n\\n- Space complexity:\\nSpace Complexity: o(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for(int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n\\n                if (i == 0) {\\n                    grid[i][j] += grid[i][j - 1];\\n                    continue;\\n                }\\n\\n                if (j == 0) {\\n                    grid[i][j] += grid[i - 1][j];\\n                    continue;\\n                }\\n\\n                grid[i][j] += Math.Min(grid[i][j - 1], grid[i - 1][j]);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for(int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n\\n                if (i == 0) {\\n                    grid[i][j] += grid[i][j - 1];\\n                    continue;\\n                }\\n\\n                if (j == 0) {\\n                    grid[i][j] += grid[i - 1][j];\\n                    continue;\\n                }\\n\\n                grid[i][j] += Math.Min(grid[i][j - 1], grid[i - 1][j]);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345767,
                "title": "3-approaches-recursive-to-most-optimised",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n// SOLUTION 1 : RECURSIVE APPROACH\\n    int solve(int row, int col, vector<vector<int>>&grid){\\n        // base case\\n        if(row == 0 && col == 0){\\n            return grid[0][0];\\n        }\\n        \\n        // out of bound case\\n        if(row < 0 || col < 0){\\n            return 1e9;\\n        }\\n        \\n        // recursive calls\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int ans = min(up , left);\\n        \\n        return ans;\\n    }\\n    \\n// SOLUTION 2 : RECURSIVE + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&dp){\\n        // base case\\n        if(i == 0 && j == 0){\\n            return grid[0][0];\\n        }\\n        \\n        if( i < 0 || j < 0){\\n            return 1e9;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        // recursive calls\\n        int up = grid[i][j] + solve2(i-1, j, grid, dp);\\n        int left = grid[i][j] + solve2(i, j-1, grid, dp);\\n        int ans = min(up, left);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n// SOLUTION 3 : TABULATION METHOD (BOTTOM UP APPORACH)\\n    int solve3(vector<vector<int>>& grid){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        vector<vector<int>>dp(row, vector<int>(col, 0));\\n\\n        for(int i = 0; i<row; i++){\\n            for(int j = 0; j<col; j++){\\n\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }\\n\\n                else{\\n\\n                    int up = grid[i][j];\\n                    if(i > 0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j > 0) left+= dp[i][j-1];\\n                    else left += 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n\\n        return dp[row-1][col-1];\\n    }\\n\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // recursive solution \\n        // int row = grid.size();\\n        // int col = grid[0].size();\\n        // return solve(row-1, col-1, grid);\\n        \\n        // recursion + memoization\\n        //    int row = grid.size();\\n        //    int col = grid[0].size();\\n        //    vector<vector<int>>dp(row, vector<int>(col, -1));\\n        //    return solve2(row-1, col-1, grid, dp);\\n\\n        // tabulation method\\n           return solve3(grid);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n// SOLUTION 1 : RECURSIVE APPROACH\\n    int solve(int row, int col, vector<vector<int>>&grid){\\n        // base case\\n        if(row == 0 && col == 0){\\n            return grid[0][0];\\n        }\\n        \\n        // out of bound case\\n        if(row < 0 || col < 0){\\n            return 1e9;\\n        }\\n        \\n        // recursive calls\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int ans = min(up , left);\\n        \\n        return ans;\\n    }\\n    \\n// SOLUTION 2 : RECURSIVE + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&dp){\\n        // base case\\n        if(i == 0 && j == 0){\\n            return grid[0][0];\\n        }\\n        \\n        if( i < 0 || j < 0){\\n            return 1e9;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        // recursive calls\\n        int up = grid[i][j] + solve2(i-1, j, grid, dp);\\n        int left = grid[i][j] + solve2(i, j-1, grid, dp);\\n        int ans = min(up, left);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n// SOLUTION 3 : TABULATION METHOD (BOTTOM UP APPORACH)\\n    int solve3(vector<vector<int>>& grid){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        vector<vector<int>>dp(row, vector<int>(col, 0));\\n\\n        for(int i = 0; i<row; i++){\\n            for(int j = 0; j<col; j++){\\n\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }\\n\\n                else{\\n\\n                    int up = grid[i][j];\\n                    if(i > 0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j > 0) left+= dp[i][j-1];\\n                    else left += 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n\\n        return dp[row-1][col-1];\\n    }\\n\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // recursive solution \\n        // int row = grid.size();\\n        // int col = grid[0].size();\\n        // return solve(row-1, col-1, grid);\\n        \\n        // recursion + memoization\\n        //    int row = grid.size();\\n        //    int col = grid[0].size();\\n        //    vector<vector<int>>dp(row, vector<int>(col, -1));\\n        //    return solve2(row-1, col-1, grid, dp);\\n\\n        // tabulation method\\n           return solve3(grid);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345695,
                "title": "java-dp-o-1-space-7-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minPathSum(int[][] grid) {\\n    var m = grid.length;\\n    var n = grid[0].length;\\n\\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == 0 && j == 0) continue;\\n\\n        grid[i][j] +=\\n          Math.min(i == 0 ? 1000 : grid[i-1][j],\\n                   j == 0 ? 1000 : grid[i][j-1]);\\n      }\\n    }\\n    return grid[m-1][n-1];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public int minPathSum(int[][] grid) {\\n    var m = grid.length;\\n    var n = grid[0].length;\\n\\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == 0 && j == 0) continue;\\n\\n        grid[i][j] +=\\n          Math.min(i == 0 ? 1000 : grid[i-1][j],\\n                   j == 0 ? 1000 : grid[i][j-1]);\\n      }\\n    }\\n    return grid[m-1][n-1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335810,
                "title": "tabulation-approach-based-explanation-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince there can be numerous number of ways using which we can reach from (0,0) to (m-1, n-1), recursion is evident that it needs to be applied here. Also, after applying some basic recursion, we accordingly optimise our code using memoization, tabulation and space optimisation techniques.\\n![image.png](https://assets.leetcode.com/users/images/59a709e2-b2db-4dbe-bf2a-37cc20ef5f27_1679660889.3993416.png)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n=Declare a dp[] array of size [n][m].\\n=First initialize the base condition values, i.e dp[0][0] = matrix[0][0]\\n=Our answer should get stored in dp[n-1][m-1]. We want to move from (0,0) to (n-1,m-1). But we can\\u2019t move arbitrarily, we should move such that at a particular i and j, we have all the values required to compute dp[i][j].\\n=If we see the memoized code, values required for dp[i][j] are: dp[i-1][j] and dp[i][j-1]. So we only use the previous row and column value.\\n=We have already filled the top-left corner (i=0 and j=0), if we move in any of the two following ways(given below), at every cell we do have all the previous values required to compute its value.\\n=We can use two nested loops to have this traversal\\n=Whenever i>0 , j>0, we will simply mark dp[i][j] = matric[i][j] + min(dp[i-1][j],dp[i][j-1]), according to our recursive relation.\\n=When i=0 or j=0, we add to up( or left) 1e9, so that this path can be rejected.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m) {as there are two nested loops}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m) {as we are using an array of size n*m}\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0 && j==0) dp[i][j] = grid[i][j];\\n                \\n                else{\\n                    int up = grid[i][j];\\n                    if(i>0) up+=dp[i-1][j];\\n                    else up+=1e9;\\n                    \\n                    int left = grid[i][j];\\n                    if(j>0) left+=dp[i][j-1];\\n                    else left+=1e9;\\n                    \\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0 && j==0) dp[i][j] = grid[i][j];\\n                \\n                else{\\n                    int up = grid[i][j];\\n                    if(i>0) up+=dp[i-1][j];\\n                    else up+=1e9;\\n                    \\n                    int left = grid[i][j];\\n                    if(j>0) left+=dp[i][j-1];\\n                    else left+=1e9;\\n                    \\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287986,
                "title": "java-memoization-solution-99-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n# Code\\n```\\nclass Solution {\\n    public int f(int i , int j , int[][] grid,int n , int m , int[][] dp) {\\n        if(i == n-1 && j == m-1) return grid[i][j]; \\n        if(i == n || j== m) return (int)1e9;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int right = grid[i][j] + f(i,j+1,grid,n,m,dp);\\n        int down = grid[i][j] + f(i+1,j,grid,n,m,dp);\\n        return dp[i][j] = Math.min(right,down);\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length,m = grid[0].length;\\n        int[][] dp = new int[n][m];\\n        for(int[] d : dp) Arrays.fill(d,-1);\\n        return f(0,0,grid,n,m,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int f(int i , int j , int[][] grid,int n , int m , int[][] dp) {\\n        if(i == n-1 && j == m-1) return grid[i][j]; \\n        if(i == n || j== m) return (int)1e9;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int right = grid[i][j] + f(i,j+1,grid,n,m,dp);\\n        int down = grid[i][j] + f(i+1,j,grid,n,m,dp);\\n        return dp[i][j] = Math.min(right,down);\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length,m = grid[0].length;\\n        int[][] dp = new int[n][m];\\n        for(int[] d : dp) Arrays.fill(d,-1);\\n        return f(0,0,grid,n,m,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182290,
                "title": "time-o-m-n-space-o-1-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180672,
                "title": "beats-96-4-64-minimum-path-sum-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize m and n as the number of rows and columns of the grid.\\n- Initialize dp list of size n with the first element of dp being the first element of the first row of the grid.\\n- Loop through the remaining columns of the first row, updating each dp[i] as dp[i-1] + grid[0][i].\\n- Loop through the remaining rows of the grid, updating the first column of each row as dp[0] + grid[i][0].\\n- Loop through the remaining columns of the current row, updating each dp[j] as the minimum of dp[j-1] and dp[j] plus the current grid element.\\n- Return the last element of dp which is the minimum path sum from top left to bottom right.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        dp[0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1] + grid[0][i]\\n        for i in range(1, m):\\n            dp[0] += grid[i][0]\\n            for j in range(1, n):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[n-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        dp[0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1] + grid[0][i]\\n        for i in range(1, m):\\n            dp[0] += grid[i][0]\\n            for j in range(1, n):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164319,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        sols = [[x for x in row] for row in grid]\\n\\n        for row in range(1, len(grid)):\\n            sols[row][0] += sols[row - 1][0]\\n\\n        for col in range(1, len(grid[0])):\\n            sols[0][col] += sols[0][col - 1]\\n        \\n        for row in range(1, len(grid)):\\n            for col in range(1, len(grid[0])):\\n                sols[row][col] += min(sols[row - 1][col], sols[row][col - 1])\\n\\n        return sols[-1][-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        fill(0, 0, grid);\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n\\n    public void fill(int row, int col, int[][] grid) {\\n        if (row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        if (row != 0 && col != 0) {\\n            grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n        }\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (col == 0) {\\n                grid[i][col] = grid[i - 1][col] + grid[i][col];\\n            } else {\\n                grid[i][col] = grid[i][col] + Math.min(grid[i - 1][col], grid[i][col - 1]);\\n            }\\n        }\\n\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (row == 0) {\\n                grid[row][i] = grid[row][i - 1] + grid[row][i];\\n            } else {\\n            grid[row][i] = grid[row][i] + Math.min(grid[row][i - 1], grid[row - 1][i]);\\n            }\\n        } \\n        fill(row + 1, col + 1, grid);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        sols = [[x for x in row] for row in grid]\\n\\n        for row in range(1, len(grid)):\\n            sols[row][0] += sols[row - 1][0]\\n\\n        for col in range(1, len(grid[0])):\\n            sols[0][col] += sols[0][col - 1]\\n        \\n        for row in range(1, len(grid)):\\n            for col in range(1, len(grid[0])):\\n                sols[row][col] += min(sols[row - 1][col], sols[row][col - 1])\\n\\n        return sols[-1][-1]\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        fill(0, 0, grid);\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n\\n    public void fill(int row, int col, int[][] grid) {\\n        if (row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        if (row != 0 && col != 0) {\\n            grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n        }\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (col == 0) {\\n                grid[i][col] = grid[i - 1][col] + grid[i][col];\\n            } else {\\n                grid[i][col] = grid[i][col] + Math.min(grid[i - 1][col], grid[i][col - 1]);\\n            }\\n        }\\n\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (row == 0) {\\n                grid[row][i] = grid[row][i - 1] + grid[row][i];\\n            } else {\\n            grid[row][i] = grid[row][i] + Math.min(grid[row][i - 1], grid[row - 1][i]);\\n            }\\n        } \\n        fill(row + 1, col + 1, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096502,
                "title": "2-ms-fastest-ever-java-python-bottom-up-dp-space-optimized",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n// 2D Dp\\nExcept boundary cases :\\n *   dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]\\n\\n// 1D space optimized\\nPreprocess the dp[] array with the first rwo of the grid.\\nThen iterate through remaining elements and choose :\\n*    dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j]\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# In-place \\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i==0 and j==0:\\n                    continue\\n                elif i==0:\\n                    grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j]\\n        return grid[-1][-1]\\n```\\n# Space optimized (Not in-place)\\n```\\nclass Solution { // 1D space optimized\\n    public int minPathSum(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[]=new int[n];\\n        dp[0]=grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            if(j==0) dp[j]=grid[i][j]+dp[j];\\n            else\\n            dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i==0 and j==0:\\n                    continue\\n                elif i==0:\\n                    grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j]\\n        return grid[-1][-1]\\n```\n```\\nclass Solution { // 1D space optimized\\n    public int minPathSum(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[]=new int[n];\\n        dp[0]=grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            if(j==0) dp[j]=grid[i][j]+dp[j];\\n            else\\n            dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060624,
                "title": "dynamic-programming-solution-in-python3",
                "content": "# | Dynamic Programming Solution in Python3:\\n\\n![solution.png](https://assets.leetcode.com/users/images/c42cc536-3e54-4245-a93d-7d0b4bdcbaf1_1673897684.0651052.png)\\n\\n### Complexity\\n***Time complexity =>***  \\nO(n^2)\\n***Space complexity =>***  \\nO(n^2)\\n\\n## Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        m = len(grid)\\n        \\n        dp = [[0]*(n) for x in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[i][j] = grid[i][j]\\n                elif i == 0:\\n                    dp[i][j] = grid[i][j] + dp[i][j - 1]\\n                elif j == 0:\\n                    dp[i][j] = grid[i][j] + dp[i - 1][j]\\n                else:\\n                    dp[i][j] = min(grid[i][j] + dp[i-1][j], grid[i][j] + dp[i][j - 1])\\n        \\n        return dp[m-1][n-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        m = len(grid)\\n        \\n        dp = [[0]*(n) for x in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[i][j] = grid[i][j]\\n                elif i == 0:\\n                    dp[i][j] = grid[i][j] + dp[i][j - 1]\\n                elif j == 0:\\n                    dp[i][j] = grid[i][j] + dp[i - 1][j]\\n                else:\\n                    dp[i][j] = min(grid[i][j] + dp[i-1][j], grid[i][j] + dp[i][j - 1])\\n        \\n        return dp[m-1][n-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041086,
                "title": "recursion-to-space-optimization-all-solutions",
                "content": "**DO UPVOTE IF YOU FIND IT HELPFUL**\\n\\n**RECURSION**\\n```\\n  int solve(int i,int j,vector<vector<int>>& grid)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         int up=grid[i][j] + solve(i-1,j,grid);\\n         int left=grid[i][j] + solve(i,j-1,grid);\\n         return min(left,up);\\n     }\\n```\\n**MEMOIZATION**\\n```\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&dp)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         if(dp[i][j]!=-1)\\n         return dp[i][j];\\n\\n         int up=grid[i][j] + solve(i-1,j,grid,dp);\\n         int left=grid[i][j] + solve(i,j-1,grid,dp);\\n         return dp[i][j]= min(left,up);\\n    }\\n```\\n**TABULATION**\\n```\\n vector<vector<int>>dp(n,vector<int>(m,0));\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(i==0&&j==0)\\n              dp[i][j]=grid[i][j];\\n              else\\n              {\\n                  int up=1e9,left=1e9;\\n                  if(i>0)\\n                  up=grid[i][j]+dp[i-1][j];\\n                  if(j>0)\\n                  left=grid[i][j]+dp[i][j-1];\\n                  dp[i][j]=min(up,left);\\n              }\\n         }\\n     }\\n     return dp[n-1][m-1];\\n```\\n**SPACE OPTIMIZATION**\\n\\n```\\nvector<int>prev(m,0),curr(m,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0&&j==0)\\n               curr[j]=grid[i][j];\\n               else\\n               {\\n                   int up=1e9,left=1e9;\\n                   if(i>0)\\n                   up=grid[i][j]+prev[j];\\n                   if(j>0)\\n                   left=grid[i][j]+curr[j-1];\\n                   curr[j]=min(up,left);\\n               }\\n          }\\n          prev=curr;\\n      }\\n      return prev[m-1];\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n  int solve(int i,int j,vector<vector<int>>& grid)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         int up=grid[i][j] + solve(i-1,j,grid);\\n         int left=grid[i][j] + solve(i,j-1,grid);\\n         return min(left,up);\\n     }\\n```\n```\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&dp)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         if(dp[i][j]!=-1)\\n         return dp[i][j];\\n\\n         int up=grid[i][j] + solve(i-1,j,grid,dp);\\n         int left=grid[i][j] + solve(i,j-1,grid,dp);\\n         return dp[i][j]= min(left,up);\\n    }\\n```\n```\\n vector<vector<int>>dp(n,vector<int>(m,0));\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(i==0&&j==0)\\n              dp[i][j]=grid[i][j];\\n              else\\n              {\\n                  int up=1e9,left=1e9;\\n                  if(i>0)\\n                  up=grid[i][j]+dp[i-1][j];\\n                  if(j>0)\\n                  left=grid[i][j]+dp[i][j-1];\\n                  dp[i][j]=min(up,left);\\n              }\\n         }\\n     }\\n     return dp[n-1][m-1];\\n```\n```\\nvector<int>prev(m,0),curr(m,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0&&j==0)\\n               curr[j]=grid[i][j];\\n               else\\n               {\\n                   int up=1e9,left=1e9;\\n                   if(i>0)\\n                   up=grid[i][j]+prev[j];\\n                   if(j>0)\\n                   left=grid[i][j]+curr[j-1];\\n                   curr[j]=min(up,left);\\n               }\\n          }\\n          prev=curr;\\n      }\\n      return prev[m-1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015988,
                "title": "easy-java-solution-recursive-dp-beginner-friendly",
                "content": "# Intuition\\n1. Handle base cases\\n2. Get down and right value recursive\\n3. Return min(down, right) + self value\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid, int row, int col, int[][] dp) {\\n        if(row < 0 || row >= grid.length || col < 0 || col >=grid[0].length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[row][col] != 0) {\\n            return dp[row][col];\\n        }\\n        if(row == grid.length -1 && col == grid[0].length - 1) {\\n            return grid[row][col];\\n        }\\n\\n        int rightSum = minPathSum(grid, row, col + 1, dp);\\n        int downSum = minPathSum(grid, row + 1, col, dp);\\n        return dp[row][col] = Math.min(rightSum, downSum) + grid[row][col];\\n        \\n    }\\n    public int minPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        return minPathSum(grid, 0 ,0, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid, int row, int col, int[][] dp) {\\n        if(row < 0 || row >= grid.length || col < 0 || col >=grid[0].length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[row][col] != 0) {\\n            return dp[row][col];\\n        }\\n        if(row == grid.length -1 && col == grid[0].length - 1) {\\n            return grid[row][col];\\n        }\\n\\n        int rightSum = minPathSum(grid, row, col + 1, dp);\\n        int downSum = minPathSum(grid, row + 1, col, dp);\\n        return dp[row][col] = Math.min(rightSum, downSum) + grid[row][col];\\n        \\n    }\\n    public int minPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        return minPathSum(grid, 0 ,0, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970608,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(!i && !j) return grid[i][j];\\n        if(i < 0 || j < 0) return INT_MAX;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, grid, dp);\\n        int l = dfs(i, j - 1, grid, dp);\\n\\n        return dp[i][j] = grid[i][j] + min(u, l);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return dfs(n - 1, m - 1, grid, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dp[0][0] = grid[0][0];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(!i && !j) continue;\\n                int u = INT_MAX, l = INT_MAX;\\n                if(i > 0) u = dp[i - 1][j];\\n                if(j > 0) l = dp[i][j - 1];\\n                dp[i][j] = grid[i][j] + min(u, l);\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> dp(m, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            vector<int> temp(m);\\n            for(int j=0; j<m; j++) {\\n                temp[j] = grid[i][j] + min(dp[j], (j > 0 ? temp[j - 1] : INT_MAX));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(!i && !j) return grid[i][j];\\n        if(i < 0 || j < 0) return INT_MAX;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, grid, dp);\\n        int l = dfs(i, j - 1, grid, dp);\\n\\n        return dp[i][j] = grid[i][j] + min(u, l);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return dfs(n - 1, m - 1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dp[0][0] = grid[0][0];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(!i && !j) continue;\\n                int u = INT_MAX, l = INT_MAX;\\n                if(i > 0) u = dp[i - 1][j];\\n                if(j > 0) l = dp[i][j - 1];\\n                dp[i][j] = grid[i][j] + min(u, l);\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> dp(m, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            vector<int> temp(m);\\n            for(int j=0; j<m; j++) {\\n                temp[j] = grid[i][j] + min(dp[j], (j > 0 ? temp[j - 1] : INT_MAX));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912143,
                "title": "c-recursion-memorization-tabulation-space-optimization-teache-by-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(m*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(N) + O(M-1 N-1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n*********************RECURSION********************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      long long up = grid[i][j] + func(i-1,j,grid);\\n      long long  left = grid[i][j] + func(i,j-1,grid);\\n      return min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        return func(m-1,n-1,grid);\\n        \\n    }\\n};\\n\\n****************************MEMORIZATION*************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      if(dp[i][j] != -1) return dp[i][j];\\n      long long up = grid[i][j] + func(i-1,j,grid,dp);\\n      long long  left = grid[i][j] + func(i,j-1,grid,dp);\\n      return dp[i][j] = min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return func(m-1,n-1,grid,dp);\\n        \\n    }\\n};\\n******************************TABULATION********************************\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=dp[i-1][j];\\n                    else up +=1e9;\\n                    if(j>0) left +=dp[i][j-1];\\n                    else left +=1e9;\\n\\n                    dp[i][j] = min(up,left);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n************************SPACE OPTIMIZATION*************************\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>prev(n,0);\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    temp[j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=prev[j];\\n                    else up +=1e9;\\n                    if(j>0) left +=temp[j-1];\\n                    else left +=1e9;\\n\\n                    temp[j] = min(up,left);\\n                }\\n            }\\n            prev =temp;\\n        }\\n        return prev[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n*********************RECURSION********************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      long long up = grid[i][j] + func(i-1,j,grid);\\n      long long  left = grid[i][j] + func(i,j-1,grid);\\n      return min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        return func(m-1,n-1,grid);\\n        \\n    }\\n};\\n\\n****************************MEMORIZATION*************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      if(dp[i][j] != -1) return dp[i][j];\\n      long long up = grid[i][j] + func(i-1,j,grid,dp);\\n      long long  left = grid[i][j] + func(i,j-1,grid,dp);\\n      return dp[i][j] = min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return func(m-1,n-1,grid,dp);\\n        \\n    }\\n};\\n******************************TABULATION********************************\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=dp[i-1][j];\\n                    else up +=1e9;\\n                    if(j>0) left +=dp[i][j-1];\\n                    else left +=1e9;\\n\\n                    dp[i][j] = min(up,left);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n************************SPACE OPTIMIZATION*************************\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>prev(n,0);\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    temp[j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=prev[j];\\n                    else up +=1e9;\\n                    if(j>0) left +=temp[j-1];\\n                    else left +=1e9;\\n\\n                    temp[j] = min(up,left);\\n                }\\n            }\\n            prev =temp;\\n        }\\n        return prev[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880796,
                "title": "c-memoization-dp-recursion-with-clean-comments",
                "content": "At every step, we have **two choices** - to move *right* **or** to move *down*, and we need **min** from both the recursive calls.\\n\\nso, first add the current cell\\'s value and then go to the next cell, either right or down, and return minimum.\\n\\nthen just memoize the recursion, to optimise it.\\n```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n    \\n    int rec(vector<vector<int>>& grid, int i, int j) {\\n        // pruning statement to check out of bounds\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            return 1e9;\\n        \\n        // base case, reached at destination\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1)\\n            return grid[i][j];\\n        \\n        // cache check\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // compute and store/memoize\\n        return dp[i][j] = min(\\n            grid[i][j] + rec(grid, i + 1, j), \\n            grid[i][j] + rec(grid, i, j + 1)\\n        );\\n    }\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        return rec(grid, 0, 0);\\n    }\\n};\\n```\\nif you have any doubts, *feel free to ask* :)\\nplease **UpVote** \\uD83D\\uDD3C , if it helped",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n    \\n    int rec(vector<vector<int>>& grid, int i, int j) {\\n        // pruning statement to check out of bounds\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            return 1e9;\\n        \\n        // base case, reached at destination\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1)\\n            return grid[i][j];\\n        \\n        // cache check\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // compute and store/memoize\\n        return dp[i][j] = min(\\n            grid[i][j] + rec(grid, i + 1, j), \\n            grid[i][j] + rec(grid, i, j + 1)\\n        );\\n    }\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        return rec(grid, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819398,
                "title": "how-to-print-the-path-if-asked",
                "content": "[ShadyCoder](https://leetcode.com/ShadyCoder/) in the [Discuss section]() asked -> \\n\\n\"What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?\"\\n\\nIt is implemented in `minPath()` Function below...\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n// function for minPath getting the minPath string....\\n    string minPath(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<string>> path(m, vector<string>(n));\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n            path[i][0] += path[i - 1][0] + \"D\";\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n            path[0][j] += path[0][j - 1] + \"R\";\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n                if (dp[i][j] == grid[i][j] + dp[i - 1][j])\\n                    path[i][j] = path[i - 1][j] + \"D\";\\n                else\\n                    path[i][j] = path[i][j - 1] + \"R\";\\n            }\\n        }\\n        return path[m - 1][n - 1];\\n    }\\n};\\n\\n// driver code \\nint main()\\n{\\n    vector<vector<vector<int>>> TestCases(3);\\n    TestCases[0] = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\\n    TestCases[1] = {{1, 2, 3}, {4, 5, 6}};\\n    TestCases[2] = {{1, 15, 3, 10}, {2, 2, 10, 32}, {3, 6, 1, 1}, {10, 5, 3, 5}, {3, 4, 2, 10}};\\n    Solution S;\\n    for (int i = 0; i < TestCases.size(); i++)\\n    {\\n        cout << \"Test Case #\" << i + 1 << endl;\\n        for (auto &v : TestCases[i])\\n        {\\n            for (auto &x : v)\\n                cout << x << \"\\\\t\";\\n            cout << endl;\\n        }\\n        cout << \"Min Path Sum = \" << S.minPathSum(TestCases[i]) << endl;\\n        cout << \"Min Path = \" << S.minPath(TestCases[i]) << endl;\\n        cout << endl;\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n// function for minPath getting the minPath string....\\n    string minPath(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<string>> path(m, vector<string>(n));\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n            path[i][0] += path[i - 1][0] + \"D\";\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n            path[0][j] += path[0][j - 1] + \"R\";\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n                if (dp[i][j] == grid[i][j] + dp[i - 1][j])\\n                    path[i][j] = path[i - 1][j] + \"D\";\\n                else\\n                    path[i][j] = path[i][j - 1] + \"R\";\\n            }\\n        }\\n        return path[m - 1][n - 1];\\n    }\\n};\\n\\n// driver code \\nint main()\\n{\\n    vector<vector<vector<int>>> TestCases(3);\\n    TestCases[0] = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\\n    TestCases[1] = {{1, 2, 3}, {4, 5, 6}};\\n    TestCases[2] = {{1, 15, 3, 10}, {2, 2, 10, 32}, {3, 6, 1, 1}, {10, 5, 3, 5}, {3, 4, 2, 10}};\\n    Solution S;\\n    for (int i = 0; i < TestCases.size(); i++)\\n    {\\n        cout << \"Test Case #\" << i + 1 << endl;\\n        for (auto &v : TestCases[i])\\n        {\\n            for (auto &x : v)\\n                cout << x << \"\\\\t\";\\n            cout << endl;\\n        }\\n        cout << \"Min Path Sum = \" << S.minPathSum(TestCases[i]) << endl;\\n        cout << \"Min Path = \" << S.minPath(TestCases[i]) << endl;\\n        cout << endl;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2577847,
                "title": "python-90-solution-dp",
                "content": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dp=[[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                dp[row][col]=grid[row][col]\\n                if row==0 and col==0:\\n                    continue\\n                candidates=set()\\n                if col>0:\\n                    candidates.add(dp[row][col-1])\\n                if row>0:\\n                    candidates.add(dp[row-1][col])\\n                dp[row][col]+=min(candidates)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dp=[[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                dp[row][col]=grid[row][col]\\n                if row==0 and col==0:\\n                    continue\\n                candidates=set()\\n                if col>0:\\n                    candidates.add(dp[row][col-1])\\n                if row>0:\\n                    candidates.add(dp[row-1][col])\\n                dp[row][col]+=min(candidates)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455017,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=694ITcSBySY",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=694ITcSBySY",
                "codeTag": "Unknown"
            },
            {
                "id": 2410066,
                "title": "python-solution-from-recursion-to-dp-and-then-dp-space-optimisation-o-n",
                "content": "**Please Upvote if you liked it**\\n\\n**Recursion : TLE**\\n```\\nclass Solution:\\n    def solve(self,i,j,a):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        up=a[i][j]+self.solve(i-1,j,a)\\n        down=a[i][j]+self.solve(i,j-1,a)\\n        return min(up,down)\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        return self.solve(m-1,n-1,grid)\\n```\\n**Memoization : Accepted**\\n```\\nclass Solution:\\n    def solve(self,i,j,a,dp):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        \\n        up = a[i][j] + self.solve(i-1,j,a,dp)\\n        down = a[i][j] + self.solve(i,j-1,a,dp)\\n        dp[i][j] = min(up,down)\\n        return dp[i][j]\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        return self.solve(m-1,n-1,grid,dp)\\n```\\n***Dynamic Programming(tabulation): Accepted***\\n```\\nclass Solution:\\n\\t    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[0][0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=dp[i-1][j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    dp[i][j]=min(up,left)\\n                    \\n        return dp[m-1][n-1]\\n```\\n# *Space Optimization O(N)+O(N)*\\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid[0])\\n        prev=[-1]*n\\n        for i in range(m):\\n            curr=[-1]*n\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    curr[0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=prev[j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=curr[j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    curr[j]=min(up,left)\\n            prev=curr\\n                    \\n        return prev[n-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self,i,j,a):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        up=a[i][j]+self.solve(i-1,j,a)\\n        down=a[i][j]+self.solve(i,j-1,a)\\n        return min(up,down)\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        return self.solve(m-1,n-1,grid)\\n```\n```\\nclass Solution:\\n    def solve(self,i,j,a,dp):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        \\n        up = a[i][j] + self.solve(i-1,j,a,dp)\\n        down = a[i][j] + self.solve(i,j-1,a,dp)\\n        dp[i][j] = min(up,down)\\n        return dp[i][j]\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        return self.solve(m-1,n-1,grid,dp)\\n```\n```\\nclass Solution:\\n\\t    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[0][0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=dp[i-1][j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    dp[i][j]=min(up,left)\\n                    \\n        return dp[m-1][n-1]\\n```\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid[0])\\n        prev=[-1]*n\\n        for i in range(m):\\n            curr=[-1]*n\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    curr[0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=prev[j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=curr[j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    curr[j]=min(up,left)\\n            prev=curr\\n                    \\n        return prev[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375062,
                "title": "explained-java-solution-easy-to-understand-2ms-90-faster-full-explanation",
                "content": "**NOTE** : Please do try **UNIQUE PATH** problem before trying this problem : https://leetcode.com/problems/unique-paths/\\nand my solution and explanation to that problem is : https://leetcode.com/problems/unique-paths/discuss/2364894/JAVA-SOLUTION-or-0MS-100-FASTER-or-FULL-EXPLANATION\\n\\nNow coming to this problem :\\n* we can move either down or right \\n* for the grid[0][0] we don\\'t update it.\\n* so for the 0th row or column we will update the cost by adding the cost before that column i.e\\n1.  \\t\\t\\tfor the 0th row --> grid[i][j] += grid[i][j-1]\\n1.  \\t\\t\\tfor the 0th col --> grid[i][j] += grid[i-1][j];\\n\\n\\n\\n* Now for the other elements we update them adding that block value to **MIN** of the value from top element above them and the left element to that block (since we can from either down or right , therefor to reach any element we enter in it either from top of it of left of it )\\n\\n```\\npublic int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                else if (i == 0){\\n                    grid[i][j] += grid[i][j-1];\\n                }\\n                else if(j == 0){\\n                    grid[i][j] += grid[i-1][j];\\n                }\\n                else {\\n                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n```\\n\\n\\n\\n\\n.\\n.\\n.\\n.\\n* Let\\'s see how a grid looks like after all these operations \\n```\\n1\\t3\\t1                              1     4     5\\n1\\t5\\t1           -->                2     7     6\\n4\\t2\\t1                              6     8     7\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                else if (i == 0){\\n                    grid[i][j] += grid[i][j-1];\\n                }\\n                else if(j == 0){\\n                    grid[i][j] += grid[i-1][j];\\n                }\\n                else {\\n                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n```\n```\\n1\\t3\\t1                              1     4     5\\n1\\t5\\t1           -->                2     7     6\\n4\\t2\\t1                              6     8     7\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334414,
                "title": "recursive-memoization-tabulation-c",
                "content": "**1) RECURSION**\\n\\nThis solution will give **TLE (ONLY 23 / 61 TEST CASES PASSED)**\\n\\n```\\n// Recursive Solution\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid);\\n        \\n        return min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        return solve(m - 1, n - 1, grid);\\n    }\\n};\\n```\\n\\n\\n**2) MEMOIZATION**\\n\\n  This solution passes all the test cases\\n```\\n// Memoization\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid, vector<vector<long long int>> &dp)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid, dp);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid, dp);\\n        \\n        return dp[i][j] = min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, -1));\\n        \\n        return solve(m - 1, n - 1, grid, dp);\\n    }\\n};\\n```\\n\\n\\n**3) TABULATION**\\n This solution passes all the test cases\\n \\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    long long int up = grid[i][j];\\n                    if(i > 0)\\n                        up += dp[i - 1][j];\\n                    else\\n                        up += 1e9; // to neglect this path  \\n                    \\n                    long long int left = grid[i][j];                    \\n                    if(j > 0)\\n                        left += dp[i][j - 1];\\n                    else\\n                        left += 1e9; // to neglect this path\\n                    \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Recursive Solution\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid);\\n        \\n        return min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        return solve(m - 1, n - 1, grid);\\n    }\\n};\\n```\n```\\n// Memoization\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid, vector<vector<long long int>> &dp)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid, dp);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid, dp);\\n        \\n        return dp[i][j] = min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, -1));\\n        \\n        return solve(m - 1, n - 1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    long long int up = grid[i][j];\\n                    if(i > 0)\\n                        up += dp[i - 1][j];\\n                    else\\n                        up += 1e9; // to neglect this path  \\n                    \\n                    long long int left = grid[i][j];                    \\n                    if(j > 0)\\n                        left += dp[i][j - 1];\\n                    else\\n                        left += 1e9; // to neglect this path\\n                    \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093326,
                "title": "easy-to-understand-cpp-solution",
                "content": "go through the matrix from (1,1);\\n\\n````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        \\n        for(int j=1; j<m; j++){\\n            arr[0][j]+=arr[0][j-1];\\n        }\\n        for(int j=1; j<n; j++){\\n            arr[j][0]+=arr[j-1][0];\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                arr[i][j]+=min(arr[i-1][j],arr[i][j-1]);\\n            }\\n        }\\n        return arr[n-1][m-1];\\n    }\\n};\\n````\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        \\n        for(int j=1; j<m; j++){\\n            arr[0][j]+=arr[0][j-1];\\n        }\\n        for(int j=1; j<n; j++){\\n            arr[j][0]+=arr[j-1][0];\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                arr[i][j]+=min(arr[i-1][j],arr[i][j-1]);\\n            }\\n        }\\n        return arr[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072550,
                "title": "all-c-solutions-brute-memoization-dp-dp-optimised-dp-constant-space",
                "content": "### Approach 1 - Recursion\\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid);\\n        \\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return helper(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\nTime Complexity - O(2^(M+N)) \\nSpace Complexity - O(M+N)\\n\\n### Approach 2 - Memoization\\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& memo){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        if(memo[x][y] != -1) return memo[x][y];\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid, memo);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid, memo);\\n        \\n        return memo[x][y] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        return helper(m-1, n-1, grid, memo);\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O((M+N) + M\\\\*N) - Recursice Stack Space + Memo table\\n\\n### Approach 3 - DP\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp (m, vector<int>(n, 0));\\n        dp[0][0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + dp[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y] + dp[x][y-1];\\n                \\n                dp[x][y] = min(up, left);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(M\\\\*N) - DP table\\n\\n### Approach 4 - DP optimised\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> prevRow(n, 0), curRow(n, 0);\\n        curRow[0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + prevRow[y];\\n                if(y-1 >= 0) left = grid[x][y] + curRow[y-1];\\n                \\n                curRow[y] = min(up, left);\\n            }\\n            prevRow = curRow;\\n        }\\n        return curRow[n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(N) - DP table\\n\\n### Approach 5 - DP with constant space\\n##### The approach involves modification of the input array and the solution will fail if the input array is immutable\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y-1];\\n                \\n                grid[x][y] += min(up, left);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid);\\n        \\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return helper(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& memo){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        if(memo[x][y] != -1) return memo[x][y];\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid, memo);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid, memo);\\n        \\n        return memo[x][y] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        return helper(m-1, n-1, grid, memo);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp (m, vector<int>(n, 0));\\n        dp[0][0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + dp[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y] + dp[x][y-1];\\n                \\n                dp[x][y] = min(up, left);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> prevRow(n, 0), curRow(n, 0);\\n        curRow[0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + prevRow[y];\\n                if(y-1 >= 0) left = grid[x][y] + curRow[y-1];\\n                \\n                curRow[y] = min(up, left);\\n            }\\n            prevRow = curRow;\\n        }\\n        return curRow[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y-1];\\n                \\n                grid[x][y] += min(up, left);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967500,
                "title": "dp-solution-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) {\\n                    dp[i][j]=grid[i][j]; //filling top-left cell\\n                }\\n                if(i==0 && j!=0){\\n                    dp[i][j]=dp[i][j-1]+grid[i][j]; //filling first row\\n                }\\n                if(j==0 && i!=0){\\n                    dp[i][j]=dp[i-1][j]+grid[i][j]; //filling first column\\n                }\\n                if(i!=0 && j!=0){\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; //filling rest of the cells\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) {\\n                    dp[i][j]=grid[i][j]; //filling top-left cell\\n                }\\n                if(i==0 && j!=0){\\n                    dp[i][j]=dp[i][j-1]+grid[i][j]; //filling first row\\n                }\\n                if(j==0 && i!=0){\\n                    dp[i][j]=dp[i-1][j]+grid[i][j]; //filling first column\\n                }\\n                if(i!=0 && j!=0){\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; //filling rest of the cells\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879199,
                "title": "c-very-very-easy-simple-8-line-code-tc-o-n-m-sc-o-1",
                "content": "```\\n\\tint minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) grid[i][j]+=grid[i][j-1];\\n                else if(j==0) grid[i][j]+=grid[i-1][j];\\n                else grid[i][j]+=min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n```\\n\\nThe extension of this problem is [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/). The solution of this question is similar to this.\\nSolution link - https://leetcode.com/problems/dungeon-game/discuss/1879082/c-very-very-easy-simple-9-line-code-tc-o-nm-sc-o-1",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tint minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) grid[i][j]+=grid[i][j-1];\\n                else if(j==0) grid[i][j]+=grid[i-1][j];\\n                else grid[i][j]+=min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1837560,
                "title": "c-very-easy-recursive-memoization-tabulation-solution",
                "content": "Just upvote to make a little effort for your motivation \\n// Memoization \\n```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int find(vector<vector<int>>& grid, int m,int n, int i,int j){\\n            \\n        if(i == m-1 and j == n-1) return grid[i][j]; \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int right=INT_MAX, bottom = INT_MAX;\\n        if(i<m-1) right= grid[i][j]+find(grid,m,n,i+1,j);\\n        if(j<n-1) bottom = grid[i][j]+find(grid,m,n,i,j+1);\\n        \\n        return dp[i][j]=min(right, bottom);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n       int m= grid.size(),n= grid[0].size();\\n        return find(grid,m,n,0,0);\\n    }\\n};\\n```\\n\\n// DP tabulation\\n```\\nclass Solution{\\npublic:\\nint minPathSum(vector<vector<int>>& grid) {\\n        \\n       int m= grid.size(),n= grid[0].size();\\n  \\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1; i<m ; i++) dp[i][0]= dp[i-1][0]+grid[i][0];\\n        for(int j=1; j<n ; j++) dp[0][j]= dp[0][j-1]+grid[0][j];\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                dp[i][j]= grid[i][j]+min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int find(vector<vector<int>>& grid, int m,int n, int i,int j){\\n            \\n        if(i == m-1 and j == n-1) return grid[i][j]; \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int right=INT_MAX, bottom = INT_MAX;\\n        if(i<m-1) right= grid[i][j]+find(grid,m,n,i+1,j);\\n        if(j<n-1) bottom = grid[i][j]+find(grid,m,n,i,j+1);\\n        \\n        return dp[i][j]=min(right, bottom);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n       int m= grid.size(),n= grid[0].size();\\n        return find(grid,m,n,0,0);\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\nint minPathSum(vector<vector<int>>& grid) {\\n        \\n       int m= grid.size(),n= grid[0].size();\\n  \\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1; i<m ; i++) dp[i][0]= dp[i-1][0]+grid[i][0];\\n        for(int j=1; j<n ; j++) dp[0][j]= dp[0][j-1]+grid[0][j];\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                dp[i][j]= grid[i][j]+min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803657,
                "title": "recursion-memorization-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>>&dp){\\n        if(i == m-1 and j == n-1) return grid[i][j];\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int down = INT_MAX, right = INT_MAX;\\n        \\n        if(i+1 < grid.size())    down = solve(i+1,j,m,n,grid,dp);\\n        \\n        if(j+1 < grid[0].size()) right = solve(i,j+1,m,n,grid,dp);\\n        \\n        int ans = grid[i][j] + min(down,right);\\n        return dp[i][j] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return solve(0,0,m,n,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>>&dp){\\n        if(i == m-1 and j == n-1) return grid[i][j];\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int down = INT_MAX, right = INT_MAX;\\n        \\n        if(i+1 < grid.size())    down = solve(i+1,j,m,n,grid,dp);\\n        \\n        if(j+1 < grid[0].size()) right = solve(i,j+1,m,n,grid,dp);\\n        \\n        int ans = grid[i][j] + min(down,right);\\n        return dp[i][j] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return solve(0,0,m,n,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783719,
                "title": "java-top-down-dp-simple-code-explained",
                "content": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n       // Create DP matrix // Following Top Down Approach\\n       int[][] result = new int[grid.length][grid[0].length];\\n        \\n    \\t\\n    \\tfor(int i=0; i<grid.length; i++) {\\n    \\t\\tfor(int j=0; j<grid[0].length; j++) {\\n                \\n                \\n    \\t\\t\\tif(i==0 && j==0) { // For 1st element // Directly add\\n    \\t\\t\\t\\tresult[i][j]= grid[i][j];\\n    \\t\\t\\t}\\n                \\n                \\n                //\\u2192\\n                else if(i==0 ) { // For 1st Row \\n                    result[i][j] = result[i][j-1] + grid[i][j];\\n    \\t\\t\\t}\\n                \\n                \\n                // \\u2193\\n    \\t\\t\\telse if(j==0) { // For 1st Column\\n    \\t\\t\\t\\tresult[i][j] = result[i-1][j] + grid[i][j];\\n    \\t\\t\\t}\\n                \\n                // \\u2192                \\n                //\\u2193\\n    \\t\\t\\telse { // Except 1st row and 1st column\\n    \\t\\t\\t\\tresult[i][j] = Math.min(result[i-1][j],result[i][j-1]) + grid[i][j];\\n    \\t\\t\\t}\\t\\t\\t\\n    \\t}\\n        \\n      }\\n    return result[grid.length - 1][grid[0].length- 1]; // Return result[2][2]  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n       // Create DP matrix // Following Top Down Approach\\n       int[][] result = new int[grid.length][grid[0].length];\\n        \\n    \\t\\n    \\tfor(int i=0; i<grid.length; i++) {\\n    \\t\\tfor(int j=0; j<grid[0].length; j++) {\\n                \\n                \\n    \\t\\t\\tif(i==0 && j==0) { // For 1st element // Directly add\\n    \\t\\t\\t\\tresult[i][j]= grid[i][j];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1768077,
                "title": "c-dp-recursive-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n//Recusrive-> TLE\\n//Time and Space: O(2^(n+m)) and O(N)stack + O(m-1, n-1);\\n    int func(int i, int j, vector<vector<int>>& a){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        int up = a[i][j] + func(i-1,j,a);\\n        int left = a[i][j] + func(i,j-1,a);\\n        \\n        return min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        return func(n-1,m-1,a);\\n    }\\n    \\n//Memoization-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(N)stack + O(n*m);\\n   int func(int i, int j, vector<vector<int>>& a,vector<vector<int>> &dp){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int up = a[i][j] + func(i-1,j,a,dp);\\n        int left = a[i][j] + func(i,j-1,a,dp);\\n        \\n        return dp[i][j] = min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        return func(n-1,m-1,a,dp);\\n    }\\n    \\n//Tabulation-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(n*m);\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) dp[i][j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e8;\\n                \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n    \\n// Space Optimiztion->Accepted\\uD83D\\uDD25\\n// Time: O(n*m)\\n// Space: O(m)\\nint minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int>prev(m,0), curr(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) curr[j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= curr[j-1];\\n                    else left+= 1e8;\\n                \\n                    curr[j] = min(left, up);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Recusrive-> TLE\\n//Time and Space: O(2^(n+m)) and O(N)stack + O(m-1, n-1);\\n    int func(int i, int j, vector<vector<int>>& a){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        int up = a[i][j] + func(i-1,j,a);\\n        int left = a[i][j] + func(i,j-1,a);\\n        \\n        return min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        return func(n-1,m-1,a);\\n    }\\n    \\n//Memoization-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(N)stack + O(n*m);\\n   int func(int i, int j, vector<vector<int>>& a,vector<vector<int>> &dp){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int up = a[i][j] + func(i-1,j,a,dp);\\n        int left = a[i][j] + func(i,j-1,a,dp);\\n        \\n        return dp[i][j] = min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        return func(n-1,m-1,a,dp);\\n    }\\n    \\n//Tabulation-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(n*m);\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) dp[i][j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e8;\\n                \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n    \\n// Space Optimiztion->Accepted\\uD83D\\uDD25\\n// Time: O(n*m)\\n// Space: O(m)\\nint minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int>prev(m,0), curr(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) curr[j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= curr[j-1];\\n                    else left+= 1e8;\\n                \\n                    curr[j] = min(left, up);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1844924,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844935,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844856,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1568882,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567180,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844809,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567830,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1780572,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1569788,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1800731,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844924,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844935,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844856,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1568882,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567180,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844809,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567830,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1780572,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1569788,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1800731,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1732247,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845396,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1569523,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845071,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845039,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2069231,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2066589,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2062807,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2046516,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2044908,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2044546,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1991689,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1970176,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1968499,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1963540,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1922475,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1910311,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845593,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845487,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845410,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845351,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845074,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845032,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845018,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844992,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844962,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844954,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844952,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844923,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844904,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844902,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844895,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844858,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844855,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844841,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844840,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844330,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842951,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1835620,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810558,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1795151,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754116,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740933,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729388,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1722996,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1718321,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1713015,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1694940,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1675957,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1670947,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]