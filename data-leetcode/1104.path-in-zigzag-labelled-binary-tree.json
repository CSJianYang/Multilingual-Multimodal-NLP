[
    {
        "title": "Path In Zigzag Labelled Binary Tree",
        "question_content": "In an infinite binary tree where every node has two children, the nodes are labelled in row order.\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the label of a node in this tree, return the labels in the path from the root of the tree to the&nbsp;node with that label.\n&nbsp;\nExample 1:\n\nInput: label = 14\nOutput: [1,3,4,14]\n\nExample 2:\n\nInput: label = 26\nOutput: [1,2,6,10,26]\n\n&nbsp;\nConstraints:\n\n\t1 <= label <= 10^6",
        "solutions": [
            {
                "id": 324011,
                "title": "python-o-logn-time-and-space-with-readable-code-and-step-by-step-explanation",
                "content": "Step by Step Explanation\\nWith the thought in mind that in an ordered binary tree that goes from 1 to n:\\n```\\nNormally Ordered Binary Tree:\\n             1\\n           /   \\\\\\n         2       3\\n       /  \\\\     /  \\\\\\n     4     5   6     7\\n   / |    /|   |\\\\    | \\\\\\n 8   9  10 11 12 13  14  15\\n```\\nThought 1) You can easily determine the parent by dividing by 2 with a normally ordered (non-zigzag) binary tree\\nFor example the parent of 9 can be calculated via int(9/2) which is 4\\n\\nThought 2) So we now how how to trace from the input `label` to the root node. So lets start with `label` In our example, we will use 14. To determine the parent of 14, notice that in the same spot in a normally ordered binary tree that it is 9. So you just need to calculate how to get from 14 to 9.\\n```\\nZig Zag Binary Tree:\\n             1\\n           /   \\\\\\n         3       2  <- 3+2-3 = 2/2 = 1\\n       /  \\\\     /  \\\\\\n     4     5   6     7   <- 7+4-4 = 7/2 = 3\\n   / |    /|   |\\\\    | \\\\\\n 15 14  13 12 11 10  9  8   <- 15+8-14 = 9/2 = 4\\n```\\ninversion formula: (max number of current level + min number of current level) - current number\\nFor example to find the inversion of 14: 15 + 8 - 14 = 9\\nFrom here you just divide 9 by 2 to find the parent 4\\n\\nThought 3) You have to run the inversion formula at every level because at every level the row is inverted relative to the previous row\\n\\nTime Complexity:\\nO(3 log n). 3 are needed as commented in the code.\\n\\nSpace Complexity:\\nIf including the space required for the return `res` object counts as space then we need\\nO(log n) because we need to store the path from the root to the `label`.\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        res = [] # O(log n) space\\n        node_count = 1\\n        level = 1\\n        # Determine level of the label\\n        while label >= node_count*2: # O(log n) time\\n            node_count *= 2\\n            level += 1\\n        # Iterate from the target label to the root\\n        while label != 0: # O(log n) time\\n            res.append(label)\\n            level_max = 2**(level) - 1\\n            level_min = 2**(level-1)\\n            label = int((level_max + level_min - label)/2)\\n            level -= 1\\n        return res[::-1] # O(n) time\\n```",
                "solutionTags": [],
                "code": "```\\nNormally Ordered Binary Tree:\\n             1\\n           /   \\\\\\n         2       3\\n       /  \\\\     /  \\\\\\n     4     5   6     7\\n   / |    /|   |\\\\    | \\\\\\n 8   9  10 11 12 13  14  15\\n```\n```\\nZig Zag Binary Tree:\\n             1\\n           /   \\\\\\n         3       2  <- 3+2-3 = 2/2 = 1\\n       /  \\\\     /  \\\\\\n     4     5   6     7   <- 7+4-4 = 7/2 = 3\\n   / |    /|   |\\\\    | \\\\\\n 15 14  13 12 11 10  9  8   <- 15+8-14 = 9/2 = 4\\n```\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        res = [] # O(log n) space\\n        node_count = 1\\n        level = 1\\n        # Determine level of the label\\n        while label >= node_count*2: # O(log n) time\\n            node_count *= 2\\n            level += 1\\n        # Iterate from the target label to the root\\n        while label != 0: # O(log n) time\\n            res.append(label)\\n            level_max = 2**(level) - 1\\n            level_min = 2**(level-1)\\n            label = int((level_max + level_min - label)/2)\\n            level -= 1\\n        return res[::-1] # O(n) time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323293,
                "title": "invert-labels",
                "content": "#### Intuition\\nIf the tree is numbered left-to-right (not zigzag), the parent\\'s label can be always determined as ```label / 2```. For zigzag, we need to \"invert\" the parent label.\\n\\n#### Simplified Solution\\nThe idea is the same as for the original solution below, but I hope this one is a bit easier to understand. We first build the path from label to the root (by dividing the label by two).\\n\\nThen, we go thougth the path, and invert odd labels.\\n\\n**C++**\\n```cpp\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int> res;\\n    for (; label > 0; label /= 2)\\n        res.push_back(label);\\n    for (int i = res.size() - 1; i >= 0; --i)\\n        if (i % 2 == 1)\\n            res[i] = (1 << (res.size() - i - 1)) * 3 - res[i] - 1;\\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```\\n\\n#### Original Solution\\nDetermine the tree ```level``` where our value is located. The maximum label in the level is ```1 << level - 1```, and minimum is ```1 << (level - 1)```. We will use this fact to \"invert\" the parent label.\\n\\n**C++**\\n```cpp\\nvector<int> pathInZigZagTree(int label, int level = 0) {\\n  while (1 << level <= label) ++level;\\n  vector<int> res(level);\\n  for(; label >= 1; label /= 2, --level) {\\n    res[level - 1] = label;\\n    label = (1 << level) - 1 - label + (1 << (level - 1));\\n  }\\n  return res;\\n}\\n```\\n#### Complexity Analysis\\nRuntime: *O(log n)*\\nMemory: *O(1)* or *O(log n)* if we consider the memory required for the result.",
                "solutionTags": [
                    "C"
                ],
                "code": "```label / 2```\n```cpp\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int> res;\\n    for (; label > 0; label /= 2)\\n        res.push_back(label);\\n    for (int i = res.size() - 1; i >= 0; --i)\\n        if (i % 2 == 1)\\n            res[i] = (1 << (res.size() - i - 1)) * 3 - res[i] - 1;\\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```\n```level```\n```1 << level - 1```\n```1 << (level - 1)```\n```cpp\\nvector<int> pathInZigZagTree(int label, int level = 0) {\\n  while (1 << level <= label) ++level;\\n  vector<int> res(level);\\n  for(; label >= 1; label /= 2, --level) {\\n    res[level - 1] = label;\\n    label = (1 << level) - 1 - label + (1 << (level - 1));\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323312,
                "title": "simple-solution-in-java-using-properties-of-complete-binary-tree-o-log-n",
                "content": "1) Calculate current depth of the label\\n2) Calculate offset (for each depth, values lie from 2^d -> 2^(d+1) -1\\n3) Find the real parent based on offset\\n4) Repeat until we reach 1\\n\\ne.g. parent of 14 is 4\\n1) depth = 3, values in this depth lie from 8 to 15 (since it is a complete binary tree)\\n2) offset = 15 - 14 = 1\\n3) real parent of 14 = parent of ( 8 + offset ) = parent (9) = 9/2 = 4\\n\\n```\\npublic List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        int parent = label;\\n        result.addFirst(parent);\\n\\n        while(parent != 1) {\\n            int d = (int)(Math.log(parent)/Math.log(2));\\n            int offset = (int)Math.pow(2, d+1) - 1 - parent;\\n            parent = ((int)Math.pow(2, d) + offset) / 2;\\n            result.addFirst(parent);   \\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        int parent = label;\\n        result.addFirst(parent);\\n\\n        while(parent != 1) {\\n            int d = (int)(Math.log(parent)/Math.log(2));\\n            int offset = (int)Math.pow(2, d+1) - 1 - parent;\\n            parent = ((int)Math.pow(2, d) + offset) / 2;\\n            result.addFirst(parent);   \\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323462,
                "title": "c-o-log-n-solution-with-comments",
                "content": "C++ O(log n) Solution with comments\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label); //taking bottom up approach, so the label itself must be included \\n        int height=log2(label); //height of label from root\\n        \\n        while(height!=0){\\n            int left=pow(2,height-1); // rank of left limit of the previous level \\n            int right=pow(2,height)-1;// rank of right limit of the previous level\\n            label=left+(right-label/2);// The previous level is sorted in different order than current one.\\n                                       //So the new label is adjusted accordingly\\n            result.push_back(label);  //newly found label is appened to result\\n            height--;\\n        }\\n        \\n        reverse(result.begin(),result.end()); //required top to down, so the array is reversed. \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label); //taking bottom up approach, so the label itself must be included \\n        int height=log2(label); //height of label from root\\n        \\n        while(height!=0){\\n            int left=pow(2,height-1); // rank of left limit of the previous level \\n            int right=pow(2,height)-1;// rank of right limit of the previous level\\n            label=left+(right-label/2);// The previous level is sorted in different order than current one.\\n                                       //So the new label is adjusted accordingly\\n            result.push_back(label);  //newly found label is appened to result\\n            height--;\\n        }\\n        \\n        reverse(result.begin(),result.end()); //required top to down, so the array is reversed. \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323286,
                "title": "if-this-question-is-easy-than-why-2-3-of-participants-cannot-solve-it",
                "content": "If this question is `Easy` than why 2/3 of participants (including me) cannot solve it?",
                "solutionTags": [],
                "code": "If this question is `Easy` than why 2/3 of participants (including me) cannot solve it?",
                "codeTag": "Unknown"
            },
            {
                "id": 323310,
                "title": "python-1-line-solution",
                "content": "In the same line, the biggest = smallest * 2  - 1, which leads to the factor 3.\\nAnd also, each parent is the half of their children, which leads to the pow of 2.\\n\\n**Python:**\\n```\\n    def pathInZigZagTree(self, x):\\n        return self.pathInZigZagTree(3 * 2 ** (len(bin(x)) - 4) - 1 - x / 2) + [x] if x > 1 else [1]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def pathInZigZagTree(self, x):\\n        return self.pathInZigZagTree(3 * 2 ** (len(bin(x)) - 4) - 1 - x / 2) + [x] if x > 1 else [1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 327870,
                "title": "java-solution-with-detailed-explanation",
                "content": "\\nHere in my solution, the depth and position are both 0 indexed.\\nFor the first number on level n, there are total 2 ^ n before it.\\n\\n\\tdepth = 0   |                            1\\n\\tdepth = 1   |                 3                     2\\n\\t...\\n\\tdepth = n   |    2^ n-1, ....                     2^n-k/2-1....\\n\\t\\t\\t\\t\\t  /\\t    \\\\\\t\\t\\t\\t\\t\\t   /   \\\\\\n\\tdepth = n+1 | 2^n,     2^n+1, ....           2^n+k, 2^n+(k+1)....\\nWe first get the current depth and position of the given number, then deduct (pos + 1)  from the label which will get last number on the upper level. For example from the image, the current position of 14 is depth=3 and pos=6. We deduct 7 get 7. The next thing is to find the postion of its parent, which is pos / 2. For example, 14 position is 6, the position of its parent (4) is 3.\\nIn this way, we get all the numbers. The time complexity is O(lgn)\\n![image](https://assets.leetcode.com/users/shield_david/image_1562351879.png)\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new LinkedList<>();\\n        if(label <= 0)\\n            return result;\\n        int level = 0;\\n        while(Math.pow(2, level) - 1 < label)   level++;        \\n        level--; // calculate the depth, 0 indexed, 0 is odd\\n        while(level != 0) {\\n            result.add(0, label);\\n            int pos = label - (int) Math.pow(2, level); // calculate the position, 0 indexed  \\n            label = label - (pos + 1) - pos / 2;\\n            level--;\\n        }\\n        result.add(0, 1);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new LinkedList<>();\\n        if(label <= 0)\\n            return result;\\n        int level = 0;\\n        while(Math.pow(2, level) - 1 < label)   level++;        \\n        level--; // calculate the depth, 0 indexed, 0 is odd\\n        while(level != 0) {\\n            result.add(0, label);\\n            int pos = label - (int) Math.pow(2, level); // calculate the position, 0 indexed  \\n            label = label - (pos + 1) - pos / 2;\\n            level--;\\n        }\\n        result.add(0, 1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860872,
                "title": "c-o-logn-solution-bottom-up",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 6.5 MB, less than 29.20% of C++ online submissions for Path In Zigzag Labelled Binary Tree..\\n.\\n.\\n![image](https://assets.leetcode.com/users/images/88917ec1-bdf8-4d78-b360-8d7a3a897fcf_1600876038.6600647.png)\\n\\n\\n```\\nWe find the labels starting from given label in bottom to top order\\nFirst we find the depth of the current label as : depth = log2(label)\\nThe parent label (next label) of  the current label will be label/2 in non zigzag binary tree\\nAs the given tree is zigzag labeled no labels will have their original parent label which is label/2 except depth 1 labels, root has depth 0.\\n    \\nSo, we find the parent label (next label) of the current label in zigzag tree as:\\n\\nparent label = previous depth first element + (previous depth last element - next label in non zigzag tree)\\nprevious depth first element : 2^ (depth-1)\\nprevious depth last element : 2^ (depth) -1\\nnext label in non zigzag tree : label/2\\n\\nExample:\\nFor label 14, depth = log2(14) = 3\\ndepth = 3, label = 14, parent label = 2^(3-1) + 2^3 -1 - 14/2 = 4 + 7 - 7 = 4\\ndepth = 2, label =  4, parent label = 2^(2-1) + 2^2 -1 -  4/2 = 2 + 3 - 2 = 3\\ndepth = 1, label =  3, parent label = 2^(1-1) + 2^1 -1 -  3/2 = 1 + 1 - 1 = 1\\nSo, path = [1, 3, 4, 14]\\n```\\n.\\n.\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\n        vector<int>result;\\n        \\n        // depth of the given label\\n        int depth = log10(label)/log10(2);\\n        \\n        // Insert labels in the front of the vector from bottom to top\\n        while(depth>=0)\\n        {\\n            // insert current label in the front of vector \\n            result.insert(result.begin(),label);\\n            \\n            // next label (parent label of current label) in non zizag tree: label/2\\n            // in zigzag tree we get label as: \\n            // previous depth first element + (previous depth last element - next label in non zigzag tree)\\n            // previous depth first element : 2^ (depth-1)\\n            // previous depth last element : 2^ (depth) -1\\n            // next label in non zigzag tree : label/2\\n            label = (int)pow(2,depth-1) + (int)pow(2,depth) - 1 - label/2;\\n            depth--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nWe find the labels starting from given label in bottom to top order\\nFirst we find the depth of the current label as : depth = log2(label)\\nThe parent label (next label) of  the current label will be label/2 in non zigzag binary tree\\nAs the given tree is zigzag labeled no labels will have their original parent label which is label/2 except depth 1 labels, root has depth 0.\\n    \\nSo, we find the parent label (next label) of the current label in zigzag tree as:\\n\\nparent label = previous depth first element + (previous depth last element - next label in non zigzag tree)\\nprevious depth first element : 2^ (depth-1)\\nprevious depth last element : 2^ (depth) -1\\nnext label in non zigzag tree : label/2\\n\\nExample:\\nFor label 14, depth = log2(14) = 3\\ndepth = 3, label = 14, parent label = 2^(3-1) + 2^3 -1 - 14/2 = 4 + 7 - 7 = 4\\ndepth = 2, label =  4, parent label = 2^(2-1) + 2^2 -1 -  4/2 = 2 + 3 - 2 = 3\\ndepth = 1, label =  3, parent label = 2^(1-1) + 2^1 -1 -  3/2 = 1 + 1 - 1 = 1\\nSo, path = [1, 3, 4, 14]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\n        vector<int>result;\\n        \\n        // depth of the given label\\n        int depth = log10(label)/log10(2);\\n        \\n        // Insert labels in the front of the vector from bottom to top\\n        while(depth>=0)\\n        {\\n            // insert current label in the front of vector \\n            result.insert(result.begin(),label);\\n            \\n            // next label (parent label of current label) in non zizag tree: label/2\\n            // in zigzag tree we get label as: \\n            // previous depth first element + (previous depth last element - next label in non zigzag tree)\\n            // previous depth first element : 2^ (depth-1)\\n            // previous depth last element : 2^ (depth) -1\\n            // next label in non zigzag tree : label/2\\n            label = (int)pow(2,depth-1) + (int)pow(2,depth) - 1 - label/2;\\n            depth--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453554,
                "title": "easy-to-understand-o-log-n-c-solution-with-intuition-and-explanation-with-example",
                "content": "**Steps** to approach this problem:-\\n1. Determining the level of label node.\\n2. Determining its parent(path) with the help of non-zigzag tree.\\n\\nLets see the below two trees:-\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1                                                         -> level 1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2                                                        3                          -> level 2\\n\\t\\t\\t\\t\\t\\t\\t                4                                5                           6                          7             -> level 3\\n\\t                            8                    9               10            11\\t\\t\\t  12           13         14             15       -> level 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNon-Zigzag\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1                                                         -> level 1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t3                                                        2                           -> level 2\\n\\t\\t\\t\\t\\t\\t\\t                4                                5                           6                          7                -> level 3\\n\\t                            15                    14               13              12\\t\\t\\t  11           10         9             8           -> level 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tZigzag\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n1. We can clearly observe that whether the tree may be zigzag or non-zigzag the level in which a label node will lie remains same as each level contain same nodes in both trees.\\nThis level is simply **(int)log2(label) +1** .\\n\\n2. Now if we observe for a non-zigzag tree, the parent of any label node will always be **label/2**.\\nAlso, for each level the nodes lying in the level will be in the following range:-\\n**[2^(level-1),(2^level)-1]** where ^ denotes power.\\nOne important observation is that, the ***label node in zigzag tree is in its mirror position in non-zigzag tree***\\nSo if we can determine the corresponding mirror node of label node in a level then we can easily say its parent is label/2.\\nSo to determine this:-\\n**(Mirror node - lowest node in that level) = (Highest node in that level - label node)**\\nLets say mirror node=x\\nx - 2^(level-1) = (2^level)-1 - label\\n=>** x = ((2^level)-1 - label) + 2^(level-1)**\\nSo parent of x will be x/2.\\n\\nSo we will simply push back the value of x in our result vector and in the end return the reversed result.\\n\\nEg. Let label =13\\n\\nlevel=(int)log2(label)+1 = (int)log2(13)+1 = 4.\\nNow see the 4th level in above 2 trees.\\nThe position of 13 is exaclty the mirror position in both trees.\\nMirror of 13 = ?\\nx=mirror\\nusing this:-\\nx = ((2^level)-1 - label) + 2^(level-1) = ((2^4)-1 - 13) + 2^(4-1) = 10\\nand we know the parent of 10 in non-zigzag tree is 10/2 =5.\\nSo parent of 13 in zigzag tree is also 5.\\nSimilarly we can repeat by setting the label to its parent.\\n```\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        int level=(int)log2(label)+1; // determine the level in which the label node will lie\\n        int x=label;\\n        ans.push_back(x); \\n        while(level>1)\\n        {\\n            x=(((int)pow(2,level)-1-x)+(int)pow(2,level-1))/2;    // use the non-zigzag tree form to determine the parent\\n            ans.push_back(x);\\n            level--;            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;  \\n    }\\n```\\n\\nPlease upvote if you find it helpful as it really motivates me to help the community.\\nAny suggestions are welcomed!\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        int level=(int)log2(label)+1; // determine the level in which the label node will lie\\n        int x=label;\\n        ans.push_back(x); \\n        while(level>1)\\n        {\\n            x=(((int)pow(2,level)-1-x)+(int)pow(2,level-1))/2;    // use the non-zigzag tree form to determine the parent\\n            ans.push_back(x);\\n            level--;            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447819,
                "title": "c-easy-solution-for-beginners-with-math-explanation-100-faster",
                "content": "### Approach: \\n\\nAll we have to do is, we have to find parent for each label everytime, until we reach 1. \\nAs it is an infinite binary tree and constraints are upto 10^6, we cannot store it in array or in form of normal node pointers.\\n\\nThe challenge here is to **FIND THE PARENT OF A GIVEN LABEL USING MATHS**\\n\\nFew observations, which come in sight are:\\n- If label is a power of 2, then its parent is label - 1. (Due to zig zag nature of tree).\\n- Difference between label and its level start = 2 * (Difference between its parent and parent level end).\\n- Parent Level End = Label Level Start - 1\\n\\nSo for any label, its parent comes out to be = Parent Level End - (Difference between label and its level start)/2\\n\\nFor example, label = 14.\\n![image](https://assets.leetcode.com/users/images/35accf05-0e72-4384-9429-ce767f235088_1630915985.5353606.png)\\n\\nMy submission:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerTwo(long long n){\\n        return ((n - 1)&n) == 0;\\n    }\\n    int getLevelStart(long long n){\\n        while(!isPowerTwo(n)){\\n            n++;\\n        }\\n        return n/2;\\n    }\\n    int getParent(int n){\\n        if(isPowerTwo(n)){\\n            return n - 1;\\n        } else {\\n            int level_start = getLevelStart(n);\\n            int difference = (n - level_start)/2;\\n            return level_start - 1 - difference;\\n        }\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        while(label != 1){\\n            int parent = getParent(label);\\n            result.push_back(parent);\\n            label = parent;\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n};\\n```\\n**PLEASE UPVOTE IT IF YOU LIKED IT, IT REALLY MOTIVATES :)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerTwo(long long n){\\n        return ((n - 1)&n) == 0;\\n    }\\n    int getLevelStart(long long n){\\n        while(!isPowerTwo(n)){\\n            n++;\\n        }\\n        return n/2;\\n    }\\n    int getParent(int n){\\n        if(isPowerTwo(n)){\\n            return n - 1;\\n        } else {\\n            int level_start = getLevelStart(n);\\n            int difference = (n - level_start)/2;\\n            return level_start - 1 - difference;\\n        }\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        while(label != 1){\\n            int parent = getParent(label);\\n            result.push_back(parent);\\n            label = parent;\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323848,
                "title": "golang-o-log-n-with-detail-explanation",
                "content": "\\n\\nWe first consider the normal case.\\n\\nObviously for a specific number, we can easily find the path from root to the node labeled with the number. \\n\\nFor example, **111 -> 11 -> 1**, **101 -> 10 -> 1**, **110 -> 11 -> 1**. Just shift the number one bit to the right and we can get the parent node of the number until we meet the root node labeled with 1.\\n![image](https://assets.leetcode.com/users/kerojin/image_1561907141.png)\\n\\nNow we consider the zigzag case.\\n![image](https://assets.leetcode.com/users/kerojin/image_1561907407.png)\\nCompared to the normal case, **it needs to convert the node to the symmetric node on the same level and get the parent node**\\n\\nFor example, **100 (--symmetric-> 111) -> 11 (--symmetric-> 10) -> 1, 101 (--symmetric-> 110) -> 11 (--symmetric->10) -> 1**\\n\\nHow to get the symmetric of the number on the same level? **The highest bit remains unchanged, the other bits are reversed**\\n> 1**110** -> 1**001**, we can find 1110+1001=**10111**=10000+1000-1, so **1001 = 10000+1000-1-1110**. That is what `1<<tb + 1<<(tb-1) - 1 - n` means.\\n\\n14(1**110**) --> 9(1**001**) -> 4(100)\\n4(1**00**) --> 7(1**11**) -> 3(11)\\n3(1**1**) --> 2(1**0**) -> 1\\n\\nso the path is 1->3->4->14\\n\\n26(1**1010**) --> 21(1**0101**) -> 10(1010)\\n10(1**010**) --> 13(1**101**) -> 6(110)\\n6(1**10**) --> 5(1**01**) -> 2(10)\\n2(1**0**) --> 3(1**1**) -> 1\\n\\nso the path is 1->2->6->10->26\\n\\n```go\\nfunc pathInZigZagTree(label int) []int {\\n\\tans := []int{label}\\n\\tfor label > 1 {\\n\\t\\tlabel = convert(label)\\n\\t\\tans = append(ans, label)\\n\\t}\\n\\tfor i, j := 0, len(ans)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tans[i], ans[j] = ans[j], ans[i]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc convert(n int) int {\\n\\ttb := uint(bits(n))\\n\\treturn symmetric(n, tb) >> 1\\n}\\n\\nfunc symmetric(n int, tb uint) int {\\n\\treturn 1<<tb + 1<<(tb-1) - 1 - n\\n}\\n\\nfunc bits(n int) int {\\n\\tr := 0\\n\\tfor n > 0 {\\n\\t\\tr++\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn r\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pathInZigZagTree(label int) []int {\\n\\tans := []int{label}\\n\\tfor label > 1 {\\n\\t\\tlabel = convert(label)\\n\\t\\tans = append(ans, label)\\n\\t}\\n\\tfor i, j := 0, len(ans)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tans[i], ans[j] = ans[j], ans[i]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc convert(n int) int {\\n\\ttb := uint(bits(n))\\n\\treturn symmetric(n, tb) >> 1\\n}\\n\\nfunc symmetric(n int, tb uint) int {\\n\\treturn 1<<tb + 1<<(tb-1) - 1 - n\\n}\\n\\nfunc bits(n int) int {\\n\\tr := 0\\n\\tfor n > 0 {\\n\\t\\tr++\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn r\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323302,
                "title": "c-log-n-intuitive-solution-with-algo-comments",
                "content": "1. First find level of label and index of given label in its respective level.\\n2. Go up the tree each level , index of parent will be half of children\\'s index in its respective level . Find label value considering zig zag in odd/even levels.\\n3. Reverse the array and return result\\n\\n```\\n\\t\\tint index=0;\\n        vector<int> res;\\n        res.push_back(label); // pushing given label in res\\n         int curr_level=0;  // this will serve as current level\\n        while(label>0)  // finding label\\'s level\\n        {\\n            int x = pow(2,curr_level);\\n            if(x<label)\\n\\t\\t\\t\\tlabel-=x;\\n            else\\n                break;\\n            curr_level++;\\n        }\\n        if(curr_level%2==0) // index of label in its level\\n            index= label-1;  \\n        else\\n            index = pow(2,curr_level)-label;\\n        \\n        while(curr_level>0)  // finding label\\'s parents indices\\n        {\\n            curr_level--;\\n            index=index/2; // index in its level\\n            if(curr_level%2==0)\\n                res.push_back(pow(2,curr_level)+index); // to find label value \\n            else\\n                res.push_back(pow(2,curr_level+1)-index-1);\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\t\\tint index=0;\\n        vector<int> res;\\n        res.push_back(label); // pushing given label in res\\n         int curr_level=0;  // this will serve as current level\\n        while(label>0)  // finding label\\'s level\\n        {\\n            int x = pow(2,curr_level);\\n            if(x<label)\\n\\t\\t\\t\\tlabel-=x;\\n            else\\n                break;\\n            curr_level++;\\n        }\\n        if(curr_level%2==0) // index of label in its level\\n            index= label-1;  \\n        else\\n            index = pow(2,curr_level)-label;\\n        \\n        while(curr_level>0)  // finding label\\'s parents indices\\n        {\\n            curr_level--;\\n            index=index/2; // index in its level\\n            if(curr_level%2==0)\\n                res.push_back(pow(2,curr_level)+index); // to find label value \\n            else\\n                res.push_back(pow(2,curr_level+1)-index-1);\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691083,
                "title": "java-solution-with-explanation",
                "content": "```\\n    // in a normally indexed tree, we can find the parent of a node by node.index/2\\n    // but in this case, some levels node indexes are reversed\\n    // original: 8 9 10 11 12 13 14 15 \\n    // current:  15 14 12 12 11 10 9 8\\n    // we want to find current 14\\'s parent which is original 9\\'s parent  9/2 = 4\\n    // how do we know 14\\'s corresponding reverse node is 9?\\n    // we can see that every original index + current index are the same\\n    // so we can get min and max of every level  -> min + max - 14 is the corresponding reversed index\\n    // step1: find target label\\'s level \\n    // step2: all the way up to root, every level, we get min, max, find reversed index -> parent add to result;\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int count = 0;\\n        while (label > count) {\\n            count += Math.pow(2, level); // 1  3 7 15\\n            level++;   // 1 2 3 4\\n        }\\n        level = level - 1;\\n        List<Integer> result = new ArrayList<>();\\n\\n        while (level >= 0) {\\n            result.add(0, label);\\n            int min = (int)Math.pow(2, level);\\n            int max = (int)Math.pow(2, level+1)-1;\\n            int reversedLabel = min + max - label;\\n            label = reversedLabel/2;\\n            level = level - 1;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    // in a normally indexed tree, we can find the parent of a node by node.index/2\\n    // but in this case, some levels node indexes are reversed\\n    // original: 8 9 10 11 12 13 14 15 \\n    // current:  15 14 12 12 11 10 9 8\\n    // we want to find current 14\\'s parent which is original 9\\'s parent  9/2 = 4\\n    // how do we know 14\\'s corresponding reverse node is 9?\\n    // we can see that every original index + current index are the same\\n    // so we can get min and max of every level  -> min + max - 14 is the corresponding reversed index\\n    // step1: find target label\\'s level \\n    // step2: all the way up to root, every level, we get min, max, find reversed index -> parent add to result;\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int count = 0;\\n        while (label > count) {\\n            count += Math.pow(2, level); // 1  3 7 15\\n            level++;   // 1 2 3 4\\n        }\\n        level = level - 1;\\n        List<Integer> result = new ArrayList<>();\\n\\n        while (level >= 0) {\\n            result.add(0, label);\\n            int min = (int)Math.pow(2, level);\\n            int max = (int)Math.pow(2, level+1)-1;\\n            int reversedLabel = min + max - label;\\n            label = reversedLabel/2;\\n            level = level - 1;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 323300,
                "title": "python-level-based-approach",
                "content": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n        level, tot = -1, 0\\n        while label > tot:\\n            level += 1\\n            tot += (2 ** level)\\n        \\n        level -= 1\\n        cur = label // 2\\n        res = [label]\\n        while level > -1:\\n            st, end = 2 ** level, (2 **(level+1)) - 1\\n            cur = st + end - cur\\n            res.append(cur)\\n            level -= 1\\n            cur = cur // 2\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n        level, tot = -1, 0\\n        while label > tot:\\n            level += 1\\n            tot += (2 ** level)\\n        \\n        level -= 1\\n        cur = label // 2\\n        res = [label]\\n        while level > -1:\\n            st, end = 2 ** level, (2 **(level+1)) - 1\\n            cur = st + end - cur\\n            res.append(cur)\\n            level -= 1\\n            cur = cur // 2\\n        return res[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 888006,
                "title": "java-100-o-log-n",
                "content": "plz do Upvote if you like the solution.\\n\\nclass Solution {\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result=new ArrayList<>();\\n        int parent=label;\\n        result.add(parent);\\n        while(parent !=1){\\n            int depth= (int) (Math.log(parent)/Math.log(2));\\n            int offset= (int) Math.pow(2,depth+1)-1-parent;\\n            parent= ((int) Math.pow(2,depth)+ offset)/2;\\n            result.add(parent);\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result=new ArrayList<>();\\n        int parent=label;\\n        result.add(parent);\\n        while(parent !=1){\\n            int depth= (int) (Math.log(parent)/Math.log(2));\\n            int offset= (int) Math.pow(2,depth+1)-1-parent;\\n            parent= ((int) Math.pow(2,depth)+ offset)/2;\\n            result.add(parent);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3263448,
                "title": "c-solution-with-explanation-beats-100",
                "content": "# Approach\\n1. Simply find the parent of a label as we find the parent of a node in complete binary tree (label/2).\\n2. Since upper level is in reverse order relative to the current level, therefore correct parent will be different. For example - if parent is 7 in complete binary tree, correct binary tree will be 4 in this case. If parent is 5 then correct parent will be 6.\\n3. For finding the correct parent of a node we need to subtract incorrect parent from the sum of minimum and maximum value of the previous level (4+7-(14/2)=4).\\n4. Minimum value in the previous level = 2^(current_height - 1).\\n5. Maximum value in the previous level = 2^(current_height)-1.\\n6. Therefore correct parent will be 2^(current_height - 1) + 2^(current_height)-1 + (label/2)\\n7. Repeat these steps untill we reach the root node.\\n\\n# Complexity\\n- Time complexity:\\n  O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height =log2(label);\\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(height){\\n            int left=pow(2,height-1);\\n            int right=pow(2,height)-1;\\n            label=left+right-(label/2);\\n            ans.push_back(label);\\n            height--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height =log2(label);\\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(height){\\n            int left=pow(2,height-1);\\n            int right=pow(2,height)-1;\\n            label=left+right-(label/2);\\n            ans.push_back(label);\\n            height--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608949,
                "title": "python-o-log-n-level-wise-parent-calculation",
                "content": "# Intuition\\nA starting point to solve this problem is to think of the much simpler case. when the labelling is always done from left-to-right. \\nIn that case, you may get the solution by simply dividing the current label by 2 until you reach the top (`1`). \\nHowever, we must make sure we divide the correct number by finding its symmetry in the level, hence, avoiding the fact that the labelling direction keeps switiching up.\\n\\n### Procedure\\n- We first determine the level of the label.\\n- We init the solutions list as a `deque` to prepend elements in `O(1)`\\n- We iterate starting from the label\\'s level up to the first level (`0`).\\n- We append the current label to the `deque`.\\n- We get the label of the previous level in one operation, it uses:\\n\\t- `last_element`: the last element in the current level: `2**l - 1`\\n\\t- `first_element`: the first element in the current level: `2**(l-1)`\\n\\t- The update operation is: `(last_element + first_element - label) // 2`\\n- Time: `O(log n)`, Space: `O(1)`\\n\\n```Python\\nfrom math import log\\nfrom collections import deque\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        level = int(log(label, 2))\\n        solution = deque()\\n        for l in range(level, -1, -1):\\n            solution.appendleft(label)\\n            label = (3*(2**l) - 1 - label) // 2\\n        return solution\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nfrom math import log\\nfrom collections import deque\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label):\\n        level = int(log(label, 2))\\n        solution = deque()\\n        for l in range(level, -1, -1):\\n            solution.appendleft(label)\\n            label = (3*(2**l) - 1 - label) // 2\\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572570,
                "title": "0ms-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int tmp = label;\\n        \\n        while (tmp != 0){\\n            tmp /= 2;\\n            level ++;\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        while (level > 0){\\n            res.add(label);\\n\\t\\t\\t/*At level n, the smallest label is 2^(n-1), the greatest label is 2^n - 1. \\n\\t\\t\\tThus a label plus its complementary label is equal to 2^(n-1) + 2^n - 1.\\n\\t\\t\\tThe predecessor of a node with label n has label n/2 if the labels are not reversed. \\n\\t\\t\\tNow that the labels are reversed every two levels, either the node itself or its predecessor is at a reversed level. \\n\\t\\t\\tSo to calculate the label of its predecessor, we use its complementary label / 2.*/\\n            label = (3 * (int)Math.pow(2, level - 1) - 1 -label);\\n            label /= 2;\\n            level --;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0;\\n        int tmp = label;\\n        \\n        while (tmp != 0){\\n            tmp /= 2;\\n            level ++;\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        while (level > 0){\\n            res.add(label);\\n\\t\\t\\t/*At level n, the smallest label is 2^(n-1), the greatest label is 2^n - 1. \\n\\t\\t\\tThus a label plus its complementary label is equal to 2^(n-1) + 2^n - 1.\\n\\t\\t\\tThe predecessor of a node with label n has label n/2 if the labels are not reversed. \\n\\t\\t\\tNow that the labels are reversed every two levels, either the node itself or its predecessor is at a reversed level. \\n\\t\\t\\tSo to calculate the label of its predecessor, we use its complementary label / 2.*/\\n            label = (3 * (int)Math.pow(2, level - 1) - 1 -label);\\n            label /= 2;\\n            level --;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396484,
                "title": "simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        // int parent = label;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        res.addFirst(label);\\n        \\n        while(label != 1){\\n            int level = (int)(Math.log(label)/Math.log(2))+1;\\n            int max = (int)Math.pow(2,level) - 1;\\n            int min = (int)Math.pow(2,level - 1);\\n            label = (int)(max + min - label)/2;\\n            \\n            res.addFirst(label);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        // int parent = label;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        res.addFirst(label);\\n        \\n        while(label != 1){\\n            int level = (int)(Math.log(label)/Math.log(2))+1;\\n            int max = (int)Math.pow(2,level) - 1;\\n            int min = (int)Math.pow(2,level - 1);\\n            label = (int)(max + min - label)/2;\\n            \\n            res.addFirst(label);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939470,
                "title": "c-simple-solution-beats-100",
                "content": "The approach is quite simple first of all we generate a path without the zigzag. i.e. we will just divide the number with two, to get its\\'s parent. then we will keep on storing it\\'s value into the ans vector.\\n\\nThe second step is mapping. There will always be elements in power of 2 on every level.\\n\\n```\\nsuppose we are dealing with level 3 i.e. 8 elements now if we invert the level each element will be mapped to it\\'s counter part;\\n\\n 1   2  3     4  5  6    7  8\\n |   |   |    |__|   |   |  |\\n |   |   |___________|   |  |\\n |   |___________________|  |\\n |__________________________|\\n \\n so we just have to find the corresponding element and scale it up i.e add the first element occuring in the corresponding level.\\n \\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        for(int i = label; i > 0; i/=2) {\\n            ans.push_back(i);  //pushing the parents without zigzag pattern\\n        }\\n        int aux = 4;\\n        reverse(ans.begin(), ans.end());\\n        for(int i = ans.size()-2; i > 0; i -=2 ){\\n            int l = log2(ans[i+1]);\\n            l = pow(2, l); //contains the number fo elements in that level\\n            int aux = log2(ans[i]);\\n            aux = pow(2, aux); //aux contain the value of the first element of that level\\n            ans[i] = aux + (l - ans[i])-1; //finding the corresponding element\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nsuppose we are dealing with level 3 i.e. 8 elements now if we invert the level each element will be mapped to it\\'s counter part;\\n\\n 1   2  3     4  5  6    7  8\\n |   |   |    |__|   |   |  |\\n |   |   |___________|   |  |\\n |   |___________________|  |\\n |__________________________|\\n \\n so we just have to find the corresponding element and scale it up i.e add the first element occuring in the corresponding level.\\n \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        for(int i = label; i > 0; i/=2) {\\n            ans.push_back(i);  //pushing the parents without zigzag pattern\\n        }\\n        int aux = 4;\\n        reverse(ans.begin(), ans.end());\\n        for(int i = ans.size()-2; i > 0; i -=2 ){\\n            int l = log2(ans[i+1]);\\n            l = pow(2, l); //contains the number fo elements in that level\\n            int aux = log2(ans[i]);\\n            aux = pow(2, aux); //aux contain the value of the first element of that level\\n            ans[i] = aux + (l - ans[i])-1; //finding the corresponding element\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455280,
                "title": "c-easy-to-understand-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>v;\\n        while(label>0) {\\n            v.push_back(label);\\n            label/=2;\\n        }\\n        for(int i=0;i<v.size();i++) {\\n            if(i%2==1) {\\n                int base=log2(v[i]);\\n                int add=pow(2,base+1)-1-v[i];\\n                v[i]=pow(2,base)+add;\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>v;\\n        while(label>0) {\\n            v.push_back(label);\\n            label/=2;\\n        }\\n        for(int i=0;i<v.size();i++) {\\n            if(i%2==1) {\\n                int base=log2(v[i]);\\n                int add=pow(2,base+1)-1-v[i];\\n                v[i]=pow(2,base)+add;\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556569,
                "title": "easy-to-understand-faser-than-100-11-lines",
                "content": "```\\n vector<int> pathInZigZagTree(int label) {\\n    int level = log(label) / log(2) + 1;  \\n    vector<int> path(level);\\n    while (label) {\\n        path[level - 1] = label;\\n        label = pow(2, level) - 1 - label + pow(2, level - 1);\\n        label >>= 1;\\n        level--;\\n    }\\n    return path;\\n }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> pathInZigZagTree(int label) {\\n    int level = log(label) / log(2) + 1;  \\n    vector<int> path(level);\\n    while (label) {\\n        path[level - 1] = label;\\n        label = pow(2, level) - 1 - label + pow(2, level - 1);\\n        label >>= 1;\\n        level--;\\n    }\\n    return path;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459714,
                "title": "c-easy-to-understand-0-ms",
                "content": "///\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> pathInZigZagTree(int n) {\\n        int lastValue = 1; // start and end of root node will be 1\\n        int currVal = 0 ; // To traverse to the given root/level\\n        \\n        while(currVal < n)\\n        {\\n            currVal += lastValue; // to reach the correct level\\n            lastValue *=2;\\n        }\\n        \\n        lastValue /=2; // to come back to the original level \\n        \\n        vector<int> ans;\\n        while( n != 1)\\n        {\\n            ans.emplace_back(n);\\n            int complement = 3*lastValue - n - 1; // start = lastValue , end = 2*lastValue-1 , compl = start + end - n;\\n            int parent = complement/2;   // parent = complement of n/2;\\n            n = parent;  // update number\\n            lastValue /=2; // decrease level\\n        }\\n        ans.emplace_back(1);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> pathInZigZagTree(int n) {\\n        int lastValue = 1; // start and end of root node will be 1\\n        int currVal = 0 ; // To traverse to the given root/level\\n        \\n        while(currVal < n)\\n        {\\n            currVal += lastValue; // to reach the correct level\\n            lastValue *=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1110443,
                "title": "c-o-logn-fundamental-approach",
                "content": "For a given label we can first find it\\'s distance from minimum/starting value in the given level. This can be given by:\\n**dist = label - pow(2, level)**\\n\\nwhere pow(2, level) gives the minimum value in the level.\\n\\nWe further divide it by 2 to get equivalent distance that gets reflected in previous level. (Property of binary tree - Number of nodes in previous level is half of current level.)\\n**dist = dist / 2**\\n\\nNow finally to get parent in previous level we just need to remove this **dist**  from greatest value in previous level.\\n**parent =  (pow(2, level) - 1) - dist**\\n\\nFinally return reverse of vector, since the calculation has been done in bottom up manner.\\n\\n```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int p = log2(label);\\n        \\n        res.push_back(label);\\n        \\n        while(p > 0) {\\n            int dist = (label - pow(2, p)) / 2;\\n            label =  pow(2, p) - 1 - dist;\\n\\n            res.push_back(label);         \\n            p--;\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int p = log2(label);\\n        \\n        res.push_back(label);\\n        \\n        while(p > 0) {\\n            int dist = (label - pow(2, p)) / 2;\\n            label =  pow(2, p) - 1 - dist;\\n\\n            res.push_back(label);         \\n            p--;\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497583,
                "title": "java-o-log-n-solution-using-the-path-and-symmetric-path",
                "content": "1. If the tree is not zigzag, what is the path to a number?\\n```\\n Stack<Integer> path = new Stack<>();\\n int tmp = label;\\n while(tmp > 1) {\\n\\t path.push(tmp % 2);\\n     tmp /= 2;\\n }\\n```\\n\\n2. Find the nodes on the path and the symmetric path: values[0] and values[1], for example: if the number is 26:\\n```\\nvalues[0] = [1, 2, 5, 10, 21]      <- symmetric path\\nvalues[1] = [1, 3, 6, 13, 26]      <- path to 26 in the non-zigzag tree.\\n```\\n3. So the path to the node in the zigzag tree: choose one from symmetric path and path alternatively.\\n```\\n[1, 2, 6, 10, 26]     <- path to 26 in the zigzag tree\\n```\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        Stack<Integer> path = new Stack<>();\\n        int tmp = label;\\n        while(tmp > 1) {\\n            path.push(tmp % 2);\\n            tmp /= 2;\\n        }\\n        int[][] values = new int[2][path.size() + 1];\\n        values[0][0] = 1;\\n        values[1][0] = 1;\\n        int step = 1;\\n        while(!path.isEmpty()) {\\n            int dir = path.pop();\\n            values[0][step] = values[0][step - 1] * 2 + (dir == 0 ? 1 : 0);\\n            values[1][step] = values[1][step - 1] * 2 + dir;\\n            ++step;\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        int index = step % 2;\\n        for(int i = 0; i < step; ++i) {\\n            res.add(values[(index + i) % 2][i]);\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n Stack<Integer> path = new Stack<>();\\n int tmp = label;\\n while(tmp > 1) {\\n\\t path.push(tmp % 2);\\n     tmp /= 2;\\n }\\n```\n```\\nvalues[0] = [1, 2, 5, 10, 21]      <- symmetric path\\nvalues[1] = [1, 3, 6, 13, 26]      <- path to 26 in the non-zigzag tree.\\n```\n```\\n[1, 2, 6, 10, 26]     <- path to 26 in the zigzag tree\\n```\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        Stack<Integer> path = new Stack<>();\\n        int tmp = label;\\n        while(tmp > 1) {\\n            path.push(tmp % 2);\\n            tmp /= 2;\\n        }\\n        int[][] values = new int[2][path.size() + 1];\\n        values[0][0] = 1;\\n        values[1][0] = 1;\\n        int step = 1;\\n        while(!path.isEmpty()) {\\n            int dir = path.pop();\\n            values[0][step] = values[0][step - 1] * 2 + (dir == 0 ? 1 : 0);\\n            values[1][step] = values[1][step - 1] * 2 + dir;\\n            ++step;\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        int index = step % 2;\\n        for(int i = 0; i < step; ++i) {\\n            res.add(values[(index + i) % 2][i]);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323837,
                "title": "java-java-solution-with-explanation",
                "content": "idea borrowed from @votrubac, and translate to Java\\nhttps://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/discuss/323293/C%2B%2B-O(log-n)\\n\\nThe basic idea is to get the height of the node in the tree and then traverse back to root which is the tricky part (since it is zigzaged).\\n\\nWe know that the target node\\'s actual parent should be the parent of its symmetric node at current height. So we first get the current height which is the first for loop. Then, to get the symmetric node, we first need to realize the fact: **(label of current node + label of symmetric node) == (label of minimum node at current height) + (label of maximum node at current height)** The minimum label can be calculated by 2^(level - 1) and maximum label can be calculated by 2^(level) - 1, where level is the current height. \\n\\n```\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int size = 1;\\n        int level = 1;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        while ((size << 1) <= label) {\\n            size <<= 1;\\n            level++;\\n        }\\n        while (label != 0) {\\n            res.addFirst(label);\\n            label = ((1 << level) - 1 + (1 << (level - 1)) - label) / 2; \\n            level--;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int size = 1;\\n        int level = 1;\\n        LinkedList<Integer> res = new LinkedList<>();\\n        while ((size << 1) <= label) {\\n            size <<= 1;\\n            level++;\\n        }\\n        while (label != 0) {\\n            res.addFirst(label);\\n            label = ((1 << level) - 1 + (1 << (level - 1)) - label) / 2; \\n            level--;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323676,
                "title": "python-simple-solution-with-explanation",
                "content": "First of all, ignore the fact that the binary tree is a zegzag labelled binary Tree. Simply assuming it\\'s a sequentially labelled binary tree. Then the path could be easily calculated.\\n\\nThe only difference between our assumption and the fact is that there are several different items. The ```key abservation``` is that we could easily find the complement of those different items, given the height of our item:\\n```complement = 2**(height+1) + 2**height - item``` \\n\\n```\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        while label:\\n            res.append(label)\\n            label /= 2\\n        res = res[::-1]\\n        for i in range(len(res)-2, 0, -2):\\n            res[i] = 2**(i+1) -1 + 2**i - res[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```key abservation```\n```complement = 2**(height+1) + 2**height - item```\n```\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        while label:\\n            res.append(label)\\n            label /= 2\\n        res = res[::-1]\\n        for i in range(len(res)-2, 0, -2):\\n            res[i] = 2**(i+1) -1 + 2**i - res[i]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323382,
                "title": "python-3-easy-explained",
                "content": "In normaly row-ordered binary tree we can find parent node by **label//2**, but in this problem we need to adjust calculation depending if current or previous row is inverted.\\n\\nE.g. label 14 is in negatively ordered row, so to find parent we adjust position - that is see 14 occupies place of 9, then divide 9 by 2, thus parent is 9//2 = 4.\\n\\nLabel 4 is in normally ordered row - we divide by 2, 4//2 = 2, but place of 2 in previous  row is occupied by 3, thus parent of 4 is 3.\\n\\nI created helper array to store order of every row to simplify thought process.\\n\\nSee how to find parents in rows, where row represented by tuple **(min_element_in_row, is_neg_order)**:\\n\\n(1, 0)\\n(2, 1) - inverted order, to find parent adjust current row position and divide by 2\\n(4, 0) - normal order, divide by 2 and adjust parent row position\\n(8, 1) - inverted order, to find parent adjust current row position and divide by 2\\n(16, 0) - normal order, divide by 2 and adjust parent row position\\nand so on...\\n    \\n```\\nclass Solution:\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        rows = [(1, 0)] #row represented by tuple (min_element_in_row, is_neg_order)\\n        while rows[-1][0]*2 <= label:\\n            rows.append((rows[-1][0]*2, 1 - rows[-1][1]))\\n            \\n        power, negOrder = rows.pop()\\n        \\n        res = []\\n        while label > 1:\\n            res.append(label)\\n                \\n            if negOrder:\\n                # adjust label position and find parent with division by 2\\n                # a, b - range of current row \\n                a, b = power, power*2 -1\\n                label = (a + (b - label))//2\\n            else:\\n                # divide label by 2 and adjust parent position\\n                # a, b - range of previous row\\n                a, b = power//2, power - 1\\n                label = b - (label//2 - a)\\n                \\n            power, negOrder = rows.pop()\\n            \\n                          \\n        res.append(1)\\n                          \\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        rows = [(1, 0)] #row represented by tuple (min_element_in_row, is_neg_order)\\n        while rows[-1][0]*2 <= label:\\n            rows.append((rows[-1][0]*2, 1 - rows[-1][1]))\\n            \\n        power, negOrder = rows.pop()\\n        \\n        res = []\\n        while label > 1:\\n            res.append(label)\\n                \\n            if negOrder:\\n                # adjust label position and find parent with division by 2\\n                # a, b - range of current row \\n                a, b = power, power*2 -1\\n                label = (a + (b - label))//2\\n            else:\\n                # divide label by 2 and adjust parent position\\n                # a, b - range of previous row\\n                a, b = power//2, power - 1\\n                label = b - (label//2 - a)\\n                \\n            power, negOrder = rows.pop()\\n            \\n                          \\n        res.append(1)\\n                          \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018989,
                "title": "simplest-solution-ever",
                "content": "# Code\\n```\\n#include<cmath>\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int level=0,a=label;\\n        vector<int> res;\\n        while(a>0){a=a/2;level++;}\\n        for(int i=level-1;i>0;i--){\\n            res.push_back(label);\\n            int x=(pow(2,i)+pow(2,i-1)-1);\\n            int y=label/2;\\n            label=x-y;\\n        }\\n        res.push_back(1);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n#include<cmath>\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int level=0,a=label;\\n        vector<int> res;\\n        while(a>0){a=a/2;level++;}\\n        for(int i=level-1;i>0;i--){\\n            res.push_back(label);\\n            int x=(pow(2,i)+pow(2,i-1)-1);\\n            int y=label/2;\\n            label=x-y;\\n        }\\n        res.push_back(1);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3221022,
                "title": "100-faster-time-o-n-space-o-ans-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) {\\n        vector<int> ans;\\n        int k = 0, y = x;\\n        while(y){\\n            k++;\\n            y >>= 1;\\n        }\\n        // cout<<k--<<\" \";\\n        --k;\\n        while(x>1){\\n            if(k&1){\\n                ans.push_back(x);\\n                x = (1<<(k+1))-x+(1<<k)-1;\\n                x >>= 1;\\n            }else{\\n                ans.push_back(x);\\n                x >>= 1;\\n                x = (1<<(k))-x+(1<<(k-1))-1;\\n            }\\n            k--;\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) {\\n        vector<int> ans;\\n        int k = 0, y = x;\\n        while(y){\\n            k++;\\n            y >>= 1;\\n        }\\n        // cout<<k--<<\" \";\\n        --k;\\n        while(x>1){\\n            if(k&1){\\n                ans.push_back(x);\\n                x = (1<<(k+1))-x+(1<<k)-1;\\n                x >>= 1;\\n            }else{\\n                ans.push_back(x);\\n                x >>= 1;\\n                x = (1<<(k))-x+(1<<(k-1))-1;\\n            }\\n            k--;\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3121699,
                "title": "binary-tree-not-required-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "# Intuition\\nBinary Tree Not Required\\n\\n# Approach\\n1. Create an array having all elements of every level till the level where our label element exists. Remeber to reverse the array for even number of levels. \\n=> arr.reverse();\\n2. Find the index of element where label exist from the last level of above array. \\n=> let indexOfLabelElement = array[array.length - 1].indexOf(label);\\n3. Find Parent of this level till we hit level 0. \\n=> Math.floor(indexOfLabelElement / 2);\\n\\n# Complexity\\n- Time complexity:\\n=> O(n)\\n\\n- Space complexity:\\n=> O(n)\\n\\n# Code\\n```\\nvar pathInZigZagTree = function(label) {\\n\\tlet array = [];\\n\\tlet currentLevel = 0;\\n\\tlet currentElement = 1;\\n\\tlet totalElementsBuild = 0;\\n\\twhile (totalElementsBuild < label) {\\n\\t\\tlet elementInCurrentLevel = Math.pow(2, currentLevel);\\n\\t\\ttotalElementsBuild += elementInCurrentLevel;\\n\\t\\tconst arr = [];\\n\\t\\twhile (elementInCurrentLevel--) {\\n\\t\\t\\tarr.push(currentElement++);\\n\\t\\t}\\n\\t\\tif (currentLevel % 2 !== 0) {\\n\\t\\t\\tarr.reverse();\\n\\t\\t}\\n\\t\\tarray.push(arr);\\n\\t\\tcurrentLevel++;\\n\\t}\\n\\tlet indexOfLabelElement = array[array.length - 1].indexOf(label);\\n\\tconst output = [ label ];\\n\\tfor (let index = array.length - 2; index >= 0; index--) {\\n\\t\\tindexOfLabelElement = Math.floor(indexOfLabelElement / 2);\\n\\t\\toutput.push(array[index][indexOfLabelElement]);\\n\\t}\\n\\treturn output.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathInZigZagTree = function(label) {\\n\\tlet array = [];\\n\\tlet currentLevel = 0;\\n\\tlet currentElement = 1;\\n\\tlet totalElementsBuild = 0;\\n\\twhile (totalElementsBuild < label) {\\n\\t\\tlet elementInCurrentLevel = Math.pow(2, currentLevel);\\n\\t\\ttotalElementsBuild += elementInCurrentLevel;\\n\\t\\tconst arr = [];\\n\\t\\twhile (elementInCurrentLevel--) {\\n\\t\\t\\tarr.push(currentElement++);\\n\\t\\t}\\n\\t\\tif (currentLevel % 2 !== 0) {\\n\\t\\t\\tarr.reverse();\\n\\t\\t}\\n\\t\\tarray.push(arr);\\n\\t\\tcurrentLevel++;\\n\\t}\\n\\tlet indexOfLabelElement = array[array.length - 1].indexOf(label);\\n\\tconst output = [ label ];\\n\\tfor (let index = array.length - 2; index >= 0; index--) {\\n\\t\\tindexOfLabelElement = Math.floor(indexOfLabelElement / 2);\\n\\t\\toutput.push(array[index][indexOfLabelElement]);\\n\\t}\\n\\treturn output.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683563,
                "title": "python3-xor-solution",
                "content": "Recently I learned about an interesting way to label complete binary trees. Where the nodes are labelled with bits where going left you append a \\'0\\' and if you go right, you append a \\'1\\'. Normally you can get the path (from leaf to root) by just bitshifting to the right each step. But since the even rows are flipped, you need to get the \"mirror image\" of some nodes in the path. To do that you can notice that to get the \"mirror image\" of a number on a certain level, you flip every bit except the leading 1.  To \"flip the bits\", you can use XOR\\n\\n![image](https://assets.leetcode.com/users/images/cc32b129-6888-440e-a69e-f507dfbcb750_1665613178.5220823.png)\\n\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        x = label\\n        mask = 0 \\n        while x > 1:\\n            x >>= 1\\n            mask <<= 1\\n            mask |= 1\\n            \\n        x = label\\n        res = deque()\\n        while x:\\n            res.appendleft(x)\\n            x >>= 1\\n            mask >>= 1\\n            x ^= mask\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        x = label\\n        mask = 0 \\n        while x > 1:\\n            x >>= 1\\n            mask <<= 1\\n            mask |= 1\\n            \\n        x = label\\n        res = deque()\\n        while x:\\n            res.appendleft(x)\\n            x >>= 1\\n            mask >>= 1\\n            x ^= mask\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471876,
                "title": "python-solution-know-your-tree-well",
                "content": "```\\nclass Solution:\\n    # Remember rule of binary tree parenthood:\\n    # ith node\\'s children are 2*i and 2*i+1 (i = 1, 2, ...)\\n    # First of all, given label, we know which level it is at: label.bit_length()-1\\n    # Now we have a zigzag situation\\n    # On ith row (with 2^i nodes 2^i, 2^i+1,... 2^(i+1) - 1)\\n    # if i is odd, it becomes reversed 2^(i+1)-1, 2^(i+1)-2,... 2^(i+1) - 2^i\\n    # Therefore we separate into two cases:\\n    # 1. if the node given is on an even level i\\n    # if label is odd / even, we know its parent is j = (label - 1)//2 / label//2\\n    # But we should output 2^i - (j - 2^(i-1) + 1)\\n    # If the node 2*j+1 / 2*j given is on an odd level i\\n    # We find its parent on the even level \\n    # which is 2^i - (j - 2^(i-1) + 1)\\n    \\n    def zigzagpath(self, label, path, level):\\n        while level > 0:\\n            path += [label]\\n            label //= 2\\n            parent_new = pow(2, level) - (label + 1 - pow(2,level-1))\\n            path += [parent_new]\\n            label //= 2\\n            level -= 2\\n        path.append(1)\\n        return path\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level, result = label.bit_length() - 1, []\\n        if level % 2 == 1:\\n            result.append(label)\\n            if label % 2 == 1:\\n                label -= 1\\n            label //= 2\\n            label = pow(2, level) - (label + 1 - pow(2,level-1))\\n            level -= 1\\n        return reversed(self.zigzagpath(label, result, level))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Remember rule of binary tree parenthood:\\n    # ith node\\'s children are 2*i and 2*i+1 (i = 1, 2, ...)\\n    # First of all, given label, we know which level it is at: label.bit_length()-1\\n    # Now we have a zigzag situation\\n    # On ith row (with 2^i nodes 2^i, 2^i+1,... 2^(i+1) - 1)\\n    # if i is odd, it becomes reversed 2^(i+1)-1, 2^(i+1)-2,... 2^(i+1) - 2^i\\n    # Therefore we separate into two cases:\\n    # 1. if the node given is on an even level i\\n    # if label is odd / even, we know its parent is j = (label - 1)//2 / label//2\\n    # But we should output 2^i - (j - 2^(i-1) + 1)\\n    # If the node 2*j+1 / 2*j given is on an odd level i\\n    # We find its parent on the even level \\n    # which is 2^i - (j - 2^(i-1) + 1)\\n    \\n    def zigzagpath(self, label, path, level):\\n        while level > 0:\\n            path += [label]\\n            label //= 2\\n            parent_new = pow(2, level) - (label + 1 - pow(2,level-1))\\n            path += [parent_new]\\n            label //= 2\\n            level -= 2\\n        path.append(1)\\n        return path\\n    \\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level, result = label.bit_length() - 1, []\\n        if level % 2 == 1:\\n            result.append(label)\\n            if label % 2 == 1:\\n                label -= 1\\n            label //= 2\\n            label = pow(2, level) - (label + 1 - pow(2,level-1))\\n            level -= 1\\n        return reversed(self.zigzagpath(label, result, level))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327791,
                "title": "java-array-solution",
                "content": "```\\nclass Solution {\\n    // storing tree in array\\n    public List<Integer> pathInZigZagTree(int n) {\\n        \\n        int arr[] = new int[1000000];   //space for storing tree \\n         \\n        // here don\\'t see the code think that you have to construct array as \\n        //     1 3 2 4 5 6 7 15 14 13 12 11 10 9 8 .........\\n        //     so jump to next comment\\n        \\n        int p = 1;\\n        for(int i = 0 ; i < n ; i++,p++){\\n            int x = (int)Math.pow(2, p-1);\\n            int start = 1,diff = 1;\\n            \\n            if(p%2 != 0){\\n              start = (int)Math.pow(2, p-1);\\n                diff = 1;\\n            } \\n            else{\\n              start = (int)Math.pow(2, p)-1;\\n                diff = -1;                \\n            }\\n            while(x > 0){\\n                if(i == arr.length) break;\\n                x--;\\n                arr[i++] = start;\\n                start += diff;\\n            }\\n            \\n                if(i == arr.length) break;\\n            i--;\\n       }\\n        // find the  n and start finding its parents\\n        //     since \\n        //     child = 2*parent + 1 || 2*parent + 2\\n        //     so in general we ge parent as \\n        //     parent = (child-1)/2 \\n        //      here parent and child are represented through index\\n            \\n        List<Integer> ans = new ArrayList<>();\\n        int i = 0;\\n        while(arr[i] != n){\\n            i++;\\n        }\\n        while(i>0){\\n            ans.add(arr[i]);\\n            i = (i-1)/2;\\n        }\\n        ans.add(arr[0]);\\n        // reverseing the arraylist\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    // storing tree in array\\n    public List<Integer> pathInZigZagTree(int n) {\\n        \\n        int arr[] = new int[1000000];   //space for storing tree \\n         \\n        // here don\\'t see the code think that you have to construct array as \\n        //     1 3 2 4 5 6 7 15 14 13 12 11 10 9 8 .........\\n        //     so jump to next comment\\n        \\n        int p = 1;\\n        for(int i = 0 ; i < n ; i++,p++){\\n            int x = (int)Math.pow(2, p-1);\\n            int start = 1,diff = 1;\\n            \\n            if(p%2 != 0){\\n              start = (int)Math.pow(2, p-1);\\n                diff = 1;\\n            } \\n            else{\\n              start = (int)Math.pow(2, p)-1;\\n                diff = -1;                \\n            }\\n            while(x > 0){\\n                if(i == arr.length) break;\\n                x--;\\n                arr[i++] = start;\\n                start += diff;\\n            }\\n            \\n                if(i == arr.length) break;\\n            i--;\\n       }\\n        // find the  n and start finding its parents\\n        //     since \\n        //     child = 2*parent + 1 || 2*parent + 2\\n        //     so in general we ge parent as \\n        //     parent = (child-1)/2 \\n        //      here parent and child are represented through index\\n            \\n        List<Integer> ans = new ArrayList<>();\\n        int i = 0;\\n        while(arr[i] != n){\\n            i++;\\n        }\\n        while(i>0){\\n            ans.add(arr[i]);\\n            i = (i-1)/2;\\n        }\\n        ans.add(arr[0]);\\n        // reverseing the arraylist\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187059,
                "title": "c-o-logn-solution",
                "content": "```\\n//if you draw the tree given in the problem statement you will notice that \\n//depending on the number of #bits of the current label the maximum value is pow(#ofbits)-1 and the size is pow(#bits-1)\\n//for example label = 14, so #bits = 4, so maxvalue = 15, sz = 8, so we will have\\n//15 14 13 12 11 10 9 8,\\n//now if you notice the above elements can be written as,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//where left operand is nothing but the parent of that respective label childs an\\n//another thing is to notice is that the second operand starts from 1 and after every two element skips the next element.\\n//and now if you number the indices you will see a way to find the second operand too,\\n//15 14 13 12 11 10 9 8,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//7,6,5,4,3,2,1,0,\\n//so for label 14 we have to subtract 10 to get the parent 4 , which are being done by,\\n//int ind = abs(sz-abs(maxValue-label)-1); //abs(8-abs(15-14)-1) = 6\\n//int minus = ind + floor(ind/2)+1; 6 + floor(6/2) +1 = 10 , so 14-10 = 4 which is the parent.\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n    \\n        vector<int>ans;\\n        int sz=0,maxValue=0,bits=0;\\n        \\n        while(label>=1){\\n            \\n            bits = log2(label)+1;\\n\\t\\t\\t\\n            maxValue = pow(2,bits)-1; //maxvalue of the level in which the current label is\\n\\t\\t\\tsz = pow(2,bits-1); //number of element in that level\\n            \\n            ans.push_back(label);\\n            int ind = abs(sz-abs(maxValue-label)-1); //index of the current label \\n            int minus = ind + floor(ind/2)+1; // the number upon substracting will give the current labels parent\\n            label = label-minus;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//if you draw the tree given in the problem statement you will notice that \\n//depending on the number of #bits of the current label the maximum value is pow(#ofbits)-1 and the size is pow(#bits-1)\\n//for example label = 14, so #bits = 4, so maxvalue = 15, sz = 8, so we will have\\n//15 14 13 12 11 10 9 8,\\n//now if you notice the above elements can be written as,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//where left operand is nothing but the parent of that respective label childs an\\n//another thing is to notice is that the second operand starts from 1 and after every two element skips the next element.\\n//and now if you number the indices you will see a way to find the second operand too,\\n//15 14 13 12 11 10 9 8,\\n//4+11, 4+10,5+8,5+7,6+5,6+4,7+2,7+1,\\n//7,6,5,4,3,2,1,0,\\n//so for label 14 we have to subtract 10 to get the parent 4 , which are being done by,\\n//int ind = abs(sz-abs(maxValue-label)-1); //abs(8-abs(15-14)-1) = 6\\n//int minus = ind + floor(ind/2)+1; 6 + floor(6/2) +1 = 10 , so 14-10 = 4 which is the parent.\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n    \\n        vector<int>ans;\\n        int sz=0,maxValue=0,bits=0;\\n        \\n        while(label>=1){\\n            \\n            bits = log2(label)+1;\\n\\t\\t\\t\\n            maxValue = pow(2,bits)-1; //maxvalue of the level in which the current label is\\n\\t\\t\\tsz = pow(2,bits-1); //number of element in that level\\n            \\n            ans.push_back(label);\\n            int ind = abs(sz-abs(maxValue-label)-1); //index of the current label \\n            int minus = ind + floor(ind/2)+1; // the number upon substracting will give the current labels parent\\n            label = label-minus;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915645,
                "title": "c-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=label;\\n        vector<int> ans;\\n        \\n        while(label!=0){\\n            if(label%2!=0){\\n                ans.push_back(label);\\n                --label;\\n                label/=2;\\n            }else{\\n                ans.push_back(label);\\n                label/=2;\\n            }\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        if(ans.size()%2==0){\\n            for(int i=3; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }else{\\n            for(int i=2; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=label;\\n        vector<int> ans;\\n        \\n        while(label!=0){\\n            if(label%2!=0){\\n                ans.push_back(label);\\n                --label;\\n                label/=2;\\n            }else{\\n                ans.push_back(label);\\n                label/=2;\\n            }\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        if(ans.size()%2==0){\\n            for(int i=3; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }else{\\n            for(int i=2; i<=ans.size(); i+=2){\\n                int lower = (1<<(i-1));\\n                int upper = (1<<i)-1;\\n                ans[i-1]=upper-ans[i-1]+lower;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668693,
                "title": "c-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/f101aca7-a3ab-4244-b142-fc8760722811_1641391858.5747855.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/0ee8c6aa-e426-4092-9248-d3d4d73a8355_1641391878.2286615.jpeg)\\n\\n\\n```\\n#define rep(i,a,b) for(int i=a ; i<(b) ; ++i )\\n#define endl \"\\\\n\"\\n#define pb push_back\\n#define ff first\\n#define ss second\\n#define endl \"\\\\n\"\\n#define debug(x) cout<<#x<<\" : \"<<x<<\"\\\\n\";\\n#define all(x) x.begin(), x.end()\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        \\n        // flips all the bits of x except the most significant bit //\\n        auto flip = [](int x){\\n        \\n            int lim = 31 - __builtin_clz(x);\\n\\n            int ans = 0;\\n\\n            rep(i,0,lim){\\n                if(!(x&(1<<i)))\\n                ans |= (1<<i);\\n            }\\n\\n            ans |= (x&(1<<lim));\\n\\n            return ans;\\n        };\\n        \\n        while(label!=1){\\n            \\n            res.pb(label);\\n\\n            label = flip(label);\\n\\n            label>>=1; // label/=2;\\n        }\\n        \\n        res.pb(1);\\n        reverse(all(res));\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define rep(i,a,b) for(int i=a ; i<(b) ; ++i )\\n#define endl \"\\\\n\"\\n#define pb push_back\\n#define ff first\\n#define ss second\\n#define endl \"\\\\n\"\\n#define debug(x) cout<<#x<<\" : \"<<x<<\"\\\\n\";\\n#define all(x) x.begin(), x.end()\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        \\n        // flips all the bits of x except the most significant bit //\\n        auto flip = [](int x){\\n        \\n            int lim = 31 - __builtin_clz(x);\\n\\n            int ans = 0;\\n\\n            rep(i,0,lim){\\n                if(!(x&(1<<i)))\\n                ans |= (1<<i);\\n            }\\n\\n            ans |= (x&(1<<lim));\\n\\n            return ans;\\n        };\\n        \\n        while(label!=1){\\n            \\n            res.pb(label);\\n\\n            label = flip(label);\\n\\n            label>>=1; // label/=2;\\n        }\\n        \\n        res.pb(1);\\n        reverse(all(res));\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1586393,
                "title": "c-solution-concise-includes-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int t=1;\\n        while(t<=label){\\n            t=t*2;\\n        }\\n        t/=2;   //Extrating the starting node value which belongs to the same level as label\\n        vector<int> ans;\\n        while(t>0){\\n            ans.push_back(label);\\n            label=(3*t-label-1)/2; //Using the value of label\\'s complement to get the parent value of label\\n            t/=2;\\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int t=1;\\n        while(t<=label){\\n            t=t*2;\\n        }\\n        t/=2;   //Extrating the starting node value which belongs to the same level as label\\n        vector<int> ans;\\n        while(t>0){\\n            ans.push_back(label);\\n            label=(3*t-label-1)/2; //Using the value of label\\'s complement to get the parent value of label\\n            t/=2;\\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364324,
                "title": "java-o-log-n",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 36.7 MB, less than 61.44% of Java online submissions for Path In Zigzag Labelled Binary Tree.**\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 1,labels = 1;\\n        List<Integer> res = new ArrayList();\\n        \\n        while(labels < label){\\n            labels += (int)Math.pow(2,level);\\n            level++;\\n        }\\n        \\n        while(label > 0){\\n            res.add(label);\\n            int max = (int)(Math.pow(2,level) - 1);\\n            int min = (int)Math.pow(2,level-1);\\n            label = (int)((max + min - label)/2);\\n            level--;\\n        }\\n        \\n        Collections.reverse(res);\\n        return res;\\n    }\\n}a\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 1,labels = 1;\\n        List<Integer> res = new ArrayList();\\n        \\n        while(labels < label){\\n            labels += (int)Math.pow(2,level);\\n            level++;\\n        }\\n        \\n        while(label > 0){\\n            res.add(label);\\n            int max = (int)(Math.pow(2,level) - 1);\\n            int min = (int)Math.pow(2,level-1);\\n            label = (int)((max + min - label)/2);\\n            level--;\\n        }\\n        \\n        Collections.reverse(res);\\n        return res;\\n    }\\n}a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328711,
                "title": "easy-and-simple-math-solution-100-faster-o-height-complexity-height-not-found",
                "content": "Every level starts with a power of 2 so by finding the log base of any number we can find its height, through which we can calculate the first element. Then what I\\'ve done is I halved the number and in the upper row we want the mirror of that number. By obesrvation, the difference of the number which we got after dividing by 2 which on subtracting with first element of the level, we can find its distance from the first element of that row. And its mirror which we require also has the same difference but from the last node of that level which is firstNum*2 - 1; And with putting it in loop, we\\'re done.\\n\\n\\n```\\n    public List<Integer> pathInZigZagTree(int num) {\\n        \\n        ArrayList<Integer> answer = new ArrayList<>();\\n        int baseExponent = (int)(Math.log(num)/Math.log(2));\\n        int basePow = 1 << baseExponent;\\n        \\n        int upperPow = basePow*2;\\n        \\n        while(num >= 1){\\n            \\n            answer.add(num);\\n            num = num/2;\\n            \\n            upperPow = basePow;\\n            basePow = basePow/2;\\n            \\n            int diff = num - basePow;\\n            \\n            num = upperPow - 1 - diff;\\n            \\n        }\\n        \\n        Collections.reverse(answer);\\n        \\n        return answer;\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int num) {\\n        \\n        ArrayList<Integer> answer = new ArrayList<>();\\n        int baseExponent = (int)(Math.log(num)/Math.log(2));\\n        int basePow = 1 << baseExponent;\\n        \\n        int upperPow = basePow*2;\\n        \\n        while(num >= 1){\\n            \\n            answer.add(num);\\n            num = num/2;\\n            \\n            upperPow = basePow;\\n            basePow = basePow/2;\\n            \\n            int diff = num - basePow;\\n            \\n            num = upperPow - 1 - diff;\\n            \\n        }\\n        \\n        Collections.reverse(answer);\\n        \\n        return answer;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290114,
                "title": "c-dequeue-bfs",
                "content": "**The idea is to first create a parent array using bfs for our elements\\nand then perform normal traversal using this parent array.\\nWe notice that on even levels we need to seek our last element of queue and push children in the front\\nand the opposite for odd levels. So the best possible data structure to use is deque.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label)\\n    {\\n        deque<int> q;//Our queue\\n        vector<int> par(1000002,-1);//Parent array\\n        q.push_front(1);\\n        int fl=1,br=0,curr=2;//Flag is fl, br is to break out when our children curr increases to >label\\n        while(!br)\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int x;\\n                if(fl)\\n                {\\n                    x=q.back();\\n                    q.pop_back();\\n                    q.push_front(curr),q.push_front(curr+1);\\n                }\\n                else\\n                {\\n                    x=q.front();\\n                    q.pop_front();\\n                    q.push_back(curr),q.push_back(curr+1); \\n                }\\n                curr+=2;\\n                //cout<<x<<endl;\\n                par[curr-2]=par[curr-1]=x;\\n                if(curr>label)\\n                {\\n                    br++;\\n                    break;\\n                }\\n            }\\n            fl=1-fl;//This flag determines whether we will (pop and push) or (push and pop) \\n        }\\n        vector<int> ans;\\n        int th=label;\\n        while(th!=-1)//Simple traversal using parent array and 1\\'s parent is -1\\n            ans.push_back(th),th=par[th];\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label)\\n    {\\n        deque<int> q;//Our queue\\n        vector<int> par(1000002,-1);//Parent array\\n        q.push_front(1);\\n        int fl=1,br=0,curr=2;//Flag is fl, br is to break out when our children curr increases to >label\\n        while(!br)\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int x;\\n                if(fl)\\n                {\\n                    x=q.back();\\n                    q.pop_back();\\n                    q.push_front(curr),q.push_front(curr+1);\\n                }\\n                else\\n                {\\n                    x=q.front();\\n                    q.pop_front();\\n                    q.push_back(curr),q.push_back(curr+1); \\n                }\\n                curr+=2;\\n                //cout<<x<<endl;\\n                par[curr-2]=par[curr-1]=x;\\n                if(curr>label)\\n                {\\n                    br++;\\n                    break;\\n                }\\n            }\\n            fl=1-fl;//This flag determines whether we will (pop and push) or (push and pop) \\n        }\\n        vector<int> ans;\\n        int th=label;\\n        while(th!=-1)//Simple traversal using parent array and 1\\'s parent is -1\\n            ans.push_back(th),th=par[th];\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1188725,
                "title": "c-bit-manipulation",
                "content": "HINT is find the parent of that label in non-zig-zag binary tree\\n\\nconsider , elements at odd level have been reversed in zig-zag binary treee\\n\\nThe parent of the current node is the , reverse element of the respective class of 2 power n - class here refers to elements having same MSB\\n\\nHere , MSB represents the depth of the binary tree element and its reversed element is obtained by , flipping all the bits from MSB+1 to zero \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        \\n        ans.push_back(label);\\n        while(label != 1){\\n            int msb = 0;\\n            for(int i=32;i>=0;--i){\\n                if(label&(1LL << i)){\\n                    msb = i;   //Depth of that element in the zig-zag binary tree is found\\n                    break;\\n                }\\n            }\\n            int num = 0;\\n            \\n            int i=0;\\n            while(i < msb){\\n                if(!(label & (1LL << i)))num += pow(2,i);\\n                ++i;\\n            }\\n            num += pow(2,msb); //original  element in the non-zig-zag binary tree\\n            ans.push_back(num/2);\\n            label = num/2;     //Its parent\\n            \\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n***For Recursion Lovers***\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> ans;\\n\\nvoid dfs(int label){\\n    if(label == 1)return ;\\n    \\n        int msb = 0;\\n        for(int i=32;i>=0;--i){\\n            if(label&(1LL << i)){\\n                msb = i; //depth\\n                break;\\n            }\\n        }\\n        int num = 0;\\n\\n        int i=0;\\n        while(i < msb){\\n            if(!(label & (1LL << i)))num += pow(2,i);\\n            ++i;\\n        }\\n        num += pow(2,msb);\\n        label = num/2;   //parent \\n        \\n        dfs(label);\\n        ans.push_back(label);\\n            \\n}\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        ans.clear();\\n        dfs(label);\\n        ans.push_back(label);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        \\n        ans.push_back(label);\\n        while(label != 1){\\n            int msb = 0;\\n            for(int i=32;i>=0;--i){\\n                if(label&(1LL << i)){\\n                    msb = i;   //Depth of that element in the zig-zag binary tree is found\\n                    break;\\n                }\\n            }\\n            int num = 0;\\n            \\n            int i=0;\\n            while(i < msb){\\n                if(!(label & (1LL << i)))num += pow(2,i);\\n                ++i;\\n            }\\n            num += pow(2,msb); //original  element in the non-zig-zag binary tree\\n            ans.push_back(num/2);\\n            label = num/2;     //Its parent\\n            \\n            \\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nvector<int> ans;\\n\\nvoid dfs(int label){\\n    if(label == 1)return ;\\n    \\n        int msb = 0;\\n        for(int i=32;i>=0;--i){\\n            if(label&(1LL << i)){\\n                msb = i; //depth\\n                break;\\n            }\\n        }\\n        int num = 0;\\n\\n        int i=0;\\n        while(i < msb){\\n            if(!(label & (1LL << i)))num += pow(2,i);\\n            ++i;\\n        }\\n        num += pow(2,msb);\\n        label = num/2;   //parent \\n        \\n        dfs(label);\\n        ans.push_back(label);\\n            \\n}\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        ans.clear();\\n        dfs(label);\\n        ans.push_back(label);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182182,
                "title": "c-log-n-intuitive-approach-time-better-than-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height=0;\\n        while(pow(2,height)<=label)\\n        {\\n            height=height+1;\\n        }\\n        cout<<height;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        // label=pow(2,height-1)-label/2+pow(2,height-2);\\n         while(height>1)\\n         {\\n             int father=pow(2,height-1)-1-label/2+pow(2,height-2);\\n             label=father;\\n             height=height-1;\\n             ans.push_back(father);\\n         }\\n        // ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int height=0;\\n        while(pow(2,height)<=label)\\n        {\\n            height=height+1;\\n        }\\n        cout<<height;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        // label=pow(2,height-1)-label/2+pow(2,height-2);\\n         while(height>1)\\n         {\\n             int father=pow(2,height-1)-1-label/2+pow(2,height-2);\\n             label=father;\\n             height=height-1;\\n             ans.push_back(father);\\n         }\\n        // ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1104927,
                "title": "c-faster-than-100-solution",
                "content": "ALGORITHM: \\n\\n1. Find the false parent. ( false parent is half of child 2 i.e. 7 for 14 and 15).\\n2. Find mirror of false parent.\\n3. Push the mirror into stack.\\n4. Reverse the stack into a vector.\\n        \\n---------------------------\\n        \\n-> False parent is half of the child.\\n-> mirror is reflection of node in other half of tree.\\n\\nHere goes the code ,\\n\\n```\\nclass Solution {\\npublic:\\n    int findMirror(int label){\\n        \\n        int x = label;\\n        int level =-1;\\n        \\n        while(x!=0){\\n            x = x>>1;\\n            level++;\\n        }\\n        \\n        int lowerB = 1<<level;\\n        int upperB = (1<<(level+1)) -1;\\n        \\n        int gap = label-lowerB;\\n        \\n        \\n        return abs(upperB-gap);\\n    }\\n    \\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        stack<int>st;\\n        vector<int>ans;\\n        st.push(label);\\n        \\n        while(label !=1){\\n            \\n            int falseParent = label/2;\\n            int mirror = findMirror(falseParent);\\n            st.push(mirror);\\n            label = mirror;\\n        }\\n        \\n        while(st.size()!=0){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMirror(int label){\\n        \\n        int x = label;\\n        int level =-1;\\n        \\n        while(x!=0){\\n            x = x>>1;\\n            level++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1020294,
                "title": "intuitive-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0, n = label;\\n        while(n != 0)\\n        {\\n            level ++;\\n            n = n / 2;\\n        }\\n        int[] res = new int[level];\\n        res[level - 1] = label;\\n        for(int l = level - 2; l >= 0; l --)\\n        {\\n            label = label / 2;\\n            if((level - l) % 2 == 1)\\n                res[l] = label;\\n            else\\n                res[l] = (int)Math.pow(2, l + 1) - 1 - label + (int)Math.pow(2, l);\\n        }\\n        List<Integer> l = new ArrayList<>();\\n        for(int e : res)\\n            l.add(e);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int level = 0, n = label;\\n        while(n != 0)\\n        {\\n            level ++;\\n            n = n / 2;\\n        }\\n        int[] res = new int[level];\\n        res[level - 1] = label;\\n        for(int l = level - 2; l >= 0; l --)\\n        {\\n            label = label / 2;\\n            if((level - l) % 2 == 1)\\n                res[l] = label;\\n            else\\n                res[l] = (int)Math.pow(2, l + 1) - 1 - label + (int)Math.pow(2, l);\\n        }\\n        List<Integer> l = new ArrayList<>();\\n        for(int e : res)\\n            l.add(e);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017882,
                "title": "c-solution-faster-than-100-solution-0-ms",
                "content": "I tried to give as obvious variable names as possible.\\nobs_parent is the observed parent\\n```\\nclass Solution {\\npublic:\\n    int getParent(int n){\\n        int level = 0;\\n        int sum = 0;\\n        while(sum < n){\\n            sum += pow(2, level);\\n            level++;\\n        }\\n        level -= 1;\\n        int end = sum - pow(2, level);\\n        int start = (end - pow(2, level - 1)) + 1;\\n        int range = end - start + 1;\\n        int realParent = n / 2;\\n        int obs_parent;\\n        if(realParent < start + (range / 2)){\\n            obs_parent = end - (realParent - start);\\n        }\\n        else{\\n            obs_parent = start + (end - realParent);\\n        }\\n        return obs_parent;\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        if(label == 1)  return {1};\\n        vector<int> result;\\n        result.insert(result.begin(), label);\\n        int parent = 0;\\n        while(parent != 1){\\n            parent = getParent(label);\\n            result.insert(result.begin(), parent);\\n            label = parent;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getParent(int n){\\n        int level = 0;\\n        int sum = 0;\\n        while(sum < n){\\n            sum += pow(2, level);\\n            level++;\\n        }\\n        level -= 1;\\n        int end = sum - pow(2, level);\\n        int start = (end - pow(2, level - 1)) + 1;\\n        int range = end - start + 1;\\n        int realParent = n / 2;\\n        int obs_parent;\\n        if(realParent < start + (range / 2)){\\n            obs_parent = end - (realParent - start);\\n        }\\n        else{\\n            obs_parent = start + (end - realParent);\\n        }\\n        return obs_parent;\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        if(label == 1)  return {1};\\n        vector<int> result;\\n        result.insert(result.begin(), label);\\n        int parent = 0;\\n        while(parent != 1){\\n            parent = getParent(label);\\n            result.insert(result.begin(), parent);\\n            label = parent;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791993,
                "title": "explained-python-easy-to-understand-1-line-concept",
                "content": "We start from the label and stop till we get 1. \\n\\nLogic: \\nIf num = \\'1001\\' (binary format), then it\\'s parent will be \\'1\\' + inverted(num[1:-1])\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        res = []\\n        \\n        while label != 1:\\n            res.append(label)\\n            label = int(\\'1\\' + \"\".join(map(lambda x: \\'1\\' if x == \\'0\\' else \\'0\\', format(label, \\'b\\')[1:-1])), 2)\\n        res.append(1)\\n        \\n        return reversed(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        \\n        res = []\\n        \\n        while label != 1:\\n            res.append(label)\\n            label = int(\\'1\\' + \"\".join(map(lambda x: \\'1\\' if x == \\'0\\' else \\'0\\', format(label, \\'b\\')[1:-1])), 2)\\n        res.append(1)\\n        \\n        return reversed(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657156,
                "title": "java-very-clean-solution-runs-in-0ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (label != 0) {\\n            list.addFirst(label);\\n            label = getParent(label);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private int getParent(int label) {\\n        int highestBit = 1 << (int) (Math.log(label) / Math.log(2));\\n        int position = label ^ highestBit;\\n        \\n        int parent = highestBit - position / 2 - 1;\\n        return parent;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (label != 0) {\\n            list.addFirst(label);\\n            label = getParent(label);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private int getParent(int label) {\\n        int highestBit = 1 << (int) (Math.log(label) / Math.log(2));\\n        int position = label ^ highestBit;\\n        \\n        int parent = highestBit - position / 2 - 1;\\n        return parent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634695,
                "title": "python-easy-to-understand-faster-than-91-93-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\n        #Base case\\n        if label == 1:\\n            return [1]\\n        \\n\\t\\t# Calculate the level that the label is present in \\n        level = 1\\n        while True:\\n            if (2**level - 1 >= label):\\n\\t\\t\\t\\tbreak\\n            level += 1\\n            \\t\\n        pathArray = [label]\\n\\t\\t# reduce level by 1 since we have already added label to the path array\\n        level -= 1\\n        \\n\\t\\t# Base case\\n        while level != 0:\\n            \\n\\t\\t\\t# calculating parent \\n            label = 2**(level-1) + ((2**(level+1) - 1 - label)//2)\\n\\t\\t    # insert parent to the top\\n            pathArray.insert(0, label)\\n            level -= 1\\n            \\n        return pathArray\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\n        #Base case\\n        if label == 1:\\n            return [1]\\n        \\n\\t\\t# Calculate the level that the label is present in \\n        level = 1\\n        while True:\\n            if (2**level - 1 >= label):\\n\\t\\t\\t\\tbreak\\n            level += 1\\n            \\t\\n        pathArray = [label]\\n\\t\\t# reduce level by 1 since we have already added label to the path array\\n        level -= 1\\n        \\n\\t\\t# Base case\\n        while level != 0:\\n            \\n\\t\\t\\t# calculating parent \\n            label = 2**(level-1) + ((2**(level+1) - 1 - label)//2)\\n\\t\\t    # insert parent to the top\\n            pathArray.insert(0, label)\\n            level -= 1\\n            \\n        return pathArray\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593865,
                "title": "100-time-space-solution-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<int>ans;\\n        int level=0;\\n        int x = pow(2,0);\\n        while (label>=x)\\n        {\\n            level++;\\n            x=pow(2,level);\\n        }\\n        ans.push_back(label);\\n        level--;\\n        label/=2;\\n        while(label>=1)\\n        {\\n            label = pow(2,level)-1+pow(2,level-1)-label;\\n            ans.push_back(label);\\n            label/=2;\\n            level--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<int>ans;\\n        int level=0;\\n        int x = pow(2,0);\\n        while (label>=x)\\n        {\\n            level++;\\n            x=pow(2,level);\\n        }\\n        ans.push_back(label);\\n        level--;\\n        label/=2;\\n        while(label>=1)\\n        {\\n            label = pow(2,level)-1+pow(2,level-1)-label;\\n            ans.push_back(label);\\n            label/=2;\\n            level--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538505,
                "title": "go-golang-0ms-solution",
                "content": "```\\nfunc findLevel(label int) (int, int, int) {\\n    s := 1\\n    n := 0\\n    for {\\n        if label >= s && label < s * 2 {\\n            return n, s, s * 2 - 1\\n        }\\n        n ++\\n        s = s * 2\\n    }\\n}\\n\\nfunc pathInZigZagTree(label int) []int {\\n    level, min, max := findLevel(label)   \\n    res := make([]int, level + 1)\\n    res[level] = label\\n    for label != 1 {\\n        label = label / 2\\n        level --\\n        min = min / 2\\n        max = max / 2\\n        label = max - label + min\\n        res[level] =  label\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findLevel(label int) (int, int, int) {\\n    s := 1\\n    n := 0\\n    for {\\n        if label >= s && label < s * 2 {\\n            return n, s, s * 2 - 1\\n        }\\n        n ++\\n        s = s * 2\\n    }\\n}\\n\\nfunc pathInZigZagTree(label int) []int {\\n    level, min, max := findLevel(label)   \\n    res := make([]int, level + 1)\\n    res[level] = label\\n    for label != 1 {\\n        label = label / 2\\n        level --\\n        min = min / 2\\n        max = max / 2\\n        label = max - label + min\\n        res[level] =  label\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486736,
                "title": "ease-javascript-solution",
                "content": "```\\n/**\\n * @param {number} label\\n * @return {number[]}\\n */\\nvar pathInZigZagTree = function(label) {\\n    let level = 0, res = [label];\\n    // get label\\'s level\\n    while(label = parseInt(label / 2)) {\\n        level++;\\n    }\\n    \\n    // 1. every level\\'s number is in [Math.pow(2, level), Math.pow(2, level + 1) - 1]\\n    // 2. node[level - 1] = parseInt(res[level] / 2)\\n    // 3. res[level - 1] = (Math.pow(2, level) + Math.pow(2, level + 1) - 1) - node[level - 1] is the parent node we need;\\n    for(let i = level - 1; i >= 0; i--) {\\n        let sum = (2 ** i) + (2 ** (i + 1)) - 1;\\n        let val = parseInt(res[0] / 2);\\n        res.unshift(sum - val);\\n    }\\n    return res;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} label\\n * @return {number[]}\\n */\\nvar pathInZigZagTree = function(label) {\\n    let level = 0, res = [label];\\n    // get label\\'s level\\n    while(label = parseInt(label / 2)) {\\n        level++;\\n    }\\n    \\n    // 1. every level\\'s number is in [Math.pow(2, level), Math.pow(2, level + 1) - 1]\\n    // 2. node[level - 1] = parseInt(res[level] / 2)\\n    // 3. res[level - 1] = (Math.pow(2, level) + Math.pow(2, level + 1) - 1) - node[level - 1] is the parent node we need;\\n    for(let i = level - 1; i >= 0; i--) {\\n        let sum = (2 ** i) + (2 ** (i + 1)) - 1;\\n        let val = parseInt(res[0] / 2);\\n        res.unshift(sum - val);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473751,
                "title": "easy-to-understand-python3-solution-with-explanation",
                "content": "The logic consists of three components:\\n* Any number will always be in level : floor(log2(number)). Therefore given the label we can get the level it will be in.\\n* In a normal tree, the leftmost node in a level will have value : 2^(level - 1)\\n* In a normal tree, the rightmost node in a level will have value: 2^(level) - 1\\n* In the zigzag tree, the leftmost and rightmost node limits are interchanged alternatively. However since we are going to add these values, it does not matter.\\n* From the tree and the limits for a level above, we can see that for any node, its parent is : (leftmost limit + rightmost limit - label) // 2\\n* This implies parent(label) = (2^(level - 1) + 2^(level) - 1 - label) // 2.\\n* We can do this operation repeatedly to trace the path to the parent.\\n```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        res = [label]\\n        level = math.floor(math.log(label, 2)) + 1\\n        currentNode = label\\n        while level > 1:\\n            parent = (2**(level-1) + 2**(level) - 1 - currentNode) // 2\\n            res.insert(0, parent)\\n            currentNode = parent\\n            level -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        res = [label]\\n        level = math.floor(math.log(label, 2)) + 1\\n        currentNode = label\\n        while level > 1:\\n            parent = (2**(level-1) + 2**(level) - 1 - currentNode) // 2\\n            res.insert(0, parent)\\n            currentNode = parent\\n            level -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443958,
                "title": "c-100-runtime-100-mem",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n       int low = log2 (label);\\n        vector<int> ans (low+1);\\n        int cur = 0;\\n        ans[0] = 1;\\n        ans[low] = label;\\n        for (int i = low - 1; i > 0; i--) {\\n            cur = (pow(2, low+1) - ans[i+1] + pow(2, low) - 1)/2;\\n            ans[i] = cur;\\n            low--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n       int low = log2 (label);\\n        vector<int> ans (low+1);\\n        int cur = 0;\\n        ans[0] = 1;\\n        ans[low] = label;\\n        for (int i = low - 1; i > 0; i--) {\\n            cur = (pow(2, low+1) - ans[i+1] + pow(2, low) - 1)/2;\\n            ans[i] = cur;\\n            low--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427306,
                "title": "golang-bottom-to-top-solution-cost-logn",
                "content": "```\\nfunc pathInZigZagTree(label int) []int {\\n\\tvar res []int\\n\\tres = append(res, label)\\n\\tvar layer_num int = math.Ilogb(float64(label))\\n    if layer_num == 0{\\n        return res\\n    }\\n\\tfor layer_num > 1{\\n\\t\\tvar parent int = label/2\\n\\t\\tlayer_min := int(math.Pow(2,float64(layer_num - 1)))\\n\\t\\tlayer_max := int(math.Pow(2,float64(layer_num)) - 1)\\n\\t\\tparent = layer_max - (parent - layer_min)\\n\\t\\tlabel = parent\\n\\t\\tlayer_num--\\n\\t\\tres = append(res, parent)\\n\\t}\\n\\tres = append(res, 1)\\n\\tfor i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tres[i], res[j] = res[j], res[i]\\n\\t} \\n\\treturn res\\n}",
                "solutionTags": [],
                "code": "```\\nfunc pathInZigZagTree(label int) []int {\\n\\tvar res []int\\n\\tres = append(res, label)\\n\\tvar layer_num int = math.Ilogb(float64(label))\\n    if layer_num == 0{\\n        return res\\n    }\\n\\tfor layer_num > 1{\\n\\t\\tvar parent int = label/2\\n\\t\\tlayer_min := int(math.Pow(2,float64(layer_num - 1)))\\n\\t\\tlayer_max := int(math.Pow(2,float64(layer_num)) - 1)\\n\\t\\tparent = layer_max - (parent - layer_min)\\n\\t\\tlabel = parent\\n\\t\\tlayer_num--\\n\\t\\tres = append(res, parent)\\n\\t}\\n\\tres = append(res, 1)\\n\\tfor i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tres[i], res[j] = res[j], res[i]\\n\\t} \\n\\treturn res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 359041,
                "title": "python-3-short-solution",
                "content": "```\\nfrom math import log\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        line, result = int(log(label, 2)), [label]\\n        \\n        while line:            \\n\\t\\t    # calculate offset to the left or right side\\n            offset = result[-1] - 2 ** line\\n\\t\\t\\t# subtract current offset and parent offset\\n            result.append(result[-1] - offset - (offset // 2 + 1))\\n            line -= 1\\n            \\n        return result[::-1]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import log\\n\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        line, result = int(log(label, 2)), [label]\\n        \\n        while line:            \\n\\t\\t    # calculate offset to the left or right side\\n            offset = result[-1] - 2 ** line\\n\\t\\t\\t# subtract current offset and parent offset\\n            result.append(result[-1] - offset - (offset // 2 + 1))\\n            line -= 1\\n            \\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325180,
                "title": "o-logn-java-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/arif32/image_1562050357.png)\\n\\n```\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\t\\tList<Integer> result = new LinkedList<Integer>();\\n\\t\\tresult.add(label);\\n        int height = findHeight(label);\\n\\t\\twhile (label != 1) {\\n\\t\\t\\tint parent = label / 2;\\n\\t\\t\\t--height;\\n\\t\\t\\tint start = (int) (Math.pow(2, height));\\n\\t\\t\\tint end = start + (int) (Math.pow(2, height)) - 1;\\n\\t\\t\\tlabel = start + (end - parent); // reverse index\\n\\t\\t\\tresult.add(0, label);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tint findHeight(int n) {\\n\\t\\tint height = 0;\\n\\t\\twhile (n != 1) {\\n\\t\\t\\tn = n / 2;\\n\\t\\t\\theight++;\\n\\t\\t}\\n\\t\\treturn height;\\n\\t}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\t\\tList<Integer> result = new LinkedList<Integer>();\\n\\t\\tresult.add(label);\\n        int height = findHeight(label);\\n\\t\\twhile (label != 1) {\\n\\t\\t\\tint parent = label / 2;\\n\\t\\t\\t--height;\\n\\t\\t\\tint start = (int) (Math.pow(2, height));\\n\\t\\t\\tint end = start + (int) (Math.pow(2, height)) - 1;\\n\\t\\t\\tlabel = start + (end - parent); // reverse index\\n\\t\\t\\tresult.add(0, label);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tint findHeight(int n) {\\n\\t\\tint height = 0;\\n\\t\\twhile (n != 1) {\\n\\t\\t\\tn = n / 2;\\n\\t\\t\\theight++;\\n\\t\\t}\\n\\t\\treturn height;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324913,
                "title": "dew-it-simple-logic-o-log-n-100-100",
                "content": "## The Approach\\nThings we need to note are as follows:\\n* MAX value at each level is:\\ndepth 1: **1** = 2^1 - 1\\ndepth 2: **3** = 2^2 - 1\\ndepth 3: **7** = 2^3 - 1\\n.\\n.\\ndepth n: **x** = ***(2^n) - 1***\\n* Similarly, the MIN value at each level is ***2^(n-1)***\\n* In a **normal tree** (without zig zag), the parent of any node n will have the value [n/2]\\n=>Example: parent of 3 is [3/2] = 1\\n* The parent of a node n in a **normal tree** would be at index (n/2 - MIN value of previous level)\\n=>Example, parent of 10 is 5. MIN value of the level is 4. Hence index of 5 in previous row is 1\\n* In a **zig zag tree**, the index of the parent will be inverted. If there are r elements in the array, index i inverted will be [r-1-i] (first element becomes last and so on)\\n=> If we take the same example of 10, the index in the normal tree is 1\\n=> Number of elements in the parent row = 4 (values from 4 to 7)\\n=> Index in the inverted row is 4 - 1 - 1 = 2\\n=> This simply means that the actual parent of 10 in a zig zag tree is the second element starting from 4 (which happens to be 6 as shown in the example image in the description of the problem)\\n\\nWe use this basic idea to compute parents for labels and further recursively find their parents.\\n\\nNote:\\n* We first construct the path starting with required label and then go upwards in the tree. Because of this, we need to invert the answer arraylist before returning\\n* A variable named \"seed\" is frequently seen in my code. It is simply the smallest element in the row that we are currently looking at\\n\\n## The Code\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n        int seed = 1;\\n        while(seed <= label) seed *= 2;\\n        seed /= 2;\\n        get(label, ans, seed);\\n\\t\\t\\n        int n = ans.size();\\n        for(int i=0; i<n/2; ++i) {\\n            int temp = ans.get(i);\\n            ans.set(i, ans.get(n-1-i));\\n            ans.set(n-1-i, temp);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n    \\n    private void get(int label, List<Integer> ans, int seed) {\\n        if(label > 0) {\\n            ans.add(label);\\n            int newLabel = label/2 - seed/2;\\n            newLabel = seed - 1 - newLabel;\\n            get(newLabel, ans, seed/2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n        int seed = 1;\\n        while(seed <= label) seed *= 2;\\n        seed /= 2;\\n        get(label, ans, seed);\\n\\t\\t\\n        int n = ans.size();\\n        for(int i=0; i<n/2; ++i) {\\n            int temp = ans.get(i);\\n            ans.set(i, ans.get(n-1-i));\\n            ans.set(n-1-i, temp);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n    \\n    private void get(int label, List<Integer> ans, int seed) {\\n        if(label > 0) {\\n            ans.add(label);\\n            int newLabel = label/2 - seed/2;\\n            newLabel = seed - 1 - newLabel;\\n            get(newLabel, ans, seed/2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063088,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n     // taken help\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n     // taken help\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591629,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l = label;\\n        int n{};\\n        //getting the depth of required node\\n        while(l){\\n            n++;\\n            l >>= 1; // dividing by 2\\n        }\\n\\n        vector<int> ans(n);\\n        ans[n-1] = label;\\n        for(int i = n-2; i>=0;i--){\\n            ans[i] = (3*(1<<(i+1)) - ans[i+1] - 1)/2; \\n            // (1 << i) = 2 raise to power i\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l = label;\\n        int n{};\\n        //getting the depth of required node\\n        while(l){\\n            n++;\\n            l >>= 1; // dividing by 2\\n        }\\n\\n        vector<int> ans(n);\\n        ans[n-1] = label;\\n        for(int i = n-2; i>=0;i--){\\n            ans[i] = (3*(1<<(i+1)) - ans[i+1] - 1)/2; \\n            // (1 << i) = 2 raise to power i\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340653,
                "title": "michael-scott-says-he-beat-this-100-on-java",
                "content": "# Intuition\\nMichael is busy at the moment(sleeping), just look at the code it is self explanatory \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224831,
                "title": "c-solution-beats-100-ii-simple-and-clean-code",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> r;\\n        r.push_back(label);\\n        int d=log2(label),m;\\n        while(d)\\n        {\\n            m=pow(2,d)+pow(2,d+1)-1-label;  //mirror w.r.to non zig zag version \\n            // OR you can do pow(2,d-1)+pow(2,d)-1-label/2;\\n            //4+7-(14/2) == 4+7-7 == 4 \\n            r.push_back(m/2);\\n            label=m/2;\\n            d--;\\n        }\\n        reverse(r.begin(),r.end());\\n        return r;\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> r;\\n        r.push_back(label);\\n        int d=log2(label),m;\\n        while(d)\\n        {\\n            m=pow(2,d)+pow(2,d+1)-1-label;  //mirror w.r.to non zig zag version \\n            // OR you can do pow(2,d-1)+pow(2,d)-1-label/2;\\n            //4+7-(14/2) == 4+7-7 == 4 \\n            r.push_back(m/2);\\n            label=m/2;\\n            d--;\\n        }\\n        reverse(r.begin(),r.end());\\n        return r;\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137820,
                "title": "python-bitwise-solution-with-explanation",
                "content": "Let us take an example of 4th level as  `[8, 9, 10, 11, 12, 13, 14, 15]`\\n```\\n[8, 9, 10, 11, 12, 13, 14, 15]   |   [\\'1000\\', \\'1001\\', \\'1010\\', \\'1011\\', \\'1100\\', \\'1101\\', \\'1110\\', \\'1111\\']\\n[15, 14, 13, 12, 11, 10, 9, 8]   |   [\\'1111\\', \\'1110\\', \\'1101\\', \\'1100\\', \\'1011\\', \\'1010\\', \\'1001\\', \\'1000\\']\\n```\\nWe can see that the zigzag fashion leads `ALL bits fliped EXCEPT the 1st \\'1\\'`\\n```\\n\\'1000\\' -> \\'1111\\', \\'1001\\' -> \\'1110\\', \\'1010\\'->\\'1101\\', \\'1011\\' -> \\'1100\\'\\n```\\nSo we can do bits flipping to get the parent node\\n```\\ndef pathInZigZagTree(self, x: int) -> List[int]:\\n\\tres = [x]\\n\\twhile(x>1):\\n\\t\\tx >>= 1                          # move to the parent level \\n\\t\\tx = x^(1<<(x.bit_length()-1))-1  # flipping all bits EXCEPT the 1st \\'1\\'\\n\\t\\tres.append(x)\\n\\treturn res[::-1]\\n```\\n\\nIf you are not comfortable with bitwise computation, the following line also works for `flipping bits `\\n```\\nx = int(\\'1\\'+\\'\\'.join(\\'1\\' if i==\\'0\\' else \\'0\\' for i in bin(x)[3:]), 2)\\n```",
                "solutionTags": [],
                "code": "```\\n[8, 9, 10, 11, 12, 13, 14, 15]   |   [\\'1000\\', \\'1001\\', \\'1010\\', \\'1011\\', \\'1100\\', \\'1101\\', \\'1110\\', \\'1111\\']\\n[15, 14, 13, 12, 11, 10, 9, 8]   |   [\\'1111\\', \\'1110\\', \\'1101\\', \\'1100\\', \\'1011\\', \\'1010\\', \\'1001\\', \\'1000\\']\\n```\n```\\n\\'1000\\' -> \\'1111\\', \\'1001\\' -> \\'1110\\', \\'1010\\'->\\'1101\\', \\'1011\\' -> \\'1100\\'\\n```\n```\\ndef pathInZigZagTree(self, x: int) -> List[int]:\\n\\tres = [x]\\n\\twhile(x>1):\\n\\t\\tx >>= 1                          # move to the parent level \\n\\t\\tx = x^(1<<(x.bit_length()-1))-1  # flipping all bits EXCEPT the 1st \\'1\\'\\n\\t\\tres.append(x)\\n\\treturn res[::-1]\\n```\n```\\nx = int(\\'1\\'+\\'\\'.join(\\'1\\' if i==\\'0\\' else \\'0\\' for i in bin(x)[3:]), 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3136729,
                "title": "python-solution-with-explanation-easy-to-understand",
                "content": "* How many levels will be there if n=14? The ans is 3 (level 0,level 1, level 2 and level3)\\n* How many levels will be there if n=16? The ans is 4.\\n* The number of levels in this binary tree will be [log2(n)] where [x] represents floor value. [3.99] = 3\\n* The levels in this tree are odd levels and even levels all odd,even levels follows same patterns respectively.\\n* for all odd level the parent can be calculated as `label = 2**(level-1)+(2**(level-1)-pos-1)`. i.e. decreasing respective positions.\\n* for all even level parent can be calculated as `2**(level) - 1 - pos`. Increasing respective positions\\n* for odd level example suppose we have` label = 13 and level = 3` its parent label will be `2**(3-1)+(2**(3-1)-((13-(2**3))//2-1)` that is `4+4-2-1` that is 5.\\n* for even level example suppose we have `label = 5 and level = 2` its parent label will be `2**(2) - 1 - (5-2**2)//2` that is 3.\\n\\n```\\nfrom math import log2,floor\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = floor(log2(label))\\n        ans = [label]\\n        while label!=1:\\n            c = label - 2**level\\n            pos = c//2\\n            if level&1:\\n                label = 2**(level-1)+(2**(level-1)-pos-1)\\n            else:\\n                label = 2**(level) - 1 - pos\\n            level -= 1\\n            ans.append(label)\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nfrom math import log2,floor\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = floor(log2(label))\\n        ans = [label]\\n        while label!=1:\\n            c = label - 2**level\\n            pos = c//2\\n            if level&1:\\n                label = 2**(level-1)+(2**(level-1)-pos-1)\\n            else:\\n                label = 2**(level) - 1 - pos\\n            level -= 1\\n            ans.append(label)\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026396,
                "title": "beats-100",
                "content": "# Code\\n```\\nint parent(int n){\\n    int org=n/2;\\n    if(n==1) return -1;\\n    int x=log2(n)-1;\\n    return pow(2,x+1)-1-(org-pow(2,x));\\n}\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>res;\\n        while(label!=-1){\\n            res.push_back(label);\\n            label=parent(label);\\n        }\\n        reverse (res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint parent(int n){\\n    int org=n/2;\\n    if(n==1) return -1;\\n    int x=log2(n)-1;\\n    return pow(2,x+1)-1-(org-pow(2,x));\\n}\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>res;\\n        while(label!=-1){\\n            res.push_back(label);\\n            label=parent(label);\\n        }\\n        reverse (res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990123,
                "title": "simple-python-solution",
                "content": "# Intuition\\nFirst Calculate at which level the target value will appear and then \\ncalculate the path backword. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        def check_level(label, p):\\n            while True:\\n                if label <= 2 **(p+1) -1:\\n                    return p\\n                else:\\n                    p += 1\\n        level = check_level(label,0)\\n        \\n        def find_path(level, label):\\n            ans = [label]\\n            while level > 0:\\n                parent = (2**(level+1) - 1) + (2**(level)) - label\\n                ans.append(parent//2)\\n                label = parent//2\\n                level -= 1\\n            return ans[::-1]\\n        return  find_path(level,label)   \\n\\n\\n                 \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        def check_level(label, p):\\n            while True:\\n                if label <= 2 **(p+1) -1:\\n                    return p\\n                else:\\n                    p += 1\\n        level = check_level(label,0)\\n        \\n        def find_path(level, label):\\n            ans = [label]\\n            while level > 0:\\n                parent = (2**(level+1) - 1) + (2**(level)) - label\\n                ans.append(parent//2)\\n                label = parent//2\\n                level -= 1\\n            return ans[::-1]\\n        return  find_path(level,label)   \\n\\n\\n                 \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742318,
                "title": "flip-bits",
                "content": "```\\nint change(int &n)\\n{\\n    n=n>>1;\\n    int bits=log2(n)+1;\\n    \\n    for(int i=0;i<bits-1;i++)//No need to flip MSB\\n    {\\n        n=n^(1<<i);\\n    }\\n    return n;\\n}\\nclass Solution \\n{\\npublic:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(label>1)\\n        {\\n            int x=change(label);\\n            ans.push_back(x);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution \\n{\\npublic:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(label>1)\\n        {\\n            int x=change(label);\\n            ans.push_back(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2725585,
                "title": "c-o-logn-simple-observation",
                "content": "Based on the parent at previous layer and corresponding number if level is reversed.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int d = log2(label)+1;\\n        \\n        vector<int> ans;\\n        \\n        vector<int> temp;\\n        int n = label;\\n        while(n>0){\\n            temp.push_back(n);\\n            n /= 2;\\n        }\\n            \\n        for(int i=0; i<temp.size(); i++){\\n            int curr = temp[i];\\n                \\n            if(i%2 == 0){\\n                ans.push_back(curr);\\n            }\\n            else{\\n                int start = pow(2, d-1);\\n                int end = pow(2, d) - 1;\\n                    \\n                int fromstart = curr - start;\\n                int fromend = end - fromstart;\\n                    \\n                ans.push_back(fromend);\\n            }    \\n            \\n            d--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int d = log2(label)+1;\\n        \\n        vector<int> ans;\\n        \\n        vector<int> temp;\\n        int n = label;\\n        while(n>0){\\n            temp.push_back(n);\\n            n /= 2;\\n        }\\n            \\n        for(int i=0; i<temp.size(); i++){\\n            int curr = temp[i];\\n                \\n            if(i%2 == 0){\\n                ans.push_back(curr);\\n            }\\n            else{\\n                int start = pow(2, d-1);\\n                int end = pow(2, d) - 1;\\n                    \\n                int fromstart = curr - start;\\n                int fromend = end - fromstart;\\n                    \\n                ans.push_back(fromend);\\n            }    \\n            \\n            d--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465385,
                "title": "c-easy-to-understand-faster-than-100-of-c-online-submissions",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        int num=0;\\n        int level=0;\\n        while(label>num)\\n            num+=pow(2,level++);\\n        vector<int> ans(level);\\n        int i;\\n        for(i=level;i>1;i--)\\n        {\\n            cout<<i<<\"-\";\\n            ans[i-1]=label;\\n            int low=pow(2,i-2);\\n            int high=pow(2,i-1)-1;\\n            if(i%2!=0)\\n            {\\n                label=high-(int)(label-pow(2,i-1))/2;\\n                cout<<label<<\" \";\\n            }\\n            else\\n            {\\n                label=low+(pow(2,i)-1-label)/2;\\n                cout<<label<<\" \";\\n            }\\n        }\\n        ans[i-1]=label;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> pathInZigZagTree(int label) \\n    {\\n        int num=0;\\n        int level=0;\\n        while(label>num)\\n            num+=pow(2,level++);\\n        vector<int> ans(level);\\n        int i;\\n        for(i=level;i>1;i--)\\n        {\\n            cout<<i<<\"-\";\\n            ans[i-1]=label;\\n            int low=pow(2,i-2);\\n            int high=pow(2,i-1)-1;\\n            if(i%2!=0)\\n            {\\n                label=high-(int)(label-pow(2,i-1))/2;\\n                cout<<label<<\" \";\\n            }\\n            else\\n            {\\n                label=low+(pow(2,i)-1-label)/2;\\n                cout<<label<<\" \";\\n            }\\n        }\\n        ans[i-1]=label;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2440245,
                "title": "cpp-easy-0-ms-100-faster",
                "content": "The approach is to find the level of node i.e for 14 it is 3(0 based leveling ) and for 26 it is 4.Then find parent of node if the tree was given in normal order like 1,2,3,4,.....\\nlevel is stored in var n and then res is used to store correct node is it was given in normal order.\\n for eg in case of 14 the normal order would be 9 and for 10 it would be 13...\\n so to get normal node value I added first and last value of level and subtracted the given node...\\n this is all about approach.\\n \\n Try dry running code if u didn\\'t get it\\n\\n```\\nvoid solve(int l,vector<int> &ans)\\n    {\\n        if(l==1)\\n        {\\n            ans.push_back(1);\\n            return ;\\n        }\\n            \\n        int n=log2(l);\\n        int res=(pow(2,n+1)-1+pow(2,n)-l)/2;\\n        solve(res,ans);\\n        ans.push_back(l);\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>  ans;\\n        solve(label,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid solve(int l,vector<int> &ans)\\n    {\\n        if(l==1)\\n        {\\n            ans.push_back(1);\\n            return ;\\n        }\\n            \\n        int n=log2(l);\\n        int res=(pow(2,n+1)-1+pow(2,n)-l)/2;\\n        solve(res,ans);\\n        ans.push_back(l);\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>  ans;\\n        solve(label,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314445,
                "title": "recursive-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int label,vector<int>& ans)\\n    {\\n        ans.push_back(label);\\n         if(label<=1)\\n             return ;\\n        \\n        int rowNumber=0;\\n        long long n=1;\\n        while(label>=n)\\n        {\\n            rowNumber++;\\n            n=n*2;  \\n        }\\n        long long start=n/2;\\n        int index=(label-start)/2 +1;\\n        solve(start/2+(start/2-index),ans);\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n       vector<int> ans;\\n        solve(label,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(int label,vector<int>& ans)\\n    {\\n        ans.push_back(label);\\n         if(label<=1)\\n             return ;\\n        \\n        int rowNumber=0;\\n        long long n=1;\\n        while(label>=n)\\n        {\\n            rowNumber++;\\n            n=n*2;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2302857,
                "title": "new-method-to-solve-this-queston-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        vector<int> tree;\\n        int l=1;\\n        int k=1;\\n        while(l+k<=label)\\n        {\\n            k=k*2;\\n             l+=k;\\n        }\\n        k=k*2;\\n         l+=k;\\n       // cout<<l<<endl;\\n        for(int i=1;i<=l;i++)\\n        {\\n            tree.push_back(i);\\n        }\\n        \\n        int st=1;\\n        int i=0;\\n        int turn=1;\\n        while(i+st-1<l)\\n        {\\n            //cout<<i<<\" \"<<st<<endl;\\n            if(turn==0)\\n            {\\n                reverse(tree.begin()+i,tree.begin()+i+st);\\n                turn =1;\\n            }\\n            else\\n                turn=0;\\n            i=i+st;\\n            st=st*2;\\n        }\\n        \\n        if(turn==0)\\n        {\\n            reverse(tree.begin()+i,tree.end());\\n        }\\n       \\n        int x=-1;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(tree[i]==label)\\n           {\\n               x=i;\\n               break;\\n           }\\n        }\\n        \\n        while(x>0)\\n        {\\n           // cout<<x<<e\\n            res.push_back(tree[x]);\\n            x=(x-1)/2;\\n        }\\n        res.push_back(tree[0]);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        vector<int> tree;\\n        int l=1;\\n        int k=1;\\n        while(l+k<=label)\\n        {\\n            k=k*2;\\n             l+=k;\\n        }\\n        k=k*2;\\n         l+=k;\\n       // cout<<l<<endl;\\n        for(int i=1;i<=l;i++)\\n        {\\n            tree.push_back(i);\\n        }\\n        \\n        int st=1;\\n        int i=0;\\n        int turn=1;\\n        while(i+st-1<l)\\n        {\\n            //cout<<i<<\" \"<<st<<endl;\\n            if(turn==0)\\n            {\\n                reverse(tree.begin()+i,tree.begin()+i+st);\\n                turn =1;\\n            }\\n            else\\n                turn=0;\\n            i=i+st;\\n            st=st*2;\\n        }\\n        \\n        if(turn==0)\\n        {\\n            reverse(tree.begin()+i,tree.end());\\n        }\\n       \\n        int x=-1;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(tree[i]==label)\\n           {\\n               x=i;\\n               break;\\n           }\\n        }\\n        \\n        while(x>0)\\n        {\\n           // cout<<x<<e\\n            res.push_back(tree[x]);\\n            x=(x-1)/2;\\n        }\\n        res.push_back(tree[0]);\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2256129,
                "title": "68-tc-and-72-sc-easy-python-solution",
                "content": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n\\tans = [label]\\n\\twhile(label != 1):\\n\\t\\tpar1 = label//2\\n\\t\\tx = int(log(par1, 2))\\n\\t\\tdiff = par1 - 2**x\\n\\t\\tlabel = 2**(x+1)-1 - diff\\n\\t\\tans.append(label)\\n\\treturn ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef pathInZigZagTree(self, label: int) -> List[int]:\\n\\tans = [label]\\n\\twhile(label != 1):\\n\\t\\tpar1 = label//2\\n\\t\\tx = int(log(par1, 2))\\n\\t\\tdiff = par1 - 2**x\\n\\t\\tlabel = 2**(x+1)-1 - diff\\n\\t\\tans.append(label)\\n\\treturn ans[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2247937,
                "title": "o-logn-observation-on-calculating-the-parent-of-the-label",
                "content": "Looking at the complete binary tree we can deduce that the level of the given label is ```floor(log2(label))+1```.\\n\\nLet\\'s say the level of the current label is ```level```. For this ```level``` the node\\'s value will vary from ```2^level - 1``` to ```2^(level-1)```.\\n\\nLet\\'s say the current level is **even**. At this ```level``` there are ```2^(level-1)``` nodes among these nodes every 2 nodes from ```2^(level-1)``` nodes is assigned to a parent node.\\n\\nTo find the parent label for a node with label ```n``` at the current level we can subtract ```n``` from the node at the extreme left i.e. ```2^level - 1```(even level). Let\\'s say the different is ```diff```. \\nWe can safely say that ```diff/2``` is the position of the parent node with respect to the left most node at the parent level.\\nFor example:\\nfor label 14 (level = 4), the leftmost node\\'s label is 15, the difference is 1. Position ```pos``` of the parent is 1/2 = 0 with respect to the left most node at level 3 i.e ```2^(3-1)```(odd level), so the parent node\\'s label is ```2^(3-1)``` + ```pos```(relative position from leftmost node i.e 0), the parent node\\'s label turns out to be 4.\\n\\n\\nIf the ```level``` is **odd** then the left most node\\'s value becomes ```2^(level-1)``` so the difference ```diff``` becomes ```label - 2^(level-1)```, ```pos``` is ```diff/2```. Parent node\\'s label (even level) becomes ```2^parentLevel - 1 - pos``` since the parent level is even for the sequence is reversed.\\n\\nC++ solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int lev = floor(log2(label))+1;\\n        vector<int> ans;\\n        while(lev>0) {\\n            // cout<<label<<\" \"<<lev<<endl;\\n            ans.push_back(label);\\n            if (lev%2==0) {\\n                int prev = pow(2,lev) - label - 1; // differece with the leftmost node and divided by 2 to get the position pos\\n                prev/=2;\\n                lev--; // level decreased to parent\\'s level\\n                label = pow(2,lev-1)+prev;\\n            } else {\\n                int prev = label - pow(2,lev-1);\\n                prev/=2;\\n                lev--;\\n                label = pow(2,lev)-prev-1;\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```floor(log2(label))+1```\n```level```\n```level```\n```2^level - 1```\n```2^(level-1)```\n```level```\n```2^(level-1)```\n```2^(level-1)```\n```n```\n```n```\n```2^level - 1```\n```diff```\n```diff/2```\n```pos```\n```2^(3-1)```\n```2^(3-1)```\n```pos```\n```level```\n```2^(level-1)```\n```diff```\n```label - 2^(level-1)```\n```pos```\n```diff/2```\n```2^parentLevel - 1 - pos```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int lev = floor(log2(label))+1;\\n        vector<int> ans;\\n        while(lev>0) {\\n            // cout<<label<<\" \"<<lev<<endl;\\n            ans.push_back(label);\\n            if (lev%2==0) {\\n                int prev = pow(2,lev) - label - 1; // differece with the leftmost node and divided by 2 to get the position pos\\n                prev/=2;\\n                lev--; // level decreased to parent\\'s level\\n                label = pow(2,lev-1)+prev;\\n            } else {\\n                int prev = label - pow(2,lev-1);\\n                prev/=2;\\n                lev--;\\n                label = pow(2,lev)-prev-1;\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2238990,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool rev_b(bool flag)\\n    {\\n        if(flag == true) return false;\\n        return true;\\n    }\\n    \\n    void vec_arrange(vector<int> &v, bool flag)\\n    {\\n        if(flag == true)\\n        {\\n           reverse(v.begin(), v.end());\\n        }\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<vector<int>> v;\\n        vector<int> temp;\\n        int count = 1, i=1, j=0;\\n        bool flag = true;\\n        \\n        while(true)\\n        {\\n            for(int tmp = 0; tmp<count; tmp++)\\n            {\\n                temp.push_back(i);\\n                i++;\\n                if(i == label+1)\\n                {\\n                    j = 1;\\n                }\\n            }\\n            flag = rev_b(flag);\\n            vec_arrange(temp, flag);\\n            v.push_back(temp);\\n            temp.clear();\\n            if(j == 1) break;\\n            count = 2*count;\\n        }\\n        \\n        i = v.size()-1;\\n        j = v[i].size()-1;\\n        \\n        for(int k=0; k<j+1; k++)\\n        {\\n            if(v[i][k] == label)\\n            {\\n                j = k;\\n                break;\\n            }\\n        }\\n        \\n        while(i>-1 && j>-1)\\n        {\\n            temp.push_back(v[i][j]);\\n            i--;\\n            j = ceil(j/2);\\n        }\\n        \\n        reverse(temp.begin(), temp.end());        \\n     \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool rev_b(bool flag)\\n    {\\n        if(flag == true) return false;\\n        return true;\\n    }\\n    \\n    void vec_arrange(vector<int> &v, bool flag)\\n    {\\n        if(flag == true)\\n        {\\n           reverse(v.begin(), v.end());\\n        }\\n    }\\n    \\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        vector<vector<int>> v;\\n        vector<int> temp;\\n        int count = 1, i=1, j=0;\\n        bool flag = true;\\n        \\n        while(true)\\n        {\\n            for(int tmp = 0; tmp<count; tmp++)\\n            {\\n                temp.push_back(i);\\n                i++;\\n                if(i == label+1)\\n                {\\n                    j = 1;\\n                }\\n            }\\n            flag = rev_b(flag);\\n            vec_arrange(temp, flag);\\n            v.push_back(temp);\\n            temp.clear();\\n            if(j == 1) break;\\n            count = 2*count;\\n        }\\n        \\n        i = v.size()-1;\\n        j = v[i].size()-1;\\n        \\n        for(int k=0; k<j+1; k++)\\n        {\\n            if(v[i][k] == label)\\n            {\\n                j = k;\\n                break;\\n            }\\n        }\\n        \\n        while(i>-1 && j>-1)\\n        {\\n            temp.push_back(v[i][j]);\\n            i--;\\n            j = ceil(j/2);\\n        }\\n        \\n        reverse(temp.begin(), temp.end());        \\n     \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090667,
                "title": "c-o-log-n-solution-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n  \\n  vector<int> pathInZigZagTree(int label) \\n  {  \\n  \\n\\t   vector<int>result;        \\n        \\n\\t\\tint depth = log2(label);\\n        while(depth>=0)\\n        {\\n            result.insert(result.begin(),label);\\n           \\n\\t\\t   int left=pow(2,depth-1);\\n\\t\\t  int right=pow(2,depth)-1;\\n\\t\\t  label=left+(right-label/2);\\n          \\n\\t\\t  depth--;\\n        \\n\\t\\t}\\n\\t\\t\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n  \\n  vector<int> pathInZigZagTree(int label) \\n  {  \\n  \\n\\t   vector<int>result;        \\n        \\n\\t\\tint depth = log2(label);\\n        while(depth>=0)\\n        {\\n            result.insert(result.begin(),label);\\n           \\n\\t\\t   int left=pow(2,depth-1);\\n\\t\\t  int right=pow(2,depth)-1;\\n\\t\\t  label=left+(right-label/2);\\n          \\n\\t\\t  depth--;\\n        \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2023504,
                "title": "c-faster-than-100",
                "content": "```\\n    vector<int> pathInZigZagTree(int label) {\\n         vector<int> result;\\n         int level = logBase2(label);\\n        result.push_back(label);\\n       \\n        while(label > 1){\\n            int l = pow(2,level-2);\\n            int h = pow(2,level-1) -1;\\n            label = label/2;\\n            label = l + (h-label);\\n            result.push_back(label);\\n            level--;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n    \\n    int logBase2(int num){\\n        int res = 0;\\n        while(num>0){\\n            num >>= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> pathInZigZagTree(int label) {\\n         vector<int> result;\\n         int level = logBase2(label);\\n        result.push_back(label);\\n       \\n        while(label > 1){\\n            int l = pow(2,level-2);\\n            int h = pow(2,level-1) -1;\\n            label = label/2;\\n            label = l + (h-label);\\n            result.push_back(label);\\n            level--;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n    \\n    int logBase2(int num){\\n        int res = 0;\\n        while(num>0){\\n            num >>= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966346,
                "title": "java-fast-solution-0ms-100-beat",
                "content": "![image](https://assets.leetcode.com/users/images/93f53438-7db3-414f-b024-c6adcaa4ee6d_1650450661.2556148.png)\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> answer = new ArrayList<>();\\n        int parent = label;\\n        answer.add(parent);\\n        while (parent != 1) {\\n            int depth = (int) (Math.log(parent) / Math.log(2));\\n            int offset = (int) Math.pow(2, depth + 1) - 1 - parent;\\n            parent = ((int) Math.pow(2, depth) + offset) / 2;\\n            answer.add(parent);\\n        }\\n        Collections.reverse(answer);\\n        return answer; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> answer = new ArrayList<>();\\n        int parent = label;\\n        answer.add(parent);\\n        while (parent != 1) {\\n            int depth = (int) (Math.log(parent) / Math.log(2));\\n            int offset = (int) Math.pow(2, depth + 1) - 1 - parent;\\n            parent = ((int) Math.pow(2, depth) + offset) / 2;\\n            answer.add(parent);\\n        }\\n        Collections.reverse(answer);\\n        return answer; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954889,
                "title": "java-logarithmic-run-time-base2",
                "content": "Computer height of the Binary Tree - logN / log2 (rows)\\n\\nFor each row in Binary Tree - \\n1. Find start and end node indices\\n2. Find correct node index of the label in the row if the nodes were indexed in the right order -\\n\\ta. Compute offset [How far the label is from the end]\\n\\tb. Actual Index = start + offset\\n```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> nodes = new LinkedList<>();\\n\\n        int depth = (int) (Math.log(label) / Math.log(2));\\n        while (depth >= 0) {\\n            nodes.add(0, label);\\n\\n            int start = (int) (Math.pow(2, depth));\\n            int end = start * 2 - 1;\\n\\n            int offset = end - label;\\n            int actualIndex = start + offset;\\n\\n            label = actualIndex / 2;\\n            depth--;\\n        }\\n\\n        return nodes;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> nodes = new LinkedList<>();\\n\\n        int depth = (int) (Math.log(label) / Math.log(2));\\n        while (depth >= 0) {\\n            nodes.add(0, label);\\n\\n            int start = (int) (Math.pow(2, depth));\\n            int end = start * 2 - 1;\\n\\n            int offset = end - label;\\n            int actualIndex = start + offset;\\n\\n            label = actualIndex / 2;\\n            depth--;\\n        }\\n\\n        return nodes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862396,
                "title": "simple-and-easy-solution-in-c",
                "content": "```\\nvector<int> pathInZigZagTree(int label) {\\n//last level value\\n        int last_l_val = 1;\\n\\t\\t//curr level value\\n        int curr_l_max = 0;\\n        while(curr_l_max<label){\\n            curr_l_max+=last_l_val;   // 1 3 7 15 .....\\n            last_l_val*=2; // 1 2 4 8 16\\n        }\\n        last_l_val/=2;          // 8\\n        vector<int> v;\\n        while(label!=1){\\n            v.push_back(label);                      // 13 5 3 \\n            int compliment = (3*last_l_val-label-1);    // first find the compliment of label means original children of label\\'s parent \\n            label = compliment/2;\\n            last_l_val/=2;\\n        }\\n\\t\\t// push 1 to vector\\n        v.push_back(1);\\n\\t\\t//reverse the vector \\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n//last level value\\n        int last_l_val = 1;\\n\\t\\t//curr level value\\n        int curr_l_max = 0;\\n        while(curr_l_max<label){\\n            curr_l_max+=last_l_val;   // 1 3 7 15 .....\\n            last_l_val*=2; // 1 2 4 8 16\\n        }\\n        last_l_val/=2;          // 8\\n        vector<int> v;\\n        while(label!=1){\\n            v.push_back(label);                      // 13 5 3 \\n            int compliment = (3*last_l_val-label-1);    // first find the compliment of label means original children of label\\'s parent \\n            label = compliment/2;\\n            last_l_val/=2;\\n        }\\n\\t\\t// push 1 to vector\\n        v.push_back(1);\\n\\t\\t//reverse the vector \\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666985,
                "title": "c-using-basic-mathematics-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) \\n    {\\n        vector<int> path;\\n        while(x)\\n        {\\n            path.push_back(x);\\n            x /= 2;\\n        }\\n        \\n        reverse(path.begin(),path.end());\\n        \\n        if(path.size() & 1)\\n        {\\n            for(int  i = 0; i < path.size(); i++)\\n            {\\n                if(!(i & 1)) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < path.size(); i++)\\n            {\\n                if(i & 1) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        \\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int x) \\n    {\\n        vector<int> path;\\n        while(x)\\n        {\\n            path.push_back(x);\\n            x /= 2;\\n        }\\n        \\n        reverse(path.begin(),path.end());\\n        \\n        if(path.size() & 1)\\n        {\\n            for(int  i = 0; i < path.size(); i++)\\n            {\\n                if(!(i & 1)) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < path.size(); i++)\\n            {\\n                if(i & 1) continue;\\n                //reverse value\\n                int beg = pow(2,i);\\n                int end = pow(2, i + 1) - 1;\\n                \\n                path[i] = end + beg - path[i];\\n            }\\n        }\\n        \\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641795,
                "title": "python3-o-logn-commented",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        mn=mx=total=1\\n        while not (mn<=label<=mx): #go to the depth level of the label in our tree\\n            total*=2               #total=number of nodes in each level\\n            mn=total               #mx = maximum value in each level (rightmost element)\\n            mx=total*2-1           #mn = minimum value in each level (leftmost element)\\n        res=collections.deque()\\n        while label>0:    \\n            res.appendleft(label)\\n            mx//=2                 #go up one level in the tree and update mx,mn and label\\n            mn//=2                 #the new label is it\\'s parent (label//2), but mirrored from the center of the level\\n            label//=2\\n            diff=abs(mx-label)\\n            label=mn+diff\\n        return res            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        mn=mx=total=1\\n        while not (mn<=label<=mx): #go to the depth level of the label in our tree\\n            total*=2               #total=number of nodes in each level\\n            mn=total               #mx = maximum value in each level (rightmost element)\\n            mx=total*2-1           #mn = minimum value in each level (leftmost element)\\n        res=collections.deque()\\n        while label>0:    \\n            res.appendleft(label)\\n            mx//=2                 #go up one level in the tree and update mx,mn and label\\n            mn//=2                 #the new label is it\\'s parent (label//2), but mirrored from the center of the level\\n            label//=2\\n            diff=abs(mx-label)\\n            label=mn+diff\\n        return res            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497450,
                "title": "c-o-log-n-beats-100-with-explanation",
                "content": "Instead of creating the whole tree we can only find the parents of the node.\\nAs the tree to be constructed would have been full binary tree i.e. each node has two children this property can be exploited.\\nFor array representation of a full binary tree each node at index i would hv its children at 2*i and 2*i +1 index or each node would have its parent at i/2 index.\\nBut in our case the tree defined in a zig zag manner so we need to find the distance from last node at its level and add it to the first node of the level giving us the parent node.\\nif it was a normal binary tree parent would have been i/2 so now we check the distance of i/2 from last node (2*h-1 where h is level) at the level and add it to the first node(pow(2,h-1));\\neg.\\nfor node 14:\\nfor normal tree parent would have been 7 but now it will be 2^3-1(number of nodes covered till this level) - 7 (i/2) + 2^2(first node)\\n\\n\\n```\\n vector<int> pathInZigZagTree(int label) {\\n        vector<int>a;\\n        int p=label;\\n        int h=log2(label); //find height till which we need to traverse\\n        while(p!=1)\\n        {\\n            a.push_back(p);\\n            p=p/2;\\n            if(p==1)\\n            {\\n                break;\\n            }\\n            p=pow(2,h)-1-p+pow(2,h-1);\\n            h--;\\n        }\\n        a.push_back(1);\\n        reverse(a.begin(),a.end());\\n        return a;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> pathInZigZagTree(int label) {\\n        vector<int>a;\\n        int p=label;\\n        int h=log2(label); //find height till which we need to traverse\\n        while(p!=1)\\n        {\\n            a.push_back(p);\\n            p=p/2;\\n            if(p==1)\\n            {\\n                break;\\n            }\\n            p=pow(2,h)-1-p+pow(2,h-1);\\n            h--;\\n        }\\n        a.push_back(1);\\n        reverse(a.begin(),a.end());\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488208,
                "title": "c-o-n-100-faster-space-o-1",
                "content": "\\t1. every time add the element into res and then invert the node.\\n\\t2. if it was from left to right then it would have been label/2 always but in this case have to invert.\\n\\t3. just take the sum of previous level first element from left and right then substract the label/2 and then \\n\\t4. recursion will do the rest of the work.\\n\\n\\tvector<int> res;\\n    void rec(int label){\\n        if(label==1)  {  res.push_back(1); return ;}\\n        res.push_back(label) ;\\n        int level = (int)log2(label) ;\\n        int element = label/2 ;\\n        level--;\\n        int sum = 0;\\n        int t = pow(2,level) ;sum+=t ;\\n        sum = sum + pow(2,(level+1))-1;\\n        rec(sum-element) ;\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        rec(label) ;reverse(res.begin(),res.end()) ;return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "\\t1. every time add the element into res and then invert the node.\\n\\t2. if it was from left to right then it would have been label/2 always but in this case have to invert.\\n\\t3. just take the sum of previous level first element from left and right then substract the label/2 and then \\n\\t4. recursion will do the rest of the work.\\n\\n\\tvector<int> res;\\n    void rec(int label){\\n        if(label==1)  {  res.push_back(1); return ;}\\n        res.push_back(label) ;\\n        int level = (int)log2(label) ;\\n        int element = label/2 ;\\n        level--;\\n        int sum = 0;\\n        int t = pow(2,level) ;sum+=t ;\\n        sum = sum + pow(2,(level+1))-1;\\n        rec(sum-element) ;\\n    }\\n    vector<int> pathInZigZagTree(int label) {\\n        rec(label) ;reverse(res.begin(),res.end()) ;return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1437241,
                "title": "c-o-logn-solution-100-faster-runtime",
                "content": "```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        while(label != 1){\\n            int row = floor(log2(label)) + 1;\\n            int parent = label / 2;\\n            int starting = (1 << (row - 2));\\n            int diff = parent - starting;\\n            int ending = (1 << (row - 1)) - 1;\\n            result.push_back(label);\\n            label = ending - diff;\\n        }\\n        result.push_back(1);\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        while(label != 1){\\n            int row = floor(log2(label)) + 1;\\n            int parent = label / 2;\\n            int starting = (1 << (row - 2));\\n            int diff = parent - starting;\\n            int ending = (1 << (row - 1)) - 1;\\n            result.push_back(label);\\n            label = ending - diff;\\n        }\\n        result.push_back(1);\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428745,
                "title": "java-o-n-simple-solution-with-explanation",
                "content": "**Idea / Approach**\\nSo I would start to approach the problem from the information we have. \\n1. We know the id of the node whose path is to be found. \\n2. We can find the height of the level in which it is there as h\\n3. The number of nodes until the previous height is **2^(h-1)-1**.\\n4. So the position of the current node in the level alone would be **label - (num nodes until prev level)**\\n5. So if the node is in xth position in its level, the parent would be in **(x-1)/2** th position from the end **in its level** . Or we can say (x-1)/2 parents will be there before the desired parent in that level.\\n6. The end in its level will have id of? Thats right from point 3 we get the max id in that level and we have to reduce the number of parents that come before the current node as **(2^(h-1)-1-(x-1)/2)**.\\n\\nHope you find it useful!! :) \\n**Recursive:**\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; // (not too important) storing the required powers so that it doesn\\'t have to be recalculated for each level\\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>();\\n        rec(h, label, res, pow);\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    void rec(int h, int num, ArrayList<Integer> path, int[] pow){\\n        if(h==0) return;\\n        path.add(num);\\n        int count = num-(pow[h-1]-1);\\n        int next = pow[h-1]-1 - (count-1)/2;\\n        rec(h-1, next, path, pow);\\n    }\\n}\\n```\\nI later saw that it can be converted to an iterative solution which just keeps reducing height and runs the quickest !!\\n**Iterative:**\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; \\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>(h);\\n        int count, next;\\n        while(--h>=0){ // since we need only the previous  level height and not the current height we can reduce and use the same for finding the number of elements in the previous level and the parent label\\n            res.add(label);\\n            count = label-(pow[h]-1);\\n            label = pow[h]-1 - (count-1)/2;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; // (not too important) storing the required powers so that it doesn\\'t have to be recalculated for each level\\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>();\\n        rec(h, label, res, pow);\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    void rec(int h, int num, ArrayList<Integer> path, int[] pow){\\n        if(h==0) return;\\n        path.add(num);\\n        int count = num-(pow[h-1]-1);\\n        int next = pow[h-1]-1 - (count-1)/2;\\n        rec(h-1, next, path, pow);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int h = 1+(int)(Math.log(label)/Math.log(2)+1e-10);\\n        int[] pow = new int[h+1]; \\n        pow[0]=1;\\n        for(int i=1;i<=h;i++)\\n            pow[i]=pow[i-1]*2;\\n        ArrayList<Integer> res =new ArrayList<>(h);\\n        int count, next;\\n        while(--h>=0){ // since we need only the previous  level height and not the current height we can reduce and use the same for finding the number of elements in the previous level and the parent label\\n            res.add(label);\\n            count = label-(pow[h]-1);\\n            label = pow[h]-1 - (count-1)/2;\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365821,
                "title": "log-n-well-documented-most-optimized",
                "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        // Finding the initial level of node \"label\"\\n        int level = log2(label) + 1;\\n        \\n        // Here sum is equal to lower value and higher value of that particular level.\\n        int sum = pow(2,level-1) + pow(2,level)-1;\\n        \\n        // Take a \"ans\" vector to store the ans.\\n        vector<int>  ans;\\n        \\n        // Run a loop while the value of level is greater than 0.\\n        while(label > 0)\\n        {\\n            // Store the current \"label\" in \"ans\" vector\\n            ans.push_back(label);\\n            \\n            // Find the alternative to \"label\" as below because the parent of \"label\" is half the value of its alternative value (observation).\\n            int alt = sum - label;\\n            \\n            // Find parent\\n            label = alt/2;\\n            \\n            // Find the find for next iteration.\\n            sum = (sum - 1) / 2;\\n        }\\n        \\n        // Since we have stored the elements in reverse order, So we need to reverse our answer.\\n        reverse(ans.begin(), ans.end());\\n        \\n        // Return \"ans\"\\n        return ans;\\n    }\\n};\\n\\nTime : O(logN) \\nEvery time our next lebel decreases by half.\\n\\nSpace: O(logN)\\nWe are storing our answer.\\n\\nIf you still don\\'t understand, comment down, I will give an example.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        // Finding the initial level of node \"label\"\\n        int level = log2(label) + 1;\\n        \\n        // Here sum is equal to lower value and higher value of that particular level.\\n        int sum = pow(2,level-1) + pow(2,level)-1;\\n        \\n        // Take a \"ans\" vector to store the ans.\\n        vector<int>  ans;\\n        \\n        // Run a loop while the value of level is greater than 0.\\n        while(label > 0)\\n        {\\n            // Store the current \"label\" in \"ans\" vector\\n            ans.push_back(label);\\n            \\n            // Find the alternative to \"label\" as below because the parent of \"label\" is half the value of its alternative value (observation).\\n            int alt = sum - label;\\n            \\n            // Find parent\\n            label = alt/2;\\n            \\n            // Find the find for next iteration.\\n            sum = (sum - 1) / 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1351221,
                "title": "c-100-0ms-o-log-n-time-and-memory",
                "content": "Idea: Calculate the path for a normal complete binary tree and flip the nodes alternatively.\\n\\n1. The node with value `label` will be at a level with height `log2(label)  + 1`.\\n2. Path from node to root for a normal complete binary tree is computed as the floor of division by 2 continuously until we reach root. Eg:- `14 -> 7 -> 3 -> 1`.\\n3. In a Zig-Zag tree, the nodes at levels with same parity as the level of `label` remain unchanged while the others are flipped.\\n4. To flip a node, we need to observe that the offset of the node from the start of that level and the offset of the flipped node from the end of that level is equal. Eg: `10 flips to 13, 10 - 8 == 15 - 13`. \\n5. Thus, to flip a node at level `i`, we find the offset from the start, which is `val - 2^i` and subtract this from the last node, which is `2^(i+1) - 1`. So, the value of flipped node = `2^(i + 1) - (val - 2^i)  = 2^(i+1) + 2^i - val`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\t\\t// Level of node with value = label\\n        int lg = log2(label)+1;\\n\\t\\t// Don\\'t flip the last node\\n        bool flip = false;\\n\\t\\t// Store powers of 2 for faster computation\\n        vector<int> path(lg, 0), powers(lg+1, 1);\\n        for(int i=1; i<lg+1; i++)\\n            powers[i] = 2*powers[i-1];\\n        for(int i=lg-1; i>-1; i--) {\\n\\t\\t\\t// Store the original path\\n            path[i] = label;\\n            label /= 2;\\n\\t\\t\\t// Check if current level\\'s parity is different from that of last node\\n            if(flip)\\n                path[i] = powers[i+1] + powers[i] - path[i] - 1;\\n\\t\\t\\t// Flip the nodes alternatively\\n            flip = !flip;\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n\\t\\t// Level of node with value = label\\n        int lg = log2(label)+1;\\n\\t\\t// Don\\'t flip the last node\\n        bool flip = false;\\n\\t\\t// Store powers of 2 for faster computation\\n        vector<int> path(lg, 0), powers(lg+1, 1);\\n        for(int i=1; i<lg+1; i++)\\n            powers[i] = 2*powers[i-1];\\n        for(int i=lg-1; i>-1; i--) {\\n\\t\\t\\t// Store the original path\\n            path[i] = label;\\n            label /= 2;\\n\\t\\t\\t// Check if current level\\'s parity is different from that of last node\\n            if(flip)\\n                path[i] = powers[i+1] + powers[i] - path[i] - 1;\\n\\t\\t\\t// Flip the nodes alternatively\\n            flip = !flip;\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317308,
                "title": "c-log-n-solution",
                "content": "Generate the path in a normally ordered binary tree, then reverse the nodes that are out of order. The tricky bit here is to realize that you need to reverse the nodes not on whether or not they were actually reversed, but whether the layers in between are in the wrong order.\\n```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int count=1;\\n        while (label){\\n            res.push_back(label);\\n            label/=2;\\n        }\\n        reverse(res.begin(), res.end());\\n        for (int i=1 + !(res.size()%2);i<res.size();i+=2){\\n            int r=(1<<(i+1))-1; //Max Number for this layer of the tree\\n            int l=(1<<i); //Min number\\n            int dist=res[i]-l; //Reflect the distance\\n            res[i]=r-dist;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        int count=1;\\n        while (label){\\n            res.push_back(label);\\n            label/=2;\\n        }\\n        reverse(res.begin(), res.end());\\n        for (int i=1 + !(res.size()%2);i<res.size();i+=2){\\n            int r=(1<<(i+1))-1; //Max Number for this layer of the tree\\n            int l=(1<<i); //Min number\\n            int dist=res[i]-l; //Reflect the distance\\n            res[i]=r-dist;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314575,
                "title": "java-solution-o-log-n-time-o-log-n-space-using-power-of-two-series-trick",
                "content": "[https://github.com/2018hsridhar/Leetcode_Solutions/blob/master/leetcode_1104.java](http://)\\n```\\n/*\\nTHOUGHT PROCESS : \\n\\n1104. Path In Zigzag Labelled Binary Tree\\nURL = https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/\\n\\nAlways ask if each node, in a binary tree, is uniquely labeled or not ( provided we know if the bTree is also labeled ) \\nFactorization ( into {2,3} ) can guarantee convergence to the value of 1 here\\n\\nEasiest way to think of problem : utilize 2-power sequence\\nlen = 6 [ 1,2,4,8,16,32 ]\\nlen = 7 [ 1,2,4,8,16,32,64]\\nlen = 8 [ 1,2,4,8,16,32,64,128]\\n=> Quick to built intuition from here!\\n\\n\\nEdge cases\\n1\\n2\\n3\\n127\\n128\\n17\\n14\\n1000000\\n\\nComputational Complexity : \\nTime = O(log(N)) + O(N) + O(N/2) = O(N) [ break down into three segments, per loop and for list reversal ( assume optimized here ) ]\\nSpace = O(N) [ due to array list ]\\n\\nBetter idea : use the reverse iterator?\\n\\n*/\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        // [1] Generate the binary sequence ( divide by 2 sequence ) until you hit 1 ( you are guaranteed to hit 1, as you hit {2,3} at some point )\\n        ArrayList<Integer> traversal = new ArrayList<Integer>();\\n        while(label != 1)\\n        {\\n            traversal.add(label);\\n            label /= 2;\\n        }\\n        // Add label ( equal to 1 now! ) \\n        traversal.add(label);\\n        \\n        // [2] Reverse iterate over this arrayList now : convert to array\\n        Collections.reverse(traversal);\\n        int n = traversal.size();\\n        \\n        // [3] Perform computation on array, based on parity of traversal size\\n        if(n % 2 == 0) // len = 6 [ 1,2,4,8,16,32 ]\\n        {\\n            for(int i = 2; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i,replVal);\\n            }\\n        }\\n        else if ( n % 2 == 1)\\n        {\\n            for(int i = 1; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i, replVal);\\n            }\\n        }\\n        \\n        return traversal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Tree"
                ],
                "code": "```\\n/*\\nTHOUGHT PROCESS : \\n\\n1104. Path In Zigzag Labelled Binary Tree\\nURL = https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/\\n\\nAlways ask if each node, in a binary tree, is uniquely labeled or not ( provided we know if the bTree is also labeled ) \\nFactorization ( into {2,3} ) can guarantee convergence to the value of 1 here\\n\\nEasiest way to think of problem : utilize 2-power sequence\\nlen = 6 [ 1,2,4,8,16,32 ]\\nlen = 7 [ 1,2,4,8,16,32,64]\\nlen = 8 [ 1,2,4,8,16,32,64,128]\\n=> Quick to built intuition from here!\\n\\n\\nEdge cases\\n1\\n2\\n3\\n127\\n128\\n17\\n14\\n1000000\\n\\nComputational Complexity : \\nTime = O(log(N)) + O(N) + O(N/2) = O(N) [ break down into three segments, per loop and for list reversal ( assume optimized here ) ]\\nSpace = O(N) [ due to array list ]\\n\\nBetter idea : use the reverse iterator?\\n\\n*/\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        // [1] Generate the binary sequence ( divide by 2 sequence ) until you hit 1 ( you are guaranteed to hit 1, as you hit {2,3} at some point )\\n        ArrayList<Integer> traversal = new ArrayList<Integer>();\\n        while(label != 1)\\n        {\\n            traversal.add(label);\\n            label /= 2;\\n        }\\n        // Add label ( equal to 1 now! ) \\n        traversal.add(label);\\n        \\n        // [2] Reverse iterate over this arrayList now : convert to array\\n        Collections.reverse(traversal);\\n        int n = traversal.size();\\n        \\n        // [3] Perform computation on array, based on parity of traversal size\\n        if(n % 2 == 0) // len = 6 [ 1,2,4,8,16,32 ]\\n        {\\n            for(int i = 2; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i,replVal);\\n            }\\n        }\\n        else if ( n % 2 == 1)\\n        {\\n            for(int i = 1; i < n; i += 2)\\n            {\\n                int replVal = (((int)Math.pow(2,i) * 3 ) - 1 ) - traversal.get(i);\\n                traversal.set(i, replVal);\\n            }\\n        }\\n        \\n        return traversal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309157,
                "title": "c-math-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        \\n        int level;\\n        int parent;\\n        int sum;\\n        int temp;\\n        \\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(label > 1){\\n            \\n            parent = label/2;\\n            level = (31 - __builtin_clz(parent));\\n            temp = pow(2, level);\\n            sum = temp + 2*temp - 1;\\n            label = sum - parent;\\n            ans.insert(ans.begin(), label);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        \\n        int level;\\n        int parent;\\n        int sum;\\n        int temp;\\n        \\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        while(label > 1){\\n            \\n            parent = label/2;\\n            level = (31 - __builtin_clz(parent));\\n            temp = pow(2, level);\\n            sum = temp + 2*temp - 1;\\n            label = sum - parent;\\n            ans.insert(ans.begin(), label);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302083,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int t) {\\n        if(t==1){\\n            return {1};\\n        }\\n        int i=0;\\n        while((1<<i) <= t){\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(t){\\n            ans.push_back(t);\\n            \\n            if(i&1){\\n                int x = t - (1<<(i-1)); // counting no. of nodes behind cur node\\n                int par = x/2; // count no. of parents which come before the par of cur node.\\n                int st = (1<<(i-1))-1; // front element of par row, which is even\\n                t = st-par; // getting par of curr node\\n                i--;\\n            }\\n            else{\\n               int x = (1<<(i))-t-1; // counting no. of nodes before cur node\\n               int par = x/2; // count no. of parents which come before the par of cur node\\n                int st = (1<<(i-2));// front element of par row, which is odd\\n                t = st + par; //  getting par of curr node\\n                i--;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int t) {\\n        if(t==1){\\n            return {1};\\n        }\\n        int i=0;\\n        while((1<<i) <= t){\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(t){\\n            ans.push_back(t);\\n            \\n            if(i&1){\\n                int x = t - (1<<(i-1)); // counting no. of nodes behind cur node\\n                int par = x/2; // count no. of parents which come before the par of cur node.\\n                int st = (1<<(i-1))-1; // front element of par row, which is even\\n                t = st-par; // getting par of curr node\\n                i--;\\n            }\\n            else{\\n               int x = (1<<(i))-t-1; // counting no. of nodes before cur node\\n               int par = x/2; // count no. of parents which come before the par of cur node\\n                int st = (1<<(i-2));// front element of par row, which is odd\\n                t = st + par; //  getting par of curr node\\n                i--;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288152,
                "title": "pre-compute-powers-of-2-99-speed",
                "content": "Runtime: 20 ms, faster than 99.29% of Python3 online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 14.3 MB, less than 50.00% of Python3 online submissions for Path In Zigzag Labelled Binary Tree.\\n```\\nfrom math import log2\\nclass Solution:\\n\\n    power2 = {i: pow(2, i) for i in range(21)}\\n\\n    def pathInZigZagTree(self, label: int):\\n        if label == 1:\\n            return [1]\\n        row = int(log2(label))\\n        labels = [1] * (row + 1)\\n        labels[row] = label\\n        position = (Solution.power2[row + 1] - 1 - label if row % 2 else\\n                    label - Solution.power2[row])\\n        for r in range(row - 1, 0, -1):\\n            position //= 2\\n            if r % 2:\\n                labels[r] = Solution.power2[r + 1] - 1 - position\\n            else:\\n                labels[r] = Solution.power2[r] + position\\n        return labels\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom math import log2\\nclass Solution:\\n\\n    power2 = {i: pow(2, i) for i in range(21)}\\n\\n    def pathInZigZagTree(self, label: int):\\n        if label == 1:\\n            return [1]\\n        row = int(log2(label))\\n        labels = [1] * (row + 1)\\n        labels[row] = label\\n        position = (Solution.power2[row + 1] - 1 - label if row % 2 else\\n                    label - Solution.power2[row])\\n        for r in range(row - 1, 0, -1):\\n            position //= 2\\n            if r % 2:\\n                labels[r] = Solution.power2[r + 1] - 1 - position\\n            else:\\n                labels[r] = Solution.power2[r] + position\\n        return labels\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242695,
                "title": "c-100-faster",
                "content": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        ans.push_back(label);\\n        int i=1;\\n        while(pow(2,i)<=label)\\n        {\\n            i++;\\n        }\\n        i--;\\n        int val=label;\\n        while(i>0)\\n        {\\n            val=val/2;\\n            val=val-pow(2,i-1);\\n            val=pow(2,i)-val-1;\\n            ans.push_back(val);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        ans.push_back(label);\\n        int i=1;\\n        while(pow(2,i)<=label)\\n        {\\n            i++;\\n        }\\n        i--;\\n        int val=label;\\n        while(i>0)\\n        {\\n            val=val/2;\\n            val=val-pow(2,i-1);\\n            val=pow(2,i)-val-1;\\n            ans.push_back(val);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241236,
                "title": "c-easy-solution-100-beat-concept-of-2-h-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int i=1;\\n        while(pow(2,i)-1 < label)\\n        {\\n            i++;\\n        }\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(i-1!=0)\\n        {\\n            int v=i-1;\\n            int total=pow(2,v);\\n            int j = label - total;\\n            j=j+j/2;\\n            label=label-j;\\n            label-=1;\\n            ans.push_back(label);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int i=1;\\n        while(pow(2,i)-1 < label)\\n        {\\n            i++;\\n        }\\n        vector<int>ans;\\n        ans.push_back(label);\\n        while(i-1!=0)\\n        {\\n            int v=i-1;\\n            int total=pow(2,v);\\n            int j = label - total;\\n            j=j+j/2;\\n            label=label-j;\\n            label-=1;\\n            ans.push_back(label);\\n            i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232562,
                "title": "o-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int levels = 1;\\n        int nodes = 1;\\n        levels = log2(label);\\n        vector<int>result;\\n        result.push_back(label);\\n        while(levels>0)\\n        {\\n            int dist = (label - pow(2,levels))/2;\\n            label = pow(2,levels)-1-dist;\\n            result.push_back(label);\\n            levels--;\\n        }\\n        reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int levels = 1;\\n        int nodes = 1;\\n        levels = log2(label);\\n        vector<int>result;\\n        result.push_back(label);\\n        while(levels>0)\\n        {\\n            int dist = (label - pow(2,levels))/2;\\n            label = pow(2,levels)-1-dist;\\n            result.push_back(label);\\n            levels--;\\n        }\\n        reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219932,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nvector<int> pathInZigZagTree(int label) {\\n        int level=log2(label)+1;\\n        vector<int> ans;\\n        while(label>0){\\n            ans.insert(ans.begin(),label);\\n            int level_max= (1<<level)-1;\\n            int level_min= 1<<(level-1);\\n            label=(level_max + level_min - label)/2;\\n            level--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> pathInZigZagTree(int label) {\\n        int level=log2(label)+1;\\n        vector<int> ans;\\n        while(label>0){\\n            ans.insert(ans.begin(),label);\\n            int level_max= (1<<level)-1;\\n            int level_min= 1<<(level-1);\\n            label=(level_max + level_min - label)/2;\\n            level--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194882,
                "title": "easy-c-100-fastest",
                "content": "//The idea is we should change parent every time we move up i.e. 15 will be changed to 8, 4 will be changed to 7 as counting is done in zigzig pattern\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int ht=ceil(log2(label+1));\\n        cout<<ht;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        label/=2;ht--;\\n        while (ht>=1){\\n            int orig=pow(2,ht-1)+(pow(2,ht)-1-label);   //orig will give the node number, the current node would come from if counting wasn\\'t done on zigziag\\n            label=orig;\\n            ans.push_back(label);\\n            ht--;\\n            label=label/2;\\n            \\n         }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int ht=ceil(log2(label+1));\\n        cout<<ht;\\n        vector<int> ans;\\n        ans.push_back(label);\\n        label/=2;ht--;\\n        while (ht>=1){\\n            int orig=pow(2,ht-1)+(pow(2,ht)-1-label);   //orig will give the node number, the current node would come from if counting wasn\\'t done on zigziag\\n            label=orig;\\n            ans.push_back(label);\\n            ht--;\\n            label=label/2;\\n            \\n         }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1176846,
                "title": "python3-move-along-the-tree",
                "content": "\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = int(log2(label))\\n        compl = 3*2**level - 1 - label # complement \\n        \\n        ans = []\\n        while label: \\n            ans.append(label)\\n            label //= 2\\n            compl //= 2\\n            label, compl = compl, label\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = int(log2(label))\\n        compl = 3*2**level - 1 - label # complement \\n        \\n        ans = []\\n        while label: \\n            ans.append(label)\\n            label //= 2\\n            compl //= 2\\n            label, compl = compl, label\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166840,
                "title": "c-0ms-100-math-iterative",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Path In Zigzag Labelled Binary Tree.\\nMemory Usage: 6.1 MB, less than 75.52% of C++ online submissions for Path In Zigzag Labelled Binary Tree.\\n**General idea**\\nnuxt number = level * 3 - label / 2 - 1; where level is the number of digits in the \"label\" + 1.\\n```\\nclass Solution {\\npublic:\\n  vector<int> pathInZigZagTree(int label) {\\n    vector <int> answer;\\n    int k = label, level = 1;\\n    while(k != 1) k = k>>1, level = level<<1;\\n    \\n    while(level){\\n      answer.push_back(label);\\n      label = (level>>1) + level - (label>>1) - 1;\\n      level = level>>1;\\n    }\\n    \\n    reverse(answer.begin(),answer.end());\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> pathInZigZagTree(int label) {\\n    vector <int> answer;\\n    int k = label, level = 1;\\n    while(k != 1) k = k>>1, level = level<<1;\\n    \\n    while(level){\\n      answer.push_back(label);\\n      label = (level>>1) + level - (label>>1) - 1;\\n      level = level>>1;\\n    }\\n    \\n    reverse(answer.begin(),answer.end());\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147738,
                "title": "java-iterative-solution-100-0-ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> l=new ArrayList<>();\\n        int temp=label;\\n\\t\\t/**\\n\\t\\tadding nodes from label to root node while considering\\n\\t\\tit as a normal binary tree without zig-zag\\n\\t\\t*/\\n        while(temp>0){\\n            l.add(temp);\\n            temp/=2;\\n        }\\n        Collections.reverse(l);\\n        \\n\\t\\t/**\\n\\t\\tafter reversing list \\n\\t\\tinside for loop \\n\\t\\t1. if list size is even --> the label node is at odd index hence i \\n\\t\\t                             check for even positions and flip the node value using formula \\n\\t\\t2. if list size is odd --> the label node is at even index hence i \\n\\t\\t                             check for odd positions and flip the node value using formula \\t\\t\\n\\t\\thi --> highest value node in that level\\n\\t\\tlo --> lowest value node in that level\\n\\t\\tformula --> if the labeling starts from right to left then I add (hi - currVal = d : distance from \\n\\t\\tcurrent node to last node ) to lo, thereby getting the corresponding node equi-distance(d) from lower node\\n\\t\\t*/\\n        for(int i=0;i<l.size();i++){\\n            boolean flipNode=false;\\n            if(l.size()%2 == 0 && i%2==0){\\n                flipNode=true;\\n            }else if(l.size()%2 != 0 && i%2!=0){\\n                flipNode=true;\\n            }\\n            \\n            if(flipNode){\\n                int lo=(int)Math.pow(2,i);\\n                int hi=(int)Math.pow(2,i+1)-1;\\n                temp=lo+hi-l.get(i);\\n                l.set(i,temp);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> l=new ArrayList<>();\\n        int temp=label;\\n\\t\\t/**\\n\\t\\tadding nodes from label to root node while considering\\n\\t\\tit as a normal binary tree without zig-zag\\n\\t\\t*/\\n        while(temp>0){\\n            l.add(temp);\\n            temp/=2;\\n        }\\n        Collections.reverse(l);\\n        \\n\\t\\t/**\\n\\t\\tafter reversing list \\n\\t\\tinside for loop \\n\\t\\t1. if list size is even --> the label node is at odd index hence i \\n\\t\\t                             check for even positions and flip the node value using formula \\n\\t\\t2. if list size is odd --> the label node is at even index hence i \\n\\t\\t                             check for odd positions and flip the node value using formula \\t\\t\\n\\t\\thi --> highest value node in that level\\n\\t\\tlo --> lowest value node in that level\\n\\t\\tformula --> if the labeling starts from right to left then I add (hi - currVal = d : distance from \\n\\t\\tcurrent node to last node ) to lo, thereby getting the corresponding node equi-distance(d) from lower node\\n\\t\\t*/\\n        for(int i=0;i<l.size();i++){\\n            boolean flipNode=false;\\n            if(l.size()%2 == 0 && i%2==0){\\n                flipNode=true;\\n            }else if(l.size()%2 != 0 && i%2!=0){\\n                flipNode=true;\\n            }\\n            \\n            if(flipNode){\\n                int lo=(int)Math.pow(2,i);\\n                int hi=(int)Math.pow(2,i+1)-1;\\n                temp=lo+hi-l.get(i);\\n                l.set(i,temp);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060623,
                "title": "c-o-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=1,c=1;\\n        vector<int> ans;\\n        while(c*2<=label){\\n            c*=2;\\n            l++;\\n        }\\n        while(label!=0){\\n            ans.push_back(label);\\n            int maxi=((int)pow(2,l))-1;\\n            int mini=((int)pow(2,l-1));\\n            label=(int)(maxi+mini-label)/2;\\n            l--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int l=1,c=1;\\n        vector<int> ans;\\n        while(c*2<=label){\\n            c*=2;\\n            l++;\\n        }\\n        while(label!=0){\\n            ans.push_back(label);\\n            int maxi=((int)pow(2,l))-1;\\n            int mini=((int)pow(2,l-1));\\n            label=(int)(maxi+mini-label)/2;\\n            l--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038907,
                "title": "java-log-n-2",
                "content": "```\\nclass Solution\\n{\\n    private int[] pow2;\\n    private int flip(int x)\\n    {\\n        int k=0;\\n        for(k=0; k<25; k++)\\n        {\\n            if(x>=pow2[k] && x<pow2[k+1])\\n            {\\n                return pow2[k]+pow2[k+1]-1-x;\\n            }\\n        }\\n        return -1;\\n    }\\n    public List<Integer> pathInZigZagTree(int n)\\n    {\\n        int x=1;\\n        pow2 = new int[25];\\n        int i=0;\\n        while(i<25)\\n        {\\n            pow2[i++]=x;\\n            x=x*2;\\n        }\\n        List<Integer> ret = new LinkedList<>();\\n        while(n>0)\\n        {\\n            ret.add(0,n);\\n            n=flip(n/2);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    private int[] pow2;\\n    private int flip(int x)\\n    {\\n        int k=0;\\n        for(k=0; k<25; k++)\\n        {\\n            if(x>=pow2[k] && x<pow2[k+1])\\n            {\\n                return pow2[k]+pow2[k+1]-1-x;\\n            }\\n        }\\n        return -1;\\n    }\\n    public List<Integer> pathInZigZagTree(int n)\\n    {\\n        int x=1;\\n        pow2 = new int[25];\\n        int i=0;\\n        while(i<25)\\n        {\\n            pow2[i++]=x;\\n            x=x*2;\\n        }\\n        List<Integer> ret = new LinkedList<>();\\n        while(n>0)\\n        {\\n            ret.add(0,n);\\n            n=flip(n/2);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025020,
                "title": "c-solution-o-logn-faster-than-100",
                "content": "I get the concept from here [click here](https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/discuss/324011/Python-O(logn)-time-and-space-with-readable-code-and-step-by-step-explanation)\\n```\\nvector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>v;\\n        int level=1;\\n        int level_starting_value=1;\\n        while(label>=level_starting_value*2)     \\n        {\\n            level++;\\n            level_starting_value*=2;\\n        }\\n        while(label)\\n        {\\n            v.push_back(label);\\n            int maxmOfLevel=pow(2,level)-1;\\n            int minmOfLevel=pow(2,level-1);\\n            label=(minmOfLevel+maxmOfLevel-label)/2;\\n            level--;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> pathInZigZagTree(int label) \\n    {\\n        vector<int>v;\\n        int level=1;\\n        int level_starting_value=1;\\n        while(label>=level_starting_value*2)     \\n        {\\n            level++;\\n            level_starting_value*=2;\\n        }\\n        while(label)\\n        {\\n            v.push_back(label);\\n            int maxmOfLevel=pow(2,level)-1;\\n            int minmOfLevel=pow(2,level-1);\\n            label=(minmOfLevel+maxmOfLevel-label)/2;\\n            level--;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 971132,
                "title": "3-different-java-solution-o-n-o-logn-time",
                "content": "\\t//time :O(N) , space O(N)\\n\\t/*\\n\\tapproach 1 : \\n\\t  -> create the zig zag tree upto given label using 2 stacks.\\n\\t  ->traverse and find all ancestors of given label\\n\\t*/\\n\\tclass TreeNode{\\n\\t\\tint data;\\n\\t\\tTreeNode left,right;\\n\\t\\tpublic TreeNode(int data){\\n\\t\\t\\tthis.data=data;\\n\\t\\t}\\n\\t}\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tDeque<TreeNode> s1 = new ArrayDeque<>();\\n\\t\\t\\tDeque<TreeNode> s2 = new ArrayDeque<>();\\n\\t\\t\\tTreeNode root=new TreeNode(1);\\n\\t\\t\\ts1.push(root);\\n\\t\\t\\tint c = 2;\\n\\t\\t\\tboolean isLess = true;\\n\\t\\t\\twhile((!s1.isEmpty() || !s2.isEmpty()) && isLess) {\\n\\t\\t\\t\\t\\twhile(!s1.isEmpty()){\\n\\t\\t\\t\\t\\t\\tTreeNode x = s1.pop();\\n\\t\\t\\t\\t\\t\\tTreeNode l = new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tTreeNode r=  new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tx.right =l;x.left=r;\\n\\t\\t\\t\\t\\t\\ts2.push(l);s2.push(r);\\n\\t\\t\\t\\t\\t\\tif(c>label){\\n\\t\\t\\t\\t\\t\\t\\tisLess = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!isLess)break;\\n\\t\\t\\t\\twhile(!s2.isEmpty()){\\n\\t\\t\\t\\t\\t\\tTreeNode x = s2.pop();\\n\\t\\t\\t\\t\\t\\tTreeNode l = new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tTreeNode r=  new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tx.left =l;x.right=r;\\n\\t\\t\\t\\t\\t\\ts1.push(l);s1.push(r);\\n\\t\\t\\t\\t\\t\\tif(c>label){\\n\\t\\t\\t\\t\\t\\t\\tisLess = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tLinkedList<Integer> ans = new LinkedList<>();\\n\\t\\t\\tform(root,ans,label);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tprivate boolean form( TreeNode root,LinkedList<Integer> ans,int label){\\n\\t\\t\\tif(root==null)return false;\\n\\t\\t\\tif(root.data==label){\\n\\t\\t\\t\\tans.addFirst(root.data);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tboolean l = form(root.left,ans,label);\\n\\t\\t\\tif(l){\\n\\t\\t\\t\\tans.addFirst(root.data);\\n\\t\\t\\t\\treturn l;\\n\\t\\t\\t}\\n\\t\\t\\tboolean r = form(root.right,ans,label);\\n\\t\\t\\tif(r){\\n\\t\\t\\t\\tans.addFirst(root.data);\\n\\t\\t\\t\\treturn r;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t// time : O(N)  , space O(N) \\n\\t/*approach 2 : \\n\\t  ->Instead to creating Tree , what we can do it to store level order of the zig zag tree in a list.\\n\\t  -> for any index i , (i-1)/2 th index is the index of its parent\\n\\t  */\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\tlist.add(1);\\n\\t\\t\\tboolean isSmall = true;\\n\\t\\t\\tfor(int i=2;i<=label;i++){\\n\\t\\t\\t\\tif(i%2==0){\\n\\t\\t\\t\\t\\tfor(int j=(int)Math.pow(2,i)-1;j>Math.pow(2,i-1)-1;j--){\\n\\t\\t\\t\\t\\t\\t list.add(j);\\n\\t\\t\\t\\t\\t\\t if(j==label){\\n\\t\\t\\t\\t\\t\\t\\tisSmall=false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int j=(int)Math.pow(2,i-1);j<Math.pow(2,i);j++){\\n\\t\\t\\t\\t\\t\\tlist.add(j);\\n\\t\\t\\t\\t\\t\\tif(j==label){\\n\\t\\t\\t\\t\\t\\t\\tisSmall=false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!isSmall)break;\\n\\t\\t\\t}\\n\\t\\t\\tLinkedList<Integer> ans = new LinkedList<>();\\n\\t\\t\\tans.add(label);\\n\\t\\t\\t int zz=list.size()-1;\\n\\t\\t\\twhile(zz>0){\\n\\t\\t\\t\\tans.addFirst(list.get((zz-1)/2));\\n\\t\\t\\t\\tzz=(zz-1)/2;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\t//time O(logn) , space O(logn)\\n\\t// approach 3 :\\n\\t/*\\n\\t  ->Now instead of storing the whole tree, we can initially store all the ancestors of label(like for a normal tree) without thinking zig zag tree.\\n\\t  ->Now we need to change those values in the list which need to be reversed due to zig zag tree.(every alternative ancestor)\\n\\t  -> upon observation we can see that the new value is the mirror image of the origional value.\\n\\t  -> like we can find the diff btw origional value and the nearest greater power of 2 ,  \\n\\t  -> so the new value will be the nearest smallest power of 2 + the calculated diff.\\n\\t  -> one thing to keep in mind that we need to change either even indexed ancestor or odd indexed ancestors\\n\\t  -> we can find this with the help of # of ancestors of label.\\n\\t  -> if the # of ancestors(same as list size) is odd then we change odd indexed ancestors else change even indexed ancestors.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tLinkedList<Integer> list =new LinkedList<>();\\n\\t\\t\\twhile(label>0){\\n\\t\\t\\t\\tlist.addFirst(label);\\n\\t\\t\\t\\tlabel/=2;\\n\\t\\t\\t}\\n\\t\\t\\tArrayList<Integer> ans = new ArrayList(list);\\n\\t\\t\\tint s = 0;\\n\\t\\t\\tif(ans.size()%2==1)s=1;\\n\\t\\t\\tfor(int i=s;i<ans.size()-1;i+=2){\\n\\t\\t\\t\\tint add = (int)Math.pow(2,i+1)-1-ans.get(i);\\n\\t\\t\\t\\tans.set(i,(int)Math.pow(2,i)+add);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> pathInZigZagTree(int label) {\\n\\t\\t\\tDeque<TreeNode> s1 = new ArrayDeque<>();\\n\\t\\t\\tDeque<TreeNode> s2 = new ArrayDeque<>();\\n\\t\\t\\tTreeNode root=new TreeNode(1);\\n\\t\\t\\ts1.push(root);\\n\\t\\t\\tint c = 2;\\n\\t\\t\\tboolean isLess = true;\\n\\t\\t\\twhile((!s1.isEmpty() || !s2.isEmpty()) && isLess) {\\n\\t\\t\\t\\t\\twhile(!s1.isEmpty()){\\n\\t\\t\\t\\t\\t\\tTreeNode x = s1.pop();\\n\\t\\t\\t\\t\\t\\tTreeNode l = new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tTreeNode r=  new TreeNode(c++);\\n\\t\\t\\t\\t\\t\\tx.right =l;x.left=r;\\n\\t\\t\\t\\t\\t\\ts2.push(l);s2.push(r);\\n\\t\\t\\t\\t\\t\\tif(c>label){\\n\\t\\t\\t\\t\\t\\t\\tisLess = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 947288,
                "title": "c-code-well-commented-and-explained-0ms-faster-than-100",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Path In Zigzag Labelled Binary Tree.**\\n**Memory Usage: 6.6 MB, less than 64.06% of C++ online submissions for Path In Zigzag Labelled Binary Tree.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        if(label == 1)\\n            return {1};\\n        \\n        \\n        int level = log2(label); //Formula to get the depth or level where the element is located\\n        \\n        res.insert(res.begin(), label); //Insert it into result vector\\n        level--; //We store the elements from the previous level to the 0th level\\n        \\n        while(level != 0){\\n            label = 3 * pow(2, level) - 1 - label/2; //Formula to get the element for each level\\n            res.insert(res.begin(), label); //Insert it into the resultant vector\\n            level--;           //Decrease level by 1\\n        }\\n        res.insert(res.begin(), 1); //As 1 will always be the first element and we didnt included level 0 till now so push 1 to the beginning\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> res;\\n        if(label == 1)\\n            return {1};\\n        \\n        \\n        int level = log2(label); //Formula to get the depth or level where the element is located\\n        \\n        res.insert(res.begin(), label); //Insert it into result vector\\n        level--; //We store the elements from the previous level to the 0th level\\n        \\n        while(level != 0){\\n            label = 3 * pow(2, level) - 1 - label/2; //Formula to get the element for each level\\n            res.insert(res.begin(), label); //Insert it into the resultant vector\\n            level--;           //Decrease level by 1\\n        }\\n        res.insert(res.begin(), 1); //As 1 will always be the first element and we didnt included level 0 till now so push 1 to the beginning\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875417,
                "title": "convert-to-binary-log-n-2-complexity-worse-than-logn-but-interesting",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        x=bin(label)[2:]\\n        n = len(x)\\n        #invert path\\n        y=\"1\"\\n        for i in range(1, n): y += \"0\" if x[i] == \"1\" else \"1\"\\n        #Follow path in odd even fashion\\n        out = []\\n        for i in range(n):\\n            if n%2 == 0:\\n                if i % 2 == 1: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n            else:\\n                if i % 2 == 0: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        x=bin(label)[2:]\\n        n = len(x)\\n        #invert path\\n        y=\"1\"\\n        for i in range(1, n): y += \"0\" if x[i] == \"1\" else \"1\"\\n        #Follow path in odd even fashion\\n        out = []\\n        for i in range(n):\\n            if n%2 == 0:\\n                if i % 2 == 1: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n            else:\\n                if i % 2 == 0: out.append(int(x[:i+1], 2))\\n                else: out.append(int(y[:i+1], 2))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845575,
                "title": "typescript-simple-o-logn-beats-100-w-detailed-comments",
                "content": "```\\nfunction pathInZigZagTree(label: number): number[] {\\n    // find level this label is on\\n    let level: number = Math.floor(Math.log(label) / Math.log(2) + 1);\\n\\n    // create an empty path array of size level\\n    // (since we need to go that many levels to reach label)\\n    const path: number[] = Array(level);\\n\\n    // go until label is 0\\n    while (label > 0) {\\n        // at this level is simply the label (node we encountered in path)\\n        path[level - 1] = label;\\n\\n        // calculate symmetric node on other side (since we are zig zagging)\\n        label = 2 ** level - 1 - label + 2 ** (level - 1);\\n\\n        // right shift by 1 since we are going up a level\\n        label >>= 1;\\n\\n        // go up a level\\n        level--;\\n    }\\n\\n    return path;\\n}\\n```\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction pathInZigZagTree(label: number): number[] {\\n    // find level this label is on\\n    let level: number = Math.floor(Math.log(label) / Math.log(2) + 1);\\n\\n    // create an empty path array of size level\\n    // (since we need to go that many levels to reach label)\\n    const path: number[] = Array(level);\\n\\n    // go until label is 0\\n    while (label > 0) {\\n        // at this level is simply the label (node we encountered in path)\\n        path[level - 1] = label;\\n\\n        // calculate symmetric node on other side (since we are zig zagging)\\n        label = 2 ** level - 1 - label + 2 ** (level - 1);\\n\\n        // right shift by 1 since we are going up a level\\n        label >>= 1;\\n\\n        // go up a level\\n        level--;\\n    }\\n\\n    return path;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840617,
                "title": "java-simple-solution",
                "content": "```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        int n = (int)(Math.log(label)/Math.log(2))+1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (n > 0) {\\n            list.addFirst(label);\\n            int ref = (1<<n)+(1<<n-1)-label-1;\\n            label = ref/2;\\n            n--;\\n        }\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<Integer> pathInZigZagTree(int label) {\\n        int n = (int)(Math.log(label)/Math.log(2))+1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        while (n > 0) {\\n            list.addFirst(label);\\n            int ref = (1<<n)+(1<<n-1)-label-1;\\n            label = ref/2;\\n            n--;\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 838927,
                "title": "java-0ms-100-faster-14-lines",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int s = (int) (Math.log(label)/Math.log(2));\\n        List<Integer> result = new ArrayList<>(s+1);\\n        result.add(label);\\n        for(int i = s; i > 0; i--){\\n            int k = (int) (label - Math.pow(2,i))/2;\\n            label = (int)Math.pow(2,i) - 1 - k;\\n            result.add(label);\\n        }\\n        Collections.sort(result);\\n        return  result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int s = (int) (Math.log(label)/Math.log(2));\\n        List<Integer> result = new ArrayList<>(s+1);\\n        result.add(label);\\n        for(int i = s; i > 0; i--){\\n            int k = (int) (label - Math.pow(2,i))/2;\\n            label = (int)Math.pow(2,i) - 1 - k;\\n            result.add(label);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 837634,
                "title": "c-readable-code-formula-based-to-compute-parent-explanation",
                "content": "Formula derivation here => https://imgur.com/FdKcoMf\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int current = label, parent;\\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        \\n        while (current != 1) {\\n            parent = getParent(current);\\n            ans.push_back(parent);\\n            current = parent;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    private:\\n    int getLevel(int num) {\\n        int i = 0;\\n        while(pow(2, i) <= num) {\\n            i++;\\n        }\\n        return i - 1;\\n    }\\n    int getParent(int child) {\\n        int levelOfChild = getLevel(child);\\n        int levelOfParent = levelOfChild - 1;\\n        return (1<<levelOfChild) + (1<<levelOfParent) - (1 + (child>>1));\\n        // return pow(2, levelOfChild) + pow(2, levelOfParent) - (1 + child/2) ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int current = label, parent;\\n        \\n        vector<int> ans;\\n        ans.push_back(label);\\n        \\n        while (current != 1) {\\n            parent = getParent(current);\\n            ans.push_back(parent);\\n            current = parent;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    private:\\n    int getLevel(int num) {\\n        int i = 0;\\n        while(pow(2, i) <= num) {\\n            i++;\\n        }\\n        return i - 1;\\n    }\\n    int getParent(int child) {\\n        int levelOfChild = getLevel(child);\\n        int levelOfParent = levelOfChild - 1;\\n        return (1<<levelOfChild) + (1<<levelOfParent) - (1 + (child>>1));\\n        // return pow(2, levelOfChild) + pow(2, levelOfParent) - (1 + child/2) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822768,
                "title": "short-and-simple-solution-time-space-complexity-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        int lvl = log2(label)+1;\\n        vector<int> ans(lvl,0);\\n        \\n        while(label>=1){\\n            \\n            ans[lvl-1] = label;\\n            label = pow(2,lvl-1)+pow(2,lvl-2)-1-label/2;\\n            lvl--;\\n        }\\n        \\n    return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        \\n        int lvl = log2(label)+1;\\n        vector<int> ans(lvl,0);\\n        \\n        while(label>=1){\\n            \\n            ans[lvl-1] = label;\\n            label = pow(2,lvl-1)+pow(2,lvl-2)-1-label/2;\\n            lvl--;\\n        }\\n        \\n    return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813183,
                "title": "c-clean-code-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while (label) {\\n            ans.insert(ans.begin(), label);\\n            label /= 2;\\n        }\\n        for (int i = 2 - ans.size() % 2; i < ans.size() - 1; i += 2)\\n            ans[i] = 3 * pow(2, i) - 1 - ans[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while (label) {\\n            ans.insert(ans.begin(), label);\\n            label /= 2;\\n        }\\n        for (int i = 2 - ans.size() % 2; i < ans.size() - 1; i += 2)\\n            ans[i] = 3 * pow(2, i) - 1 - ans[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807272,
                "title": "super-short-c-code-beats-100-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int x = log2(label);    //getting number of levels required\\n        vector<int> ans(x+1,1); // Initializing vector with value 1\\n        while(x){                     \\n            ans[x--] = label;\\n            label /= 2;\\n            label = (1<<x+1) + (1<<x) - label - 1; // calculating required value for each level\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int x = log2(label);    //getting number of levels required\\n        vector<int> ans(x+1,1); // Initializing vector with value 1\\n        while(x){                     \\n            ans[x--] = label;\\n            label /= 2;\\n            label = (1<<x+1) + (1<<x) - label - 1; // calculating required value for each level\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 791261,
                "title": "c-fastest-and-easiest-code-using-the-properties-of-a-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while(label){\\n            ans.push_back(label);\\n            label/=2;\\n        }\\n        bool tmp=ans.size()%2;\\n        reverse(ans.begin(),ans.end());\\n        for(int i=tmp;i<ans.size();i+=2){\\n            ans[i]=pow(2,i+1)-ans[i]+pow(2,i)-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ans;\\n        while(label){\\n            ans.push_back(label);\\n            label/=2;\\n        }\\n        bool tmp=ans.size()%2;\\n        reverse(ans.begin(),ans.end());\\n        for(int i=tmp;i<ans.size();i+=2){\\n            ans[i]=pow(2,i+1)-ans[i]+pow(2,i)-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781732,
                "title": "swift-solution",
                "content": "```\\nfinal class Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        var labelCopy = label\\n\\n        var level = 0\\n        while labelCopy > 0 {\\n            level += 1\\n            labelCopy = labelCopy/2\\n        }\\n\\n        var output = [Int]()\\n        var nextLevel = label\\n        while level > 0 {\\n            let min = Double(pow(Double(2.0), Double(level - 1)))\\n            let max = Double(pow(Double(2.0), Double(level)) - 1.0)\\n            output.append(nextLevel)\\n            nextLevel = (Int(max + min) - nextLevel) / 2\\n            level -= 1\\n        }\\n        return output.reversed()\\n    }\\n }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        var labelCopy = label\\n\\n        var level = 0\\n        while labelCopy > 0 {\\n            level += 1\\n            labelCopy = labelCopy/2\\n        }\\n\\n        var output = [Int]()\\n        var nextLevel = label\\n        while level > 0 {\\n            let min = Double(pow(Double(2.0), Double(level - 1)))\\n            let max = Double(pow(Double(2.0), Double(level)) - 1.0)\\n            output.append(nextLevel)\\n            nextLevel = (Int(max + min) - nextLevel) / 2\\n            level -= 1\\n        }\\n        return output.reversed()\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740010,
                "title": "java-0ms-so-easy-your-mom-will-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        // loga b = log10 b / log10 a\\n        int lvl = 1+ (int) (Math.log(label) / Math.log(2));\\n        while (label > 0) {\\n            ans.add(0, label);\\n            label = (int)((Math.pow(2,lvl)-1) + (Math.pow(2,lvl-1)) - label);\\n            label = label/2;\\n            lvl--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        // loga b = log10 b / log10 a\\n        int lvl = 1+ (int) (Math.log(label) / Math.log(2));\\n        while (label > 0) {\\n            ans.add(0, label);\\n            label = (int)((Math.pow(2,lvl)-1) + (Math.pow(2,lvl-1)) - label);\\n            label = label/2;\\n            lvl--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705519,
                "title": "java-0ms-math",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int n = 1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        list.add(label);\\n\\t\\t// the the level of the node\\n        while(Math.pow(2, n) - 1 < label){\\n            n++;\\n        }\\n\\t\\t// check the lcoation of each row by finding the symmetry\\n        while(n > 1){\\n            label /= 2;\\n\\t\\t\\t// base case, we are at the first row\\n            if(n == 2){\\n                list.addFirst(label);\\n                break;\\n            }\\n            n--; // go up\\n\\t\\t\\t// get the middle of current row\\n            int min = (int)Math.pow(2, n - 1); // min of current row\\n            int max = (int)Math.pow(2, n) - 1; // max of current row\\n            int middle = min + (max - min) / 2; // middle\\n            \\n            int location = middle - label + 1 + middle; // get the location\\n            list.addFirst(location); //add to the result\\n            label = location; // reset the label\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int n = 1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        list.add(label);\\n\\t\\t// the the level of the node\\n        while(Math.pow(2, n) - 1 < label){\\n            n++;\\n        }\\n\\t\\t// check the lcoation of each row by finding the symmetry\\n        while(n > 1){\\n            label /= 2;\\n\\t\\t\\t// base case, we are at the first row\\n            if(n == 2){\\n                list.addFirst(label);\\n                break;\\n            }\\n            n--; // go up\\n\\t\\t\\t// get the middle of current row\\n            int min = (int)Math.pow(2, n - 1); // min of current row\\n            int max = (int)Math.pow(2, n) - 1; // max of current row\\n            int middle = min + (max - min) / 2; // middle\\n            \\n            int location = middle - label + 1 + middle; // get the location\\n            list.addFirst(location); //add to the result\\n            label = location; // reset the label\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696831,
                "title": "c-100-faster-with-explaination-easy-to-understand-o-1-memory",
                "content": "We first find the level of the current label. Then we traverse the tree up from the node in a tree assuming it is an ordinary binary tree, by taking the mirror image of the current value in the present level. Each level start with (1<<level) numbered node and ends with (1<<(level+1)) -1 numbered node. So we can get the mirror imaged node by taking the difference from the upper value and incrementing the same difference to the lower value. Then we find its parent which is equal to the (node/2) in an ordinary binary tree.\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int cur=0;\\n        int level=0;\\n        while(cur<label)\\n        {\\n            cur=cur+(1<<level);\\n            level++;\\n        }\\n        level--;                    // this is the level of our label\\n        vector<int> ans;\\n        int temp=label;\\n        // cout<<level;\\n        while(level>0 and temp!=1)\\n        {\\n            ans.push_back(temp);    // push the current label\\n            int start=1<<level;\\n            int diff=(1<<(level+1))-1-temp;\\n            int rev=start+diff;     // flip it in a way that it would be present in an ordinary binary tree\\n            temp=rev/2;             // this is the parent in the ordinary binary tree\\n            level--;                // level of the parent node of temp\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        int cur=0;\\n        int level=0;\\n        while(cur<label)\\n        {\\n            cur=cur+(1<<level);\\n            level++;\\n        }\\n        level--;                    // this is the level of our label\\n        vector<int> ans;\\n        int temp=label;\\n        // cout<<level;\\n        while(level>0 and temp!=1)\\n        {\\n            ans.push_back(temp);    // push the current label\\n            int start=1<<level;\\n            int diff=(1<<(level+1))-1-temp;\\n            int rev=start+diff;     // flip it in a way that it would be present in an ordinary binary tree\\n            temp=rev/2;             // this is the parent in the ordinary binary tree\\n            level--;                // level of the parent node of temp\\n        }\\n        ans.push_back(1);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 676197,
                "title": "c-0ms-solution-w-backtracking",
                "content": "Run-time is `O(logn)`. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        std::vector<int> res;\\n        int cur{label}, row{(int)std::log2(label)}, l{1<<row}, r{(1<<(row+1))-1};\\n        while(row != 0) {\\n            res.emplace_back(cur);\\n            int nextL{1<<(row-1)}, nextR{(1<<row)-1};\\n            if(row % 2) cur = nextL + ((r-cur)>>1);\\n            else cur = nextR - ((cur-l)>>1);\\n            l = nextL, r = nextR;\\n            --row;\\n        }\\n        res.emplace_back(1);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        std::vector<int> res;\\n        int cur{label}, row{(int)std::log2(label)}, l{1<<row}, r{(1<<(row+1))-1};\\n        while(row != 0) {\\n            res.emplace_back(cur);\\n            int nextL{1<<(row-1)}, nextR{(1<<row)-1};\\n            if(row % 2) cur = nextL + ((r-cur)>>1);\\n            else cur = nextR - ((cur-l)>>1);\\n            l = nextL, r = nextR;\\n            --row;\\n        }\\n        res.emplace_back(1);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670769,
                "title": "c-arithmetic-explained-100-speed-100-memory",
                "content": "Starting with n, iteratively decrement with a transform expression to trace the path through the tree. At each step up in the tree, the value in the path will be the minimum value at that level plus some offset.\\n\\nThe offset is calculated as the difference between the maximum value at the new level and the current n value divided by 2. This quantity basically enables the \\'flipping\\' in the value between maximum and minimum of the new value and then adding to the extent that it\\'s needed such that the correct node \\'bucket\\' is identified.\\n\\nNote: unnecessary brackets are used to help others follow the math logic.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int n) {\\n        int l = getLevel(n);           //Get n\\'s level\\n        vector<int> ans(l+1, 0);       //Answer has level number of spaces (the path through each level) plus the root level\\n        int i = l;                     //for iterating from deepest level to the root\\n        while(n > 1){                  //Iterating from n to 1\\n            ans[i] = n;\\n            n = pow(2,l-1) + ((pow(2,l) - 1) - n/2); //At each step in the path, transform n = (first number of next level = pow(2,l-1)) + ((max at next level up = pow(2,l) - 1) - (n/2))\\n            l--;\\n            i--;\\n        }\\n        ans[0] = 1;     //Set the remaining value to the root value\\n        return ans;\\n    }\\n    \\n    //Get the zero-indexed level that the label n exists on\\n    int getLevel(int n) {\\n        return (n == 1)? 0 : getLevel(n/2)+1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int n) {\\n        int l = getLevel(n);           //Get n\\'s level\\n        vector<int> ans(l+1, 0);       //Answer has level number of spaces (the path through each level) plus the root level\\n        int i = l;                     //for iterating from deepest level to the root\\n        while(n > 1){                  //Iterating from n to 1\\n            ans[i] = n;\\n            n = pow(2,l-1) + ((pow(2,l) - 1) - n/2); //At each step in the path, transform n = (first number of next level = pow(2,l-1)) + ((max at next level up = pow(2,l) - 1) - (n/2))\\n            l--;\\n            i--;\\n        }\\n        ans[0] = 1;     //Set the remaining value to the root value\\n        return ans;\\n    }\\n    \\n    //Get the zero-indexed level that the label n exists on\\n    int getLevel(int n) {\\n        return (n == 1)? 0 : getLevel(n/2)+1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655845,
                "title": "python-faster-than-100-simple-explained-4-lines",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n            r.append(label)\\n        return r[::-1]\\n\\n```\\n\\nGeneral approach:\\n\\n1. First we find what level the label is on. `math.ceil(math.log2(label + 1))` . This looks complicated, but it\\'s not.\\n\\nIf you look at the tree:\\n\\n```\\n1 - range 2**0 - level 1\\n3 2 - range 2**1 ... 2**2-1 - level 2\\n4 5 6 7 - range 2**2 ... 2**3-1 - level 3\\n```\\n\\nit makes sense. `label + 1` will be in the range `2**(x-1) < label + 1 <= 2**x`, so `log2(label+1)` rounded up will give us the level.\\n\\nThe list `r` is our return array. We can pre-populate it with the initial `label`.\\n\\nNow we spin a loop and we go level by level from the bottom up:\\n\\n```\\n        for l in range(l-1,0,-1):\\n```\\n\\nand at each step we calculate the label above and add it to the return list.\\n\\nHow do we calculate the label above?\\n\\nThe code is:\\n\\n```\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n```\\nto make it more readable:\\n\\n```\\nif l%2==0:\\n\\tlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\nelse:\\n\\tlabel = (2**l) - 1 - (label - 2**l)//2\\n```\\n\\nWhat is going on here? First, due to zigzag numbering, we treat odd and even levels different - this is what `if l%2==0` for.\\nNow, some simple logic. let\\'s say our current label is the 3rd element in the current level (from the left, index starts at 0). in order to tell the index of the parent element, we need to split the elements on the current level into pairs and the index of the pair will be the index of the parent element.  The we apply that offset to the left most element on the upper level.\\n\\nSo for even rows:\\n\\n```\\nlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\n```\\nwhere `2**(l-1)` is the leftmost element of the level above and the `(2**(l+1) - 1 - label)//2` is the pair index and for the even:\\n`(2**l) - 1` is the leftmost and ` (label - 2**l)//2` is the pair index.\\n\\nNow we just need to return the elements in the reversed order and we are done:\\n```\\n        return r[::-1]\\n```\\n\\nNow we can save a line by combining the 2 lines inside loop into 1:\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            r.append(2**(l-1) + (2**(l+1) - 1 - r[-1])//2 if l%2==0 else  (2**l) - 1 - (r[-1] - 2**l)//2)\\n        return r[::-1]\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n            r.append(label)\\n        return r[::-1]\\n\\n```\n```\\n1 - range 2**0 - level 1\\n3 2 - range 2**1 ... 2**2-1 - level 2\\n4 5 6 7 - range 2**2 ... 2**3-1 - level 3\\n```\n```\\n        for l in range(l-1,0,-1):\\n```\n```\\n            label = 2**(l-1) + (2**(l+1) - 1 - label)//2 if l%2==0 else  (2**l) - 1 - (label - 2**l)//2\\n```\n```\\nif l%2==0:\\n\\tlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\nelse:\\n\\tlabel = (2**l) - 1 - (label - 2**l)//2\\n```\n```\\nlabel = 2**(l-1) + (2**(l+1) - 1 - label)//2\\n```\n```\\n        return r[::-1]\\n```\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        l,r = math.ceil(math.log2(label + 1)),[label]\\n        for l in range(l-1,0,-1):\\n            r.append(2**(l-1) + (2**(l+1) - 1 - r[-1])//2 if l%2==0 else  (2**l) - 1 - (r[-1] - 2**l)//2)\\n        return r[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647518,
                "title": "c-5-lines-o-log-n-math-solution-explained",
                "content": "If we look at the non-zigzag tree as below\\n```\\n\\t\\t\\t\\t\\t1                    row 0\\n\\t\\t\\t2                3           row 1\\n\\t    4       5        6        7      row 2\\n\\t  8   9   10  11   12  13   14  15   row 3\\n```\\nLet\\'s take ```14``` as an example:\\nIf we want to go from the leaf node with value ```14``` to the root node with value ```1```, what we need to do is to keep deviding by 2 from ```14``` to ```1```, which gives ```14, 7, 3, 1```.\\n\\nLet\\'s say now we are standing at node with value ```14```. To consider the zigzag structure, we need to modify the values coming from the row above us, and every alternative rows (in this given example, it would be row 2 and row 0 shown in the figure above).\\n\\nSo how to do the modification? We notice that row ```i``` starts with value of ```2^i```. Let\\'s call this value as \"base\".\\nThen, If we substract \"base\" from all the values in this row, they will look like:\\n```\\n\\t\\t\\t\\t\\t0                    row 0 (base = 1)\\n\\t\\t\\t0                1           row 1 (base = 2)\\n\\t    0       1        2        3      row 2 (base = 4)\\n\\t  0   1   2   3    4   5    6   7    row 3 (base = 8)\\n\\t\\t  ~                     ~\\n```\\nSo the original ```14``` is corresponding to ```6``` now, and the position that we need it to be is ```1``` (both marked with ```~``` in the figure above). Clearly, we want to do things like: \\n\\n```new value = (base - 1) - current value```\\n\\nBut remeber, we substracted \"base\" from each element previously, so we need change the equation above into:\\n\\n```(new value - base) = (base - 1) - (current value - base)```\\n\\nand we therefore get:\\n\\n```new value = 3 * base - 1 - current value```\\n\\n\\nThis algorithm gives us O(log n) time compelexity in the step of dividing ```n``` by 2 until 0. The modification step and the reverse step takes the same order time complexity as well, since they process the same amount of values as the dividing step. Therefore, overall time complexity is still O(log n).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ret;\\n        for (; label; label >>= 1) ret.push_back(label);\\n        for (int i = 1; i < ret.size(); i += 2) ret[i] = 3 * (1 << (ret.size() - 1 - i)) - 1 - ret[i];\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t1                    row 0\\n\\t\\t\\t2                3           row 1\\n\\t    4       5        6        7      row 2\\n\\t  8   9   10  11   12  13   14  15   row 3\\n```\n```14```\n```14```\n```1```\n```14```\n```1```\n```14, 7, 3, 1```\n```14```\n```i```\n```2^i```\n```\\n\\t\\t\\t\\t\\t0                    row 0 (base = 1)\\n\\t\\t\\t0                1           row 1 (base = 2)\\n\\t    0       1        2        3      row 2 (base = 4)\\n\\t  0   1   2   3    4   5    6   7    row 3 (base = 8)\\n\\t\\t  ~                     ~\\n```\n```14```\n```6```\n```1```\n```~```\n```new value = (base - 1) - current value```\n```(new value - base) = (base - 1) - (current value - base)```\n```new value = 3 * base - 1 - current value```\n```n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> ret;\\n        for (; label; label >>= 1) ret.push_back(label);\\n        for (int i = 1; i < ret.size(); i += 2) ret[i] = 3 * (1 << (ret.size() - 1 - i)) - 1 - ret[i];\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644205,
                "title": "java-simple-solution-using-linkedlist",
                "content": "![image](https://assets.leetcode.com/users/mart74/image_1590087859.png)\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list=new LinkedList<Integer>();\\n        //Go up from label to 1\\n        while(label>0){\\n            list.push(label);\\n            label/=2;\\n        }//~\\n        \\n        int n=list.size();\\n        for(int i=1;i<n;i++){            \\n            //Change in dependency from parity n \\n            if(n%2!=0&&i%2!=0||n%2==0&&i%2==0){   \\n               int val=list.get(i).intValue();\\n               int lower=(int)Math.pow(2,i); \\n               int upper=2*lower-1; \\n               list.set(i,lower+(upper-val));\\n            }\\n        }//~\\n        \\n        return list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        LinkedList<Integer> list=new LinkedList<Integer>();\\n        //Go up from label to 1\\n        while(label>0){\\n            list.push(label);\\n            label/=2;\\n        }//~\\n        \\n        int n=list.size();\\n        for(int i=1;i<n;i++){            \\n            //Change in dependency from parity n \\n            if(n%2!=0&&i%2!=0||n%2==0&&i%2==0){   \\n               int val=list.get(i).intValue();\\n               int lower=(int)Math.pow(2,i); \\n               int upper=2*lower-1; \\n               list.set(i,lower+(upper-val));\\n            }\\n        }//~\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574477,
                "title": "c-o-logn-logn-readable-iterative-6-3-mb-less-memory-than-100",
                "content": "A more readable solution, \\nO(log<sup>2</sup>n): for each level, we call the method `getLevel` adding extra factor of `logn` \\n```\\nclass Solution {\\n    int getLevel(int number) {\\n        // returns the depth of node of \\'number\\'\\n        return log2(number);\\n    }\\n    \\n    long long int getNumberInLevel(int level) {\\n        // returns number of nodes in the given level\\n        return (1 << level);\\n    }\\n    \\n    long long int getParent(int number) {\\n        // get the expected parent of given number in normal Binary Tree\\n        int parent = number / 2, level = getLevel(parent);\\n        \\n        // find the lowest valued node in the level\\n        long long int first = (1LL << level), size = getNumberInLevel(level);\\n        \\n        // As it is a zig-zag tree, \\'i\\'th node from first in normal tree\\n        // will be located as \\'i\\'th node from the end in the same level\\n        long long int last = first + size -1, dist = parent - first;\\n        \\n        return last - dist;\\n    }\\n    \\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> order;\\n        \\n        // Climb up the tree while we don\\'t reach the root\\n        while(label != 1) {\\n            order.push_back(label);\\n            label = getParent(label);\\n        }   \\n        \\n        order.push_back(label);\\n        reverse(order.begin(), order.end());\\n        \\n        return order;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int getLevel(int number) {\\n        // returns the depth of node of \\'number\\'\\n        return log2(number);\\n    }\\n    \\n    long long int getNumberInLevel(int level) {\\n        // returns number of nodes in the given level\\n        return (1 << level);\\n    }\\n    \\n    long long int getParent(int number) {\\n        // get the expected parent of given number in normal Binary Tree\\n        int parent = number / 2, level = getLevel(parent);\\n        \\n        // find the lowest valued node in the level\\n        long long int first = (1LL << level), size = getNumberInLevel(level);\\n        \\n        // As it is a zig-zag tree, \\'i\\'th node from first in normal tree\\n        // will be located as \\'i\\'th node from the end in the same level\\n        long long int last = first + size -1, dist = parent - first;\\n        \\n        return last - dist;\\n    }\\n    \\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> order;\\n        \\n        // Climb up the tree while we don\\'t reach the root\\n        while(label != 1) {\\n            order.push_back(label);\\n            label = getParent(label);\\n        }   \\n        \\n        order.push_back(label);\\n        reverse(order.begin(), order.end());\\n        \\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566211,
                "title": "clean-c-100-space-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>ans;\\n        while(label){\\n            ans.push_back(label);\\n            int l = floor(log2(label));\\n            int actual = pow(2,l+1)-1 + pow(2,l) - label;\\n            label = actual/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int>ans;\\n        while(label){\\n            ans.push_back(label);\\n            int l = floor(log2(label));\\n            int actual = pow(2,l+1)-1 + pow(2,l) - label;\\n            label = actual/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546889,
                "title": "java-straightforward-recursive-solution-o-logn",
                "content": "The first idea comes into my head is recursion because there is a \"Tree\" keyword. Although the question is not directly related to tree, we can solve it by recursion in a straight forward manner.\\n\\nThe recursive function take the lower(inclusive) label  and the higher label (exclusive) of current row, a boolean to indicate whether current row is in reverse manner, and the target label we need to find, and it returns the position of the node in current row which is the label node or is the ancestor of the label node. The position returned can help us to find the label of its parent.\\n\\n```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new ArrayList<>();\\n        findLabel(1, 2, false, label, result);\\n        Collections.reverse(result);\\n        return result;\\n    }\\n    \\n    private int findLabel(int lower, int upper, boolean reversed, int label, List<Integer> result) {\\n        if (label >= lower && label < upper) {\\n            int currPos = reversed ? (upper - label) : (label - lower + 1);\\n            result.add(label);\\n            return currPos;\\n        }\\n        int bottomPos = findLabel(upper, upper * 2, !reversed, label, result);\\n        int currPos = (bottomPos - 1) / 2 + 1;\\n        int currLabel = reversed ? (upper - currPos) : (lower + currPos - 1);\\n        result.add(currLabel);\\n        return currPos;\\n    }\\n}\\n\\n/*\\nfirst line: <= 2^0\\nsecond line: 2^1 <= x < 2^2\\nthird line: 2^2 <=\\n\\nrecursive function:\\n    input: lower, upper, reversed\\n    output: pos of node where label is itself or under its subtree\\n            pos is always from left to right, start from 1\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> result = new ArrayList<>();\\n        findLabel(1, 2, false, label, result);\\n        Collections.reverse(result);\\n        return result;\\n    }\\n    \\n    private int findLabel(int lower, int upper, boolean reversed, int label, List<Integer> result) {\\n        if (label >= lower && label < upper) {\\n            int currPos = reversed ? (upper - label) : (label - lower + 1);\\n            result.add(label);\\n            return currPos;\\n        }\\n        int bottomPos = findLabel(upper, upper * 2, !reversed, label, result);\\n        int currPos = (bottomPos - 1) / 2 + 1;\\n        int currLabel = reversed ? (upper - currPos) : (lower + currPos - 1);\\n        result.add(currLabel);\\n        return currPos;\\n    }\\n}\\n\\n/*\\nfirst line: <= 2^0\\nsecond line: 2^1 <= x < 2^2\\nthird line: 2^2 <=\\n\\nrecursive function:\\n    input: lower, upper, reversed\\n    output: pos of node where label is itself or under its subtree\\n            pos is always from left to right, start from 1\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518041,
                "title": "java-neat-log-n-soluton",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int k = (int)(Math.log(label) / Math.log(2.0));\\n        int start = (int)Math.pow(2.0, k);\\n        int last = label - start;\\n        Stack<Integer> stk = new Stack<>();\\n        int ok = 0;\\n        while(k >= 0){\\n            if (ok == 1){\\n                stk.add(start + start - last - 1);\\n            }else{\\n                stk.add(start + last);\\n            }\\n            ok ^= 1;\\n            last /= 2;\\n            start /= 2;\\n            k--;\\n        }\\n        Collections.reverse(stk);\\n        return stk;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int k = (int)(Math.log(label) / Math.log(2.0));\\n        int start = (int)Math.pow(2.0, k);\\n        int last = label - start;\\n        Stack<Integer> stk = new Stack<>();\\n        int ok = 0;\\n        while(k >= 0){\\n            if (ok == 1){\\n                stk.add(start + start - last - 1);\\n            }else{\\n                stk.add(start + last);\\n            }\\n            ok ^= 1;\\n            last /= 2;\\n            start /= 2;\\n            k--;\\n        }\\n        Collections.reverse(stk);\\n        return stk;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487047,
                "title": "python-easy-to-understand-o-lgn",
                "content": "The solution here is easy to understand.\\n1. First find the total level of this label. This is actually how many bits does the binary numer of label has.\\n2. second loop from bottem to root. \\n\\tfor odd row the index of the tree is same as the value.\\n\\tfor even row the index + value == 2 ** (level - 1) + (2 ** level) - 1\\n\\tthe next level index is half of previous level\\n\\tSo we can get every level\\'s value and index easily.\\n\\n```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = 0\\n        tem = label\\n\\t\\t# find level\\n        while tem > 0:\\n            level += 1\\n            tem = tem >> 1\\n        result = collections.deque()\\n        currentval = label\\n\\t\\t\\n\\t\\t#find value sequence\\n        while level > 0:\\n            result.appendleft(currentval)\\n            curidx = currentval if (level % 2) else 2 ** (level - 1) - 1 + (2 ** level) - currentval\\n            nxtidx = curidx//2\\n            level -= 1\\n            currentval = nxtidx if (level % 2) else 2 ** (level) - 1 + 2 ** (level - 1) - nxtidx\\n        return result\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = 0\\n        tem = label\\n\\t\\t# find level\\n        while tem > 0:\\n            level += 1\\n            tem = tem >> 1\\n        result = collections.deque()\\n        currentval = label\\n\\t\\t\\n\\t\\t#find value sequence\\n        while level > 0:\\n            result.appendleft(currentval)\\n            curidx = currentval if (level % 2) else 2 ** (level - 1) - 1 + (2 ** level) - currentval\\n            nxtidx = curidx//2\\n            level -= 1\\n            currentval = nxtidx if (level % 2) else 2 ** (level) - 1 + 2 ** (level - 1) - nxtidx\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 481963,
                "title": "java-runtime-0-ms-100-00-speed-100-00-memory",
                "content": "\\n```class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n\\n        while (label > 1) {\\n            int heightOfTree = (int) (Math.log10(label) / Math.log10(2));\\n            int rowStartValue = (int) Math.pow(2, heightOfTree);\\n            label = (rowStartValue - 1) - ((label - rowStartValue) / 2);\\n            list.add(label);\\n        }\\n\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n\\n        while (label > 1) {\\n            int heightOfTree = (int) (Math.log10(label) / Math.log10(2));\\n            int rowStartValue = (int) Math.pow(2, heightOfTree);\\n            label = (rowStartValue - 1) - ((label - rowStartValue) / 2);\\n            list.add(label);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 461146,
                "title": "fastest-solution-o-logn-time",
                "content": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        ret = [label]\\n        height = int(math.log(label,2))\\n        prev = 1<<height\\n        while height:\\n            right = prev-1         # 2^height-1\\n            left = prev = prev//2  # 2^(height-1)\\n            label = left+right-label//2\\n            ret.append(label)\\n            height -= 1\\n        return ret[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        ret = [label]\\n        height = int(math.log(label,2))\\n        prev = 1<<height\\n        while height:\\n            right = prev-1         # 2^height-1\\n            left = prev = prev//2  # 2^(height-1)\\n            label = left+right-label//2\\n            ret.append(label)\\n            height -= 1\\n        return ret[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445874,
                "title": "easy-to-understand-faster-than-100-00-less-than-100-00",
                "content": "```\\nUnder normal circumstances, 14 will like this [14,7,3,1], but 14 is flipped\\n          1  \\n    2          3 \\n 4    5     6     7 \\n8 9 10 11 12 13 14 15\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        \\n        int tmp = label;\\n        while (tmp > 1) {\\n            tmp = tmp/2;\\n            result.push_back(tmp);\\n        }\\n\\n        \\n        // odd should be changed\\n        // last one will always be 1 \\n        for (int i = 1; i < result.size() - 1; i = i + 2) {\\n            int levelmin = pow(2, result.size() - i - 1);\\n            int levelmax = pow(2, result.size() - i) - 1;\\n            int newval = levelmax - result[i] + levelmin;\\n            result[i] = newval;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nUnder normal circumstances, 14 will like this [14,7,3,1], but 14 is flipped\\n          1  \\n    2          3 \\n 4    5     6     7 \\n8 9 10 11 12 13 14 15\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> result;\\n        result.push_back(label);\\n        \\n        int tmp = label;\\n        while (tmp > 1) {\\n            tmp = tmp/2;\\n            result.push_back(tmp);\\n        }\\n\\n        \\n        // odd should be changed\\n        // last one will always be 1 \\n        for (int i = 1; i < result.size() - 1; i = i + 2) {\\n            int levelmin = pow(2, result.size() - i - 1);\\n            int levelmax = pow(2, result.size() - i) - 1;\\n            int newval = levelmax - result[i] + levelmin;\\n            result[i] = newval;\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444828,
                "title": "swift-math-solution",
                "content": "```\\nimport Foundation\\n\\nclass Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        if label == 1 {\\n            return [1]\\n        }\\n\\n        let numberOfRows = Int(ceil(log2(Double(label + 1))))\\n        return pathInZigZagTree((Int(pow(2.0, Double(numberOfRows))) - label + Int(pow(2.0, Double(numberOfRows - 1))) - 1) / 2) + [label]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport Foundation\\n\\nclass Solution {\\n    func pathInZigZagTree(_ label: Int) -> [Int] {\\n        if label == 1 {\\n            return [1]\\n        }\\n\\n        let numberOfRows = Int(ceil(log2(Double(label + 1))))\\n        return pathInZigZagTree((Int(pow(2.0, Double(numberOfRows))) - label + Int(pow(2.0, Double(numberOfRows - 1))) - 1) / 2) + [label]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441075,
                "title": "simple-java-solution",
                "content": "Time Complextity: O(log N)\\nSpace Complexity: O(log N)\\n```\\n    public List<Integer> pathInZigZagTree(int label) {        \\n        int num = 1;\\n        int level = 1;\\n        int totalNodes = 1;\\n        \\n        LinkedList<Integer> path = new LinkedList<Integer>();\\n        path.addFirst(label);\\n        \\n        while(totalNodes < label){\\n            num *= 2;\\n            totalNodes += num;\\n            level++;\\n        }\\n        \\n        while(label > 1){\\n            int diff = totalNodes - label;\\n            int parentOffset = diff / 2;\\n            int parentLevelStart = ((totalNodes/2) /2) + 1;\\n            \\n            int parent = parentLevelStart + parentOffset;\\n            path.addFirst(parent);\\n            \\n            label = parent;\\n            totalNodes = totalNodes / 2;\\n        }\\n        return path;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> pathInZigZagTree(int label) {        \\n        int num = 1;\\n        int level = 1;\\n        int totalNodes = 1;\\n        \\n        LinkedList<Integer> path = new LinkedList<Integer>();\\n        path.addFirst(label);\\n        \\n        while(totalNodes < label){\\n            num *= 2;\\n            totalNodes += num;\\n            level++;\\n        }\\n        \\n        while(label > 1){\\n            int diff = totalNodes - label;\\n            int parentOffset = diff / 2;\\n            int parentLevelStart = ((totalNodes/2) /2) + 1;\\n            \\n            int parent = parentLevelStart + parentOffset;\\n            path.addFirst(parent);\\n            \\n            label = parent;\\n            totalNodes = totalNodes / 2;\\n        }\\n        return path;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433663,
                "title": "java-100-time-mem-compact-recursion-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        list.add(label);\\n        addNumber(list, label, Integer.highestOneBit(label));\\n        return list;\\n    }\\n    \\n    private void addNumber(List<Integer> numbers, int number, int startPoint) {\\n        if (number == 1) {\\n            return;\\n        }\\n        int index = (number - startPoint + 2) / 2;\\n        int nextNumber = startPoint - index;\\n        numbers.add(0, nextNumber);\\n        addNumber(numbers, nextNumber, Integer.highestOneBit(nextNumber));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        list.add(label);\\n        addNumber(list, label, Integer.highestOneBit(label));\\n        return list;\\n    }\\n    \\n    private void addNumber(List<Integer> numbers, int number, int startPoint) {\\n        if (number == 1) {\\n            return;\\n        }\\n        int index = (number - startPoint + 2) / 2;\\n        int nextNumber = startPoint - index;\\n        numbers.add(0, nextNumber);\\n        addNumber(numbers, nextNumber, Integer.highestOneBit(nextNumber));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425747,
                "title": "easy-to-understand",
                "content": "```\\nvar pathInZigZagTree = function(label) {\\n  let level = 1;\\n  let num = 1;\\n  /* record how many nodes of each level */\\n  let levelCount = 1;\\n  /* find last level */\\n  while (num < label) {\\n    levelCount *= 2;\\n    num += levelCount;\\n    level += 1;\\n  }\\n  /* insert ans in reverse order */\\n  const ans = [label];\\n  while (--level) {\\n    /* because of zigzag, each pair for each level */\\n    /* we find the \\'other\\' number */\\n    let levelEnd = 2 ** (level) - 1;\\n    let levelStart = 2 ** (level - 1);\\n    let target = Math.floor(label / 2);\\n    target = levelEnd + levelStart - target;\\n    label = target;\\n    ans.push(target);\\n  }\\n  \\n  return ans.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathInZigZagTree = function(label) {\\n  let level = 1;\\n  let num = 1;\\n  /* record how many nodes of each level */\\n  let levelCount = 1;\\n  /* find last level */\\n  while (num < label) {\\n    levelCount *= 2;\\n    num += levelCount;\\n    level += 1;\\n  }\\n  /* insert ans in reverse order */\\n  const ans = [label];\\n  while (--level) {\\n    /* because of zigzag, each pair for each level */\\n    /* we find the \\'other\\' number */\\n    let levelEnd = 2 ** (level) - 1;\\n    let levelStart = 2 ** (level - 1);\\n    let target = Math.floor(label / 2);\\n    target = levelEnd + levelStart - target;\\n    label = target;\\n    ans.push(target);\\n  }\\n  \\n  return ans.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382188,
                "title": "java-o-logn",
                "content": "```\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        List<Integer> q = new ArrayList();\\n        while (label != 0)\\n        {\\n            q.add(label);\\n            label /= 2;\\n        }\\n        \\n        Collections.reverse(q);\\n        int base = q.size() % 2 == 0 ? 4 : 2;\\n        for (int i = base / 2; i < q.size(); i += 2)\\n        {\\n            int sum = base * 3 - 1;\\n            base = base << 2;\\n            q.set(i, sum - q.get(i));\\n        }\\n        \\n        \\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> pathInZigZagTree(int label) \\n    {\\n        List<Integer> q = new ArrayList();\\n        while (label != 0)\\n        {\\n            q.add(label);\\n            label /= 2;\\n        }\\n        \\n        Collections.reverse(q);\\n        int base = q.size() % 2 == 0 ? 4 : 2;\\n        for (int i = base / 2; i < q.size(); i += 2)\\n        {\\n            int sum = base * 3 - 1;\\n            base = base << 2;\\n            q.set(i, sum - q.get(i));\\n        }\\n        \\n        \\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378478,
                "title": "java-math-beat-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int row = (int) (Math.log(label)/ Math.log(2));\\n        List<Integer> list = new ArrayList<>(row + 1);\\n        while (label > 1) {\\n            list.add(label);\\n            label = label >> 1;\\n            label = (1 << row--) + (1 << row) - 1 - label; \\n        }\\n        list.add(1);\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        int row = (int) (Math.log(label)/ Math.log(2));\\n        List<Integer> list = new ArrayList<>(row + 1);\\n        while (label > 1) {\\n            list.add(label);\\n            label = label >> 1;\\n            label = (1 << row--) + (1 << row) - 1 - label; \\n        }\\n        list.add(1);\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367549,
                "title": "11-8-mb-less-than-100-00-of-python-online-submissions-python",
                "content": "```class Solution(object):\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        liste=set()\\n        n=1\\n        while label > pow(2,n)-1:\\n            n+=1\\n        liste.add(label)\\n        while label>1:\\n            n-=1\\n            label=pow(2,n-1)+(pow(2,n)-1-int(label/2))\\n            liste.add(label)\\n        return sorted(liste)`\\n```",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def pathInZigZagTree(self, label):\\n        \"\"\"\\n        :type label: int\\n        :rtype: List[int]\\n        \"\"\"\\n        liste=set()\\n        n=1\\n        while label > pow(2,n)-1:\\n            n+=1\\n        liste.add(label)\\n        while label>1:\\n            n-=1\\n            label=pow(2,n-1)+(pow(2,n)-1-int(label/2))\\n            liste.add(label)\\n        return sorted(liste)`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362791,
                "title": "recursive-java-solution-i-think-it-is-easier-than-other-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> res = new ArrayList<>();\\n        if(label == 1) {\\n            res.add(1);\\n            return res;\\n        }\\n        // Each level is 2^l ~ 2^(l+1)-1.\\n        int l = log(label);\\n        int prev = label / 2;\\n        prev = (int)Math.pow(2, l-1) + ((int)Math.pow(2, l) - 1 - prev);\\n        res.addAll(pathInZigZagTree(prev));\\n        res.add(label);\\n        return res;\\n    }\\n    \\n    // Return log-2 (x). Round up to smaller value.\\n    public static int log(int x) {\\n        return (int) (Math.log(x) / Math.log(2));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> res = new ArrayList<>();\\n        if(label == 1) {\\n            res.add(1);\\n            return res;\\n        }\\n        // Each level is 2^l ~ 2^(l+1)-1.\\n        int l = log(label);\\n        int prev = label / 2;\\n        prev = (int)Math.pow(2, l-1) + ((int)Math.pow(2, l) - 1 - prev);\\n        res.addAll(pathInZigZagTree(prev));\\n        res.add(label);\\n        return res;\\n    }\\n    \\n    // Return log-2 (x). Round up to smaller value.\\n    public static int log(int x) {\\n        return (int) (Math.log(x) / Math.log(2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361295,
                "title": "c-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> paths;\\n        int i=0,up=0,res=0,n=label;\\n        bool flag=1;\\n        while(i<32 && n) {i++; n=n>>1;}\\n        //cout<<i;\\n        while(i){\\n            res = (i%2==1) ?(1<<(i-1)) :(1<<i)-1;\\n            //cout<<res<<\" \";\\n            int lab = (flag==0) ?((i%2) ?(res+up) :(res-up)) :label;\\n            flag=0;\\n            up = (i%2==1) ?(lab-res)/2 :(res-lab)/2;\\n            i--;\\n            paths.push_back(lab);\\n        }\\n        reverse(paths.begin(), paths.end());\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        vector<int> paths;\\n        int i=0,up=0,res=0,n=label;\\n        bool flag=1;\\n        while(i<32 && n) {i++; n=n>>1;}\\n        //cout<<i;\\n        while(i){\\n            res = (i%2==1) ?(1<<(i-1)) :(1<<i)-1;\\n            //cout<<res<<\" \";\\n            int lab = (flag==0) ?((i%2) ?(res+up) :(res-up)) :label;\\n            flag=0;\\n            up = (i%2==1) ?(lab-res)/2 :(res-lab)/2;\\n            i--;\\n            paths.push_back(lab);\\n        }\\n        reverse(paths.begin(), paths.end());\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 357749,
                "title": "java-full-explanation-100-beat-in-both",
                "content": "Approach:\\n\\nBrute Force: \\nAs you understand the simplest approach would be just generate the binary tree like above, and do the traversal and find the nodes in between. \\n\\nOptimal Approach: \\nLet\\u2019s understand the question first, \\n1.\\tOdd Level : When level is odd, numbering start from right \\n2.\\tEven Level : When level is Even, numbering start from left \\n\\nNow for a moment forget about the zig-zag tree, and have a normal tree  where numbering is based on node insert in level order traversal\\n\\n![image](https://assets.leetcode.com/users/nits2010/image_1565699666.png)\\n\\nIn Full binary tree, if you are at a node (say 6) we can find its parent by 6/2 = 3 [ because each node have 2 child\\u2019s, then they must be separated by 2 child\\u2019s only at each level].\\nFor 7 -> 7/2 = 3\\nFor 5/2= 2\\n\\nBack to original question.\\nThe only difference with the normal tree vs zig-zag tree has the numbering getting altered based on level (even/odd).\\n\\nOur task is boils down to first find the level, at which our target is placed in zig-zag tree. \\nIf you observe, then you\\u2019ll see its regardless that tree is normal or zig-zag the placement of any label will always be based on Hight of tree [ level of tree ].\\n\\nSo in our original example:\\n![image](https://assets.leetcode.com/users/nits2010/image_1565699708.png)\\n\\nThe level of 14 can be easily evaluated by 2^n >= 14. The least value of n is your level. \\nHere in our case, n = 4 as 2^4 = 16 > 14 [ whereas 2^3 < 14 ].\\n\\nOk, now we know what is the level of our current label = 4. \\nNext we need to know, what is the level at which its parent would be, and that is trivial it will always be 1 less than its level until you hit root. \\n\\nBut since the tree is zig-zag, just doing 14/2 = 7 wont\\u2019 give you the parent. \\nBut it will tell you the where could be the parent. \\nSee at level 3 [ parent level] we have 4 , 5, 6, 7 which tells 7 is symmetry of 4 and 6 is for 5 and vice-versa.\\n\\ni.e. 14/2 = 7 then our parent would be 4 [ 4 is symmetry for 7 ].\\n\\nThere could be multiple way to find this \\n1.\\tUsing Level with odd-even rule\\n2.\\tBy applying maths in it. \\n\\nI\\u2019m covering first 2nd approach. \\nOk, now we know this level have 4,5,6,7 as nodes \\nAnd if you do (7 + 4 \\u2013 4)/2 = (7)/2 = 7/2=3 [your required parent of 4].\\nMeans, (level last node value + level first node value \\u2013 lastLable)/2\\n\\n\\nOk, we know at each level how many nodes are there which is defined by \\n2^(level-1) ; for level = 3 => 2^2 = 4.[ which is the start of this level in normal tree]\\nFor end of the level we can simply do 2^(level) -1 = 8-1 = 7\\n\\nOk, so we have a formula to calculate the last node label and first node label using current level. \\n \\n( ( 2^level -1 ) + ( 2^(level-1)  )  - lable ) /2\\n\\nHence;\\nLabel=14 with level 4 => (2^4 \\u2013 1 + 2^3 \\u2013 14)/2 = (15 + 8 \\u2013 14 )= 9/2 = 4\\nLabel = 4 with level 3 => (7 + 4 \\u2013 4 ) / 2 = 3\\nLabel = 3 with level 2 => (4 + 2 -3 )/2 = 3/2 = 1 [your main root] \\n Hence [1,3,4,14]\\n\\n\\n```\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\n        if (label <= 0)\\n            return Collections.EMPTY_LIST;\\n\\n        if (label == 1)\\n            return Arrays.asList(1);\\n\\n\\n        /**\\n         * Find the level of this label is;\\n         * You can compute like 2^n > label; find the least value of \\'n\\'\\n         */\\n        int level = (int) (Math.log(label) / Math.log(2)) + 1;;\\n\\n        List<Integer> path = new ArrayList<>(level + 1);\\n        path.add(label);\\n\\n        /**\\n         * Backtrack from this level to the root\\n         *\\n         * O(log(level))\\n         */\\n        while (level > 1) {\\n\\n//            int totalNodes = (int) (Math.pow(2, level) - 1 + Math.pow(2, level - 1));\\n\\n            /**\\n             * Find the parent of this label;\\n             * ................................\\n             * In normal tree, the parent of any node is calculated by v/2.\\n             * Since the tree is zig-zag; which parents of every node has push to other side but they have symmetry\\n             *\\n             * For example: Node=14\\n             * For normal tree: 14/2 = 7\\n             * For zig-zag tree: Nodes just above this node are\\n             * 4 , 5 , 6 , 7\\n             * So if it were normal tree, the parent is on 7 while if its zig-zag then its on 4. Which is symmetrical.\\n             *\\n             * Hence,\\n             *\\n             * Find how many nodes are there at this level.\\n             * This level labeling would start from Math.pow(2, level - 1))\\n             * and end at (Math.pow(2, level) - 1\\n             *\\n             * Which is equivalent to ((1 << level) - 1) + (1 << (level - 1))\\n             */\\n            int totalNodes = ((1 << level) - 1) + (1 << (level - 1));\\n\\n\\n            //Parent of this label is same as normal tree parent.\\n            int parentLabel = (totalNodes - label) / 2;\\n\\n            label = parentLabel;\\n            path.add(label);\\n            level--;\\n\\n        }\\n        Collections.reverse(path);\\n        return path;\\n    }\\n```\\n\\nCheck this for way 1: https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/discuss/323848/Golang-O(log-n)-with-detail-explanation\\n",
                "solutionTags": [],
                "code": "```\\n\\n    public List<Integer> pathInZigZagTree(int label) {\\n\\n        if (label <= 0)\\n            return Collections.EMPTY_LIST;\\n\\n        if (label == 1)\\n            return Arrays.asList(1);\\n\\n\\n        /**\\n         * Find the level of this label is;\\n         * You can compute like 2^n > label; find the least value of \\'n\\'\\n         */\\n        int level = (int) (Math.log(label) / Math.log(2)) + 1;;\\n\\n        List<Integer> path = new ArrayList<>(level + 1);\\n        path.add(label);\\n\\n        /**\\n         * Backtrack from this level to the root\\n         *\\n         * O(log(level))\\n         */\\n        while (level > 1) {\\n\\n//            int totalNodes = (int) (Math.pow(2, level) - 1 + Math.pow(2, level - 1));\\n\\n            /**\\n             * Find the parent of this label;\\n             * ................................\\n             * In normal tree, the parent of any node is calculated by v/2.\\n             * Since the tree is zig-zag; which parents of every node has push to other side but they have symmetry\\n             *\\n             * For example: Node=14\\n             * For normal tree: 14/2 = 7\\n             * For zig-zag tree: Nodes just above this node are\\n             * 4 , 5 , 6 , 7\\n             * So if it were normal tree, the parent is on 7 while if its zig-zag then its on 4. Which is symmetrical.\\n             *\\n             * Hence,\\n             *\\n             * Find how many nodes are there at this level.\\n             * This level labeling would start from Math.pow(2, level - 1))\\n             * and end at (Math.pow(2, level) - 1\\n             *\\n             * Which is equivalent to ((1 << level) - 1) + (1 << (level - 1))\\n             */\\n            int totalNodes = ((1 << level) - 1) + (1 << (level - 1));\\n\\n\\n            //Parent of this label is same as normal tree parent.\\n            int parentLabel = (totalNodes - label) / 2;\\n\\n            label = parentLabel;\\n            path.add(label);\\n            level--;\\n\\n        }\\n        Collections.reverse(path);\\n        return path;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346434,
                "title": "java-easy-to-understand-solution",
                "content": "1. find out the last row of the node;\\n2. get then normal node index \\n3. add the path from bottom to root. if the row number is even, find the correct label using the formula:  startOfCurrentRow + (num of nodes in this row - (label - startOfCurrentRow)) - 1.    Because num of nodes in current row  is the same as Start label Of current row, then the formula is simplified as: 3 * startOfCurrentRow - normalLabel - 1; \\n       \\n\\t   \\n       public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> path = new LinkedList();\\n        int row = 1; \\n        int startOfNextRow = 2; \\n        while (label >= startOfNextRow) {\\n            startOfNextRow *= 2;\\n            row++;\\n        }\\n        \\n        int startOfCurrentRow = startOfNextRow / 2;\\n        int normalLabel = (row % 2 == 1) ? label : 3 * startOfCurrentRow - label -1;\\n        while (row > 0) {\\n            if (row % 2 == 0) {\\n                path.add(0, 3 * startOfCurrentRow - normalLabel - 1);\\n            }\\n            else {\\n                path.add(0, normalLabel);\\n            }\\n            \\n            startOfCurrentRow /= 2;\\n            normalLabel /= 2;\\n            row--;\\n        }\\n        \\n        return path;\\n\\t\\t}",
                "solutionTags": [],
                "code": "1. find out the last row of the node;\\n2. get then normal node index \\n3. add the path from bottom to root. if the row number is even, find the correct label using the formula:  startOfCurrentRow + (num of nodes in this row - (label - startOfCurrentRow)) - 1.    Because num of nodes in current row  is the same as Start label Of current row, then the formula is simplified as: 3 * startOfCurrentRow - normalLabel - 1; \\n       \\n\\t   \\n       public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> path = new LinkedList();\\n        int row = 1; \\n        int startOfNextRow = 2; \\n        while (label >= startOfNextRow) {\\n            startOfNextRow *= 2;\\n            row++;\\n        }\\n        \\n        int startOfCurrentRow = startOfNextRow / 2;\\n        int normalLabel = (row % 2 == 1) ? label : 3 * startOfCurrentRow - label -1;\\n        while (row > 0) {\\n            if (row % 2 == 0) {\\n                path.add(0, 3 * startOfCurrentRow - normalLabel - 1);\\n            }\\n            else {\\n                path.add(0, normalLabel);\\n            }\\n            \\n            startOfCurrentRow /= 2;\\n            normalLabel /= 2;\\n            row--;\\n        }\\n        \\n        return path;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 333262,
                "title": "c-math-trick-with-xor",
                "content": "Code:- \\n\\nLets consider the level of root is 1.\\n\\nIf the tree is filled normally , left to right for all levels , and assigning a bit 0 for left direction and 1 for right direction , starting with bit 1 for root since label constraint starts from 1 , we can exactly know the number at any level with the directions.\\n\\nIn the zig zag ordering the original position of a number at any level is just the XOR with (total number of nodes-1) in that level.\\nNumber of Nodes at any level can be derived as : power( 2, L-1) ,\\nL is  level \\nSo in level 4 where the zig zag ordering is  15 14 13 12 11 10 9 8, and xoring each with 7 (number of nodes in this level -1) we have 8 9 10 11 12 13 14 15 \\n\\nso dividing the given number by 2 we get its original position in previous level and on XORing operation we get the zig zag element .\\ndo it until the element reaches root:\\n\\n\\n```\\n#include <math.h> \\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int l) {\\n        vector<int> r;\\n        int n = log2(l); // find required bits to hold the number \\n        r.insert(r.begin(), l);\\n        int p = pow(2,n-1)-1;\\n      \\n        while(l !=1)\\n        {\\n            l=l/2;\\n            int t = l^p;   \\n            r.insert(r.begin(),l^p);\\n            l=t;\\n            p = p>>1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <math.h> \\nclass Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int l) {\\n        vector<int> r;\\n        int n = log2(l); // find required bits to hold the number \\n        r.insert(r.begin(), l);\\n        int p = pow(2,n-1)-1;\\n      \\n        while(l !=1)\\n        {\\n            l=l/2;\\n            int t = l^p;   \\n            r.insert(r.begin(),l^p);\\n            l=t;\\n            p = p>>1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 332115,
                "title": "simple-python",
                "content": "```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        parent = label\\n        res = [parent]  \\n        row = int(math.log(parent, 2))\\n        rowStart = 2 ** row\\n\\t\\t\\n        while row != 0:\\n            dist_to_start = (parent - rowStart) // 2\\n            parent = rowStart - dist_to_start - 1\\n            res.insert(0, parent)\\n            row -= 1\\n            rowStart //= 2\\n        return res     \\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        parent = label\\n        res = [parent]  \\n        row = int(math.log(parent, 2))\\n        rowStart = 2 ** row\\n\\t\\t\\n        while row != 0:\\n            dist_to_start = (parent - rowStart) // 2\\n            parent = rowStart - dist_to_start - 1\\n            res.insert(0, parent)\\n            row -= 1\\n            rowStart //= 2\\n        return res     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 329884,
                "title": "python3-it-s-all-about-mathematics",
                "content": "\\tclass Solution:\\n\\t\\tdef pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\t\\tres=[label]\\n\\t\\t\\tnum=1\\n\\t\\t\\tlevel=1\\n\\t\\t\\twhile num<label:\\n\\t\\t\\t\\tnum=num+2**level\\n\\t\\t\\t\\tlevel+=1  \\n\\t\\t\\twhile label!=0:\\n\\t\\t\\t\\tMAX=2**(level)-1\\n\\t\\t\\t\\tMIN=2**(level-1)                        \\n\\t\\t\\t\\ttem=(MAX+MIN-label)//2            \\n\\t\\t\\t\\tif tem!=0:\\n\\t\\t\\t\\t\\tres.append(tem)\\n\\t\\t\\t\\tlevel-=1\\n\\t\\t\\t\\tlabel=tem\\n\\t\\t\\treturn res[::-1]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef pathInZigZagTree(self, label: int) -> List[int]:\\n\\t\\t\\tres=[label]\\n\\t\\t\\tnum=1\\n\\t\\t\\tlevel=1\\n\\t\\t\\twhile num<label:\\n\\t\\t\\t\\tnum=num+2**level\\n\\t\\t\\t\\tlevel+=1  \\n\\t\\t\\twhile label!=0:\\n\\t\\t\\t\\tMAX=2**(level)-1\\n\\t\\t\\t\\tMIN=2**(level-1)                        \\n\\t\\t\\t\\ttem=(MAX+MIN-label)//2            \\n\\t\\t\\t\\tif tem!=0:\\n\\t\\t\\t\\t\\tres.append(tem)\\n\\t\\t\\t\\tlevel-=1\\n\\t\\t\\t\\tlabel=tem\\n\\t\\t\\treturn res[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 326834,
                "title": "python-explain-this-math-problem-in-detail-clear-solution-beats-83-72",
                "content": "In a full binary tree (FBT), the number of nodes at level 1 is 1, 2 at level 2, 4 at level 3,..., and `2**(i-1)` at level `i`. So, From level 1 to level `i`, there are `1 + 2 + 4 + ... + 2**(i-1) = 2**i - 1` nodes totally. Suppose the node of `label` is at level `j`, `j` must fullfill `2**(j-1) - 1 < label <= 2**j - 1`. Therefore, we can firstly find out the level of `label` with bit operations.\\n```python\\ntmp = label\\nlevel = 0\\nwhile tmp:\\n    tmp >>= 1\\n    level += 1\\n```\\nThen, we will figure out the location of `label` on its `level`, which we call it `p`. If `level` is odd, nodes would be labelled from left to right. Since there are `2**(level-1)-1` nodes from level 1 to level `level-1`, `label` would be the `label - (2**(level-1) - 1)`-th node at level `level`. On the other hand, if `level` is even, `label` would be the `2**level - label`-th node at level `level`. So,\\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\\nImagine a FBT, which is labelled from left to right at every level (you may have seen it if you have been in a data structure class). In this tree, the children of the node labelled `n`, are labelled `2*n` and `2*n+1`. For the node which is at level `level`, and is the `p` th node counted from left to right, its parent is labelled `label / 2`, and its grandparent is labelled `label / 2 / 2`, and so on. We can clearly find the path from the root to `label` by dividing `label` with 2 repeatly until it is equal to 1. After getting such a path, just map it to the FBT of this problem. The mapping rule is:\\n\\n```python\\nif level is odd:\\n    label_on_zigzag_FBT = label_on_normal_FBT\\nif level is even:\\n    label_on_zigzag_FBT = 2**level + 2**(level-1) - 1 - label_on_normal_FBT\\n    label_on_normal_FBT = 2**level + 2**(level-1) - 1 - label_on_zigzag_FBT\\n```\\nThis is acquired from the former equation:\\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\\nTree nodes of the same `level` and same `p` map to each others.\\n\\nFinally, we combine all code blocks:\\n```python\\nclass Solution:\\n    def pathInZigZagTree(self, label: int):\\n        tmp = label\\n        level = 0\\n        while tmp:\\n            tmp >>= 1\\n            level += 1\\n\\n        label_on_zigzag_FBT = label\\n        label_on_normal_FBT = label_on_zigzag_FBT\\n        if level % 2 == 0:\\n            label_on_normal_FBT = 2 ** level + 2 ** (level - 1) - 1 - label_on_zigzag_FBT\\n        \\n        ans = []\\n        # path on normal FBT\\n        while label_on_normal_FBT >= 1:\\n            ans.append(label_on_normal_FBT)\\n            label_on_normal_FBT = int(label_on_normal_FBT / 2)\\n\\n        ans.reverse()\\n        # map to zigzag FBT\\n        for i in range(2, len(ans)+1, 2):\\n            ans[i-1] = 2 ** i + 2 ** (i - 1) - 1 - ans[i-1]\\n\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ntmp = label\\nlevel = 0\\nwhile tmp:\\n    tmp >>= 1\\n    level += 1\\n```\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\n```python\\nif level is odd:\\n    label_on_zigzag_FBT = label_on_normal_FBT\\nif level is even:\\n    label_on_zigzag_FBT = 2**level + 2**(level-1) - 1 - label_on_normal_FBT\\n    label_on_normal_FBT = 2**level + 2**(level-1) - 1 - label_on_zigzag_FBT\\n```\n```python\\np = 2**level - label if level % 2 == 0 else label - (2**(level-1) - 1)\\n```\n```python\\nclass Solution:\\n    def pathInZigZagTree(self, label: int):\\n        tmp = label\\n        level = 0\\n        while tmp:\\n            tmp >>= 1\\n            level += 1\\n\\n        label_on_zigzag_FBT = label\\n        label_on_normal_FBT = label_on_zigzag_FBT\\n        if level % 2 == 0:\\n            label_on_normal_FBT = 2 ** level + 2 ** (level - 1) - 1 - label_on_zigzag_FBT\\n        \\n        ans = []\\n        # path on normal FBT\\n        while label_on_normal_FBT >= 1:\\n            ans.append(label_on_normal_FBT)\\n            label_on_normal_FBT = int(label_on_normal_FBT / 2)\\n\\n        ans.reverse()\\n        # map to zigzag FBT\\n        for i in range(2, len(ans)+1, 2):\\n            ans[i-1] = 2 ** i + 2 ** (i - 1) - 1 - ans[i-1]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326609,
                "title": "go-o-log-n",
                "content": "```go\\nfunc pathInZigZagTree(label int) []int {\\n    level, s := 1, 1\\n    for ; s < label; level++ { s += 1<<uint(level) }\\n    res := make([]int, level)\\n    res[0], res[level-1] = 1, label\\n    for level -= 2; level > 0; level-- {\\n        s >>= 1\\n        label = s-(label-s+1)/2+1\\n        res[level] = label\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pathInZigZagTree(label int) []int {\\n    level, s := 1, 1\\n    for ; s < label; level++ { s += 1<<uint(level) }\\n    res := make([]int, level)\\n    res[0], res[level-1] = 1, label\\n    for level -= 2; level > 0; level-- {\\n        s >>= 1\\n        label = s-(label-s+1)/2+1\\n        res[level] = label\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325656,
                "title": "c-o-log-n-clean-and-a-straight-forward-intuitive-approach",
                "content": "Intuition: \\n1. Every alternate level is reversed. So, every grand-parent of any node is node/4 (Parent of any node => node/2, it\\'s parent => parent/2 or node/4).\\n2. Last level will always be the given parameter label.\\n3. So, all we need is to find the value of parent of label (in case level > 1)\\n\\nFinding parent of label:\\n1. Let there be `level` levels.\\n2. Number of nodes at `level-1 => (2^(level-1)-1)` => let\\'s call this x\\n3. If not reversed, parent will be label/2. This parent is `x-label/2+1 => y` nodes before last node at level-1.\\n4. Since, nodes are reversed at level. New node is y nodes ahead of level-2 => `y + (2^(level-2) - 1)`\\n\\nCode for this intuition:\\n\\n\\t\\tvector<int> pathInZigZagTree(int label) {\\n\\t\\t\\n\\t\\t\\tint level = ceil(log2(label+1));\\n\\n\\t\\t\\tvector<int> labels(level, 0);\\n\\t\\t\\tif (level > 0)\\n\\t\\t\\t\\tlabels[level-1] = label;\\n\\t\\t\\tif (level > 1)\\n\\t\\t\\t\\tlabels[level-2] = ((pow(2,level-1) - 1) - label/2 + 1) + (pow(2, level-2) - 1);\\n\\n\\t\\t\\tfor (int i=level-3; i>=0; i--)\\n\\t\\t\\t\\tlabels[i] = labels[i+2] / 4;\\n\\n\\t\\t\\treturn labels;\\n\\t\\t}\\n\\t\\t\\nComplexity: `O(log n)`",
                "solutionTags": [
                    "C"
                ],
                "code": "Intuition: \\n1. Every alternate level is reversed. So, every grand-parent of any node is node/4 (Parent of any node => node/2, it\\'s parent => parent/2 or node/4).\\n2. Last level will always be the given parameter label.\\n3. So, all we need is to find the value of parent of label (in case level > 1)\\n\\nFinding parent of label:\\n1. Let there be `level` levels.\\n2. Number of nodes at `level-1 => (2^(level-1)-1)` => let\\'s call this x\\n3. If not reversed, parent will be label/2. This parent is `x-label/2+1 => y` nodes before last node at level-1.\\n4. Since, nodes are reversed at level. New node is y nodes ahead of level-2 => `y + (2^(level-2) - 1)`\\n\\nCode for this intuition:\\n\\n\\t\\tvector<int> pathInZigZagTree(int label) {\\n\\t\\t\\n\\t\\t\\tint level = ceil(log2(label+1));\\n\\n\\t\\t\\tvector<int> labels(level, 0);\\n\\t\\t\\tif (level > 0)\\n\\t\\t\\t\\tlabels[level-1] = label;\\n\\t\\t\\tif (level > 1)\\n\\t\\t\\t\\tlabels[level-2] = ((pow(2,level-1) - 1) - label/2 + 1) + (pow(2, level-2) - 1);\\n\\n\\t\\t\\tfor (int i=level-3; i>=0; i--)\\n\\t\\t\\t\\tlabels[i] = labels[i+2] / 4;\\n\\n\\t\\t\\treturn labels;\\n\\t\\t}\\n\\t\\t\\nComplexity: `O(log n)`",
                "codeTag": "Unknown"
            },
            {
                "id": 325408,
                "title": "share-my-code-c",
                "content": "vector<int> pathInZigZagTree(int label) {\\n        int num = log2(label) + 1;\\n        vector<int> res(num, 0);\\n        while (num > 0)\\n        {\\n            res[num - 1] = label;\\n            label = (pow(2, num - 1) + (pow(2, num) - 1 - label)) / 2;\\n            num--;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "vector<int> pathInZigZagTree(int label) {\\n        int num = log2(label) + 1;\\n        vector<int> res(num, 0);\\n        while (num > 0)\\n        {\\n            res[num - 1] = label;\\n            label = (pow(2, num - 1) + (pow(2, num) - 1 - label)) / 2;\\n            num--;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1931980,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1574940,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 2028000,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1978228,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1805408,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1748069,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            },
            {
                "id": 1711845,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "how many of you thinks that question description in not clear."
                    },
                    {
                        "username": "psonlinux",
                        "content": "Given the `label` we can always find how many nodes are there in between `label` and it\\'s parent .\\nLet it be `x` .\\nTo get parent of `label` subtract `label - x - 1 = p` .\\nHow to find `x` ?\\nx = y + z\\ny = no of nodes before `label` and starting node of that row . \\nz = no of nodes after parent p and before starting node of next row .\\n\\nHow to find label of starting node of any row ?\\n`int startRow = 2 ^ log2(nodeLabel)` \\n\\ny = label - startRow\\nOnce you have find y , finding x is simple .\\nz = y / 2, because for each pair of in y there is one parent in level above !\\n\\nPerform above steps until you reach node 1 . Save all parents along the way .\\nTry to digest the idea .\\n\\nT : O(log label)\\nS : O(log label)\\n\\nI am not pasting code deliberately ."
                    },
                    {
                        "username": "nt34542",
                        "content": "Fog chal raha hai in my brain after reading the problem statement\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "what is this problem even asking.... how do we know what the root of the tree even is?"
                    },
                    {
                        "username": "aditya_gupta17",
                        "content": "the constraints of the problem give us a hint that we would not be requiring to create a tree and traverse a tree. Thus we should get a hint of finding a relationship between a node and its parent. By making a tree upto 3-4 levels one can observe that there indeed exists a relationship. let A be the power of two smaller or equal to label. The parent would then be (A-(distance between label and A)/2 +1). Thus we can make a while loop by updating the label\\n\\nint nearestPowerofTwo(int a){\\n    int i=1;\\n    while(i<=a){\\n        i=i*2;\\n    }\\n    i=i/2;\\n    return i;\\n}\\nvector<int> pathInZigZagTree(int label) {\\n    vector<int>ans;\\n    while(label!=1){\\n        ans.push_back(label);\\n        int nearest=nearestPowerofTwo(label);\\n        label=nearest-(((label-nearest)/2)+1);\\n    }\\n    ans.push_back(1);\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n}"
                    },
                    {
                        "username": "saikrishna_vemaraju",
                        "content": "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(label);\\n        //replace every parent with its complement\\n        //complement-start=end-label;\\n        //complement=start+end-label;\\n        //Ex:-c=8+15-14=9\\n        //parent=complement/2;\\n        while(label!=1)\\n        {\\n            int level = (int)(Math.log(label)/Math.log(2));\\n            int start= (int)Math.pow(2,level);\\n            int end =(int)Math.pow(2,level+1)-1;\\n            int complement = start+end-label;\\n            label = complement/2;\\n            list.add(0,label);\\n\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "coderr_divy",
                        "content": "class Solution {\\npublic:\\n    vector<int> pathInZigZagTree(int label) {\\n        long count=1;\\n        long n=label;\\n        long p=1;\\n        long k1=0;\\n        while(p<=n){\\n       p=pow(2,k1);\\n       k1++;\\n        }\\n        vector<int>ans;\\n        vector<long>parent(1000000,-1);\\n        \\n       \\n        long turn =1;\\n        long i=2;\\n        deque<long>dq;\\n        dq.push_back(1);\\n       while(i<=n){\\n            stack<long>st;\\n           long nodes=pow(2,count);\\n           long target=(i+nodes-1);\\n           i=nodes;\\n           if(turn==1){\\n               turn=1-turn;\\n               \\n               while(i<=target){\\n                   st.push(i);\\n                   i++;\\n\\n             \\n         }\\n         while(!st.empty()){\\n          \\n             long k=st.top();\\n             if(st.empty())\\n             break;\\n             st.pop();\\n             if(st.empty())\\n             break;\\n             long kk=st.top();\\n               if(st.empty())\\n               break;\\n             st.pop();\\n             if(dq.empty())\\n             break;\\nlong x=dq.front();\\ndq.pop_front();\\nparent[k]=x;\\nparent[kk]=x;\\ndq.push_back(k);\\ndq.push_back(kk);\\n         }\\n\\n               \\n               \\n           }\\n           else{\\n               turn=1-turn;\\n               while(i<=target){\\n                long kx=i;\\n                long kxx=i+1;\\n                i++;\\n                i++;\\n                if(dq.empty())\\n                break;\\n                parent[kx]=dq.front();\\n                parent[kxx]=dq.front();\\n                dq.pop_front();\\n                \\n                dq.push_back(kx);\\n                dq.push_back(kxx);\\n               }\\n           }\\n           count++;\\n       }\\n\\n    long kkk=n;\\n    while(parent[kkk]!=-1){\\n        ans.push_back(parent[kkk]);\\n        kkk=parent[kkk];\\n    }\\n \\n    reverse(ans.begin(),ans.end());\\n       ans.push_back(n);\\n        return ans;\\n    }\\n};\\n\\nI got Runtime error here... please help\\n\\n runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type \\'int\\', which requires 4 byte alignment (stl_deque.h)\\n0xbebebebebebec0ba: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16"
                    }
                ]
            }
        ]
    }
]